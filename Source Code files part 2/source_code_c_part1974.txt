
        static public long GetNotNullInt64(SqlDataReader dataReader, int ordinalIndex)
        {
            if (ordinalIndex < 0
                || dataReader.IsDBNull(ordinalIndex))
            {
                return 0;
            }

            return dataReader.GetInt64(ordinalIndex);
        }

        static public int GetNotNullInt32(SqlDataReader dataReader, int ordinalIndex)
        {
            if (ordinalIndex < 0
                || dataReader.IsDBNull(ordinalIndex))
            {
                return 0;
            }

            return dataReader.GetInt32(ordinalIndex);
        }

        static public decimal GetNotNullDecimal(SqlDataReader dataReader, int ordinalIndex)
        {
            if (ordinalIndex < 0
                || dataReader.IsDBNull(ordinalIndex))
            {
                return 0;
            }

            return dataReader.GetDecimal(ordinalIndex);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\Helpers\Interfaces.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Xml;

namespace xonline.server.catalogwatcher
{
    interface IElement
    {
        void WriteToXml(XmlWriter writer);
    }

    interface IType
    {
        bool Validate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\ZuneApp\ZuneAppConfigListener.cs ===
﻿using System;
using System.Diagnostics;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.sql.sqlclient;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// config listener class for ZuneDB related config changes
    /// </summary>
    public class ZuneAppConfigListener : IConfigListener, IDisposable
    {
        // The connection used to get the list of media ids which have changed SHOULD BE REUSED to get the actual documents
        private SqlClient _sqlReplicaClient = null;
        private string _producerInstanceName = null;
        private object _lock = new object();

        public SqlClient SqlZuneDBReplicaClient
        {
            get 
            {
                if (_sqlReplicaClient == null)
                {
                    lock (_lock)
                    {
                        if (_sqlReplicaClient == null)
                        {
                            // recreate the connection to the latest active Zune DB bank
                            _sqlReplicaClient = new SqlClient(ConfigUtil.FECatalogDBZuneAppsVirtualInterfaceInfo);
                        }
                    }
                }
                return _sqlReplicaClient;
            }
        }

        public ZuneAppConfigListener(string producerInstanceName)
        {
            _producerInstanceName = producerInstanceName;
        }

        // custom callback for value change of setting "zune_dvi_FECatalogDBZuneApps_active" which means A/B flipping happens
        public void SettingChange(ISettingChangeEventArgs e)
        {
            if (!e.Setting.Equals(Setting.zune_dvi_FECatalogDBZuneApps_active, StringComparison.OrdinalIgnoreCase))
            {
                return;
            }
            if (_sqlReplicaClient != null)
            {
                lock (_lock)
                {
                    if (_sqlReplicaClient != null)
                    {
                        // close the connection to the current passive bank
                        Xom.Log(XomAreaName.catalogwatcherlog, string.Format("{2}|active bank is changed from {0} to {1}, connection to the current passive bank will be closed", e.ValueOld, e.ValueNew, _producerInstanceName));
                        _sqlReplicaClient.Close();
                        _sqlReplicaClient = null;
                    }
                }
            }
        }

        // do nothing for other change APIs
        public void VirtualInterfaceChange(IVirtualInterfaceChangeEventArgs e)
        {
        }

        public void ServerListChange(IServerListChangeEventArgs e)
        {
        }

        public void InterfaceChange(IInterfaceChangeEventArgs e)
        {
        }

        public void InterfaceBucketChange(IInterfaceBucketChangeEventArgs e)
        {
        }

        public void VirtualInterfaceListChange(IVirtualInterfaceListChangeEventArgs e)
        {
        }

        public void MultiSettingChange(IMultiSettingChangeEventArgs e)
        {
        }

        public void GameConfigChange()
        {
        }

        public void XdelaySettingsChange()
        {
        }

        public void XrlMappingsChange()
        {
        }

        /// <summary>
        /// Cleanup our resources
        /// </summary>
        public void Dispose()
        {
            if (_sqlReplicaClient != null)
            {
                // dispose connection
                _sqlReplicaClient.Dispose();
                _sqlReplicaClient = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\ZuneApp\ZuneAppDocument.cs ===
// 
// CatalogWatcher.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Linq;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;

using xonline.common.config;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{    
    public class ZuneAppDocument: ILSNDocument
    {
        private static XmlWriterSettings s_XmlSettings = new XmlWriterSettings();

        static ZuneAppDocument()
        {
            s_XmlSettings.OmitXmlDeclaration = true;
            s_XmlSettings.Encoding = Encoding.UTF8; 
            // TODO: read encoding from configuration.
        }

        private MediaIdLcid _mediaIdLcid = null;
        private string _id = null;
        private object _document = null;

        public ZuneAppDocument(Guid mediaId, int lcid, LSN lsn)
            : this(mediaId, lcid, lsn, (int)ZuneAppVisibilityStatus.Live)
        {
        }

        public ZuneAppDocument(Guid mediaId, int lcid, LSN lsn, int visibilityStatus)
        {
            _mediaIdLcid = new MediaIdLcid(lsn, mediaId, lcid);
            _id = _mediaIdLcid.MediaId.ToString() + "_" + _mediaIdLcid.Lcid.ToString();
            VisibilityStatus = visibilityStatus;
        }

        // Properties which can only be set via the constructor
        #region ILSNDocument Members
        public LSN      LSN                             { get { return _mediaIdLcid.LSN; }}
        #endregion

        #region IWatcherDocument Members
        public string DocumentId                      
        { 
            get { return _id; }
        }

        public object Document 
        { 
            get 
            {
                if (_document == null)
                {
                    _document = this.GetXmlString();
                }
                return _document;
            } 
        }
        #endregion

        public MediaIdLcid MediaIdLcid                  { get { return _mediaIdLcid; } }

        /// <summary>
        /// status code of this doc:
        /// 1   unpublished
        /// 2   staging
        /// 3   live
        /// 4   withdrawn
        /// 5   deleted
        /// 6   beta
        /// </summary>
        public int VisibilityStatus { get; private set; }

        public string Publisher { get; set; }

        public int DownloadCount { get; set; }

        // Properties from Zune Entity
        public string Title { get; set; }

        public float Score { get; set; }

        public int Rank { get; set; }

        /// <summary>
        /// Visibility date of the item
        /// </summary>
        public DateTime VisibilityDate { get; set; }

        /// <summary>
        /// Additional strings from the database that should be indexed along with the item (keywords, artist name, etc)
        /// </summary>
        public string AdditionalIndexableStrings { get; set; }

        private string[] _clientTypeList= null;
        private string[] _storeList = null;

        public string[] ClientTypes
        {
            get { return _clientTypeList; }
        }

        public string[] Stores
        {
            get { return _storeList; }
        }

        public bool Visible
        {
            get
            {
                return (this.VisibilityStatus == (int)ZuneAppVisibilityStatus.Live);
            }
        }

        private static bool s_OrdinalsInitialized = false;
        // static fields to store the ordinal of fields returned from dbo.GetApplicationNamesByIds
        private static int s_Ordinal_MediaId = -1;
        private static int s_ordinal_Position = -1;
        private static int s_Ordinal_Title = -1;
        private static int s_Ordinal_VisibilityDate = -1;
        private static int s_Ordinal_Score = -1;
        private static int s_Ordinal_Publisher = -1;
        private static int s_Ordinal_DownloadCount = -1;
        private static int s_Ordinal_VisibilityStatusId = -1;
        private static int s_Ordinal_IndexableStrings = -1;
        private static int s_Ordinal_Offers = -1;

        public static ZuneAppDocument Create(SqlDataReader reader, IList<MediaIdLcid> mediaIdLcidList)
        {
            if (!s_OrdinalsInitialized)
            {
                // initialize static ordinal fields
                s_Ordinal_MediaId = reader.GetOrdinal("Id");
                s_ordinal_Position = reader.GetOrdinal("position");
                s_Ordinal_Title = reader.GetOrdinal("Title");
                s_Ordinal_VisibilityDate = reader.GetOrdinal("VisibilityDate");
                s_Ordinal_Score = reader.GetOrdinal("Score");
                s_Ordinal_Publisher = reader.GetOrdinal("Publisher");
                s_Ordinal_DownloadCount = reader.GetOrdinal("DownloadCount");
                s_Ordinal_VisibilityStatusId = reader.GetOrdinal("VisibilityStatusId");
                s_Ordinal_IndexableStrings = reader.GetOrdinal("IndexableStrings");
                s_Ordinal_Offers = reader.GetOrdinal("Offers");
                if (s_Ordinal_MediaId == -1
                    || s_ordinal_Position == -1
                    || s_Ordinal_Title == -1
                    || s_Ordinal_VisibilityDate == -1
                    || s_Ordinal_Score == -1
                    || s_Ordinal_Publisher == -1
                    || s_Ordinal_DownloadCount == -1
                    || s_Ordinal_VisibilityStatusId == -1
                    || s_Ordinal_IndexableStrings == -1
                    || s_Ordinal_Offers == -1)
                {
                    throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_OPERATION_ERROR,
                                                XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR,
                                                "internal error: can not get the expected columns from dbo.GetApplicationNamesByIds");
                }
                s_OrdinalsInitialized = true;
            }

            Guid mediaId;
            if (!DAL.TryGetGuid(reader, s_Ordinal_MediaId, out mediaId))
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_OPERATION_ERROR,
                                                XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR,
                                                "internal error: Media Id is NULL");
            }

            // get the position of current application which is returned by dbo.GetApplicationNamesByIds
            // this position is relative to the list of (MediaIds,lcids) tuples (ToDo List)
            int position = -1;
            if (!reader.IsDBNull(s_ordinal_Position))
            {
                position = reader.GetInt32(s_ordinal_Position);
            }
            if (position < 0 || position >= mediaIdLcidList.Count)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_OPERATION_ERROR,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR,
                    string.Format("internal error: the position of application id [{0}] is invalid.", mediaId)
                    );
            }

            // use position to get current pair of MediaId and Lcid from the list of (MediaIds,lcids) tuples (ToDo List)
            MediaIdLcid mediaIdLcid = mediaIdLcidList[position];            

            if(mediaIdLcid.MediaId != mediaId)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_OPERATION_ERROR,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR,
                    string.Format("internal error: the application id: [{0}] from tuple ToDo List does not match with the returned application id [{1}] from dbo.GetApplicationNamesByIds", mediaIdLcid.MediaId, mediaId)
                    );
            }

            ZuneAppDocument doc = new ZuneAppDocument(mediaId, mediaIdLcid.Lcid, mediaIdLcid.LSN);            
            // The value of Title, VisibilityDate and VisibilityStatus fields can't be NULL from DB reader
            try
            {
                doc.Title = reader.GetString(s_Ordinal_Title);
                doc.VisibilityDate = reader.GetDateTime(s_Ordinal_VisibilityDate);
                doc.VisibilityStatus = reader.GetInt32(s_Ordinal_VisibilityStatusId);
            }
            catch (System.Data.SqlTypes.SqlNullValueException ex)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_OPERATION_ERROR,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR,
                    "internal error: there should not be any NULL value in Title, VisibilityDate or VisibilityStatus fields returned from dbo.GetApplicationNamesByIds",
                    ex
                    );
            }

            doc.Score = (float)DAL.GetNotNullDecimal(reader, s_Ordinal_Score);
            doc.DownloadCount = (int)DAL.GetNotNullInt64(reader, s_Ordinal_DownloadCount);
            doc.Publisher = DAL.GetNonNullString(reader, s_Ordinal_Publisher);
            doc.AdditionalIndexableStrings = DAL.GetNonNullString(reader, s_Ordinal_IndexableStrings);

            // get offer detail info
            string offerDetailXml = DAL.GetNonNullString(reader, s_Ordinal_Offers);
            if(!string.IsNullOrEmpty(offerDetailXml))
            {
                doc.InitOfferDetailInfo(offerDetailXml);
            }

            return doc;
        }

        private void InitOfferDetailInfo(string offerDetailXml)
        {
            HashSet<string> storeSet = new HashSet<string>();
            HashSet<string> clientTypeSet = new HashSet<string>();
            using (var ms = new System.IO.MemoryStream(Encoding.UTF8.GetBytes(offerDetailXml)))
            {
                System.Data.SqlTypes.SqlXml sqlXml = new System.Data.SqlTypes.SqlXml(ms);
                string key = string.Empty;
                using (XmlReader xmlReader = sqlXml.CreateReader())
                {
                    while (xmlReader.Read())
                    {
                        if (xmlReader.IsStartElement("OfferInstance")
                            && xmlReader.MoveToAttribute("Store")
                            && xmlReader.ReadAttributeValue())
                        {
                            key = xmlReader.Value.Trim();
                            if (!string.IsNullOrEmpty(key))
                            {
                                storeSet.Add(key);
                            }
                        }
                        else if (xmlReader.IsStartElement("ClientType")
                            && xmlReader.MoveToAttribute("ClientType")
                            && xmlReader.ReadAttributeValue())
                        {
                            key = xmlReader.Value.Trim();
                            if (!string.IsNullOrEmpty(key))
                            {
                                clientTypeSet.Add(key);
                            }
                        }
                    }
                }
            }
            _storeList = storeSet.ToArray();
            _clientTypeList = clientTypeSet.ToArray();
        }

        private string GetXmlString()
        {
            StringBuilder sb = new StringBuilder();
            using (XmlWriter writer = XmlWriter.Create(sb, s_XmlSettings))
            {
                writer.WriteStartElement("Application");

                XmlUtility.WriteElement(writer, "applicationid", this.DocumentId);
                XmlUtility.WriteNonEmptyStringElement(writer, "searchtitle", this.Title.ToString());
                XmlUtility.WriteNonEmptyStringElement(writer, "zunescore", this.Score.ToString());
                XmlUtility.WriteNonEmptyStringElement(writer, "visibilitydate", this.VisibilityDate.ToString());
                XmlUtility.WriteNonEmptyStringElement(writer, "keywords", this.AdditionalIndexableStrings);
                XmlUtility.WriteNonEmptyStringElement(writer, "publisher", this.Publisher);
                XmlUtility.WriteNonEmptyStringElement(writer, "downloadcount", this.DownloadCount.ToString());
                XmlUtility.WriteNonEmptyStringElement(writer, "visible", this.Visible ? "1" : "0");
                XmlUtility.WriteNonEmptyStringElement(writer, "clienttype", string.Join(";", this.ClientTypes));
                XmlUtility.WriteNonEmptyStringElement(writer, "storetype", string.Join(";", this.Stores));

                writer.WriteEndElement();
            }
            return sb.ToString();
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\ZuneApp\ZuneAppEnums.cs ===
﻿using System;

namespace xonline.server.catalogwatcher
{
    public enum ZuneAppVisibilityStatus
    {
        Unpublished = 1,
        Staging = 2,
        Live = 3,
        Withdrawn = 4,
        Deleted = 5,
        Beta = 6
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\Helpers\XmlUtility.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.IO;
using System.Xml;

namespace xonline.server.catalogwatcher
{
    static class XmlUtility
    {
        public const string IEBNamespace = "http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion";
        public const string DateTimeFormat = "yyyy-MM-ddTHH:mm:ssZ";

        public static bool Validate(object obj)
        {
            if (obj is IType)
                return (null != obj && ((IType)obj).Validate());
            else
                return (null != obj);
        }

        static public void WriteElement(XmlWriter writer, string elementName, string elementValue)
        {
            writer.WriteStartElement(elementName);
            writer.WriteValue(elementValue);
            writer.WriteEndElement();
        }

        static public void WriteNullableElement(XmlWriter writer, string elementName, object elementValue)
        {
            if (null == elementValue)
            {
                WriteNullElement(writer, elementName);
            }
            else
            {
                WriteElement(writer, elementName, elementValue.ToString());
            }
        }

        static public void WriteNonEmptyStringElement(XmlWriter writer, string elementName, string elementValue)
        {
            if (!string.IsNullOrEmpty(elementValue))
            {
                WriteElement(writer, elementName, elementValue);
            }
        }

        // place holder
        static public void WriteNullElement(XmlWriter writer, string elementName)
        {
            writer.WriteElementString(elementName, String.Empty);
        }

        static public void WriteCollection<T>(XmlWriter writer, string collectionName, IEnumerable<T> collection, bool alwaysWriteRootTag)
            where T : IElement
        {
            if (null != collection && collection.Count<T>() > 0)
            {
                writer.WriteStartElement(collectionName);
                foreach (T element in collection)
                {
                    element.WriteToXml(writer);
                }
                writer.WriteEndElement();
            }
            else if (alwaysWriteRootTag)
            {
                XmlUtility.WriteNullElement(writer, collectionName);
            }
        }

        static public void WriteToXmlSafe<T>(XmlWriter writer, T element)
            where T : IElement
        {
            if (null != element)
            {
                element.WriteToXml(writer);
            }
        }

        static public String GetInnerXml(string data, ProductType type)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(data);
            if (type == ProductType.MovieTrailer)
                type = ProductType.Movie;

            return doc.SelectSingleNode(type.ToString()).OuterXml;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\ZuneApp\ZuneAppDocumentProducer.cs ===
// 
// ZuneAppDocumentProducer.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;
using System.Threading;
using System.Linq;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;
using xonline.common.utilities;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// The producer for Zune Application documents
    /// </summary>
    /// <remarks>
    /// A 'watcher' can have multiple instances, where each watcher instantiates a separate instance of 
    /// a ZuneAppDocumentProducer. This allows for the load of document production to be distributed across
    /// both a set of CRON machines and (most importantly) a set of catalog replicas. Distribution occurs
    /// by sequentially numbering each instance, starting at zero. Each instance then uses this number to
    /// perform hashing on each document identifier to determine if it is responsible for processing that
    /// id.
    /// 
    /// Since different replicas may be out of sync (one replica may be behind in terms of not having the
    /// latest set of changes - potentially hours behind). Hence when the list of ids needing processing
    /// is retrieved, the corresponding document retrieval needs to come from the exact same replica. If
    /// the id list were retrieved from an uptodate replica but the document is retrieved from a replica
    /// that is behind, then the document pushed to ESP would consist of OLD data. This instance would then
    /// mark the LSN as having been completed and the new document information will never be pushed to ESP.
    /// By hitting the same replica, the ToDo table and document tables will be in sync - if the updated
    /// document info is not on the replica, the LSN would not exist in the ToDo table.
    /// 
    /// The ZuneAppDocumentProducer works in the following manner:
    /// 
    /// Firstly, Init() is called passing in this instances identifier called the bucketId as well as
    /// the total number of instances (numBuckets). The init method then retrieves the last LSN which
    /// it is gaurenteed to have processed - this comes from npdb. It then connects to a replica and
    /// retrieves all mediaId, lcid tuples from the 'ToDo' table, storing them in a list called '_detectedIds'.
    /// It also stores the connection to that replica which it will use when retrieveing the documents,
    /// ensuring that ids and documents come from a single source.
    /// 
    /// The method GetNextBatchOfDocuments() is then called repeatedly, passing in the number of documents
    /// to be generated. Each time the method is called the 'next' set of documents is generated. The list
    /// '_detectedIds' is used as the master list of all ids for which documents need to be produced. The
    /// instance variable '_overallPosition' is used to keep track of where in this list we have got on
    /// each iteration of the method being called.
    /// 
    /// The list '_detectedIds' is, in case of error, never initialised or reset to null - this provides
    /// a simple check that can be made each time the public methods are called to make sure that the
    /// class is in a good state.
    /// </remarks>
    public class ZuneAppDocumentProducer : IWatcherDocumentProducer
    {
        private List<MediaIdLcid> _detectedIds = null;          // The list of (MediaIds,lcids) tuples to generate documents for and is grouped by lcid

        private int _overallPosition = 0;                   // maintain the poistion in the '_detectedIds' list.
        private int _bucketId = -1;                         // this instances bucket id
        private int _numBuckets = -1;                       // total number of buckets
        private string _instanceName = String.Empty;        // the name for this MediaDocumentProducer instance - used for logging, exceptions

        private ZuneAppConfigListener _zuneAppConfigListener = null;    // custom config listener for changes of Zune DB Virtual Interface value

        /// <summary>
        /// Connection to the Replica DB; this connection will be used by Detector and the Extractor
        /// </summary>
        private SqlClient SqlZuneDBReplicaClient
        {
            get
            {
                if (_zuneAppConfigListener != null)
                {
                    return _zuneAppConfigListener.SqlZuneDBReplicaClient;
                }
                throw new InvalidOperationException("Should access this property after calling Init() method!");
            }
        }
        /// <summary>
        /// Returns the name of this producer instance
        /// </summary>
        public String InstanceName
        {
            get { return _instanceName; }
        }

        public WorkerReport Report
        {
            get;
            set;
        }

        /// <summary>
        /// Initialize the Producer
        /// </summary>        
        public void Init(int bucketId, int numBuckets)
        {
            if (bucketId < 0)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                String.Format("ZuneAppDocumentProducer initialized with invalid parameter value for 'BucketId'. Value should be greater than or equal to zero. Value is {0}", bucketId));
            }
            if (numBuckets <= 0)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                String.Format("ZuneAppDocumentProducer initialized with invalid parameter value for 'Number of Buckets'. Value should be greater than zero. Value is {0}", numBuckets));
            }
            if (bucketId >= numBuckets)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                String.Format("ZuneAppDocumentProducer initialized with invalid parameter values. BucketId is not less than Number of Buckets. BucketId is {0}. Number of Buckets is {1}", bucketId, numBuckets));
            }
            _bucketId = bucketId;
            _numBuckets = numBuckets;
            _instanceName = String.Format("CatalogWatcher|Producer|{0}|{1}|{2:D3}", Constants.ZuneApp_ResourceName, Constants.ZuneApp_DestinationName, bucketId); 

            // Create a config listener which contains connection to an Zune Application DB replica
            _zuneAppConfigListener = new ZuneAppConfigListener(_instanceName);

            // apply this config listener
            ConfigInterop configInterop = new ConfigInterop();
            configInterop.ConfigListener = _zuneAppConfigListener;      
            
            // Reset/zero certain counters
            DetectorCounters.Counters[_instanceName].DetectedIdsCount.RawValue = 0;
            ExtractorCounters.Counters[_instanceName].CallsTotal.RawValue = 0;

            // Get the set of ids for which this watcher instance needs to produce documents.
            GetMediaLCIDsFromToDo();

            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Initialized", _instanceName));
        }

        /// <summary>
        /// Get the Maximum Batch Size for the Extractor
        /// </summary>
        public int GetMaxBatchSize()
        {
            return Config.GetIntSetting(Setting.zunedb_catalogwatcher_extractor_batch_size);
        }

        /// <summary>
        /// This function reads the LSN value from the CatalogWatcherStatus table in the npdb
        /// </summary>
        private LSN GetLastProcessedLSN()
        {
            LSN retVal = null;
            // Open a connection to the front door
            using (SqlClient sqlClient = new SqlClient(Interface.npdb))
            {
                sqlClient.AddParameter("@i_bucket_id", _bucketId);
                sqlClient.AddParameter("@vc_destination_name", Constants.ZuneApp_DestinationName);
                sqlClient.AddParameter("@vc_resource_name", Constants.ZuneApp_ResourceName);
                sqlClient.StoredProc = "dbo.p_catalog_watcher_get_last_lsn";

                using (SqlDataReader r = sqlClient.Execute())
                {
                    if (r.Read())
                    {
                        byte[] lsn = r.GetSqlBinary(r.GetOrdinal("lsn")).Value;
                        byte[] seq = r.GetSqlBinary(r.GetOrdinal("seq")).Value;
                        retVal = new LSN(lsn, seq);
                    }
                }
            }
            return retVal;
        }

        private static bool s_InitializedOrdinalForToDoSP = false;
        private static int s_lcidOrdinalForToDoSP = -1;
        private static int s_mediaIdOrdinalForToDoSP = -1;
        private static int s_lsnOrdinalForToDoSP = -1;
        private static int s_seqOrdinalForToDoSP = -1;

        /// <summary>
        /// Return all the mediaId, lcids from the the ToDo table using the passed in connection to the Replica
        /// </summary>
        private void GetMediaLCIDsFromToDo()
        {
            _detectedIds = new List<MediaIdLcid>(100);

            Dictionary<int, List<MediaIdLcid>> detectedIdsDic = new Dictionary<int, List<MediaIdLcid>>();
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            LSN lastProcessedLSN = GetLastProcessedLSN();

            SqlZuneDBReplicaClient.ClearParameters();
            SqlZuneDBReplicaClient.StoredProc = "dbo.CatalogDBZuneAppsWatcherToDoGet";
            SqlZuneDBReplicaClient.AddParameter("@lsn", lastProcessedLSN.Lsn);
            SqlZuneDBReplicaClient.AddParameter("@seq", lastProcessedLSN.Seq);
            using (SqlDataReader r = SqlZuneDBReplicaClient.Execute())
            {
                while (r.Read())
                {
                    if (!s_InitializedOrdinalForToDoSP)
                    {
                        s_mediaIdOrdinalForToDoSP = r.GetOrdinal("mediaId");
                        s_lcidOrdinalForToDoSP = r.GetOrdinal("lcid");
                        s_lsnOrdinalForToDoSP = r.GetOrdinal("lsn");
                        s_seqOrdinalForToDoSP = r.GetOrdinal("seq");
                        if (s_mediaIdOrdinalForToDoSP == -1
                            || s_lsnOrdinalForToDoSP == -1
                            || s_seqOrdinalForToDoSP == -1)
                        {
                            throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_OPERATION_ERROR,
                                                XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR,
                                                "can not get the expected columns from Sproc");
                        }
                        s_InitializedOrdinalForToDoSP = true;
                    }
                    Guid mediaId = r.GetGuid(s_mediaIdOrdinalForToDoSP);
                    if (Math.Abs(mediaId.GetHashCode()) % _numBuckets == _bucketId)
                    {
                        int lcid = r.GetInt32(s_lcidOrdinalForToDoSP);
                        byte[] lsn = r.GetSqlBinary(s_lsnOrdinalForToDoSP).Value;
                        Debug.Assert(lsn.Length == 10);
                        byte[] seq = r.GetSqlBinary(s_seqOrdinalForToDoSP).Value;
                        Debug.Assert(seq.Length == 10);
                        MediaIdLcid mediaLcid = new MediaIdLcid(new LSN(lsn, seq), mediaId, lcid);
                        _detectedIds.Add(mediaLcid);
                    }
                }
            }

            DetectorCounters.Counters[_instanceName].AverageExecutionTime.IncrementBy(timeElapsed.TimeElapsed);
            DetectorCounters.Counters[_instanceName].AverageExecutionTimeBase.Increment();
            DetectorCounters.Counters[_instanceName].DetectedIdsCount.IncrementBy(_detectedIds.Count);

            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{1}|Detected {0} ids for document production", _detectedIds.Count, _instanceName));
        }

        /// <summary>
        /// This method generates documents for each mediaId, Lcid pair
        /// </summary>
        public IEnumerable<IWatcherDocument> GetNextBatchOfDocuments(int batchSize)
        {
            // Validation. Check that a valid batchSizeis passed in. Also verify that the
            // list '_detectedIds' is not null - a value of null indicates that this instance
            // has either not been initialized correctly or is in an invalid state caused by
            // some previous exception.
            if (batchSize <= 0)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_GENERATE_DOCUMENTS_INVALID_COUNT,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                    String.Format("BatchSize for GetNextBatchOfDocuments must be greater than zero. Current value: {0}", batchSize));
            }
            if (_detectedIds == null)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_PRODUCER_INVALID_STATE,
                XEvent.Id.ZUNEDB_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                "GetNextBatchOfDocuments invoked either without initializing the class instance or after an exception has occurred");
            }

            List<IWatcherDocument> documents = new List<IWatcherDocument>();

            //If there are no IDs detected to generate documents for, no work to do.
            if (_detectedIds.Count != 0)
            {
                int actualBatchSize = 0;
                try
                {
                    SqlZuneDBReplicaClient.ClearParameters();
                    SqlZuneDBReplicaClient.StoredProc = "dbo.GetApplicationNamesByIds";

                    SqlZuneDBReplicaClient.AddParameter("@instant", DateTime.UtcNow);

                    DataTable table = new DataTable();
                    table.Columns.Add(new DataColumn("mediaId", typeof(Guid)));
                    table.Columns.Add(new DataColumn("lcid", typeof(int)));
                    table.Columns.Add(new DataColumn("position", typeof(int)));

                    for (int currentBatchCount = 0;
                        ((currentBatchCount < batchSize) && (_overallPosition < _detectedIds.Count));
                        currentBatchCount++, _overallPosition++)
                    {
                        table.Rows.Add(new Object[] {
                                                    _detectedIds[_overallPosition].MediaId,
                                                    _detectedIds[_overallPosition].Lcid,
                                                    _overallPosition });
                    }
                    SqlParameter mediaIdLcidsToProcess = SqlZuneDBReplicaClient.Command.Parameters.AddWithValue("@mediaIdLcidTuples", table);
                    mediaIdLcidsToProcess.SqlDbType = SqlDbType.Structured;
                    mediaIdLcidsToProcess.TypeName = "dbo.OrderedMediaIdLcidTuples";

                    SqlZuneDBReplicaClient.Command.CommandTimeout = Config.GetIntSetting(Setting.zunedb_catalogwatcher_extractor_timeout_in_secs);

                    // Execute the command against the latest replica bank.
                    // This ensures that we will not hit a old replica bank for the document information, where that
                    // replica is behind (e.g. replication has stopped). If this were to happen, we would publish
                    // old data, mark the LSN as completed and then not publish the new data.
                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                    using (SqlDataReader r = SqlZuneDBReplicaClient.Execute())
                    {
                        while (r.Read())
                        {
                            ZuneAppDocument doc = ZuneAppDocument.Create(r, _detectedIds);
                            documents.Add(doc);
                            actualBatchSize++;
                        }
                    }
                    // Bookkeeping
                    ExtractorCounters.Counters[_instanceName].AverageExecutionTime.IncrementBy(timeElapsed.TimeElapsed);
                    ExtractorCounters.Counters[_instanceName].AverageExecutionTimeBase.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsPerSecond.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsTotal.Increment();
                    ExtractorCounters.Counters[_instanceName].AverageBatchSize.IncrementBy(actualBatchSize);
                    ExtractorCounters.Counters[_instanceName].AverageBatchSizeBase.Increment();
                }
                catch (Exception e)
                {
                    ExtractorCounters.Counters[_instanceName].CallsFailedPerSecond.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsFailedTotal.Increment();

                    // An error has been encountered. We set the list of detected ids to be null
                    // to prevent any more processing happening.
                    _detectedIds = null;

                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("Exception {0}", e));
                    throw e;
                }
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Processed {1} of total {2} ids.", _instanceName, actualBatchSize, _detectedIds.Count));
            }
            return documents;
        }

        /// <summary>
        /// Returns the max queue size for the documents queue for the zune application documents
        /// </summary>
        public int GetMaxQueueLength()
        {
            return Config.GetIntSetting(Setting.zunedb_catalogwatcher_producer_consumer_zuneapp_max_queue_size);
        }

        /// <summary>
        /// Cleanup our resources
        /// </summary>
        public void Dispose()
        {
            if (_zuneAppConfigListener != null)
            {
                // detach config listener
                ConfigInterop configInterop = new ConfigInterop();
                configInterop.ConfigListener = null; 
                // dispose listener
                _zuneAppConfigListener.Dispose();
                _zuneAppConfigListener = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\CDCTests.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Diagnostics;

using Marketplace.Test.Common.Service;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("wirosas"), TestFrequency("Daily"), EnvRequirement("xblobonly")]
    public class CDCTests
    {
        [TestGroupSetup]
        public void Setup()
        {

        }

        [TestGroupTearDown]
        public void Shutdown() { }

        [TestCase, TestCasePriority(1)]
        class CDC_Standard_BVT_Media : WatcherTestsBase
        {
            public CDC_Standard_BVT_Media() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //Before we start, clear the CDC Media table and destination ToDoProduct table
                Catalog.ExecuteNonQuery(SQLDisableTransferJob());
                Catalog.StopTransferJob();
                Catalog.WaitForTransferJobIdle(); //even though disabled, wait for it to stop executing (if it's already running)
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMedia());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMediaUserRatingAggregate());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCUsageAggregateFromReporting());
                Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                Catalog.ExecuteNonQuery(SQLEnableTransferJob());
                //Get the top 10 mediaIds from the Media table
                List< string > mediaIds = Catalog.ExecuteQueryGetSingleColumn(QuerySelectTopMediaIdsFromMedia());

                //get count of rows for our mediaIds in the CDC Media before we update.  Should be 0.
                int cdcBeforeUpdate = Catalog.ExecuteQueryGetSingleInt(GetCountMediasFromCDCMedia(mediaIds));
                
                //Get count in the dest table before update/transfer job
                int destTableCountBefore = Catalog.ExecuteQueryGetSingleInt(GetCountUniqueMediasFromToDoProducts(mediaIds));

                //Update the modified date on those top Medias
                Global.RO.Info("Update rows in Media...");
                Catalog.ExecuteNonQuery(UpdateMediaModifiedDate(mediaIds));

                //Give CDC time to catch the changes and move them to the CDC table
                Global.RO.Info("Give CDC time to pick up the changes (10 seconds)...");
                WaitSeconds(10);

                //get count of rows for our mediaIds in the CDC Media after we update. 
                //Exact number of rows TBD, if even possible.
                int cdcAfterUpdate = Catalog.ExecuteQueryGetSingleInt(GetCountMediasFromCDCMedia(mediaIds));
                Global.RO.Info(string.Format("Selected MediaIds in CDC before the update: {0}", cdcBeforeUpdate));
                Global.RO.Info(string.Format("Selected MediaIds in CDC after the update: {0}", cdcAfterUpdate));
                Global.RO.Info(string.Format("CDC Table Difference: {0}", cdcAfterUpdate - cdcBeforeUpdate));

                //Compare before vs. after count.
                if (cdcBeforeUpdate >= cdcAfterUpdate)
                {
                    Global.RO.Info("CDC failed to catch changes!");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                
                //Give Transfer job time to wake up and move the changes to the table
                Global.RO.Info("Give the transfer job time to run (62 seconds)...");
                WaitSeconds(62);

                //Check Destination table for records
                int destTableCountAfter = Catalog.ExecuteQueryGetSingleInt(SQLCountMediasFromToDoProducts(mediaIds));
                int destTableUniqueMediaId = Catalog.ExecuteQueryGetSingleInt(GetCountUniqueMediasFromToDoProducts(mediaIds));

                Global.RO.Info(string.Format("Dest Table Before: {0}", destTableCountBefore));
                Global.RO.Info(string.Format("Dest Table After: {0}", destTableCountAfter));
                Global.RO.Info(string.Format("Dest Table Difference: {0}", destTableCountAfter - destTableCountBefore));
                Global.RO.Info(string.Format("Unique MediaIds in Dest: {0}", destTableUniqueMediaId));

                //The transfer amount between cdc tables is twice that of the difference between dest tables.
                //CDC adds two rows for every update (a 'before' and 'after' row), and just one row for an insert.
                //The dest table copies just the 'after' row.
                if ((cdcAfterUpdate <= cdcBeforeUpdate) && (destTableCountAfter <= destTableCountBefore))
                {
                    Global.RO.Info("Transfer Job didn't transfer the CDC rows properly.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Transfer job completed successfully.");
                }

                Catalog.CloseConnection();
            }           
        }


        [TestCase, TestCasePriority(1)]
        class CDC_Standard_BVT_MediaUserRatingAggregate : WatcherTestsBase
        {
            public CDC_Standard_BVT_MediaUserRatingAggregate() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //Before we start, clear the CDC Media table and destination ToDoProduct table
                Catalog.ExecuteNonQuery(SQLDisableTransferJob());
                Catalog.StopTransferJob();
                Catalog.WaitForTransferJobIdle(); //even though disabled, wait for it to stop executing (if it's already running)
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMedia());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMediaUserRatingAggregate());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCUsageAggregateFromReporting());
                Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                Catalog.ExecuteNonQuery(SQLEnableTransferJob());

                //Get the top 10 mediaIds from the Media table
                List< string > mediaIds = Catalog.ExecuteQueryGetSingleColumn(QuerySelectTopMediaIdsFromMedia());

                //get count of rows for our mediaIds in the CDC Media before we update.  Should be 0.
                int cdcBeforeUpdate = Catalog.ExecuteQueryGetSingleInt(GetTotalCountMediasFromCDCMediaUserRatingAggregate(mediaIds));

                //Get the count in the dest table before the update/transfer job
                int destTableCountBefore = Catalog.ExecuteQueryGetSingleInt(GetTotalCountMediasFromToDoProducts(mediaIds));

                //Update the modified date on those top Medias
                Global.RO.Info("Insert/Update rows in MediaUserRatingAggregate...");
                Catalog.ExecuteNonQuery(UpdateMediasInMediaUserRatingAggregate(mediaIds));


                //Give CDC time to catch the changes
                Global.RO.Info("Give CDC time to run (10 seconds)...");
                WaitSeconds(10);

                //get count of rows for our mediaIds in the CDC Media after we update. Exact number of rows TBD, if even possible.
                int cdcAfterUpdate = Catalog.ExecuteQueryGetSingleInt(GetTotalCountMediasFromCDCMediaUserRatingAggregate(mediaIds));

                Global.RO.Info(string.Format("Selected MediaIds in CDC before the update: {0}", cdcBeforeUpdate));
                Global.RO.Info(string.Format("Selected MediaIds in CDC after the update: {0}", cdcAfterUpdate));
                Global.RO.Info(string.Format("CDC Table Difference: {0}", cdcAfterUpdate - cdcBeforeUpdate));

                //Compare before vs. after count.
                if (cdcBeforeUpdate >= cdcAfterUpdate)
                {
                    Global.RO.Info("CDC failed to catch changes!");
                    ResultCode = TEST_RESULTS.FAILED;
                }


                //Give Transfer job time to wake up and move the changes to the table
                Global.RO.Info("Give the transfer job time to run (62 seconds)...");
                WaitSeconds(62);

                //Check Destination table for records
                int destTableCountAfter = Catalog.ExecuteQueryGetSingleInt(GetTotalCountMediasFromCDCMediaUserRatingAggregate(mediaIds));
                int destTableUniqueMediaId = Catalog.ExecuteQueryGetSingleInt(GetCountMediasFromCDCMediaUserRatingAggregate(mediaIds));

                Global.RO.Info(string.Format("Dest Table Before: {0}", destTableCountBefore));
                Global.RO.Info(string.Format("Dest Table After: {0}", destTableCountAfter));
                Global.RO.Info(string.Format("Dest Table Difference: {0}", destTableCountAfter - destTableCountBefore));
                Global.RO.Info(string.Format("Unique MediaIds in Dest: {0}", destTableUniqueMediaId));

                if ((cdcAfterUpdate <= cdcBeforeUpdate) && (destTableCountAfter <= destTableCountBefore))
                {
                    Global.RO.Info("Transfer Job didn't transfer the CDC rows properly.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Transfer job completed successfully.");
                }

                Catalog.CloseConnection();
            }

            #region SqlStrings

            private string UpdateMediasInMediaUserRatingAggregate(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("IF EXISTS(SELECT 1 FROM dbo.MediaUserRatingAggregate WHERE mediaId='{0}')\n", mediaId);
                    sb.AppendFormat("UPDATE dbo.MediaUserRatingAggregate SET modifiedDate=GETDATE() WHERE mediaId = '{0}'\n", mediaId);
                    sb.AppendFormat("ELSE\n");
                    sb.AppendFormat("INSERT INTO dbo.MediaUserRatingAggregate VALUES ('{0}', 'US', 5.0, 100, GETDATE(), GETDATE())\n", mediaId);
                    sb.Append("\n");
                }

                return sb.ToString();
            }

            private string GetCountMediasFromCDCMediaUserRatingAggregate(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("SELECT COUNT(DISTINCT(mediaId)) FROM cdc.dbo_MediaUserRatingAggregate_CT WHERE ");
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("mediaId='{0}' OR ", mediaId);
                }
                sb.Remove(sb.Length - 3, 3); //remove the last OR

                return sb.ToString();
            }

            private string GetTotalCountMediasFromCDCMediaUserRatingAggregate(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("SELECT COUNT(mediaId) FROM cdc.dbo_MediaUserRatingAggregate_CT WHERE ");
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("mediaId='{0}' OR ", mediaId);
                }
                sb.Remove(sb.Length - 3, 3); //remove the last OR

                return sb.ToString();
            }

            private string GetCountMediasFromToDoProducts(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("SELECT COUNT(DISTINCT(mediaId)) FROM dbo.CatalogWatcherToDoProduct WHERE ");
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("mediaId='{0}' OR ", mediaId);
                }
                sb.Remove(sb.Length - 3, 3); //remove the last OR

                return sb.ToString();
            }

            private string GetTotalCountMediasFromToDoProducts(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("SELECT COUNT(mediaId) FROM dbo.CatalogWatcherToDoProduct WHERE ");
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("mediaId='{0}' OR ", mediaId);
                }
                sb.Remove(sb.Length - 3, 3); //remove the last OR

                return sb.ToString();
            }

            #endregion
        }


        [TestCase, TestCasePriority(1)]
        class CDC_Standard_BVT_UsageAggregateFromReporting : WatcherTestsBase
        {
            public CDC_Standard_BVT_UsageAggregateFromReporting() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //Before we start, clear the CDC Media table and destination ToDoProduct table
                Catalog.ExecuteNonQuery(SQLDisableTransferJob());
                Catalog.StopTransferJob();
                Catalog.WaitForTransferJobIdle(); //even though disabled, wait for it to stop executing (if it's already running)
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMedia());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMediaUserRatingAggregate());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCUsageAggregateFromReporting());
                Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                Catalog.ExecuteNonQuery(SQLEnableTransferJob());

                //Get the top 10 mediaIds from the Media table
                List<string> mediaIds = Catalog.ExecuteQueryGetSingleColumn(QuerySelectTopMediaIdsFromMedia());

                //get count of rows for our mediaIds in the CDC UsageAggregateFromReporting before we update.  Should be 0.
                int cdcBeforeUpdate = Catalog.ExecuteQueryGetSingleInt(GetCountMediasFromCDUsageAggregateFromReporting(mediaIds));

                //Get dest table count before update/transfer job
                int destTableCountBefore = Catalog.ExecuteQueryGetSingleInt(GetCountMediasFromCDUsageAggregateFromReporting(mediaIds));

                //Update the modified date on those top Medias
                Global.RO.Info("Make changes to UsageAggregateFromReporting...");
                Catalog.ExecuteNonQuery(UpdateRowIdsInUsageAggregateFromReporting(mediaIds));

                //Give CDC time to pick up the changes and move them to the CDC table
                Global.RO.Info("Give CDC time to pick up the changes");
                WaitSeconds(10);

                //get count of rows for our mediaIds in the CDC Media after we update. Exact number of rows TBD, if even possible.
                int cdcAfterUpdate = Catalog.ExecuteQueryGetSingleInt(GetCountMediasFromCDUsageAggregateFromReporting(mediaIds));

                Global.RO.Info(string.Format("Selected MediaIds in CDC before the update: {0}", cdcBeforeUpdate));
                Global.RO.Info(string.Format("Selected MediaIds in CDC after the update: {0}", cdcAfterUpdate));
                Global.RO.Info(string.Format("CDC Table Difference: {0}", cdcAfterUpdate - cdcBeforeUpdate));

                //Compare before vs. after count.
                if (cdcBeforeUpdate >= cdcAfterUpdate)
                {
                    Global.RO.Info("CDC failed to catch changes!");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                //Give Transfer job time to wake up and move the changes to the table
                Global.RO.Info("Give Transfer job time to run (62 seconds)...");
                WaitSeconds(62);

                //Check Destination table for records
                int destTableCountAfter = Catalog.ExecuteQueryGetSingleInt(GetCountMediasFromCDUsageAggregateFromReporting(mediaIds));
                int destTableUniqueMediaId = Catalog.ExecuteQueryGetSingleInt(GetTotalCountMediasFromToDoProducts(mediaIds));

                Global.RO.Info(string.Format("Dest Table Before: {0}", destTableCountBefore));
                Global.RO.Info(string.Format("Dest Table After: {0}", destTableCountAfter));
                Global.RO.Info(string.Format("Dest Table Difference: {0}", destTableCountAfter - destTableCountBefore));
                Global.RO.Info(string.Format("Unique MediaIds in Dest: {0}", destTableUniqueMediaId));

                if ((cdcAfterUpdate <= cdcBeforeUpdate) && (destTableCountAfter <= destTableCountBefore))
                {
                    Global.RO.Info("Transfer Job didn't transfer the CDC rows properly.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Transfer job competed successfully");
                }

                Catalog.CloseConnection();
            }

            #region SqlStrings

            private string UpdateRowIdsInUsageAggregateFromReporting(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("IF EXISTS(SELECT 1 FROM dbo.UsageAggregateFromReporting WHERE rowId='{0}')\n", mediaId);
                    sb.AppendFormat("UPDATE dbo.UsageAggregateFromReporting SET modifiedDate=GETDATE() WHERE rowId = '{0}'\n", mediaId);
                    sb.AppendFormat("ELSE\n");
                    sb.AppendFormat("INSERT INTO dbo.UsageAggregateFromReporting VALUES ('{0}', 22, '{0}', '{0}', 'US', 100, GETDATE(), GETDATE())\n", mediaId);
                    sb.Append("\n");
                }

                return sb.ToString();
            }

            private string GetCountMediasFromCDUsageAggregateFromReporting(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("SELECT COUNT(DISTINCT(rowId)) FROM cdc.dbo_UsageAggregateFromReporting_CT WHERE ");
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("rowId='{0}' OR ", mediaId);
                }
                sb.Remove(sb.Length - 3, 3); //remove the last OR

                return sb.ToString();
            }

            private string GetCountMediasFromToDoProducts(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("SELECT COUNT(DISTINCT(mediaId)) FROM dbo.CatalogWatcherToDoProduct WHERE ");
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("mediaId='{0}' OR ", mediaId);
                }
                sb.Remove(sb.Length - 3, 3); //remove the last OR

                return sb.ToString();
            }

            private string GetTotalCountMediasFromToDoProducts(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("SELECT COUNT(mediaId) FROM dbo.CatalogWatcherToDoProduct WHERE ");
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("mediaId='{0}' OR ", mediaId);
                }
                sb.Remove(sb.Length - 3, 3); //remove the last OR

                return sb.ToString();
            }

            #endregion
        }


        [TestCase, TestCasePriority(1)]
        class CDC_CDC_Enabled : WatcherTestsBase
        {
            public CDC_CDC_Enabled() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("Querying for CDC Status on RawCatalogDB...");

                string cdcEnabled = Catalog.ExecuteQueryGetSingle("SELECT is_cdc_enabled FROM sys.databases WHERE name='RawCatalogDB'");

                Global.RO.Info(string.Format("CDC Enabled Value: {0}", cdcEnabled));

                if (cdcEnabled != "True")
                {
                    Global.RO.Info("CDC is not enabled on RawCatalogDB!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("CDC is enabled.");
                }

                Catalog.CloseConnection();
            }
        }

        class CDC_CDC_Tables_Exist : WatcherTestsBase
        {
            public CDC_CDC_Tables_Exist() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("Verifying CDC Tables exist in RawCatalogDB...");
                string tablesExist = Catalog.ExecuteQueryGetSingle(QueryCDCTablesExist());

                //if CDC tables exist
                if(tablesExist != "1")
                {
                    Global.RO.Info("One or more CDC tables do not exist in RawCatalogDB!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Expected CDC tables exist");
                }

                Catalog.CloseConnection();
            }
            #region SqlStrings
            public string QueryCDCTablesExist()
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("IF (EXISTS(SELECT 1 FROM sysobjects WHERE name='dbo_media_CT') AND ");
                sb.Append("EXISTS(SELECT 1 FROM sysobjects WHERE name='dbo_MediaUserRatingAggregate_CT') AND ");
                sb.Append("EXISTS(SELECT 1 FROM sysobjects WHERE name='dbo_UsageAggregateFromReporting_CT'))");
                sb.Append("SELECT 1 ");
                sb.Append("ELSE ");
                sb.Append("SELECT 0");

                return sb.ToString();
            } 
            #endregion
        }


        [TestCase, TestCasePriority(1)]
        class CDC_ToDoTransferProduct_Job_Exists : WatcherTestsBase
        {
            public CDC_ToDoTransferProduct_Job_Exists() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("Verifying CatalogWatcherToDoTransferProduct job exists in RawCatalogDB...");
                string jobExists = Catalog.ExecuteQueryGetSingle("IF (EXISTS(SELECT 1 FROM sysobjects WHERE name='CatalogWatcherToDoTransferProduct')) SELECT 1 ELSE SELECT 0");

                //if job exists
                if (jobExists != "1")
                {
                    Global.RO.Info("CatalogWatcherToDoTransferProduct job does not exist in RawCatalogDB!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("CatalogWatcherToDoTransferProduct job exists");
                }

                Catalog.CloseConnection();
            }
        }


        [TestCase, TestCasePriority(1)]
        class CDC_ToDoProducts_Table_Exists : WatcherTestsBase
        {
            public CDC_ToDoProducts_Table_Exists() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("Verifying CatalogWatcherToDoProduct table exists in RawCatalogDB...");
                string tableExists = Catalog.ExecuteQueryGetSingle("IF (EXISTS(SELECT 1 FROM sysobjects WHERE name='CatalogWatcherToDoProduct')) SELECT 1 ELSE SELECT 0");

                //Assert ToDoProduct table exists
                if (tableExists != "1")
                {
                    Global.RO.Info("CatalogWatcherToDoProduct table does not exist in RawCatalogDB!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("CatalogWatcherToDoProduct table exists");
                }

                Catalog.CloseConnection();
            }
        }


        [TestCase, TestCasePriority(2)]
        class CDC_Job_With_Empty_CDCMedia_Table : WatcherTestsBase
        {
            public CDC_Job_With_Empty_CDCMedia_Table() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //First, update some records so we have something in the CatalogWatcherToDoProducts table
                Global.RO.Info("Update Media table...");
                List<string> mediaIds = Catalog.ExecuteQueryGetSingleColumn(QuerySelectTopMediaIdsFromMedia());
                Catalog.ExecuteNonQuery(UpdateMediaModifiedDate(mediaIds));

                //Wait for CDC & Transfer job, 10 + 62 = 72
                Global.RO.Info("Give CDC & Transfer job time to run (72 seconds)...");
                WaitSeconds(72);

                //Empty the CDC table
                Global.RO.Info("Empty the CDC tables");
                Catalog.ExecuteNonQuery(SQLDisableTransferJob());
                Catalog.StopTransferJob();
                Catalog.WaitForTransferJobIdle(); //even though disabled, wait for it to stop executing (if it's already running)
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMedia());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMediaUserRatingAggregate());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCUsageAggregateFromReporting());
                Catalog.ExecuteNonQuery((SQLEnableTransferJob()));

                //Wait for next Transfer Job
                Global.RO.Info("Give CDC & Transfer job time to run (72 seconds)...");
                WaitSeconds(72);

                //Since CDC is empty, CatalogWatcherToDoProduct should be empty after the Transfer job
                int countRowsInToDoProducts = Catalog.ExecuteQueryGetSingleInt(GetCountFromToDoProduct());

                if (0 != countRowsInToDoProducts)
                {
                    Global.RO.Info("CatalogWatcherToDoProducts is not empty and it should be!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("CatalogWatcherToDoProducts table is empty like expected, success!");
                }

                Catalog.CloseConnection();
            }

        }


        [TestCase, TestCasePriority(2)]
        class CDC_Job_With_Empty_CDCMediaUserRatingAggregate_Table : WatcherTestsBase
        {
            public CDC_Job_With_Empty_CDCMediaUserRatingAggregate_Table() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //First, update some records so we have something in the ToDoProducts table
                List<string> mediaIds = Catalog.ExecuteQueryGetSingleColumn(QuerySelectTopMediaIdsFromMedia());

                Global.RO.Info("Insert/Update data in MediaUserRatingAggregate...");
                Catalog.ExecuteNonQuery(UpdateMediasInMediaUserRatingAggregate(mediaIds));

                //Wait for CDC & Transfer job, 10 + 62 = 72
                Global.RO.Info("Give CDC & Transfer job time to run (72 seconds)...");
                WaitSeconds(72);

                //Empty the CDC table
                Global.RO.Info("Empty out the CDC tables...");
                Catalog.ExecuteNonQuery(SQLDisableTransferJob());
                Catalog.StopTransferJob();
                Catalog.WaitForTransferJobIdle(); //even though disabled, wait for it to stop executing (if it's already running)
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMedia());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMediaUserRatingAggregate());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCUsageAggregateFromReporting());
                Catalog.ExecuteNonQuery(SQLEnableTransferJob());

                //Wait for next Transfer Job
                Global.RO.Info("Wait for next transfer job (72 seconds)...");
                WaitSeconds(72);

                //Since CDC is empty, ToDoProduct should be empty after the Transfer job
                int countRowsInToDoProducts = Catalog.ExecuteQueryGetSingleInt(GetCountFromToDoProduct());

                if (0 != countRowsInToDoProducts)
                {
                    Global.RO.Info("CatalogWatcherToDoProducts is not empty and it should be!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("CatalogWatcherToDoProducts table is empty, success!");
                }

                Catalog.CloseConnection();
            }

            #region SqlStrings
            private string UpdateMediasInMediaUserRatingAggregate(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("IF EXISTS(SELECT 1 FROM dbo.MediaUserRatingAggregate WHERE mediaId='{0}')\n", mediaId);
                    sb.AppendFormat("UPDATE dbo.MediaUserRatingAggregate SET modifiedDate=GETDATE() WHERE mediaId = '{0}'\n", mediaId);
                    sb.AppendFormat("ELSE\n");
                    sb.AppendFormat("INSERT INTO dbo.MediaUserRatingAggregate VALUES ('{0}', 'US', 5.0, 100, GETDATE(), GETDATE())\n", mediaId);
                    sb.Append("\n");
                }

                return sb.ToString();
            }
                       
            #endregion
        }


        [TestCase, TestCasePriority(2)]
        class CDC_Job_With_Empty_CDCUsageAggregateFromReporting_Table : WatcherTestsBase
        {
            public CDC_Job_With_Empty_CDCUsageAggregateFromReporting_Table() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //First, update some records so we have something in the ToDoProducts table
                Global.RO.Info("Update Rows in UsageAggregateFromReporting...");
                List<string> mediaIds = Catalog.ExecuteQueryGetSingleColumn(QuerySelectTopMediaIdsFromMedia());
                Catalog.ExecuteNonQuery(UpdateRowIds(mediaIds));

                //Wait for CDC & Transfer job, 10 + 62 = 72
                Global.RO.Info("Give CDC & Transfer job time to run (72 seconds)...");
                WaitSeconds(72);

                //Empty the CDC table
                Catalog.ExecuteNonQuery(SQLDisableTransferJob());
                Catalog.StopTransferJob();
                Catalog.WaitForTransferJobIdle(); //even though disabled, wait for it to stop executing (if it's already running)
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMedia());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMediaUserRatingAggregate());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCUsageAggregateFromReporting());
                Catalog.ExecuteNonQuery(SQLEnableTransferJob());

                //Wait for next Transfer Job
                Global.RO.Info("Give CDC & Transfer job time to run (72 seconds)...");
                WaitSeconds(72);

                //Since CDC is empty, ToDoProduct should be empty after the Transfer job
                int countRowsInToDoProducts = Catalog.ExecuteQueryGetSingleInt(GetCountFromToDoProduct());

                if (0 != countRowsInToDoProducts)
                {
                    Global.RO.Info("CatalogWatcherToDoProducts is not empty and it should be!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Table is empty, success!");
                }

                Catalog.CloseConnection();

                return;
            }

            #region SqlStrings
            private string UpdateRowIds(List<string> mediaIds)
            {
                StringBuilder sb = new StringBuilder();
                foreach(string mediaId in mediaIds)
                {
                    sb.AppendFormat("IF EXISTS(SELECT 1 FROM dbo.UsageAggregateFromReporting WHERE rowId='{0}')\n", mediaId);
                    sb.AppendFormat("UPDATE dbo.UsageAggregateFromReporting SET modifiedDate=GETDATE() WHERE rowId = '{0}'\n", mediaId);
                    sb.AppendFormat("ELSE\n");
                    sb.AppendFormat("INSERT INTO dbo.UsageAggregateFromReporting VALUES ('{0}', 22, '{0}', '{0}', 'US', 100, GETDATE(), GETDATE())\n", mediaId);
                    sb.Append("\n");
                }

                return sb.ToString();
            }

            #endregion
        }


        [TestCase, TestCasePriority(2)]
        class CDC_Job_With_CDC_Disabled : WatcherTestsBase
        {
            public CDC_Job_With_CDC_Disabled() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //Disable CDC on the entire database
                Global.RO.Info("Disabling CDC...");
                Catalog.ExecuteNonQuery(DisableCDC());

                //Give CDC time to disable
                WaitSeconds(5); 

                //Execute the Transfer Job
                Global.RO.Info("Executing the Transfer Job...");
                try
                {
                    Catalog.ExecuteNonQuery(SQLExecuteTransferJob());
                }
                catch (SqlException)
                {
                    //Good, we were expecting an exception!
                    Global.RO.Info("Exception found, as expected.");

                    //Since we're done, enable CDC again
                    Global.RO.Info("Enabling CDC before exit");
                    Catalog.ExecuteNonQuery(EnableCDC());

                    return;
                }

                Global.RO.Info("Exception not found: SQL was expected to throw an exception.  It did not.");
                ResultCode = TEST_RESULTS.FAILED;

                //Test failed, so enable CDC
                Global.RO.Info("Enabling CDC before exit");
                Catalog.ExecuteNonQuery(EnableCDC());

                Catalog.CloseConnection();
            }

            #region SqlStrings
            private string DisableCDC()
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("declare @rc int\n");
                sb.Append("exec @rc = sys.sp_cdc_disable_db\n");
                sb.Append("select @rc\n");

                return sb.ToString();
            }

            private string EnableCDC()
            {
                string enableCDCScript = File.ReadAllText("Suites\\EnableCDC.sql");

                return enableCDCScript;
            } 
            #endregion
        }

        [TestCase, TestCasePriority(3)]
        class CDC_Stress_Test : WatcherTestsBase
        {
            public CDC_Stress_Test() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("Deleting data from all CDC tables & Destination table...");
                Catalog.ExecuteNonQuery(SQLDisableTransferJob());
                Catalog.StopTransferJob();
                Catalog.WaitForTransferJobIdle(); //even though disabled, wait for it to stop executing (if it's already running)
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMedia());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMediaUserRatingAggregate());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCUsageAggregateFromReporting());
                Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                Catalog.ExecuteNonQuery(SQLEnableTransferJob());

                //Update all the cdc-enabled rows until we hit close to numRecordsToUpdate
                int runs = 4;
                for (int i = 1; i <= runs; ++i)
                {
                    Global.RO.Info("Update all cdc-enabled rows in Media: Run {0}", i);
                    Catalog.ExecuteNonQuery(UpdateRowsInMedia());
                }

                //Give CDC 60 seconds to catch up
                Global.RO.Info("Wait 60 seconds for CDC");
                WaitSeconds(60);

                int rowsInCDCMedia = Catalog.ExecuteQueryGetSingleInt(GetCountMediasFromCDCMedia());

                int rowInToDoProducts = 0;
                
                //Wait for the transer job.  May take a while to complete, so wait up to 5 minutes.
                int maxWaits = 5;
                while (rowInToDoProducts == 0 && maxWaits > 0)
                {
                    Global.RO.Info("Wait 60 seconds for TransferJob");
                    WaitSeconds(60);

                    rowInToDoProducts = Catalog.ExecuteQueryGetSingleInt(GetCountFromToDoProduct());

                    --maxWaits;
                }
                Global.RO.Info("Rows in CDC_Media: {0}", rowsInCDCMedia);
                Global.RO.Info("Rows in CatalogWatcherToDoProducts: {0}", rowInToDoProducts);

                Catalog.CloseConnection();
            }

            #region SqlStrings
            private string CountRowsInMedia()
            {
                return "SELECT COUNT(1) FROM Media m JOIN MediaType mt ON mt.mediaTypeId = m.mediaTypeId WHERE mt.CatalogWatcherEnabled = 1";
            }

            private string GetCountMediasFromCDCMedia()
            {
                return "SELECT COUNT(1) FROM cdc.dbo_Media_CT";
            }


            private string UpdateRowsInMedia()
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendLine("UPDATE Media SET modifiedDate=GETDATE()");
                sb.AppendLine("WHERE mediaTypeId IN");
                sb.AppendLine("( ");
                sb.AppendLine("1,  --Game ");
                sb.AppendLine("5,  --Game Trial ");
                sb.AppendLine("18, --Game Content ");
                sb.AppendLine("19, --Game Demo ");
                sb.AppendLine("20, --Theme ");
                sb.AppendLine("21, --Xbox Original Game ");
                sb.AppendLine("22, --Gamer Tile ");
                sb.AppendLine("23, --Arcade Game ");
                sb.AppendLine("24, --Game Consumable ");
                sb.AppendLine("30, --Game Video ");
                sb.AppendLine("34, --Game Trailer ");
                sb.AppendLine("37, --XNA Indie Game ");
                sb.AppendLine("45, --Server Backed Game ");
                sb.AppendLine("46, --Marketplace ");
                sb.AppendLine("47  --AvatarItem ");
                sb.AppendLine(") ");

                return sb.ToString();
            } 
            #endregion
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\BucketingTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;
using System.Configuration;


using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Diagnostics;
using xonline.common.config;

using xonline.server.catalogwatcher;

using Com.FastSearch.Esp.Search;
using Com.FastSearch.Esp.Search.Query;
using Com.FastSearch.Esp.Search.Result;
using Com.FastSearch.Esp.Search.View;
using Com.FastSearch.Esp.Content;
using Com.FastSearch.Esp.Content.Config;
using System.Xml;
using System.Collections.Specialized;

using Marketplace.Test.Common.Service;


namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("wirosas"), TestFrequency("Daily"), EnvRequirement("xblobonly, manual")]
    public class BucketingTests
    {
        private static CMNPDB _npdbConnection = null;
        private static CMRawCatalogDB _catalogConnection = null;
        private static string _watcherMachineName = "";

        private static ISearchView _searchView = null;
        private static IDocumentFeeder _documentFeeder = null;

        private static String _fastEspInstallation = String.Empty;
        private static String _fastEspIngestionPort = String.Empty;
        private static String _fastEspSearchPort = String.Empty;
        private static String _fastEspCatalog = String.Empty;

        private static List<string[]> _savedWatchers;

        //private static string _fileMediaIds100 = "watcherTests_mediaIds100.txt";
        private static string _healthcheckUrl = "http://{0}:11210/cron/health.ashx";

        public class BucketingTestDocument : IWatcherDocument
        {
            String _id;
            String _document;

            public BucketingTestDocument(String id, String document)
            {
                _id = id;
                _document = document;
            }
            // The unique Id that identifies the document
            public string DocumentId { get { return _id.ToString(); } }
            // The actual document that gets generated and published
            public Object Document { get { return _document; } }

        }

        private static IQueryResult DoSearch(String searchTerm)
        {
            IQuery query = new Query(searchTerm);

            return _searchView.Search(query);
        }

        /// <summary>
        /// Gets the txt_args xml blob from all existing watchers
        /// </summary>
        /// <returns></returns>
        private static List<string> GetExistingWatcherXml()
        {
            return _npdbConnection.ExecuteQueryGetSingleColumn(StringSelectWatchers());
        }

        /// <summary>
        /// Given a bucketId and the total number of buckets, adds a watcher.
        /// Does NOT include doing an iisreset to shut the system down or a healthcheck to kick it off again.
        /// </summary>
        /// <param name="bucketId"></param>
        /// <param name="totalBuckets"></param>
        /// <returns></returns>
        private static bool AddWatcher(int bucketId, int totalBuckets)
        {
            //@todo - increment totalBuckets for each existing watcher
            List<int> bucketIds = GetAllBucketIds();

            //Update existing watchers with the correct bucket count
            foreach (int bId in bucketIds)
            {
                _npdbConnection.ExecuteNonQuery(StringUpdateWatcherBucketCount(bId, totalBuckets));
            }

            //insert our new watcher with the bucketId/count provided
            _npdbConnection.ExecuteNonQuery(StringInsertWatcher(bucketId, totalBuckets));

            return true;
        }

        /// <summary>
        /// Given a bucketId and the total number of buckets, adds a watcher.
        /// Does NOT include doing an iisreset to shut the system down or a healthcheck to kick it off again.
        /// </summary>
        /// <param name="xml">The xml blob for the txt_args parameter in t_cron_jobs</param>
        /// <param name="totalBuckets"></param>
        /// <returns></returns>
        private static bool AddWatcher(string xml, int totalBuckets)
        {
            //@todo - increment totalBuckets for each existing watcher
            List<int> bucketIds = GetAllBucketIds();

            //Update existing watchers with the correct bucket count
            foreach (int bId in bucketIds)
            {
                _npdbConnection.ExecuteNonQuery(StringUpdateWatcherBucketCount(bId, totalBuckets));
            }

            //insert our new watcher with the bucketId/count provided
            _npdbConnection.ExecuteNonQuery(StringInsertWatcher(xml));

            return true;
        }

        /// <summary>
        /// Deletes a watcher and updates totalBuckets appropriately for other watchers.
        /// </summary>
        /// <param name="bucketId"></param>
        /// <returns></returns>
        private static bool RemoveWatcher(int bucketId)
        {
            _npdbConnection.ExecuteNonQuery(StringDeleteWatcher(bucketId));

            List<int> bucketIds = GetAllBucketIds();

            //Watcher has been deleted, loop through existing buckets and update the count
            foreach (int bId in bucketIds)
            {
                _npdbConnection.ExecuteNonQuery(StringUpdateWatcherBucketCount(bId, bucketIds.Count));
            }

            return true;
        }

        #region SqlStrings
        /// <summary>
        /// Generates the query string to select the proper mediaIds from the catalog.
        /// If count is negative, consider it "SELECT * FROM Media"
        /// </summary>
        /// <param name="count">Number of mediaIds to return. If negative, returns all eligible mediaIds</param>
        /// <returns></returns>
        private static string StringSelectMediaIdsFromMedia()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("SELECT m.mediaId FROM Media m");
            sb.AppendLine("JOIN MediaType mt ON mt.mediaTypeId = m.mediaTypeId");
            sb.AppendLine("WHERE mt.mediaTypeId IN");
            sb.AppendLine("(");
            sb.AppendLine("1,  --Game ");
            sb.AppendLine("5,  --Game Trial ");
            sb.AppendLine("18, --Game Content ");
            sb.AppendLine("19, --Game Demo ");
            sb.AppendLine("20, --Theme ");
            sb.AppendLine("21, --Xbox Original Game ");
            sb.AppendLine("22, --Gamer Tile ");
            sb.AppendLine("23, --Arcade Game ");
            sb.AppendLine("24, --Game Consumable ");
            sb.AppendLine("30, --Game Video ");
            sb.AppendLine("34, --Game Trailer ");
            sb.AppendLine("37, --XNA Indie Game ");
            sb.AppendLine("45, --Server Backed Game ");
            sb.AppendLine("46, --Marketplace ");
            sb.AppendLine("47  --AvatarItem ");
            sb.AppendLine(")");
            sb.AppendLine("ORDER BY m.mediaId");

            return sb.ToString();
        }

        private static string StringSelectAllWatchers()
        {
            return "SELECT * FROM t_cron_jobs WHERE vc_name like '%CatalogWatcher%'";
        }

        /// <summary>
        /// Most of the cron table's watcher data is unimportant for testing.  That's why we only get the meat,
        /// the arugment xml.  This contains all the parameters in an xml blob.
        /// </summary>
        /// <returns></returns>
        private static string StringSelectWatchers()
        {
            return "SELECT txt_args FROM t_cron_jobs WHERE vc_assembly = 'CatalogWatcherPlugin.dll'";
        }

        private static string StringInsertWatcher(int bucketId, int numBuckets)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("INSERT INTO t_cron_jobs VALUES");
            sb.AppendLine("(");
            sb.AppendLine("'CatalogWatcher',");
            sb.AppendLine("0,");
            sb.AppendLine("'CatalogWatcherPlugin.dll',");
            sb.AppendLine("'xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper',");
            sb.AppendFormat("{0},", StringTxtArgXml(bucketId, numBuckets));
            sb.AppendLine("'1900-01-01 00:00:00.000',");
            sb.AppendLine("'1900-01-01 00:00:00.000',");
            sb.AppendLine("120,");
            sb.AppendLine("2147483647,");
            sb.AppendLine("3600,");
            sb.AppendLine("'',");
            sb.AppendLine("0,"); //DISABLED BY DEFAULT
            sb.AppendLine("''");
            sb.AppendLine(")");

            return sb.ToString();
        }

        private static string StringInsertWatcher(string xml)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("INSERT INTO t_cron_jobs VALUES");
            sb.AppendLine("(");
            sb.AppendLine("'CatalogWatcher',");
            sb.AppendLine("0,");
            sb.AppendLine("'CatalogWatcherPlugin.dll',");
            sb.AppendLine("'xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper',");
            sb.AppendFormat("{0},", xml);
            sb.AppendLine("'1900-01-01 00:00:00.000',");
            sb.AppendLine("'1900-01-01 00:00:00.000',");
            sb.AppendLine("120,");
            sb.AppendLine("2147483647,");
            sb.AppendLine("3600,");
            sb.AppendLine("'',");
            sb.AppendLine("1,"); //ENABLED BY DEFAULT
            sb.AppendLine("''");
            sb.AppendLine(")");

            return sb.ToString();
        }

        private static string StringDeleteWatcher(int bucketId)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("DELETE FROM t_cron_jobs\n");
            sb.AppendFormat("WHERE txt_args LIKE '%<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>%'\n", bucketId);
            sb.AppendFormat("AND vc_assembly = 'CatalogWatcherPlugin.dll'");

            return sb.ToString();
        }

        private static string StringUpdateWatcherBucketCount(int bucketIdToUpdate, int newNumberOfBuckets)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("UPDATE t_cron_jobs SET");
            sb.AppendLine("txt_args = '<PluginContext>");
            sb.AppendFormat("<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>\n", bucketIdToUpdate);
            sb.AppendFormat("<attribute name=\"NumberOfBuckets\" type=\"System.Int32\">{0}</attribute>\n", newNumberOfBuckets);
            sb.AppendLine("<attribute name=\"ResourceName\" type=\"System.String\">Media</attribute>");
            sb.AppendLine("<attribute name=\"DestinationName\" type=\"System.String\">ESP</attribute>");
            sb.AppendLine("</PluginContext>'\n");
            sb.AppendFormat("WHERE txt_args like '%<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>%'", bucketIdToUpdate);

            return sb.ToString();
        }

        private static string StringDisableWatcher(int bucketId)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("UPDATE t_cron_jobs SET");
            sb.AppendLine("b_enabled=0\n");
            sb.AppendFormat("WHERE txt_args like '%<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>%'", bucketId);

            return sb.ToString();
        }

        private static string StringEnableWatcher(int bucketId)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("UPDATE t_cron_jobs SET");
            sb.AppendLine("b_enabled=1\n");
            sb.AppendFormat("WHERE txt_args like '%<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>%'", bucketId);

            return sb.ToString();
        }

        private static string StringDeleteFromCDCToDoProductsTables()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("DELETE FROM cdc.dbo_Media_CT");
            sb.AppendLine("DELETE FROM cdc.dbo_MediaUserRatingAggregate_CT");
            sb.AppendLine("DELETE FROM cdc.dbo_UsageAggregateFromReporting_CT");
            sb.AppendLine("DELETE FROM CatalogWatcherToDoProduct");

            return sb.ToString();
        }

        private static string StringDeleteFromWatcherStatus()
        {
            return "DELETE FROM t_catalog_watcher_status";
        }

        private static string StringDeleteWatchers()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("DELETE FROM t_cron_jobs");
            sb.AppendLine("WHERE vc_assembly = 'CatalogWatcherPlugin.dll'");

            return sb.ToString();
        }

        private static string StringUpdateMedias(List<string> mediaIds)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("UPDATE Media SET modifiedDate=GETDATE() WHERE mediaId IN (");
            foreach (string mediaId in mediaIds)
            {
                sb.AppendFormat("'{0}',", mediaId);
            }
            sb.Remove(sb.Length - 1, 1); //remove trailing comma
            sb.AppendLine(")");

            return sb.ToString();
        }

        private static string StringUpdateNextRuntimeOnWatcher()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("UPDATE t_cron_jobs SET");
            sb.AppendLine("dt_exec_next_actual = '2008-11-10 10:00:00.000',");
            sb.AppendLine("dt_exec_next_scheduled = '2008-11-10 10:00:00.000'");
            sb.AppendLine("WHERE vc_assembly = 'CatalogWatcherPlugin.dll'");

            return sb.ToString();
        }

        private static string StringDeleteCollectionDocs()
        {
            return string.Format("\\\\{0} C:\\esp\\bin\\collection-admin.cmd -m clearcollection -n {1}", _fastEspInstallation, _fastEspCatalog);
        }
        #endregion

        /// <summary>
        /// Parses the xml in the txt_args field from t_cron_jobs and
        /// pulls out the bucketId.
        /// </summary>
        /// <param name="xml"></param>
        /// <returns>int bucketId</returns>
        private static int GetBucketIdFromXml(string xml)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xml);

            if (null != doc)
            {
                XmlNodeList nodes = doc.SelectNodes("/PluginContext/attribute[@name='BucketId']");

                if (null != nodes && 0 < nodes.Count)
                {
                    return Convert.ToInt32(nodes[0].InnerText);
                }
            }

            return -1;
        }

        /// <summary>
        /// Returns the updated txt_args value for NPDB, containing a new BucketId.
        /// </summary>
        /// <param name="xml"></param>
        /// <param name="newBucketId"></param>
        /// <returns></returns>
        private static string ChangeBucketId(string xml, int newBucketId)
        {
            int oldBucketId = GetBucketIdFromXml(xml);

            string oldStr = string.Format("<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>", oldBucketId);
            string newStr = string.Format("<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>", newBucketId);

            xml.Replace(oldStr, newStr);

            return xml;
        }

        /// <summary>
        /// Returns the updated txt_args value for NPDB, containing the new number of buckets.
        /// </summary>
        /// <param name="xml"></param>
        /// <param name="newNumberOfBuckets"></param>
        /// <returns></returns>
        private static string ChangeNumberOfBuckets(string xml, int newNumberOfBuckets)
        {
            int oldNumberOfBuckets = GetBucketIdFromXml(xml);

            string oldStr = string.Format("<attribute name=\"NumberOfBuckets\" type=\"System.Int32\">{0}</attribute>", oldNumberOfBuckets);
            string newStr = string.Format("<attribute name=\"NumberOfBuckets\" type=\"System.Int32\">{0}</attribute>", newNumberOfBuckets);

            xml.Replace(oldStr, newStr);

            return xml;
        }

        /// <summary>
        /// Generates the xml blob for the txt_args value in the t_cron_jobs table
        /// </summary>
        /// <param name="bucketId"></param>
        /// <param name="numberOfBuckets"></param>
        /// <returns></returns>
        private static string StringTxtArgXml(int bucketId, int numberOfBuckets)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("'<PluginContext>");
            sb.AppendFormat("<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>\n", bucketId);
            sb.AppendFormat("<attribute name=\"NumberOfBuckets\" type=\"System.Int32\">{0}</attribute>\n", numberOfBuckets);
            sb.AppendLine("<attribute name=\"ResourceName\" type=\"System.String\">Media</attribute>");
            sb.AppendLine("<attribute name=\"DestinationName\" type=\"System.String\">ESP</attribute>");
            sb.AppendLine("</PluginContext>'");

            return sb.ToString();
        }

        /// <summary>
        /// Generates the xml blob for the txt_args value in the t_cron_jobs table.
        /// Useful when needing to test improper values.
        /// </summary>
        /// <param name="bucketId"></param>
        /// <param name="numberOfBuckets"></param>
        /// <param name="resourceName"></param>
        /// <param name="destinationName"></param>
        /// <returns></returns>
        private static string GetArgXmlString(string bucketId, string numberOfBuckets, string resourceName, string destinationName)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("'<PluginContext>");
            sb.AppendFormat("<attribute name=\"BucketId\" type=\"System.Int32\">{0}</attribute>\n", bucketId);
            sb.AppendFormat("<attribute name=\"NumberOfBuckets\" type=\"System.Int32\">{0}</attribute>\n", numberOfBuckets);
            sb.AppendFormat("<attribute name=\"ResourceName\" type=\"System.String\">{0}</attribute>\n", resourceName);
            sb.AppendFormat("<attribute name=\"DestinationName\" type=\"System.String\">{0}</attribute>\n", destinationName);
            sb.AppendLine("</PluginContext>'");

            return sb.ToString();
        }

        /// <summary>
        /// Gets a list of random mediaIds from the database.
        /// </summary>
        /// <param name="count">Number of random mediaIds to return</param>
        /// <returns></returns>
        private static List<string> GetRandomMediaIds(int count)
        {
            //get all mediaIds
            List<string> allMediaIds = _catalogConnection.ExecuteQueryGetSingleColumn(StringSelectMediaIdsFromMedia());

            //if negative, return all mediaIds, OR
            //if there are fewer mediaIds in the database than what we want, just return everything we have.
            if (count < 0 || allMediaIds.Count < count)
                return allMediaIds;

            //randomly pick from those mediaIds the count that we want
            Random rand = new Random(DateTime.Now.Millisecond);
            List<string> mediaIds = new List<string>();
            while (mediaIds.Count < count)
            {
                int randomId = rand.Next(allMediaIds.Count); //get a random mediaId
                mediaIds.Add(allMediaIds[randomId]); //add it to the list
                allMediaIds.RemoveAt(randomId); //remove it from the source list so we don't get it again.
            }

            return mediaIds;
        }

        /// <summary>
        /// Updates the modified date on a list of mediaIds
        /// </summary>
        /// <param name="mediaIds"></param>
        /// <returns></returns>
        private static bool UpdateMediaIds(List<string> mediaIds)
        {
            _catalogConnection.ExecuteNonQuery(StringUpdateMedias(mediaIds)); //update the selected mediaIds

            return true;
        }

        /// <summary>
        /// Examines each existing watcher and returns a unique bucketId.
        /// </summary>
        /// <returns></returns>
        private static int GetUniqueWatcherBucket()
        {
            List<int> bucketIds = GetAllBucketIds();

            int uniqueBucketId = 0;

            //loop through bucketIds until we find an Id that isn't in use.
            while (bucketIds.Contains(uniqueBucketId))
            {
                ++uniqueBucketId;
            }

            return uniqueBucketId;
        }

        /// <summary>
        /// Returns a list of bucketIds from all existing watchers.
        /// </summary>
        /// <returns></returns>
        private static List<int> GetAllBucketIds()
        {
            //Get the bucketIds for all existing watchers
            List<string> existingWatchers = GetExistingWatcherXml();
            List<int> bucketIds = new List<int>();

            foreach (string watcher in existingWatchers)
            {
                bucketIds.Add(GetBucketIdFromXml(watcher));
            }

            return bucketIds;
        }

        /// <summary>
        /// Deletes all documents in the FAST ESP collection.
        /// </summary>
        /// <returns></returns>
        private static bool DeleteDocumentsInCollection()
        {
            Process p = System.Diagnostics.Process.Start("psexec.exe", StringDeleteCollectionDocs());

            p.WaitForExit();

            return true;
        }

        /// <summary>
        /// Calls iisreset on the watcher box.
        /// </summary>
        private static void CallIISReset()
        {
            Process p = System.Diagnostics.Process.Start("psexec.exe", string.Format( "\\\\{0} iisreset", _watcherMachineName));
            p.WaitForExit();
        }

        /// <summary>
        /// calls the cron healthcheck on the watcher box
        /// </summary>
        private static void CallCronHealthCheck()
        {
            WebRequest request = WebRequest.Create(string.Format(_healthcheckUrl, _watcherMachineName));
            request.GetResponse();
        }

        /// <summary>
        /// Compares two list of strings, returning a list of duplicates.
        /// </summary>
        /// <param name="list1"></param>
        /// <param name="list2"></param>
        /// <returns></returns>
        private static List<string> CompareLists(List<string> list1, List<string> list2)
        {
            List<string> output = new List<string>();
            foreach (string mediaId1 in list1)
            {
                if (list2.Contains(mediaId1))
                {
                    output.Add(mediaId1);
                }
            }

            return output;
        }

        /// <summary>
        /// Predicate function for sorting/removing events from the list of events.
        /// </summary>
        /// <param name="eventEntry"></param>
        /// <returns></returns>
        public static bool CronFailuresOnly(EventLogEntry eventEntry)
        {
            if (eventEntry.Source != "cron" && eventEntry.EntryType != EventLogEntryType.Error)
                return true;
            else
                return false;
        }

        public static bool SearchEventLogForFailures(string failureMessage, double minutesBeforeCutoff)
        {
            EventLog objEventLog = null;
            int eventLogConnectAttempts = 0;
            //I've had cases where I was unable to connect to the event log object.  In that case, try to reconnect
            while (objEventLog == null && eventLogConnectAttempts < 5)
            {
                try
                {
                    objEventLog = new EventLog("Application", _watcherMachineName);
                    ++eventLogConnectAttempts;
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Couldn't connect to EventLog on {0}", _watcherMachineName);
                    Global.RO.Warn(e.Message);
                }
            }

            EventLogEntry[] logArray = new EventLogEntry[objEventLog.Entries.Count];
            objEventLog.Entries.CopyTo(logArray, 0);
            List<EventLogEntry> logList = new List<EventLogEntry>(logArray);
            logList.RemoveAll(CronFailuresOnly); //removes all but cron failures
            DateTime cutoffTime = DateTime.Now.Subtract(TimeSpan.FromMinutes(minutesBeforeCutoff));
            
            //logList.Reverse(); //is is sorted by date/time, starting with most recent.
            

            foreach (EventLogEntry eventEntry in logList)
            {
                if (eventEntry.EntryType == EventLogEntryType.Error && eventEntry.Source == "cron" &&
                    eventEntry.TimeGenerated < cutoffTime)
                {
                    if(null == failureMessage) //looking for AN error, nothing specific
                    {
                        Global.RO.Info("Error Found");
                        Global.RO.Info("Event Log Time is: {0}", eventEntry.TimeWritten.ToString());
                        Global.RO.Info("Event Log Message is: {0}", eventEntry.Message);
                        return true;
                    }
                    else if(eventEntry.Message.Contains(failureMessage)) //looking for a specific error
                    {
                        Global.RO.Info("Specified Error Found");
                        Global.RO.Info("Event Log Time is: {0}", eventEntry.TimeWritten.ToString());
                        Global.RO.Info("Event Log Message is: {0}", eventEntry.Message);
                        return true;
                    }
                       
                }
            }

            return false;
        }

        public static void StoreAllWatchers()
        {
            _savedWatchers = _npdbConnection.ExecuteQueryGetMultiple(StringSelectAllWatchers());
        }

        public static void RestoreAllWatchers()
        {
            //Delete any remaining watchers
            _npdbConnection.ExecuteNonQuery(StringDeleteWatchers());

            //Insert watchers that existed before test
            int watcherCount = _savedWatchers.Count;
            int columns = _savedWatchers[0].Length;

            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < watcherCount; ++i)
            {
                sb.AppendLine("INSERT INTO t_cron_jobs VALUES");
                sb.AppendLine(
                    string.Format("('{0}',{1},'{2}','{3}','{4}','{5}','{6}',{7},{8},{9},'{10}',{11},'{12}')\n",
                    _savedWatchers[i][1], //vc_name
                    _savedWatchers[i][2], //i_title_id
                    _savedWatchers[i][3], //vc_assembly
                    _savedWatchers[i][4], //vc_class
                    _savedWatchers[i][5], //txt_args
                    _savedWatchers[i][6], //dt_exec_next_scheduled
                    _savedWatchers[i][7], //dt_exec_next_actual
                    _savedWatchers[i][8], //i_exec_interval_secs
                    _savedWatchers[i][9], //i_exec_count
                    _savedWatchers[i][10], //i_exec_timeout
                    _savedWatchers[i][11], //vc_exec_frontdoor
                    _savedWatchers[i][12], //b_enabled
                    _savedWatchers[i][13] //vc_error_text
                    ));
            }

            _npdbConnection.ExecuteNonQuery(sb.ToString());
        }

        /// <summary>
        /// Adds or Removes watchers as necessary to reach the target number.
        /// </summary>
        /// <param name="totalWatchersWanted"></param>
        /// <returns></returns>
        private static bool PrepareWatchers(int totalWatchersWanted)
        {
            //Delete from CDC/ToDoProducts tables
            Global.RO.Info("Delete everything from CDC/ToDoProducts tables");
            _catalogConnection.ExecuteNonQuery(StringDeleteFromCDCToDoProductsTables());

            Global.RO.Info("Delete documents in collection");
            DeleteDocumentsInCollection();

            //Delete existing watchers
            _npdbConnection.ExecuteNonQuery(StringDeleteWatchers());

            //Delete LSNs from status table
            Global.RO.Info("Delete any existing LSN entries in the status table");
            _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());

            //Reset IIS on the xblob box
            Global.RO.Info("Calling iisreset on watcher box...");
            Thread.Sleep(1000);
            CallIISReset();   
         
            //Add Watchers
            List<int> existingWatcherBucketIds = GetAllBucketIds();

            for(int i = existingWatcherBucketIds.Count; i < totalWatchersWanted; ++i) //if fewer watchers exist, add one
            {
                Global.RO.Info("Too few watchers for test, adding watcher");
                AddWatcher(GetUniqueWatcherBucket(), totalWatchersWanted);
            }

            _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

            //Run health checks to start watchers
            Global.RO.Info("Running Healthcheck to kickstart cron");
            CallCronHealthCheck();

            return true;
        }

        /// <summary>
        /// Uses existing watchers, processes mediaIds and tests bucketing per watcher.
        /// </summary>
        /// <param name="numMediaIdsToProcess"></param>
        /// <returns></returns>
        private static bool TestBucketing(int numMediaIdsToProcess)
        {
            bool success = true;

            List<string> mediaIds = GetRandomMediaIds(numMediaIdsToProcess);

            if (mediaIds.Count != numMediaIdsToProcess) //Not enough mediaIds, return fail.
            {
                Global.RO.Warn("Not enough mediaIds to process test.  Expected {0} mediaIDs, only got {1} mediaIDs.", numMediaIdsToProcess, mediaIds.Count);
                numMediaIdsToProcess = mediaIds.Count;
            }
            
            List<int> bucketIds = GetAllBucketIds();

            int numWatchers = bucketIds.Count;

            //Disable all watchers but 1
            foreach (int bucketId in bucketIds)
            {
                _npdbConnection.ExecuteNonQuery(StringDisableWatcher(bucketId));
            }

            //update mediaIds
            Global.RO.Info("Updating mediaIds");
            UpdateMediaIds(mediaIds);

            Thread.Sleep(10000);

            Global.RO.Info("Waiting for CDC, Transfer Job to run...");
            _catalogConnection.ExecuteNonQuery("EXEC dbo.CatalogWatcherToDoTransferProduct");
            Thread.Sleep(60000);

            List<List<string>> mediaIdsProcessedPerWatcher = new List<List<string>>();
            for (int i = 0; i < numWatchers; ++i)
            {
                mediaIdsProcessedPerWatcher.Add(new List<string>());
            }

            IQueryResult result;
            int numMatchingDocsPerMediaId = 0;
            int numMatchingDocsPerWatcher = 0;
            int numMatchingDocsTotal = 0;

            for (int i = 0; i < numWatchers; ++i)
            {
                Global.RO.Info("Running watcher {0}", i);

                _npdbConnection.ExecuteNonQuery(StringEnableWatcher(bucketIds[i]));

                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());
                Thread.Sleep(3 * 60000); //3 minute wait...

                Global.RO.Info("Verifying output...");

                numMatchingDocsPerWatcher = 0;

                foreach (string mediaId in mediaIds)
                {
                    result = DoSearch(string.Format("xml:productId:\"{0}\"", mediaId));

                    numMatchingDocsPerMediaId = result.DocCount;

                    //if there were matching docs for this mediaId, 
                    //add it to the list of mediaIds processed for this watcher/bucket.
                    if (numMatchingDocsPerMediaId > 0) 
                    {
                        numMatchingDocsTotal += numMatchingDocsPerMediaId;
                        numMatchingDocsPerWatcher += numMatchingDocsPerMediaId;
                        mediaIdsProcessedPerWatcher[i].Add(mediaId);
                    }
                }

                Global.RO.Info("Total docs for watcher {0}: {1}", i, numMatchingDocsPerWatcher);

                _npdbConnection.ExecuteNonQuery(StringDisableWatcher(bucketIds[i]));

                Global.RO.Info("Deleting documents in collection");
                DeleteDocumentsInCollection();
            }

            Global.RO.Info("Total docs over all mediaIds: {0}", numMatchingDocsTotal);

            int totalMediaIdsProcessed = 0;
            for (int i = 0; i < numWatchers; ++i)
            {
                Global.RO.Info("Total mediaIds processed for watcher {0}: {1}", i, mediaIdsProcessedPerWatcher[i].Count);
                totalMediaIdsProcessed += mediaIdsProcessedPerWatcher[i].Count;
            }

            if (totalMediaIdsProcessed != numMediaIdsToProcess)
            {
                success = false;
                Global.RO.Info("{0} mediaIds were expected to be processed, {1} were actually processed.", numMediaIdsToProcess, totalMediaIdsProcessed);
            }

            //if there are more than 1 watchers, verify they didn't process the same mediaId multiple times
            if (numWatchers > 1)
            {
                for (int i = 0; i < numWatchers - 1; ++i)
                {
                    for (int j = i+1; j < numWatchers; ++j)
                    {
                        List<string> duplicateMediaIds = CompareLists(mediaIdsProcessedPerWatcher[i], mediaIdsProcessedPerWatcher[j]);

                        if (duplicateMediaIds.Count > 0)
                        {
                            success = false;
                            Global.RO.Info("Failed, two watchers processed the same mediaId");
                            Global.RO.Info("MediaIds processed by both watchers:");
                            foreach (string mediaId in duplicateMediaIds)
                            {
                                Global.RO.Info(mediaId);
                            }
                        }
                    }
                }
            }

            return success;
        }

        /// <summary>
        /// Generates the specified number of watchers and tests bucketing.
        /// </summary>
        /// <param name="numWatchers"></param>
        /// <param name="numMediaIdsToProcess"></param>
        /// <returns></returns>
        private static bool TestBucketing(int numWatchers, int numMediaIdsToProcess)
        {
            //Set up watchers
            Global.RO.Info("Preparing watchers");
            PrepareWatchers(numWatchers);

            Thread.Sleep(3000);

            return TestBucketing(numMediaIdsToProcess);
        }

        [TestGroupSetup]
        public void Setup()
        {
            _npdbConnection = new CMNPDB();
            _catalogConnection = new CMRawCatalogDB();
            
            //Load configuration settings for the test cases
            Configuration config = ConfigurationManager.OpenExeConfiguration(System.Reflection.Assembly.GetExecutingAssembly().Location);

            _watcherMachineName = config.AppSettings.Settings["XblobMachineName"].Value;
            _healthcheckUrl = string.Format(_healthcheckUrl, _watcherMachineName);

            _fastEspInstallation = config.AppSettings.Settings["FastEspInstallation"].Value;
            _fastEspIngestionPort = config.AppSettings.Settings["FastEspIngestionPort"].Value;
            _fastEspSearchPort = config.AppSettings.Settings["FastEspSearchPort"].Value;
            _fastEspCatalog = config.AppSettings.Settings["FastEspCatalog"].Value;

            //Get existing watchers from NPDB so we can restore the existing
            //settings when tests are done.
            StoreAllWatchers();            

            NameValueCollection configuration = new NameValueCollection();
            configuration.Add("Com.FastSearch.Esp.Search.Http.QRServers", _fastEspInstallation + ":" + _fastEspSearchPort);

            ISearchFactory searchFactory = SearchFactory.NewInstance(configuration);

            _searchView = searchFactory.GetSearchView(_fastEspCatalog.ToLower());

            _documentFeeder = Factory.CreateDocumentFeeder(_fastEspInstallation + ":" + _fastEspIngestionPort, _fastEspCatalog);

            // Force the flush to wait until it is completely indexed and searchable
            ISubsystem indexing = _documentFeeder.GetSystemConfig().GetSubsystem("indexing");
            if (indexing != null)
            {
                indexing.CompletedCallbackEnabled = true;
            } 
        }

        [TestGroupTearDown]
        public void Shutdown() 
        {
            RestoreAllWatchers();

            _npdbConnection.CloseConnection();
            _catalogConnection.CloseConnection();

            // Turn off waiting for the indexing to be finished
            ISubsystem indexing = _documentFeeder.GetSystemConfig().GetSubsystem("indexing");
            if (indexing != null)
            {
                indexing.CompletedCallbackEnabled = false;
            }

            if (_documentFeeder != null)
            {
                _documentFeeder.Dispose();
            }
        }

        [TestCase, TestCasePriority(1)]
        class Bucketing_DeploymentValidation : WatcherTestsBase
        {
            public Bucketing_DeploymentValidation() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //Queries NPDB looking for watchers
                List<string> existingWatchers = GetExistingWatcherXml();

                if (existingWatchers.Count == 0)  //No watchers found
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                //See if a setting for the ESP location exists
                int espLocationSetting = 0;//_npdbConnection.ExecuteQueryGetSingleInt("SELECT COUNT(1) FROM t_settings WHERE vc_setting='catalogwatcher_fast_esp_content_distributor'");
                try
                {
                    espLocationSetting = Global.XEnv.GetSetting("catalogwatcher_fast_esp_max_documents_per_batch").Length > 0 ? 1 : 0;
                }
                catch (Exception e)
                {
                    Global.RO.Error(e.Message);
                }

                if (espLocationSetting == 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                //Maybe add checks to see if other watcher tables exist - first check to see if covered in other testing

            }
        }

        /// <summary>
        /// Bug 47368 - Cron should not crash when the plugin does not contain the assembly
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class Bucketing_BadAssembly : WatcherTestsBase
        {
            public Bucketing_BadAssembly() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    //Stop cron so we can make some changes
                    CallIISReset();

                    //Change the watcher setting to a bad value
                    UpdateWatcherSetting("vc_assembly", "TestNotCatalogWatcherPlugin.dll", "CatalogWatcherPlugin.dll", "xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper");
                    _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                    //Give it a second for the changes to take effect
                    WaitSeconds(3);

                    //restart cron
                    CallCronHealthCheck();

                    Global.RO.Info("Waiting for watcher to run...");
                    WaitSeconds(90);

                    Global.RO.Info("Searching events for failure...");
                    //Watch event log for any failure in the past 2 minutes
                    if (SearchEventLogForFailures(null, 2.0))
                    {
                        ResultCode = TEST_RESULTS.PASSED; //test passed, no error found
                    }
                }
                catch (Exception e)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    Global.RO.Error(e.Message);
                }

                //Reset the watcher back to its default value
                CallIISReset();
                UpdateWatcherSetting("vc_assembly", "CatalogWatcherPlugin.dll", "CatalogWatcherPlugin.dll", "xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper");
                WaitSeconds(3);
                //restart cron
                CallCronHealthCheck();
            }
        }

        /// <summary>
        /// Bug 47357 - Cron should not crash because of bad text argument in the t_cron_jobs table
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class Bucketing_BadTextArgument : WatcherTestsBase
        {
            public Bucketing_BadTextArgument() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                //Stop cron so we can make some changes
                CallIISReset();

                //Change the watcher setting to a bad value
                UpdateWatcherSetting("txt_args", "BadTextArgs", "CatalogWatcherPlugin.dll", "xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper");
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                //Give it a second for the changes to take effect
                WaitSeconds(3);

                //restart cron
                CallCronHealthCheck();

                Global.RO.Info("Waiting for watcher to run...");
                WaitSeconds(90);

                Global.RO.Info("Searching events for failure...");

                //Watch event log for any failure in the past 2 minutes
                if (SearchEventLogForFailures(null, 2.0))
                {
                    ResultCode = TEST_RESULTS.PASSED; //test passed, no error found
                }

                //Reset the watcher back to its default value
                CallIISReset();
                UpdateWatcherSetting("txt_args", StringTxtArgXml(1, 1), "CatalogWatcherPlugin.dll", "xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper");
                WaitSeconds(3);
                //restart cron
                CallCronHealthCheck();
            }
        }

        [TestCase, TestCasePriority(1)]
        class Bucketing_SingleWatcher : WatcherTestsBase
        {
            public Bucketing_SingleWatcher() : base() { }

            protected override void Execute()
            {
                bool success = TestBucketing(1, 100);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class Bucketing_TwoWatchers : WatcherTestsBase
        {
            public Bucketing_TwoWatchers() : base() {}

            protected override void Execute()
            {
                bool success = TestBucketing(2, 100);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class Bucketing_FiveWatchers : WatcherTestsBase
        {
            public Bucketing_FiveWatchers() : base() { }

            protected override void Execute()
            {
                bool success = TestBucketing(5, 200);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, TestCasePriority(3)]
        class Bucketing_BucketIdNegative : WatcherTestsBase
        {
            public Bucketing_BucketIdNegative() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("Calling IISReset...");
                CallIISReset();

                //Clear out all watchers and watcher data
                _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());
                _npdbConnection.ExecuteNonQuery(StringDeleteWatchers());

                Global.RO.Info("Adding watcher with negative bucketId (-1)");
                AddWatcher(GetArgXmlString("-1", "1", "Media", "ESP"), 1);
                
                //Reset runtime on watcher
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                Global.RO.Info("Calling health check to kick off cron");
                CallCronHealthCheck();

                Global.RO.Info("Waiting for watcher to run...");
                WaitSeconds(180);

                Global.RO.Info("Searching events for failure...");

                if (SearchEventLogForFailures("MediaDocumentProducer initialized with invalid parameter value for 'BucketId'.", 5.0))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
             
            }
        }

        [TestCase, TestCasePriority(3)]
        class Bucketing_BucketIdString : WatcherTestsBase
        {
            public Bucketing_BucketIdString() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                string bucketId = "BillID";

                Global.RO.Info("Calling IISReset...");
                CallIISReset();

                //Clear out all watchers and watcher data
                _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());
                _npdbConnection.ExecuteNonQuery(StringDeleteWatchers());

                Global.RO.Info("Adding watcher with a string bucektId 'BillID'");
                AddWatcher(GetArgXmlString(bucketId, "1", "Media", "ESP"), 1);

                //Reset runtime on watcher
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                Global.RO.Info("Calling health check to kick off cron");
                CallCronHealthCheck();

                Global.RO.Info("Waiting for watcher to run...");
                WaitSeconds(90);

                Global.RO.Info("Searching events for failure...");

                if (SearchEventLogForFailures("Input string was not in a correct format.", 2.0))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class Bucketing_ResourceUnknown : WatcherTestsBase
        {
            public Bucketing_ResourceUnknown() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("Calling IISReset...");
                CallIISReset();

                //Clear out all watchers and watcher data
                _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());
                _npdbConnection.ExecuteNonQuery(StringDeleteWatchers());

                Global.RO.Info("Adding watcher with an invalid resource");
                AddWatcher(GetArgXmlString("1", "1", "InvalidResource", "ESP"), 1);

                //Reset runtime on watcher
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                Global.RO.Info("Calling health check to kick off cron");
                CallCronHealthCheck();

                Global.RO.Info("Waiting for watcher to run...");
                WaitSeconds(180);

                Global.RO.Info("Searching events for failure...");

                if(SearchEventLogForFailures("Invalid resourceName passed to the DetectorFactory", 5.0))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }

            }
        }

        [TestCase, TestCasePriority(3)]
        class Bucketing_DestinationUnknown : WatcherTestsBase
        {
            public Bucketing_DestinationUnknown() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("Calling IISReset...");
                CallIISReset();

                //Clear out all watchers and watcher data
                _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());
                _npdbConnection.ExecuteNonQuery(StringDeleteWatchers());

                Global.RO.Info("Adding watcher with an invalid destination");
                AddWatcher(GetArgXmlString("1", "1", "Media", "InvalidDestination"), 1);

                //Reset runtime on watcher
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                Global.RO.Info("Calling health check to kick off cron");
                CallCronHealthCheck();

                Global.RO.Info("Waiting for watcher to run...");
                WaitSeconds(180);

                Global.RO.Info("Searching events for failure...");

                if (SearchEventLogForFailures("Invalid destination passed to the DetectorFactory", 5.0))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
  
            }
        }


        //[TestCase, TestCasePriority(3)]
        class Bucketing_Perf_ExtractorAvgExecutionTime_MultipleWatchersRunning_Watcher0 : WatcherTestsBase
        {
            public Bucketing_Perf_ExtractorAvgExecutionTime_MultipleWatchersRunning_Watcher0() : base() { }


            public ManualResetEvent monitoringComplete;

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                monitoringComplete = new ManualResetEvent(false);

                Global.RO.Info("Putting database tables in a good state...");
                DeleteDocumentsInCollection();
                _catalogConnection.ExecuteNonQuery(StringDeleteFromCDCToDoProductsTables());
                _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());

                List<int> bucketIds = GetAllBucketIds();
                if (bucketIds.Count <= 1) //Not enough buckets, add buckets
                {
                    Global.RO.Info("Resetting IIS before adding watchers...");
                    CallIISReset();

                    Global.RO.Info("Adding watchers...");
                    int numWatchers = 2; //want at least 2 watchers
                    for (int i = bucketIds.Count; i < numWatchers; ++i)
                    {
                        int uniqueBucketId = GetUniqueWatcherBucket();
                        AddWatcher(uniqueBucketId, numWatchers);
                    }

                    WaitSeconds(2); //even though the change should go through immediately, wait, just in case.

                    Global.RO.Info("Updating watcher runtimes to start right away...");
                    _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                    Global.RO.Info("Health check to kick off cron...");
                    CallCronHealthCheck();

                    WaitSeconds(120); //wait 2 minutes for the jobs to start and create the perf counter instances
                }

                //Enable all buckets if they're not enabled already.
                bucketIds = GetAllBucketIds();
                foreach (int bucketId in bucketIds)
                {
                    _npdbConnection.ExecuteNonQuery(StringEnableWatcher(bucketId));
                }

                Global.RO.Info("Updating watcher runtimes to start right away...");
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                //Register perf counters for the event
                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);
                PerfCounterTargetReached += monitorDelegate; //Register for the event

                Global.RO.Info("Update all relative mediaIds...");
                _catalogConnection.ExecuteNonQuery(StringUpdateMedias(GetRandomMediaIds(300)));

                try
                {
                    MonitorPerformanceCounter(PERF_EXTRACTOR,
                                              PERF_EXTRACTOR_AVG_EXECUTION_TIME,
                                              "mediadocumentproducer_media_esp_0",
                                              0.0000001, 180);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }


                    //Unregister when you’re cleaning up the test case
                    PerfCounterTargetReached -= monitorDelegate;
                }
                catch(Exception e)
                {
                    Global.RO.Warn("Failed to monitor performance counter.");
                    Global.RO.Error(e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }

            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved,
            string performanceCounterCategory,
            string performanceCounter,
            string performanceCounterInstance,
            double performanceCounterValue)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        //[TestCase, TestCasePriority(3)]
        class Bucketing_Perf_ExtractorAvgExecutionTime_MultipleWatchersRunning_Watcher1 : WatcherTestsBase
        {
            public Bucketing_Perf_ExtractorAvgExecutionTime_MultipleWatchersRunning_Watcher1() : base() { }

            public ManualResetEvent monitoringComplete;

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                monitoringComplete = new ManualResetEvent(false);

                Global.RO.Info("Putting database tables in a good state...");
                DeleteDocumentsInCollection();
                _catalogConnection.ExecuteNonQuery(StringDeleteFromCDCToDoProductsTables());
                _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());

                List<int> bucketIds = GetAllBucketIds();
                if (bucketIds.Count <= 1) //Not enough buckets, add buckets
                {
                    Global.RO.Info("Resetting IIS before adding watchers...");
                    CallIISReset();

                    Global.RO.Info("Adding watchers...");
                    int numWatchers = 2; //want at least 2 watchers
                    for (int i = bucketIds.Count; i < numWatchers; ++i)
                    {
                        int uniqueBucketId = GetUniqueWatcherBucket();
                        AddWatcher(uniqueBucketId, numWatchers);
                    }

                    WaitSeconds(2); //even though the change should go through immediately, wait, just in case.

                    Global.RO.Info("Updating watcher runtimes to start right away...");
                    _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                    Global.RO.Info("Health check to kick off cron...");
                    CallCronHealthCheck();

                    WaitSeconds(120); //wait 2 minutes for the jobs to start and create the perf counter instances
                }

                //Enable all buckets if they're not enabled already.
                bucketIds = GetAllBucketIds();
                foreach (int bucketId in bucketIds)
                {
                    _npdbConnection.ExecuteNonQuery(StringEnableWatcher(bucketId));
                }

                Global.RO.Info("Updating watcher runtimes to start right away...");
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                //Register perf counters for the event
                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);
                PerfCounterTargetReached += monitorDelegate; //Register for the event

                Global.RO.Info("Update all relative mediaIds...");
                _catalogConnection.ExecuteNonQuery(StringUpdateMedias(GetRandomMediaIds(300)));

                try
                {
                    MonitorPerformanceCounter(PERF_EXTRACTOR,
                                              PERF_EXTRACTOR_AVG_EXECUTION_TIME,
                                              "mediadocumentproducer_media_esp_1",
                                              0.0000001, 180);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }


                    //Unregister when you’re cleaning up the test case
                    PerfCounterTargetReached -= monitorDelegate;
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Failed to monitor performance counter.");
                    Global.RO.Error(e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }

            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved,
            string performanceCounterCategory,
            string performanceCounter,
            string performanceCounterInstance,
            double performanceCounterValue)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        //[TestCase, TestCasePriority(3)]
        class Bucketing_Perf_DetectorAvgExecutionTime_MultipleWatchersRunning_Watcher0 : WatcherTestsBase
        {
            public Bucketing_Perf_DetectorAvgExecutionTime_MultipleWatchersRunning_Watcher0() : base() { }
            
            public ManualResetEvent monitoringComplete;

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                monitoringComplete = new ManualResetEvent(false);

                Global.RO.Info("Putting database tables in a good state...");
                DeleteDocumentsInCollection();
                _catalogConnection.ExecuteNonQuery(StringDeleteFromCDCToDoProductsTables());
                _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());

                List<int> bucketIds = GetAllBucketIds();
                if (bucketIds.Count <= 1) //Not enough buckets, add buckets
                {
                    Global.RO.Info("Resetting IIS before adding watchers...");
                    CallIISReset();

                    Global.RO.Info("Adding watchers...");
                    int numWatchers = 2; //want at least 2 watchers
                    for (int i = bucketIds.Count; i < numWatchers; ++i)
                    {
                        int uniqueBucketId = GetUniqueWatcherBucket();
                        AddWatcher(uniqueBucketId, numWatchers);
                    }

                    WaitSeconds(2); //even though the change should go through immediately, wait, just in case.

                    Global.RO.Info("Updating watcher runtimes to start right away...");
                    _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                    Global.RO.Info("Health check to kick off cron...");
                    CallCronHealthCheck();

                    WaitSeconds(120); //wait 2 minutes for the jobs to start and create the perf counter instances
                }

                //Enable all buckets if they're not enabled already.
                bucketIds = GetAllBucketIds();
                foreach (int bucketId in bucketIds)
                {
                    _npdbConnection.ExecuteNonQuery(StringEnableWatcher(bucketId));
                }

                Global.RO.Info("Updating watcher runtimes to start right away...");
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                //Register perf counters for the event
                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);
                PerfCounterTargetReached += monitorDelegate; //Register for the event

                Global.RO.Info("Update all relative mediaIds...");
                _catalogConnection.ExecuteNonQuery(StringUpdateMedias(GetRandomMediaIds(300)));

                try
                {
                    MonitorPerformanceCounter(PERF_DETECTOR,
                                              PERF_DETECTOR_AVG_EXECUTION_TIME,
                                              "mediadocumentproducer_media_esp_0",
                                              0.0000001, 180);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }


                    //Unregister when you’re cleaning up the test case
                    PerfCounterTargetReached -= monitorDelegate;
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Failed to monitor performance counter.");
                    Global.RO.Error(e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }

            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved,
            string performanceCounterCategory,
            string performanceCounter,
            string performanceCounterInstance,
            double performanceCounterValue)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        //[TestCase, TestCasePriority(3)]
        class Bucketing_Perf_DetectorAvgExecutionTime_MultipleWatchersRunning_Watcher1 : WatcherTestsBase
        {
            public Bucketing_Perf_DetectorAvgExecutionTime_MultipleWatchersRunning_Watcher1() : base() { }

            public ManualResetEvent monitoringComplete;

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                monitoringComplete = new ManualResetEvent(false);

                Global.RO.Info("Putting database tables in a good state...");
                DeleteDocumentsInCollection();
                _catalogConnection.ExecuteNonQuery(StringDeleteFromCDCToDoProductsTables());
                _npdbConnection.ExecuteNonQuery(StringDeleteFromWatcherStatus());

                List<int> bucketIds = GetAllBucketIds();
                if (bucketIds.Count <= 1) //Not enough buckets, add buckets
                {
                    Global.RO.Info("Resetting IIS before adding watchers...");
                    CallIISReset();

                    Global.RO.Info("Adding watchers...");
                    int numWatchers = 2; //want at least 2 watchers
                    for (int i = bucketIds.Count; i < numWatchers; ++i)
                    {
                        int uniqueBucketId = GetUniqueWatcherBucket();
                        AddWatcher(uniqueBucketId, numWatchers);
                    }

                    WaitSeconds(2); //even though the change should go through immediately, wait, just in case.

                    Global.RO.Info("Updating watcher runtimes to start right away...");
                    _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                    Global.RO.Info("Health check to kick off cron...");
                    CallCronHealthCheck();

                    WaitSeconds(120); //wait 2 minutes for the jobs to start and create the perf counter instances
                }

                //Enable all buckets if they're not enabled already.
                bucketIds = GetAllBucketIds();
                foreach (int bucketId in bucketIds)
                {
                    _npdbConnection.ExecuteNonQuery(StringEnableWatcher(bucketId));
                }

                Global.RO.Info("Updating watcher runtimes to start right away...");
                _npdbConnection.ExecuteNonQuery(StringUpdateNextRuntimeOnWatcher());

                //Register perf counters for the event
                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);
                PerfCounterTargetReached += monitorDelegate; //Register for the event

                Global.RO.Info("Update all relative mediaIds...");
                _catalogConnection.ExecuteNonQuery(StringUpdateMedias(GetRandomMediaIds(300)));

                try
                {
                    MonitorPerformanceCounter(PERF_DETECTOR,
                                              PERF_DETECTOR_AVG_EXECUTION_TIME,
                                              "mediadocumentproducer_media_esp_1",
                                              0.0000001, 180);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }


                    //Unregister when you’re cleaning up the test case
                    PerfCounterTargetReached -= monitorDelegate;
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Failed to monitor performance counter.");
                    Global.RO.Error(e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }

            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved,
            string performanceCounterCategory,
            string performanceCounter,
            string performanceCounterInstance,
            double performanceCounterValue)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\CommandsUnitTests.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Net;
using System.Threading;
using System.IO;

using xonline.common.sql.sqlclient;
using xonline.common.mgmt;
using System.Xml;
using xonline.server.catalogwatcher;
using xonline.common.config;
using xonline.common.service;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using HResult = xonline.common.service.HResult;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("ripin"), TestFrequency("Check-In"), EnvRequirement("Watcher")]
    public class CommandsUnitTests
    {

        public class RefreshCommandBase : TestBase
        {
            protected void RunTest(Hashtable args, List<MediaIdLcid> expectedOutput, List<Guid> distinctMediaIds)
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    CommonUtils.CleanupToDoTable();                    
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr.IsSuccess())
                    {
                        Thread.Sleep(120000);
                        List<MediaIdLcid> list = CommonUtils.GetMediaLcidFromToDoTable();
                        bool bEqual = false;
                        if (list.Count == expectedOutput.Count)
                        {
                            int i = 0;
                            for (; i < list.Count; i++)
                            {
                                if (list[i].ToString() == expectedOutput[i].ToString())
                                {
                                    continue;
                                }
                                else
                                {
                                    break;
                                }
                            }
                            if (i == list.Count)
                            {
                                bEqual = true;
                            }
                        }
                        if (!bEqual)
                        {
                            throw new Exception("Lists not equal. Test failed.");
                        }
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("P_RefreshAllCommand passed");
                    }
                    else
                    {
                        throw new Exception("Watcher::Command call failed with hr: "+ hr.ToString());
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("P_RefreshAllCommand Failed: " + e);
                }
            }
        }


        [TestCase, TestCasePriority(1)]
        public class P_RefreshAllCommand : RefreshCommandBase
        {
            protected override void Execute()
            {
                Hashtable args = new Hashtable();
                args["op"] = "RefreshAllProductMedia";
                List<Guid> distinctMediaIds = new List<Guid>();
                List<MediaIdLcid> expectedOutput = CommonUtils.GetMediaFromMediaTable(0, distinctMediaIds);
                RunTest(args, expectedOutput, distinctMediaIds);
            }
        }

        
        public class RefreshNMediaBase : RefreshCommandBase
        {
            protected void PrepareInputAndRunTest(int n)
            {
                Hashtable args = new Hashtable();
                args["op"] = "RefreshProductMediaIds";
                List<Guid> distinctMediaIds = new List<Guid>();
                List<MediaIdLcid> expectedOutput = CommonUtils.GetMediaFromMediaTable(n, distinctMediaIds);
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < distinctMediaIds.Count; i++)
                {
                    sb.Append(distinctMediaIds[i]);
                    if (i < distinctMediaIds.Count - 1)
                    {
                        sb.Append(".");
                    }
                }
                args["p1"] = sb.ToString();
                RunTest(args, expectedOutput, distinctMediaIds);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_Refresh1Media : RefreshNMediaBase
        {
            protected override void Execute()
            {
                PrepareInputAndRunTest(1);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_Refresh5Media : RefreshNMediaBase
        {
            protected override void Execute()
            {
                PrepareInputAndRunTest(5);
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_NullArgs : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = null;
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_NullArgs passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_NullArgs failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_NullArgs failed " + e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_NoArgs : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_NoArgs passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_NoArgs failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_NoArgs failed " + e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_NoOp : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["p1"] = "1";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_NoOp passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_NoOp failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_NoOp failed " + e);
                }
            }
        }


        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_InvalidOp : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "abrakadabra";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_InvalidOp passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_InvalidOp failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_InvalidOp failed " + e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_MissingOpParam : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "RefreshProductMediaIds";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_MissingOpParam passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_MissingOpParam failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_MissingOpParam failed " + e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_EmptyOpParam : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "RefreshProductMediaIds";
                    args["p1"] = "";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_EmptyOpParam passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_EmptyOpParam failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_EmptyOpParam failed " + e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_InvalidOpParam_Non_Id_String : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "RefreshProductMediaIds";
                    args["p1"] = "abrakadabra";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_InvalidOpParam_Non_Id_String passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_InvalidOpParam_Non_Id_String failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_InvalidOpParam_Non_Id_String failed " + e);
                }
            }
        }



        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_InvalidOpParam_IdNotPresent : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "RefreshProductMediaIds";
                    args["p1"] = Guid.Empty.ToString();
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_InvalidOpParam_IdNotPresent passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_InvalidOpParam_IdNotPresent failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_InvalidOpParam_IdNotPresent failed " + e);
                }
            }
        }


        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_InvalidOpParam_IdOfWrongMediaType : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "RefreshProductMediaIds";
                    args["p1"] = "F594F82E-CC55-417A-AA2F-084892220BBC";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_InvalidOpParam_IdOfWrongMediaType passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_InvalidOpParam_IdOfWrongMediaType failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_InvalidOpParam_IdOfWrongMediaType failed " + e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_RefreshCommand_InvalidParam_RefreshAll : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "RefreshAllProductMedia";
                    args["p1"] = "F594F82E-CC55-417A-AA2F-084892220BBC";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_RefreshCommand_InvalidParam_RefreshAll passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_RefreshCommand_InvalidParam_RefreshAll failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_RefreshCommand_InvalidParam_RefreshAll failed " + e);
                }
            }
        }

        public class P_AdminCommand_SetEnable_Base : TestBase
        {
            public void RunTest(bool curEnableValue, bool newEnableValue)
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    CommonUtils.SetWatcherEnabled(curEnableValue);
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    Hashtable args = new Hashtable();
                    args["op"] = "WatcherSetEnable";
                    args["p1"] = newEnableValue ? "1" : "0";
                    HResult hr = handler.Command(args, sb);
                    if (hr.IsSuccess())
                    {
                        if (CommonUtils.IsWatcherEnabledValue(newEnableValue))
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                            Global.RO.Info("P_AdminCommand_SetEnable Test Passed");
                        }
                        else
                        {
                            throw new Exception("Test failed as the enabled value is not as expected");
                        }
                    }
                    else
                    {
                        throw new Exception("Test failed with hr: "+hr);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("P_AdminCommand_SetEnable_Base Failed: " + e);
                }

            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_AdminCommand_SetEnable_TRUE_CURRENTLY_FALSE : P_AdminCommand_SetEnable_Base
        {
            protected override void Execute()
            {
                RunTest(false, true);   
            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_AdminCommand_SetEnable_TRUE_CURRENTLY_TRUE : P_AdminCommand_SetEnable_Base
        {
            protected override void Execute()
            {
                RunTest(true, true);
            }
        }


        [TestCase, TestCasePriority(1)]
        public class P_AdminCommand_SetEnable_FALSE_CURRENTLY_FALSE : P_AdminCommand_SetEnable_Base
        {
            protected override void Execute()
            {
                RunTest(false, false);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_AdminCommand_SetEnable_FALSE_CURRENTLY_TRUE : P_AdminCommand_SetEnable_Base
        {
            protected override void Execute()
            {
                RunTest(true, false);
            }
        }


        [TestCase, TestCasePriority(2)]
        public class N_AdminCommand_SetEnable_EmptyString : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "WatcherSetEnable";
                    args["p1"] = "";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_AdminCommand_SetEnable_EmptyString passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_AdminCommand_SetEnable_EmptyString failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_AdminCommand_SetEnable_EmptyString failed " + e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_AdminCommand_SetEnable_Invalid_Value_Negative : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    CommonUtils.SetWatcherEnabled(true);
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    Hashtable args = new Hashtable();
                    args["op"] = "WatcherSetEnable";
                    args["p1"] = "-1";
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        if (!CommonUtils.IsWatcherEnabledValue(true))
                        {
                            throw new Exception("N_AdminCommand_SetEnable_Invalid_Value_Negative failed as the command modified the enable status");
                        }
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_AdminCommand_SetEnable_Invalid_Value_Negative test passed");
                    }
                    else
                    {
                        throw new Exception("N_AdminCommand_SetEnable_Invalid_Value_Negative Test Failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_AdminCommand_SetEnable_Invalid_Value_Negative test failed "+e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_AdminCommand_SetEnable_Invalid_Value_String : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    CommonUtils.SetWatcherEnabled(true);
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    Hashtable args = new Hashtable();
                    args["op"] = "WatcherSetEnable";
                    args["p1"] = "abrakadabra";
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        if (!CommonUtils.IsWatcherEnabledValue(true))
                        {
                            throw new Exception("N_AdminCommand_SetEnable_Invalid_Value_String failed as the command modified the enable status");
                        }
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_AdminCommand_SetEnable_Invalid_Value_String test passed");
                    }
                    else
                    {
                        throw new Exception("N_AdminCommand_SetEnable_Invalid_Value_String Test Failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_AdminCommand_SetEnable_Invalid_Value_String test failed " + e);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_AdminCommand_SetEnable_MissingOpParam : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "WatcherSetEnable";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_AdminCommand_SetEnable_MissingOpParam passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_AdminCommand_SetEnable_MissingOpParam failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_AdminCommand_SetEnable_MissingOpParam failed " + e);
                }
            }
        }


        [TestCase, TestCasePriority(2)]
        public class N_AdminCommand_SetEnable_MultipleValues : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    Hashtable args = new Hashtable();
                    args["op"] = "WatcherSetEnable";
                    args["p1"] = "1.0";
                    UserCommandHandler handler = new UserCommandHandler();
                    StringBuilder sb = new StringBuilder();
                    HResult hr = handler.Command(args, sb);
                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        Global.RO.Info("N_AdminCommand_SetEnable_MultipleValues passed.");
                        return;
                    }
                    else
                    {
                        Global.RO.Error("N_AdminCommand_SetEnable_MultipleValues failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_AdminCommand_SetEnable_MultipleValues failed " + e);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\ConnectionManager.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Diagnostics;
using xonline.common.config;

namespace Marketplace.Test.Common.Service
{
    /// <summary>
    /// This is a base class to manage the sql connections needed for testing.
    /// Instead of each test opening their own connection to the database, this
    /// will maintain a single connection for all tests to use.  It's abstract
    /// so we can have multiple derived classes that connect to different databases.
    /// </summary>
    public abstract class ConnectionManager
    {
        protected SqlConnection connection;
        public SqlCommand command;
        public SqlDataReader reader;

        public ConnectionManager() 
        {
            connection = null;
            reader = null;
        }

        ~ConnectionManager()
        {

        }

        protected abstract void Connect();

        protected void CreateCommand()
        {
            if (null != connection)
            {
                command = connection.CreateCommand();
                command.CommandTimeout = 300;
            }
            else
            {
                Debug.Assert(false, "ConnectionManager error: Couldn't create a command because of a null connection.");
            }
        }

        public bool IsClosed
        {
            get
            {
                if (null == reader ||
                   reader.IsClosed)
                {
                    return true;
                }

                return false;
            }
        }

        public void ExecuteNonQuery(string commandText)
        {
            if (null != reader && !reader.IsClosed)
                reader.Close();

            command.CommandText = commandText;
            command.ExecuteNonQuery();
        }

        public List< string[] > ExecuteQueryGetMultiple(string commandText)
        {
            command.CommandText = commandText;

            if (null != reader && !reader.IsClosed)
                reader.Close();

            reader = command.ExecuteReader();

            int columns = reader.FieldCount;

            //so far I haven't found an easy way to get a count
            //of the number of rows returned, so I'm using a containter
            //that can grow easily.
            List< string[] > queryResults = new List< string[] >();
            while (reader.Read())
            {
                List<string> row = new List<string>();
                for (int i = 0; i < columns; ++i)
                {
                    row.Add(reader[i].ToString());
                }

                queryResults.Add(row.ToArray());
            }

            reader.Close();

            return queryResults;
        }

        public string ExecuteQueryGetSingle(string commandText)
        {
            command.CommandText = commandText;

            if (null != reader && !reader.IsClosed)
                reader.Close();

            reader = command.ExecuteReader();

            string queryResult = null;

            if (reader.HasRows)
            {
                reader.Read();
                queryResult = reader[0].ToString();
            }

            return queryResult;
        }

        public List<string> ExecuteQueryGetSingleColumn(string commandText)
        {
            List<string> output = new List<string>();

            command.CommandText = commandText;

            if (null != reader && !reader.IsClosed)
                reader.Close();

            reader = command.ExecuteReader();

            if (reader.HasRows)
            {
                while (reader.Read())
                {
                    output.Add(reader[0].ToString());
                }
            }

            return output;

        }

        public int ExecuteQueryGetSingleInt(string commandText)
        {
            command.CommandText = commandText;

            if (null != reader && !reader.IsClosed)
                reader.Close();

            reader = command.ExecuteReader();

            string queryResult = null;

            if (reader.HasRows)
            {
                reader.Read();
                queryResult = reader[0].ToString();
            }

            return Convert.ToInt32(queryResult);
        }

        public string ExecuteQueryGetSingleValue(string commandText, string columnName)
        {
            command.CommandText = commandText;

            if (null != reader && !reader.IsClosed)
                reader.Close();

            reader = command.ExecuteReader();

            string queryResult = null;

            if (reader.HasRows)
            {
                reader.Read();

                queryResult = reader.GetValue(reader.GetOrdinal(columnName)).ToString();
            }

            return queryResult;
        }

        public void CloseConnection()
        {
            if (null != reader && !reader.IsClosed)
                reader.Close();

            connection.Close();
        }
    }


    public class CMRawCatalogDB : ConnectionManager
    {
        public CMRawCatalogDB()
        {
            Connect();
            CreateCommand();
        }

        protected override void Connect()
        {
            connection = new SqlConnection(Config.GetSingleInterface(Interface.ContentIngestionCatalogDB).SqlConnectionString);
            
            connection.Open();
        }

        public void WaitForTransferJobIdle()
        {
            string jobSproc = "EXEC msdb..sp_help_job @job_name='TransferCDCDataSQLJob', @job_aspect=N'job'";
            while (ExecuteQueryGetSingleValue(jobSproc, "current_execution_status") != "4") //4 = idle
            {
                Thread.Sleep(1000); //wait one second and try again
            }
        }

        public void StopTransferJob()
        {
            string jobSproc = "EXEC msdb..sp_help_job @job_name='TransferCDCDataSQLJob', @job_aspect=N'job'";
            //if active, shut it down (1, 2, 3 are active states)
            if (Convert.ToInt32(ExecuteQueryGetSingleValue(jobSproc, "current_execution_status")) <= 3)
            {
                ExecuteNonQuery("EXEC msdb..sp_stop_job @job_name='TransferCDCDataSQLJob'");
            }
        }

    }

    // [JKONKLE]  I didn't look to see who uses this class.  I just updated the Connect() method, 
    // which will not be appropriate if consumers of this class try to manipulate configdb data.
    public class CMNPDB : ConnectionManager
    {
        public CMNPDB()
        {
            Connect();
            CreateCommand();
        }

        protected override void Connect()
        {
            connection = new SqlConnection(Config.GetSingleInterface(Interface.npdb).SqlConnectionString);
            connection.Open();
        }
    }
} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\CommonUtils.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Net;
using System.Threading;

using xonline.common.sql.sqlclient;
using xonline.common.mgmt;
using System.Xml;
using xonline.server.catalogwatcher;
using xonline.common.config;
using xonline.common.service;

using ServerTestFramework;
using ServerTestFramework.LiveService;


namespace xonline.server.marketplace.test
{
    public class CommonUtils
    {
        public static void CleanupToDoTable()
        {

            using (SqlClient sqlMasterClient = new SqlClient(Interface.ContentIngestionCatalogDB, false))
            {
                sqlMasterClient.Command.CommandText = "delete from cdc.dbo_media_CT; delete from cdc.dbo_MediaUserRatingAggregate_CT; delete from cdc.dbo_UsageAggregateFromReporting_CT";
                sqlMasterClient.Command.CommandType = System.Data.CommandType.Text;
                sqlMasterClient.ExecuteNonQuery();
            }

            using (SqlClient sqlMasterClient = new SqlClient(Interface.ContentIngestionCatalogDB, false))
            {
                sqlMasterClient.Command.CommandText = "delete from dbo.CatalogWatcherToDoProduct";
                sqlMasterClient.Command.CommandType = System.Data.CommandType.Text;
                sqlMasterClient.ExecuteNonQuery();
            }
        }

        public static List<MediaIdLcid> GetMediaFromAggregate(int count)
        {
            List<MediaIdLcid> list = new List<MediaIdLcid>();
            using (SqlClient sqlReplicaClient = new SqlClient(VirtualInterface.fecatalogdbxbox, true))
            {
                string cmd = String.Format("select top {0} ra.mediaId as [mediaId], l.lcid as [lcid] from MediaUserRatingAggregate as ra JOIN Locale l on ra.countryCode = l.countryCode", count);
                sqlReplicaClient.Command.CommandText = cmd;
                sqlReplicaClient.Command.CommandType = System.Data.CommandType.Text;
                using (SqlDataReader r = sqlReplicaClient.Execute())
                {
                    while (r.Read())
                    {
                        Guid mediaId = r.GetGuid(r.GetOrdinal("mediaId"));
                        int lcid = r.GetInt32(r.GetOrdinal("lcid"));
                        MediaIdLcid MediaIdLcid = new MediaIdLcid(null, mediaId, lcid);
                        list.Add(MediaIdLcid);
                    }
                }
            }
            return list;
        }

        public static List<MediaIdLcid> GetMediaFromMediaTable(int i, List<Guid> distinctMediaIds)
        {
            List<MediaIdLcid> list = new List<MediaIdLcid>();
            Guid prevGuid = Guid.Empty;
            using (SqlClient sqlReplicaClient = new SqlClient(VirtualInterface.fecatalogdbxbox, true))
            {
                string cmd = String.Format("DECLARE @MediaTypeCatalogWatcherEnabled TABLE(MediaTypeId INT) "+
                                            "INSERT INTO @MediaTypeCatalogWatcherEnabled EXEC CatalogWatcherMediaTypes "+
                                            "select m.mediaId as [mediaId] , mlm.lcid as [lcid] from Media m "+
                                            "join MediaLocaleMap mlm on mlm.mediaId = m.mediaId "+
                                            "WHERE m.mediaTypeId in "+
                                            "(SELECT mediaTypeId FROM @MediaTypeCatalogWatcherEnabled) "+
                                            "AND m.mediaId in (select distinct {0} mediaId FROM Media where mediaTypeId in (SELECT mediaTypeId FROM @MediaTypeCatalogWatcherEnabled) ) "+
                                            "order by m.mediaId ", (i == 0) ? "" : ("top " + i));
                sqlReplicaClient.Command.CommandText = cmd;
                sqlReplicaClient.Command.CommandType = System.Data.CommandType.Text;
                using (SqlDataReader r = sqlReplicaClient.Execute())
                {
                    while (r.Read())
                    {
                        Guid mediaId = r.GetGuid(r.GetOrdinal("mediaId"));
                        int lcid = r.GetInt32(r.GetOrdinal("lcid"));
                        MediaIdLcid MediaIdLcid = new MediaIdLcid(null, mediaId, lcid);
                        list.Add(MediaIdLcid);
                        if(!prevGuid.Equals(mediaId))
                        {
                            distinctMediaIds.Add(mediaId);
                            prevGuid = mediaId;
                        }
                    }
                }
            }
            return list;
        }

        public static List<MediaIdLcid> GetMediaLcidFromToDoTable()
        {
            List<MediaIdLcid> list = new List<MediaIdLcid>();
            using (SqlClient sqlReplicaClient = new SqlClient(VirtualInterface.fecatalogdbxbox, true))
            {
                string cmd = String.Format("select mediaId,lcid,__$start_lsn,__$seqval from CatalogWatcherToDoProduct order by mediaId");
                sqlReplicaClient.Command.CommandText = cmd;
                sqlReplicaClient.Command.CommandType = System.Data.CommandType.Text;
                using (SqlDataReader r = sqlReplicaClient.Execute())
                {
                    while (r.Read())
                    {
                        Guid mediaId = r.GetGuid(r.GetOrdinal("mediaId"));
                        int lcid = r.GetInt32(r.GetOrdinal("lcid"));
                        MediaIdLcid MediaIdLcid = new MediaIdLcid(null, mediaId, lcid);
                        list.Add(MediaIdLcid);
                    }
                }
            }
            return list;
        }

        public static void UpdateMediaLCID(List<MediaIdLcid> list)
        {
            // Update each media, in order, and each in a separate statement such that the order that
            // the records go into the CDC tables is the order that they are in the list provided.
            foreach (MediaIdLcid mediaIdLcid in list)
            {
                using (SqlClient sqlMasterClient = new SqlClient(Interface.ContentIngestionCatalogDB, false))
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append("update dbo.MediaUserRatingAggregate set modifiedDate = GETUTCDATE() FROM dbo.MediaUserRatingAggregate as ra JOIN Locale l on ra.countryCode = l.countryCode where ");
                    sb.Append("(ra.mediaId = '" + mediaIdLcid.MediaId + "' and l.lcid = " + mediaIdLcid.Lcid + " ) ");
                    sqlMasterClient.Command.CommandText = sb.ToString();
                    sqlMasterClient.Command.CommandType = System.Data.CommandType.Text;
                    sqlMasterClient.ExecuteNonQuery();
                }
            }
        }

        public static void SetWatcherEnabled(bool setEnable)
        {
            using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
            {
                string cmd = "UPDATE t_cron_jobs SET b_enabled = " + ((setEnable) ? "1" : "0") +
                    " WHERE vc_assembly = 'CatalogWatcherPlugin.dll'";

                sqlClient.Command.CommandText = cmd.ToString();
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.ExecuteNonQuery();

            }
        }

        public static bool IsWatcherEnabledValue(bool enabled)
        {
            bool retVal = false;           
            using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
            {
                string cmd = "select b_enabled as [Enabled] from t_cron_jobs where vc_assembly = 'CatalogWatcherPlugin.dll'";
                sqlClient.Command.CommandText = cmd;
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                using (SqlDataReader r = sqlClient.Execute())
                {
                    while (r.Read())
                    {
                        int i = (int) (r.GetByte(r.GetOrdinal("Enabled")));
                        retVal = ((enabled) ? (i >= 1) : (i == 0));
                        if (!retVal)
                        {
                            break;
                        }
                    }
                }
            }
            return retVal;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\DocumentProducerUnitTests.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Net;
using System.Threading;

using xonline.common.sql.sqlclient;
using xonline.common.mgmt;
using System.Xml;
using xonline.server.catalogwatcher;
using xonline.common.config;
using xonline.common.service;

using ServerTestFramework;
using ServerTestFramework.LiveService;


namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("ripin"), TestFrequency("Check-In"), EnvRequirement("Watcher")]
    public class DocumentGeneratorUnitTests
    {
        [TestCase, TestCasePriority(1)]
        public class P_NoDocumentsChanged: TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    CommonUtils.CleanupToDoTable();                    
                    IWatcherDocumentProducer producer = new MediaDocumentProducer();
                    producer.Init(0, 1);
                    IEnumerable<IWatcherDocument> docs = producer.GetNextBatchOfDocuments(100);
                    int actualBatchSize = 0;
                    foreach (IWatcherDocument doc in docs)
                    {
                        actualBatchSize++;
                    }
                    if (actualBatchSize != 0)
                    {
                        throw new Exception("Count is not zero: " + actualBatchSize);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("NoDocumentsChanged Failed: "+e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        public class DocumentsChanged : TestBase
        {
            protected void RunTest(string testName, int totalDocCount, int batchSize)
            {
                String virtualCollectionName = Config.GetSetting("catalogwatcher_fast_esp_virtual_collection_name");

                testName = "DocumentsChanged_" + testName;
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    CommonUtils.CleanupToDoTable();
                    List<MediaIdLcid> list = CommonUtils.GetMediaFromAggregate(totalDocCount);
                    CommonUtils.UpdateMediaLCID(list);
                    Thread.Sleep(61000);
                    IWatcherDocumentProducer producer = new MediaDocumentProducer();
                    producer.Init(0, 1);
                    int i = 0;
                    LSN prevLSN = new LSN("0");
                    while(true)
                    {                        
                        IEnumerable<IWatcherDocument> docs = producer.GetNextBatchOfDocuments(batchSize);

                        int actualBatchSize = 0;
                        foreach (IWatcherDocument d in docs)
                        {
                            actualBatchSize++;
                            MediaDocument doc = (MediaDocument)d;
                            String expectedDocumentId = list[i].MediaId.ToString() + "_" + list[i].Lcid.ToString();
                            if ( !String.IsNullOrEmpty( virtualCollectionName ))
                            {
                                expectedDocumentId = expectedDocumentId + "_" + virtualCollectionName;
                            }
                            if (doc.DocumentId != expectedDocumentId )
                            {
                                throw new Exception(String.Format("Not equal ids. Id was [{0}] expected [{1}]", doc.DocumentId, expectedDocumentId ));
                            }
                            if (doc.LSN.CompareTo(prevLSN) < 0)
                            {
                                throw new Exception("LSN not monotically increasing");
                            }
                            prevLSN = doc.LSN;
                            i++;
                        }

                        if (actualBatchSize == 0)
                        {
                            break;
                        }
                    }
                    if (i != list.Count)
                    {
                        throw new Exception(String.Format( "Not all documents generated - expected {0} but found {1}", list.Count, i ));
                    }
                    Global.RO.Info(testName + " passed.");
                }
                catch (Exception e)
                {
                    Global.RO.Error(testName+ " failed!!! "+e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_LessThanBatchSize : DocumentsChanged
        {
            protected override void Execute()
            {
                RunTest("LessThanBatchSize", 3, 5);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_EqualToBatchSize : DocumentsChanged
        {
            protected override void Execute()
            {
                RunTest("EqualToBatchSize", 3, 3);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_GreaterThanBatchSize : DocumentsChanged
        {
            protected override void Execute()
            {
                RunTest("GreaterThanBatchSize", 10, 4);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class P_BucketTests : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    String virtualCollectionName = Config.GetSetting("catalogwatcher_fast_esp_virtual_collection_name");

                    CommonUtils.CleanupToDoTable();
                    List<MediaIdLcid> listAll = CommonUtils.GetMediaFromAggregate(20);
                    CommonUtils.UpdateMediaLCID(listAll);
                    List<MediaIdLcid> list0 = new List<MediaIdLcid>();
                    List<MediaIdLcid> list1 = new List<MediaIdLcid>();
                    foreach(MediaIdLcid id in listAll)
                    {
                        if(Math.Abs(id.MediaId.GetHashCode()) % 2 == 0)
                        {
                            list0.Add(id);                        
                        }
                        else
                        {
                            list1.Add(id);
                        }
                    }
                    
                    Thread.Sleep(61000);                                       
                    
                    IWatcherDocumentProducer producer0 = new MediaDocumentProducer();
                    producer0.Init(0, 2);
                    IWatcherDocumentProducer producer1 = new MediaDocumentProducer();
                    producer1.Init(1, 2);
                                        
                    int totalAll = 0;
                    int total0 = 0;
                    int total1 = 0;
                    LSN prevLSN = new LSN("0");
                    
                    while(true)
                    {                        
                        IEnumerable<IWatcherDocument> docs = producer0.GetNextBatchOfDocuments(1);

                        int actualBatchSize = 0;
                        foreach (IWatcherDocument d in docs)
                        {
                            actualBatchSize++;
                            MediaDocument doc = (MediaDocument)d;
                            String expectedDocumentId = list0[total0].MediaId.ToString() + "_" + list0[total0].Lcid.ToString();
                            if (!String.IsNullOrEmpty(virtualCollectionName))
                            {
                                expectedDocumentId = expectedDocumentId + "_" + virtualCollectionName;
                            }
                            if (doc.DocumentId != expectedDocumentId)
                            {
                                throw new Exception(String.Format("Not equal ids. Expected [{0}] but got [{1}]", expectedDocumentId, doc.DocumentId ));
                            }
                            if (doc.LSN.CompareTo(prevLSN) < 0)
                            {
                                throw new Exception("LSN not monotically increasing");
                            }
                            prevLSN = doc.LSN;
                            total0++;
                            totalAll++;
                        }

                        if (actualBatchSize == 0)
                        {
                            break;
                        }
                    }
                    
                    if (total0 != list0.Count)
                    {
                        throw new Exception("Not all 0 documents generated");
                    }                    
                    
                    prevLSN = new LSN("0");
                    
                    while(true)
                    {                        
                        IEnumerable<IWatcherDocument> docs = producer1.GetNextBatchOfDocuments(1);

                        int actualBatchSize = 0;
                        foreach (IWatcherDocument d in docs)
                        {
                            actualBatchSize++;
                            MediaDocument doc = (MediaDocument)d;
                            String expectedDocumentId = list1[total1].MediaId.ToString() + "_" + list1[total1].Lcid.ToString();
                            if (!String.IsNullOrEmpty(virtualCollectionName))
                            {
                                expectedDocumentId = expectedDocumentId + "_" + virtualCollectionName;
                            }
                            if (doc.DocumentId != expectedDocumentId)
                            {
                                throw new Exception(String.Format("Not equal ids. Expected [{0}] but got [{1}]", expectedDocumentId, doc.DocumentId));
                            }
                            if (doc.LSN.CompareTo(prevLSN) < 0)
                            {
                                throw new Exception("LSN not monotically increasing");
                            }
                            prevLSN = doc.LSN;
                            total1++;
                            totalAll++;
                        }
                        if (actualBatchSize == 0)
                        {
                            break;
                        }
                    }
                    
                    if (total1 != list1.Count)
                    {
                        throw new Exception("Not all 1 documents generated");
                    }                    
                    
                    if (totalAll != listAll.Count)
                    {
                        throw new Exception("Not all documents generated");
                    }
                    
                    Global.RO.Info("BucketTests passed.");
                }
                catch (Exception e)
                {
                    Global.RO.Error("BucketTests failed!!! "+e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }


        [TestCase, TestCasePriority(2)]
        public class N_ZeroMaxDocuments : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    IWatcherDocumentProducer producer = new MediaDocumentProducer();
                    producer.Init(0, 1);
                    producer.GetNextBatchOfDocuments(0);
                    Global.RO.Error("ZeroMaxDocuments failed!!! No exception thrown");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_GENERATE_DOCUMENTS_INVALID_COUNT)
                    {
                        Global.RO.Info("ZeroMaxDocuments passed.");
                    }
                    else
                    {
                        Global.RO.Error("ZeroMaxDocuments failed!!! " + xe);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("ZeroMaxDocuments failed!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_LessThanZeroMaxDocuments : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    IWatcherDocumentProducer producer = new MediaDocumentProducer();
                    producer.Init(0, 1);
                    producer.GetNextBatchOfDocuments(-1);
                    Global.RO.Error("ZeroMaxDocuments failed!!! No Exception thrown");
                    ResultCode = TEST_RESULTS.FAILED;

                }
                catch (XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_GENERATE_DOCUMENTS_INVALID_COUNT)
                    {
                        Global.RO.Info("ZeroMaxDocuments passed.");
                    }
                    else
                    {
                        Global.RO.Error("ZeroMaxDocuments failed!!! "+xe);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("ZeroMaxDocuments failed!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_UninitializedProducerTest : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    IWatcherDocumentProducer producer = new MediaDocumentProducer();
                    producer.GetNextBatchOfDocuments(10);
                    Global.RO.Error("UninitializedProducerTest failed!!! No Exception thrown");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_INVALID_STATE)
                    {
                        Global.RO.Info("UninitializedProducerTest passed.");
                    }
                    else
                    {
                        Global.RO.Error("UninitializedProducerTest failed!!! " + xe);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("UninitializedProducerTest failed!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_InitializedWithIncorrectBucketId : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    IWatcherDocumentProducer producer = new MediaDocumentProducer();
                    producer.Init(-1, 1);
                    Global.RO.Error("InitializedWithIncorrectBucketId failed!!! No Exception thrown");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY)
                    {
                        Global.RO.Info("InitializedWithIncorrectBucketId passed.");
                    }
                    else
                    {
                        Global.RO.Error("InitializedWithIncorrectBucketId failed!!! " + xe);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("InitializedWithIncorrectBucketId failed!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_InitializedWithIncorrectBucketCount : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    IWatcherDocumentProducer producer = new MediaDocumentProducer();
                    producer.Init(0, 0);
                    Global.RO.Error("InitializedWithIncorrectBucketCount failed!!! No Exception thrown");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY)
                    {
                        Global.RO.Info("InitializedWithIncorrectBucketCount passed.");
                    }
                    else
                    {
                        Global.RO.Error("InitializedWithIncorrectBucketCount failed!!! " + xe);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("InitializedWithIncorrectBucketCount failed!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }


        [TestCase, TestCasePriority(2)]
        public class N_InitializedWithBucketIdGreaterThanBucketCount : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    IWatcherDocumentProducer producer = new MediaDocumentProducer();
                    producer.Init(2, 1);
                    Global.RO.Error("InitializedWithBucketIdGreaterThanBucketCount failed!!! No Exception thrown");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY)
                    {
                        Global.RO.Info("InitializedWithBucketIdGreaterThanBucketCount passed.");
                    }
                    else
                    {
                        Global.RO.Error("InitializedWithBucketIdGreaterThanBucketCount failed!!! " + xe);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("InitializedWithBucketIdGreaterThanBucketCount failed!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\DocumentsQueueUnitTests.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Net;
using System.Threading;

using xonline.common.sql.sqlclient;
using xonline.common.mgmt;
using System.Xml;
using xonline.server.catalogwatcher;
using xonline.common.config;
using xonline.common.service;

using ServerTestFramework;
using ServerTestFramework.LiveService;


namespace xonline.server.marketplace.test
{

    public class QueueTestDocument : IWatcherDocument        
    {
        int _id;
        public QueueTestDocument(int id)
        {
            _id = id;
        }
        // The unique Id that identifies the document
        public string DocumentId { get {return _id.ToString();} }
        // The actual document that gets generated and published
        public Object Document { get {return _id;} }        
            
    }

    [TestGroup, Owner("ripin"), TestFrequency("Check-In"), EnvRequirement("Watcher")]
    public class QueueUnitTests
    {
        [TestGroupSetup]
        public void Setup() { }
        [TestGroupTearDown]
        public void Shutdown() { }

        public const int c_queueMaxLength = 5;

        [TestCase, TestCasePriority(1)]
        public class ZeroQueueLength : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    using (DocumentsQueue queue = new DocumentsQueue(0))
                    {
                        Global.RO.Error("Zero Length Test FAILED!!!");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (XRLException)
                {
                    Global.RO.Info("Zero Length Test passed");
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        public class AddNullObjectTest : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    using (DocumentsQueue queue = new DocumentsQueue(c_queueMaxLength))
                    {
                        queue.Enqueue(null);
                    }
                }
                catch (XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_NULL_DOCUMENT_IN_QUEUE)
                    {
                        Global.RO.Info("AddNullObject test passed.");
                    }
                    else
                    {
                        Global.RO.Error("AddNullObjectTest test FAILED!!!" + xe);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("AddNullObjectTest test FAILED!!!" + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }

            }
        }

        [TestCase, TestCasePriority(1)]
        public class SimpleAddRemoveTest : TestBase
        {
            DocumentsQueue queue = new DocumentsQueue(c_queueMaxLength);
            private void ThreadProc1(object o)
            {
                Thread.Sleep(5000);
                DocumentsQueue queue = (DocumentsQueue)o;
                queue.Shutdown();
            }

            protected override void Execute()
            {
                int i = 0;
                int j = 0;
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    QueueTestDocument doc = null;
                    for (; i < c_queueMaxLength; i++)
                    {
                        doc = new QueueTestDocument(i);
                        queue.Enqueue(doc);
                    }
                    ThreadPool.QueueUserWorkItem(new WaitCallback(ThreadProc1), queue);
                    while (true)
                    {
                        doc = (QueueTestDocument)queue.Dequeue();
                        if (doc == null)
                        {
                            break;
                        }
                        if (doc.DocumentId != j.ToString())
                        {
                            throw new Exception("Incorrect order");
                        }
                        j++;
                    }
                    if (i != j)
                    {
                        throw new Exception("Incorrect count");
                    }
                    Global.RO.Info("SimpleAddRemove Test passed");
                }
                catch (Exception e)
                {
                    Global.RO.Error("SimpleAddRemove Test FAILED!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        public class ThreadingTestsBase: TestBase 
        {
            public AutoResetEvent blockEvent = new AutoResetEvent(false);
            public DocumentsQueue queue;
            public int size;

            public ThreadingTestsBase()
            {
                size = c_queueMaxLength;
                queue = new DocumentsQueue(size);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class TestRemoveCallBlockUnblock : ThreadingTestsBase
        {
            public static void ThreadProc1(object o)
            {
                TestRemoveCallBlockUnblock t = o as TestRemoveCallBlockUnblock;
                t.DequeueVerifier();
            }

            public void DequeueVerifier()
            {
                try
                {
                    if (queue.Count != 0)
                    {
                        throw new Exception("queue not empty");
                    }
                    bool bReceivedSignal = blockEvent.WaitOne(5000, false);
                    if (bReceivedSignal)
                    {
                        throw new Exception("Did not block");
                    }
                    queue.Enqueue(new QueueTestDocument(0));
                    bReceivedSignal = blockEvent.WaitOne(5000, false);
                    if (!bReceivedSignal)
                    {
                        throw new Exception("Did not dequeue");
                    }
                    Global.RO.Info("TestRemoveCallBlockUnblock test passed");
                }
                catch (Exception e)
                {
                    Global.RO.Error("TestRemoveCallBlockUnblock Test FAILED!!! "+e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }

            protected override void  Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    ThreadPool.QueueUserWorkItem(ThreadProc1, this);
                    IWatcherDocument doc = queue.Dequeue();
                    blockEvent.Set();
                    if (doc.DocumentId != "0")
                    {
                        throw new Exception("Incorrect document returned");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("TestRemoveCallBlockUnblock test FAILED !!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }

        }

        [TestCase, TestCasePriority(1)]
        public class TestAddCallBlockUnblock : ThreadingTestsBase
        {
            public static void ThreadProc1(object o)
            {
                TestAddCallBlockUnblock t = o as TestAddCallBlockUnblock;
                t.EnqueueVerifier();
            }

            public void EnqueueVerifier()
            {
                try
                {
                    if (queue.Count != size)
                    {
                        throw new Exception("queue not full");
                    }
                    bool bSignalRecieved = blockEvent.WaitOne(5000, false);
                    if (bSignalRecieved)
                    {
                        throw new Exception("Did not block!!!");
                    }
                    queue.Dequeue();
                    bSignalRecieved = blockEvent.WaitOne(10000, false);
                    if (!bSignalRecieved)
                    {
                        throw new Exception("Did not dequeue");
                    }
                    Global.RO.Info("TestAddCallBlockUnblock Test Passed");
                }
                catch(Exception e)
                {
                    Global.RO.Error("TestAddCallBlockUnblock Test FAILED!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }

            protected override void Execute()
            {
                int i = 0;
                QueueTestDocument doc = null;
                ResultCode = TEST_RESULTS.PASSED;
                for (; i < size + 1; i++)
                {
                    doc = new QueueTestDocument(i);
                    if (i == size)
                    {
                        ThreadPool.QueueUserWorkItem(ThreadProc1, this);                        
                    }
                    queue.Enqueue(doc);
                    if (i >= size)
                    {
                        blockEvent.Set();
                    }
                }                
            }

        }

        [TestCase, TestCasePriority(1)]
        public class AddBeforeConsumerCallsDequeue : ThreadingTestsBase
        {
            private void ThreadProc1(object o)
            {
                try
                {
                    QueueTestDocument doc = (QueueTestDocument)queue.Dequeue();
                    if (doc.DocumentId != "1")
                    {
                        throw new Exception("Tests AddBeforeConsumerCallsDequeue failed to retrieve document 1");
                    }
                    Global.RO.Info("AddBeforeConsumerCallsDequeue: Got document 1");
                    doc = (QueueTestDocument)queue.Dequeue();
                    if (doc.DocumentId != "2")
                    {
                        throw new Exception("Tests AddBeforeConsumerCallsDequeue failed to retrieve document 2");
                    }
                    Global.RO.Info("AddBeforeConsumerCallsDequeue: Got document 2");
                    Global.RO.Info("AddBeforeConsumerCallsDequeue Test Passed");
                }
                catch (Exception e)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    Global.RO.Error("AddBeforeConsumerCallsDequeue Test FAILED!!! " + e);
                }

            }

            protected override void Execute()
            {                                
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    queue.Enqueue(new QueueTestDocument(1));
                    ThreadPool.QueueUserWorkItem(new WaitCallback(ThreadProc1));
                    Thread.Sleep(5000);
                    queue.Enqueue(new QueueTestDocument(2));
                }
                catch (Exception e)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    Global.RO.Error("AddBeforeConsumerCallsDequeue Test FAILED!!! " + e);
                }

            }
        }


        public class ShutdownTests: TestBase
        {
            public AutoResetEvent blockEvent = new AutoResetEvent(false);
            public DocumentsQueue queue;
            public int size;

            public ShutdownTests()
            {
                size = c_queueMaxLength;
                queue = new DocumentsQueue(size);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class ShutdownByProducerQueueEmpty: ShutdownTests
        {

            public static void ThreadProc1(object o)
            {
                ShutdownByProducerQueueEmpty test = o as ShutdownByProducerQueueEmpty;
                test.ShutdownProc();
            }

            public void ShutdownProc()
            {
                try
                {
                    // Sleep so that we can yield control to the other thread
                    Thread.Sleep(3000);
                    if (queue.Count != 0)
                    {
                        throw new Exception("Queue not empty");
                    }
                    queue.Shutdown();
                }
                catch (Exception e)
                {
                    Global.RO.Error("ShutdownByProducerQueueEmpty test FAILED!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ThreadPool.QueueUserWorkItem(ThreadProc1, this);
                try
                {
                    QueueTestDocument doc = (QueueTestDocument)queue.Dequeue();
                    if (doc != null)
                    {
                        throw new Exception("Document returned is not null");
                    }
                    Global.RO.Info("ShutdownByProducerQueueEmpty test passed.");
                }
                catch (Exception e)
                {
                    Global.RO.Error("ShutdownByProducerQueueEmpty test FAILED!!! "+e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                
            }

        }

        [TestCase, TestCasePriority(1)]
        public class ShutdownByPublisherQueueEmpty : ShutdownTests
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    queue.Shutdown();
                    bool bAdded = queue.Enqueue(new QueueTestDocument(0));
                    if (bAdded)
                    {
                        throw new Exception("Able to add to queue");
                    }
                    Global.RO.Info("ShutdownByPublisherQueueEmpty passed.");
                }
                catch (Exception e)
                {
                    Global.RO.Error("ShutdownByPublisherQueueEmpty FAILED!!! "+e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        public class ShutdownByPublisherQueueFull : ShutdownTests
        {
            public static void ThreadProc1(object o)
            {
                ShutdownByPublisherQueueFull test = o as ShutdownByPublisherQueueFull;
                test.ShutdownByPublisherQueueFullProc();
                
            }

            public void ShutdownByPublisherQueueFullProc()
            {
                try
                {                    
                    if (queue.Count != queue.MaxLength)
                    {
                        throw new Exception("Queue not full");
                    }
                    queue.Shutdown();
                }
                catch (Exception e)
                {
                    Global.RO.Error("ShutdownByProducerQueueEmpty test FAILED!!! " + e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    bool bAdded = false;
                    for (int i = 0; i < size + 1; i++)
                    {
                        QueueTestDocument doc = new QueueTestDocument(i);
                        if (i == size)
                        {
                            ThreadPool.QueueUserWorkItem(ThreadProc1, this);                            
                        }
                        bAdded = queue.Enqueue(doc);
                    }
                    if (bAdded)
                    {
                        throw new Exception("Able to add to a shutdown queue");
                    }
                    Global.RO.Info("ShutdownByPublisherQueueFull passed. ");
                }
                catch (Exception e)
                {
                    Global.RO.Error("ShutdownByPublisherQueueFull FAILED!!! "+e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        public class ShutdownByProducerQueueFull : ShutdownTests
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    int i = 0;
                    for (i = 0; i < size; i++)
                    {
                        queue.Enqueue(new QueueTestDocument(i));
                    }
                    queue.Shutdown();
                    i = 0;
                    while(true)
                    {
                        QueueTestDocument doc = (QueueTestDocument) queue.Dequeue();
                        if (doc == null)
                        {
                            break;
                        }
                        i++;
                    }
                    if (i != size)
                    {
                        throw new Exception("incorrect document count");
                    }
                    Global.RO.Info("ShutdownByProducerQueueFull passed");
                }
                catch (Exception e)
                {
                    Global.RO.Error("ShutdownByProducerQueueFull FAILED!!! "+e);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\DocumentStatusTests.cs ===
using System;
using System.Data;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Configuration;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;

using xonline.server.catalogwatcher;
using xonline.common.sql.sqlclient;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.LiveService;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("craigta"), TestFrequency("Check-In"), EnvRequirement("Watcher")]
    public class DocumentStatusTests
    {
        public class DocumentStatusTestDocument : ILSNDocument
        {
            String _id;
            String _document;
            LSN _lsn;

            public DocumentStatusTestDocument(String id, String document, LSN lsn)
            {
                _id = id;
                _document = document;
                _lsn = lsn;
            }
            // The unique Id that identifies the document
            public string DocumentId { get { return _id.ToString(); } }
            // The actual document that gets generated and published
            public Object Document { get { return _document; } }
            public LSN LSN { get { return _lsn; } set { _lsn = value; } }
        }

        [TestGroupSetup]
        public void Setup() { }

        [TestGroupTearDown]
        public void Shutdown() { }

        #region Helper Methods
        private static LSN RetrieveLsn(int bucketId, string destination, string resource)
        {
            LSN retVal = null;
            using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
            {
                sqlClient.Command.CommandText = String.Format("SELECT b_lsn_value, b_seq_value"
                                                            + " FROM t_catalog_watcher_status ws JOIN"
                                                            + " t_catalog_watcher_destination wd on ws.i_destination_id = wd.i_destination_id JOIN"
                                                            + " t_catalog_watcher_resource wr on ws.i_resource_id = wr.i_resource_id"
                                                            + " WHERE i_bucket_id = {0} AND vc_destination_name = '{1}' AND vc_resource_name = '{2}'",
                                                            bucketId, destination, resource);

                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                using (SqlDataReader reader = sqlClient.Execute())
                {
                    if (reader.Read())
                    {
                        byte[] lsn = reader.GetSqlBinary(reader.GetOrdinal("b_lsn_value")).Value;
                        byte[] seq = reader.GetSqlBinary(reader.GetOrdinal("b_seq_value")).Value;
                        retVal = new LSN(lsn, seq);
                    }

                    if (reader.Read())
                    {
                        throw new Exception("Only expected one value");
                    }
                }
            }

            return retVal;
        }

        private static void SetLsn(int bucketId, string destination, string resource, LSN lsn)
        {
            using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
            {
                sqlClient.StoredProc = "dbo.p_catalog_watcher_update_status";
                sqlClient.AddParameter("@i_bucket_id", bucketId);
                sqlClient.AddParameter("@vc_destination_name", destination);
                sqlClient.AddParameter("@vc_resource_name", resource);
                sqlClient.AddParameter("@b_lsn_value", lsn.Lsn);
                sqlClient.AddParameter("@b_seq_value", lsn.Seq);
                sqlClient.AddParameter(ParameterDirection.ReturnValue, "@returnValue", 0);

                sqlClient.Execute();

                // Check if update was success
                int returnValue = (int)sqlClient.Command.Parameters["@returnValue"].Value;

                if (returnValue != 1)
                {
                    throw new Exception("Could not update CatalogWatcherStatus, sql returned failure: " + returnValue);
                }
            }
        }
        #endregion


        #region Positive Test Cases

        [TestCase, TestCasePriority(1)]
        class Pos_Add_One_Document_Force_Commit : TestBase
        {
            public Pos_Add_One_Document_Force_Commit() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                LSN initialLsn = new LSN("1");
                SetLsn(1, "ESP", "Media", initialLsn);

                LSN lsn = new LSN("2");

                DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");             
                DocumentStatusTestDocument testDocument = new DocumentStatusTestDocument("1","document",lsn);
                ds.AddDocument(testDocument);
                ds.Commit();
                
                LSN lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(initialLsn) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database should not have changed");
                }

                ds.CommitAllProcessedDocuments();

                lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(lsn) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not updated after forcing the commit");
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        class Pos_Add_Two_Groups_Commit_Validate_Group_One_Updated : TestBase
        {
            public Pos_Add_Two_Groups_Commit_Validate_Group_One_Updated() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                LSN initialLsn = new LSN("1");
                SetLsn(1, "ESP", "Media", initialLsn);

                LSN lsn1 = new LSN("2");
                DocumentStatusTestDocument testDocument1Group1 = new DocumentStatusTestDocument("1", "document", lsn1);
                DocumentStatusTestDocument testDocument2Group1 = new DocumentStatusTestDocument("1", "document", lsn1);

                LSN lsn2 = new LSN("3");
                DocumentStatusTestDocument testDocument1Group2 = new DocumentStatusTestDocument("1", "document", lsn2);

                DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");

                ds.AddDocument(testDocument1Group1);
                ds.AddDocument(testDocument2Group1);
                ds.AddDocument(testDocument1Group2);
                ds.Commit();

                LSN lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(lsn1) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                }   
            }
        }

        [TestCase, TestCasePriority(1)]
        class Pos_Add_Two_Groups_ForceCommit_Validate_Group_Two_Updated : TestBase
        {
            public Pos_Add_Two_Groups_ForceCommit_Validate_Group_Two_Updated() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                LSN initialLsn = new LSN("1");
                SetLsn(1, "ESP", "Media", initialLsn);

                LSN lsn1 = new LSN("2");
                DocumentStatusTestDocument testDocument1Group1 = new DocumentStatusTestDocument("1", "document", lsn1);
                DocumentStatusTestDocument testDocument2Group1 = new DocumentStatusTestDocument("1", "document", lsn1);

                LSN lsn2 = new LSN("3");
                DocumentStatusTestDocument testDocument1Group2 = new DocumentStatusTestDocument("1", "document", lsn2);

                DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");

                ds.AddDocument(testDocument1Group1);
                ds.AddDocument(testDocument2Group1);
                ds.AddDocument(testDocument1Group2);
                ds.CommitAllProcessedDocuments();

                LSN lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(lsn2) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                } 
            }
        }

        [TestCase, TestCasePriority(1)]
        class Pos_Add_No_Document_Commit : TestBase
        {
            public Pos_Add_No_Document_Commit() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                LSN initialLsn = new LSN("1");
                SetLsn(1, "ESP", "Media", initialLsn);

                LSN originalLsnFromDb = RetrieveLsn(1, "ESP", "Media");

                DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");
                ds.Commit();
                ds.CommitAllProcessedDocuments();

                LSN afterCommitLsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (originalLsnFromDb.CompareTo(afterCommitLsnFromDb) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                } 
            }
        }

        [TestCase, TestCasePriority(1)]
        class Pos_Multiple_Document_Groups_Commit : TestBase
        {
            public Pos_Multiple_Document_Groups_Commit() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                LSN initialLsn = new LSN("1");
                SetLsn(1, "ESP", "Media", initialLsn);

                LSN lsn1 = new LSN("2");
                DocumentStatusTestDocument testDocument1Group1 = new DocumentStatusTestDocument("1", "document", lsn1);
                DocumentStatusTestDocument testDocument2Group1 = new DocumentStatusTestDocument("1", "document", lsn1);

                LSN lsn2 = new LSN("3");
                DocumentStatusTestDocument testDocument3Group2 = new DocumentStatusTestDocument("1", "document", lsn2);
                DocumentStatusTestDocument testDocument4Group2 = new DocumentStatusTestDocument("1", "document", lsn2);
                DocumentStatusTestDocument testDocument5Group2 = new DocumentStatusTestDocument("1", "document", lsn2);

                LSN lsn3 = new LSN("4");
                DocumentStatusTestDocument testDocument6Group3 = new DocumentStatusTestDocument("1", "document", lsn3);

                LSN lsn4 = new LSN("5");
                DocumentStatusTestDocument testDocument7Group4 = new DocumentStatusTestDocument("1", "document", lsn4);

                LSN lsn5 = new LSN("6");
                DocumentStatusTestDocument testDocument8Group5 = new DocumentStatusTestDocument("1", "document", lsn5);
                DocumentStatusTestDocument testDocument9Group5 = new DocumentStatusTestDocument("1", "document", lsn5);

                DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");
                ds.Commit();
                LSN lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(initialLsn) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                } 


                ds.AddDocument(testDocument1Group1);
                ds.Commit();
                lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(initialLsn) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                } 

                ds.AddDocument(testDocument2Group1);
                ds.AddDocument(testDocument3Group2);
                ds.Commit();
                lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(lsn1) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                }

                ds.AddDocument(testDocument4Group2);
                ds.AddDocument(testDocument5Group2);
                ds.AddDocument(testDocument6Group3);
                ds.Commit();
                lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(lsn2) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                }

                ds.AddDocument(testDocument7Group4);
                ds.AddDocument(testDocument8Group5);
                ds.AddDocument(testDocument9Group5);
                ds.Commit();
                lsnFromDb = RetrieveLsn(1, "ESP", "Media");

                if (lsnFromDb.CompareTo(lsn4) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                }
                
                ds.CommitAllProcessedDocuments();

                lsnFromDb = RetrieveLsn(1, "ESP", "Media");
                if (lsnFromDb.CompareTo(lsn5) != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new Exception("lsn from the database does not match what was expected");
                } 
            }
        }

        #endregion

        #region Negative Test Cases
        [TestCase, TestCasePriority(2)]
        class Neg_Bucket_Id_Negative : TestBase
        {
            public Neg_Bucket_Id_Negative() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    DocumentStatus ds = new DocumentStatus(-10, "ESP", "Media");
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_NEGATIVE_BUCKET)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Bucket_Id_Negative Test Failed!!!" + xe);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class Neg_Lsn_Not_Increasing : TestBase
        {
            public Neg_Lsn_Not_Increasing() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    LSN initialLsn = new LSN("1");
                    SetLsn(1, "ESP", "Media", initialLsn);

                    LSN lsn1 = new LSN("2");
                    DocumentStatusTestDocument testDocument1 = new DocumentStatusTestDocument("1", "document", lsn1);

                    LSN lsn2 = new LSN("1");
                    DocumentStatusTestDocument testDocument2 = new DocumentStatusTestDocument("1", "document", lsn2);

                    DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");                    
                    ds.AddDocument(testDocument1);
                    ds.AddDocument(testDocument2);

                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_INCORRECT_LSN_ORDER)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Lsn_Not_Increasing Test Failed!!!" + xe);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class Neg_Destination_Does_Not_Exist : TestBase
        {
            public Neg_Destination_Does_Not_Exist() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    LSN lsn = new LSN("1");
                    DocumentStatus ds = new DocumentStatus(1, "DoesNotExist", "Media");
                    DocumentStatusTestDocument testDocument = new DocumentStatusTestDocument("1", "document", lsn);
                    ds.AddDocument(testDocument);
                    ds.CommitAllProcessedDocuments();
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_UPDATE_LSN_FAILED)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Destination_Does_Not_Exist Test Failed!!!" + xe);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class Neg_Destination_Null : TestBase
        {
            public Neg_Destination_Null() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    LSN lsn = new LSN("1");
                    DocumentStatus ds = new DocumentStatus(1, null, "Media");
                    DocumentStatusTestDocument testDocument = new DocumentStatusTestDocument("1", "document", lsn);
                    ds.AddDocument(testDocument);
                    ds.CommitAllProcessedDocuments();
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Destination_Null Test Failed!!!" + xe);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class Neg_Resource_Does_Not_Exist : TestBase
        {
            public Neg_Resource_Does_Not_Exist() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    LSN lsn = new LSN("1");
                    DocumentStatus ds = new DocumentStatus(1, "ESP", "DoesNotExist");
                    DocumentStatusTestDocument testDocument = new DocumentStatusTestDocument("1", "document", lsn);
                    ds.AddDocument(testDocument);
                    ds.CommitAllProcessedDocuments();
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_UPDATE_LSN_FAILED)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Resource_Does_Not_Exist Test Failed!!!" + xe);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class Neg_Resource_Null : TestBase
        {
            public Neg_Resource_Null() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    LSN lsn = new LSN("1");
                    DocumentStatus ds = new DocumentStatus(1, "ESP", null);
                    DocumentStatusTestDocument testDocument = new DocumentStatusTestDocument("1", "document", lsn);
                    ds.AddDocument(testDocument);
                    ds.CommitAllProcessedDocuments();
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_INVALID_RESOURCE_NAME)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Resource_Null Test Failed!!!" + xe);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class Neg_Document_Invalid_LSN : TestBase
        {
            public Neg_Document_Invalid_LSN() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");
                    DocumentStatusTestDocument testDocument = new DocumentStatusTestDocument("1", "document", null);
                    ds.AddDocument(testDocument);
                    ds.CommitAllProcessedDocuments();
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_UPDATE_LSN_FAILED)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Document_Invalid_LSN Test Failed!!!" + xe);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class Neg_Document_Null : TestBase
        {
            public Neg_Document_Null() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");
                    ds.AddDocument(null);
                    ds.CommitAllProcessedDocuments();
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_NULL_DOCUMENT)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Document_Null Test Failed!!!" + xe);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class Neg_Document_Invalid : TestBase
        {
            public class WatcherDocument : IWatcherDocument
            {
                String _id;
                String _document;

                public WatcherDocument(String id, String document)
                {
                    _id = id;
                    _document = document;
                }
                // The unique Id that identifies the document
                public string DocumentId { get { return _id.ToString(); } }
                // The actual document that gets generated and published
                public Object Document { get { return _document; } }
            }

            public Neg_Document_Invalid() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    DocumentStatus ds = new DocumentStatus(1, "ESP", "Media");
                    WatcherDocument testDocument = new WatcherDocument("1", "document");
                    ds.AddDocument(testDocument);
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_NULL_DOCUMENT)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Document_Invalid Test Failed!!!" + xe);
                    }
                }
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\DocSprocTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using Marketplace.Test.Common.Service;
using System.Configuration;
using System.Xml;
using System.Xml.Schema;
using System.Security;
using System.IO;
using xonline.common.config;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("wirosas"), TestFrequency("Daily"), EnvRequirement("xblobonly")]
    class DocSprocTests
    {
        //Needed when executing the stored procedure.  Obtained from config file.
        private static string _xblobMachineName = "";

        //XSD validation error count
        private static int _errorCount = 0;

        //XSD validation error message
        private static string _errorMessage = "";

        //XSD file for all document types.  If we make multiple schemas more
        //specific to certain mediaTypes, we can add them in later.
        private static string _genericXsdFile = "Suites\\product.xsd";

        //Test data mediaIds for this set of tests.  
        private static string _gondMediaId = "66acd000-77fe-1000-9115-D802089D946D";
        private static string _arcadeMediaId = "66acd000-77fe-1000-9115-D80248653D40";
        private static string _indieGameMediaId = "66acd000-77fe-1000-9115-D80257CDEA84";
        private static string _xboxOriginalMediaId = "66acd000-77fe-1000-9115-D80210EA0A07";

        //These tests are concerned with validating the document's form, not so much with
        //validating its content.  That being said, we'll just be looking at EN-US docs.
        private static string _commonLcid = "1033";

        private static CMRawCatalogDB _catalogConnection = null;

        /// <summary>
        /// Event handler for schema validation errors.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public static void ValidationHandler(object sender,
                                     ValidationEventArgs args)
        {
            _errorMessage = _errorMessage + args.Message + "\r\n";
            _errorCount++;
        }

        #region SQLStrings
        private static string StringSelectMediaIdLcidPairsFromMedia(int mediaType)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("SELECT m.mediaId, ml.lcid");
            sb.AppendLine("FROM Media m");
            sb.AppendLine("JOIN MediaLocale ml ");
            sb.AppendLine("ON m.mediaId = ml.mediaId");
            sb.AppendLine(string.Format("WHERE m.mediaTypeId = {0}", mediaType));
            sb.AppendLine("ORDER BY m.mediaId");

            return sb.ToString();
        }

        private static string StringExecuteGetProductDocumentsStoredProc(List<string[]> mediaIdLcids)
        {
            StringBuilder sb = new StringBuilder();
            
            //Declare temporary variables
            sb.AppendLine("DECLARE @items dbo.OrderedMediaIdLcidTuples");
            sb.AppendLine("DECLARE @pdlcMediaTypes dbo.IntegerList");
            sb.AppendLine("DECLARE @ratableMediaTypes dbo.IntegerList");
            sb.AppendLine("DECLARE @userRatings_min_reviewCount int");

            //Insert into items
            sb.AppendLine("INSERT INTO @items (mediaId, lcid, position) VALUES");

            for (int i = 0; i < mediaIdLcids.Count; ++i)
            {
                sb.AppendFormat("( '{0}', {1}, {2} ),", mediaIdLcids[i][0], mediaIdLcids[i][1], i);
            }
            //if there's a trailing comma (which there should be), remove it.
            if (sb[sb.Length - 1] == ',')
                sb.Remove(sb.Length - 1, 1);

            //Insert into pdlcMediaTypes
            string[] pdlcMediaTypes = GetPdlcMediaTypes();
            sb.AppendLine("INSERT INTO @pdlcMediaTypes (i) VALUES ");
            foreach (string pmt in pdlcMediaTypes)
            {
                sb.AppendFormat("({0}),", pmt);
            }
            if (sb[sb.Length - 1] == ',')
                sb.Remove(sb.Length - 1, 1);

            //Insert into ratableMediaTypes
            string[] ratableMediaTypes = GetRatableMediaTypes();
            sb.AppendLine("INSERT INTO @ratableMediaTypes (i) VALUES ");
            foreach (string rmt in ratableMediaTypes)
            {
                sb.AppendFormat("({0}),", rmt);
            }
            if (sb[sb.Length - 1] == ',')
                sb.Remove(sb.Length - 1, 1);

            //Insert into userRatings_min_reviewCount
            string userRatings_min_reviewCount = GetUserRatingsMinReviewCount();
            sb.AppendLine(string.Format("SET @userRatings_min_reviewCount = {0}", userRatings_min_reviewCount));

            sb.AppendLine(string.Format("EXEC GetProductDocuments 1, @items, @pdlcMediaTypes, @ratableMediaTypes, @userRatings_min_reviewCount, '{0}'", 
                          _xblobMachineName));

            Global.RO.Info("SQL String: {0}", sb.ToString());

            return sb.ToString();
        }

        private static string StringExecuteGetProductDocumentsStoredProc(string mediaId, string lcid)
        {
            List<string[]> mediaIdLcids = new List<string[]>();
            string[] row = new string[] { mediaId, lcid.ToString() };
            mediaIdLcids.Add(row);

            return StringExecuteGetProductDocumentsStoredProc(mediaIdLcids);
        }

        private static string StringSelectTitleDescriptionFromMediaLocale(string mediaId, string lcid)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendFormat("SELECT title, description FROM MediaLocale WHERE mediaId = '{0}' AND lcid = {1}", mediaId, lcid);

            return sb.ToString();
        }

        private static string StringUpdateTitleDescription(string mediaId, string lcid, string title, string description)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("UPDATE MediaLocale SET");
            sb.AppendLine(string.Format("title='{0}',", title));
            sb.AppendLine(string.Format("description='{0}'", description));
            sb.AppendLine(string.Format("WHERE mediaId='{0}' AND lcid={1}", mediaId, lcid));

            return sb.ToString();
        }

        private static string StringMediaIdLcidInMediaLocaleExists(string mediaId, string lcid)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("SELECT COUNT(1) FROM MediaLocale WHERE ");
            sb.AppendFormat("mediaId='{0}' AND lcid={1}", mediaId, lcid);

            return sb.ToString();
        }

        private static string StringUpdateTitleDescription(string mediaId, string lcid, string titleAndDescription)
        {
            return StringUpdateTitleDescription(mediaId, lcid, titleAndDescription, titleAndDescription);
        } 
        #endregion

        /// <summary>
        /// Gets a list of random mediaId/lcids of a certain mediaType from the database.
        /// </summary>
        /// <param name="count">Number of random mediaIds to return</param>
        /// <returns></returns>
        private static List<string[]> GetRandomMediaIdLcids(int count, int mediaType)
        {
            //get all mediaIds
            List<string[]> allMediaIdLcids = _catalogConnection.ExecuteQueryGetMultiple(StringSelectMediaIdLcidPairsFromMedia(mediaType));

            //if negative, return all mediaIds, OR
            //if there are fewer mediaIds in the database than what we want, just return everything we have.
            if (count < 0 || allMediaIdLcids.Count < count)
            {
                Global.RO.Warn("Not enough mediaId/lcids found, returning what's available: {0} mediaId/lcids.", allMediaIdLcids.Count);
                return allMediaIdLcids;
            }

            //randomly pick from those mediaIds the count that we want
            Random rand = new Random(DateTime.Now.Millisecond);
            List<string[]> mediaIdLcids = new List<string[]>();
            while (mediaIdLcids.Count < count)
            {
                int randomId = rand.Next(allMediaIdLcids.Count); //get a random mediaId
                mediaIdLcids.Add(allMediaIdLcids[randomId]); //add it to the list
                allMediaIdLcids.RemoveAt(randomId); //remove it from the source list so we don't get it again.
            }

            return mediaIdLcids;
        }

        private static string[] GetPdlcMediaTypes()
        {
            return Config.GetMultiSetting("pdlc_mediatypes");
        }

        private static string[] GetRatableMediaTypes()
        {
            return Config.GetMultiSetting("ratings_mediatypes");
        }

        private static string GetUserRatingsMinReviewCount()
        {
            return Config.GetSetting("ratings_max_allowable_reviewcount");
        }

        /// <summary>
        /// This query is used instead of hard-coding a bunch of mediaIds in variables.  For a given
        /// parent mediaId, it tries to get a child mediaId of the given mediaType.
        /// </summary>
        /// <param name="mediaTypeToGet">mediaType we're looking for</param>
        /// <param name="parentMediaId">Parent mediaId that should have the child mediaType</param>
        /// <returns></returns>
        private static string GetChildMediaId(int mediaTypeToGet, string parentMediaId)
        {
            //build query for mediaId
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("SELECT m.mediaId FROM Media m");
            sb.AppendLine("WHERE m.mediaId IN(");
            sb.AppendLine("SELECT mr.relatedMediaId FROM MediaRelationship mr");
            sb.AppendLine("JOIN Media m on m.mediaId = mr.mediaId");
            sb.AppendLine(string.Format("WHERE m.mediaId = '{0}'", parentMediaId));
            sb.AppendLine("AND mr.mediaRelationshipTypeId = 2)");
            sb.AppendLine(string.Format("AND m.mediaTypeId = {0}", mediaTypeToGet));

            //query for mediaId
            string mediaId = _catalogConnection.ExecuteQueryGetSingle(sb.ToString());

            //return mediaId
            return mediaId;
        }

        /// <summary>
        /// Checks if a mediaId/lcid pair exists in the database.
        /// </summary>
        /// <param name="mediaId"></param>
        /// <param name="lcid"></param>
        /// <returns></returns>
        private static bool MediaIdLcidExists(string mediaId, string lcid)
        {
            int count = _catalogConnection.ExecuteQueryGetSingleInt(StringMediaIdLcidInMediaLocaleExists(mediaId, lcid));

            //if one and only one exists
            if (count == 1)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Updates the title & description of the mediaId/lcid pair  with the supplied values.
        /// </summary>
        /// <param name="mediaId"></param>
        /// <param name="lcid"></param>
        /// <param name="title"></param>
        /// <param name="description"></param>
        /// <returns></returns>
        private static bool UpdateTitleDescriptionText(string mediaId, string lcid, string title, string description)
        {
            bool success = true;

            //if the mediaId/lcid pair DOES NOT exist in MediaLocale, fail.
            if (!MediaIdLcidExists(mediaId, lcid))
            {
                Global.RO.Error("MediaId/Lcid pair does not exist.");
                success = false;
                return success;
            }


            Global.RO.Info("Updating mediaLocale with test data...");
            Global.RO.Info("Title: {0}", title);
            Global.RO.Info("Description: {0}", description);

            try
            {
                _catalogConnection.ExecuteNonQuery(StringUpdateTitleDescription(mediaId, lcid, title, description));

            }
            catch (Exception e)
            {
                Global.RO.Error("Test Failure");
                Global.RO.Error("{0}", e.Message);
                success = false;
            }

            return success;
        }
        
        /// <summary>
        /// Function that performs validation between the sproc's generated document and the schema.
        /// </summary>
        /// <param name="xmlDoc">the string output from the sproc</param>
        /// <param name="xsdDoc">the path of the xsd to use for validation</param>
        /// <returns>'true' for successful validation, 'false' for failure</returns>
        private static bool ValidateXmlAgainstSchema(string xmlDoc, string xsdDoc)
        {
            bool success = true;

            xmlDoc = xmlDoc.Replace("urn:uuid:", "");
            xmlDoc = xmlDoc.Replace("xmlns:a=\"http://www.w3.org/2005/Atom\"", "");
            xmlDoc = xmlDoc.Replace("a:", "");

            try
            {
                //Declare local objects
                XmlTextReader xsdTextReader = null;
                XmlSchemaSet xmlSchemaSet = null;
                XmlReader xmlReader = null;

                TextReader docXmlTextReader = new StringReader(xmlDoc);

                //Text reader object
                xsdTextReader = new XmlTextReader(xsdDoc);
                xmlSchemaSet = new XmlSchemaSet();
                xmlSchemaSet.Add(null, xsdTextReader);

                //XML validator object
                XmlReaderSettings settings = new XmlReaderSettings();
                settings.Schemas.Add(xmlSchemaSet);
                settings.ValidationType = ValidationType.Schema;
                //Add validation event handler
                settings.ValidationEventHandler += new ValidationEventHandler(ValidationHandler);

                xmlReader = XmlReader.Create(docXmlTextReader, settings);
                //Validate XML data
                while (xmlReader.Read()) ;

                xmlReader.Close();

                // Raise exception, if XML validation fails
                if (_errorCount > 0)
                {
                    throw new Exception(_errorMessage);
                }

                // XML Validation succeeded
                Global.RO.Info("XML validation with XSD succeeded.");
            }
            catch (Exception error)
            {
                // XML Validation failed
                Global.RO.Error("XML validation with XSD failed.");
                Global.RO.Error("Error Message: {0}", error.Message);

                success = false;
            }

            return success;
        }

        /// <summary>
        /// Validates the title/description of the document by doing a database lookup.
        /// </summary>
        /// <param name="mediaId">mediaId to get title/description from the database.</param>
        /// <param name="lcid">lcid to get title/description from the database.</param>
        /// <param name="docXml">xml returned from the sproc, to retrieve title/description from.</param>
        /// <returns></returns>
        private static bool ValidateTitleDescriptionText(string mediaId, string lcid, string docXml)
        {
            bool success = true;

            if (!MediaIdLcidExists(mediaId, lcid))
            {
                Global.RO.Error("ValidateTitleDescriptionText - MediaId/Lcid pair doesn't exist!");
                success = false;
                return success;
            }

            //Get info from database
            List<string[]> row = _catalogConnection.ExecuteQueryGetMultiple(StringSelectTitleDescriptionFromMediaLocale(mediaId, lcid));

            if (row.Count != 1) //expecting only 1 row, if not fail
            {
                Global.RO.Error("Failed to extract the title & description from mediaLocale table in the catalog!");
                success = false;
                return success;
            }
            string dbTitle = row[0][0];
            string dbDesc = row[0][1];

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(docXml);

            //string docTitle = doc.SelectSingleNode("/product/searchableXml/title").InnerText;
            //string docDesc = doc.SelectSingleNode("/product/searchableXml/fullDescription").InnerText;
            string docTitle = doc.GetElementsByTagName("title")[0].InnerText;
            string docDesc = doc.GetElementsByTagName("fullDescription")[0].InnerText;

            //if the database doesn't match what's in the xml
            if (!dbTitle.Equals(docTitle))
            {
                Global.RO.Error("Title in DB is different than document!");
                Global.RO.Error("DB Title (properly escaped): {0}", docTitle);
                Global.RO.Error("Document Title: {0}", dbTitle);
                success = false;
            }

            if (!dbDesc.Equals(docDesc))
            {
                Global.RO.Error("Description in DB is different than document!");
                Global.RO.Error("DB Description (properly escaped): {0}", docDesc);
                Global.RO.Error("Document Description: {0}", dbDesc);
                success = false;
            }

            return success;
        }

        /// <summary>
        /// Validates the exact number of expected documents was returned, and no document was NULL.
        /// </summary>
        /// <param name="mediaType">mediaType to generate documents for.  Will request 100 documents
        /// of this mediaType.  Warns if there are not enough mediaIds of that type.  Best when used with
        /// a production backup.</param>
        /// <returns>'true' for success, 'false' for failure</returns>
        private static bool TestCountDocsReturned(int mediaType)
        {
            bool success = true;

            Global.RO.Info("Get random mediaIds of mediaType {0}", mediaType);
            List<string[]> mediaIdLcids = GetRandomMediaIdLcids(100, mediaType);

            Global.RO.Info("Executing sproc with {0} records of mediaType {1}", mediaIdLcids.Count, mediaType);
            List<string[]> sprocOutput = _catalogConnection.ExecuteQueryGetMultiple(StringExecuteGetProductDocumentsStoredProc(mediaIdLcids));

            //Compare output row count with input row count.  Should be equal.
            Global.RO.Info("{0} input rows, {1} output rows.", mediaIdLcids.Count, sprocOutput.Count);

            //values not equal, find out what's wrong
            if (mediaIdLcids.Count != sprocOutput.Count)
            {
                success = false;

                Global.RO.Error("Row count is not equal!");

                for (int i = 0; i < sprocOutput.Count - 1; ++i)
                {
                    //if mediaId and lcid is duplicated (they'll be next to each other)
                    if (sprocOutput[i][0] == sprocOutput[i + 1][0] &&
                       sprocOutput[i][1] == sprocOutput[i + 1][1])
                    {
                        Global.RO.Error("MediaId: {0} | Lcid: {1}", sprocOutput[i][0], sprocOutput[i][1]);
                    }
                }
            }

            //check for null documents.  If there is a null document, fail.
            foreach (string[] row in sprocOutput)
            {
                if (row[2] == null)
                {
                    success = false;

                    Global.RO.Error("Null document found! MediaId: {0} | Lcid: {1}", row[0], row[1]);
                }
            }

            return success;
        }

        /// <summary>
        /// Main validation function.  All tests that validate the document against a schema use this function.
        /// </summary>
        /// <param name="xsdToUse">The path to the schema file to use in validation.</param>
        /// <param name="mediaId">mediaId to generate a document for.</param>
        /// <param name="lcid">lcid to generate a document for.</param>
        /// <returns>'true' for success, 'false' for failure.</returns>
        private static bool TestDocValidation(string xsdToUse, string mediaId, string lcid)
        {
            bool success = true;

            if (!MediaIdLcidExists(mediaId, lcid))
            {
                Global.RO.Error("TestDocValidation - MediaId/Lcid pair doesn't exist.");
                success = false;
                return success;
            }

            //Reset error-tracking variables
            _errorCount = 0;
            _errorMessage = "";

            //Execute the sproc with the given mediaId/lcid pair.
            List<string[]> sprocOutput = _catalogConnection.ExecuteQueryGetMultiple(StringExecuteGetProductDocumentsStoredProc(mediaId, lcid));

            //if something other than 1 document was returned OR the document is null, fail because something's wrong.
            if (sprocOutput.Count != 1 || sprocOutput[0][2] == null)
            {
                Global.RO.Error("Failed to get a document from the sproc!");
                success = false;
                return success;
            }

            Global.RO.Info("Validate xml document with schema");
            //validate the document from the sproc against our schema.
            if (false == ValidateXmlAgainstSchema(sprocOutput[0][2], xsdToUse))
            {
                //if failed, fail test.
                success = false;
                Global.RO.Error("Schema validation failed.");
            }

            Global.RO.Info("Validate text integrity in document title & description");
            if (false == ValidateTitleDescriptionText(mediaId, lcid, sprocOutput[0][2]))
            {
                success = false;
                Global.RO.Error("Title/Description validation failed.");
            }

            return success;
        }

        [TestGroupSetup]
        public void Setup()
        {
            _catalogConnection = new CMRawCatalogDB();

            Configuration config = ConfigurationManager.OpenExeConfiguration(System.Reflection.Assembly.GetExecutingAssembly().Location);
            _xblobMachineName = config.AppSettings.Settings["XblobMachineName"].Value;
        }

        [TestGroupTearDown]
        public void Shutdown()
        {

        } 

        #region Tests_Count_Docs_Returned

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType1_GonD : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(1);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType5_GameTrial : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(5);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType18_GameContent : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(18);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType19_GameDemo : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(19);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType20_Theme : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(20);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType21_XboxOriginal : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(21);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType22_Tile : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(22);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType23_Arcade : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(23);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType24_Consumable : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(24);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType30_GameVideo : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(30);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType34_GameTrailer : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(34);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType37_IndieGame : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(37);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //[TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType45_ServerBackedGame : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(45);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //[TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType46_Marketplace : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(46);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1)]
        class DocSproc_CountMediaType47_AvatarItem : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                bool success = TestCountDocsReturned(47);

                if (success)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        } 
        #endregion

        #region ValidateMediaTypes

        //360 Game
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType1_GonD : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 1, 360/GonD Game");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Game Trial
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType5_GameTrial : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 5, Game Trial");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                string mediaId = GetChildMediaId(5, _arcadeMediaId);

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(mediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, mediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Game Content
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType18_GameContent : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 18, Game Content");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                string mediaId = GetChildMediaId(18, _gondMediaId);

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(mediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, mediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }
         
        //Game Demo
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType19_GameDemo : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 19, Game Demo");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                string mediaId = GetChildMediaId(19, _gondMediaId);

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(mediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, mediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Theme
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType20_Theme : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 20, Theme");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                string mediaId = GetChildMediaId(20, _gondMediaId);

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(mediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, mediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Xbox Original
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType21_XboxOriginal : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 21, Xbox Original");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_xboxOriginalMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _xboxOriginalMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Gamer Tile (Gamer Picture)
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType22_Tile : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 22, Gamer Tile (Picture)");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                string mediaId = GetChildMediaId(22, _gondMediaId);

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(mediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, mediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Arcade Game
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType23_Arcade : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 23, Arcade Game");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_arcadeMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _arcadeMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Game Consumable
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType24_Consumable : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 24, Game Consumable");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                string mediaId = GetChildMediaId(24, _gondMediaId);

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(mediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, mediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Game Video - no test data yet
        //[TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType30_GameVideo : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("MediaType 30, Game Video");
            }
        }

        //Game Trailer - no test data yet
        //[TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType34_GameTrailer : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("MediaType 34, Game Trailer");
            }
        }

        //XNA Indie Game
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType37_IndieGame : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 37, XNA Indie Game");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_indieGameMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _indieGameMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        //Server-Backed Game (1 vs. 100) - no test data yet
        //[TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType45_ServerBackedGame : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("MediaType 45, Server-Backed Game (1 vs. 100)");
            }
        }

        //Marketplace item - no test data yet
        //[TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType46_Marketplace : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("MediaType 46, Marketplace item");
            }
        }

        //Avatar Item
        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_MediaType47_AvatarItem : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                Global.RO.Info("MediaType 47, Avatar Item");

                string title = "Testing";
                string description = "Costco Doc Sproc Test";

                string mediaId = GetChildMediaId(47, _gondMediaId);

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(mediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, mediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }  
        #endregion

        [TestCase, TestCasePriority(1)]
        class DocSproc_ValidationTest_Japanese : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "絶マたな";
                string description = "絶賛放送中のアニメ「ゼーガペイン」が、マイクロソフト×サンライズ×バンダイナムコゲームスの強力タッグにより、３Dメカアクションシューティングゲームになって登場。Xbox360だから実現できた、かつてない美麗な映像、ゲームならではのスピード感あふれるメカアクションは一見の価値あり。アニメに出てくるキャラクターはもちろん、このゲームオリジナルのキャラクターも多数存在し、アニメでは描かれていない「ゼーガペイン」の世界の謎を楽しむことができる。また、パートナーとなる様々なキャラクターや豊富なスキル・パーツを組み合わせることで、自分だけのゼーガペインを作ることが可能。接近戦型、遠距離型、防御型など自分のプレイスタイルを確立しよう。  多岐にわたるミッション、発生するいくつものイベント、襲い掛かる強敵たち・・・。その全てをクリアして、気になるストーリーを補完しよう。XboxLIVEを使えば世界中のプレイヤーと通信対戦モードや、チャットでの会話が楽しめる。  Xbox360対応ソフト『ゼーガペインXOR』2006年夏始動！";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;
                                
            }
        }

        #region Tests_XML_Injection

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Ampersand : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "Testing Ampersand &";
                string description = "Costco & Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_GreaterThan : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "Testing Greater Than >";
                string description = "Costco > Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_LessThan : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "Testing Less Than <";
                string description = "Costco < Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_DoubleQuotes : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "Testing Double Quotes \"";
                string description = "Costco \"Doc Sproc\" Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_SingleQuotes : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "Testing Single Quotes ''";
                string description = "Costco ''Doc'' Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml1 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "TestingXml1<";
                string description = "Costco Doc Sproc Test<";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml2 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = ">Testing Xml2";
                string description = ">Costco Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml3 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "Testing Xml3<!--";
                string description = "Costco Doc Sproc Test<!--";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml4 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "-->Testing Xml4";
                string description = "-->Costco Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml5 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "<!--Testing Xml5-->";
                string description = "<!--Costco Doc Sproc Test--<";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml6 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "<description>TestingXml6</description>";
                string description = "<title>Costco Doc Sproc Test</title>";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml7 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "Testing Xml7]]>";
                string description = "Costco Doc Sproc Test]]>";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml8 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "TestingXml8''";
                string description = "Costco Doc Sproc Test''";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml9 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "TestingXml9\"";
                string description = "Costco Doc Sproc Test\"";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, TestCasePriority(2)]
        class DocSproc_ValidationTest_Xml10 : WatcherTestsBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string title = "</title>TestingXml10";
                string description = "</description>Costco Doc Sproc Test";

                //Update the mediaId/lcid with this title and description
                UpdateTitleDescriptionText(_gondMediaId, _commonLcid, title, description);

                bool success = TestDocValidation(_genericXsdFile, _gondMediaId, _commonLcid);

                if (false == success)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        } 
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\EndToEndTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using Marketplace.Test.Common.Service;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("wirosas"), TestFrequency("Daily"), EnvRequirement("Watcher")]
    public class EndToEndWatcherTests
    {
        [TestGroupSetup]
        public void Setup() { }

        [TestGroupTearDown]
        public void Shutdown() { }
        
        [TestCase, TestCasePriority(1)]
        class P_Pipeline_Test_With_Single_Document : WatcherTestsBase
        {
            public P_Pipeline_Test_With_Single_Document() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string uniqueTitleModifier = GenerateRandomModifier(10);
                    
                try
                {
                    PrepareForEndToEndTest();

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(1, uniqueTitleModifier);

                    WatchFASTForUpdatedDocuments(modifiedMedia, uniqueTitleModifier, 5);
                }
                finally
                {
                    //Remove any modified title strings to start fresh.
                    Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                }

                Global.RO.Info("Test completed.");
            }           
        }

        [TestCase, TestCasePriority(1)]
        class P_Pipeline_Test_With_10_Documents : WatcherTestsBase
        {
            public P_Pipeline_Test_With_10_Documents() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string uniqueTitleModifier = GenerateRandomModifier(10);

                try
                {
                    PrepareForEndToEndTest();

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    WatchFASTForUpdatedDocuments(modifiedMedia, uniqueTitleModifier, 5);
                }
                finally
                {
                    //Remove any modified title strings to start fresh.
                    Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                }

                Global.RO.Info("Test completed.");
            }
        }

        [TestCase, TestCasePriority(1)]
        class P_Pipeline_Test_With_5000_Documents : WatcherTestsBase
        {
            public P_Pipeline_Test_With_5000_Documents() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string uniqueTitleModifier = GenerateRandomModifier(10);

                try
                {
                    PrepareForEndToEndTest();

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(5000, uniqueTitleModifier);

                    WatchFASTForUpdatedDocuments(modifiedMedia, uniqueTitleModifier, 30);
                }
                finally
                {
                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_Pipeline_Test_With_Gradual_Increase_In_Documents : WatcherTestsBase
        {
            public P_Pipeline_Test_With_Gradual_Increase_In_Documents() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                int currentDocumentCount = 10;
                int finalDocumentsToPublish = 10000;
                int stepMultiplier = 2;
                
                PrepareForEndToEndTest();

                while (currentDocumentCount < finalDocumentsToPublish)
                {
                    string uniqueTitleModifier = GenerateRandomModifier(10);
                    
                    Global.RO.Info(
                        String.Format("*** Now publishing {0} documents ***", currentDocumentCount));

                    try
                    {

                        Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(currentDocumentCount, uniqueTitleModifier);

                        if (modifiedMedia.Count < currentDocumentCount)
                        {
                            currentDocumentCount = finalDocumentsToPublish;
                        }

                        WatchFASTForUpdatedDocuments(modifiedMedia, uniqueTitleModifier, 60);
                        
                        if (ResultCode == TEST_RESULTS.FAILED)
                        {
                            break;
                        }
                    }
                    finally
                    {
                        //Remove any modified title strings to start fresh.
                        if (ResultCode != TEST_RESULTS.FAILED)
                        {
                            Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                        }
                    }


                    //increment documents to publish
                    currentDocumentCount *= stepMultiplier;
                }

                Global.RO.Info("Test completed.");
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_Pipeline_Test_With_Staggered_Documents_For_5_Minutes : WatcherTestsBase
        {
            public P_Pipeline_Test_With_Staggered_Documents_For_5_Minutes() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                int testcaseDurationMinutes = 5;

                PrepareForEndToEndTest();

                DateTime completionTime = DateTime.Now.AddMinutes(testcaseDurationMinutes);

                Global.RO.Info("Testcase will run until: " + completionTime.ToString());

                while (DateTime.Now < completionTime)
                {
                    try
                    {                     
                        string uniqueTitleModifier = GenerateRandomModifier(10);

                        Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                        WatchFASTForUpdatedDocuments(modifiedMedia, uniqueTitleModifier, 5);

                        if (ResultCode == TEST_RESULTS.FAILED)
                        {
                            break;
                        }
                    }
                    finally
                    {
                        //Remove any modified title strings to start fresh.
                        if (ResultCode != TEST_RESULTS.FAILED)
                        {
                            Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                        }
                    }

                }
                
                Global.RO.Info("Test completed.");
            }
        }
        
        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Detector_Average_Execution_Time : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Detector_Average_Execution_Time() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                        PERF_DETECTOR,
                        PERF_DETECTOR_AVG_EXECUTION_TIME,
                        PERF_DETECTOR_INSTANCE,
                        0.001,
                        60);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);


                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }

                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }
        
        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Detector_Number_Of_Items_Detected : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Detector_Number_Of_Items_Detected() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    double currentValue = GetCurrentCounterValue(
                        PERF_DETECTOR,
                        PERF_DETECTOR_NUMBER_OF_ITEMS_DETECTED,
                        PERF_DETECTOR_INSTANCE);
                    
                    MonitorPerformanceCounter(
                       PERF_DETECTOR,
                       PERF_DETECTOR_NUMBER_OF_ITEMS_DETECTED,
                       PERF_DETECTOR_INSTANCE,
                       currentValue + 1,
                       180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");                
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }
        
        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Extractor_Average_Execution_Time : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Extractor_Average_Execution_Time() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                        PERF_EXTRACTOR,
                        PERF_EXTRACTOR_AVG_EXECUTION_TIME,
                        PERF_EXTRACTOR_INSTANCE,
                        0.001,
                        180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);


                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }

                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");                
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Extractor_Average_Batch_Size_All_Time : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Extractor_Average_Batch_Size_All_Time() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                        PERF_EXTRACTOR,
                        PERF_EXTRACTOR_AVERAGE_BATCH_SIZE,
                        PERF_EXTRACTOR_INSTANCE,
                        1,
                        180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");                               
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Extractor_API_Requests_Total : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Extractor_API_Requests_Total() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    double currentValue = GetCurrentCounterValue(
                        PERF_EXTRACTOR,
                        PERF_EXTRACTOR_API_REQUESTS_TOTAL,
                        PERF_EXTRACTOR_INSTANCE);

                    MonitorPerformanceCounter(
                        PERF_EXTRACTOR,
                        PERF_EXTRACTOR_API_REQUESTS_TOTAL,
                        PERF_EXTRACTOR_INSTANCE,
                        currentValue + 1,
                        180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");                 
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Extractor_API_Requests_Per_Second : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Extractor_API_Requests_Per_Second() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                       PERF_EXTRACTOR,
                       PERF_EXTRACTOR_API_REQUESTS_PER_SECOND,
                       PERF_EXTRACTOR_INSTANCE,
                       1,
                       180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");                          
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3), EnvRequirement("XblobOnly")]
        class P_Perf_Counter_Extractor_Total_Failures : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Extractor_Total_Failures() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                
                if (!Global.CurrentEnvironment.Environment.ToLower().Contains("xblob"))
                {
                    Global.RO.Warn("This test case makes modifications to stored procedure names and " +
                        "is too risky to run in shared environments.  This test case will not execute.");
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    Global.RO.Info("Renaming GetProductDocuments to GetProductDocuments2 to induce a failure.");
                    Catalog.ExecuteNonQuery(
                        RenameGetProductMedia("GetProductDocuments", "GetProductDocuments2"));

                    PrepareForEndToEndTest();

                    double currentValue = GetCurrentCounterValue(
                        PERF_EXTRACTOR,
                        PERF_EXTRACTOR_TOTAL_FAILURES,
                        PERF_EXTRACTOR_INSTANCE);

                     MonitorPerformanceCounter(
                        PERF_EXTRACTOR,
                        PERF_EXTRACTOR_TOTAL_FAILURES,
                        PERF_EXTRACTOR_INSTANCE,
                        currentValue + 1,
                        180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    Global.RO.Info("Renaming GetProductDocuments2 back to GetProductDocuments.");
                    Catalog.ExecuteNonQuery(
                        RenameGetProductMedia("GetProductDocuments2", "GetProductDocuments"));

                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3), EnvRequirement("XblobOnly")]
        class P_Perf_Counter_Extractor_Failures_Per_Second : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Extractor_Failures_Per_Second() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if(!Global.CurrentEnvironment.Environment.ToLower().Contains("xblob"))
                {
                    Global.RO.Warn("This test case makes modifications to stored procedure names and " +
                        "is too risky to run in shared environments.  This test case will not execute.");
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    Global.RO.Info("Renaming GetProductDocuments to GetProductDocuments2 to induce a failure.");
                    Catalog.ExecuteNonQuery(
                        RenameGetProductMedia("GetProductDocuments", "GetProductDocuments2"));

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                        PERF_EXTRACTOR,
                        PERF_EXTRACTOR_FAILURES_PER_SECOND,
                        PERF_EXTRACTOR_INSTANCE,
                        1,
                        180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    Global.RO.Info("Renaming GetProductDocuments2 back to GetProductDocuments.");
                    Catalog.ExecuteNonQuery(
                        RenameGetProductMedia("GetProductDocuments2", "GetProductDocuments"));

                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");                 
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }
        
        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Publisher_Flush_Documents_Time : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Publisher_Flush_Documents_Time() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                        PERF_PUBLISHER,
                        PERF_PUBLISHER_AVG_FLUSH_DOCUMENTS_TIME,
                        PERF_PUBLISHER_INSTANCE,
                        0.001,
                        600);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(100, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 600 seconds...");
                    if (!monitoringComplete.WaitOne(600000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Publisher_Number_Of_Document_Errors : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Publisher_Number_Of_Document_Errors() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                
                PerfCounterTargetReachedDelegate monitorDelegate =
                    new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {                   
                    PerfCounterTargetReached += monitorDelegate;
                    
                    PrepareForEndToEndTest();

                    //Get the first mediaIds from the Media table
                    List<string[]> mediaIds = Catalog.ExecuteQueryGetMultiple(
                        QuerySelectTopTitlesFromMediaLocale(5));

                    MonitorPerformanceCounter(
                        PERF_PUBLISHER,
                        PERF_PUBLISHER_NUMBER_OF_DOCUMENT_ERRORS,
                        PERF_PUBLISHER_INSTANCE,
                        1,
                        60);

                    Global.RO.Warn("Currently there is no way to drive FAST Documennt errors from an end to end perspective.  " +
                        "Please see the unit tests for the Watcher Publisher component.");
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;
                }

                Global.RO.Info("Test completed.");
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Publisher_Number_Of_Document_Warnings: WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Publisher_Number_Of_Document_Warnings() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate =
                    new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();
                    
                    //Get the first mediaIds from the Media table
                    List<string[]> mediaIds = Catalog.ExecuteQueryGetMultiple(
                        QuerySelectTopTitlesFromMediaLocale(5));

                    MonitorPerformanceCounter(
                        PERF_PUBLISHER,
                        PERF_PUBLISHER_NUMBER_OF_DOCUMENT_WARNINGS,
                        PERF_PUBLISHER_INSTANCE,
                        1,
                        60);

                    Global.RO.Warn("Currently there is no way to drive FAST Documennt warnings from an end to end perspective.  " +
                        "Please see the unit tests for the Watcher Publisher component.");
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;
                }
                
                Global.RO.Info("Test completed.");
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Publisher_Average_Publish_Time : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Publisher_Average_Publish_Time() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                        PERF_PUBLISHER,
                        PERF_PUBLISHER_AVERAGE_PUBLISH_TIME,
                        PERF_PUBLISHER_INSTANCE,
                        .001,
                        600);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(100, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 600 seconds...");
                    if (!monitoringComplete.WaitOne(600000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }
                
                Global.RO.Info("Test completed.");
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Publisher_Number_Of_Documents_Published : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Publisher_Number_Of_Documents_Published() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    double currentValue = GetCurrentCounterValue(
                        PERF_PUBLISHER,
                        PERF_PUBLISHER_NUMBER_OF_DOCUMENTS_PUBLISHED,
                        PERF_PUBLISHER_INSTANCE);

                    MonitorPerformanceCounter(
                        PERF_PUBLISHER,
                        PERF_PUBLISHER_NUMBER_OF_DOCUMENTS_PUBLISHED,
                        PERF_PUBLISHER_INSTANCE,
                        currentValue + 1,
                        600);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 600 seconds...");
                    if (!monitoringComplete.WaitOne(600000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");                    
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Publisher_Number_Of_Documents_Published_Per_Second : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Publisher_Number_Of_Documents_Published_Per_Second() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                         PERF_PUBLISHER,
                         PERF_PUBLISHER_NUMBER_OF_DOCUMENTS_PUBLISHED_PER_SECOND,
                         PERF_PUBLISHER_INSTANCE,
                         .001,
                         600);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 600 seconds...");
                    if (!monitoringComplete.WaitOne(600000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");                                          
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Queue_Average_Wait_Time : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Queue_Average_Wait_Time() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                        PERF_QUEUE,
                        PERF_QUEUE_AVERAGE_WAIT_TIME,
                        PERF_WATCHER_INSTANCE,
                        .001,
                        180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(100, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");     
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Queue_Average_Dequeue_Time : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Queue_Average_Dequeue_Time() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                         PERF_QUEUE,
                         PERF_QUEUE_DEQUEUE_WAIT_TIME,
                         PERF_WATCHER_INSTANCE,
                         .001,
                         180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");             
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }
        
        [TestCase, TestCasePriority(3)]
        class P_Perf_Counter_Queue_Average_Enqueue_Time : WatcherTestsBase
        {
            ManualResetEvent monitoringComplete = new ManualResetEvent(false);

            public P_Perf_Counter_Queue_Average_Enqueue_Time() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PerfCounterTargetReachedDelegate monitorDelegate = new PerfCounterTargetReachedDelegate(PerfMonitorCompleted);

                try
                {
                    PerfCounterTargetReached += monitorDelegate;

                    PrepareForEndToEndTest();

                    MonitorPerformanceCounter(
                         PERF_QUEUE,
                         PERF_QUEUE_ENQUEUE_WAIT_TIME,
                         PERF_WATCHER_INSTANCE,
                         .001,
                         180);

                    string uniqueTitleModifier = GenerateRandomModifier(10);

                    Dictionary<string, string> modifiedMedia = ModifyMediaAndTitles(10, uniqueTitleModifier);

                    Global.RO.Info("Waiting for the performance counter value to be achieved or will time out in 180 seconds...");
                    if (!monitoringComplete.WaitOne(180000, true))
                    {
                        Global.RO.Error("Performance counter did not increment as expected within the specified amount of time.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("Desired perf counter value was achieved.");
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                finally
                {
                    PerfCounterTargetReached -= monitorDelegate;

                    //Remove any modified title strings to start fresh.
                    if (ResultCode != TEST_RESULTS.FAILED)
                    {
                        Catalog.ExecuteNonQuery(RemoveTestcaseTitleModifiers());
                    }
                }

                Global.RO.Info("Test completed.");       
            }

            void PerfMonitorCompleted(bool desiredValueWasAchieved, string counterCategory, string counter, string instance, double value)
            {
                if (desiredValueWasAchieved)
                {
                    monitoringComplete.Set();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\CollectionExtensionMethods.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;
using System.Text;

/// <summary>
/// Extension methods for the Collection&lt;T&gt; class
/// </summary>
public static class CollectionExtensionMethods
{
    /// <summary>
    /// Adds a number of items to a Collection
    /// </summary>
    /// <typeparam name="T">The type parameter of the collection</typeparam>
    /// <param name="myCollection">The target collection</param>
    /// <param name="itemList">The list of items to add</param>
    public static void AddRange<T>(this Collection<T> myCollection, T[] itemList)
    {
        foreach (T item in itemList)
        {
            myCollection.Add(item);
        }
    }

    /// <summary>
    /// Adds a number of items to a Collection
    /// </summary>
    /// <typeparam name="T">The type parameter of the collection</typeparam>
    /// <param name="myCollection">The target collection</param>
    /// <param name="itemList">The list of items to add</param>
    public static void AddRange<T>(this Collection<T> myCollection, Collection<T> itemList)
    {
        foreach (T item in itemList)
        {
            myCollection.Add(item);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\WatcherTestsBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Web;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Data.SqlClient;

using Com.FastSearch.Esp.Search;
using Com.FastSearch.Esp.Search.Query;
using Com.FastSearch.Esp.Search.Result;
using Com.FastSearch.Esp.Search.View;
using Com.FastSearch.Esp.Content;
using Com.FastSearch.Esp.Content.Config;

using xonline.common.config;

namespace Marketplace.Test.Common.Service
{

    /// <summary>
    /// Base test class for the Watcher test cases
    /// </summary>
    internal class WatcherTestsBase : TestBase
    {
        #region Fields

        internal const string PERF_DETECTOR_INSTANCE = "catalogwatcher|producer|media|esp|000";
        internal const string PERF_DETECTOR = "XBL Catalog Watcher: Detector Perf Counters";
        internal const string PERF_DETECTOR_AVG_EXECUTION_TIME = "Catalog Watcher: Avg. execution time";
        internal const string PERF_DETECTOR_NUMBER_OF_ITEMS_DETECTED = "Catalog Watcher: Number of items detected";

        internal const string PERF_EXTRACTOR_INSTANCE = "catalogwatcher|producer|media|esp|000";
        internal const string PERF_EXTRACTOR = "XBL Catalog Watcher: Extractor Perf Counters";
        internal const string PERF_EXTRACTOR_AVG_EXECUTION_TIME = "Catalog Watcher: Avg. execution time";
        internal const string PERF_EXTRACTOR_AVERAGE_BATCH_SIZE = "Catalog Watcher: Average batch size (all time)";
        internal const string PERF_EXTRACTOR_API_REQUESTS_TOTAL = "Catalog Watcher: Extractor API requests total";
        internal const string PERF_EXTRACTOR_API_REQUESTS_PER_SECOND = "Catalog Watcher: Extractor API requests/sec";
        internal const string PERF_EXTRACTOR_TOTAL_FAILURES = "Catalog Watcher: Extractor API total failures";
        internal const string PERF_EXTRACTOR_FAILURES_PER_SECOND = "Catalog Watcher: Extractor failures/sec";

        internal const string PERF_PUBLISHER_INSTANCE = "catalogwatcher|publisher|media|esp|000";
        internal const string PERF_PUBLISHER = "XBL Catalog Watcher: Publisher ESP Perf Counters";
        internal const string PERF_PUBLISHER_AVG_FLUSH_DOCUMENTS_TIME = "Catalog Watcher: Publisher ESP: Avg. Flush Documents time";
        internal const string PERF_PUBLISHER_NUMBER_OF_DOCUMENT_ERRORS = "Catalog Watcher: Publisher ESP: Number of document errors";
        internal const string PERF_PUBLISHER_NUMBER_OF_DOCUMENT_WARNINGS = "Catalog Watcher: Publisher ESP: Number of document warnings";
        internal const string PERF_PUBLISHER_AVERAGE_PUBLISH_TIME = "Catalog Watcher: Publisher ESP: Avg. publish time";
        internal const string PERF_PUBLISHER_NUMBER_OF_DOCUMENTS_PUBLISHED = "Catalog Watcher: Publisher ESP: Number of document published";
        internal const string PERF_PUBLISHER_NUMBER_OF_DOCUMENTS_PUBLISHED_PER_SECOND = "Catalog Watcher: Publisher ESP: Number of documents published per second";

        internal const string PERF_WATCHER_INSTANCE = "catalogwatcher|watcher|media|esp|000";
        internal const string PERF_QUEUE = "XBL Catalog Watcher: Queue Perf Counters";
        internal const string PERF_QUEUE_AVERAGE_WAIT_TIME = "Catalog Watcher: Avg. wait time";
        internal const string PERF_QUEUE_DEQUEUE_WAIT_TIME = "Catalog Watcher: Queue Operations: dequeue wait time";
        internal const string PERF_QUEUE_ENQUEUE_WAIT_TIME = "Catalog Watcher: Queue Operations: enqueue wait time";
        internal const string PERF_QUEUE_CURRENT_QUEUE_LENGTH = "Catalog Watcher: Current Queue Length";

        private static CMRawCatalogDB catalog = null;
        private static CMNPDB npdb = null;
        internal string xblobMachineName = String.Empty;
        private string watcherPort = String.Empty; 
        internal static string fastEspInstallation = String.Empty;
        private static string fastEspMarketplaceSearch = String.Empty;
        private static string fastEspSearchPort = String.Empty;
        private static string fastEspCatalog = String.Empty;
        private static string fastEspVirtualCollectionName = String.Empty;
        private static ISearchView searchView = null;

        private string randomCharacterBase = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        private Random random = new Random();

        #endregion

        #region Properties

        internal CMRawCatalogDB Catalog
        {
            get 
            {
                if (null == catalog ||
                    catalog.IsClosed)
                {
                    catalog = new CMRawCatalogDB();                    
                }
                
                return catalog;
            }
        }

        internal CMNPDB NPDB
        {
            get
            {
                if (null == npdb ||
                    npdb.IsClosed)
                {
                    npdb = new CMNPDB();
                }

                return npdb;
            }
        }

        #endregion

        #region Constructor and Initialization

        /// <summary>
        /// Constructor for the Watcher tests base class
        /// </summary>
        internal WatcherTestsBase()
        {
            //Get the cron virtual interface from the environment
            Uri xblobUri = new Uri("http://" + Global.XEnv.GetVirtualInterface("cron_int").ToString());

            xblobMachineName = xblobUri.Host;
            watcherPort = xblobUri.Port.ToString();

            //Get the fastEspMarketplaceIngestion virtual interface from the environment

            

            // Retrieve virtual interface information, construct connection string
            string[] ingestionIps = Config.GetMultiSetting("fastEspMarketplaceIngestionIps");
            string collectionName = Config.GetSetting(Setting.catalogwatcher_fast_esp_collection_name);
            string ingestionPort = Config.GetSetting(Setting.catalogwatcher_fast_esp_ingestion_port);

            StringBuilder espContentDistributor = new StringBuilder();
            string noFirstComma = string.Empty;

            // Format of the content distributor is a comma seperated list of host:port values
            //      host1:port,host2:port,host3:port
            foreach (string ip in ingestionIps)
            {
                espContentDistributor.AppendFormat("{0}{1}:{2}", noFirstComma, ip, ingestionPort);
                noFirstComma = ",";
            }
            
            fastEspInstallation = espContentDistributor.ToString();

            //Get the fastEspMarketplaceSearch virtual interface from the environment

            IVirtualInterfaceInfo fastEspMarketplaceSearchVIInfo = Config.GetVirtualInterface("fastEspMarketplaceSearch");

            Uri fastSearchUri = fastEspMarketplaceSearchVIInfo.Url;

            fastEspMarketplaceSearch = fastSearchUri.Host;
            fastEspSearchPort = fastSearchUri.Port.ToString();
            fastEspCatalog = fastEspMarketplaceSearchVIInfo.Info1;

            //Get the catalogwatcher_fast_esp_virtual_collection_name to be used when issuing queries to ensure we're not searching all documents
            //on a shared server
            fastEspVirtualCollectionName = Config.GetSetting(Setting.catalogwatcher_fast_esp_virtual_collection_name);

        }

        #endregion

        #region Cron and Command Methods

        protected override void Execute() { }

        /// <summary>
        /// Ping the health check page for the watcher to ensure the process is kept alive
        /// </summary>
        internal void PingWatcherHealthCheck()
        {
            Global.RO.Info("Pinging: " + String.Format("http://{0}:{1}/cron/health.ashx", xblobMachineName, watcherPort));
            //ping the watcher health check
            WebClient client = new WebClient();
            Stream stream = client.OpenRead(
                String.Format("http://{0}:{1}/cron/health.ashx",
                    xblobMachineName, watcherPort));
            StreamReader reader = new StreamReader(stream);
            string response = reader.ReadToEnd();
            reader.Close();
        }

        /// <summary>
        /// Monitor the specified settings for changes after the number of seconds specified
        /// </summary>
        /// <param name="settingsToMonitor">Settings to monitor</param>
        /// <param name="secondsToMonitor">Seconds to wait before gathering changes</param>
        /// <returns>List of values for the specified settings once the number of seconds specified has gone by.</returns>
        internal List<string> MonitorForChanges(List<string> settingsToMonitor, int secondsToMonitor, int changeDirection)
        {
            Global.RO.Info(String.Format("Monitoring for changes for {0} seconds.", secondsToMonitor));

            DateTime monitorDeadline = DateTime.Now;
            monitorDeadline = monitorDeadline.AddSeconds(secondsToMonitor);
            string currentSettingValue = String.Empty;

            List<string> finalSettingValues = new List<string>( new string[] { String.Empty, String.Empty} );
            
            while (DateTime.Now < monitorDeadline)
            {
                PingWatcherHealthCheck();

                for (int i = 0; i < settingsToMonitor.Count; i++)
                {
                    currentSettingValue = RetrieveWatcherSetting(settingsToMonitor[i]);

                    if (changeDirection > 0 &&
                        currentSettingValue.CompareTo(finalSettingValues[i]) < 0)
                    {
                        Global.RO.Error(
                            String.Format("The current value for {0} is less than the previous value where incrementing values are expected.", settingsToMonitor[i]));
                        Global.RO.Error(
                            String.Format("Current value: {0}  <  Previous Value: {1}", currentSettingValue, finalSettingValues[i]));

                        ResultCode = TEST_RESULTS.FAILED;
                        return null;
                    }
                    else if (changeDirection < 0 &&
                    currentSettingValue.CompareTo(finalSettingValues[i]) > 0)
                    {
                        Global.RO.Error(
                            String.Format("The current value for {0} is greater than the previous value where decrementing values are expected.", settingsToMonitor[i]));
                        Global.RO.Error(
                            String.Format("Current value: {0}  >  Previous Value: {1}", currentSettingValue, finalSettingValues[i]));

                        ResultCode = TEST_RESULTS.FAILED;
                        return null;
                    }
                    else
                    {
                        finalSettingValues[i] = currentSettingValue;
                    }
                }

                Thread.Sleep(1000);
            }           

            return finalSettingValues;
        }

        /// <summary>
        /// Do general preparation of the Watcher prior to test case execution.  Sets default, initial values for those settings specified.
        /// </summary>
        /// <param name="enabled">Specifies whether or not the Watcher should be enabled.</param>
        /// <param name="intervalSeconds">Specifies the value to be used for the interval seconds setting.</param>
        /// <param name="timeoutSeconds">Specifies the value to be used for the timeout seconds setting.</param>
        /// <param name="scheduledTime">Specifies the value for the next schedule time the Watcher will run.</param>
        /// <param name="actualTime">Specifies the value for the next actual time the Watcher will run.</param>
        internal void PrepareWatcherForTest(bool enabled, int intervalSeconds, int timeoutSeconds, string scheduledTime, string actualTime)
        {
            Global.RO.Info("Preparing the Watcher for the test.");
            PingWatcherHealthCheck();

            //disable the watcher to get it into a clean state
            Global.RO.Info("Disabling the Watcher.");
            UpdateWatcherSetting("setenabled", enabled);

            //wait a minute for the watcher to enter a disabled state
            Global.RO.Info("Sleeping for 35 seconds to allow the Watcher to shut down.");
            Thread.Sleep(new TimeSpan(0, 0, 35));

            //set the interval seconds for the watcher
            Global.RO.Info(String.Format("Set the next interval seconds to {0}.", intervalSeconds));
            UpdateWatcherSetting("setintervalseconds", intervalSeconds);

            //set the timeout seconds for the watcher
            Global.RO.Info(String.Format("Set the timeout seconds to {0}.", timeoutSeconds));
            UpdateWatcherSetting("settimeoutseconds", timeoutSeconds);

            //reset the next scheduled time for the watcher
            Global.RO.Info("Resetting the next schedule date.");
            UpdateWatcherSetting("setnextscheduled", scheduledTime);

            //reset the next actual time for the watcher
            Global.RO.Info("Resetting the next actual date.");
            UpdateWatcherSetting("setnextactual", actualTime);
        }

        /// <summary>
        /// Retrieves the value for the setting specified.
        /// </summary>
        /// <param name="settingName">The name of the setting to retrieve.</param>
        /// <returns>The value of the setting specified.</returns>
        internal string RetrieveWatcherSetting(string settingName)
        {
            //disable the watcher to get it into a clean state
            WebClient client = new WebClient();
            Stream stream = client.OpenRead(
                String.Format("http://{0}:{1}/cron/command.ashx?assembly={2}&classname={3}&op={4}&value={5}",
                    xblobMachineName, watcherPort, "TestWatcher.dll", "xonline.server.marketplace.test.TestWatcher",
                    "getsettingvalue", settingName));
            StreamReader reader = new StreamReader(stream);
            string response = reader.ReadToEnd();
            reader.Close();

            return response;
        }
        
        /// <summary>
        /// Updates the specified setting with the specified value.
        /// </summary>
        /// <param name="settingName">The name of the setting to update.</param>
        /// <param name="value">The value to use when updating the specified setting.</param>
        /// <returns>The response from the Watcher after updating the setting.</returns>
        internal string UpdateWatcherSetting(string settingName, bool value)
        {
            return UpdateWatcherSetting(settingName, value, "TestWatcher.dll", "xonline.server.marketplace.test.TestWatcher");
        }

        /// <summary>
        /// Updates the specified setting with the specified value.
        /// </summary>
        /// <param name="settingName">The name of the setting to update.</param>
        /// <param name="value">The value to use when updating the specified setting.</param>
        /// <param name="assemblyName">The name of the assembly to reference.</param>
        /// <param name="className">The name of the class to reference.</param>
        /// <returns>The response from the Watcher after updating the setting.</returns>
        internal string UpdateWatcherSetting(string settingName, bool value, string assemblyName, string className)
        {
            WebClient client = new WebClient();
            Stream stream = client.OpenRead(
                String.Format("http://{0}:{1}/cron/command.ashx?assembly={2}&classname={3}&op={4}&value={5}",
                    xblobMachineName, watcherPort, assemblyName, className,
                    settingName, value));
            StreamReader reader = new StreamReader(stream);
            string response = reader.ReadToEnd();
            reader.Close();

            return response;
        }

        /// <summary>
        /// Updates the specified setting with the specified value.
        /// </summary>
        /// <param name="settingName">The name of the setting to update.</param>
        /// <param name="value">The value to use when updating the specified setting.</param>
        /// <returns>The response from the Watcher after updating the setting.</returns>
        internal string UpdateWatcherSetting(string settingName, int value)
        {
            return UpdateWatcherSetting(settingName, value, "TestWatcher.dll", "xonline.server.marketplace.test.TestWatcher");
        }

        /// <summary>
        /// Updates the specified setting with the specified value.
        /// </summary>
        /// <param name="settingName">The name of the setting to update.</param>
        /// <param name="value">The value to use when updating the specified setting.</param>
        /// <param name="assemblyName">The name of the assembly to reference.</param>
        /// <param name="className">The name of the class to reference.</param>
        /// <returns>The response from the Watcher after updating the setting.</returns>
        internal string UpdateWatcherSetting(string settingName, int value, string assemblyName, string className)
        {
            WebClient client = new WebClient();
            Stream stream = client.OpenRead(
                String.Format("http://{0}:{1}/cron/command.ashx?assembly={2}&classname={3}&op={4}&value={5}",
                    xblobMachineName, watcherPort, assemblyName, className,
                    settingName, value));
            StreamReader reader = new StreamReader(stream);
            string response = reader.ReadToEnd();
            reader.Close();

            return response;
        }


        /// <summary>
        /// Updates the specified setting with the specified value.
        /// </summary>
        /// <param name="settingName">The name of the setting to update.</param>
        /// <param name="value">The value to use when updating the specified setting.</param>
        /// <returns>The response from the Watcher after updating the setting.</returns>
        internal string UpdateWatcherSetting(string settingName, string value)
        {
            return UpdateWatcherSetting(settingName, HttpUtility.UrlEncode(value), "TestWatcher.dll", "xonline.server.marketplace.test.TestWatcher");
        }

        /// <summary>
        /// Updates the specified setting with the specified value.
        /// </summary>
        /// <param name="settingName">The name of the setting to update.</param>
        /// <param name="value">The value to use when updating the specified setting.</param>
        /// <param name="assemblyName">The name of the assembly to reference.</param>
        /// <param name="className">The name of the class to reference.</param>
        /// <returns>The response from the Watcher after updating the setting.</returns>
        internal string UpdateWatcherSetting(string settingName, string value, string assemblyName, string className)
        {
            WebClient client = new WebClient();
            Stream stream = client.OpenRead(
                String.Format("http://{0}:{1}/cron/command.ashx?assembly={2}&classname={3}&op={4}&value={5}",
                    xblobMachineName, watcherPort, assemblyName, className,
                    settingName, value));
            StreamReader reader = new StreamReader(stream);
            string response = reader.ReadToEnd();
            reader.Close();

            return response;
        }

        /// <summary>
        /// Clean up the CDC tables to remove any interfering entries that could disrupt test cases
        /// </summary>
        /// <returns>True if successful, False if unsuccessful.</returns>
        internal bool CleanCDCTables()
        {
            try
            {
                Catalog.ExecuteNonQuery(SQLDisableTransferJob());
                WaitSeconds(10);
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMedia());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCMediaUserRatingAggregate());
                Catalog.ExecuteNonQuery(SQLDeleteFromCDCUsageAggregateFromReporting());
                Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                WaitSeconds(10);
                Catalog.ExecuteNonQuery(SQLEnableTransferJob());
            }
            catch
            {
                return false;
            }

            return true;
        }
        
        #endregion

        #region CDC Related Methods

        /// <summary>
        /// Query string to delete items from the CDC Media table
        /// </summary>
        /// <returns>Query string</returns>
        internal string SQLDeleteFromCDCMedia()
        {
            return "DELETE FROM cdc.dbo_Media_CT";
        }

        /// <summary>
        /// Query string to delete items from the MediaUserRatingAggregate table
        /// </summary>
        /// <returns>Query string</returns>
        internal string SQLDeleteFromCDCMediaUserRatingAggregate()
        {
            return "DELETE FROM cdc.dbo_MediaUserRatingAggregate_CT";
        }

        /// <summary>
        /// Query string to delete items from the UsageAggregateFromReporting table
        /// </summary>
        /// <returns>Query string</returns>
        internal string SQLDeleteFromCDCUsageAggregateFromReporting()
        {
            return "DELETE FROM cdc.dbo_UsageAggregateFromReporting_CT";
        }

        /// <summary>
        /// Query string to delete items from the WatcherToDoProduct table
        /// </summary>
        /// <returns>Query string</returns>
        internal string SQLDeleteFromToDoProduct()
        {
            return "DELETE FROM dbo.CatalogWatcherToDoProduct";
        }

        /// <summary>
        /// Query string to invoke the CatalogWatchertoDoTransferProduct job
        /// </summary>
        /// <returns>Query string</returns>
        internal string SQLExecuteTransferJob()
        {
            return "EXEC dbo.CatalogWatcherToDoTransferProduct";
        }

        /// <summary>
        /// Construct the query for the top 30 media in the Media table.
        /// </summary>
        /// <returns>The query string used to return the top 30 media.</returns>
        internal string QuerySelectTopMediaIdsFromMedia()
        {
            return QuerySelectTopMediaIdsFromMedia(30);
        }

        /// <summary>
        /// Construct the query for the top media in the Media table.  The number of
        /// media to be returned is specified by the count parameter.
        /// </summary>
        /// <param name="count">The number of media to request in the query</param>
        /// <returns>The query string used to return the number of media specified.</returns>
        internal string QuerySelectTopMediaIdsFromMedia(int count)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(String.Format("SELECT TOP({0}) m.mediaId FROM Media m", count));
            sb.AppendLine("JOIN MediaType mt ON mt.mediaTypeId = m.mediaTypeId");
            sb.AppendLine("WHERE mt.mediaTypeId IN");
            sb.AppendLine("(");
            sb.AppendLine("1,  --Game ");
            sb.AppendLine("5,  --Game Trial ");
            sb.AppendLine("18, --Game Content ");
            sb.AppendLine("19, --Game Demo ");
            sb.AppendLine("20, --Theme ");
            sb.AppendLine("21, --Xbox Original Game ");
            sb.AppendLine("22, --Gamer Tile ");
            sb.AppendLine("23, --Arcade Game ");
            sb.AppendLine("24, --Game Consumable ");
            sb.AppendLine("30, --Game Video ");
            sb.AppendLine("34, --Game Trailer ");
            sb.AppendLine("37, --XNA Indie Game ");
            sb.AppendLine("45, --Server Backed Game ");
            sb.AppendLine("46, --Marketplace ");
            sb.AppendLine("47  --AvatarItem ");
            sb.AppendLine(")");
            sb.AppendLine("ORDER BY m.mediaId");

            return sb.ToString();
        }

        /// <summary>
        /// Construct the query for the top media in the Media table.  The number of
        /// media to be returned is specified by the count parameter.
        /// </summary>
        /// <param name="count">The number of media to request in the query</param>
        /// <returns>The query string used to return the number of media specified.</returns>
        internal string QuerySelectTopTitlesFromMediaLocale(int count)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(String.Format("SELECT DISTINCT TOP({0}) ml.mediaid, ml.title FROM MediaLocale ml", count));
            sb.AppendLine("JOIN Media m ON m.mediaId = ml.mediaId");
            sb.AppendLine("JOIN MediaType mt ON mt.mediaTypeId = m.mediaTypeId");
            sb.AppendLine("WHERE mt.mediaTypeId IN");
            sb.AppendLine("(");
            sb.AppendLine("1,  --Game ");
            sb.AppendLine("5,  --Game Trial ");
            sb.AppendLine("18, --Game Content ");
            sb.AppendLine("19, --Game Demo ");
            sb.AppendLine("20, --Theme ");
            sb.AppendLine("21, --Xbox Original Game ");
            sb.AppendLine("22, --Gamer Tile ");
            sb.AppendLine("23, --Arcade Game ");
            sb.AppendLine("24, --Game Consumable ");
            sb.AppendLine("30, --Game Video ");
            sb.AppendLine("34, --Game Trailer ");
            sb.AppendLine("37, --XNA Indie Game ");
            sb.AppendLine("45, --Server Backed Game ");
            sb.AppendLine("46, --Marketplace ");
            sb.AppendLine("47  --AvatarItem ");
            sb.AppendLine(")");
            sb.AppendLine("ORDER BY ml.title");

            return sb.ToString();
        }

        /// <summary>
        /// Construct the query for random media in the Media table.  The number of
        /// media to be returned is specified by the count parameter.
        /// </summary>
        /// <param name="count">The number of media to request in the query</param>
        /// <returns>The query string used to return the number of media specified.</returns>
        internal string QuerySelectRandomTitlesFromMediaLocale(int count)
        {
            return String.Format(@"DECLARE @MediaTypeCatalogWatcherEnabled TABLE(MediaTypeId INT)

INSERT INTO @MediaTypeCatalogWatcherEnabled(MediaTypeId)

EXEC dbo.CatalogWatcherMediaTypes            
            
SELECT DISTINCT TOP({0}) ml.mediaid, ml.title, NEWID() AS randguid FROM MediaLocale ml
JOIN Media m ON m.mediaId = ml.mediaId
JOIN @MediaTypeCatalogWatcherEnabled mt ON mt.mediaTypeId = m.mediaTypeId
ORDER BY randguid", count);
        }

        internal string QuerySelectAllTitlesFromMediaLocale()
        {
            return @"DECLARE @MediaTypeCatalogWatcherEnabled TABLE(MediaTypeId INT)

INSERT INTO @MediaTypeCatalogWatcherEnabled(MediaTypeId)

EXEC dbo.CatalogWatcherMediaTypes            
            
SELECT DISTINCT ml.mediaid, ml.title FROM MediaLocale ml
JOIN Media m ON m.mediaId = ml.mediaId
JOIN @MediaTypeCatalogWatcherEnabled mt ON mt.mediaTypeId = m.mediaTypeId
ORDER BY ml.title";
        }

        /// <summary>
        /// Query string to enable the CDC transfer job
        /// </summary>
        /// <returns>Query string</returns>
        internal string SQLEnableTransferJob()
        {
            return "EXEC msdb.dbo.sp_update_job @job_name='TransferCDCDataSQLJob',@enabled=1";
        }

        /// <summary>
        /// Query string to disable the CDC transfer job
        /// </summary>
        /// <returns>Query string</returns>
        internal string SQLDisableTransferJob()
        {
            return "EXEC msdb.dbo.sp_update_job @job_name='TransferCDCDataSQLJob',@enabled=0";
        }

        /// <summary>
        /// Query string to update the modified date column on the mediaIds specified
        /// </summary>
        /// <param name="mediaIds">The mediaiIds to update</param>
        /// <returns>Query string</returns>
        internal string UpdateMediaModifiedDate(List<string> mediaIds)
        {
            StringBuilder sb = new StringBuilder();
            foreach (string mediaId in mediaIds)
            {
                sb.AppendFormat("UPDATE Media SET modifiedDate=GETDATE() WHERE mediaId = '{0}'", mediaId);
                sb.Append("\n");
            }

            return sb.ToString();
        }

        
        /// <summary>
        /// Query string to update the modified date column on the mediaIds specified
        /// </summary>
        /// <param name="mediaIds">The mediaiIds to update</param>
        /// <returns>Query string</returns>
        internal string UpdateMediaModifiedDateByTitle(List<string[]> titles)
        {
            return UpdateMediaModifiedDateByTitle(titles, String.Empty);
        }

        /// <summary>
        /// Query string to update the modified date column on the mediaIds specified
        /// </summary>
        /// <param name="mediaIds">The mediaiIds to update</param>
        /// <returns>Query string</returns>
        internal string UpdateMediaModifiedDateByTitle(List<string[]> titles, string uniqueTitleModifier)
        {
            StringBuilder sb = new StringBuilder();
            foreach (string[] title in titles)
            {
                sb.AppendLine("UPDATE Media SET modifiedDate=GETDATE() WHERE mediaId IN");
                sb.AppendFormat("(SELECT DISTINCT mediaId FROM MediaLocale WHERE title = \'{0}{1}\')", uniqueTitleModifier, title[1]);
                sb.Append("\n");
            }

            return sb.ToString();
        }

        /// <summary>
        /// Query string to update the modified date column on the mediaIds specified
        /// </summary>
        /// <param name="mediaIds">The mediaiIds to update</param>
        /// <returns>Query string</returns>
        internal string UpdateTitleByTitle(List<string[]> titles, string uniqueTitleModifier)
        {
            StringBuilder sb = new StringBuilder();
            foreach (string[] title in titles)
            {
                sb.AppendFormat("UPDATE MediaLocale SET title='{0}' + title WHERE mediaId IN ", uniqueTitleModifier);
                sb.AppendFormat("(SELECT DISTINCT mediaId FROM MediaLocale WHERE title = \'{0}\')", title[1]);
                sb.Append("\n");
            }

            return sb.ToString();
        }

        internal string RemoveTestcaseTitleModifiers()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("UPDATE MediaLocale SET title = SUBSTRING(title, charindex('*TEST*', title)+7,len(title)+1) ");
            sb.AppendLine("WHERE title LIKE '%*TEST*%'");
            
            return sb.ToString();
        }

        /// <summary>
        /// Query string to get the number of times the specified mediaids occur in the CDC Media table
        /// </summary>
        /// <param name="mediaIds">The mediaIds to filter on.</param>
        /// <returns>Query string</returns>
        internal string GetCountMediasFromCDCMedia(List<string> mediaIds)
        {
            StringBuilder sb = new StringBuilder();

            sb.Append("SELECT COUNT(DISTINCT(mediaId)) FROM cdc.dbo_Media_CT WHERE ");
            foreach (string mediaId in mediaIds)
            {
                sb.AppendFormat("mediaId='{0}' OR ", mediaId);
            }
            sb.Remove(sb.Length - 3, 3); //remove the last OR

            return sb.ToString();
        }

        /// <summary>
        /// Query string to get the number of unique mediaids occur in the CatalogWatcherTodoProduct table
        /// </summary>
        /// <param name="mediaIds">The mediaIds to filter on.</param>
        /// <returns>Query string</returns>
        internal string GetCountUniqueMediasFromToDoProducts(List<string> mediaIds)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("SELECT COUNT(DISTINCT(mediaId)) FROM dbo.CatalogWatcherToDoProduct WHERE ");
            foreach (string mediaId in mediaIds)
            {
                sb.AppendFormat("mediaId='{0}' OR ", mediaId);
            }
            sb.Remove(sb.Length - 3, 3); //remove the last OR

            return sb.ToString();
        }

        /// <summary>
        /// Query string to get the number of times the specified mediaids occur in the CatalogWatcherToDoProduct table
        /// </summary>
        /// <param name="mediaIds">The mediaIds to filter on.</param>
        /// <returns>Query string</returns>
        internal string SQLCountMediasFromToDoProducts(List<string> mediaIds)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("SELECT COUNT(mediaId) FROM dbo.CatalogWatcherToDoProduct WHERE ");
            foreach (string mediaId in mediaIds)
            {
                sb.AppendFormat("mediaId='{0}' OR ", mediaId);
            }
            sb.Remove(sb.Length - 3, 3); //remove the last OR

            return sb.ToString();
        }

        /// <summary>
        /// Query string to get the number of rows in the CatalogWatcherToDoProduct table
        /// </summary>
        /// <returns>Query string</returns>
        internal string GetCountFromToDoProduct()
        {
            return "SELECT COUNT(1) FROM dbo.CatalogWatcherToDoProduct";
        }

        #endregion

        #region FAST Related Methods

        internal void WaitForIndexingToComplete()
        {
            WaitForIndexingToComplete(fastEspInstallation, fastEspCatalog);
        }

        internal void WaitForIndexingToComplete(string fastInstallation, string fastCatalog)
        {
            IDocumentFeeder _documentFeeder = null;
            _documentFeeder = Factory.CreateDocumentFeeder(fastInstallation, fastCatalog);

            // Force the flush to wait until it is completely indexed and searchable
            ISubsystem indexing = _documentFeeder.GetSystemConfig().GetSubsystem("indexing");
            if (indexing != null)
            {
                indexing.CompletedCallbackEnabled = true;
            }

            _documentFeeder.WaitForCompletion();

            // Turn off waiting for the indexing to be finished
            indexing = _documentFeeder.GetSystemConfig().GetSubsystem("indexing");
            if (indexing != null)
            {
                indexing.CompletedCallbackEnabled = false;
            }

            if (_documentFeeder != null)
            {
                _documentFeeder.Dispose();
            }
        }

        internal static List<string> ExecuteFASTSearch(string searchTerm)
        {
            return ExecuteFASTSearch(searchTerm, 0);
        }

        internal static List<string> ExecuteFASTSearch(string searchTerm, int retriesPerDocument)
        {
            IQuery query = new Query(searchTerm);

            if (null == searchView)
            {
                NameValueCollection configuration = new NameValueCollection();
                configuration.Add("Com.FastSearch.Esp.Search.Http.QRServers", fastEspMarketplaceSearch + ":" + fastEspSearchPort);

                ISearchFactory searchFactory = SearchFactory.NewInstance(configuration);

                searchView = searchFactory.GetSearchView(fastEspCatalog.ToLower());

            }

            List<string> resultsList = new List<string>();

            IQueryResult fastResult = searchView.Search(query);
            
            for(int i = 0; i < fastResult.DocCount; i++)
            {
                IDocumentSummary document = null;
                int attempts = 1 ;
                while (document == null)
                {
                    try
                    {
                        document = fastResult.GetDocument(i + 1);
                        IDocumentSummaryField xmlField = document.GetSummaryField("xml");
                        resultsList.Add(xmlField.StringValue);
                    }
                    catch (Exception e)
                    {
                        if(e.Message.Contains("timed out"))
                        {
                            if (attempts <= retriesPerDocument)
                            {
                                Global.RO.Info("Caught an exception while attempting to get a document. Retrying... Attempt: " + attempts + "/" + retriesPerDocument);
                                attempts++;
                            }
                            else
                            {
                                throw e;
                            }
                        } 
                        else 
                        {
                            throw e;
                        }
                    }
                }
            }

            return resultsList;
        }

        internal int ExecuteFASTSearchForRefreshAll(string searchTerm)
        {
            IQuery query = new Query(searchTerm);
            query.SetParameter(new SearchParameter(BaseParameter.HITS, 1));

            if (null == searchView)
            {
                NameValueCollection configuration = new NameValueCollection();
                configuration.Add("Com.FastSearch.Esp.Search.Http.QRServers", fastEspMarketplaceSearch + ":" + fastEspSearchPort);

                ISearchFactory searchFactory = SearchFactory.NewInstance(configuration);

                searchView = searchFactory.GetSearchView(fastEspCatalog.ToLower());

            }

            DateTime start = DateTime.Now;
            IQueryResult fastResult = null;
            int retryAttempts = 1;
            while (fastResult == null)
            {
                try
                {
                    fastResult = searchView.Search(query);
                }
                catch (Com.FastSearch.Esp.Search.SearchEngineException e)
                {
                    if (retryAttempts <= 3)
                    {
                        Global.RO.Info("Caught an exception while attempting to search. Retrying... Attempt: " + retryAttempts + "/3");
                        int minutesToWait = retryAttempts * 1;
                        Global.RO.Info("Waiting {0} minutes before retrying...", minutesToWait);
                        Thread.Sleep(TimeSpan.FromMinutes(minutesToWait));
                        retryAttempts++;
                    }
                    else
                    {
                        Global.RO.Info("Exceeded the number of search retry attempts. Rethrowing the exception...");
                        throw e;
                    }
                }
            }
            DateTime finish = DateTime.Now;
            Global.RO.Info("Search execution time: " + (finish - start).ToString());

            return fastResult.DocCount;
        }

        internal double GetCurrentCounterValue(string category, string counter, string instance)
        {
            System.Diagnostics.PerformanceCounter perfCounter = new System.Diagnostics.PerformanceCounter(
                category,
                counter,
                instance,
                xblobMachineName);

            //ensure that the value returned is not 0
            //If the calculated value of a counter depends on two counter reads, the first read operation returns 0.0
            perfCounter.NextValue();

            return perfCounter.NextValue();
        }

        internal bool WaitForCounterToReachZero(string category, string counter, string instance, int duration)
        {
            System.Diagnostics.PerformanceCounter perfCounter = new System.Diagnostics.PerformanceCounter(
             category,
             counter,
             instance);

            DateTime terminationTime = DateTime.Now.AddSeconds(duration);
            while (perfCounter.NextValue() > 0 &&
                   terminationTime > DateTime.Now)
            {
                Thread.Sleep(1000);
            }

            if (terminationTime <= DateTime.Now)
            {
                return false;
            }

            return true;
        }

        internal void MonitorPerformanceCounter(string category, string counter, string instance, double desiredMinValue, int duration)
        {
            PerfMonitorData data = new PerfMonitorData(category, counter, instance, xblobMachineName, desiredMinValue, duration);
            Thread perfMonitor = new Thread(new ParameterizedThreadStart(PerfMonitorWorker));
            perfMonitor.Start(data);            
        }

        private void PerfMonitorWorker(object state)
        {
            try
            {
                PerfMonitorData data = (PerfMonitorData)state;

                System.Diagnostics.PerformanceCounter perfCounter = data.PerfCounter;
                perfCounter.NextValue();

                Global.RO.Info("Monitoring Performance Counter:");
                Global.RO.Info(String.Format("\tCategory: {0}", data.Category));
                Global.RO.Info(String.Format("\tCounter: {0}", data.Counter));
                Global.RO.Info(String.Format("\tInstance: {0}", data.Instance));
                Global.RO.Info(String.Format("\tDesired Value: {0}", data.DesiredMinValue));

                DateTime terminationTime = DateTime.Now.AddSeconds(data.Duration);
                while (terminationTime > DateTime.Now)
                {
                    if (perfCounter.NextValue() >= data.DesiredMinValue &&
                        PerfCounterTargetReached.GetInvocationList().Length > 0)
                    {
                        PerfCounterTargetReached.Invoke(true, data.Category, data.Counter, data.Instance, data.DesiredMinValue);
                        return;
                    }

                    Thread.Sleep(500);
                }

                if (PerfCounterTargetReached.GetInvocationList().Length > 0)
                {
                    PerfCounterTargetReached.Invoke(false, data.Category, data.Counter, data.Instance, data.DesiredMinValue);
                }
            }
            catch (Exception ex)
            {
                Global.RO.Error(ex.ToString());
                ResultCode = TEST_RESULTS.FAILED;
            }
        }

        internal delegate void PerfCounterTargetReachedDelegate(
            bool desiredValueWasAchieved,
            string performanceCounterCategory,
            string performanceCounter,
            string performanceCounterInstance,
            double performanceCounterValue);

        internal event PerfCounterTargetReachedDelegate PerfCounterTargetReached;

        #endregion

        #region End to End Tests

        internal void PrepareForEndToEndTest()
        {
            NPDB.ExecuteNonQuery(
                UpdateWatcherInterval(
                    60,
                    "CatalogWatcher",
                    "CatalogWatcherPlugin.dll",
                    "xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper"));

            //Clean up the CDC tables to start from a clean state.
            Global.RO.Info("Cleaning the CDC tables...");
            CleanCDCTables();

            //Remove any old modified title strings to start from an clean state.
            Global.RO.Info("Cleaning any previously modified media titles...");
            Catalog.ExecuteNonQuery(
                RemoveTestcaseTitleModifiers());
            
            //Pinging the Cron health check to ensure that the Watcher job will be running.
            PingWatcherHealthCheck();
        }

        private string UpdateWatcherInterval(int seconds, string watcherName, string watcherAssembly, string watcherClass)
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.AppendFormat("UPDATE t_cron_jobs SET i_exec_interval_secs = {0} ", seconds);
            stringBuilder.AppendFormat("WHERE vc_name=\'{0}\' ", watcherName);
            stringBuilder.AppendFormat("AND vc_assembly=\'{0}\' ", watcherAssembly);
            stringBuilder.AppendFormat("AND vc_class=\'{0}\'\n", watcherClass);            
            return stringBuilder.ToString();
        }

        internal string RenameGetProductMedia(string currentName, string newName)
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.AppendFormat("EXEC sp_rename @objName = '{0}', @newname = '{1}', @objtype = 'OBJECT'\n", currentName, newName);
            return stringBuilder.ToString();            
        }

        internal Dictionary<string, string> ModifyMediaAndTitles(int numberToModify, string uniqueTitleModifier)
        {
            Dictionary<string, string> modifiedMedia = new Dictionary<string, string>();
            //Get the first mediaIds from the Media table
            List<string[]> titles = Catalog.ExecuteQueryGetMultiple(
                QuerySelectTopTitlesFromMediaLocale(numberToModify));

            if (titles.Count < numberToModify)
            {
                Global.RO.Warn(
                    String.Format("Only {0} titles were found where {1} were requested for this testcase!", titles.Count, numberToModify));
            }

            foreach (string[] title in titles)
            {
                try
                {
                    Global.RO.Info(
                        String.Format("Updating Title: {0}", title[1]));

                    title[1] = title[1].Replace("'", "''");
                    modifiedMedia.Add(title[0], uniqueTitleModifier + title[1]);
                }
                catch { }
            }

            //Update the title on those top titles
            Global.RO.Info("Update Titles with prepended value of " + uniqueTitleModifier + "in MediaLocale...");
            Catalog.ExecuteNonQuery(
                UpdateTitleByTitle(titles, uniqueTitleModifier));

            //Update the modified date on those top titles
            Global.RO.Info("Update modified date of titles just updated in Media table...");
            Catalog.ExecuteNonQuery(
                UpdateMediaModifiedDateByTitle(titles, uniqueTitleModifier));

            //Give CDC time to catch the changes and move them to the CDC table
            Global.RO.Info("Give CDC time to pick up the changes (10 seconds)...");
            WaitSeconds(10);

            return modifiedMedia;
        }

        internal Dictionary<string, string> GetRandomMediaAndTitles(int numberToReturn)
        {
            Dictionary<string, string> retrievedMedia = new Dictionary<string, string>();

            List<string[]> titles = Catalog.ExecuteQueryGetMultiple(
                QuerySelectRandomTitlesFromMediaLocale(numberToReturn));

            if (titles.Count < numberToReturn)
            {
                Global.RO.Warn(
                    String.Format("Only {0} titles were found where {1} were requested for this testcase!", titles.Count, numberToReturn));
            }

            foreach (string[] title in titles)
            {
                try
                {
                    Global.RO.Info(
                        String.Format("Adding to dictionary: {0},{1}", title[0], title[1]));

                    title[1] = title[1].Replace("'", "''");
                    title[1] = title[1].Replace("\"", "\\\"");
                    retrievedMedia.Add(title[0], title[1]);
                }
                catch { }
            }

            return retrievedMedia;
        }

        internal Dictionary<string, string> GetAllMediaAndTitles()
        {
            Dictionary<string, string> retrievedMedia = new Dictionary<string, string>();

            List<string[]> titles = Catalog.ExecuteQueryGetMultiple(
                QuerySelectAllTitlesFromMediaLocale());

            foreach (string[] title in titles)
            {
                try
                {
                    title[1] = title[1].Replace("'", "''");
                    title[1] = title[1].Replace("\"", "\\\"");
                    retrievedMedia.Add(title[0], title[1]);
                }
                catch { }
            }

            return retrievedMedia;
        }

        internal void WatchFASTForUpdatedDocuments(Dictionary<string, string> modifiedMedia, string uniqueTitleModifier, int retryAttempts)
        {
            int attempt = 0;
            Global.RO.Info("Waiting for the Watcher to wake up and publish the documents.");
            while (attempt++ < retryAttempts)
            {
                Global.RO.Info(String.Format("Waiting 60 seconds before checking (attempt {0}/{1})...", attempt, retryAttempts));
                Thread.Sleep(60000);

                //Execute FQL query and verify that the document made it
                int nonErrorCount = 0;
                List<string> results = null;
                foreach (string mediaId in modifiedMedia.Keys)
                {
                    string fqlQuery = String.Format("xml:searchableXml:AND(filter(title:\"{0}\") AND filter(productId:\"{1}\")", uniqueTitleModifier, mediaId);
                    if (!String.IsNullOrEmpty(fastEspVirtualCollectionName))
                    {
                        fqlQuery += String.Format(" AND filter(virtualCollection:\"{0}\")", fastEspVirtualCollectionName);
                    }
                    fqlQuery += ")";

                    results = ExecuteFASTSearch(fqlQuery, 5);
                    
                    if (results.Count < 1 &&
                        attempt >= retryAttempts)
                    {
                        Global.RO.Error(
                            String.Format("Expected {0} result(s) querying FAST but received {1} for: {2}, {3}",
                            1,
                            results.Count,
                            mediaId,
                            modifiedMedia[mediaId]));
                        
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else if (results.Count > 1)
                    {
                        Global.RO.Warn(
                            String.Format("Expected {0} result(s) querying FAST but received {1} for: {2}, {3}",
                            1,
                            results.Count,
                            mediaId,
                            modifiedMedia[mediaId]));

                        Global.RO.Warn("More results were returned than expected!  If this is not acceptable please update this test cases to " +
                            "result in a FAILURE rather than Passed.");

                        nonErrorCount++;
                    }
                    else if (results.Count == 1 &&
                             results.Contains(modifiedMedia[mediaId]))
                    {
                        nonErrorCount++;
                    }
                }

                if (nonErrorCount == modifiedMedia.Count)
                {
                    Global.RO.Info("All documents have been published.");
                    return;
                }
            }
        }

        internal void WatchFASTForUpdatedDocumentsRefreshAll(string uniqueTitleModifier, int minutesToWait)
        {
            bool allDocsWritten = false;
            DateTime start = DateTime.Now;
            // We have a 3 hour timeout if all the docs were still not found
            while(!allDocsWritten && (start.AddHours(3).CompareTo(DateTime.Now) == 1))
            {
                Global.RO.Info("Waiting {0} minutes for the documents to get published to FAST...", minutesToWait);

                Thread.Sleep(TimeSpan.FromMinutes(minutesToWait));

                Global.RO.Info("Getting the number of distinct mediaId & lcid combinations from the ToDoProducts table so we know how many documents should be returned from FAST after indexing...");
                string selectDistinctCombinationsFromToDoProductsTable = "SELECT DISTINCT RawCatalogDB.dbo.CatalogWatcherToDoProduct.mediaId, RawCatalogDB.dbo.CatalogWatcherToDoProduct.lcid FROM RawCatalogDB.dbo.CatalogWatcherToDoProduct " 
                    + "JOIN RawCatalogDB.dbo.Media ON RawCatalogDB.dbo.CatalogWatcherToDoProduct.mediaId=RawCatalogDB.dbo.Media.mediaId " 
                    + "JOIN RawCatalogDB.dbo.MediaTypeLocale ON RawCatalogDB.dbo.CatalogWatcherToDoProduct.lcid = RawCatalogDB.dbo.MediaTypeLocale.lcid AND RawCatalogDB.dbo.Media.mediaTypeId=RawCatalogDB.dbo.MediaTypeLocale.mediaTypeId";
                List<string[]> results = Catalog.ExecuteQueryGetMultiple(selectDistinctCombinationsFromToDoProductsTable);

                int expectedDocumentCount = results.Count;

                string fqlQuery = String.Format("xml:searchableXml:AND(filter(title:\"{0}\")", uniqueTitleModifier);
                if (!String.IsNullOrEmpty(fastEspVirtualCollectionName))
                {
                    fqlQuery += String.Format(" AND filter(virtualCollection:\"{0}\")", fastEspVirtualCollectionName);
                }
                fqlQuery += ")";

                Global.RO.Info("Issuing query to FAST {0}", fqlQuery);

                int documentCountReturnedFromFAST = ExecuteFASTSearchForRefreshAll(fqlQuery);

                if (expectedDocumentCount == documentCountReturnedFromFAST)
                {
                    allDocsWritten = true;
                    Global.RO.Info("SUCCESS: All documents were published");
                }
                else
                {
                    Global.RO.Info("Not all documents were published (Expected: " + expectedDocumentCount + " Returned: " + documentCountReturnedFromFAST + ")");
                }
            }
            if (!allDocsWritten)
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

        }

        /// <summary>
        /// Updates all of the Catalog Watcher instances in t_cron_jobs to the specified integer
        /// </summary>
        /// 
        /// <param name="enabled">Integer - valid values are 0 and 1</param>
        internal void UpdateCatalogWatcherJobsEnabledStatusInNPDB(int enabled)
        {
            if (enabled == 0 || enabled == 1)
            {
                string watcherEnabledQuery = "UPDATE t_cron_jobs SET b_enabled='" + Convert.ToString(enabled) + "' WHERE vc_assembly=\'CatalogWatcherPlugin.dll\'";
                NPDB.ExecuteNonQuery(watcherEnabledQuery);
            }
            else
            {
                throw new ArgumentException(String.Format("The specified b_enabled value {0} is invalid!", enabled));
            }
        }

        #endregion

        /// <summary>
        /// Used to halt execution for a number of seconds.  Useful to wait for the SQL Server
        /// to run the necessary stored procs or jobs as scheduled before continuing execution.
        /// </summary>
        /// <param name="seconds">Time to wait, in seconds</param>
        internal void WaitSeconds(int seconds)
        {
            Thread.Sleep(seconds * 1000);
        }

        internal string GenerateRandomModifier(int length)
        {            
            StringBuilder stringBuilder = new StringBuilder();
            for (int i = 0; i < length; i++)
            {
                stringBuilder.Append(
                    randomCharacterBase[random.Next(0, randomCharacterBase.Length - 1)]);
            }

            stringBuilder.Append(" *TEST* ");
            return stringBuilder.ToString();
        }

        private class PerfMonitorData
        {
            internal string Category = String.Empty;
            internal string Counter = String.Empty;
            internal string Instance = String.Empty;
            internal string Machine = String.Empty;
            internal double DesiredMinValue = -1;
            internal int Duration = -1;
            internal PerformanceCounter PerfCounter = null;

            internal PerfMonitorData(string category, string counter, string instance, string targetMachine, double desiredMinValue, int duration)
            {
                Category = category;
                Counter = counter;
                Instance = instance;
                Machine = targetMachine;
                DesiredMinValue = desiredMinValue;
                Duration = duration;

                PerfCounter = new PerformanceCounter(
                    category,
                    counter,
                    instance,
                    targetMachine);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\CommandTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using Marketplace.Test.Common.Service;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("jeremyj"), TestFrequency("Daily"), EnvRequirement("XblobOnly,Watcher")]
    public class WatcherCommandTests
    { 
        internal const string WATCHER_ASSEMBLY = "CatalogWatcherPlugin.dll";
        internal const string WATCHER_CLASS = "xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper";
        internal const string WATCHER_REFRESHALL_COMMAND = "RefreshAllProductMedia";
        internal const string WATCHER_REFRESHIDS_COMMAND = "RefreshProductMediaIds";
        internal const string WATCHER_SETENABLE_COMMAND = "WatcherSetEnable";
        internal const string WATCHER_GETPRODUCTDOCUMENTS_SPROC = "RawCatalogDB.dbo.GetProductDocuments";
        internal static string WATCHER_HOST_AND_PORT = String.Empty;
        internal const int SECONDS_TO_WAIT_FOR_WATCHER_SETENABLE = 120;

        private const string CRON_INTERFACE = "cron_int";
        private const string CRON_APPLICATION = "cron";
        private const string WATCHER_PLUGIN = "catalogwatcher%";

        internal static string[] positiveHTTPCommandOutputStrings = new String[]
        {
            "<html><font color=\"#00FF00\">Updated {0} rows. <br>Operation Completed Successfully</font></html>", //0
            "<html><font color=\"#00FF00\">Enabled all the Watcher instances. <br>Operation Completed Successfully</font></html>", //1
            "<html><font color=\"#00FF00\">Disabled all the Watcher instances. <br>Operation Completed Successfully</font></html>" //2
        };

        internal static string[] positiveXmgmtCommandOutputStrings = new String[]
        {
            "Updated {0} rows. \r\nOperation Completed Successfully", //0
            "Enabled all the Watcher instances. \r\nOperation Completed Successfully", //1
            "Disabled all the Watcher instances. \r\nOperation Completed Successfully" //2

        };
        internal static string[] negativeHTTPCommandOutputStrings = new string[] 
        {
            "<html><font color=\"#FF0000\">'op' parameter is missing. Available commands: <br>{0}</font></html>", //0
            "<html><font color=\"#FF0000\">Command failed. Command Name 'op': {0} is invalid. Available commands: <br>{1}</font></html>", //1
            "<html><font color=\"#FF0000\"><br>Command failed because of an invalid parameter.<br>{0}</font></html>", //2
            "<html><font color=\"#FF0000\"><br>Command failed because of a missing parameter.<br>{0}</font></html>", //3
            "<html><font color=\"#FF0000\">Parameter p1 has an invalid guid<br>Command failed because of an invalid parameter.<br>{0}</font></html>", //4
            "<html><font color=\"#FF0000\">One of the mediaIds passed in does not exist in the Catalog or is of the wrong media type<br>Command failed because of an invalid parameter.<br>{0}</font></html>", //5
            "<html><font color=\"#FF0000\">p1 should either be 1 (to enable the watcher) or 0 (to disable the watcher)<br>Command failed because of an invalid parameter.<br>{0}</font></html>" //6

        };

        internal static string[] negativeXmgmtCommandOutputStrings = new string[] 
        {
            "'op' parameter is missing. Available commands: \r\n{0}", //0
            "Command failed. Command Name 'op': {0} is invalid. Available commands: \r\n{1}", //1
            "\r\nCommand failed because of an invalid parameter.\r\n{0}", //2
            "\r\nCommand failed because of a missing parameter.\r\n{0}", //3
            "Parameter p1 has an invalid guid\r\nCommand failed because of an invalid parameter.\r\n{0}", //4
            "One of the mediaIds passed in does not exist in the Catalog or is of the wrong media type\r\nCommand failed because of an invalid parameter.\r\n{0}", //5
            "p1 should either be 1 (to enable the watcher) or 0 (to disable the watcher)\r\nCommand failed because of an invalid parameter.\r\n{0}" //6


        };

        [TestGroupSetup]
        public void Setup() 
        {
            WATCHER_HOST_AND_PORT = Global.XEnv.GetVirtualInterface("cron_int").ToString();
        }

        [TestGroupTearDown]
        public void Shutdown() { }

        #region Utility Functions

        /// <summary>
        /// Builds the HTTP URI string for a Catalog Watcher cron command
        /// </summary>
        /// 
        /// <param name="watcherOperation">The Catalog Watcher cron command operation to issue</param>
        /// <param name="watcherOperationArgs">The arguments for the operation inside a Dictionary object (arg, value)</param>
        /// <returns>HTTP URI string to be used to issue a cron command</returns>
        internal static string BuildHTTPCommandString(string watcherOperation, Dictionary<string, string> watcherOperationArgs)
        {
            string strOperation;

            //If the operation is null we won't supply an operation at all
            if (watcherOperation == null)
            {
                strOperation = String.Empty;
            }
            else
            {
                strOperation = "&op=" + watcherOperation;
            }

            StringBuilder sbWatcherOperationArgs = new StringBuilder();

            //Build a parameter string for the operation
            if (watcherOperationArgs != null)
            {
                foreach (KeyValuePair<string, string> kvp in watcherOperationArgs)
                {
                    sbWatcherOperationArgs.Append("&" + kvp.Key + "=" + kvp.Value);
                }
            }

            return String.Format("http://{0}/cron/command.ashx?assembly={1}&classname={2}{3}{4}",
                WATCHER_HOST_AND_PORT, WATCHER_ASSEMBLY, WATCHER_CLASS, strOperation, sbWatcherOperationArgs.ToString());
        }

        /// <summary>
        /// Builds the Xmgmt command string for a Catalog Watcher cron command
        /// </summary>
        /// 
        /// <param name="watcherOperation">The Catalog Watcher cron command operation to issue</param>
        /// <param name="watcherOperationArgs">The arguments for the operation inside a Dictionary object (arg, value)</param>
        /// <returns>Xmgmt string to be used to issue a cron command</returns>
        internal static string BuildXmgmtCommandString(string watcherOperation, Dictionary<string, string> watcherOperationArgs)
        {
            string strOperation;

            //If the operation is null we won't supply an operation at all
            if (watcherOperation == null)
            {
                strOperation = String.Empty;
            }
            else
            {
                strOperation = watcherOperation;
            }

            StringBuilder sbWatcherOperationArgs = new StringBuilder();

            //Build a parameter string for the operation
            if (watcherOperationArgs != null)
            {
                foreach (KeyValuePair<string, string> kvp in watcherOperationArgs)
                {
                    sbWatcherOperationArgs.Append(" " + kvp.Value);
                }
            }

            return String.Format("e :{0} command {1} {2} {3}",
    CRON_APPLICATION, WATCHER_PLUGIN, strOperation, sbWatcherOperationArgs.ToString());
        }

        /// <summary>
        /// Gets the IPEndPoint for the Environment
        /// </summary>
        private static IPEndPoint EnvironmentIPEndPoint
        {
            get { return Global.XEnv.GetInterface(CRON_INTERFACE)[0]; }
        }

        /// <summary>
        /// Executes the Xmgmt command
        /// </summary>
        /// <param name="xmgmtCommand">The Xmgmt command to be run</param>
        /// <returns>String output of the command result</returns>
        private static string ExecuteXmgmtCommand(string xmgmtCommand)
        {
            //Initialize
            string xmgmtCommandResultString = String.Empty;

            //Execute the command
            bool xmgmtCommandResult = ManagementConsole.Execute(EnvironmentIPEndPoint, xmgmtCommand, out xmgmtCommandResultString);

            //Handle failure
            if (!xmgmtCommandResult)
            {
                throw new Exception("Unable to run xmgmt command");
            }

            return xmgmtCommandResultString;
        }

        /// <summary>
        /// Builds the Ids value string for the RefreshProductMediaIds command when insertion of Ids is NOT desired
        /// </summary>
        /// <param name="dictMedia">Dictionary object containing mediaIds and titles in a key/value pair</param>
        /// <returns>String of the provided mediaIds joined for use as the Ids parameter value</returns>
        internal static string BuildIdsStringFromDictionary(Dictionary<string, string> dictMedia)
        {
            return BuildIdsStringFromDictionary(dictMedia, -1, new string[0]);
        }

        /// <summary>
        /// Builds the Ids value string for the RefreshProductMediaIds command when insertion of Ids is desired
        /// </summary>
        /// <param name="dictMedia">Dictionary object containing mediaIds and titles in a key/value pair</param>
        /// <param name="insertStringsAtIndex">Index at which to insert Ids. Passing in an out-of-bounds index will cause nothing to be inserted.</param>
        /// <param name="stringsToInsert">String array containing the Ids to be inserted at the specified index</param>
        /// <returns>String of the provided mediaIds joined for use as the Ids parameter value</returns>
        internal static string BuildIdsStringFromDictionary(Dictionary<string, string> dictMedia, int insertStringsAtIndex, string[] stringsToInsert)
        {
            //Create a List of mediaIds from the passed in Dictionary
            List<string> mediaIds = new List<string>(dictMedia.Keys);

            //If the specified index is within range insert the Ids from the passed in string array
            if (insertStringsAtIndex > -1 && insertStringsAtIndex <= mediaIds.Count)
            {
                mediaIds.InsertRange(insertStringsAtIndex, stringsToInsert);
            }
            //Join all of the array elements using the AND (.) character
            return String.Join(".", mediaIds.ToArray());
        }

        /// <summary>
        /// Validates the output string against the string in the positive output string array specified when the string is static
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="positiveOutputStringArrayIndex">Index of the positive output string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidatePositiveHTTPCommandOutputString(string downloadedString, int positiveOutputStringArrayIndex)
        {
            return ValidatePositiveHTTPCommandOutputString(downloadedString, positiveOutputStringArrayIndex, String.Empty);
        }

        /// <summary>
        /// Validates the output string against the string in the positive output string array specified when the string contains the number of rows updated
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="positiveOutputStringArrayIndex">Index of the positive output string to validate against</param>
        /// <param name="expectedNumberOfRowsUpdated">The number of rows updated that will be formatted into the string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidatePositiveHTTPCommandOutputString(string downloadedString, int positiveOutputStringArrayIndex, int expectedNumberOfRowsUpdated)
        {
            return ValidatePositiveHTTPCommandOutputString(downloadedString, positiveOutputStringArrayIndex, Convert.ToString(expectedNumberOfRowsUpdated));
        }

        /// <summary>
        /// Validates the output string against the string in the positive output string array specified using the supplied strings to format the string to validate against
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="positiveOutputStringArrayIndex">Index of the positive output string to validate against</param>
        /// <param name="formatValues">The strings that will be formatted into the string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidatePositiveHTTPCommandOutputString(string downloadedString, int positiveOutputStringArrayIndex, params string[] formatValues)
        {
            if (positiveOutputStringArrayIndex > -1 && positiveOutputStringArrayIndex < positiveHTTPCommandOutputStrings.Length)
            {
                string expectedString = String.Format(positiveHTTPCommandOutputStrings[positiveOutputStringArrayIndex], formatValues);

                if (downloadedString == expectedString)
                {
                    Global.RO.Info("Positive Output Validation Succeeded.");
                    return true;
                }
                else
                {
                    Global.RO.Info("Positive Output Validation Failure: \"" + downloadedString + "\" is NOT EQUAL to expected string \"" + expectedString + "\"");
                    return false;
                }

            }
            else
            {
                Global.RO.Info("Positive OutputString Validation Failure: Array index is out of bounds.");
                return false;
            }
        }

        /// <summary>
        /// Validates the output string against the string (specified via the passed in index) in the positive output string array
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="positiveOutputStringArrayIndex">Index of the positive output string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidatePositiveXmgmtCommandOutputString(string downloadedString, int positiveOutputStringArrayIndex)
        {
            return ValidatePositiveXmgmtCommandOutputString(downloadedString, positiveOutputStringArrayIndex, String.Empty);
        }

        /// <summary>
        /// Validates the output string against the string in the positive output string array specified when the string contains the number of rows updated
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="positiveOutputStringArrayIndex">Index of the positive output string to validate against</param>
        /// <param name="expectedNumberOfRowsUpdated">The number of rows updated that will be formatted into the string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidatePositiveXmgmtCommandOutputString(string downloadedString, int positiveOutputStringArrayIndex, int expectedNumberOfRowsUpdated)
        {
            return ValidatePositiveXmgmtCommandOutputString(downloadedString, positiveOutputStringArrayIndex, Convert.ToString(expectedNumberOfRowsUpdated));
        }

        /// <summary>
        /// Validates the output string against the string in the positive output string array specified using the supplied strings to format the string to validate against
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="positiveOutputStringArrayIndex">Index of the positive output string to validate against</param>
        /// <param name="formatValues">The strings that will be formatted into the string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidatePositiveXmgmtCommandOutputString(string downloadedString, int positiveOutputStringArrayIndex, params string[] formatValues)
        {
            if (positiveOutputStringArrayIndex > -1 && positiveOutputStringArrayIndex < positiveXmgmtCommandOutputStrings.Length)
            {
                string expectedString = String.Format(positiveXmgmtCommandOutputStrings[positiveOutputStringArrayIndex], formatValues);

                if (downloadedString == expectedString)
                {
                    Global.RO.Info("Positive Output Validation Succeeded.");
                    return true;
                }
                else
                {
                    Global.RO.Info("Positive Output Validation Failure: \"" + downloadedString + "\" is NOT EQUAL to expected string \"" + expectedString + "\"");
                    return false;
                }

            }
            else
            {
                Global.RO.Info("Positive OutputString Validation Failure: Array index is out of bounds.");
                return false;
            }
        }

        /// <summary>
        /// Validates the output string against the string in the negative output string array specified when the string is static
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="negativeOutputStringArrayIndex">Index of the negative output string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidateNegativeHTTPCommandOutputString(string downloadedString, int negativeOutputStringArrayIndex)
        {
            return ValidateNegativeHTTPCommandOutputString(downloadedString, negativeOutputStringArrayIndex, String.Empty);
        }

        /// <summary>
        /// Validates the output string against the string in the negative output string array specified when the string is static
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="negativeOutputStringArrayIndex">Index of the negative output string to validate against</param>
        /// <param name="formatValues">The strings that will be formatted into the string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidateNegativeHTTPCommandOutputString(string downloadedString, int negativeOutputStringArrayIndex, params string[] formatValues)
        {
            if (negativeOutputStringArrayIndex > -1 && negativeOutputStringArrayIndex < negativeHTTPCommandOutputStrings.Length)
            {
                string expectedString = String.Format(negativeHTTPCommandOutputStrings[negativeOutputStringArrayIndex], formatValues);

                if(downloadedString == expectedString)
                {
                    Global.RO.Info("Negative Output Validation Succeeded.");
                    return true;
                }
                else
                {
                    Global.RO.Info("Negative Output Validation Failure: \"" + downloadedString + "\" is NOT EQUAL to expected string \"" + expectedString + "\"");
                    return false;
                }
                
            }
            else
            {
                Global.RO.Info("Negative Output Validation Failure: Array index is out of bounds.");
                return false;
            }            
        }

        /// <summary>
        /// Validates the output string against the string in the negative output string array specified when the string is static
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="negativeOutputStringArrayIndex">Index of the negative output string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidateNegativeXmgmtCommandOutputString(string downloadedString, int negativeOutputStringArrayIndex)
        {
            return ValidateNegativeXmgmtCommandOutputString(downloadedString, negativeOutputStringArrayIndex, String.Empty);
        }

        /// <summary>
        /// Validates the output string against the string in the negative output string array specified when the string is static
        /// </summary>
        /// <param name="downloadedString">The string to validate</param>
        /// <param name="negativeOutputStringArrayIndex">Index of the negative output string to validate against</param>
        /// <param name="formatValues">The strings that will be formatted into the string to validate against</param>
        /// <returns>Boolean of whether or not the string validation was successful</returns>
        internal static bool ValidateNegativeXmgmtCommandOutputString(string downloadedString, int negativeOutputStringArrayIndex, params string[] formatValues)
        {
            if (negativeOutputStringArrayIndex > -1 && negativeOutputStringArrayIndex < negativeXmgmtCommandOutputStrings.Length)
            {
                string expectedString = String.Format(negativeXmgmtCommandOutputStrings[negativeOutputStringArrayIndex], formatValues);

                if (downloadedString == expectedString)
                {
                    Global.RO.Info("Negative Output Validation Succeeded.");
                    return true;
                }
                else
                {
                    Global.RO.Info("Negative Output Validation Failure: \"" + downloadedString + "\" is NOT EQUAL to expected string \"" + expectedString + "\"");
                    return false;
                }

            }
            else
            {
                Global.RO.Info("Negative Output Validation Failure: Array index is out of bounds.");
                return false;
            }
        }

        /// <summary>
        /// Alters the GetProductMedia sproc to insert a modifier into the product title of each document
        /// </summary>
        /// <param name="wtb">WatcherTestBase object</param>
        /// <param name="sprocText">The sproc to alter</param>
        internal static void AlterGetProductMediaSproc(WatcherTestsBase wtb, string sprocText)
        {
            //Both the original sproc and the changed sproc still have CREATE PROC
            wtb.Catalog.ExecuteNonQuery(sprocText.Replace("CREATE PROC", "ALTER PROC"));
        }

        /// <summary>
        /// Checks whether or not all Catalog Watcher instances are enabled in t_cron_jobs
        /// </summary>
        /// <param name="wtb">WatcherTestBase object<</param>
        /// <returns>Boolean value of whether or not all instances were enabled</returns>
        internal static bool IsEveryCatalogWatcherInstanceEnabled(WatcherTestsBase wtb)
        {
            return ValidateAllCatalogWatcherInstancesEnabledValues(wtb, 1);
        }

        /// <summary>
        /// Checks whether or not all Catalog Watcher instances are disabled in t_cron_jobs
        /// </summary>
        /// <param name="wtb">WatcherTestBase object</param>
        /// <returns>Boolean value of whether or not all instances were disabled</returns>
        internal static bool IsEveryCatalogWatcherInstanceDisabled(WatcherTestsBase wtb)
        {
            return ValidateAllCatalogWatcherInstancesEnabledValues(wtb, 0);
        }

        /// <summary>
        /// Checks whether or not all Catalog Watcher Instance enabled statuses are set to the expected value
        /// </summary>
        /// <param name="wtb">WatcherTestBase object</param>
        /// <param name="expectedEnabledValue">String containing the expected value of the enabled status</param>
        /// <returns></returns>
        internal static bool ValidateAllCatalogWatcherInstancesEnabledValues(WatcherTestsBase wtb, int expectedEnabledValue)
        {
            Global.RO.Info("Waiting {0} seconds for the Catalog Watcher instances enabled status to be changed...", SECONDS_TO_WAIT_FOR_WATCHER_SETENABLE);
            Thread.Sleep(TimeSpan.FromSeconds(SECONDS_TO_WAIT_FOR_WATCHER_SETENABLE));

            string watcherEnabledQuery = "SELECT b_enabled, vc_exec_frontdoor, vc_name FROM t_cron_jobs WHERE vc_assembly=\'" + WatcherCommandTests.WATCHER_ASSEMBLY + "\'";
            List<string[]> result = wtb.NPDB.ExecuteQueryGetMultiple(watcherEnabledQuery);
            if(result.Count > 0)
            {
                foreach (string[] row in result)
                {
                    if (row[0] != Convert.ToString(expectedEnabledValue) && ((expectedEnabledValue == 0) ? (row[1] != String.Empty) : row[1] == String.Empty))
                    {
                        Global.RO.Info(row[2] + "'s vc_exec_frontdoor value was " + row[1] + " and b_enabled value was " + row[0]);
                        return false;
                    }
                }

                Global.RO.Info("All Catalog Watcher instances had the expected enabled status");
                return true;

            } else {
                Global.RO.Info("No results returned when querying for the status of all Catalog Watcher instances.");
                return false;
            }            
        }

        /// <summary>
        /// Shortcut function to get the URL to issue a SetEnable command against the current environment
        /// </summary>
        /// 
        /// <param name="enabled">The value of the p1 parameter</param>
        /// <returns>URL string</returns>
        internal static string CatalogWatcherSetEnableHTTPCommandRequest(string enabled)
        {
            WebClient webClient = new WebClient();

            Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

            //Add the parameter and value to the Dictionary
            watcherOperationArgs.Add("p1", enabled);

            //Build the URL to issue the specified command
            string URL = BuildHTTPCommandString(WATCHER_SETENABLE_COMMAND, watcherOperationArgs);

            Global.RO.Info("HTTP Command: " + URL);

            return webClient.DownloadString(URL);
        }

        /// <summary>
        /// Shortcut function to get the Xmgmt command to issue a SetEnable command against the current environment
        /// </summary>
        /// 
        /// <param name="enabled">The value of the p1 parameter</param>
        /// <returns>Xmgmt string</returns>
        internal static string CatalogWatcherSetEnableXmgmtCommandRequest(string enabled)
        {
            Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

            //Add the parameter and value to the Dictionary
            watcherOperationArgs.Add("p1", enabled);

            //Build the Xmgmt command to issue the specified command
            string xmgmtCommand = BuildXmgmtCommandString(WATCHER_SETENABLE_COMMAND, watcherOperationArgs);

            Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

            return ExecuteXmgmtCommand(xmgmtCommand);
        }

        internal static string GetAvailableHTTPCommands(WatcherTestsBase wtb)
        {
            StringBuilder commandHelp = new StringBuilder("");

            List<string[]> result = wtb.NPDB.ExecuteQueryGetMultiple("EXEC dbo.p_catalog_watcher_get_commands");

            if (result.Count > 0)
            {
                foreach (string[] row in result)
                {
                    commandHelp.Append(String.Format("'{0}', {1}{2}", row[0], row[1], "<br>"));
                }
            }
            else
            {
                Global.RO.Warn("0 Watcher Commands retrieved.");
            }

            return commandHelp.ToString();
        }

        internal static string GetAvailableXmgmtCommands(WatcherTestsBase wtb)
        {
            StringBuilder commandHelp = new StringBuilder("");

            List<string[]> result = wtb.NPDB.ExecuteQueryGetMultiple("EXEC dbo.p_catalog_watcher_get_commands");

            if (result.Count > 0)
            {
                foreach (string[] row in result)
                {
                    commandHelp.Append(String.Format("'{0}', {1}{2}", row[0], row[1], "\r\n"));
                }
            }
            else
            {
                Global.RO.Warn("0 Watcher Commands retrieved.");
            }

            return commandHelp.ToString();
        }

        internal static string GetCommandHelpText(WatcherTestsBase wtb, string commandName)
        {
            StringBuilder commandHelp = new StringBuilder("");

            List<string[]> result = wtb.NPDB.ExecuteQueryGetMultiple("EXEC dbo.p_catalog_watcher_get_command_info " + commandName);

            if (result.Count > 0)
            {
                foreach (string[] row in result)
                {
                    commandHelp.Append(String.Format("'{0}': {1}", commandName, row[2]));
                }
            }
            else
            {
                Global.RO.Warn("Unable to retrieve Watcher Command help text for command '" + commandName + "'.");
            }

            return commandHelp.ToString();
        }

        #endregion

        #region Positive Cases

        #region P_Watcher_HTTP_Command_RefreshAllProductMedia
        [TestCase, TestCasePriority(1), TestFrequency("Daily"), EnvRequirement("XblobOnly,Watcher,Manual")]
        class P_Watcher_HTTP_Command_RefreshAllProductMedia : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_RefreshAllProductMedia() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                StringBuilder originalSprocText = new StringBuilder();

                try
                {
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    Global.RO.Info("Getting the original " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc text...");
                    string getSprocText = @"EXEC sp_helptext '" + WATCHER_GETPRODUCTDOCUMENTS_SPROC + "';";

                    //duplicate the getproductmediasproc
                    List<string[]> result = Catalog.ExecuteQueryGetMultiple(getSprocText);

                    //change the content of the sproc to insert a identifier
                    foreach (string[] row in result)
                    {
                        originalSprocText.Append(row[0]);
                    }

                    string titleModifier = "RefreshAllTest";
                    string guidStr = Guid.NewGuid().ToString().Replace("-", "");
                    string uniqueTitleModifier = " " + guidStr.Substring(0, (guidStr.Length - titleModifier.Length)) + titleModifier;

                    Global.RO.Info("Unique title modifier: \"" + uniqueTitleModifier + "\"");

                    string beforeReplace = "ml.title ";
                    string afterReplace = "ISNULL(STUFF(ml.title, LEN(ml.title), " + uniqueTitleModifier.Length + ", '" + uniqueTitleModifier + "'), '" + uniqueTitleModifier + "') ";

                    StringBuilder alteredSprocText = new StringBuilder(originalSprocText.ToString());

                    alteredSprocText.Replace(beforeReplace, afterReplace);

                    //Alter the sproc
                    Global.RO.Info("Updating the " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc to insert a title modifier in each newly created document...");
                    WatcherCommandTests.AlterGetProductMediaSproc(this, alteredSprocText.ToString());

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetAllMediaAndTitles();

                    //WebClient webClient = new WebClient();

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHALL_COMMAND, null);

                    Global.RO.Info("HTTP Command: " + URL);

                    HttpWebRequest webRequest = (HttpWebRequest) HttpWebRequest.Create(URL);
                    webRequest.Timeout = 45000;
                    HttpWebResponse webResponse = (HttpWebResponse) webRequest.GetResponse();

                    Stream receiveStream = webResponse.GetResponseStream();

                    // Pipes the stream to a higher level stream reader with the required encoding format. 
                    StreamReader readStream = new StreamReader(receiveStream);

                    string downloadedString = readStream.ReadToEnd();

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 0, dictMedia.Count))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 90 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(90));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocumentsRefreshAll(uniqueTitleModifier, 1);
                    }
                }
                finally
                {
                    //WE MUST CHANGE THE SPROC BACK TO IT'S ORIGINAL TEXT
                    Global.RO.Info("Reverting the " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc...");
                    WatcherCommandTests.AlterGetProductMediaSproc(this, originalSprocText.ToString());
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_RefreshProductMediaIds_Single
        [TestCase, TestCasePriority(1), TestFrequency("BVT"), ]
        class P_Watcher_HTTP_Command_RefreshProductMediaIds_Single : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_RefreshProductMediaIds_Single() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int expectedUpdateCount = 1;

                try
                {
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();
                    
                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(expectedUpdateCount);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia));

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);
                    
                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 0, expectedUpdateCount))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 10 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(10));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocuments(dictMedia, "%", 5);
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_RefreshProductMediaIds_Multiple
        [TestCase, TestCasePriority(1)]
        class P_Watcher_HTTP_Command_RefreshProductMediaIds_Multiple : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_RefreshProductMediaIds_Multiple() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int expectedUpdateCount = 5;

                try
                {
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(expectedUpdateCount);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia));

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);



                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 0, expectedUpdateCount))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 10 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(10));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocuments(dictMedia, "%", 5);
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_RefreshAllProductMediaInSuccession
        [TestCase, TestCasePriority(3), EnvRequirement("XblobOnly,Watcher,Manual")]
        class P_Watcher_HTTP_Command_RefreshAllProductMediaInSuccession : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_RefreshAllProductMediaInSuccession() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                StringBuilder originalSprocText = new StringBuilder();
                int commandSubmissions = 5;
                try
                {
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    Global.RO.Info("Getting the original " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc text...");
                    string getSprocText = @"EXEC sp_helptext '" + WATCHER_GETPRODUCTDOCUMENTS_SPROC + "';";

                    //duplicate the getproductmediasproc
                    List<string[]> result = Catalog.ExecuteQueryGetMultiple(getSprocText);

                    //change the content of the sproc to insert a identifier
                    foreach (string[] row in result)
                    {
                        originalSprocText.Append(row[0]);
                    }

                    string titleModifier = "RefreshAllTest";
                    string uniqueTitleModifier = String.Empty;

                    for (int i = 1; i <= commandSubmissions; i++)
                    {
                        Global.RO.Info("Submission: " + i + " of " + commandSubmissions);
                        string guidStr = Guid.NewGuid().ToString().Replace("-", "");
                        uniqueTitleModifier = " " + guidStr.Substring(0, (guidStr.Length - titleModifier.Length)) + titleModifier;

                        Global.RO.Info("Unique title modifier: \"" + uniqueTitleModifier + "\"");

                        string beforeReplace = "ml.title ";
                        string afterReplace = "ISNULL(STUFF(ml.title, LEN(ml.title), " + uniqueTitleModifier.Length + ", '" + uniqueTitleModifier + "'), '" + uniqueTitleModifier + "') ";

                        StringBuilder alteredSprocText = new StringBuilder(originalSprocText.ToString());

                        alteredSprocText.Replace(beforeReplace, afterReplace);

                        //Alter the sproc
                        Global.RO.Info("Updating the " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc to insert a title modifier in each newly created document...");
                        WatcherCommandTests.AlterGetProductMediaSproc(this, alteredSprocText.ToString());

                        // Hit the catalog and get a mediaId + title
                        Dictionary<string, string> dictMedia = GetAllMediaAndTitles();

                        WebClient webClient = new WebClient();

                        //Build the URL to issue the specified command
                        string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHALL_COMMAND, null);

                        Global.RO.Info("HTTP Command: " + URL);

                        string downloadedString = webClient.DownloadString(URL);

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 0, dictMedia.Count))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 90 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(90));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocumentsRefreshAll(uniqueTitleModifier, 1);
                    }
                }
                finally
                {
                    //WE MUST CHANGE THE SPROC BACK TO IT'S ORIGINAL TEXT
                    Global.RO.Info("Reverting the " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc...");
                    WatcherCommandTests.AlterGetProductMediaSproc(this, originalSprocText.ToString());
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_RefreshProductMediaIds_ExtraParameter
        [TestCase, TestCasePriority(3)]
        class P_Watcher_HTTP_Command_RefreshProductMediaIds_ExtraParameter : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_RefreshProductMediaIds_ExtraParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 1;

                try
                {

                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary
                    string refreshIds = BuildIdsStringFromDictionary(dictMedia);
                    watcherOperationArgs.Add("p1", refreshIds);
                    watcherOperationArgs.Add("p2", "extraParameter");

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 0, dictMedia.Count))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 10 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(10));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocuments(dictMedia, "%", 5);
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_SetEnable_False
        [TestCase, TestCasePriority(1)]
        class P_Watcher_HTTP_Command_SetEnable_False : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_SetEnable_False() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {
                        string downloadedString = CatalogWatcherSetEnableHTTPCommandRequest("0");

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 2))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceDisabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cront job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_SetEnable_True
        [TestCase, TestCasePriority(1)]
        class P_Watcher_HTTP_Command_SetEnable_True : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_SetEnable_True() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Disabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    //Check to verify all Watcher Instances aredisabled
                    if (IsEveryCatalogWatcherInstanceDisabled(this))
                    {
                        string downloadedString = CatalogWatcherSetEnableHTTPCommandRequest("1");

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 1))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_SetEnable_False_To_True
        [RunDependency("P_Watcher_HTTP_Command_SetEnable_False")]
        [RunDependency("P_Watcher_HTTP_Command_SetEnable_True")]
        [TestCase, TestCasePriority(1)]
        class P_Watcher_HTTP_Command_SetEnable_False_To_True : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_SetEnable_False_To_True() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Attempting to disable the Catalog Watcher instances via the SetEnable command...");
                    string disableDownloadedString = CatalogWatcherSetEnableHTTPCommandRequest("0");

                    Global.RO.Info("Command Output: " + disableDownloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveHTTPCommandOutputString(disableDownloadedString, 2))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {

                        //Check to verify all Watcher Instances aredisabled
                        if (IsEveryCatalogWatcherInstanceDisabled(this))
                        {
                            Global.RO.Info("Attempting to re-enable the Catalog Watcher instances via the SetEnable command...");
                            string enableDownloadedString = CatalogWatcherSetEnableHTTPCommandRequest("1");

                            Global.RO.Info("Command Output: " + enableDownloadedString);

                            //Fail the case if the positive output string does not validate
                            if (!ValidatePositiveHTTPCommandOutputString(enableDownloadedString, 1))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                            if (ResultCode == TEST_RESULTS.PASSED)
                            {
                                if (!IsEveryCatalogWatcherInstanceEnabled(this))
                                {
                                    ResultCode = TEST_RESULTS.FAILED;
                                }
                            }
                        }
                        else
                        {
                            Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_SetEnable_ExtraParameter
        [TestCase, TestCasePriority(3)]
        class P_Watcher_HTTP_Command_SetEnable_ExtraParameter : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_SetEnable_ExtraParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    Global.RO.Info("Disabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    //Check to verify all Watcher Instances aredisabled
                    if (IsEveryCatalogWatcherInstanceDisabled(this))
                    {
                        WebClient webClient = new WebClient();

                        Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                        //Add the parameter and value to the Dictionary
                        watcherOperationArgs.Add("p1", "1");
                        watcherOperationArgs.Add("p2", "extraParameter");

                        //Build the URL to issue the specified command
                        string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_SETENABLE_COMMAND, watcherOperationArgs);

                        Global.RO.Info("HTTP Command: " + URL);

                        string downloadedString = webClient.DownloadString(URL);

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 1))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_SetEnable_False_Already_Disabled
        [TestCase, TestCasePriority(2)]
        class P_Watcher_HTTP_Command_SetEnable_False_Already_Disabled : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_SetEnable_False_Already_Disabled() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Disabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceDisabled(this))
                    {
                        string downloadedString = CatalogWatcherSetEnableHTTPCommandRequest("0");

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 2))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceDisabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_HTTP_Command_SetEnable_True_Already_Enabled
        [TestCase, TestCasePriority(2)]
        class P_Watcher_HTTP_Command_SetEnable_True_Already_Enabled : WatcherTestsBase
        {
            public P_Watcher_HTTP_Command_SetEnable_True_Already_Enabled() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {
                        string downloadedString = CatalogWatcherSetEnableHTTPCommandRequest("1");

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveHTTPCommandOutputString(downloadedString, 1))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT Enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_RefreshAllProductMedia
        [TestCase, TestCasePriority(1), TestFrequency("Daily"), EnvRequirement("XblobOnly,Watcher,Manual")]
        class P_Watcher_Xmgmt_Command_RefreshAllProductMedia : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_RefreshAllProductMedia() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                StringBuilder originalSprocText = new StringBuilder();

                try
                {
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    Global.RO.Info("Getting the original " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc text...");
                    string getSprocText = @"EXEC sp_helptext '" + WATCHER_GETPRODUCTDOCUMENTS_SPROC + "';";

                    //duplicate the getproductmediasproc
                    List<string[]> result = Catalog.ExecuteQueryGetMultiple(getSprocText);

                    //change the content of the sproc to insert a identifier
                    foreach (string[] row in result)
                    {
                        originalSprocText.Append(row[0]);
                    }

                    string titleModifier = "RefreshAllTest";
                    string guidStr = Guid.NewGuid().ToString().Replace("-", "");
                    string uniqueTitleModifier = " " + guidStr.Substring(0, (guidStr.Length - titleModifier.Length)) + titleModifier;

                    Global.RO.Info("Unique title modifier: \"" + uniqueTitleModifier + "\"");

                    string beforeReplace = "ml.title ";
                    string afterReplace = "ISNULL(STUFF(ml.title, LEN(ml.title), " + uniqueTitleModifier.Length + ", '" + uniqueTitleModifier + "'), '" + uniqueTitleModifier + "') ";

                    StringBuilder alteredSprocText = new StringBuilder(originalSprocText.ToString());

                    alteredSprocText.Replace(beforeReplace, afterReplace);

                    //Alter the sproc
                    Global.RO.Info("Updating the " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc to insert a title modifier in each newly created document...");
                    WatcherCommandTests.AlterGetProductMediaSproc(this, alteredSprocText.ToString());

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetAllMediaAndTitles();

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHALL_COMMAND, null);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 0, dictMedia.Count))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 90 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(90));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocumentsRefreshAll(uniqueTitleModifier, 1);
                    }
                }
                finally
                {
                    //WE MUST CHANGE THE SPROC BACK TO IT'S ORIGINAL TEXT
                    Global.RO.Info("Reverting the " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc...");
                    WatcherCommandTests.AlterGetProductMediaSproc(this, originalSprocText.ToString());
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_RefreshProductMediaIds_Single
        [TestCase, TestCasePriority(1), TestFrequency("BVT"),]
        class P_Watcher_Xmgmt_Command_RefreshProductMediaIds_Single : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_RefreshProductMediaIds_Single() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int expectedUpdateCount = 1;

                try
                {
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(expectedUpdateCount);

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia));

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 0, expectedUpdateCount))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 10 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(10));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocuments(dictMedia, "%", 5);
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_RefreshProductMediaIds_Multiple
        [TestCase, TestCasePriority(1)]
        class P_Watcher_Xmgmt_Command_RefreshProductMediaIds_Multiple : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_RefreshProductMediaIds_Multiple() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int expectedUpdateCount = 5;

                try
                {
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(expectedUpdateCount);

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia));

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 0, expectedUpdateCount))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 10 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(10));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocuments(dictMedia, "%", 5);
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_RefreshAllProductMediaInSuccession
        [TestCase, TestCasePriority(3), EnvRequirement("XblobOnly,Watcher,Manual")]
        class P_Watcher_Xmgmt_Command_RefreshAllProductMediaInSuccession : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_RefreshAllProductMediaInSuccession() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                StringBuilder originalSprocText = new StringBuilder();
                int commandSubmissions = 5;
                try
                {
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    Global.RO.Info("Getting the original " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc text...");
                    string getSprocText = @"EXEC sp_helptext '" + WATCHER_GETPRODUCTDOCUMENTS_SPROC + "';";

                    //duplicate the getproductmediasproc
                    List<string[]> result = Catalog.ExecuteQueryGetMultiple(getSprocText);

                    //change the content of the sproc to insert a identifier
                    foreach (string[] row in result)
                    {
                        originalSprocText.Append(row[0]);
                    }

                    string titleModifier = "RefreshAllTest";
                    string uniqueTitleModifier = String.Empty;

                    for (int i = 1; i <= commandSubmissions; i++)
                    {
                        Global.RO.Info("Submission: " + i + " of " + commandSubmissions);
                        string guidStr = Guid.NewGuid().ToString().Replace("-", "");
                        uniqueTitleModifier = " " + guidStr.Substring(0, (guidStr.Length - titleModifier.Length)) + titleModifier;

                        Global.RO.Info("Unique title modifier: \"" + uniqueTitleModifier + "\"");

                        string beforeReplace = "ml.title ";
                        string afterReplace = "ISNULL(STUFF(ml.title, LEN(ml.title), " + uniqueTitleModifier.Length + ", '" + uniqueTitleModifier + "'), '" + uniqueTitleModifier + "') ";

                        StringBuilder alteredSprocText = new StringBuilder(originalSprocText.ToString());

                        alteredSprocText.Replace(beforeReplace, afterReplace);

                        //Alter the sproc
                        Global.RO.Info("Updating the " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc to insert a title modifier in each newly created document...");
                        WatcherCommandTests.AlterGetProductMediaSproc(this, alteredSprocText.ToString());

                        // Hit the catalog and get a mediaId + title
                        Dictionary<string, string> dictMedia = GetAllMediaAndTitles();

                        //Build the Xmgmt command to issue the specified command
                        string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHALL_COMMAND, null);

                        Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                        string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 0, dictMedia.Count))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 90 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(90));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocumentsRefreshAll(uniqueTitleModifier, 1);
                    }
                }
                finally
                {
                    //WE MUST CHANGE THE SPROC BACK TO IT'S ORIGINAL TEXT
                    Global.RO.Info("Reverting the " + WATCHER_GETPRODUCTDOCUMENTS_SPROC + " sproc...");
                    WatcherCommandTests.AlterGetProductMediaSproc(this, originalSprocText.ToString());
                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_RefreshProductMediaIds_ExtraParameter
        [TestCase, TestCasePriority(3)]
        class P_Watcher_Xmgmt_Command_RefreshProductMediaIds_ExtraParameter : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_RefreshProductMediaIds_ExtraParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 1;

                try
                {

                    Catalog.ExecuteNonQuery(SQLDeleteFromToDoProduct());
                    PrepareForEndToEndTest();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary
                    string refreshIds = BuildIdsStringFromDictionary(dictMedia);
                    watcherOperationArgs.Add("p1", refreshIds);
                    watcherOperationArgs.Add("p2", "extraParameter");

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 0, dictMedia.Count))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        Global.RO.Info("Waiting 10 seconds so the changes have a chance to be picked up...");
                        Thread.Sleep(TimeSpan.FromSeconds(10));

                        Global.RO.Info("Beginning to watch FAST for updated documents...");

                        WatchFASTForUpdatedDocuments(dictMedia, "%", 5);
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_SetEnable_False
        [TestCase, TestCasePriority(1)]
        class P_Watcher_Xmgmt_Command_SetEnable_False : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_SetEnable_False() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {
                        string commandOutput = CatalogWatcherSetEnableXmgmtCommandRequest("0");

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 2))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceDisabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cront job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_SetEnable_True
        [TestCase, TestCasePriority(1)]
        class P_Watcher_Xmgmt_Command_SetEnable_True : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_SetEnable_True() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Disabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    //Check to verify all Watcher Instances aredisabled
                    if (IsEveryCatalogWatcherInstanceDisabled(this))
                    {
                        string commandOutput = CatalogWatcherSetEnableXmgmtCommandRequest("1");

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 1))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_SetEnable_False_To_True
        [RunDependency("P_Watcher_Xmgmt_Command_SetEnable_False")]
        [RunDependency("P_Watcher_Xmgmt_Command_SetEnable_True")]
        [TestCase, TestCasePriority(1)]
        class P_Watcher_Xmgmt_Command_SetEnable_False_To_True : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_SetEnable_False_To_True() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Attempting to disable the Catalog Watcher instances via the SetEnable command...");
                    string disableCommandOutput = CatalogWatcherSetEnableXmgmtCommandRequest("0");

                    Global.RO.Info("Command Output: " + disableCommandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidatePositiveXmgmtCommandOutputString(disableCommandOutput, 2))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (ResultCode == TEST_RESULTS.PASSED)
                    {

                        //Check to verify all Watcher Instances aredisabled
                        if (IsEveryCatalogWatcherInstanceDisabled(this))
                        {
                            Global.RO.Info("Attempting to re-enable the Catalog Watcher instances via the SetEnable command...");
                            string enableCommandOutput = CatalogWatcherSetEnableXmgmtCommandRequest("1");

                            Global.RO.Info("Command Output: " + enableCommandOutput);

                            //Fail the case if the positive output string does not validate
                            if (!ValidatePositiveXmgmtCommandOutputString(enableCommandOutput, 1))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                            if (ResultCode == TEST_RESULTS.PASSED)
                            {
                                if (!IsEveryCatalogWatcherInstanceEnabled(this))
                                {
                                    ResultCode = TEST_RESULTS.FAILED;
                                }
                            }
                        }
                        else
                        {
                            Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_SetEnable_ExtraParameter
        [TestCase, TestCasePriority(3)]
        class P_Watcher_Xmgmt_Command_SetEnable_ExtraParameter : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_SetEnable_ExtraParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    Global.RO.Info("Disabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    //Check to verify all Watcher Instances aredisabled
                    if (IsEveryCatalogWatcherInstanceDisabled(this))
                    {
                        Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                        //Add the parameter and value to the Dictionary
                        watcherOperationArgs.Add("p1", "1");
                        watcherOperationArgs.Add("p2", "extraParameter");

                        //Build the Xmgmt command to issue the specified command
                        string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_SETENABLE_COMMAND, watcherOperationArgs);

                        Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                        string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 1))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_SetEnable_False_Already_Disabled
        [TestCase, TestCasePriority(2)]
        class P_Watcher_Xmgmt_Command_SetEnable_False_Already_Disabled : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_SetEnable_False_Already_Disabled() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Disabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceDisabled(this))
                    {
                        string commandOutput = CatalogWatcherSetEnableXmgmtCommandRequest("0");

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 2))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceDisabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region P_Watcher_Xmgmt_Command_SetEnable_True_Already_Enabled
        [TestCase, TestCasePriority(2)]
        class P_Watcher_Xmgmt_Command_SetEnable_True_Already_Enabled : WatcherTestsBase
        {
            public P_Watcher_Xmgmt_Command_SetEnable_True_Already_Enabled() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {
                        string commandOutput = CatalogWatcherSetEnableXmgmtCommandRequest("1");

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the positive output string does not validate
                        if (!ValidatePositiveXmgmtCommandOutputString(commandOutput, 1))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT Enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #endregion

        #region Negative Cases

        #region N_Watcher_HTTP_Command_NoParameters

        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_NoParameters : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_NoParameters() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(null, null);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 0, GetAvailableHTTPCommands(this)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_InvalidOperationParameter
        [TestCase, TestCasePriority(2)]
        class N_Watcher_HTTP_Command_InvalidOperationParameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_InvalidOperationParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    string command = "notValid";

                    WebClient webClient = new WebClient();

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(command, null);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 1, command, GetAvailableHTTPCommands(this)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshAllProductMediaExtraParameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_RefreshAllProductMediaExtraParameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshAllProductMediaExtraParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", Guid.NewGuid().ToString());

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHALL_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 2, GetCommandHelpText(this, WATCHER_REFRESHALL_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_NoParameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_NoParameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_NoParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, null);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 3, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_InvalidParameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_InvalidParameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_InvalidParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p6", Guid.NewGuid().ToString());

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 3, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_EmptyParameter

        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_EmptyParameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_EmptyParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", String.Empty);

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 3, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_IntegerParameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_IntegerParameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_IntegerParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", "1");

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_MalformedGUIDParameter
        [TestCase, TestCasePriority(1)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_MalformedGUIDParameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_MalformedGUIDParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", "66acd00077fe-1000-9115-d802-585807ef");

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_SingleNotInCatalog
        [TestCase, TestCasePriority(1)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_SingleOneNotInCatalog : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_SingleOneNotInCatalog() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", Guid.NewGuid().ToString());

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 5, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiIntegerParameters
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiIntegerParameters : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiIntegerParameters() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", "1.1.1");

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithEmpty
        [TestCase, TestCasePriority(2)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithEmpty : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithEmpty() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 2;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia, 1, new string[] { String.Empty }));

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithInteger
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithInteger : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithInteger() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 2;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia, 1, new string[] { "1" }));

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithMalformedGUID
        [TestCase, TestCasePriority(1)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithMalformedGUID : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiWithMalformedGUID() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 2;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia, 1, new string[] { "66acd00077fe-1000-9115-d802-585807ef" }));

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiMalformedGUIDs
        [TestCase, TestCasePriority(2)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiMalformedGUIDs : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiMalformedGUIDs() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", "66acd00077fe-1000-9115-d802-585807ef.66acd00077fe-10-009115-d802-585807ef.66acd00077fe-1000-9115d8-02-585807ef");

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiNotInCatalog
        [TestCase, TestCasePriority(1)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiNotInCatalog : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiNotInCatalog() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", Guid.NewGuid().ToString() + "." + Guid.NewGuid().ToString() + "." + Guid.NewGuid().ToString());

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 5, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_EndsWithAnd
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_EndsWithAnd : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_EndsWithAnd() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 1;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary along with the trailing AND (.)
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia) + ".");

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiOneNotInCatalog
        [TestCase, TestCasePriority(2)]
        class N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiOneNotInCatalog : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_RefreshProductMediaIds_MultiOneNotInCatalog() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 2;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia, 1, new string[] { Guid.NewGuid().ToString() }));

                    //Build the URL to issue the specified command
                    string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("HTTP Command: " + URL);

                    string downloadedString = webClient.DownloadString(URL);

                    Global.RO.Info("Command Output: " + downloadedString);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 5, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_SetEnable_No_Parameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_SetEnable_No_Parameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_SetEnable_No_Parameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    PingWatcherHealthCheck();

                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {

                        WebClient webClient = new WebClient();

                        //Build the URL to issue the specified command
                        string URL = WatcherCommandTests.BuildHTTPCommandString(WATCHER_SETENABLE_COMMAND, null);

                        Global.RO.Info("HTTP Command: " + URL);

                        string downloadedString = webClient.DownloadString(URL);

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the negative output string does not validate
                        if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 3, GetCommandHelpText(this, WATCHER_SETENABLE_COMMAND)))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_SetEnable_Invalid_Parameter_Integer
        [TestCase, TestCasePriority(1)]
        class N_Watcher_HTTP_Command_SetEnable_Invalid_Parameter_Integer : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_SetEnable_Invalid_Parameter_Integer() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    PingWatcherHealthCheck();

                    Global.RO.Info("Disabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceDisabled(this))
                    {
                        string downloadedString = CatalogWatcherSetEnableHTTPCommandRequest("9");

                        Global.RO.Info("Command Output: " + downloadedString);

                        if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 6, GetCommandHelpText(this, WATCHER_SETENABLE_COMMAND)))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceDisabled(this))
                            {
                                Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_SetEnable_Invalid_Parameter_String
        [TestCase, TestCasePriority(1)]
        class N_Watcher_HTTP_Command_SetEnable_Invalid_Parameter_String : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_SetEnable_Invalid_Parameter_String() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    PingWatcherHealthCheck();

                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {
                        string downloadedString = CatalogWatcherSetEnableHTTPCommandRequest("invalid");

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the negative output string does not validate
                        if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 6, GetCommandHelpText(this, WATCHER_SETENABLE_COMMAND)))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_HTTP_Command_SetEnable_Empty_Parameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_HTTP_Command_SetEnable_Empty_Parameter : WatcherTestsBase
        {
            public N_Watcher_HTTP_Command_SetEnable_Empty_Parameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    PingWatcherHealthCheck();

                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {
                        string downloadedString = CatalogWatcherSetEnableHTTPCommandRequest(String.Empty);

                        Global.RO.Info("Command Output: " + downloadedString);

                        //Fail the case if the negative output string does not validate
                        if (!ValidateNegativeHTTPCommandOutputString(downloadedString, 3, GetCommandHelpText(this, WATCHER_SETENABLE_COMMAND)))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion



        #region N_Watcher_Xmgmt_Command_NoParameters

        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_NoParameters : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_NoParameters() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(null, null);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 0, GetAvailableXmgmtCommands(this)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_InvalidOperationParameter
        [TestCase, TestCasePriority(2)]
        class N_Watcher_Xmgmt_Command_InvalidOperationParameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_InvalidOperationParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    string command = "notValid";

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(command, null);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 1, command, GetAvailableXmgmtCommands(this)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshAllProductMediaExtraParameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_RefreshAllProductMediaExtraParameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshAllProductMediaExtraParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", Guid.NewGuid().ToString());

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHALL_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 2, GetCommandHelpText(this, WATCHER_REFRESHALL_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_NoParameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_NoParameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_NoParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, null);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 3, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_InvalidParameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_InvalidParameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_InvalidParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p6", Guid.NewGuid().ToString());

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 5, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_EmptyParameter

        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_EmptyParameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_EmptyParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", String.Empty);

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 3, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_IntegerParameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_IntegerParameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_IntegerParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", "1");

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MalformedGUIDParameter
        [TestCase, TestCasePriority(1)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MalformedGUIDParameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MalformedGUIDParameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", "66acd00077fe-1000-9115-d802-585807ef");

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_SingleNotInCatalog
        [TestCase, TestCasePriority(1)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_SingleOneNotInCatalog : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_SingleOneNotInCatalog() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", Guid.NewGuid().ToString());

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 5, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiIntegerParameters
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiIntegerParameters : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiIntegerParameters() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();
                    watcherOperationArgs.Add("p1", "1.1.1");

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithEmpty
        [TestCase, TestCasePriority(2)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithEmpty : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithEmpty() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 2;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia, 1, new string[] { String.Empty }));

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithInteger
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithInteger : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithInteger() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 2;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    WebClient webClient = new WebClient();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia, 1, new string[] { "1" }));

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithMalformedGUID
        [TestCase, TestCasePriority(1)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithMalformedGUID : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiWithMalformedGUID() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 2;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia, 1, new string[] { "66acd00077fe-1000-9115-d802-585807ef" }));

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiMalformedGUIDs
        [TestCase, TestCasePriority(2)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiMalformedGUIDs : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiMalformedGUIDs() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", "66acd00077fe-1000-9115-d802-585807ef.66acd00077fe-10-009115-d802-585807ef.66acd00077fe-1000-9115d8-02-585807ef");

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiNotInCatalog
        [TestCase, TestCasePriority(1)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiNotInCatalog : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiNotInCatalog() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    PingWatcherHealthCheck();

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", Guid.NewGuid().ToString() + "." + Guid.NewGuid().ToString() + "." + Guid.NewGuid().ToString());

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 5, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_EndsWithAnd
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_EndsWithAnd : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_EndsWithAnd() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 1;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary along with the trailing AND (.)
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia) + ".");

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 4, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiOneNotInCatalog
        [TestCase, TestCasePriority(2)]
        class N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiOneNotInCatalog : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_RefreshProductMediaIds_MultiOneNotInCatalog() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int numberOfProductsForTest = 2;

                try
                {
                    PingWatcherHealthCheck();

                    // Hit the catalog and get a mediaId + title
                    Dictionary<string, string> dictMedia = GetRandomMediaAndTitles(numberOfProductsForTest);

                    Dictionary<string, string> watcherOperationArgs = new Dictionary<string, string>();

                    //Add the parameter and value to the Dictionary inserting a new random GUID
                    watcherOperationArgs.Add("p1", BuildIdsStringFromDictionary(dictMedia, 1, new string[] { Guid.NewGuid().ToString() }));

                    //Build the Xmgmt command to issue the specified command
                    string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_REFRESHIDS_COMMAND, watcherOperationArgs);

                    Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                    string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                    Global.RO.Info("Command Output: " + commandOutput);

                    //Fail the case if the positive output string does not validate
                    if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 5, GetCommandHelpText(this, WATCHER_REFRESHIDS_COMMAND)))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_SetEnable_No_Parameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_SetEnable_No_Parameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_SetEnable_No_Parameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    PingWatcherHealthCheck();

                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {

                        WebClient webClient = new WebClient();

                        //Build the Xmgmt command to issue the specified command
                        string xmgmtCommand = WatcherCommandTests.BuildXmgmtCommandString(WATCHER_SETENABLE_COMMAND, null);

                        Global.RO.Info("Xmgmt Command: " + xmgmtCommand);

                        string commandOutput = ExecuteXmgmtCommand(xmgmtCommand);

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the negative output string does not validate
                        if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 3, GetCommandHelpText(this, WATCHER_SETENABLE_COMMAND)))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_SetEnable_Invalid_Parameter_Integer
        [TestCase, TestCasePriority(1)]
        class N_Watcher_Xmgmt_Command_SetEnable_Invalid_Parameter_Integer : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_SetEnable_Invalid_Parameter_Integer() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    PingWatcherHealthCheck();

                    Global.RO.Info("Disabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceDisabled(this))
                    {
                        string commandOutput = CatalogWatcherSetEnableXmgmtCommandRequest("9");

                        Global.RO.Info("Command Output: " + commandOutput);

                        if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 6, GetCommandHelpText(this, WATCHER_SETENABLE_COMMAND)))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceDisabled(this))
                            {
                                Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT disabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_SetEnable_Invalid_Parameter_String
        [TestCase, TestCasePriority(1)]
        class N_Watcher_Xmgmt_Command_SetEnable_Invalid_Parameter_String : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_SetEnable_Invalid_Parameter_String() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    PingWatcherHealthCheck();

                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {
                        string commandOutput = CatalogWatcherSetEnableXmgmtCommandRequest("invalid");

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the negative output string does not validate
                        if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 6, GetCommandHelpText(this, WATCHER_SETENABLE_COMMAND)))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #region N_Watcher_Xmgmt_Command_SetEnable_Empty_Parameter
        [TestCase, TestCasePriority(3)]
        class N_Watcher_Xmgmt_Command_SetEnable_Empty_Parameter : WatcherTestsBase
        {
            public N_Watcher_Xmgmt_Command_SetEnable_Empty_Parameter() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    PingWatcherHealthCheck();

                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    //Check to verify all Watcher Instances are enabled
                    if (IsEveryCatalogWatcherInstanceEnabled(this))
                    {
                        string commandOutput = CatalogWatcherSetEnableXmgmtCommandRequest(String.Empty);

                        Global.RO.Info("Command Output: " + commandOutput);

                        //Fail the case if the negative output string does not validate
                        if (!ValidateNegativeXmgmtCommandOutputString(commandOutput, 3, GetCommandHelpText(this, WATCHER_SETENABLE_COMMAND)))
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        if (ResultCode == TEST_RESULTS.PASSED)
                        {
                            if (!IsEveryCatalogWatcherInstanceEnabled(this))
                            {
                                Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Info("All Catalog Watcher cron job instances were NOT enabled");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                finally
                {
                    Global.RO.Info("Enabling all " + WATCHER_ASSEMBLY + " cron job instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                }

                Global.RO.Info("Test completed.");
            }
        }
        #endregion

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\DatabaseExtensions.cs ===
﻿using System.Data;

/// <summary>
/// Set of extension methods to use on the sql data reader
/// </summary>
public static class DatabaseExtensions
{
    /// <summary>
    /// Coalesce operator for the sql data reader. Returns a default value if 
    /// the reader reads a null value
    /// </summary>
    /// <typeparam name="T">Object return type</typeparam>
    /// <param name="reader">Sql data reader</param>
    /// <param name="name">The name of the column</param>
    /// <returns>The Sql Value if not null, or the default value of the type</returns>
    public static T Coalesce<T>(this IDataReader reader, string name)
    {
        return reader.IsDBNull(reader.GetOrdinal(name)) ? default(T) : (T)reader[name];
    }

    /// <summary>
    /// Coalesce operator for the sql data reader. Returns the specified default value if 
    /// the reader reads a null value
    /// </summary>
    /// <typeparam name="T">Object return type</typeparam>
    /// <param name="reader">Sql data reader</param>
    /// <param name="name">The name of the column</param>
    /// <param name="defaultValue">The default value to return</param>
    /// <returns>Value in the column</returns>
    public static T Coalesce<T>(this IDataReader reader, string name, T defaultValue)
    {
        return reader.IsDBNull(reader.GetOrdinal(name)) ? defaultValue : (T)reader[name];
    }

    /// <summary>
    /// Returns the value by using the column index
    /// </summary>
    /// <typeparam name="T">Object return type</typeparam>
    /// <param name="reader">Sql data reader</param>
    /// <param name="name">The name of the column</param>
    /// <returns>Value in the column</returns>
    public static T GetValue<T>(this IDataReader reader, string name)
    {
        return (T)reader.GetValue(reader.GetOrdinal(name));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\WatcherTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using Marketplace.Test.Common.Service;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("alexappa"), TestFrequency("Daily"), EnvRequirement("Watcher")]
    public class WatcherTests
    {
        private static string initialDateTime = "1900-01-01 00:00:00:000";
        private static List<string> scheduleSettingsToMonitor = null;
        private static List<string> initialScheduleSettingValues = null;

        [TestGroupSetup]
        public void Setup() 
        {
            //todo - determine how to handle installation and setup of the test watcher
            scheduleSettingsToMonitor = new List<string>(new string[] { "dt_exec_next_scheduled", "dt_exec_next_actual" });
            initialScheduleSettingValues = new List<string>(new string[] { initialDateTime, initialDateTime });
        }

        [TestGroupTearDown]
        public void Shutdown() { }

        [TestCase, TestCasePriority(1)]
        class Cron_Standard_Duration_Job : WatcherTestsBase       
        {
            public Cron_Standard_Duration_Job() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                
                //prepare the watcher for the test (will result in the watcher being disabled)
                PrepareWatcherForTest(false, 60, 120, initialDateTime, initialDateTime);
                
                //set the watcher lifetime to be smaller than the interval seconds
                UpdateWatcherSetting("setwatcherlifetime", 
                    String.Format("<PluginContext><attribute name=\"runseconds\" type=\"System.Int32\">{0}</attribute></PluginContext>", 30));

                //enable the watcher
                UpdateWatcherSetting("setenabled", true);
                
                //verify that the expected and actual scheduled times are updated
                List<string> finalSettingValues = MonitorForChanges(scheduleSettingsToMonitor, 195, 1);
                if (null == finalSettingValues) { return; } 
                
                for (int i = 0; i < initialScheduleSettingValues.Count; i++)
                {
                    if (initialScheduleSettingValues[i] == finalSettingValues[i])
                    {
                        Global.RO.Error(String.Format("{0} was expected to have a different value but did not.  {1} == {2}", 
                            scheduleSettingsToMonitor[i], initialScheduleSettingValues[i], finalSettingValues[i]));
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }

                //verify that the updated times are the same
                if (finalSettingValues[0] != finalSettingValues[1])
                {
                    Global.RO.Error(
                        String.Format("The expected values for dt_exec_next_scheduled and dt_exec_next_actual did not match as expected.  {0} != {1}",
                            finalSettingValues[0], finalSettingValues[1]));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }                

                Global.RO.Info("Test completed.");
            }           
        }

        [TestCase, TestCasePriority(1)]
        class Cron_Long_Running_Duration_Job : WatcherTestsBase
        {
            public Cron_Long_Running_Duration_Job() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //prepare the watcher for the test (will result in the watcher being disabled)
                PrepareWatcherForTest(false, 60, 120, initialDateTime, initialDateTime);

                //set the watcher lifetime to be smaller than the interval seconds
                UpdateWatcherSetting("setwatcherlifetime",
                    String.Format("<PluginContext><attribute name=\"runseconds\" type=\"System.Int32\">{0}</attribute></PluginContext>", 150));

                //enable the watcher
                UpdateWatcherSetting("setenabled", true);

                //monitor for changes after the specified amount of seconds
                List<string> finalSettingValues = MonitorForChanges(scheduleSettingsToMonitor, 195, 1);
                if (null == finalSettingValues) { return; }
                Global.RO.Info("Current Next Scheduled: " + finalSettingValues[0]);
                Global.RO.Info("Current Actual Scheduled: " + finalSettingValues[1]);

                //monitor for changes after the specified amount of seconds
                finalSettingValues = MonitorForChanges(scheduleSettingsToMonitor, 60, 1);
                if (null == finalSettingValues) { return; }
                Global.RO.Info("Final Next Scheduled: " + finalSettingValues[0]);
                Global.RO.Info("Final Actual Scheduled: " + finalSettingValues[1]);

                //verify that the expected and actual scheduled times are updated                
                for (int i = 0; i < initialScheduleSettingValues.Count; i++)
                {
                    if (initialScheduleSettingValues[i] == finalSettingValues[i])
                    {
                        Global.RO.Error(String.Format("{0} was expected to have a different value but did not.  {1} == {2}",
                            scheduleSettingsToMonitor[i], initialScheduleSettingValues[i], finalSettingValues[i]));
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }

                //verify that the actual time is later than the next scheduled time
                if (finalSettingValues[0] != finalSettingValues[1])
                {
                    Global.RO.Error(
                        String.Format("The expected value for dt_exec_next_scheduled was not less than dt_exec_next_actual as expected.  {0} >= {1}",
                            finalSettingValues[0], finalSettingValues[1]));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                Global.RO.Info("Test completed.");
            }
        }

        [TestCase, TestCasePriority(1)]
        class Cron_Long_Running_Duration_Followed_By_Standard_Job : WatcherTestsBase
        {
            public Cron_Long_Running_Duration_Followed_By_Standard_Job() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //prepare the watcher for the test (will result in the watcher being disabled)
                PrepareWatcherForTest(false, 60, 120, initialDateTime, initialDateTime);

                //set the watcher lifetime to be smaller than the interval seconds
                UpdateWatcherSetting(
                    "setwatcherlifetime",
                    String.Format(
                        "<PluginContext><attribute name=\"runseconds\" type=\"System.Int32\">{0}</attribute></PluginContext>",
                        150));

                //enable the watcher
                UpdateWatcherSetting("setenabled", true);

                //verify that the expected and actual scheduled times are updated
                List<string> finalSettingValues = MonitorForChanges(scheduleSettingsToMonitor, 195, 1);
                if (null == finalSettingValues) { return; }
                Global.RO.Info("Current Next Scheduled: " + finalSettingValues[0]);
                Global.RO.Info("Current Actual Scheduled: " + finalSettingValues[1]);

                //set the watcher lifetime to be smaller than the interval seconds while it is currently running
                UpdateWatcherSetting("setwatcherlifetime",
                    String.Format("<PluginContext><attribute name=\"runseconds\" type=\"System.Int32\">{0}</attribute></PluginContext>", 30));

                //monitor for changes after the specified amount of seconds
                finalSettingValues = MonitorForChanges(scheduleSettingsToMonitor, 60, 1);
                if (null == finalSettingValues) { return; }
                Global.RO.Info("Current Next Scheduled: " + finalSettingValues[0]);
                Global.RO.Info("Current Actual Scheduled: " + finalSettingValues[1]);

                //monitor for changes after the specified amount of seconds
                finalSettingValues = MonitorForChanges(scheduleSettingsToMonitor, 195, 1);
                if (null == finalSettingValues) { return; }
                Global.RO.Info("Final Next Scheduled: " + finalSettingValues[0]);
                Global.RO.Info("Final Actual Scheduled: " + finalSettingValues[1]);

                //verify that the expected and actual scheduled times are updated                
                for (int i = 0; i < initialScheduleSettingValues.Count; i++)
                {
                    if (initialScheduleSettingValues[i] == finalSettingValues[i])
                    {
                        Global.RO.Error(String.Format("{0} was expected to have a different value but did not.  {1} == {2}",
                            scheduleSettingsToMonitor[i], initialScheduleSettingValues[i], finalSettingValues[i]));
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }

                //verify that the updated times are the same
                if (finalSettingValues[0] != finalSettingValues[1])
                {
                    Global.RO.Error(
                        String.Format("The expected values for dt_exec_next_scheduled and dt_exec_next_actual did not match as expected.  {0} != {1}",
                            finalSettingValues[0], finalSettingValues[1]));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                Global.RO.Info("Test completed.");
            }
        } 

        internal static string ValidateCronHealthCheckStatus(string expectedStatus)
        {
            string URL = String.Format("http://{0}/cron/health.ashx?stylesheet=no&op=status", Global.XEnv.GetVirtualInterface("cron_int").ToString());

            XmlReader xmlReader = XmlReader.Create(URL);

            if (xmlReader.ReadToFollowing("Healthcheck"))
            {
                string healthStatus = xmlReader.GetAttribute("HealthStatus");

                if (healthStatus != null && healthStatus.ToLower() == expectedStatus.ToLower())
                {
                    Global.RO.Info("Success! Healthcheck was " + expectedStatus + ".");
                    return String.Empty;
                }
                else
                {
                    Global.RO.Info("Failure! Healthcheck status " + healthStatus + " was NOT EQUAL to " + expectedStatus + ".");
                    while(xmlReader.ReadToFollowing("HealthReport"))
                    {
                        string currentHealthReport = xmlReader.GetAttribute("Name");
                        if(currentHealthReport != null && currentHealthReport == "CronJobInfo")
                        {
                            if(xmlReader.ReadToFollowing("ErrorDetails"))
                            {
                                return xmlReader.ReadString();
                            } else 
                            {
                                break;
                            }
                        }
                    }

                    return "Unable to get the error message from the HealthReport";
                }
            } else {
                return "Healthcheck XML element was NOT found";
            }
        }

        [TestCase, Owner("jeremyj"), TestCasePriority(3), EnvRequirement("Watcher, XblobOnly, Manual")]
        class Cron_Health_Check_Green : WatcherTestsBase
        {
            public Cron_Health_Check_Green() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    Global.RO.Info("Re-enabling all of the catalog watcher instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                    Global.RO.Info("Waiting 120 seconds so we hit the next Catalog Watcher interval...");
                    Thread.Sleep(TimeSpan.FromSeconds(120));

                    string result = ValidateCronHealthCheckStatus("green");

                    if(result != String.Empty)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Info("Health check was NOT green as expected.");
                        Global.RO.Info("Error Details from CronJobInfo health report:");
                        Global.RO.Info(result);
                    }
                }
                finally { }

                Global.RO.Info("Test completed.");
            }
        }

        [TestCase, Owner("jeremyj"), TestCasePriority(3), EnvRequirement("Watcher, XblobOnly, Manual")]
        class Cron_Health_Check_Yellow : WatcherTestsBase
        {
            public Cron_Health_Check_Yellow() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    Global.RO.Info("Disabling all of the catalog watcher instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(0);

                    Global.RO.Info("Waiting 120 seconds so we hit the next Catalog Watcher interval...");
                    Thread.Sleep(TimeSpan.FromSeconds(120));

                    string result = ValidateCronHealthCheckStatus("yellow");

                    if(result != String.Empty)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Info("Health check was NOT yellow as expected.");
                        Global.RO.Info("Error Details from CronJobInfo health report:");
                        Global.RO.Info(result);
                    }
                }
                finally
                {
                    Global.RO.Info("Re-enabling all of the catalog watcher instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                    Global.RO.Info("Waiting 120 seconds so we hit the next Catalog Watcher interval...");
                    Thread.Sleep(TimeSpan.FromSeconds(120));
                }

                Global.RO.Info("Test completed.");
            }
        }

        [TestCase, Owner("jeremyj"), TestCasePriority(3), EnvRequirement("Watcher, XblobOnly, Manual")]
        class Cron_Health_Check_Red_Bad_Assembly : WatcherTestsBase
        {
            public Cron_Health_Check_Red_Bad_Assembly() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    //UPDATE THE DLL FOR THE CATALOG WATCHER INSTANCES TO BE FALSE
                    Global.RO.Info("Updating the Catalog Watcher instances to use a bad assembly...");
                    string updateAndBreakCatalogWatcherInstances = "UPDATE t_cron_jobs SET vc_assembly='TESTCronHealthCheckShouldBeRed.dll' WHERE vc_assembly='CatalogWatcherPlugin.dll'";
                    NPDB.ExecuteNonQuery(updateAndBreakCatalogWatcherInstances);

                    Global.RO.Info("Waiting 120 seconds so we hit the next Catalog Watcher interval...");
                    Thread.Sleep(TimeSpan.FromSeconds(120));

                    string result = ValidateCronHealthCheckStatus("red");

                    if(result != String.Empty)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Info("Health check was NOT red as expected.");
                        Global.RO.Info("Error Details from CronJobInfo health report:");
                        Global.RO.Info(result);
                    }
                }
                finally
                {
                    Global.RO.Info("Updating the Catalog Watcher instances to use the assembly...");
                    string updateAndFixCatalogWatcherInstances = "UPDATE t_cron_jobs SET vc_assembly='CatalogWatcherPlugin.dll' WHERE vc_assembly='TESTCronHealthCheckShouldBeRed.dll'";
                    NPDB.ExecuteNonQuery(updateAndFixCatalogWatcherInstances);

                    Global.RO.Info("Re-enabling all of the catalog watcher instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                    Global.RO.Info("Waiting 120 seconds so we hit the next Catalog Watcher interval...");
                    Thread.Sleep(TimeSpan.FromSeconds(120));
                }

                Global.RO.Info("Test completed.");
            }
        }

        [TestCase, Owner("jeremyj"), TestCasePriority(3), EnvRequirement("Watcher, XblobOnly, Manual")]
        class Cron_Health_Check_Red_Bad_Args : WatcherTestsBase
        {
            public Cron_Health_Check_Red_Bad_Args() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                List<string[]> results = null;
                try
                {
                    //SELECT THE ORIGINAL CATALOG WATCHER VALUES AND SAVE THEM SO WE CAN REVERT
                    Global.RO.Info("Getting the original txt_arg value for the first Catalog Watcher instance...");
                    string selectOriginalCronJobArgTxt = "SELECT TOP(1) i_job_id, txt_args FROM t_cron_jobs WHERE vc_assembly='CatalogWatcherPlugin.dll' ORDER BY i_job_id";
                    results = NPDB.ExecuteQueryGetMultiple(selectOriginalCronJobArgTxt);

                    if (results.Count > 0)
                    {
                        //UPDATE THE DLL FOR THE CATALOG WATCHER INSTANCES TO BE FALSE

                        string updateAndBreakCatalogWatcherInstances = "UPDATE t_cron_jobs SET txt_args='TESTCronHealthCheckShouldBeRed' WHERE i_job_id=" + results[0][0];
                        Global.RO.Info("Updating a Catalog Watcher instance to use a bad txt_arg...");
                        NPDB.ExecuteNonQuery(updateAndBreakCatalogWatcherInstances);

                        Global.RO.Info("Waiting 120 seconds so we hit the next Catalog Watcher interval...");
                        Thread.Sleep(TimeSpan.FromSeconds(120));

                        string result = ValidateCronHealthCheckStatus("red");

                        if (result != String.Empty)
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                            Global.RO.Info("Health check was NOT red as expected.");
                            Global.RO.Info("Error Details from CronJobInfo health report:");
                            Global.RO.Info(result);
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Info("Unable select a Catalog Watcher job from the cron jobs table.");
                    }
                }
                finally
                {
                    if (results != null)
                    {
                        Global.RO.Info("Updating a Catalog Watcher instance to use a good txt_arg...");
                        string updateAndFixCatalogWatcherInstances = "UPDATE t_cron_jobs SET txt_args='" + results[0][1] + "' WHERE i_job_id='" + results[0][0] + "'";
                        NPDB.ExecuteNonQuery(updateAndFixCatalogWatcherInstances);

                        Global.RO.Info("Re-enabling all of the catalog watcher instances...");
                        UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);
                        Global.RO.Info("Waiting 120 seconds so we hit the next Catalog Watcher interval...");
                        Thread.Sleep(TimeSpan.FromSeconds(120));
                    }
                }

                Global.RO.Info("Test completed.");
            }
        }

        [TestCase, Owner("jeremyj"), TestCasePriority(3), EnvRequirement("Watcher, XblobOnly, Manual")]
        class Cron_Health_Check_Red_To_Green : WatcherTestsBase
        {
            public Cron_Health_Check_Red_To_Green() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    //UPDATE THE DLL FOR THE CATALOG WATCHER INSTANCES TO BE FALSE
                    Global.RO.Info("Updating the Catalog Watcher instances to use a bad assembly...");
                    string updateAndBreakCatalogWatcherInstances = "UPDATE t_cron_jobs SET vc_assembly='TESTCronHealthCheckShouldBeRed.dll' WHERE vc_assembly='CatalogWatcherPlugin.dll'";
                    NPDB.ExecuteNonQuery(updateAndBreakCatalogWatcherInstances);

                    Global.RO.Info("Waiting 120 seconds so we hit the next Catalog Watcher interval...");
                    Thread.Sleep(TimeSpan.FromSeconds(120));

                    string result1 = ValidateCronHealthCheckStatus("red");

                    if(result1 != String.Empty)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Info("Health check was NOT red as expected.");
                        Global.RO.Info("Error Details from CronJobInfo health report:");
                        Global.RO.Info(result1);
                    }

                    string updateAndFixCatalogWatcherInstances = "UPDATE t_cron_jobs SET vc_assembly='CatalogWatcherPlugin.dll' WHERE vc_assembly='TESTCronHealthCheckShouldBeRed.dll'";
                    NPDB.ExecuteNonQuery(updateAndFixCatalogWatcherInstances);

                    Global.RO.Info("Re-enabling all of the catalog watcher instances...");
                    UpdateCatalogWatcherJobsEnabledStatusInNPDB(1);

                    Global.RO.Info("Waiting 240 seconds so we hit the next Catalog Watcher interval...");
                    Thread.Sleep(TimeSpan.FromSeconds(240));

                    string result2 = ValidateCronHealthCheckStatus("green");

                    if(result2 != String.Empty)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Info("Health check was NOT green as expected.");
                        Global.RO.Info("Error Details from CronJobInfo health report:");
                        Global.RO.Info(result2);
                    }


                }
                finally
                {
                    string updateAndFixCatalogWatcherInstances = "UPDATE t_cron_jobs SET vc_assembly='CatalogWatcherPlugin.dll' WHERE vc_assembly='TESTCronHealthCheckShouldBeRed.dll'";
                    NPDB.ExecuteNonQuery(updateAndFixCatalogWatcherInstances);
                }

                Global.RO.Info("Test completed.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests\PublisherTest.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Configuration;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;

using xonline.server.catalogwatcher;

using Com.FastSearch.Esp.Search;
using Com.FastSearch.Esp.Search.Query;
using Com.FastSearch.Esp.Search.Result;
using Com.FastSearch.Esp.Search.View;
using Com.FastSearch.Esp.Content;
using Com.FastSearch.Esp.Content.Config;

using ServerTestFramework;
using ServerTestFramework.LiveService;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("craigta"), TestFrequency("Check-In"), EnvRequirement("Watcher")]
    public class PublisherTests
    {
        public class PublisherTestDocument : IWatcherDocument
        {
            String _id;
            String _document;

            public PublisherTestDocument(String id, String document)
            {
                _id = id;
                _document = document;
            }
            // The unique Id that identifies the document
            public string DocumentId { get { return _id.ToString(); } }
            // The actual document that gets generated and published
            public Object Document { get { return _document; } }

        }

        private static ISearchView searchView = null;
        private static IDocumentFeeder _documentFeeder = null;

        private static String FastEspInstallation = String.Empty;
        private static String FastEspIngestionPort = String.Empty;
        private static String FastEspSearchPort = String.Empty;
        private static String FastEspCatalog = String.Empty;

        [TestGroupSetup]
        public void Setup() 
        {
            //Load configuration settings for the test cases
            Configuration config = ConfigurationManager.OpenExeConfiguration(System.Reflection.Assembly.GetExecutingAssembly().Location);

            FastEspInstallation = config.AppSettings.Settings["FastEspInstallation"].Value;
            FastEspIngestionPort = config.AppSettings.Settings["FastEspIngestionPort"].Value;
            FastEspSearchPort = config.AppSettings.Settings["FastEspSearchPort"].Value;
            FastEspCatalog = config.AppSettings.Settings["FastEspCatalog"].Value;

            NameValueCollection configuration = new NameValueCollection();
            configuration.Add("Com.FastSearch.Esp.Search.Http.QRServers", FastEspInstallation + ":" + FastEspSearchPort);

            ISearchFactory searchFactory = SearchFactory.NewInstance(configuration);

            searchView = searchFactory.GetSearchView(FastEspCatalog.ToLower());

            _documentFeeder = Factory.CreateDocumentFeeder(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog);

            // Force the flush to wait until it is completely indexed and searchable
            ISubsystem indexing = _documentFeeder.GetSystemConfig().GetSubsystem("indexing");
            if (indexing != null)
            {
                indexing.CompletedCallbackEnabled = true;
            } 
        }

        [TestGroupTearDown]
        public void Shutdown() 
        {
            // Turn off waiting for the indexing to be finished
            ISubsystem indexing = _documentFeeder.GetSystemConfig().GetSubsystem("indexing");
            if (indexing != null)
            {
                indexing.CompletedCallbackEnabled = false;
            }

            if (_documentFeeder != null)
            {
                _documentFeeder.Dispose();
            }
        }

        private static IQueryResult DoSearch(String searchTerm)
        {
            IQuery query = new Query(searchTerm);

            return searchView.Search(query);
        }

        [TestCase, TestCasePriority(1)]
        class Pos_Esp_Running_Publish_Document : TestBase
        {
            public Pos_Esp_Running_Publish_Document() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    String document = "<entry><title>One Publish Test</title><description>One Publish Test Desc</description> </entry>";
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog))
                    {
                        PublisherTestDocument testDocument = new PublisherTestDocument("1",document);

                        publisher.PublishDocument(testDocument);

                        publisher.FlushDocuments();                         
                    }

                    IQueryResult result = DoSearch("xml:title:\"One Publish Test\"");

                    // Validate this matches our original document
                    Int32 numberOfMatchingDocs = result.DocCount;
                    if (result.DocCount > 1)
                    {
                        throw new Exception("Expected 1 match, received: " + result.DocCount);
                    }
                    IDocumentSummary summary = result.GetDocument(1);

                    IDocumentSummaryField xmlField = summary.GetSummaryField("xml");
                    if (!xmlField.StringValue.Contains("One Publish Test"))
                    {
                        throw new Exception("Could not find test, instead found: " + xmlField.StringValue);
                    }

                    IDocumentSummaryField idField = summary.GetSummaryField("contentid");
                    if (!idField.StringValue.Equals("1"))
                    {
                        throw new Exception("Could not find document identifier 1, instead found: " + idField);
                    }                   
                }
                catch (Exception e)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error("Pos_Esp_Running_Publish_Document Test Failed!!!" + e);
                }

                // Remove the document from the catalog
                _documentFeeder.RemoveDocument("1");
                _documentFeeder.WaitForCompletion();

            }
        }

        [TestCase, TestCasePriority(1)]
        class Pos_Esp_Running_Publish_Multiple_Document : TestBase
        {
            private const int NUM_OF_DOC = 5;
            public Pos_Esp_Running_Publish_Multiple_Document() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                int i = 0; 
                try
                {                    
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog))
                    {                                                
                        while (i < NUM_OF_DOC)
                        {
                            String document = String.Format("<entry><title>Publish Test {0}</title><description>Publish Test Desc {1}</description> </entry>", i, i);
                            PublisherTestDocument testDocument = new PublisherTestDocument(i.ToString(), document);

                            publisher.PublishDocument(testDocument);
                            ++i;
                        }

                        publisher.FlushDocuments();
                    }

                    IQueryResult result = DoSearch("xml:title:\"Publish Test\"");

                    // Validate this matches our original document
                    Int32 numberOfMatchingDocs = result.DocCount;
                    if (result.DocCount != NUM_OF_DOC)
                    {
                        throw new Exception(String.Format("Expected {0} match, received: {1}", NUM_OF_DOC, result.DocCount));
                    }

                    // Check that we got back everything
                    i = 0;
                    while (i < NUM_OF_DOC)
                    {
                        IDocumentSummary summary = result.GetDocument(i + 1);

                        IDocumentSummaryField xmlField = summary.GetSummaryField("xml");
                        if (!xmlField.StringValue.Contains(String.Format("Publish Test {0}", i)))
                        {
                            throw new Exception("Could not find test, instead found: " + xmlField.StringValue);
                        }

                        IDocumentSummaryField idField = summary.GetSummaryField("contentid");
                        if (!idField.StringValue.Equals(i.ToString()))
                        {
                            throw new Exception("Could not find document identifier 1, instead found: " + idField);
                        }
                        ++i;
                    }
                }
                catch (Exception e)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error("Pos_Esp_Running_Publish_Document Test Failed!!!" + e);
                }

                // Remove all of the documents
                i = 0;
                while (i < NUM_OF_DOC)
                {
                    _documentFeeder.RemoveDocument(i.ToString());
                    ++i;
                }
                _documentFeeder.WaitForCompletion();                
            }
        }


        [TestCase, TestCasePriority(1)]
        class Pos_Esp_Running_Overwrite_document : TestBase
        {
            public Pos_Esp_Running_Overwrite_document() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    // Put in initial publisher test document
                    String document = "<entry><title>Publish Test (initial)</title><description>Publish Test Desc (initial)</description> </entry>";
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog))
                    {
                        PublisherTestDocument testDocument = new PublisherTestDocument("1", document);

                        publisher.PublishDocument(testDocument);

                        publisher.FlushDocuments();
                    }

                    // Overwrite the document
                    document = "<entry><title>Publish Test (Updated)</title><description>Publish Test Desc (Updated)</description> </entry>";
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog))
                    {
                        PublisherTestDocument testDocument = new PublisherTestDocument("1", document);

                        publisher.PublishDocument(testDocument);

                        publisher.FlushDocuments();
                    }

                    IQueryResult result = DoSearch("xml:title:\"Publish Test (Updated)\"");

                    // Validate this matches our original document
                    Int32 numberOfMatchingDocs = result.DocCount;
                    if (result.DocCount > 1)
                    {
                        throw new Exception("Expected 1 match, received: " + result.DocCount);
                    }
                    IDocumentSummary summary = result.GetDocument(1);

                    IDocumentSummaryField xmlField = summary.GetSummaryField("xml");
                    if (!xmlField.StringValue.Contains("Publish Test (Updated)"))
                    {
                        throw new Exception("Could not find test, instead found: " + xmlField.StringValue);
                    }

                    IDocumentSummaryField idField = summary.GetSummaryField("contentid");
                    if (!idField.StringValue.Equals("1"))
                    {
                        throw new Exception("Could not find document identifier 1, instead found: " + idField);
                    }
                }
                catch (Exception e)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error("Pos_Esp_Running_Overwrite_document Test Failed!!!" + e);
                }
                // Remove the document from the catalog
                _documentFeeder.RemoveDocument("1");
                _documentFeeder.WaitForCompletion();
            }
        }

        [TestCase, TestCasePriority(2)]
        class Pos_Esp_Running_No_Push_Flush : TestBase
        {
            public Pos_Esp_Running_No_Push_Flush() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog))
                    {
                        publisher.FlushDocuments();
                    }
                }
                catch (Exception e)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error("Pos_Pos_Esp_Running_No_Push_Flush Test Failed!!!" + e);
                }

            }
        }

        [TestCase, TestCasePriority(3)]
        class Neg_Esp_Not_Running: TestBase
        {
            public Neg_Esp_Not_Running() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    String document = "<entry><title>Publish Test (Updated)</title><description>Publish Test Desc (Updated)</description> </entry>";
                    using (PublisherEsp publisher = new PublisherEsp("doesnotexist:16100", FastEspCatalog))
                    {
                        PublisherTestDocument testDocument = new PublisherTestDocument("1", document);

                        publisher.PublishDocument(testDocument);

                        publisher.FlushDocuments();
                    }
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Esp_Document_Badly_Formatted Test Failed!!!" + xe);
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error("Neg_Esp_Not_Running Test Failed!!!" + ex);
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class Neg_Esp_Running_Use_Bad_Port : TestBase
        {
            public Neg_Esp_Running_Use_Bad_Port() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    String document = "<entry><title>Publish Test (Updated)</title><description>Publish Test Desc (Updated)</description> </entry>";
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + "90", FastEspCatalog))
                    {
                        PublisherTestDocument testDocument = new PublisherTestDocument("1", document);

                        publisher.PublishDocument(testDocument);

                        publisher.FlushDocuments();
                    }
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Esp_Document_Badly_Formatted Test Failed!!!" + xe);
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error("Neg_Esp_Not_Running Test Failed!!!" + ex);
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class Neg_Esp_Document_Data_Null : TestBase
        {
            public Neg_Esp_Document_Data_Null() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog))
                    {
                        PublisherTestDocument testDocument = new PublisherTestDocument("1", null);

                        publisher.PublishDocument(testDocument);

                        publisher.FlushDocuments();
                    }
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Esp_Document_Badly_Formatted Test Failed!!!" + xe);
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error("Neg_Esp_Not_Running Test Failed!!!" + ex);
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class Neg_Esp_Document_Null : TestBase
        {
            public Neg_Esp_Document_Null() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog))
                    {
                        publisher.PublishDocument(null);

                        publisher.FlushDocuments();
                    }
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Esp_Document_Badly_Formatted Test Failed!!!" + xe);
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error("Neg_Esp_Not_Running Test Failed!!!" + ex);
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class Neg_Esp_Document_Badly_Formatted : TestBase
        {
            public Neg_Esp_Document_Badly_Formatted() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    String document = "<entry><title>Publish Test cription>Pubon></entry><<<>&#$@#@!@";
                    using (PublisherEsp publisher = new PublisherEsp(FastEspInstallation + ":" + FastEspIngestionPort, FastEspCatalog))
                    {
                        PublisherTestDocument testDocument = new PublisherTestDocument("1", document);

                        publisher.PublishDocument(testDocument);

                        publisher.FlushDocuments();
                    }
                }
                catch (xonline.common.service.XRLException xe)
                {
                    if (xe.HResult == xonline.common.service.HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("Neg_Esp_Document_Badly_Formatted Test Failed!!!" + xe);
                    }                    
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\CronDal.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.config;
using xonline.common.sql.sqlclient;

namespace CatalogWatcherTests_Video.Managers
{
    class CronDal
    {
        protected string CronInterface { get; private set; }
        public CronDal(string cronInterface)
        {
            this.CronInterface = cronInterface;
        }

        public CronDal()
        {
            this.CronInterface = Interface.npdb;
        }

        /// <summary>
        /// Not sure if we need this, but adding it in case
        /// </summary>
        /// <param name="resourceName"></param>
        /// <param name="destinationName"></param>
        /// <param name="seconds"></param>
        public void UpdateCronJobInterval(string resourceName, string destinationName, int seconds)
        {
            using (SqlClient sqlClient = new SqlClient(this.CronInterface))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
UPDATE dbo.t_Cron_jobs 
SET i_exec_interval_secs = @i_exec_interval_secs
WHERE 
	@resourceName = CAST(txt_args AS xml).value('/PluginContext[1]/attribute[@name=""ResourceName""][1]','varchar(510)')
	AND @destinationName = CAST(txt_args AS xml).value('/PluginContext[1]/attribute[@name=""DestinationName""][1]','varchar(510)') 
";

                sqlClient.AddParameter("@i_exec_interval_secs", seconds);
                sqlClient.AddParameter("@resourceName", resourceName);
                sqlClient.AddParameter("@destinationName", destinationName);

                sqlClient.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Not sure if we need this, but adding it in case
        /// </summary>
        /// <param name="resourceName"></param>
        /// <param name="destinationName"></param>
        /// <param name="seconds"></param>
        public void UpdateCronJobNextRun(string resourceName, string destinationName, int seconds)
        {
            using (SqlClient sqlClient = new SqlClient(this.CronInterface))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
UPDATE dbo.t_Cron_jobs 
SET dt_exec_next_scheduled = DATEADD(second, @seconds, GETUTCDATE()),
    dt_exec_next_actual = DATEADD(second, @seconds, GETUTCDATE())
WHERE 
	@resourceName = CAST(txt_args AS xml).value('/PluginContext[1]/attribute[@name=""ResourceName""][1]','varchar(510)')
	AND @destinationName = CAST(txt_args AS xml).value('/PluginContext[1]/attribute[@name=""DestinationName""][1]','varchar(510)') 
";

                sqlClient.AddParameter("@seconds", seconds);
                sqlClient.AddParameter("@resourceName", resourceName);
                sqlClient.AddParameter("@destinationName", destinationName);

                sqlClient.ExecuteNonQuery();
            }
        }

        public void AddCronJob(string jobName, int titleId, string assemblyName, string className, string textArguments, int intervalSeconds)
        {
            //Default value for the following parameters
            DateTime nextExecutionTime = DateTime.UtcNow.AddDays(1); 
            int executionCount = 2147483647; 
            int executionTimeout = 300;

            //Return parameter
            int jobId = 0;

            using (SqlClient sqlClient = new SqlClient(this.CronInterface))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = 
    @"EXECUTE dbo.p_cron_add_job @vc_name,@i_title_id,@vc_assembly,@vc_class,@txt_args,@dt_exec_next,@i_interval_secs,@i_exec_count,@i_exec_timeout,@i_job_id OUTPUT";

                sqlClient.AddParameter("@vc_name", jobName);
                sqlClient.AddParameter("@i_title_id", titleId);
                sqlClient.AddParameter("@vc_assembly", assemblyName);
                sqlClient.AddParameter("@vc_class", className);
                sqlClient.AddParameter("@txt_args", textArguments);
                sqlClient.AddParameter("@dt_exec_next", nextExecutionTime);
                sqlClient.AddParameter("@i_interval_secs", intervalSeconds);
                sqlClient.AddParameter("@i_exec_count", executionCount);
                sqlClient.AddParameter("@i_exec_timeout", executionTimeout);
                sqlClient.AddParameter(System.Data.ParameterDirection.Output, "@i_job_id", jobId);
                sqlClient.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Deletes all the cron jobs and tracking information based on the resource and destination values it uses
        /// </summary>
        /// <param name="resourceName">Resource type the cron job uses</param>
        /// <param name="destinationName">Destination type the cron job uses</param>
        public void DeleteCronJobByType(string resourceName, string destinationName)
        {
            using (SqlClient sqlClient = new SqlClient(this.CronInterface))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
DELETE
FROM dbo.t_Cron_jobs 
WHERE 
	@resourceName = CAST(txt_args AS xml).value('/PluginContext[1]/attribute[@name=""ResourceName""][1]','varchar(510)')
	AND @destinationName = CAST(txt_args AS xml).value('/PluginContext[1]/attribute[@name=""DestinationName""][1]','varchar(510)') 

DELETE cws
FROM dbo.t_catalog_watcher_status cws 
	JOIN npdb.dbo.t_catalog_watcher_resource cwr ON cwr.i_resource_id = cws.i_resource_id
	JOIN npdb.dbo.t_catalog_watcher_destination cwd ON cwd.i_destination_id = cws.i_destination_id
WHERE @resourceName = cwr.vc_resource_name
AND @destinationName = cwd.vc_destination_name 
";

                sqlClient.AddParameter("@resourceName", resourceName);
                sqlClient.AddParameter("@destinationName", destinationName);
                sqlClient.ExecuteNonQuery();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\XsdValidator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Schema;
using System.Collections.ObjectModel;

namespace CatalogWatcherTests_Video
{
    public class XsdValidator
    {
        private XmlSchemaSet xsdSchemaSet;
        
        public XsdValidator(XmlSchemaSet validationXsd)
        {
            this.xsdSchemaSet = validationXsd;
        }

        #region FindMethods
        public Collection<string> FindErrors(string input)
        {
            return FindErrors(input,xsdSchemaSet, RecordAll);
        }
        public Collection<string> FindDistinctErrors(string input)
        {
            return FindErrors(input, xsdSchemaSet, RecordFirstTypeOnly);
        }
        public Collection<string> FindErrorsFromFile(string input)
        {
            return FindErrorsFromFile(input, xsdSchemaSet, RecordAll);
        }
        public Collection<string> FindDistinctErrorsFromFile(string input)
        {
            return FindErrorsFromFile(input, xsdSchemaSet, RecordFirstTypeOnly);
        }
        private static Collection<string> FindErrors(string input, XmlSchemaSet xsdSchemaSet, Action<object, ValidationEventArgs, Collection<string>> recorder)
        {
            Collection<string> errorMessages = new Collection<string>();

            // Set the validation settings.
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.ValidationType = ValidationType.Schema;
            settings.Schemas = xsdSchemaSet;
            settings.ValidationEventHandler += ((sender, e) => recorder(sender, e, errorMessages));

            // Create the XmlReader object.
            using (System.IO.StringReader reader = new System.IO.StringReader(input))
            using (XmlReader xmlReader = XmlReader.Create(reader, settings))
            {
                // Parse the file. 
                while (xmlReader.Read()) ;
            }

            return errorMessages;
        }

        private static Collection<string> FindErrorsFromFile(string path, XmlSchemaSet xsdSchemaSet, Action<object, ValidationEventArgs, Collection<string>> recorder)
        {
            Collection<string> errorMessages = new Collection<string>();

            // Set the validation settings.
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.ValidationType = ValidationType.Schema;
            settings.Schemas = xsdSchemaSet;
            settings.ValidationEventHandler += ((sender, e) => recorder(sender, e, errorMessages));

            // Create the XmlReader object.
            using (XmlReader xmlReader = XmlReader.Create(path, settings))
            {
                // Parse the file. 
                while (xmlReader.Read()) ;
            }

            return errorMessages;
        }
        #endregion

        private static void RecordAll(object sender, ValidationEventArgs e, Collection<string> errorMessages)
        {
            errorMessages.Add(String.Format("Line {0}. Position {1}. {2}", e.Exception.LineNumber, e.Exception.LinePosition, e.Exception.ToString()));
        }

        private static void RecordFirstTypeOnly(object sender, ValidationEventArgs e, Collection<string> errorMessages)
        {
            int hyphenIndex = e.Message.IndexOf('-');
            hyphenIndex = (hyphenIndex > 0) ? hyphenIndex : e.Message.Length;
            string initialMessage = e.Message.Substring(0, hyphenIndex);

            if (errorMessages.FirstOrDefault(x => x.Contains(initialMessage)) == null)
            {
                errorMessages.Add(String.Format("Line {0}. Position {1}. {2}", e.Exception.LineNumber, e.Exception.LinePosition, e.Exception.ToString()));
            }
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\IebAzureDeveloperStorageDal.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.IO.Compression;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace CatalogWatcherTests_Video.Managers
{

    public class IebAzureDeveloperStorageDal : PublisherDal
    {
        public string ConnectionString { get; private set; }

        public IebAzureDeveloperStorageDal(string accountName, string containerName, string connectionString)
            : base(accountName, containerName)
        {
            this.ConnectionString = connectionString;
        }
        public IebAzureDeveloperStorageDal(string accountName, string containerName, string server, string database)
            : base(accountName, containerName)
        {
            var builder = new System.Data.SqlClient.SqlConnectionStringBuilder();
            builder.DataSource = server;
            builder.InitialCatalog = database;
            builder.IntegratedSecurity = true;
            this.ConnectionString = builder.ToString();
        }

        public override string GetBlob(string blobName)
        {
            using (var conn = new SqlConnection(this.ConnectionString))
            using (var command = conn.CreateCommand())
            {
                command.CommandType = System.Data.CommandType.Text;
                command.CommandText =
@"SELECT bd.Data
FROM [dbo].[Blob] bl
JOIN [dbo].[Blockdata] bd 
	ON bl.AccountName = bd.AccountName 
	AND bl.ContainerName = bd.ContainerName 
	and bl.BlobName = bd.BlobName
JOIN [dbo].[CommittedBlock] cb ON cb.BlockId = bd.BlockId
WHERE bd.IsCommitted = 1
	AND @AccountName = bl.AccountName
	AND @ContainerName = bl.ContainerName
	AND @BlobName = bl.BlobName
ORDER BY cb.Offset";

                // Add parameters
                command.Parameters.Add("@AccountName", SqlDbType.NVarChar).Value = this.AccountName;
                command.Parameters.Add("@ContainerName", SqlDbType.NVarChar).Value = this.ContainerName;
                command.Parameters.Add("@BlobName", SqlDbType.NVarChar).Value = blobName;

                //Execute and parse query
                conn.Open();
                var reader = command.ExecuteReader();

                return ConvertToXmlString(reader);
            }
        }
        public override void WriteXmlToDisk(string blobName, string destinationFilePath)
        {
            WriteSomethingToDisk(blobName, destinationFilePath, WriteXmlToDisk);
        }

        public override void WriteBlobToDisk(string blobName, string destinationFilePath)
        {
            WriteSomethingToDisk(blobName, destinationFilePath, WriteBlobToDisk);
        }

        private void WriteSomethingToDisk(string blobName, string destinationFilePath, Action<IDataReader, string> formatter)
        {
            using (var conn = new SqlConnection(this.ConnectionString))
            using (var command = conn.CreateCommand())
            {
                command.CommandType = System.Data.CommandType.Text;
                command.CommandText =
@"SELECT bd.Data
FROM [dbo].[Blob] bl
JOIN [dbo].[Blockdata] bd 
	ON bl.AccountName = bd.AccountName 
	AND bl.ContainerName = bd.ContainerName 
	and bl.BlobName = bd.BlobName
JOIN [dbo].[CommittedBlock] cb ON cb.BlockId = bd.BlockId
WHERE bd.IsCommitted = 1
	AND @AccountName = bl.AccountName
	AND @ContainerName = bl.ContainerName
	AND @BlobName = bl.BlobName
ORDER BY cb.Offset";

                // Add parameters
                command.Parameters.Add("@AccountName", SqlDbType.NVarChar).Value = this.AccountName;
                command.Parameters.Add("@ContainerName", SqlDbType.NVarChar).Value = this.ContainerName;
                command.Parameters.Add("@BlobName", SqlDbType.NVarChar).Value = blobName;

                //Execute and parse query
                conn.Open();
                var reader = command.ExecuteReader();
                formatter(reader, destinationFilePath);
            }
        }

        public override Collection<PublisherFile> GetBlobList()
        {
            Collection<PublisherFile> result = new Collection<PublisherFile>();
            using (var conn = new SqlConnection(this.ConnectionString))
            using (var command = conn.CreateCommand())
            {
                command.CommandType = System.Data.CommandType.Text;
                command.CommandText =
@"SELECT bl.LastModificationTime, bl.BlobName
FROM [dbo].[Blob] bl
WHERE bl.IsCommitted = 1
	AND @AccountName = bl.AccountName
	AND @ContainerName = bl.ContainerName
ORDER BY bl.BlobName";

                // Add parameters
                command.Parameters.Add("@AccountName", SqlDbType.NVarChar).Value = this.AccountName;
                command.Parameters.Add("@ContainerName", SqlDbType.NVarChar).Value = this.ContainerName;

                //Execute and parse query
                conn.Open();
                var reader = command.ExecuteReader();
                while (reader.Read())
                {
                    PublisherFile item = new PublisherFile();
                    item.LastModificationTime = reader.Coalesce<DateTime>("LastModificationTime");
                    item.BlobName = reader.Coalesce<string>("BlobName");
                    result.Add(item);
                }

                return result;
            }
        }
        public override void DeleteBlobs()
        {
            Collection<PublisherFile> result = new Collection<PublisherFile>();
            using (var conn = new SqlConnection(this.ConnectionString))
            using (var command = conn.CreateCommand())
            {
                command.CommandType = System.Data.CommandType.Text;
                command.CommandText =
@"BEGIN TRAN
Delete bl
FROM Blob bl 
WHERE @AccountName = AccountName
	AND @ContainerName = ContainerName

DELETE bd
FROM BlockData bd
WHERE @AccountName = AccountName
	AND @ContainerName = ContainerName 
COMMIT
";

                // Add parameters
                command.Parameters.Add("@AccountName", SqlDbType.NVarChar).Value = this.AccountName;
                command.Parameters.Add("@ContainerName", SqlDbType.NVarChar).Value = this.ContainerName;

                //Execute and parse query
                conn.Open();
                var reader = command.ExecuteNonQuery();
            }
        }

        protected virtual TextWriter GetTextWriter(string fileName)
        {

            CloudStorageAccount account = CloudStorageAccount.Parse("");
            CloudBlobClient client = account.CreateCloudBlobClient();

            CloudBlobContainer container = client.GetContainerReference("");
            container.CreateIfNotExist();

            CloudBlob blob = container.GetBlobReference(fileName);

            BlobStream blobStream = blob.OpenWrite();
            GZipStream gz = new GZipStream(blobStream, CompressionMode.Compress);
            return new StreamWriter(gz);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Settings.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.config;

namespace CatalogWatcherTests_Video
{
    class Settings
    {
        /// <summary>
        /// The name of the Azure Storage container from NPDB
        /// IE: movies-firstparty
        /// </summary>
        public static readonly string catalogwatcher_azure_storage_container = Config.GetSetting(Setting.catalogwatcher_azure_storage_container);

        /// <summary>
        /// The format string of the full feed blob name 
        /// IE: movies_firstparty.full.{0}.slice-{1}-of-{2}.{3}.gz
        /// </summary>
        public static readonly string catalogwatcher_azure_storage_blob_format_full = Config.GetSetting(Setting.catalogwatcher_azure_storage_blob_format_full);

        /// <summary>
        /// The format string of the delta feed blob name
        /// IE: movies_firstparty.delta.{0}.slice-{1}-of-{2}.{3}.gz
        /// </summary>
        public static readonly string catalogwatcher_azure_storage_blob_format_delta = Config.GetSetting(Setting.catalogwatcher_azure_storage_blob_format_delta);

        /// <summary>
        /// The date time format part for the blob name
        /// IE: yyyy-MM-dd.HH-mm-ss
        /// </summary>
        public static readonly string catalogwatcher_azure_storage_blob_format_date_part = Config.GetSetting(Setting.catalogwatcher_azure_storage_blob_format_date_part);

        /// <summary>
        /// The connection string for Azure storage
        /// IE: UseDevelopmentStorage=true
        /// IE: DefaultEndpointsProtocol=https;AccountName=devemdstorage;AccountKey=QBkMqzLXREOMTKaRbtMVGXjpyXZCKACKX5SYy1vTJKfSyXW4RsHULOZsOu6PnmHoVeyFB13ltIizv+adzAUGwA==
        /// </summary>
        public static readonly string catalogwatcher_azure_connection_string = Config.GetSetting(Setting.catalogwatcher_azure_connection_string);

        /// <summary>
        /// The feed open element prefix:
        /// IE: <?xml version="1.0" encoding="utf-8"?><Feed xmlns="http://schemas.microsoft.com/ISS/2011/05/ingestion">
        /// </summary>
        public static readonly string catalogwatcher_azure_feed_prefix = Config.GetSetting(Setting.catalogwatcher_azure_feed_prefix);

        /// <summary>
        /// The feed close element prefix:
        /// IE: </Feed>
        /// </summary>
        public static readonly string catalogwatcher_azure_feed_suffix = Config.GetSetting(Setting.catalogwatcher_azure_feed_suffix);

        /// <summary>
        /// Server Name of the cron machine
        /// Normally the same server as npdb on an xblob
        /// </summary>
        public static readonly string CronMachineName = Config.NpdbServer;

        /// <summary>
        /// Developer Storage Server Name
        /// IE: Should be the same server as npdb
        /// </summary>
        public static readonly string DeveloperStorageServerName = Config.NpdbServer;

        /// <summary>
        /// Developer Storage Database Name
        /// </summary>
        public static readonly string DeveloperStorageDatabaseName = "DevelopmentStorageDb20090919";


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\IebVideoDal.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.sql.sqlclient;
using xonline.common.config;
using System.Data.SqlClient;
using System.Data;
using Ieb = IEBDataModel.Model4;
using System.Collections.ObjectModel;
using CatalogWatcherTests_Video.VideoProducer;

namespace CatalogWatcherTests_Video.Managers
{
    public enum MediaRelationshipType
    {
        SeriesToEpisode,
        SeasonToEpisode,
        SeriesToSeason
    }

    public partial class IebVideoDal : ProducerDal
    {
        private static readonly string TransferJobName = "Video_CT_CatalogWatch";

        public IebVideoDal()
            : base(ConfigUtil.FECatalogDBZuneVirtualInterfaceInfo)
        {
        }

        public IebVideoDal(IVirtualInterfaceInfo interfaceInformation)
            : base(interfaceInformation)
        {
        }
        #region Product
        public T GetProduct<T>(Guid mediaId, int lcid) where T : Ieb.elementProduct, new()
        {
            var result = new T();
            GetProduct(result, mediaId, lcid);
            result.Images = GetImageList(mediaId, lcid);
            
            result.ParentalControl = GetParentalControl(mediaId, lcid);
            result.Instances = GetInstance(mediaId, lcid);
            return result;
        }

        public void GetProduct(Ieb.elementProduct result, Guid mediaId, int lcid)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
-- Product & Item
SELECT 
	me.mediaId --Item.ItemId
	,ml.lcid --Item.ItemId
	,ml.title --Item.Title
	--Item.titlePronunciation There is no EMS field corresponding to a pronunciation guide for a title.
	,ml.titleSort --Item.sortTitle
	,ml.description --Item.Description
	,ml.reducedDescription --Item.ShortDescription
	--Item.keywords There is no EMS field corresponding to “keywords” as they are indicated in the Bing Data Model.
	--Item.AlternateIds There is no EMS field corresponding to an alternate title for a piece of media.
	--Item.AlternateTitles There is no EMS field corresponding to an alternate title for a piece of media.
	,mt.name 'MediaType' --Product Media Type
	,vs.name 'VisibilityStatus'-- Product.Visibility
	,me.modifiedDate
	--Product.OriginalPublicationRegion -Not available in EMS
	--Product.AverageUserRating -Not captured by any client
	--Product.NumberOfUserRatings -Not captured by any client
	--Product.applicationSpecificData -Reqd for Movies, TVEpisode, TVShow
FROM Media me
	JOIN MediaLocale ml ON me.mediaId = ml.mediaId
	JOIN VisibilityStatus vs ON me.visibilityStatusId = vs.visibilityStatusId
	JOIN MediaType mt ON mt.mediaTypeId = me.mediaTypeId
WHERE me.mediaId = @mediaId
	AND ml.lcid = @lcid
";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    if (reader.Read())
                    {
                        IebVideoToSqlMapper.MapProduct(result, reader);
                        result.Genres = GetGenresList(mediaId, lcid);
                    }
                    if (reader.Read())
                    {
                        throw new InvalidOperationException("Multiple rows returned");
                    }
                }
            }
        }
        #endregion Product
        #region TvEpisode
        public Ieb.elementTVEpisode GetTvEpisode(Guid mediaId, int lcid)
        {
            var result = GetProduct<Ieb.elementTVEpisode>(mediaId, lcid);
            GetTvEpisode(result, mediaId, lcid);

            result.Studios = GetStudioList(mediaId, lcid);
            result.Directors = GetDirectorList(mediaId, lcid);
            result.Actors = GetActorList(mediaId, lcid);
            result.Writers = GetWriterList(mediaId, lcid);
            
            return result;
        }

        public void GetTvEpisode(Ieb.elementTVEpisode result, Guid mediaId, int lcid)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
-- TVEpisode
SELECT 
	me.mediaId --Product.ItemId
	,ml.lcid --Product.ItemId
	,mt.Name 'MediaType'
	,ve.episodeNumber --TVEpisode.EpisodeNumber
	,vi.durationSecs --TVEpisode.Duration
	,vn.name 'Network' --TVEpisode.Network
	,me.originalReleaseDate --TVEpisode.originalPublicationDate
	--TVSeries.SeriesId Special FN
	--TVSeries.SeasonId Special FN
FROM Media me
	JOIN MediaType mt ON mt.mediaTypeId = me.mediaTypeId
	JOIN MediaLocale ml ON me.mediaId = ml.mediaId
	JOIN Video vi ON vi.videoMediaId = me.mediaId
	JOIN VideoEpisode ve ON ve.videoMediaId = me.mediaId
	
	JOIN ViewEpisodeNetwork ven ON ven.EpisodeId = me.mediaId
	JOIN ViewNetwork vn ON vn.Id = ven.NetworkId AND vn.Lcid = @lcid	
	JOIN Locale lo ON lo.countryCode = ven.CountryCode AND lo.lcid = @lcid
WHERE me.mediaId = @mediaId
	AND ml.lcid = @lcid";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    if (reader.Read())
                    {
                        IebVideoToSqlMapper.MapTvEpisode(result, reader);
                        result.Studios = GetStudioList(mediaId, lcid);
                        MapTvEpisodeMediaLink(result, mediaId, lcid);
                    }
                    if (reader.Read())
                    {
                        throw new InvalidOperationException("Multiple rows returned");
                    }
                }
            }
        }

        private void MapTvEpisodeMediaLink(Ieb.elementTVEpisode result, Guid mediaId, int lcid)
        {
            result.Items = new string[2];
            result.ItemsElementName = new Ieb.ItemsChoiceType1[2];
            result.ItemsElementName[0] = Ieb.ItemsChoiceType1.SeriesId;
            result.Items[0] = GetMediaLink(mediaId, lcid, MediaRelationshipType.SeriesToEpisode);
            result.ItemsElementName[1] = Ieb.ItemsChoiceType1.SeasonId;
            result.Items[1] = GetMediaLink(mediaId, lcid, MediaRelationshipType.SeasonToEpisode);
        }
        #endregion TvEpisode
        #region TvSeries
        public Ieb.elementTVSeries GetTvSeries(Guid mediaId, int lcid)
        {
            var result = GetProduct<Ieb.elementTVSeries>(mediaId, lcid);
            GetTvSeries(result, mediaId, lcid);
            
            return result;
        }

        public void GetTvSeries(Ieb.elementTVSeries result, Guid mediaId, int lcid)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
-- TVSeries
--Note: No total number of season. We have the max season number, but not a definitive 'Total Number Of Seasons'
SELECT 
	me.mediaId --Product.ItemId
	,ml.lcid --Product.ItemId
	,mt.Name 'MediaType'
	,me.originalReleaseDate --TVEpisode.originalPublicationDate
	--TVSeries.totalNumberOfSeasons
	,vn.name 'Network' --TVSeries.Network
	,scl.name 'Studio' --TVSeries.Studio
	--TVSeries.startYear ?
	--TVSeries.endYear ?
FROM Media me
	JOIN MediaType mt ON mt.mediaTypeId = me.mediaTypeId
	JOIN MediaLocale ml ON me.mediaId = ml.mediaId
	JOIN MediaCategory mc ON mc.mediaId = me.mediaId
	JOIN Category sca ON sca.categoryId= mc.categoryId
	JOIN CategorySystem scs ON scs.categorySystemId = sca.categorySystemId AND scs.name = 'Studios'
	JOIN CategoryLocale scl ON scl.categoryId = sca.categoryId
	JOIN ViewSeriesNetwork vsn ON vsn.SeriesId = me.mediaId
	JOIN ViewNetwork vn ON vn.Id = vsn.NetworkId AND vn.Lcid = @lcid	
	JOIN Locale lo ON lo.countryCode = vsn.CountryCode AND lo.lcid = @lcid
WHERE me.mediaId = @mediaId
	AND ml.lcid = @lcid";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    if (reader.Read())
                    {
                        IebVideoToSqlMapper.MapTvSeries(result, reader);
                        result.Studios = GetStudioList(mediaId, lcid);
                    }
                    if (reader.Read())
                    {
                        throw new InvalidOperationException("Multiple rows returned");
                    }
                }
            }
        }
        #endregion TvSeries
        #region TVShow
        //Not in Zune
        #endregion TVShow
        #region TvSeason
        public Ieb.elementTVSeason GetTvSeason(Guid mediaId, int lcid)
        {
            var result = GetProduct<Ieb.elementTVSeason>(mediaId, lcid);
            GetTvSeason(result, mediaId, lcid);
            
            return result;
        }

        public void GetTvSeason(Ieb.elementTVSeason result, Guid mediaId, int lcid)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
-- TVSeason
--Note: We don't have any TV Season accociated to networks since Oct 2010
--Note: We don't have any TV Season associated with Studio
SELECT 
	me.mediaId --Product.ItemId
	,ml.lcid --Product.ItemId
	,mt.Name 'MediaType'
	,vs.seasonNumber --TVSeason.seasonNumber
	,me.originalReleaseDate --TVSeason.originalPublicationDate
	,vn.name 'Network' --TVSeries.Network
	--TVSeason.Network Note: We don't have any TV Season accociated to networks since Oct 2010
	--TVSeason.Studio Note: We don't have any TV Season associated with Studio
	--TVSeason.SeriesId 
FROM Media me
	JOIN MediaType mt ON mt.mediaTypeId = me.mediaTypeId
	JOIN MediaLocale ml ON me.mediaId = ml.mediaId
	JOIN VideoSeason vs ON vs.videoSeasonMediaId = me.mediaId
	JOIN ViewSeriesSeason vss ON vss.SeasonId = me.mediaId
	JOIN ViewSeriesNetwork vsn ON vsn.SeriesId = vss.SeriesId
	JOIN ViewNetwork vn ON vn.Id = vsn.NetworkId AND vn.Lcid = @lcid
	JOIN Locale lo ON lo.countryCode = vsn.CountryCode AND lo.lcid = @lcid
WHERE me.mediaId = @mediaId
	AND ml.lcid = @lcid";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    if (reader.Read())
                    {
                        IebVideoToSqlMapper.MapTvSeason(result, reader);
                        result.Studios = GetStudioList(mediaId, lcid);
                        result.SeriesId = GetMediaLink(mediaId, lcid, MediaRelationshipType.SeriesToSeason);
                        if (!String.IsNullOrEmpty(result.SeriesId))
                        {
                            //Seasons don't have genres associated with them. Use media id from series instead
                            Guid seriesId = IebXsdValidator.ParseMediaId(result.SeriesId);
                            result.Genres = GetGenresList(seriesId, lcid);
                        }
                    }
                    if (reader.Read())
                    {
                        throw new InvalidOperationException("Multiple rows returned");
                    }
                }
            }
        }
        #endregion TvSeason
        #region Movie
        public Ieb.elementMovie GetMovie(Guid mediaId, int lcid)
        {
            var result = GetProduct<Ieb.elementMovie>(mediaId, lcid);
            GetMovie(result, mediaId, lcid);
            result.Directors = GetDirectorList(mediaId, lcid);
            result.Actors = GetActorList(mediaId, lcid);
            result.Writers = GetWriterList(mediaId, lcid);
            result.Studios = GetStudioList(mediaId, lcid);
            return result;
        }

        public void GetMovie(Ieb.elementMovie result, Guid mediaId, int lcid)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
--Movie
SELECT 
	me.mediaId --Product.ItemId
	,ml.lcid --Product.ItemId
	,mt.Name 'MediaType'
	,vi.durationSecs --Movie.DurationInSeconds
	,me.originalReleaseDate --Movie.originalPublicationDate
FROM Media me
	JOIN MediaLocale ml ON me.mediaId = ml.mediaId
	JOIN MediaType mt ON mt.mediaTypeId = me.mediaTypeId
	JOIN Video vi ON vi.videoMediaId = me.mediaId
WHERE me.mediaId = @mediaId
	AND ml.lcid = @lcid";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    if (reader.Read())
                    {
                        IebVideoToSqlMapper.MapMovie(result, reader);
                        result.Studios = GetStudioList(mediaId, lcid);
                    }
                    if (reader.Read())
                    {
                        throw new InvalidOperationException("Multiple rows returned");
                    }
                }
            }
        }


        #endregion Movie
        #region Image
        public Ieb.elementImagesImage[] GetImageList(Guid mediaId, int lcid)
        {
            var result = new Collection<Ieb.elementImagesImage>();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
select TOP 1
	'BoxArt' 'MediaRelationshipType' --Image.Purpose
	,ii.FileUrl
	,me.mediaId
	,ii.lcid 'lcid'
	,mt.name as 'MediaType'
FROM Media me 
	Join MediaType mt on mt.MediaTypeId = me.MediaTypeId
	JOIN MediaRelationship mr ON me.mediaId = mr.mediaId
	JOIN MediaRelationshipType mrt ON mr.mediaRelationshipTypeId = mrt.mediaRelationshipTypeId
	JOIN MediaInstance mi ON mr.relatedMediaId = mi.mediaId 
	JOIN ImageInstance ii ON mi.mediaInstanceId = ii.imageMediaInstanceId
	JOIN Locale lo ON lo.lcid = ii.lcid
WHERE me.mediaId = @mediaId
	AND ii.lcid = @lcid
	AND mrt.name IN ('MediaToPoster','MediaToImage','AlbumImage')
UNION ALL
select TOP 1
	'Background' 'MediaRelationshipType' --Image.Purpose
	,ii.FileUrl
	,me.mediaId
	,ii.lcid 'lcid'
	,mt.name as 'MediaType'
FROM Media me 
	Join MediaType mt on mt.MediaTypeId = me.MediaTypeId
	JOIN MediaRelationship mr ON me.mediaId = mr.mediaId
	JOIN MediaRelationshipType mrt ON mr.mediaRelationshipTypeId = mrt.mediaRelationshipTypeId
	JOIN MediaInstance mi ON mr.relatedMediaId = mi.mediaId 
	JOIN ImageInstance ii ON mi.mediaInstanceId = ii.imageMediaInstanceId
	JOIN Locale lo ON lo.lcid = ii.lcid
WHERE me.mediaId = @mediaId
	AND ii.lcid = @lcid
	AND mrt.name IN ('MediaToBackground','MediaToWideBackgroundImage')
UNION ALL
select TOP 1
	'Thumbnail' 'MediaRelationshipType' --Image.Purpose
	,ii.FileUrl
	,me.mediaId
	,ii.lcid 'lcid'
	,mt.name as 'MediaType'
FROM Media me 
	Join MediaType mt on mt.MediaTypeId = me.MediaTypeId
	JOIN MediaRelationship mr ON me.mediaId = mr.mediaId
	JOIN MediaRelationshipType mrt ON mr.mediaRelationshipTypeId = mrt.mediaRelationshipTypeId
	JOIN MediaInstance mi ON mr.relatedMediaId = mi.mediaId 
	JOIN ImageInstance ii ON mi.mediaInstanceId = ii.imageMediaInstanceId
	JOIN Locale lo ON lo.lcid = ii.lcid
WHERE me.mediaId = @mediaId
	AND ii.lcid = @lcid
	AND mrt.name IN ('MediaToThumbnail')

";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        var image = new Ieb.elementImagesImage();
                        IebVideoToSqlMapper.MapImage(image, reader);
                        result.Add(image);
                    }
                }
            }

            return result.Count > 0 ? result.ToArray() : null;
        }
        #endregion Image
        #region Genres
        public String[] GetGenresList(Guid mediaId, int lcid)
        {
            var result = new Collection<String>();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
SELECT 
	cl.name as 'CategoryLocale' --Genre.Name
FROM Media me 
	JOIN MediaCategory mc ON mc.mediaId = me.mediaId
	JOIN Category ca ON mc.categoryId = ca.categoryId
	JOIN CategorySystem cs ON cs.categorySystemId = ca.categorySystemId
	JOIN CategoryLocale cl ON ca.categoryId = cl.categoryId
	JOIN MediaType mt ON mt.mediaTypeId = me.mediaTypeId
WHERE me.mediaId = @mediaId
	AND cl.lcid = @lcid
	AND (	
		cs.name = 'External Xbox Movie Genre' AND mt.name IN ('Movie','MovieTrailer')
		OR cs.name = 'Video Genre' AND mt.Name IN ('TVEpisode','TVSeason','TVSeries')
		)
";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        result.Add(reader.Coalesce<string>("CategoryLocale"));
                    }
                }
            }

            return result.Count > 0 ? result.ToArray() : null;
        }
        #endregion Genres
        #region ParentalControl
        public Ieb.elementParentalControl GetParentalControl(Guid mediaId, int lcid)
        {
            var result = new Ieb.elementParentalControl();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
SELECT TOP 1
	rs.ratingSystemId
	,rm.FeedRatingSystem 'RatingSystem' --ParentalControl.System
	,rm.FeedRatingValue 'RatingValue' --ParentalControl.Rating
FROM Media me 
	JOIN MediaRating mr ON mr.mediaId = me.mediaId
	JOIN RatingValue rv ON rv.ratingValueId = mr.ratingValueId
	JOIN RatingSystem rs ON rs.ratingSystemId = rv.ratingSystemId
	JOIN RatingSystemCountry rsc ON rsc.ratingSystemId = rs.ratingSystemId
	JOIN dbo.Locale lo ON lo.countryCode = rsc.countryCode
	JOIN dbo.RatingMap rm ON rs.name = rm.ZuneRatingSystem AND rv.name = rm.ZuneRatingValue
WHERE me.mediaId = @mediaId
	AND lo.lcid = @lcid
ORDER BY rv.sortOrder";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    if (reader.Read())
                    {
                        int ratingSystem = reader.Coalesce<int>("ratingSystemId");
                        string descriptors = GetParentalControlDescriptor(mediaId, ratingSystem);
                        IebVideoToSqlMapper.MapParentalControl(result, reader, descriptors);
                    }
                    else
                    {
                        result.ItemsElementName = new Ieb.ItemsChoiceType[1];
                        result.Items = new object[1];
                        
                        result.ItemsElementName[0] = Ieb.ItemsChoiceType.Unrated;
                        result.Items[0] = "";
                    }
                }
            }

            return result;
        }

        public string GetParentalControlDescriptor(Guid mediaId, int ratingSystem)
        {
            var result = new StringBuilder();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
SELECT rd.name 'RatingDescriptor'
FROM MediaRatingDescriptor mrd
	JOIN dbo.RatingDescriptor rd ON rd.ratingDescriptorId = mrd.ratingDescriptorId
WHERE mrd.mediaId = @mediaId
	AND rd.ratingSystemId = @ratingSystem";

                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@ratingSystem", ratingSystem);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        if (result.Length > 0)
                        {
                            result.Append(",");
                        }
                        result.Append(reader.Coalesce<string>("RatingDescriptor"));
                    }
                }
            }

            return result.Length > 0 ? result.ToString() : null;
        }

        #endregion ParentalControl
        #region Instance

        public Ieb.elementInstances GetInstance(Guid mediaId, int lcid)
        {
            var instances = new Collection<Ieb.elementVideoInstance>();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
--VideoInstance
SELECT 
	vi.videoMediaInstanceId
	--Instance.device
	,vd.name 'VideoDefinition' --VideoInstance.ResolutionFormat
	--VideoInstance.DeliveryFormat: File.UrlUrl.EndsWith('WMV') ? 'Progressive' : 'Streaming';
	,al.locale 'PrimaryAudioLanguage' --VideoInstance.PrimaryAudioLanguage
	,vid.spokenLanguage --VideoInstance.primaryAudioLanguage?
	,vi.audioCC --VideoInstance.ClosedCaptioning?
	--VideoInstance.SubtitleLanguages Always null, no data in VideoSubtitle
	--VideoInstance.VideoInstanceType: Full,Trailer,Highlights; based on Product Type
	--VideoInstance.AdvertisementSlots?
FROM Media me 
	JOIN MediaInstance mi ON me.mediaId = mi.mediaId
	JOIN VideoInstance vi ON vi.videoMediaInstanceId = mi.mediaInstanceId
	JOIN VideoDefinition vd ON vd.videoDefinitionId = vi.videoDefinitionId
	JOIN VideoAudioTrackLanguage vatl ON vatl.videoMediaInstanceId = vi.videoMediaInstanceId
    JOIN Locale al ON al.lcid = vatl.lcid
	JOIN Video vid ON vid.videoMediaId = me.mediaId
	LEFT JOIN PreviewMediaInstance pmi ON pmi.previewMediaInstanceId = mi.mediaInstanceid
WHERE me.mediaId = @mediaId
	AND al.lcid = @lcid
	AND pmi.previewMediaInstanceId IS NULL
	AND vd.name IN ('HD','SD')
";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        var item = new Ieb.elementVideoInstance();
                        IebVideoToSqlMapper.MapInstance(item, reader);

                        var videoMediaInstanceId = reader.Coalesce<Guid>("videoMediaInstanceId");
                        item.Files = GetFileList(videoMediaInstanceId);
                        item.Availabilities = GetAvailabilityList(mediaId, lcid, videoMediaInstanceId);
                        
                        item.DeliveryFormat = item.Files[0].Url.EndsWith("WMV",StringComparison.OrdinalIgnoreCase) ? Ieb.DeliveryFormatType.Progressive : Ieb.DeliveryFormatType.Streaming;

                        instances.Add(item);
                    }
                }
            }

            if (instances.Count == 0)
            {
                return null;
            }

            var result = new Ieb.elementInstances();
            result.Items = instances.ToArray();
            return result;
        }
        #endregion Instance
        #region Availability
        public Ieb.elementAvailabilitiesAvailability[] GetAvailabilityList(Guid mediaId, int lcid, Guid mediaInstanceId)
        {
            var result = new Collection<Ieb.elementAvailabilitiesAvailability>();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
select DISTINCT lr.name as 'offerType' --Availability.offerType
	,oi.startDateTime --Availability.startDateTime
	,oi.endDateTime --Availability.endDateTime
	,oi.price --Availability.priceString
	,oi.priceCurrencyCode --Availability.priceString
FROM Media me 
	JOIN MediaInstance mi ON me.mediaId = mi.mediaId
    JOIN ProviderTermMediaInstance ptmi ON mi.mediaInstanceId = ptmi.mediaInstanceId  
    JOIN ProviderTerm pt ON ptmi.providerTermId = pt.providerTermId  
    JOIN OfferInstanceProviderTerm oipt ON pt.providerTermId = oipt.providerTermId AND oipt.visibilityStatusId = 3  
    JOIN OfferInstance oi ON oipt.offerInstanceId = oi.offerInstanceId AND oi.visibilityLevelId = 1
    JOIN Locale lc ON oi.countryCode = lc.countryCode
    JOIN LicenseRight lr ON ptmi.licenseTypeId = lr.licenseTypeId 
    LEFT JOIN PreviewMediaInstance pmi ON mi.mediaInstanceId = pmi.previewMediaInstanceId  
WHERE me.mediaId=@mediaId 
	AND lc.lcid=@lcid 
	AND pmi.previewMediaInstanceId IS NULL  
	AND mi.mediaInstanceId = @mediaInstanceId
	AND GETUTCDATE() BETWEEN oi.startDateTime AND oi.EndDateTime";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);
                sqlClient.AddParameter("@mediaInstanceId", mediaInstanceId);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        var item = new Ieb.elementAvailabilitiesAvailability();
                        IebVideoToSqlMapper.MapAvailability(item, reader);
                        result.Add(item);
                    }
                }
            }

            return result.ToArray();
        }
        #endregion Instance
        #region File
        public Ieb.elementFilesFile[] GetFileList(Guid videoMediaInstanceId)
        {
            var result = new Collection<Ieb.elementFilesFile>();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
--File
SELECT 
vf.fileUrl --File.url
,vf.size --File.Size
--File.SequenceNumber
FROM VideoInstance vi
	JOIN VideoFile vf ON vf.videoMediaInstanceId = vi.videoMediaInstanceId
WHERE vi.videoMediaInstanceId = @videoMediaInstanceId";
                sqlClient.AddParameter("@videoMediaInstanceId", videoMediaInstanceId);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        var item = new Ieb.elementFilesFile();
                        IebVideoToSqlMapper.MapFile(item, reader);
                        result.Add(item);
                    }
                }
            }

            return result.Count > 0 ? result.ToArray() : null;
        }
        #endregion File
        #region Contributor
        public Ieb.elementDirectors GetDirectorList(Guid mediaId, int lcid)
        {
            var contributorList = GetContributorList(mediaId, lcid, "Director");
            if (contributorList == null)
            {
                return null;
            }

            var result = new Ieb.elementDirectors();
            result.Director = contributorList.ToArray();
            return result;
        }

        public Ieb.elementWriters GetWriterList(Guid mediaId, int lcid)
        {
            var contributorList = GetContributorList(mediaId, lcid, "Writer");
            if (contributorList == null)
            {
                return null;
            }

            var result = new Ieb.elementWriters();
            result.Writer = contributorList.ToArray();
            return result;
        }

        public Ieb.elementActors GetActorList(Guid mediaId, int lcid)
        {
            var actors = new Collection<Ieb.elementActorsActor>();
            using (SqlClient sqlClient = GetContributorListQuery(mediaId, lcid, "Actor"))
            {
                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        Ieb.elementActorsActor actor = new Ieb.elementActorsActor();
                        IebVideoToSqlMapper.MapActor(actor, reader);
                        Guid contributorId = reader.Coalesce<Guid>("contributorId");
                        actor.Characters = GetCharacterList(mediaId,contributorId);
                        actors.Add(actor);
                    }
                }
            }

            if (actors.Count == 0)
            {
                return null;
            }

            var result = new Ieb.elementActors();
            result.Actor = actors.ToArray();
            return result;
        }
        public Collection<Ieb.elementNames> GetContributorList(Guid mediaId, int lcid, string role)
        {
            var result = new Collection<Ieb.elementNames>();
            using (SqlClient sqlClient = GetContributorListQuery(mediaId, lcid, role))
            {
                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        Ieb.elementNames contributor = new Ieb.elementNames();
                        IebVideoToSqlMapper.MapContributor(contributor, reader);

                        result.Add(contributor);
                    }
                }
            }

            return result;
        }

        public SqlClient GetContributorListQuery(Guid mediaId, int lcid, string role)
        {
            SqlClient sqlClient = new SqlClient(this.InterfaceInformation);

            sqlClient.Command.CommandType = System.Data.CommandType.Text;
            sqlClient.Command.CommandText = @"
--ProductContributor
SELECT TOP 10
	mc.contributorId --ProductContributor.canonicalId
	,ro.name 'Role' --ProductContributor.Role
	,cl.displayName --ProductContributor.Name
	,mc.sortOrder --ProductContributor.SortOrder
	,mlm.lcid
	,clm.lcid
FROM Media me 
	JOIN MediaContributor mc ON mc.mediaId = me.mediaId
	JOIN [Role] ro ON ro.roleId = mc.roleId
	JOIN MediaLocale ml ON ml.mediaId = mc.mediaId  
	JOIN MediaLocaleMap mlm ON mlm.mediaId = ml.mediaId and mlm.lcidMap = ml.lcid
	JOIN Contributor co ON co.contributorId = mc.contributorId  
	JOIN ContributorLocale cl ON cl.contributorId = co.contributorId  
	JOIN ContributorLocaleMap clm ON clm.contributorId = cl.contributorId AND clm.lcidMap = cl.lcid
WHERE 
	mc.mediaId = @mediaId 
	AND clm.lcid = @lcid
	AND mlm.lcid = @lcid  
	AND ro.name = @role
ORDER BY mc.SortOrder";
            sqlClient.AddParameter("@mediaId", mediaId);
            sqlClient.AddParameter("@lcid", lcid);
            sqlClient.AddParameter("@role", role);

            return sqlClient;
        }
        #endregion Contributor
        #region Studio
        public Ieb.elementStudios GetStudioList(Guid mediaId, int lcid)
        {
            Collection<string> studios = new Collection<string>();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
SELECT DISTINCT vi.productionCompany 'Studio'
	FROM dbo.Video vi 
	LEFT JOIN dbo.ViewSeasonEpisode vse ON vse.EpisodeId = vi.videoMediaId
    LEFT JOIN dbo.ViewSeriesSeason vss ON vss.SeasonId = vse.SeasonId
    WHERE vi.ProductionCompany IS NOT NULL
    AND (vi.videoMediaId = @mediaId OR vse.SeasonId = @mediaId OR vss.SeriesId = @mediaId)";
                sqlClient.AddParameter("@mediaId", mediaId);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        studios.Add(reader.Coalesce<String>("Studio"));
                    }
                }
            }

            if (studios.Count == 0)
            {
                return null;
            }

            var result = new Ieb.elementStudios();
            result.Studio = studios.ToArray();
            return result;
        }
        #endregion Studio
        #region Character
        public Ieb.elementCharacters GetCharacterList(Guid mediaId, Guid contributorId)
        {
            Collection<string> characters = new Collection<string>();
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
--Character
SELECT mc.character 
FROM Media me 
	JOIN MediaContributor mc ON mc.mediaId = me.mediaId
WHERE (mc.character IS NOT NULL AND mc.character <>'')
	AND me.mediaId = @mediaId 
	AND mc.contributorId = @contributorId";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@contributorId", contributorId);

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    while (reader.Read())
                    {
                        characters.Add(reader.Coalesce<String>("character"));
                    }
                }
            }

            if (characters.Count == 0)
            {
                return null;
            }

            var result = new Ieb.elementCharacters();
            result.Character = new Ieb.elementNames[characters.Count];
            for (int i = 0; i < characters.Count; i++)
            {
                result.Character[i] = new Ieb.elementNames();
                result.Character[i].Name = characters[i];
            }
            return result;
        }
        #endregion Character
        #region MediaLink
        public String GetMediaLink(Guid mediaId, int lcid, MediaRelationshipType type)
        {
            String result = null;
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
SELECT 
	mer.mediaId,
	@lcid 'lcid', 
	mt.name 'MediaType' --Product Media Type
FROM Media me
JOIN MediaRelationship mr ON me.mediaId = mr.relatedMediaId
JOIN MediaRelationshipType mrt ON mrt.mediaRelationshipTypeId = mr.mediaRelationshipTypeId
JOIN Media mer ON mr.mediaId = mer.mediaId
JOIN MediaType mt ON mt.mediaTypeId = mer.mediaTypeId
WHERE me.mediaId = @mediaId
AND mrt.name = @type";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);
                sqlClient.AddParameter("@type", type.ToString());

                using (SqlDataReader reader = sqlClient.Execute())
                {
                    if (reader.Read())
                    {
                        result = IebVideoToSqlMapper.MapItemId(reader);
                    }
                    if (reader.Read())
                    {
                        throw new InvalidOperationException("Multiple rows returned");
                    }
                    return result;
                }
            }
        }
        #endregion Genres
        #region CatalogWatcherToDoProduct

        /// <summary>
        /// Deletes all the video records for the Catalog Watcher
        /// dbo.CatalogWatcherToDoProduct
        /// </summary>
        public void ClearToDoList()
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"TRUNCATE TABLE dbo.CatalogWatcherToDoProduct";
                sqlClient.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Adds an entry to the Catalog Watcher todo list
        /// </summary>
        /// <param name="mediaId">id of the media</param>
        /// <param name="lcid">id of the locale</param>
        /// <param name="lsn">log sequence number</param>
        /// <param name="fullFeed">entry is for a full feed vs delta feed</param>
        public void AddToDoList(Guid mediaId, int lcid, long lsn, bool fullFeed)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
MERGE dbo.CatalogWatcherToDoProduct AS target
USING (SELECT @mediaId,@lcid,@lsn,@seq) AS Source (mediaId,lcid,lsn,seq)
ON	(target.mediaId = Source.mediaId
	AND target.lcid = Source.lcid
	AND target.seq = Source.seq)
WHEN MATCHED THEN
	Update SET lsn = @lsn
WHEN NOT MATCHED THEN
	INSERT (mediaId,lcid,lsn,seq)
	VALUES (@mediaId,@lcid,@lsn,@seq);";
                int fullFeedValue = (fullFeed) ? 1 : 0;

                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.AddParameter("@lcid", lcid);
                sqlClient.AddParameter("@lsn", lsn);
                sqlClient.AddParameter("@seq", fullFeedValue);

                sqlClient.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Adds an entry to the Catalog Watcher todo list
        /// </summary>
        /// <param name="mediaId">id of the media</param>
        /// <param name="lcid">id of the locale</param>
        /// <param name="lsn">log sequence number</param>
        /// <param name="fullFeed">entry is for a full feed vs delta feed</param>
        public void UpdateMedia(Guid mediaId)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"
update me
set me.modifiedDate = GETUTCDATE()
FROM dbo.Media me
WHERE me.mediaId = @mediaId
";
                sqlClient.AddParameter("@mediaId", mediaId);
                sqlClient.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Adds an entry to the Catalog Watcher todo list
        /// </summary>
        /// <param name="mediaId">id of the media</param>
        /// <param name="lcid">id of the locale</param>
        /// <param name="lsn">log sequence number</param>
        /// <param name="fullFeed">entry is for a full feed vs delta feed</param>
        public void UpdateCtState(string name, int value)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"Update dbo.CT_State SET itemValue = @value WHERE itemName = @name";
                sqlClient.AddParameter("@name", name);
                sqlClient.AddParameter("@value", value);
                sqlClient.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Enable the sql job to transfer data from CT tables to Todo tables
        /// </summary>
        public override void EnableTransferJob()
        {
            this.UpdateSqlAgentJob(TransferJobName, true);
        }

        /// <summary>
        /// Disable the sql job to transfer data from CT tables to Todo tables
        /// </summary>
        public override void DisableTransferJob()
        {
            this.UpdateSqlAgentJob(TransferJobName, false);
        }

        /// <summary>
        /// Runs the sql job to transfer data from CT tables to Todo tables
        /// </summary>
        public override void RunTransferJob()
        {
            this.RunSqlAgentJob(TransferJobName);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\IebAzureStorageDal.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.IO.Compression;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace CatalogWatcherTests_Video.Managers
{
    public class IebAzureStorageDal : PublisherDal
    {
        public string ConnectionString { get; private set; }

        protected CloudStorageAccount Account { get; private set; }
        protected CloudBlobClient Client { get; private set; }
        protected CloudBlobContainer Container { get; private set; }
        
        private BlobRequestOptions options;
            
        public IebAzureStorageDal(string accountName, string containerName, string connectionString)
            : base (accountName, containerName)
        {
            this.ConnectionString = connectionString;

            this.Account = CloudStorageAccount.Parse(this.ConnectionString);
            this.Client = this.Account.CreateCloudBlobClient();
            this.Container = this.Client.GetContainerReference(this.ContainerName);

            this.options = new BlobRequestOptions();
            this.options.BlobListingDetails = BlobListingDetails.Metadata;
        }

        /// <summary>
        /// Gets the content of the blob 
        /// </summary>
        /// <param name="blobName"></param>
        /// <returns></returns>
        public override string GetBlob(string blobName)
        {
            CloudBlob blob = this.Container.GetBlobReference(blobName);
            
            using (BlobStream blobStream = blob.OpenRead())
            {
                return ConvertToXmlString(blobStream);
            }
        }

        public override void WriteXmlToDisk(string blobName, string destinationFilePath)
        {
            CloudBlob blob = this.Container.GetBlobReference(blobName);
            
            using (BlobStream blobStream = blob.OpenRead())
            {
                 WriteXmlToDisk(blobStream, destinationFilePath);
            }
        }

        public override void WriteBlobToDisk(string blobName, string destinationFilePath)
        {
            CloudBlob blob = this.Container.GetBlobReference(blobName);

            using (BlobStream blobStream = blob.OpenRead())
            {
                WriteBlobToDisk(blobStream, destinationFilePath);
            }
        }
        
        /// <summary>
        /// Lists all blob items in the container
        /// </summary>
        public override Collection<PublisherFile> GetBlobList()
        {
            var result = new Collection<PublisherFile>();
            
            BlobRequestOptions options = new BlobRequestOptions();
            options.BlobListingDetails = BlobListingDetails.Metadata;
            var blobList = this.Container.ListBlobs(this.options);
            
            foreach (CloudBlob blobItem in blobList)
            {
                PublisherFile item = new PublisherFile();
                item.BlobName = blobItem.Uri.ToString();
                item.LastModificationTime = blobItem.Properties.LastModifiedUtc;
                result.Add(item);
            }

            return result;
        }

        /// <summary>
        /// Deletes all blob items in the container
        /// </summary>
        public override void DeleteBlobs()
        {
            BlobRequestOptions options = new BlobRequestOptions();
            options.BlobListingDetails = BlobListingDetails.Metadata;
            var blobList = this.Container.ListBlobs(this.options);

            foreach (CloudBlob blobItem in blobList)
            {
                blobItem.Delete();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\CronManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Net;

namespace CatalogWatcherTests_Video.Managers
{
    public class CronManager
    {
        public string ClassName { get; set; }
        public string AssemblyName { get; set; }
        public string CronNamePrefix { get; set; }
        public string ResourceName { get; set; }
        public string DestinationName { get; set; }

        public string WatcherMachineName { get; set; }
        public string HealthCheckUrl { get; set; }

        public int IntervalTime { get; set; }
        private static int defaultTitleId = -129071;
        private CronDal dal;
        private static readonly string textArgumentsFormat = @"<PluginContext><attribute name=""BucketId"" type=""System.Int32"">{0}</attribute><attribute name=""ResourceName"" type=""System.String"">{1}</attribute><attribute name=""NumberOfBuckets"" type=""System.Int32"">{2}</attribute><attribute name=""DestinationName"" type=""System.String"">{3}</attribute></PluginContext>";

        public CronManager()
        {
            this.dal = new CronDal();
        }

        public void Start()
        {
            //this.dal.UpdateCronJobInterval(this.ResourceName, this.DestinationName, 15);
            this.dal.UpdateCronJobNextRun(this.ResourceName, this.DestinationName, 5);
            this.CallCronHealthCheck();
        }

        /// <summary>
        /// This method will delete all existing cron jobs, and create new set of jobs
        /// </summary>
        /// <param name="total">Number of jobs to create</param>
        public void SetupJobs(int total)
        {
            this.dal.DeleteCronJobByType(this.ResourceName, this.DestinationName);
            for (int i = 0; i < total; i++)
            {
                string textArguments = FormatTextArguments(i, this.ResourceName, total, this.DestinationName);
                string jobName = FormatCronJobName(i, this.CronNamePrefix);
                this.dal.AddCronJob(jobName, defaultTitleId, this.AssemblyName, this.ClassName, textArguments, this.IntervalTime);
            }

        }

        public void Stop()
        {
            CallIISReset();
        }

        private static string FormatCronJobName(int index, string namePrefix)
        {
            return String.Format("{0}{1}", namePrefix, index);
        }

        private static string FormatTextArguments(int bucketId, string resourceName, int numberOfBuckets, string destinationName)
        {
            return string.Format(textArgumentsFormat,
                bucketId, resourceName, numberOfBuckets, destinationName);
        }

        /// <summary>
        /// Calls iisreset on the watcher box.
        /// </summary>
        private void CallIISReset()
        {
            Process p = System.Diagnostics.Process.Start("psexec.exe", string.Format("\\\\{0} iisreset", this.WatcherMachineName));
            p.WaitForExit();
        }

        /// <summary>
        /// calls the cron healthcheck on the watcher box
        /// </summary>
        private void CallCronHealthCheck()
        {
            WebRequest request = WebRequest.Create(this.HealthCheckUrl);
            request.GetResponse();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Data\IebBingFeed.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4961
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=2.0.50727.42.
// 
namespace IEBDataModel.Model4 {
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion", IsNullable=false)]
    public partial class Feed {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Movie", typeof(elementMovie))]
        [System.Xml.Serialization.XmlElementAttribute("TVEpisode", typeof(elementTVEpisode))]
        [System.Xml.Serialization.XmlElementAttribute("TVSeason", typeof(elementTVSeason))]
        [System.Xml.Serialization.XmlElementAttribute("TVSeries", typeof(elementTVSeries))]
        [System.Xml.Serialization.XmlElementAttribute("TVShow", typeof(elementTVShow))]
        public elementProduct[] Items;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementMovie : elementProduct {
        
        /// <remarks/>
        public string ApplicationSpecificData;
        
        /// <remarks/>
        public string OriginalPublicationDate;
        
        /// <remarks/>
        public elementStudios Studios;
        
        /// <remarks/>
        public string DurationInSeconds;
        
        /// <remarks/>
        public elementDirectors Directors;
        
        /// <remarks/>
        public elementActors Actors;
        
        /// <remarks/>
        public elementWriters Writers;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementStudios {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Studio")]
        public string[] Studio;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementAliases {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Alias")]
        public string[] Alias;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementSportTeam {
        
        /// <remarks/>
        public string Name;
        
        /// <remarks/>
        public elementAliases Aliases;
        
        /// <remarks/>
        public string City;
        
        /// <remarks/>
        public sportEventTerritoryType Territory;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool TerritorySpecified;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public enum sportEventTerritoryType {
        
        /// <remarks/>
        Home,
        
        /// <remarks/>
        Away,
        
        /// <remarks/>
        Neutral,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementSportTeams {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Team")]
        public elementSportTeam[] Team;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementSport {
        
        /// <remarks/>
        public string SportType;
        
        /// <remarks/>
        public string League;
        
        /// <remarks/>
        public elementSportTeams Teams;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementWriters {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Writer")]
        public elementNames[] Writer;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementNames {
        
        /// <remarks/>
        public string Name;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementCharacters {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Character")]
        public elementNames[] Character;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementActors {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Actor")]
        public elementActorsActor[] Actor;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementActorsActor : elementNames {
        
        /// <remarks/>
        public elementCharacters Characters;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementDirectors {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Director")]
        public elementNames[] Director;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(elementVideoInstance))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public abstract partial class elementInstance {
        
        /// <remarks/>
        public DeviceType Device;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("File", IsNullable=false)]
        public elementFilesFile[] Files;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Availability", IsNullable=false)]
        public elementAvailabilitiesAvailability[] Availabilities;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public enum DeviceType {
        
        /// <remarks/>
        Web,
        
        /// <remarks/>
        Xbox360,
        
        /// <remarks/>
        PC,
        
        /// <remarks/>
        Android,
        
        /// <remarks/>
        iOS,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementFilesFile {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
        public string Url;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="integer")]
        public string Size;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="integer")]
        public string SequenceNumber;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementAvailabilitiesAvailability {
        
        /// <remarks/>
        public OfferType OfferType;
        
        /// <remarks/>
        public string StartDateTime;
        
        /// <remarks/>
        public string EndDateTime;
        
        /// <remarks/>
        public string PriceDisplayString;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public enum OfferType {
        
        /// <remarks/>
        Rent,
        
        /// <remarks/>
        PurchaseToOwn,
        
        /// <remarks/>
        FreeWithAds,
        
        /// <remarks/>
        Free,
        
        /// <remarks/>
        FreeWithSubscription,
        
        /// <remarks/>
        PayPerView,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementVideoInstance : elementInstance {
        
        /// <remarks/>
        public ResolutionFormatType ResolutionFormat;
        
        /// <remarks/>
        public DeliveryFormatType DeliveryFormat;
        
        /// <remarks/>
        public string PrimaryAudioLanguage;
        
        /// <remarks/>
        public string ClosedCaptioning;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("SubtitleLanguage", IsNullable=false)]
        public string[] SubtitleLanguages;
        
        /// <remarks/>
        public VideoInstanceType VideoInstanceType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Timestamp", DataType="time", IsNullable=false)]
        public System.DateTime[] AdvertisementSlots;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public enum ResolutionFormatType {
        
        /// <remarks/>
        SD,
        
        /// <remarks/>
        HD,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public enum DeliveryFormatType {
        
        /// <remarks/>
        Streaming,
        
        /// <remarks/>
        Progressive,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public enum VideoInstanceType {
        
        /// <remarks/>
        Full,
        
        /// <remarks/>
        Trailer,
        
        /// <remarks/>
        Highlights,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementInstances {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("VideoInstance")]
        public elementVideoInstance[] Items;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementDescriptors {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Descriptor")]
        public string[] Descriptor;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementParentalControl {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Descriptors", typeof(elementDescriptors))]
        [System.Xml.Serialization.XmlElementAttribute("HasGuidance", typeof(bool))]
        [System.Xml.Serialization.XmlElementAttribute("NotRated", typeof(string))]
        [System.Xml.Serialization.XmlElementAttribute("Rating", typeof(string))]
        [System.Xml.Serialization.XmlElementAttribute("System", typeof(string))]
        [System.Xml.Serialization.XmlElementAttribute("Unrated", typeof(string))]
        [System.Xml.Serialization.XmlChoiceIdentifierAttribute("ItemsElementName")]
        public object[] Items;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ItemsElementName")]
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public ItemsChoiceType[] ItemsElementName;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion", IncludeInSchema=false)]
    public enum ItemsChoiceType {
        
        /// <remarks/>
        Descriptors,
        
        /// <remarks/>
        HasGuidance,
        
        /// <remarks/>
        NotRated,
        
        /// <remarks/>
        Rating,
        
        /// <remarks/>
        System,
        
        /// <remarks/>
        Unrated,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(elementTVShow))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(elementTVSeries))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(elementTVSeason))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(elementTVEpisode))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(elementMovie))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public abstract partial class elementProduct {
        
        /// <remarks/>
        public string Provider;
        
        /// <remarks/>
        public string ItemId;
        
        /// <remarks/>
        public string Title;
        
        /// <remarks/>
        public string TitlePronunciation;
        
        /// <remarks/>
        public string SortTitle;
        
        /// <remarks/>
        public string Description;
        
        /// <remarks/>
        public string ShortDescription;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("AlternateTitle", IsNullable=false)]
        public string[] AlternateTitles;
        
        /// <remarks/>
        public string OriginalPublicationRegion;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("AlternateId", IsNullable=false)]
        public string[] AlternateIds;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Keyword", IsNullable=false)]
        public string[] Keywords;
        
        /// <remarks/>
        public bool IsUserGenerated;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Image", IsNullable=false)]
        public elementImagesImage[] Images;
        
        /// <remarks/>
        public string LastModifiedDate;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Genre", IsNullable=false)]
        public string[] Genres;
        
        /// <remarks/>
        public elementParentalControl ParentalControl;
        
        /// <remarks/>
        public elementInstances Instances;
        
        /// <remarks/>
        public string PublicWebUri;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementImagesImage {
        
        /// <remarks/>
        public ImagePurposeType ImagePurpose;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
        public string Url;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public enum ImagePurposeType {
        
        /// <remarks/>
        BoxArt,
        
        /// <remarks/>
        Thumbnail,
        
        /// <remarks/>
        Logo,
        
        /// <remarks/>
        Background,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementTVShow : elementProduct {
        
        /// <remarks/>
        public string ApplicationSpecificData;
        
        /// <remarks/>
        public string OriginalPublicationDate;
        
        /// <remarks/>
        public string DurationInSeconds;
        
        /// <remarks/>
        public string Network;
        
        /// <remarks/>
        public elementStudios Studios;
        
        /// <remarks/>
        public elementDirectors Directors;
        
        /// <remarks/>
        public elementActors Actors;
        
        /// <remarks/>
        public elementWriters Writers;
        
        /// <remarks/>
        public elementSport Sport;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementTVSeries : elementProduct {
        
        /// <remarks/>
        public string OriginalPublicationDate;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="integer")]
        public string TotalNumberOfSeasons;
        
        /// <remarks/>
        public string Network;
        
        /// <remarks/>
        public elementStudios Studios;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="gYear")]
        public string EndYear;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementTVSeason : elementProduct {
        
        /// <remarks/>
        public string OriginalPublicationDate;
        
        /// <remarks/>
        public string SeasonNumber;
        
        /// <remarks/>
        public string SeriesId;
        
        /// <remarks/>
        public string Network;
        
        /// <remarks/>
        public elementStudios Studios;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion")]
    public partial class elementTVEpisode : elementProduct {
        
        /// <remarks/>
        public string ApplicationSpecificData;
        
        /// <remarks/>
        public string OriginalPublicationDate;
        
        /// <remarks/>
        public string EpisodeNumber;
        
        /// <remarks/>
        public string DurationInSeconds;
        
        /// <remarks/>
        public string Network;
        
        /// <remarks/>
        public elementStudios Studios;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("SeasonId", typeof(string))]
        [System.Xml.Serialization.XmlElementAttribute("SeriesId", typeof(string))]
        [System.Xml.Serialization.XmlChoiceIdentifierAttribute("ItemsElementName")]
        public string[] Items;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ItemsElementName")]
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public ItemsChoiceType1[] ItemsElementName;
        
        /// <remarks/>
        public elementDirectors Directors;
        
        /// <remarks/>
        public elementActors Actors;
        
        /// <remarks/>
        public elementWriters Writers;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion", IncludeInSchema=false)]
    public enum ItemsChoiceType1 {
        
        /// <remarks/>
        SeasonId,
        
        /// <remarks/>
        SeriesId,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\IebVideoProducerManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CatalogWatcherTests_Video.Managers
{
    /// <summary>
    /// Class for managing all interactions with the Ieb Movie source
    /// </summary>
    public class IebVideoProducerManager
    {
        private bool fullFeed;
        private long currentLsn;
        public IebVideoDal dal { get; private set; }

        int fullFeedEnableStartIndex = Int32.MaxValue;
        int fullFeedDisableStartIndex = -1;

        public IebVideoProducerManager(bool fullFeedEnabled)
        {
            this.dal = new IebVideoDal();
            this.currentLsn = 1;
            this.fullFeed = fullFeedEnabled;
        }

        /// <summary>
        /// Start the system from running:
        /// Enable Sql Agent Job
        /// Enable CT
        /// </summary>
        public void Start()
        {
            // Enable CT
            this.dal.EnableTransferJob();
        }

        /// <summary>
        /// Stop the system from running:
        /// Disables Sql Agent Job
        /// Disables CT
        /// </summary>
        public void Stop()
        {
            // Disable CT
            this.dal.DisableTransferJob();
        }

        /// <summary>
        /// Runs the sql agent job to force all documents to run
        /// </summary>
        public void Run()
        {
            this.dal.RunTransferJob();
        }

        /// <summary>
        /// Clears all movie items from CT and Todo tables
        /// </summary>
        public void ClearDocuments()
        {
            this.dal.ClearToDoList();
            this.currentLsn = 1;
        }

        /// <summary>
        /// Add items to the Todo tables
        /// </summary>
        public void AddDocuments(Guid mediaId, int lcid)
        {
            // Add the full feed record in
            this.dal.AddToDoList(mediaId, lcid, this.currentLsn++, false);

            // If we're doing delta feeds (not a full feed), then:
            // Add a record for the delta feed feed
            if (!this.fullFeed)
            {
                this.dal.AddToDoList(mediaId, lcid, this.currentLsn++, true);
                this.dal.UpdateCtState("currentFullSyncLsnEnd", fullFeedDisableStartIndex);
            }
            else
            {
                this.dal.UpdateCtState("currentFullSyncLsnEnd", fullFeedEnableStartIndex);
            }
        }

        /// <summary>
        /// Updates the documents in the media table
        /// </summary>
        public void UpdateDocuments(Guid mediaId)
        {
            this.dal.UpdateMedia(mediaId);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\IebVideoPublisherManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using System.IO.Compression;
using System.IO;

namespace CatalogWatcherTests_Video.Managers
{
    public class PublisherFile
    {
        public DateTime LastModificationTime;
        public String BlobName;
    }

    public class IebVideoPublisherManager
    {
        public PublisherDal Dal {get; private set;}


        public IebVideoPublisherManager(PublisherDal dal)
        {
            this.Dal = dal;
        }

        /// <summary>
        /// Return a list of documents currently stored
        /// </summary>
        /// <returns>List of document names</returns>
        public Collection<PublisherFile> GetDocumentList()
        {
            return this.Dal.GetBlobList();
        }

        /// <summary>
        /// Returns the content of the document
        /// </summary>
        /// <param name="name">The name of the document to fetch</param>
        /// <returns>The document</returns>
        public object GetDocument(string name)
        {
            return this.Dal.GetBlob(name);
        }

        /// <summary>
        /// Deletes all documents in storage
        /// </summary>
        public void ClearDocuments()
        {
            this.Dal.DeleteBlobs();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\IebVideoToSqlMapper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Ieb = IEBDataModel.Model4;
using System.Data;
using System.Collections.ObjectModel;
using System.Globalization;

namespace CatalogWatcherTests_Video.Managers
{
    public static class IebVideoToSqlMapper
    {
        private static readonly string DateTimeFormat = "yyyy-MM-ddTHH:mm:ssZ";
        public static string MapItemId(IDataReader reader)
        {
            Guid mediaId = reader.Coalesce<Guid>("mediaId");
            int lcid = reader.Coalesce<int>("lcid");
            System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo(lcid);
            string mediaType = reader.Coalesce<string>("MediaType");
            if (mediaType.Equals("MovieTrailer"))
            {
                mediaType = "Movie";
            }

            return String.Format("http://microsoft.com/{1}/{2}/{0}", mediaId, culture.Name, mediaType);
        }

        public static string MapApplicationSpecificData(IDataReader reader)
        {
            Guid mediaId = reader.Coalesce<Guid>("mediaId");
            int lcid = reader.Coalesce<int>("lcid");
            System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo(lcid);
            string mediaType = reader.Coalesce<string>("MediaType");
            if (mediaType.Equals("TVSeason"))
            {
                string seasonNumber = reader.Coalesce<int>("seasonNumber").ToString();
                return String.Format("Details?ContentType={0}&ContentId={1}&ContentId2={2}", mediaType, mediaId, seasonNumber);
            }
            else
            {
                return String.Format("Details?ContentType={0}&ContentId={1}", mediaType, mediaId);
            }
        }

        public static void MapProduct(Ieb.elementProduct result, IDataReader reader)
        {
            result.Provider = null; //?
            result.ItemId = MapItemId(reader);
            result.Title = reader.Coalesce<string>("title");
            result.TitlePronunciation = null;
            result.SortTitle = reader.Coalesce<string>("titleSort");
            result.Description = reader.Coalesce<string>("description");
            result.ShortDescription = reader.Coalesce<string>("reducedDescription");

            result.AlternateTitles = new string[0]; //Doesn't exist
            result.OriginalPublicationRegion = null; //Removing this
            result.AlternateIds = new string[0];
            result.Keywords = new string[0];
            result.IsUserGenerated = false;
            result.LastModifiedDate = reader.Coalesce<DateTime>("modifiedDate").ToString(DateTimeFormat);
            result.PublicWebUri = null;


            //result.ApplicationSpecificData = String.Format("Details?ContentType={0}&ContentId={1}", mediaType, mediaId);
            //result.Visibility = reader.Coalesce<string>("VisibilityStatus").Equals("Live", StringComparison.OrdinalIgnoreCase);
        }

        public static void MapTvEpisode(Ieb.elementTVEpisode result, IDataReader reader)
        {
            result.ApplicationSpecificData = MapApplicationSpecificData(reader);
            result.OriginalPublicationDate = reader.Coalesce<DateTime>("originalReleaseDate").ToString(DateTimeFormat);
            result.EpisodeNumber = reader.Coalesce<int>("episodeNumber").ToString();
            result.DurationInSeconds = reader.Coalesce<int?>("durationSecs").ToString();
            result.Network = reader.Coalesce<String>("Network");
            result.Items = null; //ItemId of Series or season I guess
            result.ItemsElementName = null; //SeasonId,SeriesId I guess
        }

        public static void MapTvSeason(Ieb.elementTVSeason result, IDataReader reader)
        {
            result.OriginalPublicationDate = reader.Coalesce<DateTime>("originalReleaseDate").ToString(DateTimeFormat);
            result.SeasonNumber = reader.Coalesce<int>("seasonNumber").ToString();
            result.Network = reader.Coalesce<String>("Network");
            result.SeriesId = null; //Populated in another call
        }

        public static void MapTvSeries(Ieb.elementTVSeries result, IDataReader reader)
        {
            result.OriginalPublicationDate = reader.Coalesce<DateTime>("originalReleaseDate").ToString(DateTimeFormat);
            result.TotalNumberOfSeasons = null;
            result.Network = reader.Coalesce<string>("Network");
            result.EndYear = null;
        }
        public static void MapMovie(Ieb.elementMovie result, IDataReader reader)
        {
            result.ApplicationSpecificData = MapApplicationSpecificData(reader);
            result.OriginalPublicationDate = reader.Coalesce<DateTime>("originalReleaseDate").ToString(DateTimeFormat);
            result.DurationInSeconds = reader.Coalesce<int?>("durationSecs").ToString();
        }
        public static void MapImage(Ieb.elementImagesImage result, IDataReader reader)
        {
            string mediaRelationshipType = reader.Coalesce<string>("MediaRelationshipType");
            Guid mediaId = reader.Coalesce<Guid>("mediaId");
            int lcid = reader.Coalesce<int>("lcid");
            System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo(lcid);
            string mediaType = reader.Coalesce<string>("MediaType");
            string fileUrl = reader.Coalesce<String>("fileUrl");

            string imageUrlMediaType = null;
            string imageUrlImageType = null;
            string queryStringParameters = null;
            switch (mediaRelationshipType)
            {
                case "BoxArt":
                    result.ImagePurpose = Ieb.ImagePurposeType.BoxArt;
                    imageUrlImageType = "primaryImage";
                    queryStringParameters = "?width=584&height=800&resize=true";
                    break;
                case "Background":
                    result.ImagePurpose = Ieb.ImagePurposeType.Background;
                    if (mediaType.StartsWith("Movie", StringComparison.OrdinalIgnoreCase))
                    {
                        imageUrlImageType = "xboxBackgroundImage";
                    }
                    else if (mediaType.StartsWith("TV", StringComparison.OrdinalIgnoreCase))
                    {
                        imageUrlImageType = "backgroundImage";
                    }
                    queryStringParameters = "?width=1920&height=1080&resize=true";
                    break;
                case "Thumbnail":
                    result.ImagePurpose = Ieb.ImagePurposeType.Thumbnail;
                    result.Url = reader.Coalesce<String>("fileUrl");
                    if (mediaType.StartsWith("Movie", StringComparison.OrdinalIgnoreCase))
                    {
                        queryStringParameters = "?width=43&height=64&resize=true";
                    }
                    else if (mediaType.StartsWith("TV", StringComparison.OrdinalIgnoreCase))
                    {
                        queryStringParameters = "?width=64&height=64&resize=true";
                    }
                    break;
                default:
                    throw new InvalidOperationException("Invalid mediaRelationshipType" + mediaRelationshipType);
            }

            switch (mediaType)
            {
                case "Movie":
                    imageUrlMediaType = "movie";
                    break;
                case "MovieTrailer":
                    imageUrlMediaType = "movieTrailer";
                    break;
                case "TVEpisode":
                    imageUrlMediaType = "tv/episode";
                    break;
                case "TVSeason":
                    imageUrlMediaType = "tv/season";
                    break;
                case "TVSeries":
                    imageUrlMediaType = "tv/series";
                    break;
                default:
                    throw new InvalidOperationException("Invalid mediaRelationshipType" + mediaRelationshipType);
            }

            result.Url = String.Format("http://catalog.zune.net/v3.2/{0}/{1}/{2}/{3}{4}", culture.Name, imageUrlMediaType, mediaId, imageUrlImageType, queryStringParameters);
        }

        private static void GetImageUrl(Ieb.elementImagesImage result, string mediaRelationshipType, Guid mediaId, System.Globalization.CultureInfo culture, string fileUrl)
        {
            switch (mediaRelationshipType)
            {
                case "BoxArt":
                    result.ImagePurpose = Ieb.ImagePurposeType.BoxArt;
                    
                    break;
                case "Background":
                    result.ImagePurpose = Ieb.ImagePurposeType.Background;
                    result.Url = String.Format("http://catalog.zune.net/v3.2/{0}/movie/{1}/xboxBackgroundImage", culture.Name, mediaId);
                    break;
                case "Thumbnail":
                    result.ImagePurpose = Ieb.ImagePurposeType.Thumbnail;
                    result.Url = fileUrl;
                    break;
                default:
                    throw new InvalidOperationException("Invalid mediaRelationshipType" + mediaRelationshipType);
            }
        }

        public static void MapParentalControl(Ieb.elementParentalControl result, IDataReader reader, string descriptors)
        {
            int maxItems = descriptors == null ? 2 : 3;
            result.Items = new object[maxItems];
            result.ItemsElementName = new Ieb.ItemsChoiceType[maxItems];

            result.ItemsElementName[0] = Ieb.ItemsChoiceType.System;
            result.Items[0] = reader.Coalesce<String>("RatingSystem");
            result.ItemsElementName[1] = Ieb.ItemsChoiceType.Rating;
            result.Items[1] = reader.Coalesce<String>("RatingValue");
            if (descriptors != null)
            {
                result.ItemsElementName[2] = Ieb.ItemsChoiceType.Descriptors;
                result.Items[2] = descriptors;
            }
        }

        public static void MapInstance(Ieb.elementVideoInstance result, IDataReader reader)
        {
            string resolutionFormat = reader.Coalesce<string>("VideoDefinition");

            result.Device = IEBDataModel.Model4.DeviceType.Xbox360;
            result.ResolutionFormat = (Ieb.ResolutionFormatType)Enum.Parse(typeof(Ieb.ResolutionFormatType), resolutionFormat, true);
            result.DeliveryFormat = Ieb.DeliveryFormatType.Progressive;
            result.PrimaryAudioLanguage = reader.Coalesce<string>("PrimaryAudioLanguage");
            result.ClosedCaptioning = reader.Coalesce<byte>("audioCC") == 1 ? "True" : "False";
        }

        public static void MapAvailability(Ieb.elementAvailabilitiesAvailability result, IDataReader reader)
        {
            var price = reader.Coalesce<decimal>("price");
            string currencyCode = reader.Coalesce<string>("priceCurrencyCode");
            result.EndDateTime = null;
            result.OfferType = MapOfferType(reader.Coalesce<string>("offerType"));
            result.PriceDisplayString = currencyCode + price;
            result.StartDateTime = reader.Coalesce<DateTime>("startDateTime").ToString(DateTimeFormat); ;
            result.EndDateTime = reader.Coalesce<DateTime>("endDateTime").ToString(DateTimeFormat); ;
        }

        private static Ieb.OfferType MapOfferType(string offerType)
        {
            switch (offerType)
            {
                case "AdSupported":
                    return Ieb.OfferType.FreeWithAds;
                case "Preview":
                    return Ieb.OfferType.Free;
                case "Purchase":
                    return Ieb.OfferType.PurchaseToOwn;
                case "PurchaseStream":
                    return Ieb.OfferType.PurchaseToOwn;
                case "Rent":
                    return Ieb.OfferType.Rent;
                case "RentStream":
                    return Ieb.OfferType.Rent;
                case "SeasonPurchase":
                    return Ieb.OfferType.PurchaseToOwn;
                case "SeasonPurchaseStream":
                    return Ieb.OfferType.PurchaseToOwn;
                case "Stream":
                    return Ieb.OfferType.Free;
                case "Subscription":
                    return Ieb.OfferType.FreeWithSubscription;
                case "SubscriptionFree":
                    return Ieb.OfferType.FreeWithSubscription;
                case "Trial":
                    return Ieb.OfferType.Free;
                default:
                    throw new ArgumentException("Unrecognized License right " + offerType);
            }

        }

        public static void MapFile(Ieb.elementFilesFile result, IDataReader reader)
        {
            result.Url = reader.Coalesce<string>("fileUrl");
            result.Size = reader.Coalesce<Int64>("size").ToString();
            result.SequenceNumber = null;
        }

        public static void MapActor(Ieb.elementActorsActor result, IDataReader reader)
        {
            result.Name = reader.Coalesce<string>("displayName");
        }
        public static void MapContributor(Ieb.elementNames result, IDataReader reader)
        {
            result.Name = reader.Coalesce<string>("displayName");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\ManagerFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace CatalogWatcherTests_Video.Managers
{
    public static class ManagerFactory
    {
        public static CronManager CreateCronManager()
        {
            CronManager result = new CronManager();
            result.AssemblyName = "CatalogWatcherPlugin.dll";
            result.ClassName = "xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper";
            result.CronNamePrefix = "CatalogWatcher";
            result.ResourceName = "Video";
            result.DestinationName = "Azure";

            result.IntervalTime = 120;
            result.WatcherMachineName = Settings.CronMachineName;
            result.HealthCheckUrl = String.Format(ConfigurationManager.AppSettings["HealthCheckUrlFormat"], result.WatcherMachineName);
            return result;
        }

        public static IebVideoPublisherManager CreatePublisherManager()
        {
            if (Settings.catalogwatcher_azure_connection_string.Equals("UseDevelopmentStorage=true", StringComparison.OrdinalIgnoreCase))
            {
                return CreateDeveloperStoragePublisherManager();
            }
            else
            {
                return CreateAzurePublisherManager();
            }
            
        }

        private static IebVideoPublisherManager CreateAzurePublisherManager()
        {
            string accountName = "emdstorage";
            String containerName = Settings.catalogwatcher_azure_storage_container;
            string connectionString = Settings.catalogwatcher_azure_connection_string;
            PublisherDal dal = new IebAzureStorageDal(accountName, containerName, connectionString);
            IebVideoPublisherManager result = new IebVideoPublisherManager(dal);
            return result;
        }

        private static IebVideoPublisherManager CreateDeveloperStoragePublisherManager()
        {

            String accountName = "devstoreaccount1";
            String containerName = Settings.catalogwatcher_azure_storage_container;
            String serverName = Settings.DeveloperStorageServerName;
            String databaseName = Settings.DeveloperStorageDatabaseName;
            
            PublisherDal dal = new IebAzureDeveloperStorageDal(accountName, containerName, serverName, databaseName);
            IebVideoPublisherManager result = new IebVideoPublisherManager(dal);
            return result;
        }

        public static IebVideoProducerManager CreateProducerManager(bool fullFeed)
        {
            IebVideoProducerManager result = new IebVideoProducerManager(fullFeed);
            return result;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\ProducerDal.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.sql.sqlclient;
using xonline.common.config;
using System.Data.SqlClient;
using System.Data;
using Ieb = IEBDataModel.Model4;
using System.Collections.ObjectModel;

namespace CatalogWatcherTests_Video.Managers
{
    public abstract class ProducerDal
    {
        protected IVirtualInterfaceInfo InterfaceInformation { get; private set; }
        public ProducerDal(IVirtualInterfaceInfo interfaceInformation)
        {
            this.InterfaceInformation = interfaceInformation;
        }

        /// <summary>
        /// Enable the sql job to transfer data from CT tables to Todo tables
        /// </summary>
        public abstract void EnableTransferJob();

        /// <summary>
        /// Disable the sql job to transfer data from CT tables to Todo tables
        /// </summary>
        public abstract void DisableTransferJob();
        
        /// <summary>
        /// Runs the sql job to transfer data from CT tables to Todo tables
        /// </summary>
        public abstract void RunTransferJob();

        /// <summary>
        /// Set the sql agent job state
        /// </summary>
        /// <param name="jobName">The name of the job</param>
        /// <param name="enabled">The new state of the job</param>
        /// <returns>true if successful</returns>
        protected void UpdateSqlAgentJob(string jobName, bool enabled)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"EXEC msdb.dbo.sp_update_job @job_name, @enabled";
                int enabledValue = (enabled) ? 1 : 0;

                sqlClient.AddParameter("@job_name", jobName);
                sqlClient.AddParameter("@enabled", enabledValue);
                sqlClient.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Query string to enable the CDC transfer job
        /// </summary>
        /// <returns>true if successful</returns>
        protected void RunSqlAgentJob(string jobName)
        {
            using (SqlClient sqlClient = new SqlClient(this.InterfaceInformation))
            {
                sqlClient.Command.CommandType = System.Data.CommandType.Text;
                sqlClient.Command.CommandText = @"EXEC msdb.dbo.sp_start_job @job_name";

                sqlClient.AddParameter("@job_name", jobName);
               
                sqlClient.ExecuteNonQuery();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\Managers\PublisherDal.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.IO.Compression;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace CatalogWatcherTests_Video.Managers
{

    public abstract class PublisherDal
    {
        public string AccountName { get; private set; }

        public string ContainerName { get; private set; }

        public PublisherDal(string accountName, string containerName)
        {
            this.AccountName = accountName;
            this.ContainerName = containerName;
        }

        public abstract string GetBlob(string blobName);
        public abstract Collection<PublisherFile> GetBlobList();
        public abstract void DeleteBlobs();
        public abstract void WriteXmlToDisk(string blobName, string destinationFilePath);
        public abstract void WriteBlobToDisk(string blobName, string destinationFilePath);

        protected static void WriteXmlToDisk(IDataReader reader, string destinationFilePath)
        {
            FileInfo destinationFileInfo = new FileInfo(destinationFilePath);
            destinationFileInfo.Directory.Create();
           
            byte[] buffer;
            using (MemoryStream mStream = new MemoryStream())
            using (GZipStream gzStream = new GZipStream(mStream, CompressionMode.Decompress))
            using (Stream writer = new FileStream(destinationFilePath, FileMode.Create, FileAccess.Write))
            {
                while (reader.Read())
                {
                    buffer = reader.Coalesce<Byte[]>("Data");
                    mStream.Write(buffer, 0, buffer.Length);
                    mStream.Position = 0;
                    CopyStream(gzStream, writer);
                    mStream.Position = 0;
                }
            }
        }

        protected static void WriteBlobToDisk(IDataReader reader, string destinationFilePath)
        {
            FileInfo destinationFileInfo = new FileInfo(destinationFilePath);
            destinationFileInfo.Directory.Create();

            byte[] buffer;
            using (MemoryStream mStream = new MemoryStream())
            using (Stream writer = new FileStream(destinationFilePath, FileMode.Create, FileAccess.Write))
            {
                while (reader.Read())
                {
                    buffer = reader.Coalesce<Byte[]>("Data");
                    mStream.Write(buffer, 0, buffer.Length);
                    mStream.Position = 0;
                    CopyStream(mStream, writer);
                    mStream.Position = 0;
                }
            }
        }

        protected static string ConvertToXmlString(IDataReader reader)
        {
            byte[] buffer;

            using (MemoryStream mStream = new MemoryStream())
            using (GZipStream gzStream = new GZipStream(mStream, CompressionMode.Decompress))
            using (StreamReader sReader = new StreamReader(gzStream))
            {
                while (reader.Read())
                {
                    buffer = reader.Coalesce<Byte[]>("Data");
                    mStream.Write(buffer, 0, buffer.Length);
                    mStream.Position = 0;
                }
                return sReader.ReadToEnd();
            }
        }

        protected static string ConvertToXmlString(Stream data)
        {
            using (GZipStream gzStream = new GZipStream(data, CompressionMode.Decompress))
            using (StreamReader reader = new StreamReader(gzStream))
            {
                return reader.ReadToEnd();
            }
        }

        protected static void WriteXmlToDisk(Stream data, string destinationFilePath)
        {
            using (GZipStream gzStream = new GZipStream(data, CompressionMode.Decompress))
            using (Stream writer = new FileStream(destinationFilePath, FileMode.Create, FileAccess.Write))
            {
                CopyStream(gzStream, writer);
            }
        }

        protected static void WriteBlobToDisk(Stream data, string destinationFilePath)
        {
            using (Stream writer = new FileStream(destinationFilePath, FileMode.Create, FileAccess.Write))
            {
                CopyStream(data, writer);
            }
        }
        
        public static void CopyStream(Stream input, Stream output)
        {
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            while (true)
            {
                int read = input.Read(buffer, 0, buffer.Length);
                if (read <= 0)
                {
                    return;
                }
                output.Write(buffer, 0, read);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\VideoProducer\FeedTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Ieb = IEBDataModel.Model4;
using System.Xml.Serialization;
using System.IO;
using System.Collections.ObjectModel;
using System.Text.RegularExpressions;
using System.Globalization;
using CatalogWatcherTests_Video.Managers;
using System.IO.Compression;

namespace CatalogWatcherTests_Video.VideoProducer
{
    /// <summary>
    /// This class is for manual testing only
    /// </summary>
    [TestClass]
    [DeploymentItem(@".\Data\CatalogWatcherTests-Video\", @".\Data\CatalogWatcherTests-Video\")]
    [DeploymentItem(@".\Data\CatalogWatcherTests-Video\IEBBingFeed.xsd", @".")]
    [DeploymentItem(@".\Data\", @".\Data\CatalogWatcherTests-Video\")]
    [DeploymentItem(@".\Data\IEBBingFeed.xsd", @".")]
    [DeploymentItem(@".\CommonConfig.xml", @".")]
    public class FeedTest : BaseVideoProducerTest
    {
        private const string destinationFolder = @"E:\IEBDataModel\INT\4.0\";
        private const string feedPath = destinationFolder + "CA1.ZuneVideo.2011-08-11.05-52-54.full.Lakeview_v0_4.gz.xml";
        //private string feedPath = @"E:\IEBDataModel\4.6\CA1.ZuneVideo.2011-07-28.18-11-07.full.Lakeview_v0_4.gz.xml";

        
        public FeedTest()
        {
        }

        //[TestMethod]
        public void Clean()
        {
            CronManager.SetupJobs(1);
            DeltaProducerManager.ClearDocuments();
            PublisherManager.ClearDocuments();
        }

        //[TestMethod]
        public void ValidateSingleFileAgainstXsd()
        {
            ValidateFileAgainstXsd(feedPath);
            ParseDocument(feedPath);
            CountDocument(feedPath);
        }

        //[TestMethod]
        public void CountItem()
        {
            Ieb.Feed feed = DeserializeFromFile<Ieb.Feed>(feedPath);
            int total = feed.Items.Count( x => (x as Ieb.elementMovie == null) ? false : ((Ieb.elementMovie)x).ApplicationSpecificData.Contains("MovieTrailer"));
            Assert.AreEqual(0, total, "Expect no movie trailers");
        }


        //[TestMethod]
        public void ValidateSingleFileCountDocument()
        {
            CountDocument(feedPath);
        }

        //[TestMethod]
        public void DownloadFromAzureStorage()
        {
            Directory.CreateDirectory(destinationFolder);
            var blobList = PublisherManager.Dal.GetBlobList();
            foreach (var blob in blobList)
            {
                Console.WriteLine("{0},{1},", blob.BlobName, blob.LastModificationTime);
                string filepath = destinationFolder + ParseFileNameFromBlobName(blob.BlobName);

                PublisherManager.Dal.WriteBlobToDisk(blob.BlobName, filepath);
                if (filepath.EndsWith(".gz"))
                    PublisherManager.Dal.WriteXmlToDisk(blob.BlobName, filepath + ".xml");
            }
        }

        //[TestMethod]
        public void ConvertZipToXml()
        {
            var fileList = Directory.GetFiles(destinationFolder);
            fileList = fileList.Where(x => x.EndsWith(".gz") && !x.Contains("END")).ToArray();

            foreach (string file in fileList)
            {
                string fileXmlName = String.Format("{0}.xml", file);

                using (Stream reader = new FileStream(file, FileMode.Open, FileAccess.Read))
                using (GZipStream gzStream = new GZipStream(reader, CompressionMode.Decompress))
                using (Stream writer = new FileStream(fileXmlName, FileMode.Create, FileAccess.Write))
                {
                    PublisherDal.CopyStream(gzStream, writer);
                }
            }
        }

        private static string ParseFileNameFromBlobName(string blobName)
        {
            int indexOfSlash = blobName.LastIndexOf("/");
            if (indexOfSlash < 0) return blobName;

            return blobName.Substring(indexOfSlash + 1);
        }

        //[TestMethod]
        public void ValidateMultiFeed()
        {
            var blobList = PublisherManager.Dal.GetBlobList();
            foreach (var blob in blobList)
            {
                Console.WriteLine("{0},{1},", blob.BlobName, blob.LastModificationTime);
                string filepath = destinationFolder + ParseFileNameFromBlobName(blob.BlobName);

                PublisherManager.Dal.WriteBlobToDisk(blob.BlobName, filepath);
                if (filepath.EndsWith(".gz"))
                    PublisherManager.Dal.WriteXmlToDisk(blob.BlobName, filepath + ".xml");
            }

            var fileList = Directory.GetFiles(destinationFolder);
            fileList = fileList.Where(x => x.EndsWith(".xml") && !x.Contains("END")).ToArray();
            foreach (string file in fileList)
            {
                Console.WriteLine("ValidateFileAgainstXsd {0}", file);
                ValidateFileAgainstXsd(file);
            }

            foreach (string file in fileList)
            {
                Console.WriteLine("ParseDocument {0}", file);
                ParseDocument(file);
            }

            CountDocument(fileList);
        }

        //[TestMethod]
        public void CombineMultipleBlobs()
        {
            String destinationZipFolder = destinationFolder + @"Output\";
            Directory.CreateDirectory(destinationZipFolder);

            var fileList = Directory.GetFiles(destinationFolder);
            fileList = fileList.Where(x => x.EndsWith(".xml") && !x.Contains("END")).ToArray();
            var feed = CombineDocumentsFromFiles(fileList);
            string combinedfileName = String.Format("{0}ZuneMicrosoft.V04.full.{1}.xml", destinationZipFolder, DateTime.UtcNow.ToString("yyyy-MM-dd.HH-mm-ss"));

            using (Stream stream = new FileStream(combinedfileName, FileMode.Create, FileAccess.Write))
            {
                SerializeFeed(stream, feed);
            }

            string combinedZipFileName = String.Format("{0}ZuneMicrosoft.V04.full.{1}.gz", destinationZipFolder, DateTime.UtcNow.ToString("yyyy-MM-dd.HH-mm-ss"));
            using (Stream stream = new FileStream(combinedZipFileName, FileMode.Create, FileAccess.Write))
            using (GZipStream gzStream = new GZipStream(stream, CompressionMode.Compress))
            {
                SerializeFeed(gzStream, feed);
            }
        }

        private static void CountDocument(string filePath)
        {
            Console.WriteLine(filePath);
            Ieb.Feed feed = DeserializeFromFile<Ieb.Feed>(filePath);
            CountDocument(feed);
        }

        private static void CountDocument(string[] fileList)
        {
            CountDocument(CombineDocumentsFromFiles(fileList));
        }

        private static Ieb.Feed CombineDocumentsFromFiles(string[] fileList)
        {
            Ieb.Feed combined = new Ieb.Feed();
            Collection<Ieb.elementProduct> combinedProduct = new Collection<Ieb.elementProduct>();
            foreach (string file in fileList)
            {
                Ieb.Feed singleFeed = DeserializeFromFile<Ieb.Feed>(file);
                if (singleFeed.Items != null)
                    combinedProduct.AddRange(singleFeed.Items);
            }
            combined.Items = combinedProduct.ToArray();
            return combined;
        }

        private static void CountDocument(Ieb.Feed feed)
        {
            int productTotal = feed.Items.Count();
            Console.WriteLine("Total Products:\t" + productTotal);

            Console.WriteLine("Product types");
            var typeGroup = from p in feed.Items
                            group p by p.GetType() into g
                            select new { ProductType = g.Key, Total = g.Count() };

            foreach (var g in typeGroup)
            {
                Console.WriteLine("  Total {0}:\t{1}", g.ProductType, g.Total);
            }

            var parentalControlGroup0 = from p in feed.Items
                                        where p.ParentalControl.Items.Length > 0
                                        group p by new { lcid = IebXsdValidator.ParseLocale(p.ItemId), Item0 = p.ParentalControl.Items[0], Item1 = (p.ParentalControl.Items.Length > 1) ? p.ParentalControl.Items[1] : "" } into g
                                        orderby g.Key.Item0
                                        select new { ParentalControlItem0 = g.Key, Total = g.Count() };
            foreach (var g in parentalControlGroup0)
            {
                Console.WriteLine("  Total {0}:\t{1}", g.ParentalControlItem0, g.Total);
            }


            int showTitleExistsTotal = feed.Items.Count(i => !String.IsNullOrEmpty(i.Title));
            Console.WriteLine("Title exists:\t" + showTitleExistsTotal);

            int parentalControlFilledExistsTotal = feed.Items.Count(i => i.ParentalControl != null && i.ParentalControl.ItemsElementName != null);
            Console.WriteLine("ParentalControl exists:\t" + parentalControlFilledExistsTotal);

            int boxArtFilledExistsTotal = feed.Items.Count(i => i.Images != null && i.Images.Where(j => j.ImagePurpose == Ieb.ImagePurposeType.BoxArt && !String.IsNullOrEmpty(j.Url)).Count() > 0);
            Console.WriteLine("boxArt exists:\t" + boxArtFilledExistsTotal);

            int backgroundImageTooMany = feed.Items.Count(i => i.Images != null && i.Images.Where(j => j.ImagePurpose == Ieb.ImagePurposeType.Background).Count() > 1);
            Console.WriteLine("background image too many:\t" + backgroundImageTooMany);

            int instancesExistsTotal = feed.Items.Count(i => i.Instances != null && i.Instances.Items != null && i.Instances.Items.Count() > 0);
            Console.WriteLine("Instances exists:\t" + instancesExistsTotal);

            int totalInstances = feed.Items.Sum(i => (i.Instances == null || i.Instances.Items == null) ? 0 : i.Instances.Items.Count());
            Console.WriteLine("Total instances:\t" + totalInstances);

            int availabilityExistsTotal = feed.Items.Sum(i =>
            {
                if (i.Instances == null || i.Instances.Items == null) return 0;

                return i.Instances.Items.Count(j => (j.Availabilities != null) && (j.Availabilities.Count() > 0));
            });

            Console.WriteLine("Availabilities for each instance exists:\t" + availabilityExistsTotal);

            int totalAvailability = feed.Items.Sum(i =>
            {
                if (i.Instances == null || i.Instances.Items == null) return 0;

                return i.Instances.Items.Sum(j => (j.Availabilities == null) ? 0 : j.Availabilities.Count());
            });

            Console.WriteLine("Total Availabilities for each instance:\t" + totalAvailability);

            int fileExistsTotal = feed.Items.Sum(i =>
            {
                if (i.Instances == null || i.Instances.Items == null) return 0;

                return i.Instances.Items.Count(j => (j.Files != null) && (j.Files.Count() > 0));
            });

            Console.WriteLine("Files for each instance exists:\t" + fileExistsTotal);

            int totalFiles = feed.Items.Sum(i =>
            {
                if (i.Instances == null || i.Instances.Items == null) return 0;

                return i.Instances.Items.Sum(j => (j.Files == null) ? 0 : j.Files.Count());
            });

            var allTVSeries = from p in feed.Items
                              where p.ItemId.Contains("TVSeries")
                              select p.ItemId;

            var allTVSeason = from p in feed.Items
                              where p.ItemId.Contains("TVSeason")
                              select new { Item = p.ItemId, Link = ((Ieb.elementTVSeason)p).SeriesId };

            var allTVEpisodes = from p in feed.Items
                                where p.ItemId.Contains("TVEpisode") && (((Ieb.elementTVEpisode)p).Items != null) && (((Ieb.elementTVEpisode)p).Items.Length > 1)
                                select new { Item = p.ItemId, Link = ((Ieb.elementTVEpisode)p).Items[1], Link2 = ((Ieb.elementTVEpisode)p).Items[0] };


            //TVEpisodes linked to valid TVSeason
            Collection<string> temp = new Collection<string>();
            foreach (var t in allTVSeason)
                temp.Add(t.Item);
            string[] allTVSeasonItemId = temp.ToArray();
            Array.Sort(allTVSeasonItemId);
            int episodesWithValidLink = allTVEpisodes.Count(x => Array.BinarySearch(allTVSeasonItemId, x.Link) > 0);
            Console.WriteLine("TV Episodes linked to valid TVSeason {0} of {1} ", episodesWithValidLink, allTVEpisodes.Count());

            //TVSeason linked to valid TVSeries
            string[] allTVSeriesItemId = allTVSeries.ToArray();
            Array.Sort(allTVSeriesItemId);
            int seasonWithValidLink = allTVSeason.Count(x => Array.BinarySearch(allTVSeriesItemId, x.Link) > 0);
            Console.WriteLine("TVSeason linked to valid TVSeries {0} of {1} ", seasonWithValidLink, allTVSeason.Count());

            //TVSeries with a TVSeason or TVEpisode linked to it
            temp = new Collection<string>();
            foreach (var t in allTVSeason)
                temp.Add(t.Link);
            foreach (var t in allTVEpisodes)
                temp.Add(t.Link2);
            string[] allTVSeriesLink = temp.ToArray();
            Array.Sort(allTVSeriesLink);
            int seriesWithSeasonOrEpisode = allTVSeries.Count(x => Array.BinarySearch(allTVSeriesLink, x) > 0);
            Console.WriteLine("TVSeries with a TVSeason or TVEpisode linked to it {0} of {1} ", seriesWithSeasonOrEpisode, allTVSeries.Count());

            //TVSeason with a TVEpisode linked to it
            temp = new Collection<string>();
            foreach (var t in allTVEpisodes)
                temp.Add(t.Link);
            string[] allTVEpisodesLink = temp.ToArray();
            Array.Sort(allTVEpisodesLink);
            int seasonsWithEpisode = allTVSeason.Count(x => Array.BinarySearch(allTVEpisodesLink, x.Item) > 0);
            Console.WriteLine("TVSeason with a TVEpisode linked to it {0} of {1} ", seasonsWithEpisode, allTVSeason.Count());


            int tvEpisodesWithStudio = feed.Items.Count(i =>
            {
                return (i.ItemId.Contains("TVEpisode")
                    && ((Ieb.elementTVEpisode)i).Studios != null
                    && ((Ieb.elementTVEpisode)i).Studios.Studio.Count() > 0
                    );
            });

            Console.WriteLine("TVEpisodes with studio {0} of {1} ", tvEpisodesWithStudio, allTVEpisodes.Count());

        }

        private static void ParseDocument(string filePath)
        {
            Ieb.Feed feed = DeserializeFromFile<Ieb.Feed>(filePath);
            CheckForErrors(IebXsdValidator.StaticElementValidation(feed, true), "Error with feed");
        }

        private void ValidateFileAgainstXsd(string filePath)
        {
            var allErrors = this.VideoXsdValidator.FindDistinctErrorsFromFile(filePath);
            foreach (var error in allErrors)
            {
                Console.WriteLine(error);
            }

            if (allErrors.Count > 0)
            {
                Assert.Fail(allErrors.Count + " xsd validation errors detected");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\VideoProducer\EndToEndTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using CatalogWatcherTests_Video.Managers;
using System.Collections.ObjectModel;
using Ieb = IEBDataModel.Model4;

namespace CatalogWatcherTests_Video.VideoProducer
{
    /// <summary>
    /// Summary description for EndToEndTests
    /// </summary>
    [TestClass]
    [DeploymentItem(@".\Data\CatalogWatcherTests-Video\", @".\Data\CatalogWatcherTests-Video\")]
    [DeploymentItem(@".\Data\CatalogWatcherTests-Video\IEBBingFeed.xsd", @".")]
    [DeploymentItem(@".\CommonConfig.xml", @".")]
    public class EndToEndTests : BaseVideoProducerTest
    {
        public EndToEndTests()
        {
        }
        [TestInitialize]
        public void TestInitialize()
        {
            CronManager.SetupJobs(1);
            DeltaProducerManager.ClearDocuments();
            PublisherManager.ClearDocuments();
        }

        [TestMethod]
        public void RunSingleDeltaDocument()
        {
            RunSingleDocument(this.DeltaProducerManager);
        }

        [TestMethod]
        public void RunMultipleDeltaDocument()
        {
            RunMultipleDocument(this.DeltaProducerManager);
        }

        [TestMethod]
        public void RunSingleFullDocument()
        {
            RunSingleDocument(this.FullProducerManager);
        }

        [TestMethod]
        public void RunMultipleFullFullDocument()
        {
            RunMultipleDocument(this.FullProducerManager);
        }


        public void RunSingleDocument(IebVideoProducerManager producerManager)
        {
            Guid expectedMediaId = new Guid("EEAA1467-1151-45F0-A6B2-000CAEC2368A");
            int expectedLcid = 1033;

            producerManager.AddDocuments(expectedMediaId, expectedLcid);

            CronManager.Start();
            Collection<PublisherFile> documentList = WaitForDocuments();
            Assert.AreEqual(1, documentList.Count, "Incorrect number of documents returned");
            Console.WriteLine("Found document " + documentList[0].BlobName);
            string feedString = (string)PublisherManager.GetDocument(documentList[0].BlobName);
            var feed = CreateMiniFeed(feedString);
            Assert.AreEqual(1, feed.Items.Length, "products returned error");
        }

        public void RunMultipleDocument(IebVideoProducerManager producerManager)
        {
            var videoList = defaultMediaList;
            foreach (var entry in videoList)
            {
                Console.WriteLine("Adding entries for ({0},{1})", entry.mediaId, entry.lcid);
                producerManager.AddDocuments(entry.mediaId, entry.lcid);
            }
            CronManager.Start();
            Collection<PublisherFile> documentList = WaitForDocuments();
            Assert.AreEqual(1, documentList.Count, "documents returned error");
            Console.WriteLine("Found document " + documentList[0].BlobName);
            string feedString = (string)PublisherManager.GetDocument(documentList[0].BlobName);
            var feed = CreateMiniFeed(feedString);
            Assert.AreEqual(defaultMediaList.Count, feed.Items.Length, "products returned error");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\VideoProducer\BaseVideoProducerTest.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Xml;
using System.Linq;
using System.Xml.Serialization;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Ieb = IEBDataModel.Model4;
using CatalogWatcherTests_Video.Managers;
using System.Xml.Schema;

namespace CatalogWatcherTests_Video.VideoProducer
{
    public class BaseVideoProducerTest
    {
        //file containing valid media and lcid for video producer to use
        private string mediaListFile = @".\Data\CatalogWatcherTests-Video\RandomMediaList.csv";

        

        /// <summary>
        /// List containing valid media and lcid for video producer to use
        /// </summary>
        protected Collection<VideoProductEntry> defaultMediaList;

        public enum ProductType
        {
            Unknown,
            Movie,
            MovieTrailer,
            TVEpisode,
            TVSeason,
            TVSeries,
            
        }

        public class VideoProductEntry
        {
            public Guid mediaId;

            public int lcid;

            public ProductType type;

            public override string ToString()
            {
                return string.Format("({0},{1},{2})", mediaId, lcid, type);
            }
        }

        protected CronManager CronManager { get; set; }

        protected IebVideoPublisherManager PublisherManager { get; set; }

        protected IebVideoProducerManager DeltaProducerManager { get; set; }

        protected IebVideoProducerManager FullProducerManager { get; set; }

        protected XsdValidator VideoXsdValidator { get; set; }

        public BaseVideoProducerTest()
        {
            this.CronManager = ManagerFactory.CreateCronManager();
            this.PublisherManager = ManagerFactory.CreatePublisherManager();
            this.DeltaProducerManager = ManagerFactory.CreateProducerManager(false);
            this.FullProducerManager = ManagerFactory.CreateProducerManager(true);
            LoadMediaList();

            var xsdSchemaSet = new XmlSchemaSet();
            xsdSchemaSet.Add("http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion", "IEBBingFeed.xsd");
            this.VideoXsdValidator = new XsdValidator(xsdSchemaSet);
        }

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext { get; set; }

        protected static void CheckForErrors(Collection<string> allErrors, string message)
        {
            foreach (var error in allErrors)
            {
                Console.WriteLine("Error:" + error);
            }

            if (allErrors.Count == 1)
            {
                Assert.Fail(message + "." + allErrors[0]);
            }
            else if (allErrors.Count > 0)
            {
                Assert.Fail(message + "." + allErrors.Count + " errors detected");
            }
        }

        protected static void AreEqual(Ieb.elementProduct expected, Ieb.elementProduct actual, string message, bool recurse)
        {
            AreEqual(expected, actual, message);
            if (!recurse)
            {
                return;
            }

            AreEqual(expected.Images, actual.Images, message + @"\Images");
            AreEqual(expected.ParentalControl, actual.ParentalControl, message + @"\ParentalControl");
            AreEqual(expected.Instances, actual.Instances, message + @"\Instances");
        }

        protected static void AreEqual(Ieb.elementProduct expected, Ieb.elementProduct actual, string message)
        {
            AreEqualNullCheck<Ieb.elementProduct>(expected, actual, message);

            Assert.AreEqual(expected.ItemId, actual.ItemId, "On CanonicalId." + message);
            Assert.AreEqual(expected.Title, actual.Title, "On Title." + message);
            Assert.AreEqual(expected.TitlePronunciation, actual.TitlePronunciation, "On TitlePronunciation." + message);
            Assert.AreEqual(expected.SortTitle, actual.SortTitle, "On SortTitle." + message);
            Assert.AreEqual(expected.Description, actual.Description, "On Description." + message);
            Assert.AreEqual(expected.ShortDescription, actual.ShortDescription, "On ShortDescription." + message);
            AreEqualUnorderedList(expected.AlternateTitles, actual.AlternateTitles, "On AlternateTitles." + message);
            Assert.AreEqual(expected.OriginalPublicationRegion, actual.OriginalPublicationRegion, "On OriginalPublicationRegion." + message);
            AreEqual<string>(expected.AlternateIds, actual.AlternateIds, "On AlternateIds." + message);
            AreEqual<string>(expected.Keywords, actual.Keywords, "On Keywords." + message);
            Assert.AreEqual(expected.IsUserGenerated, actual.IsUserGenerated, "On IsUserGenerated." + message);
            Assert.AreEqual(expected.LastModifiedDate, actual.LastModifiedDate, "On LastModifiedDate." + message);
            AreEqual<string>(expected.Genres, actual.Genres, "On Genres." + message);
            AreEqual<string>(expected.AlternateIds, actual.AlternateIds, "On AlternateIds." + message);

        }

        protected static void AreMovieEqual(Ieb.elementMovie expected, Ieb.elementMovie actual, string message, bool recurse)
        {
            AreEqual(expected, actual, message);
            if (!recurse)
            {
                return;
            }

            AreEqual(expected.Directors, actual.Directors, message + @"\Directors");
            AreEqual(expected.Actors, actual.Actors, message + @"\Actors");
            AreEqual(expected.Writers, actual.Writers, message + @"\ParentalControl");
        }

        protected static void AreMovieEqual(Ieb.elementMovie expected, Ieb.elementMovie actual, string message)
        {
            AreEqualNullCheck<Ieb.elementMovie>(expected, actual, message);
            Assert.AreEqual(expected.ApplicationSpecificData, actual.ApplicationSpecificData, "On ApplicationSpecificData." + message);
            Assert.AreEqual(expected.OriginalPublicationDate, actual.OriginalPublicationDate, "On OriginalPublicationDate." + message);
            Assert.AreEqual(expected.DurationInSeconds, actual.DurationInSeconds, "On ApplicationSpecificData." + message);
            AreEqual(expected.Studios, actual.Studios, message + @"\Studio");
        }

        protected static void AreTvEpisodeEqual(Ieb.elementTVEpisode expected, Ieb.elementTVEpisode actual, string message, bool recurse)
        {
            AreEqual(expected, actual, message);
            if (!recurse)
            {
                return;
            }
            AreEqual(expected.Directors, actual.Directors, message + @"\Directors");
            AreEqual(expected.Actors, actual.Actors, message + @"\Actors");
            AreEqual(expected.Writers, actual.Writers, message + @"\ParentalControl");
        }

        protected static void AreTvEpisodeEqual(Ieb.elementTVEpisode expected, Ieb.elementTVEpisode actual, string message)
        {
            AreEqualNullCheck<Ieb.elementTVEpisode>(expected, actual, message);
            Assert.AreEqual(expected.ApplicationSpecificData, actual.ApplicationSpecificData, "On ApplicationSpecificData." + message);
            Assert.AreEqual(expected.OriginalPublicationDate, actual.OriginalPublicationDate, "On OriginalPublicationDate." + message);
            Assert.AreEqual(expected.DurationInSeconds, actual.DurationInSeconds, "On ApplicationSpecificData." + message);
            Assert.AreEqual(expected.EpisodeNumber, actual.EpisodeNumber, "On EpisodeNumber." + message);
            Assert.AreEqual(expected.Network, actual.Network, "On Network." + message);

            AreEqual<Ieb.ItemsChoiceType1, string>(expected.ItemsElementName, expected.Items, actual.ItemsElementName, actual.Items, "On Items." + message);
            AreEqual(expected.Studios, actual.Studios, message + @"\Studio");
        }

        protected static void AreTvSeasonEqual(Ieb.elementTVSeason expected, Ieb.elementTVSeason actual, string message, bool recurse)
        {
            AreEqual(expected, actual, message);
            if (!recurse)
            {
                return;
            }

            AreEqual(expected.Studios, actual.Studios, message + @"\Studio");
        }

        protected static void AreTvSeasonEqual(Ieb.elementTVSeason expected, Ieb.elementTVSeason actual, string message)
        {
            AreEqualNullCheck<Ieb.elementTVSeason>(expected, actual, message);

            Assert.AreEqual(expected.OriginalPublicationDate, actual.OriginalPublicationDate, "On OriginalPublicationDate." + message);
            Assert.AreEqual(expected.SeasonNumber, actual.SeasonNumber, "On SeasonNumber." + message);
            Assert.AreEqual(expected.SeriesId, actual.SeriesId, "On SeriesId." + message);
            Assert.AreEqual(expected.Network, actual.Network, "On Network." + message);
            AreEqual(expected.Studios, actual.Studios, message + @"\Studio");
        }

        protected static void AreTvSeriesEqual(Ieb.elementTVSeries expected, Ieb.elementTVSeries actual, string message)
        {
            AreEqualNullCheck<Ieb.elementTVSeries>(expected, actual, message);

            Assert.AreEqual(expected.OriginalPublicationDate, actual.OriginalPublicationDate, "On OriginalPublicationDate." + message);
            //TASK 57042 - Tweak TotalNumberOfSeasons for Zune feed
            Assert.AreEqual(expected.TotalNumberOfSeasons, actual.TotalNumberOfSeasons, "On TotalNumberOfSeasons." + message);
            Assert.AreEqual(expected.Network, actual.Network, "On Network." + message);
            Assert.AreEqual(expected.EndYear, actual.EndYear, "On EndYear." + message);
            AreEqual(expected.Studios, actual.Studios, message + @"\Studio");
        }

        private static void AreEqual(Ieb.elementStudios expected, Ieb.elementStudios actual, string message)
        {
            AreEqualNullCheck<Ieb.elementStudios>(expected, actual, message);
            AreEqualUnorderedList(expected.Studio, actual.Studio, message);
        }

        protected static bool AreEqualNullCheck<T>(T expected, T actual, string message)
        {
            if (expected == null && actual == null)
            {
                return true;
            }
            else if (expected == null)
            {
                Assert.Fail("Expected value is null: " + message);
            }
            else if (actual == null)
            {
                Assert.Fail("Actual value is not null: " + message);
            }

            return false;
        }

        protected static void AreEqual<T>(T[] expected, T[] actual, string message)
        {
            if (AreEqualNullCheck<T[]>(expected, actual, message))
            {
                return;
            }

            Assert.AreEqual(expected.Length, actual.Length, "Array size different: " + message);
            for (int i = 0; i < expected.Length; i++)
            {
                Assert.AreEqual(expected[i], actual[i], "Difference at element " + i + ": " + message);
            }
        }

        protected static void AreEqual<I, V>(I[] expectedItem, V[] expectedValue, I[] actualItem, V[] actualValue, string message)
        {
            AreEqual<I>(expectedItem, actualItem, message + @"\Item");
            AreEqual<V>(expectedValue, actualValue, message + @"\Value");
        }

        protected static void AreEqual(Ieb.elementActors expected, Ieb.elementActors actual, string message)
        {
            AreEqualNullCheck<Ieb.elementActors>(expected, actual, message);
            AreEqual(expected.Actor, actual.Actor, message);
        }

        protected static void AreEqual(Ieb.elementActorsActor[] expected, Ieb.elementActorsActor[] actual, string message)
        {
            AreEqualNullCheck<Ieb.elementActorsActor[]>(expected, actual, message);
            Assert.AreEqual(expected.Length, actual.Length, "Array size different: " + message);

            //Array.Sort(expected, (left, right) => left.Name.CompareTo(right.Name));

            //Array.Sort(actual, (left, right) => left.Name.CompareTo(right.Name));

            for (int i = 0; i < expected.Length; i++)
            {
                Assert.AreEqual(expected[i].Name, actual[i].Name, "Difference at element " + i + " Name: " + message);
                AreEqual(expected[i].Characters, actual[i].Characters, message + @"\Characters " + expected[i].Name);
            }
        }

        protected static void AreEqual(Ieb.elementCharacters expected, Ieb.elementCharacters actual, string message)
        {
            AreEqualNullCheck<Ieb.elementCharacters>(expected, actual, message);
            AreEqual(expected.Character, actual.Character, message);
        }

        protected static void AreEqual(Ieb.elementDirectors expected, Ieb.elementDirectors actual, string message)
        {
            AreEqualNullCheck<Ieb.elementDirectors>(expected, actual, message);
            AreEqual(expected.Director, actual.Director, message);
        }

        protected static void AreEqual(Ieb.elementWriters expected, Ieb.elementWriters actual, string message)
        {
            AreEqualNullCheck<Ieb.elementWriters>(expected, actual, message);
            AreEqual(expected.Writer, actual.Writer, message);
        }

        protected static void AreEqual(Ieb.elementNames[] expected, Ieb.elementNames[] actual, string message)
        {
            AreEqualNullCheck<Ieb.elementNames[]>(expected, actual, message);
            Assert.AreEqual(expected.Length, actual.Length, "Array size different: " + message);

            Array.Sort(expected, (left, right) => left.Name.CompareTo(right.Name));
            Array.Sort(actual, (left, right) => left.Name.CompareTo(right.Name));
            for (int i = 0; i < expected.Length; i++)
            {
                Assert.AreEqual(expected[i].Name, actual[i].Name, "Difference at element " + i + " Name: " + message);
            }
        }

        protected static void AreEqual(Ieb.elementImagesImage[] expected, Ieb.elementImagesImage[] actual, string message)
        {
            AreEqualNullCheck<Ieb.elementImagesImage[]>(expected, actual, message);
            Assert.AreEqual(expected.Length, actual.Length, "Array size different: " + message);

            Array.Sort(expected, (left, right) => left.Url.CompareTo(right.Url));
            Array.Sort(actual, (left, right) => left.Url.CompareTo(right.Url));
            for (int i = 0; i < expected.Length; i++)
            {
                string index = actual[i].Url;
                Assert.AreEqual(expected[i].Url, actual[i].Url, "Difference at element " + index + " Url: " + message);
                Assert.AreEqual(expected[i].ImagePurpose, actual[i].ImagePurpose, "Difference at element " + index + " Character: " + message);
            }
        }

        protected static void AreEqual(Ieb.elementParentalControl expected, Ieb.elementParentalControl actual, string message)
        {
            AreEqualNullCheck<Ieb.elementParentalControl>(expected, actual, message);
            AreEqual<Ieb.ItemsChoiceType, object>(expected.ItemsElementName, expected.Items, actual.ItemsElementName, actual.Items, message);
        }

        protected static void AreEqual(Ieb.elementInstances expected, Ieb.elementInstances actual, string message)
        {
            AreEqualNullCheck<Ieb.elementInstances>(expected, actual, message);
            AreEqual(expected.Items, actual.Items, message);
        }

        protected static void AreEqual(Ieb.elementVideoInstance[] expected, Ieb.elementVideoInstance[] actual, string message)
        {
            AreEqualNullCheck<Ieb.elementVideoInstance[]>(expected, actual, message);
            Array.Sort(expected, (left, right) => left.Files[0].Url.CompareTo(right.Files[0].Url));
            Array.Sort(actual, (left, right) => left.Files[0].Url.CompareTo(right.Files[0].Url));

            for (int i = 0; i < expected.Length; i++)
            {
                string index = actual[i].Files[0].Url;
                Assert.AreEqual(expected[i].AdvertisementSlots, actual[i].AdvertisementSlots, "Difference at element " + index + " AdvertisementSlots: " + message);
                AreEqual(expected[i].Availabilities, actual[i].Availabilities, index + @"Availabilities\" + message);
                Assert.AreEqual(expected[i].ClosedCaptioning, actual[i].ClosedCaptioning, "Difference at element " + index + " ClosedCaptioning: " + message);
                Assert.AreEqual(expected[i].DeliveryFormat, actual[i].DeliveryFormat, "Difference at element " + index + " DeliveryFormat: " + message);
                Assert.AreEqual(expected[i].Device, actual[i].Device, "Difference at element " + index + " Device: " + message);
                AreEqual(expected[i].Files, actual[i].Files, index + @"Files\" + message);
                Assert.AreEqual(expected[i].PrimaryAudioLanguage, actual[i].PrimaryAudioLanguage, "Difference at element " + index + " PrimaryAudioLanguage: " + message);
                Assert.AreEqual(expected[i].ResolutionFormat, actual[i].ResolutionFormat, "Difference at element " + index + " ResolutionFormat: " + message);
                Assert.AreEqual(expected[i].SubtitleLanguages, actual[i].SubtitleLanguages, "Difference at element " + index + " SubtitleLanguages: " + message);
                Assert.AreEqual(expected[i].VideoInstanceType, actual[i].VideoInstanceType, "Difference at element " + index + " VideoInstanceType: " + message);
            }
        }

        protected static void AreEqual(Ieb.elementAvailabilitiesAvailability[] expected, Ieb.elementAvailabilitiesAvailability[] actual, string message)
        {
            AreEqualNullCheck<Ieb.elementAvailabilitiesAvailability[]>(expected, actual, message);
            Array.Sort(expected, (left, right) => left.StartDateTime.CompareTo(right.StartDateTime));
            Array.Sort(actual, (left, right) => left.StartDateTime.CompareTo(right.StartDateTime));

            for (int i = 0; i < expected.Length; i++)
            {
                string index = actual[i].StartDateTime;
                Assert.AreEqual(expected[i].EndDateTime, actual[i].EndDateTime, "Difference at element " + index + " EndDateTime: " + message);
                Assert.AreEqual(expected[i].OfferType, actual[i].OfferType, "Difference at element " + index + " OfferType: " + message);
                Assert.AreEqual(expected[i].PriceDisplayString, actual[i].PriceDisplayString, "Difference at element " + index + " PriceDisplayString: " + message);
                Assert.AreEqual(expected[i].StartDateTime, actual[i].StartDateTime, "Difference at element " + index + " StartDateTime: " + message);
            }
        }

        protected static void AreEqual(Ieb.elementFilesFile[] expected, Ieb.elementFilesFile[] actual, string message)
        {
            AreEqualNullCheck<Ieb.elementFilesFile[]>(expected, actual, message);
            Array.Sort(expected, (left, right) => left.Url.CompareTo(right.Url));
            Array.Sort(actual, (left, right) => left.Url.CompareTo(right.Url));

            for (int i = 0; i < expected.Length; i++)
            {
                Assert.AreEqual(expected[i].Url, actual[i].Url, "Difference at element " + i + " Url: " + message);
                Assert.AreEqual(expected[i].Size, actual[i].Size, "Difference at element " + i + " Size: " + message);
                Assert.AreEqual(expected[i].SequenceNumber, actual[i].SequenceNumber, "Difference at element " + i + " SequenceNumber: " + message);
            }
        }

        protected static void AreEqualUnorderedList(object[] expected, object[] actual, string message)
        {
            if (expected == null && actual == null)
            {
                return;
            }
            else if (expected == null)
            {
                Assert.Fail("Actual value is null: " + message);
            }
            else if (actual == null)
            {
                Assert.Fail("Actual value is not null: " + message);
            }
            Assert.AreEqual(expected.Length, actual.Length, "On Length." + message);
            Array.Sort(expected);
            Array.Sort(actual);
            for (int i = 0; i < expected.Length; i++)
            {
                Assert.AreEqual(expected[i], actual[i], "On item[" + i + "]." + message);
            }
        }

        protected static Ieb.elementProduct CreateProductType(string type)
        {
            return CreateProductType((ProductType)Enum.Parse(typeof(ProductType), type, true));
        }

        protected static Ieb.elementProduct CreateProductType(ProductType type)
        {
            switch (type)
            {
                case ProductType.Movie:
                    return new Ieb.elementMovie();
                case ProductType.TVEpisode:
                    return new Ieb.elementTVEpisode();
                case ProductType.TVSeason:
                    return new Ieb.elementTVSeason();
                case ProductType.TVSeries:
                    return new Ieb.elementTVSeries();
                default:
                    throw new ArgumentException("Unrecognized type " + type);
            }
        }


        /// <summary>
        /// Deserializes an object from xml.
        /// </summary>
        /// <typeparam name="T">The type of object to be returned and serialized</typeparam>
        /// <param name="filePath">Location of the xml document</param>
        /// <returns>An object instance of the provided type and string</returns>
        protected static T DeserializeFromFile<T>(string filePath)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(T));
            T obj;
            using (Stream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
            {
                obj = (T)serializer.Deserialize(stream);
            }

            return obj;
        }

        /// <summary>
        /// Deserializes an object from xml.
        /// </summary>
        /// <typeparam name="T">The type of object to be returned and serialized</typeparam>
        /// <param name="text">the xml document</param>
        /// <returns>An object instance of the provided type and string</returns>
        protected static T DeserializeFromText<T>(string text)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(T));
            T obj;
            using (TextReader textReader = new StringReader(text))
            using (XmlReader xmlReader = XmlReader.Create(textReader))
            {
                obj = (T)serializer.Deserialize(xmlReader);
            }

            return obj;
        }

        /// <summary>
        /// Deserializes an object from xml.
        /// </summary>
        /// <typeparam name="T">The type of object to be returned and serialized</typeparam>
        /// <param name="filePath">Location of the xml document</param>
        /// <returns>An object instance of the provided type and string</returns>
        protected static void SerializeFeed(Stream stream, Ieb.Feed feed)
        {
            var settings = new XmlWriterSettings();
            settings.Encoding = System.Text.Encoding.UTF8;
            // settings.Indent = true;
            XmlSerializerNamespaces ns = new XmlSerializerNamespaces();
            ns.Add("e", "http://schemas.microsoft.com/ISS/2011/05/ingestion");

            XmlSerializer serializer = new XmlSerializer(typeof(Ieb.Feed));
            serializer.Serialize(stream, feed, ns);
        }

        protected virtual Collection<PublisherFile> WaitForDocuments()
        {
            Collection<PublisherFile> result = new Collection<PublisherFile>();
            int maxWaitTime = 120;
            int currentWaitTime = 0;

            for (int i = 1; currentWaitTime < maxWaitTime; i++)
            {
                result = this.PublisherManager.GetDocumentList();
                Console.WriteLine("Waited for {0}", currentWaitTime);

                if (result.Count > 0)
                {
                    break;
                }
                currentWaitTime += i;
                System.Threading.Thread.Sleep(1000 * i);
            }

            return result;
        }

        protected virtual Ieb.Feed CreateMiniFeed(string document)
        {
            string fullDocument = document;
            var allErrors = this.VideoXsdValidator.FindDistinctErrors(fullDocument);
            foreach (var error in allErrors)
            {
                Console.WriteLine(error);
            }

            if (allErrors.Count > 0)
            {
                Assert.Fail(allErrors.Count + " xsd validation errors detected");
            }
            Ieb.Feed feed = DeserializeFromText<Ieb.Feed>(fullDocument);
            return feed;
        }


        private void LoadMediaList()
        {
            defaultMediaList = new Collection<VideoProductEntry>();
            using (TextReader reader = new StreamReader(mediaListFile))
            {
                //read header
                string line = reader.ReadLine();
                if (line == null) return;
                line = reader.ReadLine();

                //Read content
                while (!String.IsNullOrEmpty(line))
                {
                    string[] parsedLine = line.Split(',');
                    defaultMediaList.Add(new VideoProductEntry { mediaId = new Guid(parsedLine[0]), lcid = Int32.Parse(parsedLine[1]), type = (ProductType)Enum.Parse(typeof(ProductType), parsedLine[2], true) });
                    line = reader.ReadLine();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\VideoProducer\IebXsdValidator.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Xml;
using System.Xml.Schema;
using Ieb = IEBDataModel.Model4;
using System.Text.RegularExpressions;

namespace CatalogWatcherTests_Video.VideoProducer
{
    public static class IebXsdValidator
    {
        public static readonly string feedPrefixElement = @"<?xml version=""1.0"" encoding=""utf-16""?><Feed xmlns=""http://schemas.microsoft.com/Lakeview/2011/06/13/ingestion"">";
        public static readonly string entryPrefixElement = @"<?xml version=""1.0"" encoding=""utf-16""?>";
        public static readonly string feedSuffixElement = @"</Feed>";

        private static Regex applicationSpecificDataRegEx = new Regex("Details\\?ContentType=(\\w*)&ContentId=([\\w-]*)", RegexOptions.None);
        private static Regex productItemIdRegEx = new Regex(@"http://microsoft.com/(\w\w-\w\w)/\w*/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})", RegexOptions.None);

        private static int maxErrorCount = 10000;

        public static Guid ParseMediaId(string canonicalId)
        {
            Group g = productItemIdRegEx.Match(canonicalId).Groups[2];
            return new Guid(g.Value);
        }

        public static int ParseLcid(string canonicalId)
        {
            string locale = productItemIdRegEx.Match(canonicalId).Groups[1].Value;
            System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo(locale);
            return culture.LCID;
        }

        public static string ParseLocale(string canonicalId)
        {
            string locale = productItemIdRegEx.Match(canonicalId).Groups[1].Value;
            return locale;
        }

        #region StaticElementValidation

        #region Feed Validation
        public static Collection<string> StaticElementValidation(Ieb.Feed feed, bool recurse)
        {
            Collection<string> result = StaticElementValidation(feed);

            if (!recurse || result.Count >= maxErrorCount)
            {
                return result;
            }

            result.AddRange(StaticElementValidation(feed.Items, "Feed/", recurse));
            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.Feed feed)
        {
            Collection<string> result = new Collection<string>();
            if (feed.Items == null)
            {
                result.Add("Feed contains null product");
            }
            else if (feed.Items.Count() == 0)
            {
                result.Add("Feed contains no products");
            }
            return result;
        }
        #endregion Feed Validation

        #region elementProduct[] validation
        public static Collection<string> StaticElementValidation(Ieb.elementProduct[] productList, string elementLocation, bool recurse)
        {
            Collection<string> result = StaticElementValidation(productList, elementLocation);

            if (!recurse || result.Count >= maxErrorCount || productList == null)
            {
                return result;
            }

            //Validate each product element
            for (int i = 0; i < productList.Length && result.Count < maxErrorCount; i++)
            {
                result.AddRange(StaticElementValidation(productList[i], elementLocation + "ProductList[ItemId=" + productList[i].ItemId + "]/", recurse));
            }

            if (result.Count >= 0)
            {
                return result;
            }

            //Check for duplicate entries by product.ItemId
            var itemIdGroupList = from product in productList
                                  group product by product.ItemId into g
                                  select new { Key = g.Key, Count = g.Count() };

            foreach (var itemId in itemIdGroupList.Where(i => i.Count > 1))
            {
                result.Add(itemId.Key + " itemId is duplicated: " + itemId.Count);
            }

            return result;
        }
        public static Collection<string> StaticElementValidation(Ieb.elementProduct[] productList, string elementLocation)
        {
            Collection<string> result = new Collection<string>();
            if (productList == null)
            {
                result.Add(elementLocation + " elementProduct[] is null");
            }
            else if (productList.Count() == 0)
            {
                result.Add(elementLocation + " elementProduct[] has 0 elements");
            }

            if (result.Count >= maxErrorCount)
            {
                return result;
            }

            return result;
        }
        #endregion elementProduct[] validation

        #region elementProduct validation
        public static Collection<string> StaticElementValidation(Ieb.elementProduct product, string elementLocation)
        {
            Collection<string> result = new Collection<string>();
            if (product == null)
            {
                result.Add(elementLocation + " product is null.");
                return result;
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementProduct product, string elementLocation, bool recurse)
        {
            Collection<string> result = StaticElementValidation(product, elementLocation);

            if (!recurse || result.Count >= maxErrorCount)
            {
                return result;
            }

            if (product.GetType().Equals(typeof(Ieb.elementMovie)))
            {
                result.AddRange(StaticElementValidation((Ieb.elementMovie)product, elementLocation, recurse));
                return result;
            }
            else if (product.GetType().Equals(typeof(Ieb.elementTVEpisode)))
            {
                result.AddRange(StaticElementValidation((Ieb.elementTVEpisode)product, elementLocation, recurse));
                return result;
            }
            if (product.GetType().Equals(typeof(Ieb.elementTVSeries)))
            {
                result.AddRange(StaticElementValidation((Ieb.elementTVSeries)product, elementLocation, recurse));
                return result;
            }
            if (product.GetType().Equals(typeof(Ieb.elementTVSeason)))
            {
                result.AddRange(StaticElementValidation((Ieb.elementTVSeason)product, elementLocation, recurse));
                return result;
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementMovie product, string elementLocation)
        {
            Collection<string> result = new Collection<string>();
            if (product == null)
            {
                result.Add(elementLocation + " product is null.");
                return result;
            }

            string error = validateItemWishApplicationSpecificData("Movie", product.ItemId, product.ApplicationSpecificData, elementLocation);
            if (error != null)
            {
                result.Add(error);
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementMovie product, string elementLocation, bool recurse)
        {
            Collection<string> result = StaticElementValidation(product, elementLocation);

            if (!recurse || result.Count >= maxErrorCount)
            {
                return result;
            }

            if (product.Actors != null)
            {
                result.AddRange(StaticElementValidation(product.Actors.Actor, elementLocation + "Actors/", recurse));
            }
            if (product.Directors != null)
            {
                result.AddRange(StaticElementValidation(product.Directors.Director, elementLocation + "Directors/", recurse));
            }
            if (product.Writers != null)
            {
                result.AddRange(StaticElementValidation(product.Writers.Writer, elementLocation + "Writers/", recurse));
            }
            
            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementTVEpisode product, string elementLocation)
        {
            Collection<string> result = new Collection<string>();
            if (product == null)
            {
                result.Add(elementLocation + " product is null.");
                return result;
            }

            string error = validateItemWishApplicationSpecificData("TVEpisode", product.ItemId, product.ApplicationSpecificData, elementLocation);
            if (error != null)
            {
                result.Add(error);
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementTVEpisode product, string elementLocation, bool recurse)
        {
            Collection<string> result = StaticElementValidation(product, elementLocation);

            if (!recurse || result.Count >= maxErrorCount)
            {
                return result;
            }

            if (product.Actors != null)
            {
                result.AddRange(StaticElementValidation(product.Actors.Actor, elementLocation + "Actors/", recurse));
            }
            if (product.Directors != null)
            {
                result.AddRange(StaticElementValidation(product.Directors.Director, elementLocation + "Directors/", recurse));
            }
            if (product.Writers != null)
            {
                result.AddRange(StaticElementValidation(product.Writers.Writer, elementLocation + "Writers/", recurse));
            }
            
            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementTVSeason product, string elementLocation)
        {
            Collection<string> result = new Collection<string>();
            if (product == null)
            {
                result.Add(elementLocation + " product is null.");
                return result;
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementTVSeason product, string elementLocation, bool recurse)
        {
            Collection<string> result = StaticElementValidation(product, elementLocation);

            if (!recurse || result.Count >= maxErrorCount)
            {
                return result;
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementTVSeries product, string elementLocation)
        {
            Collection<string> result = new Collection<string>();
            if (product == null)
            {
                result.Add(elementLocation + " product is null.");
                return result;
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementTVSeries product, string elementLocation, bool recurse)
        {
            Collection<string> result = StaticElementValidation(product, elementLocation);

            if (!recurse || result.Count >= maxErrorCount)
            {
                return result;
            }

            return result;
        }

        private static string validateItemWishApplicationSpecificData(string type, string itemId, string applicationSpecificData, string elementLocation)
        {
            var productItemGroups = productItemIdRegEx.Match(itemId).Groups;
            var applicationSpecificDataGroups = applicationSpecificDataRegEx.Match(applicationSpecificData).Groups;
            if (productItemGroups.Count != 3)
            {
                return elementLocation + " product.ItemId is invalid: " + itemId;
            }
            else if (applicationSpecificDataGroups.Count != 3)
            {
                return elementLocation + " product.ApplicationSpecificData is invalid: " + applicationSpecificData;
            }
            else if (productItemGroups[2].Value != applicationSpecificDataGroups[2].Value)
            {
                return elementLocation + " product.ApplicationSpecificData has bad mediaId: " + applicationSpecificData + itemId;
            }
            else if (!type.Equals(applicationSpecificDataGroups[1].Value, StringComparison.OrdinalIgnoreCase))
            {
                if (type.Equals("Movie") && applicationSpecificDataGroups[1].Value.Equals("MovieTrailer"))
                {
                    //Special case for MovieTrailer; Then we expect ProductType=Movie, ContentType=MovieTrailer
                }
                else
                {
                    return elementLocation + " product.ApplicationSpecificData has bad type: " + applicationSpecificData + type;
                }
            }

            return null;
        }

        #endregion elementProduct validation

        #region elementActorsActor[] validation

        public static Collection<string> StaticElementValidation(Ieb.elementActorsActor[] actorList, string elementLocation, bool recurse)
        {
            Collection<string> result = StaticElementValidation(actorList, elementLocation);
            if (!recurse || actorList == null)
            {
                return result;
            }

            //Validate each product element
            for (int i = 0; i < actorList.Length && result.Count < maxErrorCount; i++)
            {
                result.AddRange(StaticElementValidation(actorList[i], elementLocation + "Actor[" + i + "]/", recurse));
            }

            if (result.Count >= maxErrorCount)
            {
                return result;
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementActorsActor[] actorList, string elementLocation)
        {
            Collection<string> result = new Collection<string>();
            if (actorList == null)
            {
                return result;
            }

            //Check for duplicate entries by Actor.Name
            var actorDuplicateList = from actor in actorList
                                  group actor by actor.Name into g
                                  select new { Key = g.Key, Count = g.Count() };

            foreach (var itemId in actorDuplicateList.Where(i => i.Count > 1))
            {
                //Bug 42302
                if (itemId.Key.Equals("ダン・エイクロイド"))
                {
                    continue;
                }
                result.Add(elementLocation + itemId.Key + " actor is duplicated: " + itemId.Count);
            }
            
            var characterDuplicateList = from actor in actorList
                                         where actor.Characters != null && actor.Characters.Character != null
                                         select new
                                         {
                                             Name = actor.Name,
                                             CharacterList =
                                                 from character in actor.Characters.Character
                                                 where actor.Characters != null
                                                 group character by character.Name into g
                                                 select new { Key = g.Key, Count = g.Count() }
                                         };
            foreach (var itemId in characterDuplicateList.Where(i => i.CharacterList.Where(j => j.Count > 1).Count() > 1))
            {
                result.Add(elementLocation + itemId.Name + " has duplicate characters");
            }

            return result;
        }
        #endregion elementActorsActor[] validation
        #region elementActorsActor
        public static Collection<string> StaticElementValidation(Ieb.elementActorsActor actor, string elementLocation, bool recurse)
        {
            return StaticElementValidation(actor, elementLocation);
        }

        public static Collection<string> StaticElementValidation(Ieb.elementActorsActor actor, string elementLocation)
        {
            return new Collection<string>();
        }
        #endregion elementActorsActor
        #region elementNames[] validation
        public static Collection<string> StaticElementValidation(Ieb.elementNames[] nameList, string elementLocation, bool recurse)
        {
            Collection<string> result = StaticElementValidation(nameList, elementLocation);
            if (!recurse || nameList == null)
            {
                return result;
            }

            //Validate each product element
            for (int i = 0; i < nameList.Length && result.Count < maxErrorCount; i++)
            {
                result.AddRange(StaticElementValidation(nameList[i], elementLocation + "Name[" + i + "]/", recurse));
            }

            if (result.Count >= maxErrorCount)
            {
                return result;
            }

            return result;
        }

        public static Collection<string> StaticElementValidation(Ieb.elementNames[] nameList, string elementLocation)
        {
            Collection<string> result = new Collection<string>();
            if (nameList == null)
            {
                return result;
            }

            //Check for duplicate entries by Names.Name
            var itemIdGroupList = from name in nameList
                                  group name by name.Name into g
                                  select new { Key = g.Key, Count = g.Count() };

            
            foreach (var itemId in itemIdGroupList.Where(i => i.Count > 1))
            {
                result.Add(elementLocation + itemId.Key + " item is duplicated: " + itemId.Count);
            }

            return result;
        }
        #endregion elementNames[] validation
        #region elementNames
        public static Collection<string> StaticElementValidation(Ieb.elementNames name, string elementLocation, bool recurse)
        {
            return StaticElementValidation(name, elementLocation);
        }

        public static Collection<string> StaticElementValidation(Ieb.elementNames name, string elementLocation)
        {
            return new Collection<string>();
        }
        #endregion elementNames

        #endregion StaticElementValidation

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CatalogWatcherTests-Video\VideoProducer\VideoProducerTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.server.catalogwatcher;
using xonline.common.sql.sqlclient;
using xonline.common.config;
using System.Data.SqlClient;
using System.Data;
using Ieb = IEBDataModel.Model4;
using System.Collections.ObjectModel;
using System.IO;
using System.Xml.Schema;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using CatalogWatcherTests_Video.Managers;

namespace CatalogWatcherTests_Video.VideoProducer
{
    /// <summary>
    /// Summary description for VideoProducerTests
    /// </summary>
    [TestClass]
    [DeploymentItem(@".\Data\CatalogWatcherTests-Video\", @".\Data\CatalogWatcherTests-Video\")]
    [DeploymentItem(@".\Data\CatalogWatcherTests-Video\IEBBingFeed.xsd", @".")]
    [DeploymentItem(@".\Data\", @".\Data\CatalogWatcherTests-Video\")]
    [DeploymentItem(@".\Data\IEBBingFeed.xsd", @".")]
    [DeploymentItem(@".\CommonConfig.xml", @".")]
    public class VideoProducerTests : BaseVideoProducerTest
    {
        private static Ieb.Feed randomMediaListFeed;
        /// <summary>
        /// Creates a new instance of the VideoProducerTests
        /// </summary>
        public VideoProducerTests()
        {
            SetupVideoProductList(defaultMediaList);
        }

        [TestMethod]
        public void HappyCase()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.Movie);

            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            this.DeltaProducerManager.dal.GetMovie(expectedProduct, expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedProduct, actualProduct, "");
        }

        [TestMethod]
        public void ValidateMovie()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.Movie);

            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            this.DeltaProducerManager.dal.GetMovie(expectedProduct, expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedProduct, actualProduct, "");
            AreMovieEqual(expectedProduct, actualProduct, "");
        }

        [TestMethod]
        public void ValidateMovieTrailer()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.MovieTrailer);

            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            this.DeltaProducerManager.dal.GetMovie(expectedProduct, expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedProduct, actualProduct, "");
            AreMovieEqual(expectedProduct, actualProduct, "");
        }

        [TestMethod]
        public void ValidateTvEpisode()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.TVEpisode);
            
            Ieb.elementTVEpisode expectedProduct;
            Ieb.elementTVEpisode actualProduct;
            RunSingleProduct<Ieb.elementTVEpisode>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            this.DeltaProducerManager.dal.GetTvEpisode(expectedProduct, expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedProduct, actualProduct, "");
            AreTvEpisodeEqual(expectedProduct, actualProduct, "");
        }

        [TestMethod]
        public void ValidateTvSeason()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.TVSeason);
            
            Ieb.elementTVSeason expectedProduct;
            Ieb.elementTVSeason actualProduct;
            RunSingleProduct<Ieb.elementTVSeason>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            this.DeltaProducerManager.dal.GetTvSeason(expectedProduct, expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedProduct, actualProduct, "Product");
            AreTvSeasonEqual(expectedProduct, actualProduct, "TVSeason");
        }

        [TestMethod]
        public void ValidateTvSeries()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.TVSeries);

            Ieb.elementTVSeries expectedProduct;
            Ieb.elementTVSeries actualProduct;
            RunSingleProduct<Ieb.elementTVSeries>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            this.DeltaProducerManager.dal.GetTvSeries(expectedProduct, expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedProduct, actualProduct, "Product");
            AreTvSeriesEqual(expectedProduct, actualProduct, "TVSeries");
        }

        [TestMethod]
        public void ValidateActor()
        {
            VideoProductEntry expectedId = new VideoProductEntry() { mediaId = new Guid("001EE498-716E-46CD-9AAC-1F4970BBAC48"), lcid = 1033, type = ProductType.TVEpisode };

            Ieb.elementTVEpisode expectedProduct;
            Ieb.elementTVEpisode actualProduct;
            RunSingleProduct<Ieb.elementTVEpisode>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            var expectedActorList = this.DeltaProducerManager.dal.GetActorList(expectedId.mediaId, expectedId.lcid);
            if (expectedActorList == null || expectedActorList.Actor.Length == 0) Assert.Inconclusive("No items found. Need to select a new product");

            AreEqual(expectedActorList.Actor, actualProduct.Actors.Actor, "");
        }

        [TestMethod]
        public void ValidateDirector()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.Movie);

            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            var expectedDirectorList = this.DeltaProducerManager.dal.GetDirectorList(expectedId.mediaId, expectedId.lcid);
            if (expectedDirectorList == null || expectedDirectorList.Director.Length == 0) Assert.Inconclusive("No items found. Need to select a new product");

            AreEqual(expectedDirectorList.Director, actualProduct.Directors.Director, "");
        }

        [TestMethod]
        public void ValidateWriter()
        {
            VideoProductEntry expectedId = new VideoProductEntry() { mediaId = new Guid("C190BA3A-AAAC-49E5-8560-11F021E0BB6F"), lcid = 1033, type = ProductType.Movie };
            
            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            var expectedWritersList = this.DeltaProducerManager.dal.GetWriterList(expectedId.mediaId, expectedId.lcid);
            if (expectedWritersList == null || expectedWritersList.Writer.Length == 0) Assert.Inconclusive("No items found. Need to select a new product");
            AreEqual(expectedWritersList.Writer, actualProduct.Writers.Writer, "");
        }

        [TestMethod]
        [WorkItem(62158)]
        public void ValidateImage()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.Movie);

            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            var expectedImageList = this.DeltaProducerManager.dal.GetImageList(expectedId.mediaId, expectedId.lcid);
            if (expectedImageList == null || expectedImageList.Length == 0) Assert.Inconclusive("No items found. Need to select a new product");

            AreEqual(expectedImageList, actualProduct.Images, "");
        }

        [TestMethod]
        [WorkItem(54929)]
        public void ValidateGenre()
        {
            VideoProductEntry expectedId = new VideoProductEntry() { mediaId = new Guid("00A7F895-988E-4C93-9D91-ADF700DFBF57"), lcid = 1033, type = ProductType.Movie };
            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            var expectedGenre = this.DeltaProducerManager.dal.GetGenresList(expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedGenre, actualProduct.Genres, "");
        }

        [TestMethod]
        public void ValidateParentalControl()
        {
            VideoProductEntry expectedId = new VideoProductEntry() { mediaId = new Guid("9589B1E7-CCE5-4CCB-838F-004DC3083058"), lcid = 4105, type = ProductType.Movie };
            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            var expectedParentalControl = this.DeltaProducerManager.dal.GetParentalControl(expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedParentalControl, actualProduct.ParentalControl, "");
        }

        [TestMethod]
        public void ValidateInstances()
        {
            var expectedId = defaultMediaList.First(x => x.type == ProductType.Movie);

            Ieb.elementMovie expectedProduct;
            Ieb.elementMovie actualProduct;
            RunSingleProduct<Ieb.elementMovie>(expectedId.mediaId, expectedId.lcid, out expectedProduct, out actualProduct);

            var expectedInstance = this.DeltaProducerManager.dal.GetInstance(expectedId.mediaId, expectedId.lcid);

            AreEqual(expectedInstance, actualProduct.Instances, "");
        }

        private Ieb.Feed RunSingleElement(Guid MediaId, int Lcid)
        {
            var videoList = new Collection<VideoProductEntry>();
            videoList.Add(new VideoProductEntry { mediaId = MediaId, lcid = Lcid });
            SetupVideoProductList(videoList);

            IWatcherDocumentProducer _producer = DocumentProducerFactory.CreateProducer("Video", "Azure");
            _producer.Init(0, 1);
            var documents = _producer.GetNextBatchOfDocuments(videoList.Count).ToArray();

            Assert.AreEqual(videoList.Count, documents.Count(), "Unexpected number of documents returned");
            string feedDocument = documents[0].Document.ToString();
            Console.WriteLine(feedDocument);
            return CreateMiniFeed(feedDocument);
        }

        private void RunSingleProduct<T>(Guid MediaId, int Lcid, out T expectedProduct, out T actualProduct) where T : Ieb.elementProduct, new()
        {
            var feed = RunSingleElement2(MediaId, Lcid);
            Assert.IsNotNull(feed, "Unexpected number of products in feed");
            actualProduct = (T)feed;
            expectedProduct = this.DeltaProducerManager.dal.GetProduct<T>(MediaId, Lcid);
        }

        private Ieb.elementProduct RunSingleElement2(Guid MediaId, int Lcid)
        {
            return randomMediaListFeed.Items.FirstOrDefault(x =>
            {
                int actualLcid = IebXsdValidator.ParseLcid(x.ItemId);
                Guid actualMediaId = IebXsdValidator.ParseMediaId(x.ItemId);
                return actualLcid == Lcid && actualMediaId == MediaId;
            });
        }


        //[TestMethod]
        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.CSV", @".\Data\CatalogWatcherTests-Video\NumberOfElements.csv", "NumberOfElements#csv", DataAccessMethod.Sequential)]
        public void NumberOfElements()
        {
            //Parse parameters
            int totalElements = Int32.Parse(TestContext.DataRow[0].ToString());
            int maxNumberOfDocuments = Int32.Parse(TestContext.DataRow[1].ToString());
            int expectedTotalElements = (totalElements < maxNumberOfDocuments) ? totalElements : maxNumberOfDocuments;
            Console.WriteLine("totalElements={0},maxNumberOfDocuments={1},expectedTotalElements={2}", totalElements, maxNumberOfDocuments, expectedTotalElements);

            //Insert records to be processed
            var videoList = new Collection<VideoProductEntry>(defaultMediaList.Take(totalElements).ToList());
            SetupVideoProductList(videoList);

            //Process records
            IWatcherDocumentProducer _producer = DocumentProducerFactory.CreateProducer("Video", "Azure");
            _producer.Init(0, 1);
            var documents = _producer.GetNextBatchOfDocuments(maxNumberOfDocuments);
            Assert.AreEqual(expectedTotalElements, documents.Count(), "Unexpected number of documents returned");

            var expectedVideoList = new Collection<VideoProductEntry>(videoList.Take(expectedTotalElements).ToList());

            //Generate list of returned ids
            var actualVideoList = new Collection<VideoProductEntry>();
            foreach (var item in documents)
            {
                var feed = CreateMiniFeed(item.Document.ToString());
                var actualItemId = feed.Items[0].ItemId;
                int lcid = IebXsdValidator.ParseLcid(actualItemId);
                Guid mediaId = IebXsdValidator.ParseMediaId(actualItemId);
                actualVideoList.Add(new VideoProductEntry() { lcid = lcid, mediaId = mediaId });
            }

            for (int i = 0; i < expectedVideoList.Count; i++)
            {
                Assert.AreEqual(expectedVideoList[i].mediaId, actualVideoList[i].mediaId, "Mismatch mediaId at " + i);
                Assert.AreEqual(expectedVideoList[i].lcid, actualVideoList[i].lcid, "Mismatch lcid at " + i);
            }
        }

        /*
        private void RunSingleProduct<T>(Guid MediaId, int Lcid, out T expectedProduct, out T actualProduct) where T : Ieb.elementProduct, new()
        {
            var feed = RunSingleElement2(MediaId, Lcid);

            Assert.AreEqual(1, feed.Items.Length, "Unexpected number of products in feed");

            actualProduct = (T)feed.Items[0];
            int actualLcid = IebXsdValidator.ParseLcid(actualProduct.ItemId);
            Guid actualMediaId = IebXsdValidator.ParseMediaId(actualProduct.ItemId);
            Assert.AreEqual(Lcid, actualLcid, "Unexpected Lcid");
            Assert.AreEqual(MediaId, actualMediaId, "Unexpected mediaId");

            expectedProduct = this.DeltaProducerManager.dal.GetProduct<T>(actualMediaId, actualLcid);
        }
        protected override Ieb.Feed CreateMiniFeed(string document)
        {
            string fullDocument = IebXsdValidator.feedPrefixElement + document + IebXsdValidator.feedSuffixElement;
            var allErrors = IebXsdValidator.FindDistinctErrors(fullDocument);
            foreach (var error in allErrors)
            {
                Console.WriteLine(error);
            }

            if (allErrors.Count > 0)
            {
                Assert.Fail(allErrors.Count + " xsd validation errors detected");
            }
            Ieb.Feed feed = DeserializeFromText<Ieb.Feed>(fullDocument);
            return feed;
        }*/
        private void SetupVideoProductList(Collection<VideoProductEntry> list)
        {
            if (randomMediaListFeed != null)
            {
                return;
            }
            CronManager.SetupJobs(1);
            DeltaProducerManager.ClearDocuments();
            PublisherManager.ClearDocuments();

            foreach (var entry in list)
            {
                Console.WriteLine("Adding entries for ({0},{1})", entry.mediaId, entry.lcid);
                DeltaProducerManager.AddDocuments(entry.mediaId, entry.lcid);
            }

            CronManager.Start();
            Collection<PublisherFile> documentList = WaitForDocuments();
            Assert.AreEqual(1, documentList.Count, "Incorrect number of documents returned");
            string feedString = (string)PublisherManager.GetDocument(documentList[0].BlobName);

            randomMediaListFeed = CreateMiniFeed(feedString);
            CheckForErrors(IebXsdValidator.StaticElementValidation(randomMediaListFeed, true), "Error with feed");

            Console.WriteLine("Saving feed to disk {0}.xml", documentList[0].BlobName);
            PublisherManager.Dal.WriteXmlToDisk(documentList[0].BlobName, documentList[0].BlobName + ".xml");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CDCPingTool\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CDCPingTool.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("CDCPingTool.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CDCPingTool\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Reflection;
using System.Windows.Forms;

using NamedArgParser;

namespace CDCPingTool
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);

            NamedArgsCollection argumentCollection = new NamedArgsCollection();

            // parse the command line arguments
            using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Resources.Usage.xml"))
            {
                argumentCollection.Parse(stream, args, new DisplayUsageCallback(DisplayUsage));
            }
            
            CDCPing cdcPing = new CDCPing();

            //initialize with command line values if they were provided
            cdcPing.Initialize(
                argumentCollection["DBServer"] != null ? argumentCollection["DBServer"] : String.Empty,
                argumentCollection["DBName"] != null ? argumentCollection["DBName"] : String.Empty,
                argumentCollection["WatcherServer"] != null ? argumentCollection["WatcherServer"] : String.Empty,
                argumentCollection["WatcherPort"] != null ? argumentCollection["WatcherPort"] : String.Empty,
                argumentCollection["PingInterval"] != null ? argumentCollection["PingInterval"] : String.Empty,
                argumentCollection["ReingestInterval"] != null ? argumentCollection["ReingestInterval"] : String.Empty,
                argumentCollection["MediaTypes"] != null ? argumentCollection["MediaTypes"] : String.Empty,
                argumentCollection["Execute"] != null ? true : false);
            
            Application.Run(cdcPing);
        }


        /// <summary>
        /// Displays the program usage
        /// </summary>
        /// <param name="usage">The usage string to display</param>
        private static void DisplayUsage(string usage)
        {
            Console.WriteLine(usage);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CDCPingTool\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CDCPingTool.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CDCPingTool\CDCPing.Designer.cs ===
﻿namespace CDCPingTool
{
    partial class CDCPing
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.label1 = new System.Windows.Forms.Label();
            this.databaseServer = new System.Windows.Forms.TextBox();
            this.databaseName = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.pingIntervalSeconds = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.reingestIntervalSeconds = new System.Windows.Forms.TextBox();
            this.label4 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.pingableMediaTypes = new System.Windows.Forms.TextBox();
            this.executeButton = new System.Windows.Forms.Button();
            this.statusStrip1 = new System.Windows.Forms.StatusStrip();
            this.toolStripStatus = new System.Windows.Forms.ToolStripStatusLabel();
            this.watcherCommandPort = new System.Windows.Forms.TextBox();
            this.watcherPort = new System.Windows.Forms.Label();
            this.watcherMachineName = new System.Windows.Forms.TextBox();
            this.label7 = new System.Windows.Forms.Label();
            this.statusStrip1.SuspendLayout();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(17, 12);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(87, 13);
            this.label1.TabIndex = 0;
            this.label1.Text = "Database Server";
            // 
            // databaseServer
            // 
            this.databaseServer.Location = new System.Drawing.Point(110, 9);
            this.databaseServer.Name = "databaseServer";
            this.databaseServer.Size = new System.Drawing.Size(95, 20);
            this.databaseServer.TabIndex = 1;
            // 
            // databaseName
            // 
            this.databaseName.Location = new System.Drawing.Point(330, 9);
            this.databaseName.Name = "databaseName";
            this.databaseName.Size = new System.Drawing.Size(95, 20);
            this.databaseName.TabIndex = 3;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(240, 12);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(84, 13);
            this.label2.TabIndex = 2;
            this.label2.Text = "Datebase Name";
            // 
            // pingIntervalSeconds
            // 
            this.pingIntervalSeconds.Location = new System.Drawing.Point(110, 69);
            this.pingIntervalSeconds.Name = "pingIntervalSeconds";
            this.pingIntervalSeconds.Size = new System.Drawing.Size(95, 20);
            this.pingIntervalSeconds.TabIndex = 5;
            this.pingIntervalSeconds.Text = "0";
            this.pingIntervalSeconds.TextChanged += new System.EventHandler(this.pingIntervalSeconds_TextChanged);
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(12, 72);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(92, 13);
            this.label3.TabIndex = 4;
            this.label3.Text = "Ping Interval (sec)";
            // 
            // reingestIntervalSeconds
            // 
            this.reingestIntervalSeconds.Location = new System.Drawing.Point(330, 69);
            this.reingestIntervalSeconds.Name = "reingestIntervalSeconds";
            this.reingestIntervalSeconds.Size = new System.Drawing.Size(95, 20);
            this.reingestIntervalSeconds.TabIndex = 7;
            this.reingestIntervalSeconds.Text = "0";
            this.reingestIntervalSeconds.TextChanged += new System.EventHandler(this.reingestIntervalSeconds_TextChanged);
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(211, 72);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(113, 13);
            this.label4.TabIndex = 6;
            this.label4.Text = "Reingest Interval (sec)";
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(12, 102);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(170, 13);
            this.label5.TabIndex = 8;
            this.label5.Text = "Media Types  (MediaType,Weight)";
            // 
            // pingableMediaTypes
            // 
            this.pingableMediaTypes.Location = new System.Drawing.Point(188, 99);
            this.pingableMediaTypes.Name = "pingableMediaTypes";
            this.pingableMediaTypes.Size = new System.Drawing.Size(237, 20);
            this.pingableMediaTypes.TabIndex = 9;
            // 
            // executeButton
            // 
            this.executeButton.Location = new System.Drawing.Point(15, 138);
            this.executeButton.Name = "executeButton";
            this.executeButton.Size = new System.Drawing.Size(410, 63);
            this.executeButton.TabIndex = 10;
            this.executeButton.Text = "Start";
            this.executeButton.UseVisualStyleBackColor = true;
            this.executeButton.Click += new System.EventHandler(this.executeButton_Click);
            // 
            // statusStrip1
            // 
            this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripStatus});
            this.statusStrip1.Location = new System.Drawing.Point(0, 217);
            this.statusStrip1.Name = "statusStrip1";
            this.statusStrip1.Size = new System.Drawing.Size(440, 22);
            this.statusStrip1.TabIndex = 11;
            this.statusStrip1.Text = "statusStrip1";
            // 
            // toolStripStatus
            // 
            this.toolStripStatus.Name = "toolStripStatus";
            this.toolStripStatus.Size = new System.Drawing.Size(84, 17);
            this.toolStripStatus.Text = "toolStripStatus";
            // 
            // watcherCommandPort
            // 
            this.watcherCommandPort.Location = new System.Drawing.Point(330, 40);
            this.watcherCommandPort.Name = "watcherCommandPort";
            this.watcherCommandPort.Size = new System.Drawing.Size(95, 20);
            this.watcherCommandPort.TabIndex = 15;
            // 
            // watcherPort
            // 
            this.watcherPort.AutoSize = true;
            this.watcherPort.Location = new System.Drawing.Point(254, 43);
            this.watcherPort.Name = "watcherPort";
            this.watcherPort.Size = new System.Drawing.Size(70, 13);
            this.watcherPort.TabIndex = 14;
            this.watcherPort.Text = "Watcher Port";
            // 
            // watcherMachineName
            // 
            this.watcherMachineName.Location = new System.Drawing.Point(110, 40);
            this.watcherMachineName.Name = "watcherMachineName";
            this.watcherMachineName.Size = new System.Drawing.Size(95, 20);
            this.watcherMachineName.TabIndex = 13;
            // 
            // label7
            // 
            this.label7.AutoSize = true;
            this.label7.Location = new System.Drawing.Point(17, 43);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(92, 13);
            this.label7.TabIndex = 12;
            this.label7.Text = "Watcher Machine";
            // 
            // CDCPing
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(440, 239);
            this.Controls.Add(this.watcherCommandPort);
            this.Controls.Add(this.watcherPort);
            this.Controls.Add(this.watcherMachineName);
            this.Controls.Add(this.label7);
            this.Controls.Add(this.statusStrip1);
            this.Controls.Add(this.executeButton);
            this.Controls.Add(this.pingableMediaTypes);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.reingestIntervalSeconds);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.pingIntervalSeconds);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.databaseName);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.databaseServer);
            this.Controls.Add(this.label1);
            this.Name = "CDCPing";
            this.Text = "CDC Ping";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.statusStrip1.ResumeLayout(false);
            this.statusStrip1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox databaseServer;
        private System.Windows.Forms.TextBox databaseName;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.TextBox pingIntervalSeconds;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox reingestIntervalSeconds;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.TextBox pingableMediaTypes;
        private System.Windows.Forms.Button executeButton;
        private System.Windows.Forms.StatusStrip statusStrip1;
        private System.Windows.Forms.ToolStripStatusLabel toolStripStatus;
        private System.Windows.Forms.TextBox watcherCommandPort;
        private System.Windows.Forms.Label watcherPort;
        private System.Windows.Forms.TextBox watcherMachineName;
        private System.Windows.Forms.Label label7;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CDCPingTool\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CDCPingTool")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("CDCPingTool")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b315905a-b01c-444a-8045-cba57375b786")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\CDCPingTool\CDCPing.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace CDCPingTool
{
    public partial class CDCPing : Form
    {
        #region Fields and Constants 

        private const string CONNECTION_STRING_BASE = "Data Source={0};Initial Catalog={1};Integrated Security=SSPI;Pooling=True;Max Pool Size=250";
        private const string MEDIA_ID_QUERY = "SELECT mediaId FROM Media WHERE mediaTypeId in ({0})";
        private const string MEDIA_ID_MODIFY = "UPDATE Media SET modifiedDate = '{0}' WHERE mediaId = '{1}'";
        private const string REFRESH_ALL = "http://{0}:{1}/command.ashx?assembly=watcher.dll&class=xonline.server.cron.plugins.xboxwatcher.watcher&op=RefreshAllProductMedia";
        
        private System.Threading.Timer pingTimer = null;
        private System.Threading.Timer reingestTimer = null;
        private Random random = new Random();
        private List<string> mediaWeights = new List<string>();
        private Dictionary<string, Queue<string>> mediaIdsByMediaType = new Dictionary<string, Queue<string>>();
        private bool running = false;

        #endregion

        #region Constructor and Initialization

        /// <summary>
        /// Constructor for the CDCPing form
        /// </summary>
        public CDCPing()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Initialization for the CDC Ping form and app
        /// </summary>
        /// <param name="dbServer">The server name where the database is located</param>
        /// <param name="dbName">The name of the database on the server</param>
        /// <param name="watcherMachine">The name of the server where the Catalog Watcher is located</param>
        /// <param name="watcherPort">The port where the Catalog Watcher may be contacted</param>
        /// <param name="pingInterval">The interval at which the content on the Media table will be pinged</param>
        /// <param name="reingestInterval">The interval at which all content will be reingested</param>
        /// <param name="pingableMedia">The media types that will be pinged and associated weights (mediaTypeId,weight)</param>
        /// <param name="execute">Whether or not to immediately begin executing</param>
        public void Initialize(
            string dbServer,
            string dbName,
            string watcherMachine,
            string watcherPort,
            string pingInterval,
            string reingestInterval,
            string pingableMedia,
            bool execute
            )
        {
            Configuration config = ConfigurationManager.OpenExeConfiguration(
                System.Reflection.Assembly.GetExecutingAssembly().Location);

            //Initialize with values provided, otherwise use the default values found in the config file
            databaseName.Text = (dbName != String.Empty ? dbName : config.AppSettings.Settings["databaseName"].Value);
            databaseServer.Text = (dbServer != String.Empty ? dbServer : config.AppSettings.Settings["databaseServer"].Value);
            pingIntervalSeconds.Text = (pingInterval != String.Empty ? pingInterval : config.AppSettings.Settings["pingIntervalSeconds"].Value);
            reingestIntervalSeconds.Text = (reingestInterval != String.Empty ? reingestInterval : config.AppSettings.Settings["reingestIntervalSeconds"].Value);
            pingableMediaTypes.Text = (pingableMedia != String.Empty ? pingableMedia : config.AppSettings.Settings["pingableMediaTypes"].Value);
            watcherMachineName.Text = (watcherMachine != String.Empty ? watcherMachine : config.AppSettings.Settings["watcherMachineName"].Value);
            watcherCommandPort.Text = (watcherPort != String.Empty ? watcherPort : config.AppSettings.Settings["watcherCommandPort"].Value);

            if (execute)
            {
                executeButton_Click(this, null);
            }
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            toolStripStatus.Text = String.Empty;
        }

        #endregion

        private void CalculateWeighting()
        {
            int weightsSum = 0;
            string mediaType = String.Empty;
            Dictionary<string, int> mediaTypeWeights = new Dictionary<string, int>();

            string[] mediaTypesAndWeights = pingableMediaTypes.Text.Split(",".ToCharArray());
        
            //iterate through the media types and their assigned weights
            for (int i = 0; i < mediaTypesAndWeights.Length; i++)
            {
                //grab media type id
                if (0 == i % 2)
                {
                    mediaType = mediaTypesAndWeights[i].Replace("(", String.Empty).Trim();
                    mediaIdsByMediaType.Add(mediaType, new Queue<string>());
                }

                //grab weight
                else
                {
                    int weight = Convert.ToInt32(mediaTypesAndWeights[i].Replace(")", String.Empty).Trim());
                    weightsSum += weight;
                    mediaTypeWeights.Add(mediaType, weight);
                }
            }

            int percentage = 0;
            List<string> tempMediaWeights = new List<string>();
            
            //calculate the relative percentage based on the weights assigned each media type
            foreach (string mediaTypeId in mediaTypeWeights.Keys)
            {
                percentage = (int) Math.Round((double)mediaTypeWeights[mediaTypeId] / (double)weightsSum * 100);
                for (int i = 0; i < percentage; i++)
                {
                    tempMediaWeights.Add(mediaTypeId);
                }
            }

            mediaWeights = tempMediaWeights;
        }


        private void ModifyMedia(object state)
        {
            string connectionString = String.Format(
                CONNECTION_STRING_BASE,
                databaseServer.Text,
                databaseName.Text);

            //randomly choose a media type to touch
            int index = random.Next(mediaWeights.Count);
            Queue<string> currentQueue = mediaIdsByMediaType[mediaWeights[index]];

            if (currentQueue.Count > 0)
            {
                //take the next media ID and add it back to the queue for future use
                string mediaId = currentQueue.Dequeue();
                currentQueue.Enqueue(mediaId);

                string modifiedDate = DateTime.Now.ToString("s");
                string query = String.Format(MEDIA_ID_MODIFY, modifiedDate, mediaId);

                //update the modifiedDate column with the current datetime
                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    using (SqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = query;
                        connection.Open();
                        int affectedRows = command.ExecuteNonQuery();
                    }
                }

                toolStripStatus.Text = String.Format(
                    "Updated @ {0}: {1}",
                    modifiedDate,
                    mediaId);
            }
        }
        
        private void ReingestAll(object state)
        {
            string modifiedDate = DateTime.Now.ToString("s");

            WebClient client = new WebClient();

            //Execute the refresh all command
            Stream stream = client.OpenRead(
                String.Format(
                REFRESH_ALL,
                watcherMachineName,
                watcherCommandPort));

            StreamReader reader = new StreamReader(stream);
            reader.ReadToEnd();
            reader.Close();

            toolStripStatus.Text = String.Format(
                "Refreshed All Media @ {0}",
                modifiedDate);
        }

        private void GatherMediaIds()
        {
            string connectionString = String.Format(
                CONNECTION_STRING_BASE,
                databaseServer.Text,
                databaseName.Text);

            string query = String.Empty;

            //Query for media IDs for each of the media types provided
            foreach (string mediaType in mediaIdsByMediaType.Keys)
            {
                query = String.Format(MEDIA_ID_QUERY, mediaType);

                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    using (SqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = query;

                        connection.Open();

                        //query for media IDs for the current media type
                        SqlDataReader reader = command.ExecuteReader(CommandBehavior.CloseConnection);
                        
                        //read in all returned media IDs
                        while (reader.Read())
                        {
                            mediaIdsByMediaType[mediaType].Enqueue(Convert.ToString(reader[0]));
                        }

                        reader.Close();
                    }
                }
            }
        }

        private void pingIntervalSeconds_TextChanged(object sender, EventArgs e)
        {
            UpdateIntervalValue(pingTimer, pingIntervalSeconds.Text);
        }

        private void reingestIntervalSeconds_TextChanged(object sender, EventArgs e)
        {
            UpdateIntervalValue(reingestTimer, reingestIntervalSeconds.Text);
        }

        private void UpdateIntervalValue(System.Threading.Timer timer, string updatedValue)
        {
            int seconds = 0;

            if (Int32.TryParse(updatedValue, out seconds) &&
                null != reingestTimer)
            {
                TimeSpan newInterval = new TimeSpan(0, 0, seconds);
                timer.Change(newInterval, newInterval);
            }
        }

        private void executeButton_Click(object sender, EventArgs e)
        {
            if (!running)
            {
                running = true;
                toolStripStatus.Text = String.Format("Gathering media IDs...");

                //Calculate the relative weights for each of the provided media types
                CalculateWeighting();

                //Gather the media IDs for the specified media types
                GatherMediaIds();

                //Start the recurring timer for individual content updates
                TimeSpan interval = new TimeSpan(0, 0, Convert.ToInt32(pingIntervalSeconds.Text));
                pingTimer = new System.Threading.Timer(
                    ModifyMedia,
                    null,
                    interval,
                    interval);

                //Start the recurring timer for full catalog reingestion
                interval = new TimeSpan(0, 0, Convert.ToInt32(reingestIntervalSeconds.Text));
                reingestTimer = new System.Threading.Timer(
                    ReingestAll,
                    null,
                    interval,
                    interval);

                executeButton.Text = "Stop";

                toolStripStatus.Text = "Done gathering media IDs.";
            }
            else
            {
                //Stop everything
                running = false;
                pingTimer.Dispose();
                reingestTimer.Dispose();
                executeButton.Text = "Start";
                toolStripStatus.Text = "Execution Stopped.";
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\DocumentGenerationTests\MediaIdLcid.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Marketplace.Test.Common.Service
{
    class MediaIdLcid
    {
        public Guid MediaId { get; protected set; }
        public Int32 Lcid { get; protected set; }

        public MediaIdLcid(Guid mediaId, Int32 lcd)
        {
            MediaId = mediaId;
            Lcid = lcd;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\DocumentGenerationTests\DocumentResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Data.SqlClient;
using System.Text;

using xonline.common.config;
using xonline.server.marketplace.test;

namespace Marketplace.Test.Common.Service
{
    class DetailLevel : IDocumentResult
    {
        public Guid ProductId { get; set; }
        public Int32 Lcid { get; set; }

        public String Id
        {
            get { return String.Format("{0} | {1}", ProductId, Lcid); }
        }

        public String Document { get; set; }
    }

    class DocumentResult: IDocumentResult
    {
        public Guid ProductId { get; private set; }
        public Int32 Lcid { get; private set; }
        public String Document { get; private set; }
        public String SortTitle { get; private set; }
        public Int32 DownloadCountAllTimePaid { get; private set; }
        public Int32 DownloadCountAllTimeFreeAndPaid { get; private set; }
        public Int32 DownloadCountTodayPaid { get; private set; }
        public Int32 DownloadCountTodayFreeAndPaid { get; private set; }
        public Double UserRating { get; private set; }
        public DateTime MostRecentOfferStartDate { get; private set; }
        public String SearchTitle { get; private set; }
        public String SearchDescription { get; private set; }
        public String RatingNavigator { get; private set; }
        public String LetterJump { get; private set; }
        public String ProductTypeNavigator { get; private set; }
        public Int32 AvatarBodyType { get; private set; }
        public String GenreNavigator { get; private set; }
        public String AvatarStoreNavigator { get; private set; }
        public String ParentProductNavigator { get; private set; }
        public String AvatarClothesNavigator { get; private set; }

        public DetailLevel detaillevel1 { get; set;}
        public DetailLevel detaillevel2 { get; set;}
        public DetailLevel detaillevel3 { get; set;}
        public DetailLevel detaillevel4 { get; set;}
        public DetailLevel detaillevel5 { get; set;}

        public DetailLevel detailguidebrowse { get;set;}
        public DetailLevel detailguidetitle { get;set;}
        public DetailLevel detailguidepurchase { get;set;}
        public DetailLevel detailguidecart { get;set;}     

        public String Id
        {
            get { return String.Format("{0} | {1}", ProductId, Lcid); }
        }

        /// <summary>
        /// This method adds the list of pdlc mediaTypes as a parameter to the sql command
        /// </summary>
        private static void AddPDLCMediaTypes(SqlCommand command)
        {
            string[] pdlcMediaTypes = Config.GetMultiSetting("pdlc_mediatypes");

            // Create the set of pdlc mediaTypes
            // DataTable is standard .Net object for holding matrix of data for different types. The columns
            // added have names that map to the columns of the table parameter expected by the sproc
            DataTable table = new DataTable();
            table.Columns.Add(new DataColumn("i", typeof(int)));
            if (pdlcMediaTypes.Length == 0)
            {
                throw new Exception("pdlc_mediatypes t_multisetting is empty! Ensure this is in your NPDB!");
            }

            foreach (string pdlcMediaType in pdlcMediaTypes)
            {
                int mediaType = 0;
                mediaType = Convert.ToInt32(pdlcMediaType);                
                table.Rows.Add(new object[] { 
                                                mediaType 
                                            });
            }
            SqlParameter pdlcList = command.Parameters.AddWithValue("@pdlcMediaTypes", table);
            pdlcList.SqlDbType = SqlDbType.Structured;
            pdlcList.TypeName = "dbo.IntegerList";
        }

        /// <summary>
        /// This method adds the list of rateable mediaTypes as a parameter to the sql command
        /// </summary>
        private static void AddRateableMediaTypes(SqlCommand command)
        {
            string[] rateableMediaTypes = Config.GetMultiSetting("ratings_mediatypes");

            // Create the set of rateable mediaTypes
            // DataTable is standard .Net object for holding matrix of data for different types. The columns
            // added have names that map to the columns of the table parameter expected by the sproc
            DataTable table = new DataTable();
            table.Columns.Add(new DataColumn("i", typeof(int)));
            foreach (string rateableMediaType in rateableMediaTypes)
            {
                int mediaType = 0;
                mediaType = Convert.ToInt32(rateableMediaType);
                table.Rows.Add(new object[] { 
                                                mediaType 
                                            });
            }
            SqlParameter rateableMediaTypeList = command.Parameters.AddWithValue("@rateableMediaTypes", table);
            rateableMediaTypeList.SqlDbType = SqlDbType.Structured;
            rateableMediaTypeList.TypeName = "dbo.IntegerList";
        }


        /// <summary>
        /// Retrieves all of the exempt media ids from a multisetting in NPDB, and adds them to the sql command
        /// </summary>
        private static void AddNonExemptMediaIds(SqlCommand command, string[] fastRatingNonExemptMediaIds)
        {
            if (fastRatingNonExemptMediaIds != null)
            {
                DataTable table = new DataTable();
                table.Columns.Add(new DataColumn("i", typeof(Guid)));
                foreach (string nonExemptMediaId in fastRatingNonExemptMediaIds)
                {
                    Guid mediaId = Guid.Empty;
                    mediaId = new Guid(nonExemptMediaId);
                    table.Rows.Add(new object[] { 
                                                    mediaId 
                                                });
                }
                SqlParameter fastRatingNonExemptMediaIdsList = command.Parameters.AddWithValue("@nonExemptMediaIds", table);
                fastRatingNonExemptMediaIdsList.SqlDbType = SqlDbType.Structured;
                fastRatingNonExemptMediaIdsList.TypeName = "dbo.UniqueIdList";
            }
        }

        /// <summary>
        /// Retrieves all of the exempt rating systems from a multisetting in NPDB, and adds them to the sql command
        /// </summary>
        /// 
        private static void AddNonExemptRatingSystem(SqlCommand command, string[] fastRatingNonExemptRatingSystem)
        {
            if (fastRatingNonExemptRatingSystem != null)
            {
                DataTable table = new DataTable();
                table.Columns.Add(new DataColumn("i", typeof(int)));
                foreach (string nonExemptRatingSystem in fastRatingNonExemptRatingSystem)
                {
                    int ratingSystemId = 0;
                    ratingSystemId = Convert.ToInt32(nonExemptRatingSystem);
                    table.Rows.Add(new object[] { 
                                                    ratingSystemId 
                                                });
                }
                SqlParameter fastRatingNonExemptRatingSystemList = command.Parameters.AddWithValue("@nonExemptRatingSystems", table);
                fastRatingNonExemptRatingSystemList.SqlDbType = SqlDbType.Structured;
                fastRatingNonExemptRatingSystemList.TypeName = "dbo.IntegerList";
            }
        }

        /// <summary>
        /// Retrieves all of the exempt media types from a multisetting in NPDB, and adds them to the sql command
        /// </summary>
        /// 
        private static void AddExemptMediaTypes(SqlCommand command, string[] fastRatingExemptMediaTypes)
        {
            if (fastRatingExemptMediaTypes != null)
            {
                DataTable table = new DataTable();
                table.Columns.Add(new DataColumn("i", typeof(int)));
                foreach (string exemptMediaType in fastRatingExemptMediaTypes)
                {
                    int mediaTypeId = 0;
                    mediaTypeId = Convert.ToInt32(exemptMediaType);
                    table.Rows.Add(new object[] { 
                                                    mediaTypeId 
                                                });
                }
                SqlParameter fastRatingExemptMediaTypesList = command.Parameters.AddWithValue("@exemptMediaTypes", table);
                fastRatingExemptMediaTypesList.SqlDbType = SqlDbType.Structured;
                fastRatingExemptMediaTypesList.TypeName = "dbo.IntegerList";
            }
        }

        /// <summary>
        /// Retrieves all of the exempt game content for titles from a multisetting in NPDB, and adds them to the sql command
        /// </summary>
        /// 
        private static void AddExemptGCForTitles(SqlCommand command, string[] fastRatingExemptGCForTitles)
        {
            if (fastRatingExemptGCForTitles != null)
            {
                DataTable table = new DataTable();
                table.Columns.Add(new DataColumn("i", typeof(int)));
                foreach (string exemptGCForTitle in fastRatingExemptGCForTitles)
                {
                    int titleId = 0;
                    titleId = Convert.ToInt32(exemptGCForTitle);
                    table.Rows.Add(new object[] { 
                                                    titleId 
                                                });
                }
                SqlParameter fastRatingExemptGCForTitlesList = command.Parameters.AddWithValue("@exemptGCForTitles", table);
                fastRatingExemptGCForTitlesList.SqlDbType = SqlDbType.Structured;
                fastRatingExemptGCForTitlesList.TypeName = "dbo.IntegerList";
            }
        }

        public static List<DocumentResult> GetDocuments( DataTable mediaIdLcids, string[] fastRatingNonExemptMediaIds,
                                                        string[] fastRatingNonExemptRatingSystem,string[] fastRatingExemptMediaTypes,
                                                        string[] fastRatingExemptGCForTitles)
        {
            using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
            {
                SqlCommand command = new SqlCommand();

                command.CommandText = "dbo.GetProductDocuments";
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@version", 1);

                SqlParameter mediaIdLcidsToProcess = command.Parameters.AddWithValue("@mediaIdLcidTuples", mediaIdLcids);
                mediaIdLcidsToProcess.SqlDbType = SqlDbType.Structured;
                mediaIdLcidsToProcess.TypeName = "dbo.OrderedMediaIdLcidTuples";
                AddPDLCMediaTypes(command);
                AddRateableMediaTypes(command);
                AddNonExemptMediaIds(command, fastRatingNonExemptMediaIds);
                AddNonExemptRatingSystem(command,fastRatingNonExemptRatingSystem);
                AddExemptMediaTypes(command,fastRatingExemptMediaTypes);
                AddExemptGCForTitles(command,fastRatingExemptGCForTitles );
                int minRatingReviewCount = 0;
                minRatingReviewCount = Convert.ToInt32(Config.GetSetting(Setting.ratings_max_allowable_reviewcount));
                command.Parameters.AddWithValue("@userRatings_min_reviewcount", minRatingReviewCount);                

                command.Connection = connection;
                connection.Open();

                return Results( command.ExecuteReader() );
            }
        }
        
        /// <summary>
        /// Returns all the results
        /// </summary>
        /// <returns></returns>
        public static List<DocumentResult> Results(SqlDataReader reader)
        {
            List<DocumentResult> results = new List<DocumentResult>();
            while (reader.Read())
            {
                results.Add(new DocumentResult(reader));
            }
            return results;
        }      

        /// <summary>
        /// Constructs a result from the current row in the reader
        /// </summary>
        /// <param name="reader"></param>
        private DocumentResult(SqlDataReader reader)
        {
            ProductId   = reader.GetGuid(reader.GetOrdinal("mediaId"));
            Lcid        = reader.GetInt32(reader.GetOrdinal("lcid"));
            String xml  = reader.GetSqlString(reader.GetOrdinal("document")).ToString();
            if (String.IsNullOrEmpty(xml) || xml == "Null")
            {
                Document = null;
            }
            else
            {
                Document = String.Format( "<?xml version=\"1.0\" encoding=\"utf-8\"?>{0}", xml );
            }

            detaillevel1 = new DetailLevel();
            detaillevel2 = new DetailLevel();
            detaillevel3 = new DetailLevel();
            detaillevel4 = new DetailLevel();
            detaillevel5 = new DetailLevel();

            detailguidebrowse = new DetailLevel();
            detailguidetitle = new DetailLevel();
            detailguidepurchase = new DetailLevel();
            detailguidecart = new DetailLevel();

            // Assign all of the IDs
            detaillevel1.ProductId = detaillevel2.ProductId = detaillevel3.ProductId = detaillevel4.ProductId = detaillevel5.ProductId = ProductId;
            detailguidebrowse.ProductId = detailguidetitle.ProductId = detailguidepurchase.ProductId = detailguidecart.ProductId = ProductId;

            detaillevel1.Lcid = detaillevel2.Lcid = detaillevel3.Lcid = detaillevel4.Lcid = detaillevel5.Lcid = Lcid;
            detailguidebrowse.Lcid = detailguidetitle.Lcid = detailguidepurchase.Lcid = detailguidecart.Lcid = Lcid;

            detaillevel5.Document = String.Format("<?xml version=\"1.0\" encoding=\"utf-8\"?>{0}", reader.GetSqlString(reader.GetOrdinal("detaillevel5")).ToString());

            SortTitle = reader.GetSqlString(reader.GetOrdinal("sortTitle")).ToString();
            DownloadCountAllTimeFreeAndPaid = reader.IsDBNull(reader.GetOrdinal("downloadCountAllTimeFreeAndPaid")) ? 0 : reader.GetInt32(reader.GetOrdinal("downloadCountAllTimeFreeAndPaid"));
            DownloadCountAllTimePaid = reader.IsDBNull(reader.GetOrdinal("downloadCountAllTimePaid")) ? 0 : reader.GetInt32(reader.GetOrdinal("downloadCountAllTimePaid"));
            DownloadCountTodayPaid = reader.IsDBNull(reader.GetOrdinal("downloadCountTodayPaid")) ? 0 : reader.GetInt32(reader.GetOrdinal("downloadCountTodayPaid"));
            DownloadCountTodayFreeAndPaid = reader.IsDBNull(reader.GetOrdinal("downloadCountTodayFreeAndPaid")) ? 0 : reader.GetInt32(reader.GetOrdinal("downloadCountTodayFreeAndPaid"));

            UserRating = reader.IsDBNull(reader.GetOrdinal("userRating")) ? 0 : System.Convert.ToSingle(reader.GetDecimal(reader.GetOrdinal("userRating")));
            MostRecentOfferStartDate = reader.IsDBNull(reader.GetOrdinal("mostRecentOfferStartDate")) ? DateTime.MinValue : reader.GetDateTime(reader.GetOrdinal("mostRecentOfferStartDate"));            
            SearchTitle = reader.GetSqlString(reader.GetOrdinal("searchTitle")).ToString();
            SearchDescription = reader.GetSqlString(reader.GetOrdinal("searchDescription")).ToString();

            RatingNavigator = reader.GetSqlString(reader.GetOrdinal("ratingNavigator")).ToString();
            LetterJump = reader.GetSqlString(reader.GetOrdinal("letterJump")).ToString();
            ProductTypeNavigator = reader.GetSqlString(reader.GetOrdinal("productTypeNavigator")).ToString();
            AvatarBodyType = reader.IsDBNull(reader.GetOrdinal("avatarBodyType")) ? 0 : reader.GetInt32(reader.GetOrdinal("avatarBodyType"));
            GenreNavigator = reader.GetSqlString(reader.GetOrdinal("genreNavigator")).ToString();
            AvatarStoreNavigator = reader.GetSqlString(reader.GetOrdinal("avatarStoreNavigator")).ToString();

            ParentProductNavigator = reader.GetSqlString(reader.GetOrdinal("parentProductNavigator")).ToString();
            AvatarClothesNavigator = reader.GetSqlString(reader.GetOrdinal("avatarClothesNavigator")).ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\DocumentGenerationTests\ProductDocumentRollupTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Data;
using System.Linq;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Diagnostics;
using System.Collections.Specialized;
using System.Xml;
using System.Xml.XPath;

using Marketplace.Test.Common.Service;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("craigta"), TestFrequency("Daily"), EnvRequirement("xblobonly")]
    public class ProductDocumentRollupTests
    {
        Hashtable storeid = new Hashtable();
        Hashtable usertypeid = new Hashtable();
        Hashtable startdatetime = new Hashtable();
        Hashtable enddatetime = new Hashtable();
        Hashtable visibilitylevelid = new Hashtable();
        Hashtable mediatypeid = new Hashtable();

        [TestGroupSetup]
        public void Setup()
        {
            Global.RO.Info("Saving properties for each offerinstance");
            // Save off the store/tier/start/end info to restore on shutdown

            storeid["10000000-0000-4001-8000-00001010011C"] = GetProperty("10000000-0000-4001-8000-00001010011C", "storeid");
            storeid["20000000-0000-4001-8000-00001010011C"] = GetProperty("20000000-0000-4001-8000-00001010011C", "storeid");
            storeid["30000000-0000-4001-8000-00001010011C"] = GetProperty("30000000-0000-4001-8000-00001010011C", "storeid");
            storeid["40000000-0000-4001-8000-00001010011C"] = GetProperty("40000000-0000-4001-8000-00001010011C", "storeid");
            storeid["50000000-0000-4001-8000-00001010011C"] = GetProperty("50000000-0000-4001-8000-00001010011C", "storeid");

            usertypeid["10000000-0000-4001-8000-00001010011C"] = GetProperty("10000000-0000-4001-8000-00001010011C", "usertypeid");
            usertypeid["20000000-0000-4001-8000-00001010011C"] = GetProperty("20000000-0000-4001-8000-00001010011C", "usertypeid");
            usertypeid["30000000-0000-4001-8000-00001010011C"] = GetProperty("30000000-0000-4001-8000-00001010011C", "usertypeid");
            usertypeid["40000000-0000-4001-8000-00001010011C"] = GetProperty("40000000-0000-4001-8000-00001010011C", "usertypeid");
            usertypeid["50000000-0000-4001-8000-00001010011C"] = GetProperty("50000000-0000-4001-8000-00001010011C", "usertypeid");

            startdatetime["10000000-0000-4001-8000-00001010011C"] = GetProperty("10000000-0000-4001-8000-00001010011C", "startdatetime");
            startdatetime["20000000-0000-4001-8000-00001010011C"] = GetProperty("20000000-0000-4001-8000-00001010011C", "startdatetime");
            startdatetime["30000000-0000-4001-8000-00001010011C"] = GetProperty("30000000-0000-4001-8000-00001010011C", "startdatetime");
            startdatetime["40000000-0000-4001-8000-00001010011C"] = GetProperty("40000000-0000-4001-8000-00001010011C", "startdatetime");
            startdatetime["50000000-0000-4001-8000-00001010011C"] = GetProperty("50000000-0000-4001-8000-00001010011C", "startdatetime");

            enddatetime["10000000-0000-4001-8000-00001010011C"] = GetProperty("10000000-0000-4001-8000-00001010011C", "enddatetime");
            enddatetime["20000000-0000-4001-8000-00001010011C"] = GetProperty("20000000-0000-4001-8000-00001010011C", "enddatetime");
            enddatetime["30000000-0000-4001-8000-00001010011C"] = GetProperty("30000000-0000-4001-8000-00001010011C", "enddatetime");
            enddatetime["40000000-0000-4001-8000-00001010011C"] = GetProperty("40000000-0000-4001-8000-00001010011C", "enddatetime");
            enddatetime["50000000-0000-4001-8000-00001010011C"] = GetProperty("50000000-0000-4001-8000-00001010011C", "enddatetime");

            visibilitylevelid["10000000-0000-4001-8000-00001010011C"] = GetProperty("10000000-0000-4001-8000-00001010011C", "visibilitylevelid");
            visibilitylevelid["20000000-0000-4001-8000-00001010011C"] = GetProperty("20000000-0000-4001-8000-00001010011C", "visibilitylevelid");
            visibilitylevelid["30000000-0000-4001-8000-00001010011C"] = GetProperty("30000000-0000-4001-8000-00001010011C", "visibilitylevelid");
            visibilitylevelid["40000000-0000-4001-8000-00001010011C"] = GetProperty("40000000-0000-4001-8000-00001010011C", "visibilitylevelid");
            visibilitylevelid["50000000-0000-4001-8000-00001010011C"] = GetProperty("50000000-0000-4001-8000-00001010011C", "visibilitylevelid");

            mediatypeid["10000000-0000-4001-8000-00001010011C"] = GetProperty("10000000-0000-4001-8000-00001010011C", "mediatypeid");
            mediatypeid["20000000-0000-4001-8000-00001010011C"] = GetProperty("20000000-0000-4001-8000-00001010011C", "mediatypeid");
            mediatypeid["30000000-0000-4001-8000-00001010011C"] = GetProperty("30000000-0000-4001-8000-00001010011C", "mediatypeid");
            mediatypeid["40000000-0000-4001-8000-00001010011C"] = GetProperty("40000000-0000-4001-8000-00001010011C", "mediatypeid");
            mediatypeid["50000000-0000-4001-8000-00001010011C"] = GetProperty("50000000-0000-4001-8000-00001010011C", "mediatypeid");
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
            Global.RO.Info("Reseting saved properties for each offerinstance");
            // Reset the values to what they were at the start..
            IDictionaryEnumerator enumerator = storeid.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SetProperty((String)enumerator.Key, "storeid", (String)enumerator.Value);
            }

            enumerator = usertypeid.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SetProperty((String)enumerator.Key, "usertypeid", (String)enumerator.Value);
            }

            enumerator = startdatetime.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SetProperty((String)enumerator.Key, "startdatetime", (String)enumerator.Value);
            }

            enumerator = enddatetime.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SetProperty((String)enumerator.Key, "enddatetime", (String)enumerator.Value);
            }

            enumerator = visibilitylevelid.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SetProperty((String)enumerator.Key, "visibilitylevelid", (String)enumerator.Value);
            }

            enumerator = mediatypeid.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SetProperty((String)enumerator.Key, "mediatypeid", (String)enumerator.Value);
            }
        }


        /// <summary>
        /// Sets all parameters at one time
        /// </summary>
        public static void SetAllProperty(String offerInstanceId, string startdatetime, string enddatetime, int userTypeId, int StoreId)
        {
            SetProperty(offerInstanceId, "startdatetime", startdatetime);
            SetProperty(offerInstanceId, "enddatetime", enddatetime);
            SetProperty(offerInstanceId, "usertypeid", userTypeId.ToString());
            SetProperty(offerInstanceId, "storeid", StoreId.ToString());
        }

        /// <summary>
        /// Sets an individual parameter
        /// </summary>
        public static void SetProperty(String offerInstanceId, string property, string value)
        {
            if (value == string.Empty)
            {
                throw new Exception(String.Format("For property [{0}] value was empty", property));
            }
            int updatedRows = 0;
            switch (property)
            {
                case "storeid":
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("update offerstore set storeid = {0} where offerid = ( select top 1 offerid from offerinstance where offerinstanceid = '{1}')",
                                                             value,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        updatedRows = command.ExecuteNonQuery();
                    }
                    break;
                case "usertypeid":
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("update offerinstanceusertype set usertypeid = {0} where offerinstanceid = '{1}'",
                                                             value,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        updatedRows = command.ExecuteNonQuery();

                    }
                    break;
                case "startdatetime":
                case "enddatetime":                
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("update offerinstance set {0} = '{1}' where offerinstanceid = '{2}'",
                                                             property,
                                                             value,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        updatedRows = command.ExecuteNonQuery();
                    }
                    break;
                case "visibilitylevelid":
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("update offerinstance set {0} = {1} where offerinstanceid = '{2}'",
                                                             property,
                                                             value,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        updatedRows = command.ExecuteNonQuery();
                    }
                    break;
                case "mediatypeid":
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("update media set {0} = {1} where mediaid = ( select top 1 mediaid from offerinstance oi join offer o on o.offerid = oi.offerid where offerinstanceid = '{2}')",
                                                             property,
                                                             value,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        updatedRows = command.ExecuteNonQuery();
                    }
                    break;
                default:
                    throw new Exception(String.Format("Unexpected property [{0}]", property));

            }

            if (updatedRows == 0)
            {
                throw new Exception(String.Format("Expected rows to be updated, but none were. OfferInstanceId: [{0}], property: [{1}], value: [{2}]", offerInstanceId, property, value));
            }
        }

        /// <summary>
        /// Retrieves a single property
        /// </summary>
        public static string GetProperty(String offerInstanceId, string property)
        {
            switch (property)
            {
                case "storeid":
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("select {0} from offerstore where offerid = ( select top 1 offerid from offerinstance where offerinstanceid = '{1}')",
                                                             property,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        SqlDataReader r = command.ExecuteReader();

                        if (r.Read())
                        {
                            if (r.IsDBNull(r.GetOrdinal(property)))
                            {
                                return string.Empty;
                            }
                            else
                            {
                                return r.GetInt32(r.GetOrdinal(property)).ToString();
                            }
                        }
                        else
                        {
                            return string.Empty;
                        }
                    }
                case "usertypeid":
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("select {0} from offerinstanceusertype where offerinstanceid = '{1}'",
                                                             property,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        SqlDataReader r = command.ExecuteReader();

                        if (r.Read())
                        {
                            if (r.IsDBNull(r.GetOrdinal(property)))
                            {
                                return string.Empty;
                            }
                            else
                            {
                                return r.GetInt32(r.GetOrdinal(property)).ToString();
                            }
                        }
                        else
                        {
                            return string.Empty;
                        }
                    }
                case "startdatetime":
                case "enddatetime":                
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("select {0} from offerinstance where offerinstanceid = '{1}'",
                                                             property,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        SqlDataReader r = command.ExecuteReader();

                        if (r.Read())
                        {
                            if (r.IsDBNull(r.GetOrdinal(property)))
                            {
                                return string.Empty;
                            }
                            else
                            {
                                return r.GetDateTime(r.GetOrdinal(property)).ToString();
                            }
                        }
                        else
                        {
                            return string.Empty;
                        }
                    }
                case "visibilitylevelid":
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("select {0} from offerinstance where offerinstanceid = '{1}'",
                                                             property,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        SqlDataReader r = command.ExecuteReader();

                        if (r.Read())
                        {
                            if (r.IsDBNull(r.GetOrdinal(property)))
                            {
                                return string.Empty;
                            }
                            else
                            {
                                return r.GetInt32(r.GetOrdinal(property)).ToString();
                            }
                        }
                        else
                        {
                            return string.Empty;
                        }
                    }
                case "mediatypeid":
                    using (SqlConnection connection = new SqlConnection(DocumentGenerationTestBase.RawCatalogDBConnectionString))
                    {
                        SqlCommand command = new SqlCommand();

                        command.CommandText = String.Format("select {0} from media where mediaid = ( select top 1 mediaid from offerinstance oi join offer o on o.offerid = oi.offerid where offerinstanceid = '{1}')",
                                                             property,
                                                             offerInstanceId.ToString());
                        command.CommandType = System.Data.CommandType.Text;

                        command.Connection = connection;
                        connection.Open();

                        SqlDataReader r = command.ExecuteReader();

                        if (r.Read())
                        {
                            if (r.IsDBNull(r.GetOrdinal(property)))
                            {
                                return string.Empty;
                            }
                            else
                            {
                                return r.GetInt32(r.GetOrdinal(property)).ToString();
                            }
                        }
                        else
                        {
                            return string.Empty;
                        }
                    }
                default:
                    throw new Exception(String.Format("Unexpected property [{0}]", property));

            }
        }

        /// <summary>
        /// Resets all of the offer instances to something completely in the past. They should no longer show up
        /// in any roll up return results
        /// </summary>
        private static void ResetAllToPast()
        {
            SetAllProperty("10000000-0000-4001-8000-00001010011C", "2000-01-10T01:29:09", "2001-01-10T01:29:09", 2, 1);
            SetAllProperty("30000000-0000-4001-8000-00001010011C", "2000-01-10T01:29:09", "2001-01-10T01:29:09", 2, 1);
            SetAllProperty("20000000-0000-4001-8000-00001010011C", "2000-01-10T01:29:09", "2001-01-10T01:29:09", 2, 1);
            SetAllProperty("40000000-0000-4001-8000-00001010011C", "2000-01-10T01:29:09", "2001-01-10T01:29:09", 2, 1);
            SetAllProperty("50000000-0000-4001-8000-00001010011C", "2000-01-10T01:29:09", "2001-01-10T01:29:09", 2, 1);

            SetProperty("10000000-0000-4001-8000-00001010011C", "visibilitylevelid", "1");
            SetProperty("20000000-0000-4001-8000-00001010011C", "visibilitylevelid", "1");
            SetProperty("30000000-0000-4001-8000-00001010011C", "visibilitylevelid", "1");
            SetProperty("40000000-0000-4001-8000-00001010011C", "visibilitylevelid", "1");
            SetProperty("50000000-0000-4001-8000-00001010011C", "visibilitylevelid", "1");
        }

        /// <summary>
        /// Validates that there are only X number of expected matches among what is returned
        /// </summary>
        private static void ValidateNumberOfNodes(DocumentResult result, NameValueCollection _namespaces, string xpath, int expectedMatches)
        {
            if (String.IsNullOrEmpty(result.Document))
            {
                throw new Exception(String.Format("Expected to get xml document but got [{0}] for id {1}", result.Document, result.Id));
            }

            XPathDocument document = new XPathDocument(new StringReader(result.Document));
            XPathNavigator navigator = document.CreateNavigator();
            XmlNamespaceManager mngr = new XmlNamespaceManager(new NameTable());
            if (_namespaces != null)
            {
                foreach (String prefix in _namespaces.AllKeys)
                {
                    mngr.AddNamespace(prefix, _namespaces[prefix]);
                }
            }
            XPathNodeIterator iterator = navigator.Select(xpath, mngr);
            int numberOfNodes = 0;
            while (iterator.MoveNext())
            {
                ++numberOfNodes;
            }

            if (numberOfNodes != expectedMatches)
            {
                throw new Exception(String.Format("Expected [{0}] but received [{1}] for xpath [{2}]", expectedMatches, numberOfNodes, xpath));
            }
        }

        /// <summary>
        /// Using an xpath query, determines that the node exists
        /// </summary>
        private static void CheckRollupExists(DocumentResult results, NameValueCollection _namespaces, int offerTargetType, int userType, int store, string startDate, string endDate, int? avatarBodyType)
        {
            // Validates searchableXml
            string avatarBodyPathXpath = avatarBodyType == null ? string.Empty : string.Format("and b:avatarBodyType='{0}'", avatarBodyType);
            string xpath = String.Format("//b:searchableXml//b:childRollup[b:offerTargetType='{0}' and b:tier='{1}' and b:store='{2}' and b:startDate='{3}' and b:endDate='{4}' {5}]", offerTargetType, userType, store, startDate, endDate, avatarBodyPathXpath);
            XmlUtil.ValidateNodeExists(results, xpath, _namespaces);

            // Validates detail level data
            string avatarBodyPathXpathAttribute = avatarBodyType == null ? string.Empty : string.Format("and @avatarBodyType='{0}'", avatarBodyType);
            avatarBodyPathXpath = avatarBodyType == null ? string.Empty : string.Format("and b:avatarBodyType='{0}'", avatarBodyType);
            xpath = String.Format("//b:detaillevel5//b:offerTargetTypes//b:RULE[@startDate='{0}' and @endDate='{1}' and @tiers='{2}' and @offerTargetType='{3}' and @stores='{4}' {5}]//b:offerTargetType[b:mediaType='{6}' and b:tiers='{7}' and b:stores='{8}' {9}]", startDate, endDate, userType, offerTargetType, store, avatarBodyPathXpathAttribute, offerTargetType, userType, store, avatarBodyPathXpath);
            XmlUtil.ValidateNodeExists(results.detaillevel5, xpath, _namespaces);
        }

        /// <summary>
        /// Using an xpath query, determines that the node is not present
        /// </summary>
        private static void CheckRollupDoesNotExist(DocumentResult results, NameValueCollection _namespaces, int offerTargetType, int userType, int store, string startDate, string endDate, int? avatarBodyType)
        {
            string avatarBodyPathXpath = avatarBodyType == null ? string.Empty : string.Format("and b:avatarBodyType='{0}'", avatarBodyType);
            string xpath = String.Format("//b:searchableXml//b:childRollup[b:offerTargetType='{0}' and b:userType='{1}' and b:store='{2}' and b:startDate='{3}' and b:endDate='{4}' {5}]", offerTargetType, userType, store, startDate, endDate, avatarBodyPathXpath);
            XmlUtil.ValidateNodeDoesNotExist(results, xpath, _namespaces);
        }        

        /// <summary>
        /// This validates that a rollup is generated for games themselves
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class Validate_Gond_Rollup : DocumentGenerationTestBase
        {

            public Validate_Gond_Rollup()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66ACD000-77FE-1000-9115-D9026D3B992A"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);
                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 1);

                DateTime startDate1 = new DateTime(2007,1,10,1,29,09);
                DateTime endDate1 = new DateTime(2050, 1, 10, 1, 29, 09);

                CheckRollupExists(results[0], _namespaces, 1, 3, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
            }
        }

        /// <summary>
        /// Scenario covered (Pivot on tier -- with the second not visible):
        /// 2---------
        ///                      3---------
        ///       2---------                            <----- Not a visible offer instance
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class PivotTier_Rollup_Same_Tier_OverLap_Not_Visible : DocumentGenerationTestBase
        {

            public PivotTier_Rollup_Same_Tier_OverLap_Not_Visible()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(1);
                DateTime endDate2 = DateTime.Now.AddYears(4);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);
                SetProperty("40000000-0000-4001-8000-00001010011C", "visibilitylevelid", "3"); // Set it to not be visible -- should not show in rollup
                DateTime startDate3 = DateTime.Now.AddYears(5);
                DateTime endDate3 = DateTime.Now.AddYears(7);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 3, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);
                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 2);

                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), null);
                CheckRollupExists(results[0], _namespaces, 18, 3, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);
            }
        }

        /// <summary>
        /// Scenario covered (Pivot on tier):
        /// 2---------
        ///                      3---------
        ///       2---------
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class PivotTier_Rollup_Same_Tier_OverLap : DocumentGenerationTestBase
        {

            public PivotTier_Rollup_Same_Tier_OverLap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(1);
                DateTime endDate2 = DateTime.Now.AddYears(4);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);
                DateTime startDate3 = DateTime.Now.AddYears(5);
                DateTime endDate3 = DateTime.Now.AddYears(7);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 3, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 2);

                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate2), null);
                CheckRollupExists(results[0], _namespaces, 18, 3, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);
            }
        }

        /// <summary>
        /// Scenario covered (Pivot on tier):
        /// 2---------
        ///                      2---------
        ///       3---------
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class PivotTier_Rollup_Different_Tier_OverLap : DocumentGenerationTestBase
        {

            public PivotTier_Rollup_Different_Tier_OverLap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(1);
                DateTime endDate2 = DateTime.Now.AddYears(4);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 3, 1);
                DateTime startDate3 = DateTime.Now.AddYears(5);
                DateTime endDate3 = DateTime.Now.AddYears(7);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 3);

                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupExists(results[0], _namespaces, 18, 3, 1, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);
            }
        }

        /// <summary>
        /// Scenario covered (Pivot on store):
        /// 1---------
        ///                      2---------
        ///       1---------
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class PivotStore_Rollup_Same_Store_OverLap : DocumentGenerationTestBase
        {

            public PivotStore_Rollup_Same_Store_OverLap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(1);
                DateTime endDate2 = DateTime.Now.AddYears(4);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 2);
                DateTime startDate3 = DateTime.Now.AddYears(5);
                DateTime endDate3 = DateTime.Now.AddYears(7);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 2);

                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 2, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate2), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);
            }
        }

        /// <summary>
        /// Scenario covered (Pivot on store):
        /// 1---------
        ///                      1---------
        ///       2---------
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class PivotStore_Rollup_Different_Store_OverLap : DocumentGenerationTestBase
        {

            public PivotStore_Rollup_Different_Store_OverLap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(1);
                DateTime endDate2 = DateTime.Now.AddYears(4);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 2);
                DateTime startDate3 = DateTime.Now.AddYears(5);
                DateTime endDate3 = DateTime.Now.AddYears(7);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 3);

                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 2, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);
            }
        }


        /// <summary>
        /// Scenario covered:
        /// 47---------
        ///                      47---------
        ///       18---------
        /// 18-------------------------------------      
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class PivotMediaType_Rollup_Two_MediaTypes_Overlap : DocumentGenerationTestBase
        {

            public PivotMediaType_Rollup_Two_MediaTypes_Overlap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 47
                DateTime startDate1 = DateTime.Now.AddYears(-1);
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("10000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(4);
                DateTime endDate2 = DateTime.Now.AddYears(6);
                SetAllProperty("30000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);

                // media type 18
                DateTime startDate3 = DateTime.Now.AddYears(2);
                DateTime endDate3 = DateTime.Now.AddYears(3);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 2, 1);
                DateTime startDate4 = DateTime.Now;
                DateTime endDate4 = DateTime.Now.AddYears(5);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate4), String.Format("{0:s}", endDate4), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 3);

                CheckRollupExists(results[0], _namespaces, 47, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 1);
                CheckRollupExists(results[0], _namespaces, 47, 2, 1, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 1);

                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate4), String.Format("{0:s}", endDate4), null);
            }
        }

        /// Scenario covered:
        /// 18---------
        ///                 18---------      
        ///                                  18---------
        [TestCase, TestCasePriority(1)]
        class Rollup_Three_Continous_With_Gaps : DocumentGenerationTestBase
        {

            public Rollup_Three_Continous_With_Gaps()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 47
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(1);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);

                DateTime startDate2 = DateTime.Now.AddYears(2);
                DateTime endDate2 = DateTime.Now.AddYears(3);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);

                DateTime startDate3 = DateTime.Now.AddYears(4);
                DateTime endDate3 = DateTime.Now.AddYears(5);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 3);

                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);
            }
        }

        /// Scenario covered:
        /// 47---------
        ///                 47---------      
        [TestCase, TestCasePriority(1)]
        class Rollup_No_Overlap : DocumentGenerationTestBase
        {

            public Rollup_No_Overlap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 47
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("10000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);

                DateTime startDate2 = DateTime.Now.AddYears(4);
                DateTime endDate2 = DateTime.Now.AddYears(6);
                SetAllProperty("30000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 2);

                CheckRollupExists(results[0], _namespaces, 47, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 1);
                CheckRollupExists(results[0], _namespaces, 47, 2, 1, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 1);
            }
        }


        /// Scenario covered:
        /// 18---------
        ///        18---------      
        [TestCase, TestCasePriority(1)]
        class Rollup_Overlap : DocumentGenerationTestBase
        {

            public Rollup_Overlap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(1);
                DateTime endDate2 = DateTime.Now.AddYears(4);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 1);

                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate2), null);
            }
        }

        /// Scenario covered:
        /// 18---------
        ///      18---------      
        ///                           18---------                  
        [TestCase, TestCasePriority(1)]
        class Rollup_Three_Continous_With_One_Overlap : DocumentGenerationTestBase
        {

            public Rollup_Three_Continous_With_One_Overlap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(1);
                DateTime endDate2 = DateTime.Now.AddYears(4);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);
                DateTime startDate3 = DateTime.Now.AddYears(6);
                DateTime endDate3 = DateTime.Now.AddYears(8);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", startDate3), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 2);

                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), null);

                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate2), null);
                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", startDate3), null);
            }
        }

        /// Scenario covered:
        /// 18---------
        ///      18---------      
        ///              18---------      
        [TestCase, TestCasePriority(1)]
        class Rollup_Three_Continous_All_Overlap : DocumentGenerationTestBase
        {

            public Rollup_Three_Continous_All_Overlap()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = DateTime.Now.AddYears(1);
                DateTime endDate2 = DateTime.Now.AddYears(3);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);
                DateTime startDate3 = DateTime.Now.AddYears(2);
                DateTime endDate3 = DateTime.Now.AddYears(4);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 1);

                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), null);
                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);

                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate3), null);
            }
        }

        /// Scenario covered:
        /// 18---------
        ///           18---------      
        ///                      18---------      
        [TestCase, TestCasePriority(1)]
        class Rollup_Three_Continous_All_Overlap_Exactly : DocumentGenerationTestBase
        {

            public Rollup_Three_Continous_All_Overlap_Exactly()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // Set properties as expected
                // media type 18
                DateTime startDate1 = DateTime.Now;
                DateTime endDate1 = DateTime.Now.AddYears(2);
                SetAllProperty("20000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), 2, 1);
                DateTime startDate2 = endDate1;
                DateTime endDate2 = endDate1.AddYears(2);
                SetAllProperty("40000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), 2, 1);
                DateTime startDate3 = endDate2;
                DateTime endDate3 = endDate2.AddYears(2);
                SetAllProperty("50000000-0000-4001-8000-00001010011C", String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), 2, 1);

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 1);

                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate1), null);
                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate2), String.Format("{0:s}", endDate2), null);
                CheckRollupDoesNotExist(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate3), String.Format("{0:s}", endDate3), null);

                CheckRollupExists(results[0], _namespaces, 18, 2, 1, String.Format("{0:s}", startDate1), String.Format("{0:s}", endDate3), null);
            }
        }
        
        ///
        /// Scenario covered:
        /// No offers or children with offers
        [TestCase, TestCasePriority(1)]
        class Rollup_No_Rollup_Data : DocumentGenerationTestBase
        {

            public Rollup_No_Rollup_Data()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // This media does not have any offer information present
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8021370001A"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 0);
            }
        }

        ///
        /// Scenario covered:
        /// Game with child with offerinstance not in OfferInstanceMediaInstance
        [TestCase, TestCasePriority(1)]
        class Rollup_No_Rollup_Data_MissingMediaInstance : DocumentGenerationTestBase
        {

            public Rollup_No_Rollup_Data_MissingMediaInstance()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                ResetAllToPast();

                // This media does not have any offer information present
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992C"), 1033)
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                ValidateNumberOfNodes(results[0], _namespaces, "//b:searchableXml//b:childRollup", 0);
            }
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\DocumentGenerationTests\DocumentGenerationTestBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Configuration;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.XPath;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Data.SqlClient;

namespace Marketplace.Test.Common.Service
{

    /// <summary>
    /// Base test class for the Watcher test cases
    /// </summary>
    internal class DocumentGenerationTestBase : TestBase
    {
        protected NameValueCollection attributeInt32 = new NameValueCollection();
        protected NameValueCollection attributeDateTime = new NameValueCollection();
        protected NameValueCollection attributeDouble = new NameValueCollection();
        protected NameValueCollection _namespaces = new NameValueCollection();

        public static string[] fastRatingNonExemptMediaIds { get; set; }
        public static string[] fastRatingNonExemptRatingSystem { get; set; }
        public static string[] fastRatingExemptMediaTypes { get; set; }
        public static string[] fastRatingExemptGCForTitles { get; set; } 

        public static String RawCatalogDBConnectionString
        {
            get;
            private set;
        }

        public static String NPDBConnectionString
        {
            get;
            private set;
        }

        /// <summary>
        /// Constructor for the Watcher tests base class
        /// </summary>
        internal DocumentGenerationTestBase()
        {
            _namespaces.Add("b", "http://marketplace.xboxlive.com/resource/product/v1");
            _namespaces.Add("a", "http://www.w3.org/2005/Atom");

            RawCatalogDBConnectionString = xonline.common.config.Config.GetSingleInterface(xonline.common.config.Interface.ContentIngestionCatalogDB).SqlConnectionString;
            NPDBConnectionString = xonline.common.config.Config.GetSingleInterface(xonline.common.config.Interface.npdb).SqlConnectionString;
            Global.RO.Info(String.Format("Using RawCatalogDB connection string: {0}", RawCatalogDBConnectionString ));
            attributeInt32.Add("type", "int32");
            attributeDateTime.Add("type", "datetime");
            attributeDouble.Add("type", "double");
        }

        public List<DocumentResult> GetDocuments(List<MediaIdLcid> mediaIdLcids)
        {
            return GetDocuments(mediaIdLcids.ToArray());
        }

        public List<DocumentResult> GetDocuments(MediaIdLcid[] mediaIdLcids)
        {
            DataTable items = new DataTable();
            items.Columns.Add(new DataColumn("mediaId", typeof(Guid)));
            items.Columns.Add(new DataColumn("lcid", typeof(Int32)));
            items.Columns.Add(new DataColumn("position", typeof(Int32)));

            Int32 i = 0;
            foreach (MediaIdLcid mediaIdLcid in mediaIdLcids)
            {
                Object[] item = new Object[3];
                item[0] = mediaIdLcid.MediaId;
                item[1] = mediaIdLcid.Lcid;
                item[2] = i;
                i++;

                items.Rows.Add(item);
            }

            return DocumentResult.GetDocuments(items,fastRatingNonExemptMediaIds,fastRatingNonExemptRatingSystem,fastRatingExemptMediaTypes,fastRatingExemptGCForTitles);
        }


        public List<DocumentResult> GetDocumentsWithBasicValidation(MediaIdLcid[] mediaIdLcids)
        {
            List<DocumentResult> results = GetDocuments(mediaIdLcids);

            if (results.Count != mediaIdLcids.Length)
            {
                if (results.Count == 0)
                {
                    throw new Exception( String.Format( "Expected {0} rows back but received zero.", mediaIdLcids.Length) );
                }
                else
                {
                    String message = String.Format("Expected {0} rows back but received {1}", mediaIdLcids.Length, results.Count);
                    foreach (DocumentResult d in results)
                    {
                        Global.RO.Info(String.Format("  productId={0} | lcid={1}"), d.ProductId, d.Lcid);
                    }
                    throw new Exception( message );
                }
            }

            foreach (DocumentResult result in results)
            {
                if (String.IsNullOrEmpty(result.Document))
                {
                    throw new Exception(String.Format("Expected document but received null or empty document for mediaIdLcid tuple [{0}]", result.Id ));
                }
            }

            return results;
        }

        public void CheckTrue(bool istrue)
        {
            if (!istrue)
            {
                throw new Exception("Statement did not evaluate to true");
            }
        }


        protected override void Execute() { }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\DocumentGenerationTests\ProductDocumentXsltTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Diagnostics;
using System.Collections.Specialized;
using System.Xml.XPath;
using System.Xml;
using System.Xml.Xsl;
using System.Data.SqlTypes;
using System.Collections;

using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.service;
using Marketplace.Test.Common.Service;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("craigta"), TestFrequency("Daily"), EnvRequirement("xblobonly")]
    public class ProductDocumentXsltTests
    {
        static ArrayList _transforms = new ArrayList();
        class DocumentTransform
        {
            public XslCompiledTransform transform;
            public string targetDetailView;
            public string sourceDetailView;
            public DocumentTransform(string targetDetailView, string sourceDetailView, XslCompiledTransform xslTransform)
            {
                transform = xslTransform;
                this.sourceDetailView = sourceDetailView;
                this.targetDetailView = targetDetailView;
            }
        }        

        [TestGroupSetup]
        public void Setup()
        {
            using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
            {
                sqlClient.StoredProc = "dbo.p_catalog_watcher_get_detailviews";
                SqlDataReader reader = sqlClient.Execute();

                while (reader.Read())
                {
                    string targetDetailView = reader["vc_target_detailview"].ToString();
                    string sourceDetailView = reader["vc_source_detailview"].ToString();
                    int ordinal = reader.GetOrdinal("xml_transform");
                    SqlXml detailTransform = reader.GetSqlXml(ordinal);

                    XslCompiledTransform xslTransform = new XslCompiledTransform();
                    xslTransform.Load(detailTransform.CreateReader());

                    _transforms.Add(new DocumentTransform(targetDetailView, sourceDetailView, xslTransform));
                }
                reader.Close();
            }
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        private static string RetrieveTransform(string sourceDoc, string sourceView, string targetView)
        {
            foreach (DocumentTransform transform in _transforms)
            {
                if (transform.sourceDetailView == sourceView && transform.targetDetailView == targetView)
                {
                    StringBuilder sbOutput = new StringBuilder();
                    XPathDocument xmlDoc = new XPathDocument(new StringReader(sourceDoc));

                    transform.transform.Transform(xmlDoc, XmlWriter.Create(sbOutput));
                    return sbOutput.ToString();
                }
            }
            return "";
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_transform_detaillevel5_to_mobile : DocumentGenerationTestBase
        {

            public ProductDocument_transform_detaillevel5_to_mobile()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992A"), 1033 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                // Turn the detail level 5 into the mobile detail level
                string targetView = RetrieveTransform(results[0].detaillevel5.Document, "detaillevel5", "mobile");
                DetailLevel targetDetailLevel = new DetailLevel();
                targetDetailLevel.Document = targetView;
                targetDetailLevel.Lcid = results[0].Lcid;
                targetDetailLevel.ProductId = results[0].ProductId;

                //Validate the transformed detail level
                XmlUtil.ValidateNodeExists(targetDetailLevel, "//b:detaillevelmobilepdlc//a:updated", _namespaces);

                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//a:title", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//a:id", "urn:uuid:66ACD000-77FE-1000-9115-D8026D3B992A".ToLower(), _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//a:content", "game content", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:reducedDescription", "Basic GonD with Offer.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:visibilityDate", "2007-01-10T01:29:09", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:gameReducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:titleId", "1481770961", _namespaces);

                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:productType", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:reducedTitle", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:fullTitle", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:fullDescription", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:customGenre", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:developerName", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:publisherName", _namespaces);                
                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:userRating", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(targetDetailLevel, "//b:detaillevelmobilepdlc//b:numberOfRatings", _namespaces);

                // Categories
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:categories//b:category[b:categoryId='3000']//b:categoryName", "Game Genres", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:categories//b:category[b:categoryId='3013' and b:parentCategoryId='3027']//b:categoryName", "Sports & Recreation", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:categories//b:category[b:categoryId='3027' and b:parentCategoryId='3000']//b:categoryName", "Xbox LIVE Games", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:categories//b:category[b:categoryId='4075']//b:categoryName", "Electronic Arts", _namespaces);

                XPathNodeIterator iterator = null;
                iterator = XmlUtil.GetXmlIteratorWithValue(targetDetailLevel, "//b:detaillevelmobilepdlc//b:offerInstances//b:RULE//b:offerInstance//b:offerInstanceId", "urn:uuid:00000000-0000-4001-8000-00001010001a", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "urn:uuid:00000000-0047-4000-8000-00001010111a", "http://marketplace.xboxlive.com/resource/product/v1");
                NameValueCollection priceAttributes = new NameValueCollection();
                priceAttributes.Add("paymentTypeId", "1");
                XmlUtil.ValidateNodeExistsWithAttributes(targetDetailLevel, "//b:detaillevelmobilepdlc//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000000-0000-4001-8000-00001010001a']//b:offerInstance//b:price", priceAttributes, _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", null, "200.0000", "http://marketplace.xboxlive.com/resource/product/v1");

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\UnitTests\PublisherAzureStorageTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.server.catalogwatcher;
using Microsoft.MMF;
using System.Diagnostics;
using xonline.common.service;
using System.Reflection;
using System.IO;
using xonline.common.config;
using Microsoft.WindowsAzure.StorageClient;
using Microsoft.WindowsAzure;

namespace UnitTests
{
    /// <summary>
    /// Unit tests for the PublisherAzureStorage
    /// </summary>
    [TestClass]
    public class PublisherAzureStorageTests
    {
        // our dear publisher, the subject under test
        private PublisherAzureStorageMock publisher;

        // test configuration settings
        private Settings config = Settings.Default;
 
        // our mmf test reference
        private MimicTest<PublisherAzureStorage> test;

        // used to hold a reference to the private field inside the publisher that keeps a list of pending documents to publish
        private Dictionary<String, IWatcherDocument> pendingDocuments;

        public Dictionary<String, IWatcherDocument> PendingDocuments
        {
            get
            {
                if (pendingDocuments == null)
                {
                    PrivateObject po = new PrivateObject(publisher);
                    pendingDocuments = (Dictionary<String, IWatcherDocument>)po.GetField("_pendingDocuments");
                }
                return pendingDocuments;
            }
        }

        [TestInitialize()]
        public void MyTestInitialize() 
        {
            // us our test implementation of the Publisher that won't actually write to Azure
            publisher = new PublisherAzureStorageMock();
            
            // set up our mmf test object
            test = new MimicTest<PublisherAzureStorage>(publisher);

            // tell it to intercept the proxy setting call
            var configStubMimic = StubFactory.CreateStatic(typeof(Config));
            configStubMimic.Returns(String.Empty).On(() => Config.GetSetting(Setting.billing_proxy));
            test.RedirectsStaticMethodsByCalling(configStubMimic);

            // initialize the publisher
            test.Test(t => publisher.Init(1, 2));
        }

        [TestCleanup()]
        public void MyTestCleanup()
        {
            publisher.Dispose();
        }

        [TestMethod]
        public void TestPublishDocument()
        {
            // increase the scope of MMF to include this assembly
            test.RedirectsInto(typeof(PerformanceCounter).Assembly);

            // now publisher the vid doc
            VideoDocument doc = WatcherDocumentFactory.CreateVideoDocument();
            test.Test(t => t.PublishDocument(doc));

            // validate
            Assert.AreEqual(1, this.PendingDocuments.Count);
        }

        [TestMethod]
        public void TestPublishAndFlushDocuments()
        {
            TestPublishDocument();

            // flush the documents
            test.Test(t => t.FlushDocuments());

            string fileName = publisher.GetLastFileName();

            // make sure the file was given a name and had some contents
            Assert.IsFalse(String.IsNullOrEmpty(publisher.GetLastFileName()), "The file name was null or empty");
            Assert.IsFalse(String.IsNullOrEmpty(publisher.GetLastFileContents()), "The file had no contents");

            // make sure there are no more pending documents
            Assert.AreEqual(0, this.PendingDocuments.Count, "There was not 0 pending documents");
        }

        [TestMethod]
        public void TestFlushDocumentsNonePublished()
        {
            // validate
            Assert.AreEqual(0, this.PendingDocuments.Count, "There was not 0 pending documents");

            // flush the documents
            test.Test(t => t.FlushDocuments());

            // validate
            Assert.AreEqual(0, this.PendingDocuments.Count, "There was not 0 pending documents");
        }

        [TestMethod]
        public void TestPublishDocumentNull()
        {
            VideoDocument doc = null;
            assertPublishException(publisher, doc, typeof(XRLException), "Document is null");
        }

        [TestMethod]
        public void TestPublishDocumentDataNull()
        {
            VideoDocument doc = WatcherDocumentFactory.CreateVideoDocument(null);
            assertPublishException(publisher, doc, typeof(XRLException), "Document data is null");
        }

        [TestMethod]
        public void TestPublishDocumentDataEmpty()
        {
            VideoDocument doc = WatcherDocumentFactory.CreateVideoDocument(String.Empty);
            assertPublishException(publisher, doc, typeof(XRLException), "Error submitting documents to Azure Storage: document being submitted is an empty string");
        }


        [TestMethod]
        public void TestPublishDocumentWrongType()
        {
            MediaDocument doc = WatcherDocumentFactory.CreateMediaDocument();
            assertPublishException(publisher, doc, typeof(XRLException), "Error submitting documents to Azure Storage: document being submitted is not an instance of type 'VideoDocument'");
        }

        private void assertPublishException(PublisherAzureStorage publisher, IWatcherDocument doc, Type exceptionType, string exceptionMessage)
        {
            try
            {
                publisher.PublishDocument(doc);
            }
            catch (Exception e)
            {
                Assert.IsInstanceOfType(e, exceptionType);
                Assert.AreEqual(exceptionMessage, e.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\UnitTests\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4959
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace UnitTests {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("Video")]
        public string VideoResourceName {
            get {
                return ((string)(this["VideoResourceName"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("Azure")]
        public string VideoDestinationName {
            get {
                return ((string)(this["VideoDestinationName"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("Media")]
        public string MediaResourceName {
            get {
                return ((string)(this["MediaResourceName"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("ESP")]
        public string MediaDestinationName {
            get {
                return ((string)(this["MediaDestinationName"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\UnitTests\DocumentPublisherFactoryTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.server.catalogwatcher;
using xonline.common.service;

namespace UnitTests
{
    /// <summary>
    /// Summary description for FactoryTests
    /// </summary>
    [TestClass]
    public class DocumentPublisherFactoryTests
    {
        // configuration settings
        private Settings config = Settings.Default;

        [TestMethod]
        public void TestPublisherAzureStorageCreation()
        {
            using (IWatcherDocumentPublisher publisher = DocumentPublisherFactory.CreatePublisher(
                config.VideoResourceName,
                config.VideoDestinationName))
            {
                Assert.IsNotNull(publisher as PublisherAzureStorage);
            }
        }

        [TestMethod]
        public void TestPublisherEspCreation()
        {
            using (IWatcherDocumentPublisher publisher = DocumentPublisherFactory.CreatePublisher(
                config.MediaResourceName,
                config.MediaDestinationName))
            {
                Assert.IsNotNull(publisher as PublisherEsp);
            }
        }

        [TestMethod]
        [ExpectedException(typeof(XRLException), "Invalid resourceName passed to the DetectorFactory Fake")]
        public void TestInvalidResourceCreation()
        {
            using (IWatcherDocumentPublisher publisher = DocumentPublisherFactory.CreatePublisher(
                "Fake",
                config.VideoDestinationName)) { }
        }

        [TestMethod]
        [ExpectedException(typeof(XRLException), "Invalid destination passed to the DetectorFactory Fake")]
        public void TestInvalidDestinationCreation()
        {
            using (IWatcherDocumentPublisher publisher = DocumentPublisherFactory.CreatePublisher(
                config.MediaResourceName,
                "Fake")) { }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\scripts\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_cleanserscripts_none_12.4.56.0_none_7af6294451cfe5f1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cleanserscripts
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807.manifest
XP_MANIFEST_PATH=manifests\x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807.cat
XP_CATALOG_PATH=manifests\x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807.cat
XP_PAYLOAD_PATH=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cleanserscripts,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\UnitTests\WatcherDocumentFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.server.catalogwatcher;

namespace UnitTests
{
    /// <summary>
    /// Class for creating objects with a default set of test data
    /// </summary>
    public class WatcherDocumentFactory
    {
        public static VideoDocument CreateVideoDocument()
        {
            return CreateVideoDocument("Document");
        }

        public static VideoDocument CreateVideoDocument(string document)
        {
            LSN lsn = new LSN("1");
            MediaIdLcid tuple = new MediaIdLcid(lsn, Guid.NewGuid(), 10);
            VideoDocument doc = new VideoDocument(tuple, document);
            return doc;
        }

        public static MediaDocument CreateMediaDocument()
        {
            LSN lsn = new LSN("1");
            MediaIdLcid tuple = new MediaIdLcid(lsn, Guid.NewGuid(), 10);
            MediaDocument doc = new MediaDocument(Guid.NewGuid(), 1, lsn, "Test");
            doc.Document = "Document";

            return doc;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\scripts\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_cleanserscripts_none_12.4.56.0_none_7af6294451cfe5f1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cleanserscripts
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807.manifest
XP_MANIFEST_PATH=manifests\x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807.cat
XP_CATALOG_PATH=manifests\x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807.cat
XP_PAYLOAD_PATH=x86_cleanserscripts_no-public-key_12.4.56.0_x-ww_3dc8e807
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cleanserscripts,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\DocumentGenerationTests\ProductDocumentGenerationTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Diagnostics;
using System.Collections.Specialized;
using System.Xml.XPath;

using Marketplace.Test.Common.Service;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("ajaffray"), TestFrequency("Daily"), EnvRequirement("xblobonly")]
    public class ProductDocumentGenerationTests
    {
        [TestGroupSetup]
        public void Setup()
        {
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_Basic_Game : DocumentGenerationTestBase
        {

            public ProductDocument_Basic_Game()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992A"), 1033 )
                };
                                                
                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);
                XPathNodeIterator iterator = null;
                                
                CheckTrue(results[0].SortTitle == "Title sort for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer, A");
                CheckTrue(results[0].UserRating == 3.00);
                CheckTrue(results[0].SearchTitle == String.Format(
                        "{0} {1}",
                        "Title for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer",
                        "Basic GonD with Offer"));
                
                // Download counters
                CheckTrue(results[0].DownloadCountAllTimeFreeAndPaid == 5000);
                CheckTrue(results[0].DownloadCountAllTimePaid == 4000);
                CheckTrue(results[0].DownloadCountTodayFreeAndPaid == 500);
                CheckTrue(results[0].DownloadCountTodayPaid == 400);

                CheckTrue(results[0].ParentProductNavigator == "~Title sort for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer, A#Basic GonD with Offer#66acd000-77fe-1000-9115-d8026d3b992a");

                // Most recent offer start date
                // Most recent offer start date
                DateTime dt = new DateTime(2010, 1, 10, 01, 29, 09); //"2010-01-10T01:29:09Z"
                CheckTrue(DateTime.Compare(results[0].MostRecentOfferStartDate, dt) == 0);              
                
                // Validate the searchable Xml
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:title", "Title for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:locale", "en-US", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:language", "en", _namespaces);
                XmlUtil.ValidateNodeExists(results[0], "//b:searchableXml//b:updated", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:productId", null, "66ACD000-77FE-1000-9115-D8026D3B992A", _namespaces);                
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:productType", attributeInt32, "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:visibilityStatusId", attributeInt32, "3", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:reducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:reducedDescription", "Basic GonD with Offer.", _namespaces);
                //XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//fullTitle", "Title for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer");
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:fullDescription", "Description for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer. All Download Counts are present.", _namespaces);                
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:letterJump", "T", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:isGameBrowsable", attributeInt32, "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:exactRatingId", attributeInt32, "30", _namespaces);
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:acceptableRatingIds//b:acceptableRatingId", "30", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "acceptableRatingId", attributeInt32, "40", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "acceptableRatingId", attributeInt32, "50", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "acceptableRatingId", attributeInt32, "60", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:ratingDescriptors//b:ratingDescriptor", "0", _namespaces);
                NameValueCollection attributeRatingDescriptor = new NameValueCollection();
                attributeRatingDescriptor.Add("level", "1.0000");
                attributeRatingDescriptor.Add(attributeInt32);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "ratingDescriptor", attributeRatingDescriptor, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:customGenre", "CustomShooter", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:developerName", "Microsoft Corp.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:publisherName", "Microsoft Corp.", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:titleId", attributeInt32, "1481770961", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:hexTitleId", "0x585207d1", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:effectiveTitleId", attributeInt32, "1481770961", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:avatarBodyType", attributeInt32, "0", _namespaces);

                //Offer Instances                
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:offerInstances//b:offerInstance//b:offerInstanceId", "00000000-0000-4001-8000-00001010001A", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "00000000-0047-4000-8000-00001010111A", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", attributeDateTime, "2007-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", attributeDateTime, "2050-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");                
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "visibilityLevel", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", attributeDouble, "200.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", attributeInt32, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:offerInstances//b:offerInstance//b:offerInstanceId", "00000300-0000-4001-8000-00001010001A", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "00000000-0047-4000-8000-00001010111A", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "hexOfferId", null, "0x1010111a00000000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", attributeDateTime, "2008-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", attributeDateTime, "2050-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "visibilityLevel", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", attributeDouble, "400.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", attributeInt32, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", attributeInt32, "3", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");

                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:offerInstances//b:offerInstance//b:offerInstanceId", "00000600-0000-4001-8000-00001010001A", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "00000000-0047-4000-8000-00001010111A", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "hexOfferId", null, "0x1010111a00000000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", attributeDateTime, "2010-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", attributeDateTime, "2053-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "visibilityLevel", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", attributeDouble, "100.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", attributeInt32, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");

                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:offerInstances//b:offerInstance//b:offerInstanceId", "00000700-0000-4001-8000-00001010001A", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "00000000-0047-4000-8000-00001010111A", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "hexOfferId", null, "0x1010111a00000000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", attributeDateTime, "2010-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", attributeDateTime, "2053-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "visibilityLevel", attributeInt32, "3", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", attributeDouble, "50.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", attributeInt32, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                // Since the offerInstance is not in the OfferInstanceMediaInstance table, this offer should not be returned
                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:offerInstances[b:offerInstance//b:offerInstanceId='00000800-0000-4001-8000-00001010001A']", _namespaces);

                // Categories
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:category//b:categoryId", "3000", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "categoryId", attributeInt32, "3013", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "categoryId", attributeInt32, "3027", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "categoryId", attributeInt32, "4075", "http://marketplace.xboxlive.com/resource/product/v1");


                //parent products
                XmlUtil.ValidateNodeExists(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentProductId='66ACD000-77FE-1000-9115-D8026D3B992A']", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributes(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentProductType='1']//b:parentProduct//b:parentProductType", attributeInt32, _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributes(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentRelationshipType='2']//b:parentProduct//b:parentRelationshipType", attributeInt32, _namespaces);

                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:platformTypeId", attributeInt32, "1", _namespaces);

                // Validate the 'detaillevel5' node
                XmlUtil.ValidateNodeExists(results[0].detaillevel5, "//b:detaillevel5//a:updated", _namespaces);

                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:title", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:id", "urn:uuid:66ACD000-77FE-1000-9115-D8026D3B992A".ToLower(), _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:content", "game content", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:productType", "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:reducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:reducedDescription", "Basic GonD with Offer.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:fullTitle", "Title for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:fullDescription", "Description for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer. All Download Counts are present.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:visibilityDate", "2007-01-10T01:29:09", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:globalOriginalReleaseDate", "2007-01-10T01:29:09", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:ratingId", "30", _namespaces);
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0].detaillevel5, "//b:detaillevel5//b:ratingDescriptors//b:ratingDescriptor", "0", _namespaces);
                attributeRatingDescriptor = new NameValueCollection();
                attributeRatingDescriptor.Add("level", "1.0000");      
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "ratingDescriptor", attributeRatingDescriptor, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:customGenre", "CustomShooter", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:developerName", "Microsoft Corp.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:publisherName", "Microsoft Corp.", _namespaces);                
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:titleId", "1481770961", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:gameReducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:userRating", "3.00", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:numberOfRatings", "1000", _namespaces);
                // OfferInstances
                
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE//b:offerInstance//b:offerInstanceId", "urn:uuid:00000000-0000-4001-8000-00001010001a", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "urn:uuid:00000000-0047-4000-8000-00001010111a", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", null, "2007-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", null, "2050-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                NameValueCollection priceAttributes = new NameValueCollection();
                priceAttributes.Add("paymentTypeId", "1");
                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000000-0000-4001-8000-00001010001a']//b:offerInstance//b:price", priceAttributes, _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", null, "200.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", null, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                
                NameValueCollection ruleAttributes = new NameValueCollection();
                ruleAttributes.Add("startDate", "2007-01-10T01:29:09Z");
                ruleAttributes.Add("endDate", "2050-01-10T01:29:09Z");
                ruleAttributes.Add("tiers", "2;");
                ruleAttributes.Add("stores", "1;2;");
                ruleAttributes.Add("visibilityLevel", "1");

                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000000-0000-4001-8000-00001010001a']", ruleAttributes, _namespaces);

                iterator = XmlUtil.GetXmlIteratorWithValue(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE//b:offerInstance//b:offerInstanceId", "urn:uuid:00000300-0000-4001-8000-00001010001a", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "urn:uuid:00000000-0047-4000-8000-00001010111a", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", null, "2008-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", null, "2050-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                priceAttributes = new NameValueCollection();
                priceAttributes.Add("paymentTypeId", "1");
                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000000-0000-4001-8000-00001010001a']//b:offerInstance//b:price", priceAttributes, _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", null, "400.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", null, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", null, "3", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");

                ruleAttributes = new NameValueCollection();
                ruleAttributes.Add("startDate", "2008-01-10T01:29:09Z");
                ruleAttributes.Add("endDate", "2050-01-10T01:29:09Z");
                ruleAttributes.Add("tiers", "3;");
                ruleAttributes.Add("stores", "1;2;");
                ruleAttributes.Add("visibilityLevel", "1");


                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000300-0000-4001-8000-00001010001a']", ruleAttributes, _namespaces);

                ruleAttributes = new NameValueCollection();
                ruleAttributes.Add("startDate", "2010-01-10T01:29:09Z");
                ruleAttributes.Add("endDate", "2053-01-10T01:29:09Z");
                ruleAttributes.Add("stores", "1;2;");
                ruleAttributes.Add("visibilityLevel", "2");

                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000600-0000-4001-8000-00001010001a']", ruleAttributes, _namespaces);

                iterator = XmlUtil.GetXmlIteratorWithValue(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE//b:offerInstance//b:offerInstanceId", "urn:uuid:00000600-0000-4001-8000-00001010001a", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "urn:uuid:00000000-0047-4000-8000-00001010111a", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", null, "2010-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", null, "2053-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                priceAttributes = new NameValueCollection();
                priceAttributes.Add("paymentTypeId", "1");
                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000600-0000-4001-8000-00001010001a']//b:offerInstance//b:price", priceAttributes, _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", null, "100.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", null, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");

                ruleAttributes = new NameValueCollection();
                ruleAttributes.Add("startDate", "2010-01-10T01:29:09Z");
                ruleAttributes.Add("endDate", "2053-01-10T01:29:09Z");
                ruleAttributes.Add("stores", "1;2;");
                ruleAttributes.Add("visibilityLevel", "2");


                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000600-0000-4001-8000-00001010001a']", ruleAttributes, _namespaces);

                iterator = XmlUtil.GetXmlIteratorWithValue(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE//b:offerInstance//b:offerInstanceId", "urn:uuid:00000700-0000-4001-8000-00001010001a", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "urn:uuid:00000000-0047-4000-8000-00001010111a", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", null, "2010-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", null, "2053-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                priceAttributes = new NameValueCollection();
                priceAttributes.Add("paymentTypeId", "1");
                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000700-0000-4001-8000-00001010001a']//b:offerInstance//b:price", priceAttributes, _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", null, "50.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", null, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");

                ruleAttributes = new NameValueCollection();
                ruleAttributes.Add("startDate", "2010-01-10T01:29:09Z");
                ruleAttributes.Add("endDate", "2053-01-10T01:29:09Z");
                ruleAttributes.Add("stores", "1;2;");
                ruleAttributes.Add("visibilityLevel", "3");

                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000700-0000-4001-8000-00001010001a']", ruleAttributes, _namespaces);


                //parent products
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:parentProducts[b:parentProduct//b:parentProductId='66acd000-77fe-1000-9115-d8026d3b992a']//b:parentProduct//b:parentReducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:parentProducts[b:parentProduct//b:parentProductId='66acd000-77fe-1000-9115-d8026d3b992a']//b:parentProduct//b:parentSortOrder", "1", _namespaces);

                // Categories
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:categories//b:category[b:categoryId='3000']//b:categoryName", "Game Genres", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:categories//b:category[b:categoryId='3013' and b:parentCategoryId='3027']//b:categoryName", "Sports & Recreation", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:categories//b:category[b:categoryId='3027' and b:parentCategoryId='3000']//b:categoryName", "Xbox LIVE Games", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:categories//b:category[b:categoryId='4075']//b:categoryName", "Electronic Arts", _namespaces);

                // Video previews
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:videoInstanceId", "203D042D-982E-46D3-B0BF-042E21683A04", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:videoDefinition", "HD", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:videoEncoding", "WMV HD", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:audioEncoding", "Dolby Digital", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:isAcquirable", "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:aspectRatio", "1.78:1", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:resolution", "1080p", _namespaces);

                // Video files
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:files//b:file//b:index", "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:files//b:file//b:fileUrl", "http://microsoft.com", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:files//b:file//b:fileSize", "19290", _namespaces);
                
            }           
        }


        [TestCase, TestCasePriority(1)]
        class ProductDocument_Basic_Game_JAPAN : DocumentGenerationTestBase
        {

            public ProductDocument_Basic_Game_JAPAN()
                : base()
            {
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992A"), 1041 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);
                XPathNodeIterator iterator = null;

                CheckTrue(results[0].SortTitle == "Title sort for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer, 役割");
                CheckTrue(results[0].UserRating == 4.00);
                CheckTrue(results[0].SearchTitle == String.Format(
                        "{0} {1} {2}",
                        "役割 Title for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer",
                        "Basic GonD with Offer",
                        "Title sort for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer, 役割"));

                // Download counters
                CheckTrue(results[0].DownloadCountAllTimeFreeAndPaid == 5001);
                CheckTrue(results[0].DownloadCountAllTimePaid == 6000);
                CheckTrue(results[0].DownloadCountTodayFreeAndPaid == 600);
                CheckTrue(results[0].DownloadCountTodayPaid == 600);
                CheckTrue(results[0].ParentProductNavigator == "~Title sort for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer, 役割#Basic GonD with Offer#66acd000-77fe-1000-9115-d8026d3b992a");

                // Most recent offer start date
                DateTime dt = new DateTime(2010, 1, 10, 01, 29, 09); //"2010-01-10T01:29:09Z"
                CheckTrue(DateTime.Compare(results[0].MostRecentOfferStartDate, dt) == 0);              
                
                // Validate the searchable Xml
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:title", "役割 Title for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:locale", "ja-JP", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:language", "ja", _namespaces);
                XmlUtil.ValidateNodeExists(results[0], "//b:searchableXml//b:updated", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:productId", "66ACD000-77FE-1000-9115-D8026D3B992A", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:productType", attributeInt32, "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:visibilityStatusId", attributeInt32, "3", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:reducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:reducedDescription", "Basic GonD with Offer.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:fullDescription", "Description for 役割 Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:letterJump", "T", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:isGameBrowsable", attributeInt32, "0", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:exactRatingId", "100", _namespaces);
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:acceptableRatingIds//b:acceptableRatingId", "100", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "acceptableRatingId", attributeInt32, "110", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "acceptableRatingId", attributeInt32, "120", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "acceptableRatingId", attributeInt32, "130", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "acceptableRatingId", attributeInt32, "140", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:customGenre", "CustomShooter", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:developerName", "Microsoft", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:publisherName", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:titleId", attributeInt32, "1481770961", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:hexTitleId", "0x585207d1", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:effectiveTitleId", attributeInt32, "1481770961", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:avatarBodyType", attributeInt32, "0", _namespaces);

                //Offer Instances                
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:offerInstances//b:offerInstance//b:offerInstanceId", "00000200-0000-4001-8000-00001010001A", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "00000000-0047-4000-8000-00001010111A", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", attributeDateTime, "2009-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", attributeDateTime, "2052-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "visibilityLevel", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", attributeDouble, "300.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:offerInstances//b:offerInstance//b:offerInstanceId", "00000500-0000-4001-8000-00001010001A", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "00000000-0047-4000-8000-00001010111A", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", attributeDateTime, "2010-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", attributeDateTime, "2053-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "visibilityLevel", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", attributeDouble, "600.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", attributeInt32, "3", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();


                //parent products
                XmlUtil.ValidateNodeExists(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentProductId='66ACD000-77FE-1000-9115-D8026D3B992A']", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributes(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentProductType='1']//b:parentProduct//b:parentProductType", attributeInt32, _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributes(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentRelationshipType='2']//b:parentProduct//b:parentRelationshipType", attributeInt32, _namespaces);

                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:platformTypeId", attributeInt32, "1", _namespaces);
                
                // Validate the 'detaillevel5' node
                XmlUtil.ValidateNodeExists(results[0].detaillevel5, "//b:detaillevel5//a:updated", _namespaces);

                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:title", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:id", "urn:uuid:66ACD000-77FE-1000-9115-D8026D3B992A".ToLower(), _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:content", "game content", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:productType", "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:reducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:reducedDescription", "Basic GonD with Offer.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:fullTitle", "役割 Title for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:fullDescription", "Description for 役割 Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:visibilityDate", "2007-01-10T01:29:09", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:ratingId", "100", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:customGenre", "CustomShooter", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:developerName", "Microsoft", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:publisherName", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:titleId", "1481770961", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:gameReducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:userRating", "0.00", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:numberOfRatings", "0", _namespaces);
                // OfferInstances
                iterator = XmlUtil.GetXmlIteratorWithValue(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE//b:offerInstance//b:offerInstanceId", "urn:uuid:00000200-0000-4001-8000-00001010001a", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "urn:uuid:00000000-0047-4000-8000-00001010111a", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", null, "2009-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", null, "2052-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                NameValueCollection priceAttributes = new NameValueCollection();
                priceAttributes.Add("paymentTypeId", "1");
                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000200-0000-4001-8000-00001010001a']//b:offerInstance//b:price", priceAttributes, _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", null, "300.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");

                NameValueCollection ruleAttributes = new NameValueCollection();
                ruleAttributes.Add("startDate", "2009-01-10T01:29:09Z");
                ruleAttributes.Add("endDate", "2052-01-10T01:29:09Z");
                ruleAttributes.Add("tiers", "2;");
                ruleAttributes.Add("stores", "1;2;");
                ruleAttributes.Add("visibilityLevel", "1");

                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000200-0000-4001-8000-00001010001a']", ruleAttributes, _namespaces);

                iterator = XmlUtil.GetXmlIteratorWithValue(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE//b:offerInstance//b:offerInstanceId", "urn:uuid:00000500-0000-4001-8000-00001010001a", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "urn:uuid:00000000-0047-4000-8000-00001010111a", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", null, "2010-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", null, "2053-01-10T01:29:09Z", "http://marketplace.xboxlive.com/resource/product/v1");
                priceAttributes = new NameValueCollection();
                priceAttributes.Add("paymentTypeId", "1");
                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000200-0000-4001-8000-00001010001a']//b:offerInstance//b:price", priceAttributes, _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", null, "600.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", null, "3", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", null, "2", "http://marketplace.xboxlive.com/resource/product/v1");

                ruleAttributes = new NameValueCollection();
                ruleAttributes.Add("startDate", "2010-01-10T01:29:09Z");
                ruleAttributes.Add("endDate", "2053-01-10T01:29:09Z");
                ruleAttributes.Add("tiers", "3;");
                ruleAttributes.Add("stores", "1;2;");
                ruleAttributes.Add("visibilityLevel", "1");

                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:parentProducts[b:parentProduct//b:parentProductId='66acd000-77fe-1000-9115-d8026d3b992a']//b:parentProduct//b:parentReducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:parentProducts[b:parentProduct//b:parentProductId='66acd000-77fe-1000-9115-d8026d3b992a']//b:parentProduct//b:parentSortOrder", "1", _namespaces);

                XmlUtil.ValidateNodeExistsWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances//b:RULE[b:offerInstance//b:offerInstanceId='urn:uuid:00000500-0000-4001-8000-00001010001a']", ruleAttributes, _namespaces);

                // Video previews
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:videoInstanceId",  _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:videoDefinition",  _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:videoEncoding",  _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:audioEncoding",  _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:isAcquirable", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:aspectRatio",  _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:resolution",  _namespaces);

                // Video files
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:files//b:file//b:index",  _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:files//b:file//b:fileUrl",  _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:videoPreviewInstance//b:files//b:file//b:fileSize", _namespaces);

            }
        }


        /// <summary>
        /// Used to validate the 'inherit rating' concept in the case where a parent game has a rating
        /// </summary>
        [TestCase, Owner("craigta"), TestCasePriority(1)]
        class ProductDocument_offer_instance_start_date : DocumentGenerationTestBase
        {
            public ProductDocument_offer_instance_start_date() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8026D3B992A"), 3084 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                CheckTrue(results[0].SortTitle == "Title sort for Marketplace Costco UnitTest GetProductDocument Basic GonD with Offer, Le");
                // Download counters
                CheckTrue(results[0].DownloadCountAllTimeFreeAndPaid == 20);
                CheckTrue(results[0].DownloadCountAllTimePaid == 20);
                CheckTrue(results[0].DownloadCountTodayFreeAndPaid == 10);
                CheckTrue(results[0].DownloadCountTodayPaid == 10);

                // Most recent offer start date
                DateTime dt = new DateTime(2017, 1, 10, 01, 29, 09); //"2017-01-10T01:29:09"
                CheckTrue(DateTime.Compare(results[0].MostRecentOfferStartDate, dt) == 0);     
            }
        }   


        [TestCase, TestCasePriority(1)]
        class ProductDocument_Basic_GameAddOn : DocumentGenerationTestBase
        {
            public ProductDocument_Basic_GameAddOn() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("00000000-0000-406E-80C0-86836D3B992A"), 1033 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                CheckTrue(results[0].UserRating == 2.00);

                // Validate the searchable Xml
                XmlUtil.ValidateNodeExists(results[0], "//b:searchableXml//b:fullDescription", _namespaces);

                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:locale", "en-US", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:language", "en", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:title", "Title for Marketplace Costco UnitTest GetProductDocuments Downloadble content for basic game", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:platformTypeId", attributeInt32, "0", _namespaces);

                // Validate the 'detaillevel5' node
                XmlUtil.ValidateNodeExists(results[0].detaillevel5, "//b:detaillevel5//a:updated", _namespaces);

                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:title", "content for basic game", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:id", "urn:uuid:00000000-0000-406E-80C0-86836D3B992A".ToLower(), _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//a:content", "game content", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:productType", "18", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:reducedTitle", "content for basic game", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:reducedDescription", "Downloadble content for basic game.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:fullTitle", "Title for Marketplace Costco UnitTest GetProductDocuments Downloadble content for basic game", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:fullDescription", "Description for Marketplace Costco UnitTest GetProductDocuments Downloadble content for basic game.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:visibilityDate", "2007-01-10T01:29:09", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:customGenre", "CustomShooter", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:developerName", "Microsoft Corp.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:publisherName", "Microsoft Corp.", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:titleId", "1481770961", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:gameReducedTitle", "Basic GonD with Offer", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:userRating", "2.00", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:numberOfRatings", "1000", _namespaces);
            }
        }

        /// <summary>
        /// Validates Mobile PDLC document generation, should include
        /// the right id as well as parent rollups and store
        /// Data is propped through the marketplace msi
        /// </summary>
        [TestCase, Owner("janthony"), TestCasePriority(1)]
        class ProductDocument_Mobile_PDLC : DocumentGenerationTestBase
        {
            public ProductDocument_Mobile_PDLC() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("02244567-89AB-CDEF-0000-AAAE50000203"), 1033 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                // Validate the searchable Xml
                XmlUtil.ValidateNodeExists(results[0], "//b:searchableXml//b:fullDescription", _namespaces);

                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:locale", "en-US", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:language", "en", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:title", "Title", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:productType", attributeInt32, "59", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:platformTypeId", attributeInt32, "0", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:offerInstances//b:offerInstance//b:stores//b:store", attributeInt32, "5", _namespaces);

                XmlUtil.ValidateNodeExistsWithValue(results[0], "//b:searchableXml//b:parentProducts//b:parentProduct//b:parentProductId", "02234567-89ab-cdef-0000-aaaa50000203", _namespaces);
            }
        }

        /// <summary>
        /// Used to validate the 'inherit rating' concept in the case where a parent game has a rating
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class ProductDocument_ParentGameHasRating : DocumentGenerationTestBase
        {
            public ProductDocument_ParentGameHasRating() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66ACD000-77FE-1000-9115-D8023B8D12DB"), 1033 ),  // the parent game (with rating)                                               
                    new MediaIdLcid( new Guid("00000000-0000-4052-8052-85E83B8D12DB"), 1033 ),  // the child with inheritance set to true
                    new MediaIdLcid( new Guid("00000000-0000-4051-8087-46873B8D12DB"), 1033 )   // the child with inheritance set to false
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:ratingId", "10", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[1].detaillevel5, "//b:detaillevel5//b:ratingId", "10", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[2].detaillevel5, "//b:detaillevel5//b:ratingId", "30", _namespaces);
        }       
        }       

        /// <summary>
        /// Used to validate the 'inherit rating' concept in the case where a parent game does NOT have a rating
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class ProductDocument_ParentGameWithNoRating : DocumentGenerationTestBase
        {
            public ProductDocument_ParentGameWithNoRating() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66ACD000-77FE-1000-9115-D8022C57681D"), 1033 ),  // the parent game (no rating) and no download count in UsageAggregateFromReporting
                    new MediaIdLcid( new Guid("00000000-0000-4003-80CC-D5932C57681D"), 1033 ),  // the child with inheritance set to true
                    new MediaIdLcid( new Guid("00000000-0000-407A-80D0-7A292C57681D"), 1033 )   // the child with inheritance set to false and child has value
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                // Should not have any download counts
                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:downloadCount", _namespaces);

                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:ratingId", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[1].detaillevel5, "//b:detaillevel5//b:ratingId", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[2].detaillevel5, "//b:detaillevel5//b:ratingId", "30", _namespaces);
            }
        }


        [TestCase, TestCasePriority(1)]
        class ProductDocument_RatingInheritance_MultipleParents : DocumentGenerationTestBase
        {
            public ProductDocument_RatingInheritance_MultipleParents() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8020CABD50B"), 1033 ),  // the first parent game
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8022EEA7993"), 1033 ),  // the second parent
                    new MediaIdLcid( new Guid("00000000-0000-4063-8078-98620CABD50B"), 1033 )   // the child with inheritance set to true and value = 20
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:ratingId", "40", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[1].detaillevel5, "//b:detaillevel5//b:ratingId", "30", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[2].detaillevel5, "//b:detaillevel5//b:ratingId", "40", _namespaces);
            }
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_AvatarItem : DocumentGenerationTestBase
        {
            public ProductDocument_AvatarItem() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("00000000-0000-4047-8000-000011110000"), 1033 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:avatarBodyType", attributeInt32, "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:platformTypeId", attributeInt32, "0", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:isGameBrowsable", _namespaces);

                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:avatarBodyType", "1", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:avatarItemAssetId", "66ACD000-77FE-1000-9115-D8026D3B992A", _namespaces);

                DateTime dt = new DateTime(1901, 1, 1, 0, 0, 0); //"1901-01-01T00:00:00Z"
                CheckTrue(DateTime.Compare(results[0].MostRecentOfferStartDate, dt) == 0);

                //Offer Instances
                XPathNodeIterator iterator = XmlUtil.GetXmlIteratorWithValue(results[0], "//b:searchableXml//b:offerInstances//b:offerInstance//b:offerInstanceId", "60000800-0000-4001-8000-00001010001A", _namespaces);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "offerId", null, "60000000-0047-4000-8000-00001010111A", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "startDate", attributeDateTime, "1901-01-01T00:00:00Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "endDate", attributeDateTime, "2999-12-31T00:00:00Z", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "visibilityLevel", attributeInt32, "1", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "price", attributeDouble, "200.0000", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "taxType", attributeInt32, "0", "http://marketplace.xboxlive.com/resource/product/v1");
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "tiers/tier", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToParent();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "stores/store", attributeInt32, "2", "http://marketplace.xboxlive.com/resource/product/v1");

            }
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_SomeDownloadCounts_Missing : DocumentGenerationTestBase
        {
            public ProductDocument_SomeDownloadCounts_Missing() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8023B8D12DB"), 1033 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                // Download counters
                CheckTrue(results[0].DownloadCountAllTimeFreeAndPaid == 5000);
                CheckTrue(results[0].DownloadCountAllTimePaid == 0);
                CheckTrue(results[0].DownloadCountTodayFreeAndPaid == 0);
                CheckTrue(results[0].DownloadCountTodayPaid == 0);
            }
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_No_DownloadCounts : DocumentGenerationTestBase
        {
            public ProductDocument_No_DownloadCounts() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8022C57681D"), 1033 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:downloadCount", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:platformTypeId", attributeInt32, "1", _namespaces);
            }
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_No_OfferInstances : DocumentGenerationTestBase
        {
            public ProductDocument_No_OfferInstances() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66ACD000-77FE-1000-9115-D8022C57681D"), 1033 )
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:offerInstances", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:offerInstances", _namespaces);
            }
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_No_UserRating : DocumentGenerationTestBase
        {
            public ProductDocument_No_UserRating() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("00000000-0000-4005-8000-00001370001A"), 1033 )   // XNA Game
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                CheckTrue(results[0].UserRating == 0);

                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:userRating", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:numberOfRatings", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributesAndValue(results[0], "//b:searchableXml//b:platformTypeId", attributeInt32, "0", _namespaces);

            }
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_No_ParentalControlRating : DocumentGenerationTestBase
        {
            public ProductDocument_No_ParentalControlRating() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8021370001A"), 1033 )   // XNA Game
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);
                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:exactRatingId", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:acceptableRatingIds", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:ratingId", _namespaces);
            }
        }

        [TestCase, TestCasePriority(1)]
        class ProductDocument_No_RatingDescriptor : DocumentGenerationTestBase
        {
            public ProductDocument_No_RatingDescriptor() : base() { }

            protected override void Execute()
            {
                //
                ResultCode = TEST_RESULTS.PASSED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8021370001A"), 1033 )   // XNA Game
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                XmlUtil.ValidateNodeDoesNotExist(results[0], "//b:searchableXml//b:ratingDesciptors", _namespaces);
                XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:ratingDesciptors", _namespaces);
            }
        }

        /// <summary>
        /// Game content is associated to two parents:
        ///     66acd000-77fe-1000-9115-d8020cabd50b
        ///     66acd000-77fe-1000-9115-d8022eea7993
        /// The top parent is the primary parent
        /// 
        /// The images section will need to be ordered with the primary parent first
        /// </summary>
        [TestCase, Owner("craigta"), TestCasePriority(1)]
        class ProductDocument_Image_Inherit : DocumentGenerationTestBase
        {
            public ProductDocument_Image_Inherit() : base() { }

            protected override void Execute()
            {
                //                
                ResultCode = TEST_RESULTS.FAILED;
                MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("00000000-0000-4063-8078-98620CABD50B"), 1033 )   // Game content
                };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                XPathNodeIterator iterator = XmlUtil.GetXmlIteratorWithAttributes(results[0].detaillevel5, "//b:detaillevel5//b:images", null, _namespaces);
                iterator.Current.MoveToChild(XPathNodeType.All);
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "parentGameMediaId", null, "66ACD000-77FE-1000-9115-D8020CABD50B", "http://marketplace.xboxlive.com/resource/product/v1");
                iterator.Current.MoveToNext();
                XmlUtil.ValidateNodeExistsWithValue(iterator, results[0].Id, "parentGameMediaId", null, "66ACD000-77FE-1000-9115-D8022EEA7993", "http://marketplace.xboxlive.com/resource/product/v1");
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// A Non-GOND Game
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class ProductDocument_ParentProductInfo_NonGOND : DocumentGenerationTestBase
        {
            public ProductDocument_ParentProductInfo_NonGOND() : base() { }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MediaIdLcid[] medias = new MediaIdLcid[] {
                            new MediaIdLcid( new Guid("66ACD000-77FE-1000-9115-D8022EEA7993"), 1033 ), // Non GOND Game
                        };

                List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);
                CheckTrue(results[0].ParentProductNavigator == "~Title sort for Rating inheritance multi-parent parent 2, A#Rating inheritance multi-parent parent 2#66acd000-77fe-1000-9115-d8022eea7993");

                //parent products
                XmlUtil.ValidateNodeExists(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentProductId='66ACD000-77FE-1000-9115-D8022EEA7993']", _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributes(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentProductType='1']//b:parentProduct//b:parentProductType", attributeInt32, _namespaces);
                XmlUtil.ValidateNodeExistsWithAttributes(results[0], "//b:searchableXml//b:parentProducts[b:parentProduct//b:parentRelationshipType='0']//b:parentProduct//b:parentRelationshipType", attributeInt32, _namespaces);

            }
        }



        [TestGroup, Owner("craigta"), TestFrequency("Daily"), EnvRequirement("xblobonly")]
        public class ShowRating : TestNode
        {

            /// <summary>
            /// Check that content for a titleid will display "showRating=false" when its parent is specified
            /// </summary>
            [TestCase, TestCasePriority(1)]
            class ProductDocument_ShowRating_With_TitleId : DocumentGenerationTestBase
            {
                public ProductDocument_ShowRating_With_TitleId() : base() { }

                protected override void Execute()
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    // This is game content associated with game with title id 999101147
                    MediaIdLcid[] medias = new MediaIdLcid[] {
                        new MediaIdLcid( new Guid("00000000-0000-4052-8052-85E83B8D12DB"), 1033 )   
                    };

                    DocumentGenerationTestBase.fastRatingExemptGCForTitles = new string[] { "999101147" };
                    DocumentGenerationTestBase.fastRatingNonExemptMediaIds = null;
                    DocumentGenerationTestBase.fastRatingNonExemptRatingSystem = null;
                    DocumentGenerationTestBase.fastRatingExemptMediaTypes = null;

                    List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                    XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:showRating", "false", _namespaces);

                    DocumentGenerationTestBase.fastRatingExemptGCForTitles = null;
                    DocumentGenerationTestBase.fastRatingNonExemptMediaIds = null;
                    DocumentGenerationTestBase.fastRatingNonExemptRatingSystem = null;
                    DocumentGenerationTestBase.fastRatingExemptMediaTypes = null;

                    results = GetDocumentsWithBasicValidation(medias);

                    XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:showRating", _namespaces);
                }
            }

            /// <summary>
            /// MediaType 47 (avatar item) should always display "showRating = false"
            /// </summary>
            [TestCase, TestCasePriority(1)]
            class ProductDocument_ShowRating_False_With_MediaType : DocumentGenerationTestBase
            {
                public ProductDocument_ShowRating_False_With_MediaType() : base() { }

                protected override void Execute()
                {
                    //
                    ResultCode = TEST_RESULTS.PASSED;
                    MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("00000000-0000-4047-8000-000011110000"), 1033 ),   // Avatar item exempt
                    new MediaIdLcid( new Guid("00000000-0000-407A-80D0-7A292C57681D"), 1033 )    // DLC that will not include "showRating=false"
                };

                    DocumentGenerationTestBase.fastRatingExemptGCForTitles = null;
                    DocumentGenerationTestBase.fastRatingNonExemptMediaIds = null;
                    DocumentGenerationTestBase.fastRatingNonExemptRatingSystem = null;
                    DocumentGenerationTestBase.fastRatingExemptMediaTypes = new string[] { "47" };

                    List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                    XmlUtil.ValidateNodeExistsWithValue(results[0].detaillevel5, "//b:detaillevel5//b:showRating", "false", _namespaces);
                    XmlUtil.ValidateNodeDoesNotExist(results[1].detaillevel5, "//b:detaillevel5//b:showRating", _namespaces);
                }
            }

            /// <summary>
            /// The content is an avatar item, which usually hides ratings, however in this case the rating system is exempt
            /// so it will not display that node
            /// </summary>
            [TestCase, TestCasePriority(1)]
            class ProductDocument_ShowRating_Rating_System_Exempts : DocumentGenerationTestBase
            {
                public ProductDocument_ShowRating_Rating_System_Exempts() : base() { }

                protected override void Execute()
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("00000000-0000-4047-8000-000011110000"), 1033 ), // Rating system is non-exempt
                    new MediaIdLcid( new Guid("00000000-0000-4047-8000-000011110000"), 1041 )  // Rating system for this is still exempt
                };

                    DocumentGenerationTestBase.fastRatingExemptGCForTitles = null;
                    DocumentGenerationTestBase.fastRatingNonExemptMediaIds = null;
                    DocumentGenerationTestBase.fastRatingNonExemptRatingSystem = new string[] { "0" }; // US rating system is non-exempt
                    DocumentGenerationTestBase.fastRatingExemptMediaTypes = new string[] { "47" }; ;

                    List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                    XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:showRating", _namespaces);
                    XmlUtil.ValidateNodeExistsWithValue(results[1].detaillevel5, "//b:detaillevel5//b:showRating", "false", _namespaces);
                }
            }

            /// <summary>
            /// Avatar and GonD should display "showRating=false", however the specific Avatar item should not display that
            /// </summary>
            [TestCase, TestCasePriority(1)]
            class ProductDocument_ShowRating_MediaIds_Exempts : DocumentGenerationTestBase
            {
                public ProductDocument_ShowRating_MediaIds_Exempts() : base() { }

                protected override void Execute()
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("00000000-0000-4047-8000-000011110000"), 1033 ), // Avatar content is supposed to be exempt, but using the 
                                                                                               // nonExemptMediaIds to filter it out
                    new MediaIdLcid( new Guid("66acd000-77fe-1000-9115-D8022C57681D"), 1033 )  // Should show as exempt 
                };

                    DocumentGenerationTestBase.fastRatingExemptGCForTitles = null;
                    DocumentGenerationTestBase.fastRatingNonExemptMediaIds = new string[] { "00000000-0000-4047-8000-000011110000" };
                    DocumentGenerationTestBase.fastRatingNonExemptRatingSystem = null;
                    DocumentGenerationTestBase.fastRatingExemptMediaTypes = new string[] { "47", "1" };

                    List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                    XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:showRating", _namespaces);
                    XmlUtil.ValidateNodeExistsWithValue(results[1].detaillevel5, "//b:detaillevel5//b:showRating", "false", _namespaces);
                }
            }

            /// <summary>
            /// A title id is added to exemption, but one DLC For that game is nonExempt
            /// </summary>
            [TestCase, TestCasePriority(1)]
            class ProductDocument_ShowRating_Dlc_Non_Exempt_For_ExemptTitleId : DocumentGenerationTestBase
            {
                public ProductDocument_ShowRating_Dlc_Non_Exempt_For_ExemptTitleId() : base() { }

                protected override void Execute()
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    MediaIdLcid[] medias = new MediaIdLcid[] {
                    new MediaIdLcid( new Guid("00000000-0000-407A-80D0-7A292C57681D"), 1033 ), // DLC that will not include "showRating=false"
                    new MediaIdLcid( new Guid("00000000-0000-4003-80CC-D5932C57681D"), 1033 ), // DLC that will include "showrating=False" because it is associated
                                                                                               // with an exempt title
                    new MediaIdLcid( new Guid("66ACD000-77FE-1000-9115-D8022C57681D"), 1033 )  // Main game                  
                };

                    DocumentGenerationTestBase.fastRatingExemptGCForTitles = new string[] { "743925789" };
                    DocumentGenerationTestBase.fastRatingNonExemptMediaIds = new string[] { "00000000-0000-407A-80D0-7A292C57681D" };
                    DocumentGenerationTestBase.fastRatingNonExemptRatingSystem = null;
                    DocumentGenerationTestBase.fastRatingExemptMediaTypes = null;

                    List<DocumentResult> results = GetDocumentsWithBasicValidation(medias);

                    XmlUtil.ValidateNodeDoesNotExist(results[0].detaillevel5, "//b:detaillevel5//b:showRating", _namespaces);
                    XmlUtil.ValidateNodeExistsWithValue(results[1].detaillevel5, "//b:detaillevel5//b:showRating", "false", _namespaces);
                    XmlUtil.ValidateNodeDoesNotExist(results[2].detaillevel5, "//b:detaillevel5//b:showRating", _namespaces); // game itself is not exempt
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\UnitTests\Mocks\PublisherAzureStorageMock.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.server.catalogwatcher;
using System.IO;
using xonline.common.mgmt;

namespace UnitTests
{
    /// <summary>
    /// Test version of the PublisherAzureStorage class that overrides the StreamWriter that normally goes to Azure
    /// </summary>
    public class PublisherAzureStorageMock : PublisherAzureStorage
    {
        private string lastFileName;
        private StringBuilder lastFileContents;

        protected override TextWriter GetTextWriter(string fileName)
        {
            lastFileName = fileName;
            lastFileContents = new StringBuilder();

            return new StringWriter(lastFileContents);
        }

        public string GetLastFileName()
        {
            return lastFileName;
        }

        public String GetLastFileContents()
        {
            return lastFileContents.ToString();
        }

        protected override void PublishDocumentCounters(XomRequestTimeElapsed timeElapsed)
        {
            // do nothing on purpose
        }

        protected override void FlushDocumentsCounters(XomRequestTimeElapsed timeElapsed)
        {
            // do nothing on purpose
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\test\UnitTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CatalogWatcherTests-Video")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("CatalogWatcherTests-Video")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a0483458-1c05-46ef-ad18-8f3a7f212cc3")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\svr\CleanserSvr.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Reflection;

using xonline.common.mgmt;
using xonline.common.service;

using System.Threading;
using xonline.common.config;

[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.cleansertrace)]
[assembly: XomAreaDefinition(XomAreaName.cleansermissingdata)]

[assembly: ConfigAttribute(Component.cleanser)]

namespace xonline.server.cleanser.svr 
{
    public class CleanserSrv : System.ServiceProcess.ServiceBase
    {
        ConnectionsManager tcpConnectionsManager;
        TransformManager transformManager;
        XboxLiveThread storageThread;

        public static EtxManifestStorageManager storageManager;

        public CleanserSrv()
        {          
        }
        
        /// <summary>
        /// Set things in motion so your service can do its work.
        /// </summary>
        protected override void OnStart(string[] args)
        {           
            InitService();            
            Xom.NtEvent( XEvent.Id.CLEANSER_INFO_0, "Cleanser service has been started" );
         }
 
        /// <summary>
        /// Stop this service.
        /// </summary>
        protected override void OnStop()
        {
            tcpConnectionsManager.Shutdown(); 
            transformManager.Shutdown();
            storageManager.Shutdown();
            storageThread.Join();

            Xom.NtEvent( XEvent.Id.CLEANSER_INFO_1, "Cleanser service has been shutdown" );
        }

// for testing purposes only
        public void Start()
        {
            OnStart(null);
        }

        private void InitService()
        {                   
            Config.Assembly = typeof(CleanserSrv).Assembly;
            XomLoggingControl.Init();
            try
            {
                // make sure that all singletons are initialized properly
                CleanserConfig.Initialize();
                transformManager = TransformManager.Instance;
                tcpConnectionsManager = ConnectionsManager.Instance;
                storageManager = new EtxManifestStorageManager();
                
                storageThread = new XboxLiveThread(storageManager.ThreadStartup);
                storageThread.Start(null);

                // setup config change handler to resolve Xenon 91109
                Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(CleanserSrv.ChangeBucketMap);           

                // Set up the non-IIS healthcheck listener
                xonline.common.health.HealthListener.InitializeHealthListener(Config.ComponentName);

            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.CLEANSER_CONFIG_0, e, "Failed to initialize cleanser server.");
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: " + e);
                throw;
            }
        }

        // The main entry point for the process
        static void Main(string[] args)
        {           
            bool fRunAsConsole = false;
            CleanserSrv srv = new CleanserSrv();
            
            foreach (string sArg in args)
            {
                if (sArg.ToLower().Contains("console"))
                {
                    fRunAsConsole = true;
                }
            }

            if (fRunAsConsole)
            {
                srv.RunAsConsole(args);
            }
            else
            {
                System.ServiceProcess.ServiceBase.Run(srv);
            }
        }

        //This is implemented solely so that bucket remapping will now succeed. 
        //See config.cs func RefreshInterfaceBuckets() -- if you don't add a bucketchange delegate
        //then the bucket change will NOT update the cache, breaking in Xenon 91109.
        public static void ChangeBucketMap(object sender, InterfaceBucketChangeEventArgs e)
        {
            return;
        }

        private bool _fRunAsConsole = false;

        private void RunAsConsole(string[] args)
        {
            _fRunAsConsole = true;
            OnStart(args);

            try
            {
                Console.WriteLine("Running as console.");
                Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);

                while (_fRunAsConsole)
                {
                    string sCommand = Console.ReadLine();
                }
            }
            finally
            {
                OnStop();
            }
        }

        private void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            OnStop();
        }
        
      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\svr\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;
    
namespace xonline.server.cleanser.svr
{
    
    [XomPerformanceCounterCategoryAttr( "Cleanser Svc", "XBox Live Reporting Cleanser Service" )]
    public class CleanserCounters : XomPerformanceCounterCategory
    {
        
        static public CleanserCounters Current = new CleanserCounters();
        
        [XomPerformanceCounterAttr(
            "Messages/sec", 
            "Messages per second collected from core XBL components", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MessagesPerSecond;

        [XomPerformanceCounterAttr(
            "Messages processed total", 
            "Total messages collected from core XBL components and processed by cleanser from the service startup.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessagesTotal;

        [XomPerformanceCounterAttr(
            "Messages failed/sec", 
            "Invalid messages per second collected from core XBL components", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MessagesFailedPerSecond;

        [XomPerformanceCounterAttr(
            "Messages failed total", 
            "Total invalid messages collected from core XBL components from the service startup.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessagesFailedTotal;

      [XomPerformanceCounterAttr(
            "Unknown messages/sec", 
            "Unknown messages per second collected from core XBL components", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MessagesUnknownPerSecond;

        [XomPerformanceCounterAttr(
            "Unknown messages total", 
            "Total unknown messages collected from core XBL components from the service startup.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessagesUnknownTotal;
        
        [XomPerformanceCounterAttr(
            "Tcp connections total", 
            "Total tcp connections handled by the server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter TcpConnectionsTotal;

        [XomPerformanceCounterAttr(
            "Incoming messages per second", 
            "Raw messages per second being read", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter InRawMessagesPerSecond;

        [XomPerformanceCounterAttr(
            "Incoming messages queue length", 
            "Number of messages in the message queue", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter InMessageQueueLength;

            [XomPerformanceCounterAttr(
            "Messages dropped from incoming queue/sec", 
            "Messages dropped from incoming queue per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter InMessagesDroppedPerSecond;

        [XomPerformanceCounterAttr(
            "Messages dropped from incoming queue total", 
            "Total messages dropped from incoming queue from the service startup.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InMessagesDroppedTotal;


        [XomPerformanceCounterAttr(
            "Worker queues length", 
            "Number of messages in all worker queues for all filterdb servers", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter WorkQueueLength;

            [XomPerformanceCounterAttr(
            "Messages dropped from worker queues/sec", 
            "Messages dropped from all filterdb queues per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter WorkQMessagesDroppedPerSecond;

        [XomPerformanceCounterAttr(
            "Messages dropped from worker queues total", 
            "Total messages dropped from all filterdb queues from the service startup.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter WorkQMessagesDroppedTotal;


        [XomPerformanceCounterAttr(
            "Message processing avg. execution time", 
            "Message processing average request execution time in the cleanser.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;
        
        [XomPerformanceCounterAttr(
            "Message processing avg. execution time base", 
            "Message processing base for the average request execution time in the cleanser.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;

        [XomPerformanceCounterAttr(
            "Messages sent to generic processing total",
            "Total messages sent to the generic processing system from the service startup.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GenMessagesReceivedTotal;

        [XomPerformanceCounterAttr(
            "Messages sent to generic processing per second",
            "Number of messages sent to the generic processing system per second.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GenMessagesReceivedRate;


        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\svr\EtxManifestStorage.cs ===
using System;
using System.Data;
using System.Text;
using System.Data.SqlClient;
using System.Collections;
using System.Runtime.InteropServices;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using System.IO;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Reflection;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.core.etx;
using xonline.common.utilities2;

namespace xonline.server.cleanser.svr
{
    public sealed class EtxManifestStorageManager
    {
        private XmlSerializer serializer;
        private Queue<QueueEntry> queue;
        private AutoResetEvent queueEvent;
        private ManualResetEvent shutdownEvent;
        private PropertyInfo fingerprintProperty;

        public EtxManifestStorageManager()
        {
            Type eventType;

            eventType = typeof(Event);

            this.serializer = new XmlSerializer(typeof(Event));
            this.queue = new Queue<QueueEntry>();
            this.queueEvent = new AutoResetEvent(false);
            this.shutdownEvent = new ManualResetEvent(false);
            this.fingerprintProperty = eventType.GetProperty("Fingerprint", BindingFlags.Instance | BindingFlags.Public);
        }

        public void ThreadStartup(object param)
        {
            string fingerprint;
            string path;
            byte headerVersion;

            while(true)
            {
                fingerprint = path = "empty";

                try
                {
                    if (!DequeueEventWrite(out fingerprint, out path, out headerVersion))
                    {
                        return; // exit signaled
                    }

                    if (File.Exists(path) == false)
                    {
                        Directory.CreateDirectory(Path.GetDirectoryName(path));

                        using (FileStream eventOutputStream = new FileStream(path, FileMode.CreateNew))
                        {
                            serializer.Serialize(
                                eventOutputStream,
                                EtxLoader.NPDB.GetEvent(Blob.Parse(fingerprint), headerVersion));

                            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_INFO, "Etx event written out: {0}@{1}", fingerprint, path);
                        }
                    }
                }
                catch (IOException)
                {
                    // file already exists
                    Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_HIGH, "Etx event file already exists: {0}@{1}", fingerprint, path);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.CLEANSER_ETX_WRITE_FAIL, e, "Unexpected error encountered while writing etx event: {0}@{1}", fingerprint, path);
                    Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Unexpected error encountered while writing etx event: {0}@{1}\n{2}", fingerprint, path, e);
                }
            }
        }

        public bool DequeueEventWrite(out string fingerprint, out string path, out byte headerVersion)
        {
            int handle;

            handle = AutoResetEvent.WaitAny(new WaitHandle[] { queueEvent, shutdownEvent });

            if (handle == 0) // handle is index of queue event
            {
                lock (queue)
                {
                    var entry = queue.Dequeue();

                    path = entry.TargetFile;
                    fingerprint = entry.EventFingerprint;
                    headerVersion = entry.EventHeaderVersion;

                    if (queue.Count > 0)
                    {
                        queueEvent.Set();
                    }

                    return true;
                }
            }
            else // handle is index of shutdown event
            {
                fingerprint = null;
                path = null;
                headerVersion = 0;

                return false;
            }
        }

        public void EnqueueEventWrite(string fingerprint, string logFolderName, byte headerVersion, string manifestKey)
        {
            string logroot;
            string path;

            logroot = Config.GetSetting(Setting.setup_logroot);
            path = Config.GetSetting(Setting.cleanser_EtxEventTarget);

            path = path.Replace("#LOGROOT#", logroot);
            path = path.Replace("#COMPONENT#", Config.ComponentName);
            path = path.Replace("#NEWLOGPREFIX#", logFolderName);
            path = path.Replace("#EVENTFINGERPRINT#", string.Format("{0}-{1}", fingerprint, headerVersion));
            path = path.Replace("#MANIFESTKEY#", manifestKey);

            if (File.Exists(path) == false && shutdownEvent.WaitOne(0, false) == false)
            {
                lock (queue)
                {
                    queue.Enqueue(new QueueEntry() 
                        { 
                            EventHeaderVersion = headerVersion, 
                            EventFingerprint = fingerprint, 
                            TargetFile = path,
                        });

                    queueEvent.Set();
                }
            }
        }

        public void Shutdown()
        {
            shutdownEvent.Set();
        }

        private struct QueueEntry
        {
            public string EventFingerprint
            {
                get;
                set;
            }

            public string TargetFile
            {
                get;
                set;
            }

            public byte EventHeaderVersion
            {
                get;
                set;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\svr\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\svr\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\test\dvt\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\svr\TcpListener.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Data.SqlClient;
using System.Data;
using System.Diagnostics;
using System.Timers;
using System.IO;
using System.Collections;


using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities2;

namespace xonline.server.cleanser.svr 
{
    // keep connection related info 
    public class ConnectionState 
    {
        public const int maxCountAllowedToBeMissing = 3;
        private Socket workSocket = null;
        public Socket WorkSocket 
        {
            get { return workSocket; } 
            set { workSocket = value; }        
        }

        // time of the last update from client. That information is used by ConnectionsManager.watchTimer
        // to track clients' activities, UTC format
        public object lastReceiveTimeTicks= DateTime.UtcNow.Ticks;

        // Timer sets that flag to 1 if the client has not sent anything for more than configured time
        // and fires an error event, if the client is back, the flag is reset and an information event is fired
        public int clientDeclaredMissing = 0;
        // Size of receive buffer.
        public const int BufferSize = 102400;  // maxTcpConnections is 400, so this is 40M of memory at most
        // if part of the message appears at the tail, copy it to the start of the buffer and append the rest
        public int bufferStart = 0;
        // Receive buffer for tcp packets
        public byte[] buffer = new byte[BufferSize];

        public string remoteIP = "0.0.0.0";
        public Int32 componentID = 0;
        public string remoteServer;

        public override string ToString()
        {  
            string remoteIP = "0.0.0.0";
            string remotePort = "0";
            string localIP = "0.0.0.0";
            string localPort = "0";
            try
            {
                remoteIP = (IPAddress.Parse(((IPEndPoint)workSocket.RemoteEndPoint).Address.ToString())).ToString();
                remotePort =( ((IPEndPoint)workSocket.RemoteEndPoint).Port).ToString();
                localIP = (IPAddress.Parse(((IPEndPoint)workSocket.LocalEndPoint).Address.ToString())).ToString();
                localPort = ((IPEndPoint)workSocket.LocalEndPoint).Port.ToString();
            }
            catch (Exception e) 
            {
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: "+ e.ToString());
            }

            long ticks = (long) lastReceiveTimeTicks;
            DateTime lastUpdateTime = new DateTime (ticks);
            return  "remoteIP = "+ remoteIP+
                        ", remortPort = "+ remotePort+
                        ", localIP = " + localIP+
                        ", localPort = "+localPort+
                        ", lastReceiveTime = "+lastUpdateTime.ToString()+
                        ", clientDeclaredMissing = "+clientDeclaredMissing+
                        ", componentID = " + componentID+
                        ", server = " + remoteServer;
        }

        public string ToLogString()
        {              
        string remoteIP = "0.0.0.0";
        string remotePort = "0";
        string localIP = "0.0.0.0";
        string localPort = "0";
        try
        {
            remoteIP = (IPAddress.Parse(((IPEndPoint)workSocket.RemoteEndPoint).Address.ToString())).ToString();
            remotePort =( ((IPEndPoint)workSocket.RemoteEndPoint).Port).ToString();
            localIP = (IPAddress.Parse(((IPEndPoint)workSocket.LocalEndPoint).Address.ToString())).ToString();
            localPort = ((IPEndPoint)workSocket.LocalEndPoint).Port.ToString();
        }
        catch  (Exception e)
        {
            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: "+ e.ToString());
        }

        long ticks = (long) lastReceiveTimeTicks;
        DateTime lastUpdateTime = new DateTime (ticks);
        return  remoteIP+"|"+
                remotePort+"|"+
                localIP+"|"+
                localPort+"|"+
                lastUpdateTime.ToString()+"|"+
                clientDeclaredMissing+"|"+
                componentID;
        }

        public string ToXmgmtString()
        {  
            string remoteIP = "0.0.0.0";
            string remotePort = "0";
            try
            {
                remoteIP = (IPAddress.Parse(((IPEndPoint)workSocket.RemoteEndPoint).Address.ToString())).ToString();
                remotePort =( ((IPEndPoint)workSocket.RemoteEndPoint).Port).ToString();
            }
            catch  (Exception e)
            {
            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: "+ e.ToString());
            }

            long ticks = (long) lastReceiveTimeTicks;
            DateTime lastUpdateTime = new DateTime (ticks);
            return  "IP = "+ remoteIP+
                        ":"+ remotePort+
                        ", componentID=" + componentID +
                        ", lastReceiveTime=" + lastUpdateTime.ToString() +
                        ", server=" + remoteServer;
        }


        public bool IsValidRemoteSocket()
        {
        string remoteIP = "0.0.0.0";
        try
        {
            remoteIP = (IPAddress.Parse(((IPEndPoint)workSocket.RemoteEndPoint).Address.ToString())).ToString();
        }
        catch(Exception e)
        {
            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: "+ e.ToString());
        }

         return remoteIP == "0.0.0.0"? false : true;
    }

        public void OnConnect(int componentID, long time, string remoteServer)
        {
            //first connect 
            if (this.componentID == 0 ||
             // allow multiple connect messages with consistent componentID. That could happen
            // if cleanser was down and a client accumulated connect and data messages in its tcp buffers.
                 this.componentID == componentID)
            {            
                this.componentID = componentID;
                this.remoteServer = remoteServer;
                remoteIP = (IPAddress.Parse(((IPEndPoint)workSocket.RemoteEndPoint).Address.ToString())).ToString();

                Interlocked.Exchange(ref this.lastReceiveTimeTicks, DateTime.UtcNow.Ticks);
                string logLine = "CONNECT|"+this.ToLogString();                            
                Xom.Log(XomAreaName.log, logLine);
                return;
            }
            
            throw new Exception (String.Format(
                    "Multiple Connect messages contains inconsistent componentID info. Invalid protocol. Expected {0}, got {1} from {2}",
                    this.componentID, componentID, remoteServer));
        }

        public void OnKeepAlive(long time)
        {
            // Connection state not checked, actions like eventing would spam the event logs too much

            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "ConnectionState: OnKeepAlive "+ this.ToString());
            string logLine = "KEEPALIVE|"+this.ToLogString();
            Xom.Log(XomAreaName.log, logLine);
            int origValue = Interlocked.Exchange (ref clientDeclaredMissing,0);
            if (origValue > 0)
            {
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "missing client is back "+ this.ToString());
                Xom.NtEvent(XEvent.Id.CLEANSER_INFO_2, "Missing client is back. Client info: " + this.ToString());
            }
            Interlocked.Exchange(ref this.lastReceiveTimeTicks, DateTime.UtcNow.Ticks);
        }

        public void OnData(ReportMessageData3 data)
        {
            if (IsBadConnectionState())
            {
                Xom.NtEvent(XEvent.Id.CLEANSER_BAD_PROTOCOL_FOR_DATA_REQ, "Bad protocol: connection missing component id, data request dropped. remoteIP={0}", remoteIP);
                return;
            }

            int origValue = Interlocked.Exchange (ref clientDeclaredMissing,0);
            if (origValue > 0)
            {
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW,"missing client is back  "+ this.ToString());
                Xom.NtEvent(XEvent.Id.CLEANSER_INFO_3, "Missing client is back. Client info: " + this.ToString());
            }
            Interlocked.Exchange(ref this.lastReceiveTimeTicks, DateTime.UtcNow.Ticks);  
            MessageData dt = new MessageData(this, data);
            
            TransformManager.Instance.QueueMessage(dt);
        }

        public void OnDisconnect(long time)
        {
            string logLine = "DISCONNECT|"+this.remoteIP+ "|"+this.componentID+"|"+time;
            Xom.Log(XomAreaName.log, logLine);

            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "ConnectionState: OnDisconnect "+this.ToString());

            if (IsBadConnectionState())
            {
                Xom.NtEvent(XEvent.Id.CLEANSER_BAD_PROTOCOL_FOR_DISCONNECT_REQ, "Bad protocol: connection missing component id for disconnect request. remoteIP={0}", remoteIP);
                return;
            }
        }

        private bool IsBadConnectionState()
        {
            return componentID == 0;
        }

    }

    
// that is a message sent by a core XBL component
    public class MessageData        
    {
        public string message = null;
        public DateTime time = DateTime.MinValue;
        public object [] values = null;        
        public string eventFingerprint = null;
        public byte eventHeaderVersion = 0;
        public string logStringId = null;
        public string manifestKey = null;

        // Reference to connection information, for pulling out useful info
        public ConnectionState connectionState = null;

        public MessageData( ConnectionState connectionState, ReportMessageData3 dt)
        {
            this.connectionState = connectionState;
            time = DateTime.FromFileTimeUtc(dt.llTime);
            message = dt.szMessage;

            logStringId = dt.LogStringId;
            eventHeaderVersion = dt.EtxEventHeaderVersion;
            manifestKey = dt.FileNameKey;

            if (string.IsNullOrEmpty(manifestKey))
            {
                manifestKey = String.Format("EMPTY-{0}", eventHeaderVersion);
            }

            if (dt.EtxEventFingerprint != null && dt.EtxEventFingerprint.Length > 0)
            {
                eventFingerprint = ((Blob)dt.EtxEventFingerprint).ToString();
            }

            if (string.IsNullOrEmpty(logStringId))
            {
                int index;

                if (-1 != (index = message.IndexOf('|')))
                {
                    logStringId = message.Substring(0, index);
                }
                else
                {
                    logStringId = message;
                }
            }
        }
        
        public override string ToString()
        {
            return  
                        "componentID=" + connectionState.componentID +
                        ", remoteServer=" + connectionState.remoteServer +
                        ", time=" + time +
                        ", logStringId=" + logStringId +
                        ", data=" + message;
        }
    }



    public class ConnectionsManager
    {

        private const int ticksInSec = 1000;
        private static ConnectionsManager instance = null;
        private int maxTcpClients;

        private AsynchronousSocketListener tcpListener;
        private XboxLiveThread tcpListenerThread;
        
        private ConnectionState[] tcpActiveClients;
        private System.Timers.Timer watchTimer;

        private ConnectionsManager()
        {
            tcpListener = new AsynchronousSocketListener();
            tcpListenerThread  = null;
            tcpActiveClients = null;
            maxTcpClients = 0;
            
            watchTimer = new System.Timers.Timer();
            watchTimer.Elapsed += new ElapsedEventHandler(OnTimer);

        }

        public static ConnectionsManager Instance
        {
          get 
          {
             if (instance == null) 
             {
                instance = new ConnectionsManager();
                instance.Initialize();
             }
             return instance;
          }
       }

        private void Initialize()
        {        
            maxTcpClients = Config.GetIntSetting(Setting.cleanser_maxTcpConnections);
            tcpActiveClients = new ConnectionState[maxTcpClients];
            for (int i = 0; i < maxTcpClients; i++)
            {
                tcpActiveClients [i] = null;
            }

            tcpListenerThread = new XboxLiveThread(new ThreadStart(tcpListener.StartListening));

            tcpListenerThread.Start();

            // Timer.Interval measured in milliseconds
            watchTimer.Interval = Config.GetIntSetting(Setting.cleanser_watchDogTimerIntervalSec)*ticksInSec;

            watchTimer.Enabled = true;

            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(ConnectionsManager.OnControlRequest);

      }


   

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            switch(args.Command.ToLower())
            {
                case "showconnections":
                    XomControlConnection.SendMessage(ProcessShowConnections(args), args.RequestId);
                    args.Handled = true;   
                    break;
                case "resetconnections":
                    XomControlConnection.SendMessage(ProcessResetConnections(args), args.RequestId);
                    args.Handled = true;
                    break;
            }
        }

        public static string ProcessShowConnections(ControlRequestEventArgs args)
        {
            string result = Instance.DisplayClients();
            return "Registered clients: \r\n" + result;
        }

        public static string ProcessResetConnections(ControlRequestEventArgs args)
        {
            Instance.ResetConnections();
            return "Reset all client connections.\r\n";
        }

        public void Shutdown()
        {
            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "ConnectionsManager::Shutdown");

            tcpListener.Shutdown();
            lock(tcpActiveClients )
            {
                       
                for (int i = 0; i < maxTcpClients; i++)
                {
                    if (tcpActiveClients [i] != null)
                    {
                        AsynchronousSocketListener.CloseSocket (tcpActiveClients[i].WorkSocket);
                        tcpActiveClients [i] = null;
                    }
                }
             }
            
            watchTimer.Enabled = false;
        }
        
        public ConnectionState AddClient(Socket handler)
        {
            ConnectionState newClient = new ConnectionState();
            newClient.WorkSocket = handler;

            int openSlot = 0;
            lock(tcpActiveClients )
            {
                       
                for (openSlot = 0; openSlot < maxTcpClients; openSlot++)
                {
                    if (tcpActiveClients [openSlot] == null)
                    {
                        tcpActiveClients [openSlot] = newClient;
                        string logLine = "ADDCLIENT|"+newClient.ToLogString();
                        Xom.Log(XomAreaName.log, logLine);
                        break;
                    }
                }
             }

            if(openSlot >= maxTcpClients)
            {            
                Xom.NtEvent(XEvent.Id.CLEANSER_CONFIG_1, "The number of active clients exceeds the maximum allowed. Maximum clients configured is " + maxTcpClients);
                throw new Exception("The number of active clients exceeds the maximum allowed.");
            }
            
            CleanserCounters.Current.TcpConnectionsTotal.Increment();                            
            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "AddClient: "+newClient.ToString());

            return newClient;
        }

        public void ReleaseClient(ConnectionState state)
        {              
            int i = 0;

            lock(tcpActiveClients )
            {
                       
                for (i = 0; i < maxTcpClients; i++)
                {
                    if (tcpActiveClients [i] == state)
                    {
                        Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "ReleaseClient: " + state.ToString());
                        string logLine = "RELEASECLIENT|"+state.ToLogString();
                        Xom.Log(XomAreaName.log, logLine);
                        AsynchronousSocketListener.CloseSocket (tcpActiveClients[i].WorkSocket);
                        tcpActiveClients [i] = null;
                        break;
                    }
                }
             }


            if ( i < maxTcpClients)
            {
                CleanserCounters.Current.TcpConnectionsTotal.Decrement();
            }
            else
            {                
                Xom.NtEvent(XEvent.Id.CLEANSER_COMM_0, "Client has already been released. State object: " + state.ToString());
            }      
        }

        public void ReleaseClient(Socket handler)
        {              
            int i = 0;
            ConnectionState state = null;
            lock(tcpActiveClients )
            {
                for (i = 0; i < maxTcpClients; i++)
                {
                    if (tcpActiveClients [i].WorkSocket == handler)
                    {
                        state = tcpActiveClients [i];
                        break;
                    }
                }
            }

            if (state != null)
            {
                ReleaseClient(state);
            }
            else
            {
                AsynchronousSocketListener.CloseSocket(handler);
            }
        }
        
        public string DisplayClients()
        {
            StringBuilder bldr = new StringBuilder();
             lock(tcpActiveClients )
            {                       
                for (int i = 0; i < maxTcpClients; i++)
                {
                    
                    if(tcpActiveClients[i]!=null)
                    {
                        bldr.Append("\t");
                        bldr.Append(tcpActiveClients [i].ToXmgmtString());
                        bldr.Append("\r\n");
                    }
                }
            }
            return bldr.ToString();
        }

        public void ResetConnections()
        {
            lock( tcpActiveClients )
            {
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "Resetting all client connections." );
                string logLine = "RESETCONNECTIONS";
                Xom.Log(XomAreaName.log, logLine );

                for( int i = 0; i < maxTcpClients; i++ )
                {
                    if( null != tcpActiveClients[i] )
                    {
                        ReleaseClient( tcpActiveClients[i] );
                    }
                }
            }
        }
       
        private void OnTimer(Object source, ElapsedEventArgs e) 
        {
            DateTime now;
            now = DateTime.UtcNow;
            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "ConnectionManager::OnTimer The time is "+ now.ToString()+" Time to check on those clients");

            ArrayList clientsToKill = new ArrayList();

            int watchTimerClientDeadSec = Config.GetIntSetting(Setting.cleanser_clientDeadSec);
            lock(tcpActiveClients )
            {
                       
                for (int i = 0; i < maxTcpClients; i++)
                {
                    // Tick is 100-nanosecond
                    if (tcpActiveClients [i] != null &&
                        ((( now.Ticks - ((long)tcpActiveClients [i].lastReceiveTimeTicks))/10000000 > watchTimerClientDeadSec)
                        || (!tcpActiveClients [i].IsValidRemoteSocket())))
                    {
                        int missingCount = Interlocked.Increment(ref tcpActiveClients [i].clientDeclaredMissing);
                        if (missingCount <= ConnectionState.maxCountAllowedToBeMissing && tcpActiveClients [i].IsValidRemoteSocket() )
                        {
                            long l = now.Ticks - ((long)tcpActiveClients [i].lastReceiveTimeTicks);
                            Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW,"missing client alert, elapsed ticks = "+ l+ " client = " +  tcpActiveClients [i].ToString());
                            Xom.NtEvent(XEvent.Id.CLEANSER_COMM_1, "No data received from the client. Elapsed ticks = "+ l+ " client = " +  tcpActiveClients [i].ToString());
                        }
                        else
                        {
                            clientsToKill.Add(i);
                        }
                        Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "remoteIP = "+ tcpActiveClients[i].remoteIP+", componentId =" + tcpActiveClients[i].componentID + " checked");
                    }
                }
            }

            for (int i = 0; i<clientsToKill.Count; i++)
            {
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "Index of missing client in Release client: " + i);                           

                int curVictimIndex = (int)clientsToKill[i];
                Debug.Assert(curVictimIndex >= 0 && curVictimIndex < maxTcpClients);
                if (curVictimIndex >= 0 && curVictimIndex < maxTcpClients)
                {
                    ReleaseClient(tcpActiveClients [curVictimIndex]);
                }
            }

         if (watchTimer.Interval != Config.GetIntSetting(Setting.cleanser_watchDogTimerIntervalSec)*ticksInSec)
         {
                watchTimer.Interval = Config.GetIntSetting(Setting.cleanser_watchDogTimerIntervalSec)*ticksInSec;                    
         }
       }

    }

    public class CleanserConfig
    {
        static public IInterfaceInfo face;

        public static void Initialize()
        {
               // looking for a lost identity. Get all servers which expose cleanser interface and 
               // found the one with my IP address               
                string[] serverNames = Config.GetServerListByInterface(Interface.cleanser);
                IPHostEntry iphostentry = Dns.GetHostEntry(Dns.GetHostName());
                IInterfaceInfo curFace = null; 
                for(int i=0; i < serverNames.Length; i++)
                {
                    curFace = Config.GetInterface(serverNames[i], Interface.cleanser);
                    foreach(IPAddress ipaddress in iphostentry.AddressList)
                    {
                        if (curFace.IPAddress.Equals( ipaddress))
                        {
                            face = curFace;
                            break;
                        }
                    }
                    if (face != null)
                    {
                        break;
                    }
                }
                if (face == null)
                {
                    Xom.NtEvent(XEvent.Id.CLEANSER_CONFIG_2, "Invalid cleanser configuration. Cannot find cleanser IP/Port");
                    throw new Exception("Invalid cleanser configuration. Cannot find cleanser IP/Port");
                }        
           }
        
    }

   
    public class AsynchronousSocketListener 
    {

        private ManualResetEvent acceptDone = new ManualResetEvent(false);
        private Socket listener;

        public bool isShutdown;
        
        public AsynchronousSocketListener() 
        {
            isShutdown = false;
            listener = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        }
        public void Shutdown()
        {
            isShutdown = true;
            listener.Close();
        }

        public void StartListening() 
        {                       
            IPEndPoint localEndPoint = null;
            
            try 
            {   
                IInterfaceInfo myface = CleanserConfig.face;
                localEndPoint = new IPEndPoint(myface.IPAddress, myface.Port);
                
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "Listener thread listens on localEndPoint = " + localEndPoint);

                // Bind the socket to the local endpoint and listen for incoming connections.

                listener.Bind(localEndPoint);
                listener.Listen((int)SocketOptionName.MaxConnections);                

                while (!isShutdown) 
                {
                    // Set the event to nonsignaled state.
                    acceptDone.Reset();

                    // Start an asynchronous socket to listen for connections.
                    listener.BeginAccept(new AsyncCallback(AcceptCallback), listener);

                    // Wait until a connection is made before continuing.
                    acceptDone.WaitOne();
                    Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "AsynchronousSocketListener:: StartListening - waiting for clients client");
                }
            } 

            catch (SocketException e)
            {
                string lp = localEndPoint == null?"":localEndPoint.ToString();

                Xom.NtEvent(XEvent.Id.CLEANSER_CONFIG_3, e,
                    "Cannot open listener socket. Fix the socket state and restart cleanser.\r\nLocal Point: {0}", lp
                );
            }
            catch (Exception e) 
            {
                Xom.NtEvent(XEvent.Id.CLEANSER_CODE_0, e, "Exception caught.");
            }

        }

        public void AcceptCallback(IAsyncResult ar) 
        {
            Socket handler = null;
            
            try
            {
            // Get the socket that handles the client request.
                Socket listener = (Socket) ar.AsyncState;
                handler = listener.EndAccept(ar);               
                Debug.Assert(handler!=null);
                ConnectionState state = ConnectionsManager.Instance.AddClient(handler);

                handler.BeginReceive( state.buffer, 0, ConnectionState.BufferSize, 0, new AsyncCallback(ReadCallback), state);
            }
            catch (ObjectDisposedException e)
            {
                if (!isShutdown)
                {
                    Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: "+e.ToString());
                }
            }
            catch (Exception e)
            {
                ConnectionsManager.Instance.ReleaseClient(handler);
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: "+e.ToString());
            }

            finally
            {
            // Signal the main thread to continue.
                acceptDone.Set();     
            }
        }

        public void ReadCallback(IAsyncResult ar) 
        {
            ConnectionState state = null;
            Socket handler = null;
            try
            {    
                // Retrieve the state object and the handler socket
                // from the asynchronous state object.
                state = (ConnectionState) ar.AsyncState;
                handler = state.WorkSocket;

                Debug.Assert(handler!=null);
                // Read data from the client socket. 
                int bytesRead = handler.EndReceive(ar);

                if (bytesRead > 0) 
                {   
                    // if client does not adhere the protocol, ReadData throws an exception
                    ReadData(state, bytesRead);
                    handler.BeginReceive(state.buffer, state.bufferStart, ConnectionState.BufferSize-state.bufferStart, 0, new AsyncCallback(ReadCallback), state);
                }
                else 
                {
                    ConnectionsManager.Instance.ReleaseClient(state);
                }
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: " + e.ToString() + " stack: " + e);

                // We should log something here, since we are swallowing the error
                if (e is ExceptionWithEventId)
                {
                    ExceptionWithEventId e2 = (ExceptionWithEventId)e;
                    Xom.NtEvent(e2.EventId, e2, "Unexpected error in ReadCallback.\r\n{0}", 
                                (state != null) ? state.ToString() : "(no state)");
                }
                else if (!(e is ObjectDisposedException))
                {
                    Xom.NtEvent(XEvent.Id.CLEANSER_CODE_1, e, "Unexpected error in ReadCallback.\r\n{0}", 
                                (state != null) ? state.ToString() : "(no state)");
                }
                if(handler.Connected)
                {
                    ConnectionsManager.Instance.ReleaseClient(state);
                }
            }
             
         }

        static public void CloseSocket (Socket handler)
        {
            if (null == handler)
            {
                return;
            }
            
            try
            {
                string remoteIP = (IPAddress.Parse(((IPEndPoint)handler.RemoteEndPoint).Address.ToString())).ToString();
                string remotePort = ((IPEndPoint)handler.RemoteEndPoint).Port.ToString();
                
                handler.Shutdown(SocketShutdown.Both);
                handler.Close();
                handler = null;
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_LOW, "Client " + remoteIP +":"+ remotePort+" is gone.");
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Cannot close a socket: " + e.ToString());
            }
            
        }


        private void ReadData (ConnectionState state, int bytesRead)
        {   
            int bytesToProcess = state.bufferStart+bytesRead;
            using (MemoryStream ms = new MemoryStream(state.buffer, 0, bytesToProcess))
            {
                state.bufferStart = 0;
                int curMessageStartPosition = 0;
                bool adjustNextRead = false;
                int msgEndPosition = 0;
                short msgType = 0;
                ushort msgSize = 0;

                try
                {

                    // multiple messages of different types can be present in the buffer 
                    // read from tcp, split them and process
                    while (curMessageStartPosition < bytesToProcess)
                    {
                        msgType = 0;
                        msgSize = 0;

                        // number of bytes to process is less than the min, avoid XrlException thrown by WireData
                        msgEndPosition = curMessageStartPosition+ReportMessageBase.cMinMessageSizeBytes;
                        if(msgEndPosition > bytesToProcess)
                        {
                            adjustNextRead = true;  
                            break;
                        }
                        msgType = Convert.ToInt16(state.buffer[curMessageStartPosition]);

                        // We know the message type now, so we should know the total 
                        // length of the message (since it should be the headers plus 
                        // usSize field).
                        msgSize = BitConverter.ToUInt16(state.buffer, curMessageStartPosition + 2);
                        msgEndPosition += msgSize;

                        // Connect is busted, adjust for it
                        if (msgType == (short) RPT_MSG_TYPE.RPT_MSG_CONNECT)
                        {
                            msgEndPosition += 4;  // the size of the component id
                        }

                        if (msgEndPosition > bytesToProcess)
                        {
                            adjustNextRead = true;  
                            break;
                        }


                        // little factory based on type of the message
                        switch (msgType)
                        {
                            case ((short) RPT_MSG_TYPE.RPT_MSG_CONNECT):
                                 ReportMessageConnect connect = new ReportMessageConnect();
                                 connect.ReadStream(ms);
                                 state.OnConnect(connect.iComponentID, connect.llTime, connect.vcServer);
                            break;

                            case ((short) RPT_MSG_TYPE.RPT_MSG_DATA):
                                ReportMessageData data = new ReportMessageData();
                                data.ReadStream(ms);
                                state.OnData(new ReportMessageData3(data));
                                break;

                            case ((short)RPT_MSG_TYPE.RPT_MSG_DATA_2):
                                ReportMessageData2 data2 = new ReportMessageData2();
                                data2.ReadStream(ms);
                                state.OnData(new ReportMessageData3(data2));
                                break;

                            case ((short)RPT_MSG_TYPE.RPT_MSG_DATA_3):
                                ReportMessageData3 data3 = new ReportMessageData3();
                                data3.ReadStream(ms);
                                state.OnData(data3);
                                break;

                            case ((short) RPT_MSG_TYPE.RPT_MSG_KEEPALIVE):
                                ReportMessageBase alive = new ReportMessageBase();
                                alive.ReadStream(ms);
                                state.OnKeepAlive(alive.llTime);
                            break;

                            case ((short) RPT_MSG_TYPE.RPT_MSG_DISCONNECT):
                                ReportMessageBase disconnect = new ReportMessageBase();
                                disconnect.ReadStream(ms);
                                state.OnDisconnect(disconnect.llTime);                            
                            break;

                            default:
                                // Garbage. Corrupt stream. Throw exception, causing 
                                // re-establishment of connection, to get back on 
                                // track.
                                string eventText = String.Format(
                                    "Unknown message type 0x{0} found at position {1}. BytesToProcess: {2}. Connection will be reset.",
                                    msgType, curMessageStartPosition, bytesToProcess);
                                throw new ExceptionWithEventId(XEvent.Id.CLEANSER_CODE_1, eventText);
                        }

                        if (adjustNextRead)
                        {
                            break;
                        }
                        curMessageStartPosition = (int) ms.Position;                    
                        
                    }
                
                }
                catch (EndOfStreamException e)
                {
                    Xom.NtDataEvent(XEvent.Id.CLEANSER_MESSAGE_ENDOFSTREAM, e,
                                    state.buffer,
                                    "Unexpected error while deserializing message at position {0} out of {1}.\r\n" +
                                    "msgType={2}, msgSize={3}\r\n{4}",
                                    curMessageStartPosition, bytesToProcess, msgType, msgSize, state.ToString());
                    adjustNextRead = true;
                }
                catch (XRLException e)
                {
                    // Note about exceptions: 
                    // an XRLException is assumed to have come from WireData when 
                    // deserializing the message. I suppose we assume it means an 
                    // EndOfStream exception, and adjust the next read. Any other 
                    // exception likely indicates corruption, and since this is a stream 
                    // of messages, we can't really "auto-correct" and get synced back up.  
                    // So we actually want ReadData to throw these exceptions, the caller 
                    // will catch it and release the connection, which will then 
                    // re-establish the connection and get back on track.

                    if (e.InnerException is EndOfStreamException)
                    {
                        Xom.NtDataEvent(XEvent.Id.CLEANSER_MESSAGE_ENDOFSTREAM, e,
                                        state.buffer,
                                        "Unexpected error while deserializing message at position {0} out of {1}.\r\n" +
                                        "msgType={2}, msgSize={3}\r\n{4}",
                                        curMessageStartPosition, bytesToProcess, msgType, msgSize, state.ToString());
                        adjustNextRead = true;
                    }
                    else
                    {
                        throw;
                    }
                }

                if( adjustNextRead)
                {
                    // last message in the buffer read is not complete, copy it to the beginning of the buffer
                    // and append the rest of the messsage on the next read
                    int lastMsgStartLen = bytesToProcess - curMessageStartPosition;
                    
                    ms.Position = curMessageStartPosition;
                    ms.Read(state.buffer, 0, lastMsgStartLen);
                    state.bufferStart = lastMsgStartLen;
                }
                
           }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\svr\Transform.cs ===
using System;
using System.Data;
using System.Text;
using System.Data.SqlClient;
using System.Collections;
using System.Runtime.InteropServices;
using System.Threading;
using System.Xml;
using System.IO;
using System.Collections.Specialized;
using System.Collections.Generic;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities2;


namespace xonline.server.cleanser.svr
{
    public class TransformManager
    {
        private const int c_MaxInvalidLogStringIdChars = 32;
        private const int c_MaxInvalidMessageChars = 128;

        private static TransformManager instance = null;
        private FastThreadPool fastThreadPool = null;
        private int numProcessThreads;
        private int isDroppedEvent;

        public static int isShutdown = 0;
        private static HashSet<char> invalidPathCharacters;

        static TransformManager()
        {
            invalidPathCharacters = new HashSet<char>(Path.GetInvalidFileNameChars());
            invalidPathCharacters.Add('='); // this character interferes with xom log settings
        }

        private Dictionary<string, XomFileTarget> cleanserFileTargets = new Dictionary<string, XomFileTarget>();
        private ReaderWriterLockSlim lockCleanserFileTargets = new ReaderWriterLockSlim();

        public int QueueCount
        {
            get { return fastThreadPool.QueueCount; }
        }

        private TransformManager()
        {
            isShutdown = 0;
        }

        public void Shutdown()
        {
            //
            // Just return if we've already been called
            //
            if (1 == Interlocked.Exchange(ref isShutdown, 1))
            {
                return;
            }

            // Wait for all the processing threads to end normally since isShutdown means they won't keep running.          

            DateTime stopWaitingTime = DateTime.UtcNow + TimeSpan.FromSeconds(1);
            while ((stopWaitingTime - DateTime.UtcNow).TotalSeconds > 0 &&
                   QueueCount > 0)
            {
                Thread.Sleep(10);
            }

            try
            {
                fastThreadPool.Shutdown();
            }
            catch (Exception)
            {
            }

            // Force flush the files
            FlushTargets();
        }

        public static TransformManager Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new TransformManager();
                    instance.Initialize();
                }
                return instance;
            }
        }

        public void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            switch (args.Command.ToLower())
            {
                case "help":
                    XomControlConnection.SendMessage(
                        "To show open clients connections information:\r\n" +
                        "   ShowConnections\r\n" +
                        "To close all open client connections: \r\n" +
                        "   ResetConnections\r\n" +
                        "To clear and force-reload the NPDB setting for log locations: \r\n" +
                        "   ReloadLogSettings\r\n" +
                        "To show the length of the queue: \r\n" +
                        "   ShowQueue\r\n"
                        , args.RequestId);
                    args.Handled = true;
                    break;
                case "showqueue":
                    XomControlConnection.SendMessage(TransformManager.Instance.QueueCount.ToString() + "\r\n", args.RequestId);
                    args.Handled = true;
                    break;
                case "reloadlogsettings":
                    FlushTargets();
                    args.Handled = true;
                    break;

            }
        }

        private void Initialize()
        {
            int numThreadsPerProc = Config.GetIntSetting(Setting.cleanser_workerThreadsPerProcessor);
            numProcessThreads = Environment.ProcessorCount * numThreadsPerProc;

            // Test and make sure we have the NPDB settings we need to start the cleanser
            try
            {
                string logRoot = Config.GetSetting(Setting.setup_logroot);
                string ConfigString = Config.GetSetting(Setting.cleanser_XomFileTarget);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.CLEANSER_CONFIG_0, e, "Failed to initialize cleanser because required NPDB setting(s) were missing.");
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: " + e.ToString());
                throw;
            }

            // Pool of our worker threads for processing incoming messages
            fastThreadPool = new FastThreadPool(
                Config.ComponentName, 
                numProcessThreads, 
                numProcessThreads, 
                ThreadPriority.Normal, 
                10, 
                Config.GetIntSetting(Setting.cleanser_maxQueueLength));

            // Register for setting changes
            Config.SettingChange += new SettingChangeEventHandler(OnSettingChange);

            // Xmgmt commands
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

        }

        private void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            switch(eventArgs.Setting)
            {
                case Setting.setup_logroot:
                case Setting.cleanser_XomFileTarget:
                    {
                        //If the log target or logroot changes, wipe out the hashtable of file targets
                        //so they are force-reloaded. (The hashtable autoloads on demand)
                        FlushTargets();
                    }
                    break;
            }
        }

        private void FlushTargets()
        {

            Dictionary<string, XomFileTarget> oldTargets = cleanserFileTargets;

            lockCleanserFileTargets.EnterWriteLock();
            try
            {
                // Swap out a brand new dictionary for the old one, and clear the old one 
                // outside the lock.
                cleanserFileTargets = new Dictionary<string, XomFileTarget>(cleanserFileTargets.Count);
            }
            finally
            {
                lockCleanserFileTargets.ExitWriteLock();
            }

            foreach (KeyValuePair<string, XomFileTarget> td in oldTargets)
            {
                XomFileTarget ft = td.Value;
                ft.Close();
            }
        }

        public void QueueMessage(object dt)
        {
            if (1 == isShutdown)
            {
                if (0 != Interlocked.Exchange(ref isDroppedEvent, 0))
                {
                    Xom.NtEvent(XEvent.Id.CLEANSER_COMM_2, "[TransformManager.QueueMessage]: Cleanser is shutting down. Incoming messages will not be processed. Messages are being LOST!");
                }
                CleanserCounters.Current.InMessagesDroppedPerSecond.Increment();
                CleanserCounters.Current.InMessagesDroppedTotal.Increment();
                return;
            }

            // Queue it and do it
            if (fastThreadPool.QueueUserWorkItem(WorkItemCallback, dt))
            {
                // Success!

                CleanserCounters.Current.WorkQueueLength.Increment();
                CleanserCounters.Current.InMessageQueueLength.Increment();
            
                if (0 != Interlocked.Exchange(ref isDroppedEvent, 0))
                {
                    Xom.NtEvent(XEvent.Id.CLEANSER_INFO_4, "[TransformManager.QueueMessage]: Incoming queue is no longer full. Accepting new buffers.");
                }
            }
            else
            {
                // Fail

                if (1 != Interlocked.Exchange(ref isDroppedEvent, 1))
                {
                    Xom.NtEvent(XEvent.Id.CLEANSER_COMM_2, "[TransformManager.QueueMessage]: Incoming queue is full. Dropping buffer. Max queue length is: " + fastThreadPool.MaxQueueCount.ToString());
                }
                CleanserCounters.Current.InMessagesDroppedPerSecond.Increment();
                CleanserCounters.Current.InMessagesDroppedTotal.Increment();

                MessageData objData = (MessageData)dt;
                if (null != objData)
                {
                    Xom.Log(
                        XomAreaName.cleansermissingdata, 
                        "DROPPEDMSG|" + objData.message);
                }
            }

            CleanserCounters.Current.InRawMessagesPerSecond.Increment();
        }

        private void WorkItemCallback(object param)
        {
            MessageData data = param as MessageData;
            try
            {
                ProcessMessage(data);
            }
            catch (Exception e)
            {
                try
                {
                    Xom.NtEvent(XEvent.Id.CLEANSER_CODE_3, e, 
                                "Unhandled exception in WorkItemCallback, MessageData: {0}", 
                                data.ToString());
                }
                catch (Exception)
                {}
            }
            finally
            {
                CleanserCounters.Current.WorkQueueLength.Decrement();
            }
        }

        public void ProcessMessage(MessageData data)
        {
            CleanserCounters.Current.InMessageQueueLength.Decrement();
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            // Early check of validity
            if (!IsValidFileName(data.logStringId))
            {
                InvalidMessage(data);
                goto DoneProcessing;
            }

            string fileTargetKey;

            fileTargetKey = DecodeFileTargetKey(data);
            XomFileTarget fileTarget = null;
            lockCleanserFileTargets.EnterReadLock();
            try
            {
                if (!cleanserFileTargets.TryGetValue(fileTargetKey, out fileTarget))
                {
                    // Very rare case (after intial startup) where we need to create a new 
                    // file target. Note we avoid an UpgradeableReadLock since it only 
                    // allows multiple readers, not multiple UpgradeableReadLockers. 
                    lockCleanserFileTargets.ExitReadLock();
                    lockCleanserFileTargets.EnterWriteLock();
                    try
                    {
                        // The conditions prior to releasing the read lock no longer 
                        // apply. Do over!
                        if (!cleanserFileTargets.TryGetValue(fileTargetKey, out fileTarget))
                        {
                            fileTarget = InitializeNewPrefixLog(fileTargetKey, data);
                        }
                    }
                    finally
                    {
                        lockCleanserFileTargets.ExitWriteLock();
                        lockCleanserFileTargets.EnterReadLock();
                    }
                }

                if (fileTarget != null)
                {
                    // Protect inside read lock to prevent wayward flushing / rollover / 
                    // clearing from going on.
                    fileTarget.Log(
                        XomLogTargetContext.Empty,  // @@@ TODO: get this for real
                        "cleanser",
                        1,
                        1,
                        null,
                        data.message,
                        null);
                }
            }
            finally
            {
                lockCleanserFileTargets.ExitReadLock();
            }

            // Outside the lock, no need to hold it for this
            if (fileTarget == null)
            {
                InvalidMessage(data);
                goto DoneProcessing;
            }

DoneProcessing:
            CleanserCounters.Current.AverageExecutionTime.IncrementBy(timeElapsed.MillisecondsElapsed);
            CleanserCounters.Current.AverageExecutionTimeBase.Increment();
            CleanserCounters.Current.MessagesPerSecond.Increment();
            CleanserCounters.Current.MessagesTotal.Increment();
        }

        private void InvalidMessage(MessageData data)
        {
            string logStringId = data.logStringId;
            if (logStringId != null && logStringId.Length > c_MaxInvalidLogStringIdChars)
            {
                logStringId = logStringId.Substring(0, c_MaxInvalidLogStringIdChars);
            }
                
            string message = data.message;
            if (message != null && message.Length > c_MaxInvalidMessageChars)
            {
                message = message.Substring(0, c_MaxInvalidMessageChars);
            }
                
            Xom.Log(XomAreaName.cleansermissingdata, "INVALIDMSG|{0}|{1}|{2}|{3}|{4}|{5}",
                    data.connectionState.componentID,
                    data.connectionState.remoteServer,
                    logStringId,
                    data.eventFingerprint,
                    data.message != null ? data.message.Length : 0,
                    message
                   );
            CleanserCounters.Current.MessagesFailedPerSecond.Increment();
            CleanserCounters.Current.MessagesFailedTotal.Increment();
        }

        private XomFileTarget InitializeNewPrefixLog(string fileTargetKey, MessageData message)
        {
            // Note: it's expected that the function calling this is holding a write lock
            // to lockCleanserFileTargets.
            string configString;
            string logFolderName;
            string logFileName;
            string logRoot;

            logFolderName = DecodeLogFolderName(message);
            logFileName = DecodeLogFileName(message);

            // These checks aren't strictly necessary since we already verified 
            // logStringId, but doing them again ensures against future breaks if our 
            // Decode functions change.
            if (!IsValidFileName(logFolderName) ||
                !IsValidFileName(logFileName))
            {
                // No good, let caller deal with it.
                return null;
            }

            configString = "";

            try
            {
                if (!string.IsNullOrEmpty(message.eventFingerprint))
                {
                    CleanserSrv.storageManager.EnqueueEventWrite(message.eventFingerprint, logFolderName, message.eventHeaderVersion, message.manifestKey);
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(
                    XEvent.Id.CLEANSER_ETX_ADD_FAIL, e, 
                    "Failed to queue up the etx event for writing: {0}.", 
                    message.eventFingerprint);
                
                Xom.Trace(
                    XomAreaName.cleansertrace, LogLevel.L_ERROR, 
                    "Failed to queue up the etx event for writing: {0}.\n{1}", 
                    message.eventFingerprint, e);
            }

            try
            {
                DateTime now;

                logRoot = Config.GetSetting(Setting.setup_logroot);
                configString = Config.GetSetting(Setting.cleanser_XomFileTarget);

                now = DateTime.UtcNow;

                configString = configString.Replace("#LOGROOT#", logRoot);
                configString = configString.Replace("#COMPONENT#", Config.ComponentName);
                configString = configString.Replace("#NEWLOGPREFIX#", logFolderName);
                configString = configString.Replace("#MACHINE#", Config.Server.ToLower());
                configString = configString.Replace("#LOGFILEKEY#", logFileName);
                
                XomFileTarget fileTarget = new XomFileTarget(ConfigUtil.GetParams(configString));

                try
                {
                    // Try to create the file. We need to find out if it is a valid file 
                    // and path (too long? invalid chars?) since Log() will silently fail 
                    // this, but still spam the event log. 
                    fileTarget.LazyCreateFile(false);
                }
                catch (PathTooLongException)
                {
                    // Return null and let caller gracefully handle this. Unhandled 
                    // exceptions will result in event spam.
                    return null;
                }

                cleanserFileTargets.Add(
                    fileTargetKey, 
                    fileTarget);

                return fileTarget;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.CLEANSER_CONFIG_0, e, "Failed to initialize new logging prefix for prefix: {0}.", configString);
                Xom.Trace(XomAreaName.cleansertrace, LogLevel.L_ERROR, "Exception caught: " + e);
                throw;
            }
        }

        // The Decode methods are all tied to log line schema - schema changes
        // may impact their implementation.

        private const int LogIdentifierColumn = 1;

        private string DecodeLogFileName(MessageData message)
        {
            if (string.IsNullOrEmpty(message.eventFingerprint))
            {
                return message.logStringId;
            }
            else
            {
                return string.Format("{0}.{1}",
                    message.logStringId,
                    message.manifestKey);
            }
        }

        private string DecodeLogFolderName(MessageData message)
        {
            return message.logStringId;
        }

        private string DecodeFileTargetKey(MessageData message)
        {
            return string.Format("{0}|{1}",
                message.logStringId,
                message.manifestKey);
        }

        private bool IsValidFileName(string name)
        {
            if (String.IsNullOrEmpty(name))
            {
                return false;
            }

            for (int c = 0; c < name.Length; c++)
            {
                if (invalidPathCharacters.Contains(name[c]))
                {
                    return false;
                }
            }
            return true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\svr\ProjectInstaller.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

//#define DEV_TEST

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.service;

[RunInstallerAttribute(true)]
public class ProjectInstaller: System.Configuration.Install.Installer{

    private ServiceInstaller serviceInstaller;
    private ServiceProcessInstaller processInstaller;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public ProjectInstaller()
        {
            // This call is required by the Designer.
            InitializeComponent();
        }

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }


 #region Component Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            processInstaller = new ServiceProcessInstaller();
            serviceInstaller = new ServiceInstaller();
          

#if (DEV_TEST)
            processInstaller.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
#else
            IComponentInfo compInfo = Config.GetComponent(xonline.common.config.Component.cleanser);

            LSAUtil.GrantLogonRights( compInfo.Username );

            processInstaller.Account = System.ServiceProcess.ServiceAccount.User;
            processInstaller.Username = compInfo.Username;

            CSetupSecureResolver decoder = new CSetupSecureResolver();
            processInstaller.Password = decoder.UserSecret(compInfo.Password);
#endif
  
            serviceInstaller.ServiceName = "Cleanser";
            serviceInstaller.DisplayName = "Xbox Live Reporting Cleanser Service";
            serviceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
            serviceInstaller.Committed += new System.Configuration.Install.InstallEventHandler(this.Cleanser_Committed);

            Installers.Add(serviceInstaller);
            Installers.Add(processInstaller);

            }
#endregion

    private void Cleanser_Committed(object sender, System.Configuration.Install.InstallEventArgs e)
    {
        System.ServiceProcess.ServiceController svc = new System.ServiceProcess.ServiceController("cleanser");
        svc.Start();
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\common\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\common\comphelper.cs ===
using System;


namespace xonline.server.comps.common 
{
    class EliminationHelper
    {
        //
        // Utilities
        //
        public static uint RoundsFromEntrants(uint entrants)
        {
            uint        n = (uint)entrants - 1; 
            uint        rounds;

            // Given the number of entrants e, we need to find the next biggest 
            //  power of 2 value such that 2^r = e, where r is the number of rounds.
            for (rounds = 0; n > 0; rounds++)
            {
                n = n >> 1;
            }

            return rounds;
        }       
    }
}


namespace xonline.server.comps.common 
{
    class CompHelper
    {              
        //
        // Round Interval Helper Method
        //
        public static TimeSpan IntervalToTimeSpan(DateTime dtReference, uint frequency, uint interval, int dayMask)
        {
            TimeSpan        tsInterval = new TimeSpan(0);
            
            switch (interval)
            {
            case Comp.XONLINE_COMP_INTERVAL_SECOND:
                tsInterval = TimeSpan.FromSeconds(frequency);
                break;
                
            case Comp.XONLINE_COMP_INTERVAL_MINUTE:
                tsInterval = TimeSpan.FromMinutes(frequency);
                break;
                
            case Comp.XONLINE_COMP_INTERVAL_HOUR:
                tsInterval = TimeSpan.FromHours(frequency);
                break;
                
            case Comp.XONLINE_COMP_INTERVAL_DAY:
                tsInterval = new TimeSpan(0);

                // If DayMask = 0, assume all days are selected
                if (0 == dayMask)
                {
                    dayMask = (int)Comp.XONLINE_COMP_DAY_MASK_ALL;
                }
                
                // Need to test DayMask and skip unmasked days. 
                if (0 != (dayMask & Comp.XONLINE_COMP_DAY_MASK_ALL))
                {
                    int    Bit;
                    
                    while (frequency > 0)
                    {
                        tsInterval = tsInterval.Add(TimeSpan.FromDays(1));

                        Bit = 1 << (int)((dtReference + tsInterval).DayOfWeek);

                        if (0 != (dayMask & Bit))
                        {
                            frequency--;
                        }                    
                    }
                }
                break;
                
            case Comp.XONLINE_COMP_INTERVAL_WEEK:
                tsInterval = TimeSpan.FromDays(frequency * 7);
                break;
                
            case Comp.XONLINE_COMP_INTERVAL_DAYOFYEAR:
                tsInterval = TimeSpan.FromDays(frequency);
                break;
                
            case Comp.XONLINE_COMP_INTERVAL_MONTH:
                tsInterval = dtReference.AddMonths((int)frequency) - dtReference;
                break;
                
            case Comp.XONLINE_COMP_INTERVAL_QUARTER:
                tsInterval = dtReference.AddMonths((int)frequency * 3) - dtReference;
                break;
                
            case Comp.XONLINE_COMP_INTERVAL_YEAR:
                tsInterval = dtReference.AddYears((int)frequency) - dtReference;
                break;
            }            
            
            return tsInterval;
        }
        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cleanser\test\dvt\cleansertest.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.mgmt;
//using xonline.common.config;
using xonline.common.sql.sqlclient;
using xonline.common.stfutil;
using xonline.server.cleanser.svr;

using xonline.common.config;


[TestGroup, Owner("pedrofv"), TestFrequency("Regression"), EnvRequirement("DVT")]
public class CleanserDevTest : TestNode
{
    CleanserSrv service = null;
    Socket rptSock;

    string serverName = "";
    int componentID = 16;

    /*    [TestGroupSetup]
        public void Setup()
        {        
          
        }
    
        [TestGroupTearDown]
        public void Shutdown()
        {
            DisconnectFromCleanser();
            if (service != null)
            {
                service.Stop();
            }
        }    
        */

    [TestCase]
    public void TestGenericMessaging()
    {
        int componentID = (int)3; //random component

        Console.WriteLine("This is a test of the generic message system");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();

        Console.WriteLine("Send some sample non-identified transfer messages");
        string genericmsg1 = "FOO|111168D68F420|9E8D68D68F420|9E8D68D68F433|9E8D68D68F444|1|2|BAADBEEF";
        string genericmsg2 = "BAR|111168D68F421|9E8D68D68F421|22222222222222";
        string genericmsg3 = "BAZ|111168D68F422||||something";

        //Send messages 1 and 2 with the same time stamp.
        data.szMessage = genericmsg1;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(genericmsg1));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = genericmsg2;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(genericmsg2));
        // data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = genericmsg3;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(genericmsg3));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);
        DisconnectFromCleanser();
    }

    [TestCase]
    public void TestLicenseRequest()
    {
        int componentID = (int)6;

        Console.WriteLine("This is a test of the license request messages. It should only accept hresults of 0.");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();
        //Message 1 has a 0 hresult, message 2 does not.
        Console.WriteLine("Send some sample usage store offers messages");
        string licenseMsg1 = "LICENSE_REQUEST|01234567-0123-0123-0123-0123456789ab|21234567-0123-0123-0123-0123456789ab|901234567890A|A01234567890A|B01234567890A|0";
        string licenseMsg2 = "LICENSE_REQUEST|31234567-0123-0123-0123-0123456789ab|41234567-0123-0123-0123-0123456789ab|901234567890A|A01234567890A|B01234567890A|A01234567890A";
        string licenseMsg3 = "LICENSE_REQUEST|e9d2b731-6ece-471d-966b-aa8c8b182d5c|33c0fbb6-2f2e-4b11-93bf-0277f9433e42|fa0000000000011f|fa0000000000011f|9030c4778db69|0";


        //Send messages 
        data.szMessage = licenseMsg1;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(licenseMsg1));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);


        data.szMessage = licenseMsg2;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(licenseMsg2));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = licenseMsg3;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(licenseMsg3));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);


        DisconnectFromCleanser();
    }


    [TestCase]
    public void TestUsageStore()
    {
        int componentID = (int)9;

        Console.WriteLine("This is a test of the purchase offers messages");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();
        //Message 1 is not ad supported, message 2 is.
        Console.WriteLine("Send some sample usage store offers messages");
        string usageMsg1 = "USAGE_STORE|901234567890A|01234567-0123-0123-0123-0123456789ab|||1|5|6/20/2007 2:10:08 PM|1";
        string usageMsg2 = "USAGE_STORE|901234567890A|01234567-0123-0123-0123-0123456789ab|01234567-0123-0123-0123-0123456789aC|1|9|5|6/20/2007 2:10:08 PM";


        //Send messages 
        data.szMessage = usageMsg1;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(usageMsg1));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);


        data.szMessage = usageMsg2;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(usageMsg2));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void TestPurchaseOffers()
    {
        int componentID = (int)6; //Xbos4:36 PM 9/14/2007

        Console.WriteLine("This is a test of the purchase offers messages");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();
        //Message 1 has a promotion ID, message 2 does not.
        //Message 1 comes from store 1, xbox, while message 2 comes from store 2, Zune.
        Console.WriteLine("Send some sample purchase offers messages");
        string purchaseMsg1 = "PurchaseOffersReporting|111168D68F421|211168D68F422|fake-ip|1|1286EA85-62E9-48D7-963B-F7BEAE00846C|1|2|3.14|USD|10.20|ESD|1286EA85-62E9-48D7-963B-F7BEAE00846D|1|1";
        string purchaseMsg2 = "PurchaseOffersReporting|9030c4638674a|fa00000012341234|10.20.0.94|4|00010011-0008-0060-0000-000a02010001|8|400|0.0000|USD|0.0000|USD||0|1";
        string purchaseMsg3 = "PurchaseOffersReporting|411168D68F421|211168D68F422|fake-ip|1|1286EA85-62E9-48D7-963B-F7BEAE00846C|1|222|2.1700|EUR|29.400|RUS||1|2";


        //Send messages 
        data.szMessage = purchaseMsg1;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(purchaseMsg1));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);


        data.szMessage = purchaseMsg2;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(purchaseMsg2));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);
        //DisconnectFromCleanser();

        data.szMessage = purchaseMsg3;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(purchaseMsg3));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);
        DisconnectFromCleanser();
    }

    [TestCase]
    public void TestEliteLicenseTransfer()
    {
        int componentID = (int)6; // xonline.server.xbos;

        Console.WriteLine("This is a test of the elite license transfer system");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();

        Console.WriteLine("Send some sample elite transfer messages");
        //LICTRANSFER|SGNonce|UserPUID|OldMachineID|NewMachineID|UserLicenses|MachineLicenses|hr
        string elitemsg1 = "LICTRANSFER|111168D68F420|9E8D68D68F420|9E8D68D68F433|9E8D68D68F444|1|2|BAADBEEF";
        string elitemsg2 = "LICTRANSFER|111168D68F421|9E8D68D68F421|9E8D68D68F434|9E8D68D68F445|3|4|AAAABBBB";
        string elitemsg3 = "LICTRANSFER|111168D68F422|9E8D68D68F422|9E8D68D68F435|9E8D68D68F446|5|6|FFFF0001";

        //Send messages 1 and 2 with the same time stamp.
        data.szMessage = elitemsg1;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(elitemsg1));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = elitemsg2;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(elitemsg2));
        // data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = elitemsg3;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(elitemsg3));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);
        DisconnectFromCleanser();
    }

    [TestCase]
    public void TestArgonLogging()
    {
        //XE 89756 -- add LS- prefix to message
        int componentID = (int)8; // xonline.server.stringsvr;

        Console.WriteLine("This is a test of the argon messaging system");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();

        Console.WriteLine("Send some sample argon messages");
        //LS-DHW|<machine_puid>|<MSGDATA_ASCIITEXT>
        string argonmsg1 = "LS-DHW|9E8D68D68F420|TEST PART ONE";
        string argonmsg2 = "LS-DHW|9E8D68D68F420|TEST PART ONE AS WELL";
        string argonmsg3 = "LS-DHW|9E8D68D68F421|TEST PART TWO";

        //Send messages 1 and 2 with the same time stamp and machine PUID
        data.szMessage = argonmsg1;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(argonmsg1));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = argonmsg2;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(argonmsg2));
        // data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = argonmsg3;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(argonmsg2));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void TestGeoFencing()
    {

        int componentID = (int)6; // Component.xpserver;

        Console.WriteLine("This is a test of geofencing");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();

        Console.WriteLine("Send the five geofencing elements");
        // <featureAreaHeader>|<reasonCode>|user_puid|machine_puid|user_ip|geoinfo_country|offerID
        string geofenoffer1 = "GeoFenceOfferPurchase|Filter|9E8D68D68F420|9E8D68D68F420|127.0.0.1|USA|12341234";
        string geofenoffer2 = "GeoFenceContentReferral|Filter|9F46B46B4A4F2|9F46B46B4A4A4|127.0.0.2|CAN|12341235";

        //<featureAreaHeader>|<reasonCode>|user_puid|machine_puid|user_ip|geoinfo_country|wmid|videoType
        string geofenoffer3 = "GeoFenceVideoPurchase|Filter|9F46B46B4A4F3|9F46B46B4A4A3|127.0.0.4|USA|1286EA85-62E9-48D7-963B-F7BEAE00846C|1";
        string geofenoffer4 = "GeoFenceVideoAcquireURL|Filter|9F46B46B4A4F4|9F46B46B4A4A6|127.0.0.5|CAN|1286EA85-62E9-48D7-963B-F7BEAE00846D|2";
        string geofenoffer5 = "GeoFenceVideoAcquireLicense|Filter|9F46B46B4A4F5|9F46B46B4A4A5|127.0.0.6|CAN|1286EA85-62E9-48D7-963B-F7BEAE00846E|3";



        data.szMessage = geofenoffer1;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(geofenoffer1));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = geofenoffer2;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(geofenoffer2));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = geofenoffer3;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(geofenoffer3));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = geofenoffer4;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(geofenoffer4));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = geofenoffer5;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(geofenoffer5));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);




        DisconnectFromCleanser();
    }


    [TestCase]
    public void AccountMigrateTest()
    {
        int componentID = 7; // Component.xuacs;

        ConnectToCleanser(componentID);
        Console.WriteLine("Xbox1 migrate account:valid input");
        //		MIGRATEXBOX1USER|userPassportPuid|userPuid|hr
        string logLine = "MIGRATEXBOX1USER|9E8D68D68F420|9E8D68D68F421|0";
        SendMessage(componentID, logLine);

        Console.WriteLine("Xbox.com migrate account:valid input");
        logLine = "MigrateXboxComUser|9E8D68D68F420|9E8D68D68F421|0";
        SendMessage(componentID, logLine);

        Console.WriteLine("Xbox.com migrate account:hr!=0");
        logLine = "MigrateXboxComUser|9E8D68D68F420|9E8D68D68F421|0fff";
        SendMessage(componentID, logLine);

        Console.WriteLine("Xbox.com migrate account: user_puid = 0");
        logLine = "MigrateXboxComUser|9E8D68D68F420|9E8D68D68F421|0fff";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();

    }

    [TestCase]
    public void AccountProvisionTest()
    {
        int componentID = 5; // Component.xcbk;

        ConnectToCleanser(componentID);
        Console.WriteLine("Xbox1 migrate account:valid input");
        //	PROVISIONSERVICE|aPuid|userPuid|serviceInstanceId|oldXboxOfferId|oldTierId|newXboxOfferId|newTierId
        string logLine = "PROVISIONSERVICE|9000000000409|9000000000408|irMAAAAAAAABAAEA|FFFE000080000008|6|FFFE000080000008|6|1";

        SendMessage(componentID, logLine);

        logLine = "DEPROVISIONSERVICE|1B341235|aaaaaa|1B341235|3|1B341235|6|0";
        logLine = "DEPROVISIONSERVICE|9000000000A1C|9000000000A1B|tsMCAAAAAAABAAEA|FFFE000080000008|6|FFFE000080000008|6|0";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }

    [TestCase]
    public void BannerViewAggTest()
    {
        //LSA-BAN_VW|bannerID|count
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LSA-BAN_VW|537422EA0EC69934|2";
        SendMessage(componentID, logLine);
        SendMessage(componentID, logLine);
        SendMessage(componentID, logLine);
        logLine = "LSA-BAN_VW|0|0";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }

    [TestCase]
    public void BannerViewTest()
    {
        //LS-BAN_VW|bannerID|userPUID|clientTimestamp|sequenceNumber
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LS-BAN_VW|537422EA0EC69934|9000000000A1C|2|1";
        SendMessage(componentID, logLine);
        logLine = "LS-BAN_VW|0|9000000000A1C|0|1";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }

    [TestCase]
    public void BannerClickAggTest()
    {
        //LSA-BAN_VW|bannerID|count
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LSA-BAN_CL|537422EA0EC69934|2";
        SendMessage(componentID, logLine);
        SendMessage(componentID, logLine);
        logLine = "LSA-BAN_CL|0|2";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void BannerClickTest()
    {
        //LS-BAN_VW|bannerID|userPUID|clientTimestamp|sequenceNumber
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LS-BAN_CL|537422EA0EC69934|9000000000A1C|2|1";
        SendMessage(componentID, logLine);
        logLine = "LS-BAN_CL|537422EA0EC69934|0|2|1";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void BannerPurchaseTest()
    {
        //LS-MP_P|bannerID|offerID|userPUID|clientTimestamp
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LS-MP_P|537422EA0EC69934|100|9000000000A1B|2";
        SendMessage(componentID, logLine);
        logLine = "LS-MP_P|0|0|9000000000A1B|2";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }



    [TestCase]
    public void BannerPurchaseTestNewFormat()
    {
        //LS-MP_P|bannerID|offerID|userPUID|clientTimestamp|GUID
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LS-MP_P|137422EA0EC69934|101|9000000000A1B|2|1286EA85-62E9-48D7-963B-F7BEAE00846C";
        SendMessage(componentID, logLine);
        logLine = "LS-MP_P|0|0|2000000000A1B|21286EA85-62E9-48D7-963B-F7BEAE00846D";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void BannerPurchaseAggTest()
    {
        //LSA-MP_P|bannerID|offerID|count
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LSA-MP_P|537422EA0EC69934|10|2";
        SendMessage(componentID, logLine);
        SendMessage(componentID, logLine);

        logLine = "LSA-MP_P|0|0|2";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void FusionTest()
    {
        //LS-FU|TitleID|hr|userPuid|clientTimestamp
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LS-FU|100|0|9000000000A1B|2";
        SendMessage(componentID, logLine);
        logLine = "LS-FU|0|1|9000000000A1B|2";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void FusionAggTest()
    {
        //LSA-FU|TitleID|hr|count
        int componentID = 8;
        ConnectToCleanser(componentID);
        string logLine = "LSA-FU|100|0|2";
        SendMessage(componentID, logLine);
        SendMessage(componentID, logLine);

        logLine = "LSA-FU|0|0|0";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void LicenseTest()
    {
        //ARGOLICENSE|clientTimestamp|wmid|ownerMachinePUID|currentMachinePUID|userPUID
        int componentID = 6; // Component.xbos
        ConnectToCleanser(componentID);
        string logLine = "ARGOLICENSE|0|6286EA85-62E9-48D7-963B-F7BEAE00846E|9000000000A1C|9000000000A1B|9000000000A1D|1";
        SendMessage(componentID, logLine);

        logLine = "ARGOLICENSE|0|6286EA85-62E9-48D7-963B-F7BEAE00846B|9000000000A1E|9000000000A1D|9000000000A1F|0";
        SendMessage(componentID, logLine);

        logLine = "ARGOLICENSE|0|6286EA85-62E9-48D7-963B-F7BEAE00846B|0|9000000000A1D|9000000000A1F|0";
        SendMessage(componentID, logLine);

        logLine = "ARGOLICENSE|0|0|0|0|9000000000A1D|1";
        SendMessage(componentID, logLine);

        DisconnectFromCleanser();
    }


    [TestCase]
    public void ContentTest()
    {
        int componentID = (int)6; // Component.xbos;
        Console.WriteLine("This is content download test");
        ConnectToCleanser(componentID);
        //   TimeStamp|CONTENTREF|MachineID|userPUID0|userPUID1|userPUID2|userPUID3|titleID|offerID|hresult|referralNonce|Nonce
        //                                                    machine PUID          user PUID0               TitleID      OfferID                         Nonce
        string logLine = "CONTENTREF|9E8D68D68F420|97D8FD8FDB11A|0|0|0|53450031|5345003120050111|0|fffffff|123123123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:puid0 =0, puid1!=0");
        logLine = "CONTENTREF|9E8D68D68F420|0|97D8FD8FDB11B|97D8FD8FDB11C|0|53450031|5345003120050111|0|fffffff|123123123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:puid0 =0, puid1 =0, puid2!=0");
        logLine = "CONTENTREF|9E8D68D68F420|0|97D8FD8FDB11B|97D8FD8FDB11C|0|53450031|5345003120050111|0|fffffff|123123123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:puid0 =0, puid1=0, puid2!=0");
        logLine = "CONTENTREF|9E8D68D68F420|0|0|97D8FD8FDB11C|0|53450031|5345003120050111|0|fffffff|123123123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:puid0 =0, puid1=0, puid2=0, puid3! = 0");
        logLine = "CONTENTREF|9E8D68D68F420|0|0|0|97D8FD8FDB11D|53450031|5345003120050111|0|fffffff|123123123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:puid0 =0, puid1!=0, puid2=0, puid3! = 0");
        logLine = "CONTENTREF|9E8D68D68F420|0|97D8FD8FDB11B|0|97D8FD8FDB11D|53450031|5345003120050111|0|fffffff|123123123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:hr!=0");
        logLine = "CONTENTREF|9E8D68D68F420|0|97D8FD8FDB11B|0|97D8FD8FDB11D|53450031|5345003120050111|123|fffffff|123123123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:wrong number of fields in the line");
        logLine = "CONTENTREF|9E8D68D68F420|97D8FD8FDB11A|9E8D68D68F420|53450031";
        SendMessage(componentID, logLine);


        Console.WriteLine("Content download:wrong type of a field in the line");
        logLine = "CONTENTREF|asdfg|97D8FD8FDB11A|9E8D68D68F420|53450031|5345003120050111|123123123123123"; ;
        SendMessage(componentID, logLine);


        Console.WriteLine("Content download:wrong type of a field in the line");
        logLine = "CONTENTREF|9E8D68D68F420|97D8FD8FDB11AAAAAAA|9E8D68D68F420|53450031|5345003120050111|123123123123123"; ;
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:tabs inside a field");
        logLine = "CONTENTREF|9E8D68D68F420|97D         8FD8    FDB11 |9E8D68D68F420|53450031|5345003120050111|123123123123123"; ;
        SendMessage(componentID, logLine);

        Console.WriteLine("Content download:tabs and new line inside a field");
        logLine = "CONTENTREF|9E8D68D68F420|                        \r\n\r\n\r\n\r\n9E8D68D68F420|9E8D68D68F420|53450031|5345003120050111|123123123123123"; ;
        SendMessage(componentID, logLine);

        DisconnectFromCleanser();
    }

    [TestCase]
    public void ContentXeTest2()
    {
        int componentID = 6; // Component.xbos;
        //      Timestamp|XeContentReferral|owner_machinePuid|userPuid|MachinePuid|contentId|packageSize|installSize|locations|hresult|Nonce
        ConnectToCleanser(componentID);
        Console.WriteLine("Fail on testnet");
        string logLine = "XeContentReferral|12345566|900000000173a|9500000000000|daa14067efd7078fe9a7ae9ff80c6d3681184a28||||0|0|";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }

    [TestCase]
    public void ContentXeTest()
    {
        int componentID = 6; // Component.xbos;
        //        Timestamp|XeContentReferral|owner_machinePuid|userPuid|MachinePuid|contentId|packageSize|installSize|locations|hresult|Nonce
        ConnectToCleanser(componentID);
        Console.WriteLine("Xe Content download:valid input");
        string logLine = "XeContentReferral|9E8D68D68F420|9E8D68D68F421|9E8D68D68F422|5345003120050111|12|34|1234|0|123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Xe Content download: machinePuid = 0");
        logLine = "XeContentReferral|9E8D68D68F420|9E8D68D68F421|0|5345003120050111|12|34|1234|0|123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Xe Content download: userPuid = 0");
        logLine = "XeContentReferral|9E8D68D68F420|0|9E8D68D68F421|5345003120050111|12|34|1234|0|123123123";
        SendMessage(componentID, logLine);

        Console.WriteLine("Xe Content download: hresult != 0");
        logLine = "XeContentReferral|9E8D68D68F420|9E8D68D68F421|9E8D68D68F422|5345003120050111|12|34|1234|fff|123123123";
        SendMessage(componentID, logLine);

        DisconnectFromCleanser();
    }

    [TestCase]
    public void ConentHugeTest()
    {
        int componentID = 6; // Component.xbos;

        Console.WriteLine("This is content download test");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();

        string logLine = "CONTENTREF|9E8D68D68F420|97D8FD8FDB11A|0|0|0|53450031|5345003120050111|0|fffffff|";
        long currentTime = DateTime.UtcNow.ToFileTimeUtc();


        for (int j = 0; j < 10000; j++)
        {
            MemoryStream ms = new MemoryStream();
            for (int i = 0; i < 1000; i++)
            {
                currentTime += 100000;
                data.szMessage = logLine + i + j * 10000000;
                data.usSize = (ushort)(Encoding.UTF8.GetByteCount(logLine));
                data.llTime = currentTime;
                //              data.llTime =now +i*1000000+j*100000000;
                byte[] oneMessage = (byte[])data;

                ms.Write(oneMessage, 0, oneMessage.Length);
            }

            ms.Position = 0;
            byte[] buf = new byte[ms.Length];
            ms.Read(buf, 0, (int)ms.Length);
            Send(buf);
            ms.Close();
        }

        ReportMessageBase disconnect = new ReportMessageBase();
        disconnect.bMsgType = (byte)RPT_MSG_TYPE.RPT_MSG_DISCONNECT;

        Send((byte[])disconnect);
        DisconnectFromCleanser();
    }

    [TestCase]
    public void PresenceTitleTest()
    {

        int componentID = 17; // Component.xpserver;

        Console.WriteLine("This is presence title test");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();
        // LineType|      MachinePUID|     TitleID|    UserPUID|              State|Xbox IP|    Xbox port|SessKey
        string logLineStart = "TITLESTART|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|DFFFFFF|1020|4D530064";
        //   TITLEND|MachinePUID|     TitleID|    UserPUID|        State|Xbox IP|Xbox port|SessKey|Duration(ms)
        string logLineEnd = "TITLEND|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|DFFFFFF|1020|4D530064|30000";

        data.szMessage = logLineStart;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineStart));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);
        Thread.Sleep(10);

        data.szMessage = logLineEnd;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineEnd));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);


        data.szMessage = "TITLESTART|FA00000000000011|FFFE07D1|900000000060F|1|CFEE3441|20C|8CF5A1";
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(data.szMessage));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);


        Console.WriteLine("No TitleStart, crossing 24 hours boundaries");
        logLineEnd = "TITLEND|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|12341234|1020|4D530064|5265C00";
        data.szMessage = logLineEnd;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineEnd));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);

        Console.WriteLine("No TitleStart, not crossing 24 hours boundaries");
        logLineEnd = "TITLEND|9F46B46B4A4F1|100E90A|9F46B46B4A4F4|123|12341234|1020|4D530064|526";
        data.szMessage = logLineEnd;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineEnd));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);

        DisconnectFromCleanser();
    }

    [TestCase]
    public void PresenceEndBeforeStartTest()
    {

        int componentID = 17; // Component.xpserver;

        Console.WriteLine("This is presence coalese test. Send title start after title end");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();
        // LineType|      MachinePUID|     TitleID|    UserPUID|              State|Xbox IP|    Xbox port|SessKey
        string titleStart = "TITLESTART|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|DFFFFFF|1020|4D530064";
        //   TITLEND|MachinePUID|     TitleID|    UserPUID|        State|Xbox IP|Xbox port|SessKey|Duration(ms)
        string titleEnd = "TITLEND|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|DFFFFFF|1020|4D530064|7530";

        data.szMessage = titleEnd;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(titleEnd));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);

        data.szMessage = titleStart;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(titleStart));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        Console.WriteLine("Send session start after session end");
        string sessStart = "SESSTART|9F46B46B4A4F1|100E90A|9F46B46B4A4A3|123|12341234";
        // SESEND|MachinePUID|      TitleID|UserPUID|        State|SessionID|Duration(ms
        string sessEnd = "SESEND|9F46B46B4A4F1|100E90A|9F46B46B4A4A3|123|12341234|7530";
        data.szMessage = sessEnd;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(sessEnd));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);

        data.szMessage = sessStart;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(sessStart));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        DisconnectFromCleanser();
    }

    [TestCase]
    public void QTest()
    {
        int componentID = 6; // Component.xbos;

        Console.WriteLine("This is presence test");
        ConnectToCleanser(componentID);
        ReportMessageData data = new ReportMessageData();
        long userPuid = 0x5F5E0A6;
        string logLine;
        for (int i = 0; i < 10000; i++)
        {
            logLine = "CONTENTREF|9E8D68D68F420|" + (userPuid + i).ToString() + "|0|0|0|53450031|5345003120050111|0|fffffff|";
            data.szMessage = logLine;
            data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLine));
            data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
            Send((byte[])data);
        }

        DisconnectFromCleanser();
    }

    [TestCase]
    public void PresenceGuestsTest()
    {
        int componentID = 17; // Component.xpserver;

        Console.WriteLine("This is presence test");
        ConnectToCleanser(componentID);
        ReportMessageData data = new ReportMessageData();

        //TimeStamp|GUESTCHG|MachinePUID|TitleID|UserPUID|State|OldGuests|NewGuests
        string logLine = "GUESTCHG|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|0|3";
        data.szMessage = logLine;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLine));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        logLine = "GUESTCHG|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|3|2";
        data.szMessage = logLine;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLine));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);

        logLine = "GUESTCHG|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|1|2";
        data.szMessage = logLine;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLine));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() + 30 * 10000000;
        Send((byte[])data);

        logLine = "GUESTCHG|9F46B46B4A4F1|100E90A|9F46B46B4A4F3|123|1|2";
        data.szMessage = logLine;

        DateTime tomorrow = DateTime.UtcNow.AddDays(1);
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLine));
        data.llTime = tomorrow.ToFileTimeUtc();
        Send((byte[])data);

        DisconnectFromCleanser();
    }

    [TestCase]
    public void PresenceSessionTest()
    {
        int componentID = 17; // Component.xpserver;

        Console.WriteLine("This is presence test");
        ConnectToCleanser(componentID);

        ReportMessageData data = new ReportMessageData();

        //                                        SESSTART|MachinePUID|TitleID|UserPUID|State|SessionID        
        string logLineStart = "SESSTART|9F46B46B4A4F1|100E90A|9F46B46B4A4A3|123|12341234";

        // SESEND|MachinePUID|      TitleID|UserPUID|        State|SessionID|Duration(ms)
        string logLineEnd = "SESEND|9F46B46B4A4F1|100E90A|9F46B46B4A4A3|123|12341234|30000";

        data.szMessage = logLineStart;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineStart));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);

        data.szMessage = logLineEnd;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineEnd));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() + 1000000;
        Send((byte[])data);


        data.szMessage = "SESEND|90000000019C3|FFFE0000|9000000000D0D|3|2579DB4B16580080|E1B35";
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineEnd));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() + 1000000;
        Send((byte[])data);

        data.szMessage = "SESSTART|FA00000000000000|FFFF0072|9000000000D0B|13|9155DDB108F40181";
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(data.szMessage));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 50 * 10000000;
        Send((byte[])data);

        data.szMessage = "SESSTART|9000000000101|FFED19FB|9000000000D0D|3|D6407B667D590080";
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineStart));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc() - 30 * 10000000;
        Send((byte[])data);


        Console.WriteLine("Session crosses midnight");
        logLineStart = "SESSTART|9F46B46B4A4F2|100E90A|9F46B46B4A4B3|123|12341236";
        data.szMessage = logLineStart;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineStart));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);

        logLineEnd = "SESEND|9F46B46B4A4F2|100E90A|9F46B46B4A4B3|123|12341236|5265C00";
        data.szMessage = logLineEnd;
        DateTime tomorrow = DateTime.UtcNow.AddDays(1);
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLineEnd));
        data.llTime = tomorrow.ToFileTimeUtc();
        Send((byte[])data);


        Console.WriteLine("SESEND without SESSTART");
        logLineEnd = "SESEND|9F46B46B4A4F3|100E90A|9F46B46B4A4C3|123|1234125|50000";
        SendMessage(componentID, logLineEnd);

        Console.WriteLine("SESEND without SESSTART, titleId = 0");
        logLineEnd = "SESEND|9F46B46B4A4F4|0|9F46B46B4A4D3|123|12341234|50000";
        SendMessage(componentID, logLineEnd);

        Console.WriteLine("SESEND without SESSTART, userId = 0");
        logLineEnd = "SESEND|9F46B46B4A4F5|1230|0|123|12341234|50000";
        SendMessage(componentID, logLineEnd);

        Console.WriteLine("SESEND without SESSTART, over 24h");
        logLineEnd = "SESEND|9F46B46B4A4F6|1230|1111FFFF|123|12341235|5265C00";
        SendMessage(componentID, logLineEnd);

        DisconnectFromCleanser();
    }


    [TestCase]
    public void ExhaustConnectionsTest()
    {
        Console.WriteLine("Keep connecting till no more connections available");
        int i = 0;
        try
        {
            while (true)
            {
                // Create a TCP/IP socket.
                rptSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                //assumes that the test runs against xblob
                IInterfaceInfo face = Config.GetSingleInterface(Interface.cleanser);
                IPEndPoint remoteEP = new IPEndPoint(face.IPAddress, face.Port);
                // Connect to the remote endpoint.
                rptSock.Connect(remoteEP);
                i++;
            }
        }
        catch (Exception e)
        {
            Console.WriteLine("After " + i + "connections. Exception caught: " + e.ToString());
        }
    }

    [TestCase]
    public void ProtocolTest()
    {
        Console.WriteLine("Protocol test");
        Console.WriteLine("Case1: normal flow, no data");
        ConnectToCleanser(componentID);

        ReportMessageConnect connect = new ReportMessageConnect();

        serverName = "Protocol_Test";

        connect.vcServer = serverName;
        connect.usSize = 64;
        connect.iComponentID = componentID;

        ReportMessageBase alive = new ReportMessageBase();
        alive.bMsgType = (byte)RPT_MSG_TYPE.RPT_MSG_KEEPALIVE;

        ReportMessageData data = new ReportMessageData();

        string logLine = "KIA|9F46B46B4A4F1|E010980C9714CAE7|100E90A|78848F00|9C75075078EE1|4D530064|203|7|B106E044|20C|112F5B";
        data.szMessage = logLine;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLine) + 1);

        ReportMessageBase disconnect = new ReportMessageBase();
        disconnect.bMsgType = (byte)RPT_MSG_TYPE.RPT_MSG_DISCONNECT;

        Send((byte[])connect);


        for (int i = 0; i < 2; i++)
        {
            Thread.Sleep(1000);
            Send((byte[])alive);
            Send((byte[])data);
            Thread.Sleep(1000);
        }


        Send((byte[])disconnect);
        DisconnectFromCleanser();


        Console.WriteLine("Case 2: error, no RPT_MSG_TYPE.RPT_MSG_CONNECT");
        ConnectToCleanser(componentID);
        Send((byte[])alive);
        Send((byte[])alive);

        DisconnectFromCleanser();

        Console.WriteLine("Case 3: Multiple RPT_MSG_TYPE.RPT_MSG_CONNECT with the same serverID, componentID");
        ConnectToCleanser(componentID);
        Send((byte[])connect);
        Send((byte[])connect);
        Send((byte[])connect);
        Send((byte[])alive);
        DisconnectFromCleanser();

        Console.WriteLine("Case 4: Multiple RPT_MSG_TYPE.RPT_MSG_CONNECT with the different serverID, componentID");
        ConnectToCleanser(componentID);

        serverName = "Protocol_Test_2";
        connect.vcServer = serverName;
        connect.usSize = 64;
        connect.iComponentID = 13;
        Send((byte[])connect);

        DisconnectFromCleanser();
    }

    [TestCase]
    public void SendMsgTest()
    {
        int componentID = (int)17; // Component.xpserver;

        ConnectToCleanser(componentID);
        string logLine = "SND|A14CA34:9EE|0|67300000135|673|80|5|3A|5|9FFFFFFFFFDE0;9FFFFFFFFFDE2|0";
        SendMessage(componentID, logLine);
        // TimeStamp|SND|IP:port|SenderPUID|SenderContext|SenderTitleId|messageFlags|ExpireMin|Details|MessageType|RecipientsList|hr
        logLine = "SND|0:0|9000000000760|0|FFC0FE00|0|A8C0|4|2|9000000000B5F|0";
        SendMessage(componentID, logLine);
        DisconnectFromCleanser();
    }


    [TestCase]
    public void CreateAccountTest()
    {
        int componentID = (int)7; // Component.xuacs;

        ConnectToCleanser(componentID);
        //              TimeStamp|CREATEACCOUNT|UserPUID|          hresult|gamertag|   email|                  countryId|postalCode|languageId|machinePUID|titleID|OfferID|Voucher

        string logLine = "CREATEACCOUNT|9000000001A07|0|StfPN93i55au672|xboxstress@winisp.net|103|98014|1|9400000000000|0|FFFE000080000008|460d1abd933833bad54f47bc83b04226e9c96223";

        SendMessage(componentID, logLine);

        //            CREATELIVEACCOUNT|machinePuid|userPassportPuid|ownerPassportPuid|userPuid|      hresult|GamerTag       |Email| PostalCode|countryId|languageId|cultureId|titleId|offerId|voucher
        logLine = "CREATELIVEACCOUNT|9400000000000|9000000001A07|9000000001A08|9000000001A09|0|StfPN93i55au672|xboxstress@winisp.net|98014|103|1|5|11111|FFFE000080000008|460d1abd933833bad54f47bc83b04226e9c96223";
        SendMessage(componentID, logLine);

        logLine = "CREATELIVEACCOUNT|FA00000000000102|573F5F84FA6B5646|573F5F84FA6B5646||80070057|Xe0c07acd3HGMJJ|Xe0c07acd3HGMJJ@xboxtest.com||0|0||FFFE07D1||0|";
        SendMessage(componentID, logLine);

        //            CREATEXBOXCOMACCOUNT|userPassportPuid|ownerPassportPuid|machinePuid|userPuid|hresult|gamerTag|      Email|PostalCode|countryId|languageId|cultureId
        logLine = "CREATEXBOXCOMACCOUNT|37FFF8154041A|37FFF8154041A|9400000000000|900000010E087|0|XEN4uua3ua88a76|john.smith@example.com|98052|103|1|1033";
        SendMessage(componentID, logLine);

        DisconnectFromCleanser();

    }


    [TestCase]
    public void XePurchaseTest()
    {
        int componentID = (int)6; // Component.xbos;

        ConnectToCleanser(componentID);
        //           machinePUID      userPUID       country|lang|tier| offerID   |paymentType|priceW|priceF|payInstr|hr|Nonce
        string logLine = "XeOfferPurchase|9400000000000|9400000001A07|103|1|3|FFFE000080000008|1|4|99|123123|0|12123123123";
        SendMessage(componentID, logLine);

        logLine = "XeOfferPurchase|212321|900000000106d|103|1|3|ffeeffee000000|4|0|0||8015000a|0";
        SendMessage(componentID, logLine);

        logLine = "XeOfferPurchase|9400000000000|9400000001A07|103|1|3|FFFE000080000008|1|4|99|123123|FF4|12123123123";
        SendMessage(componentID, logLine);

        DisconnectFromCleanser();
    }

    [TestCase, Description("Sets the name of the manifest log file.")]
    public void MD3ManifestKeyTest()
    {
        ConnectToCleanser(6);

        ReportMessageData3 md3 = new ReportMessageData3();
        md3.szMessage = "XboxComCleanserTest|9400000000000|9400000001A07|103|1|3|FFFE000080000008|1|4|99|123123|FF4|12123123123";
        md3.EtxEventHeaderVersion = 1;
        md3.FileNameKey = "XboxComCleanserTest";
        Send((byte[])md3);

        DisconnectFromCleanser();
    }

    private void SendMessage(int componentID, string logLine)
    {

        ReportMessageData data = new ReportMessageData();
        data.szMessage = logLine;
        data.usSize += (ushort)(Encoding.UTF8.GetByteCount(logLine));
        data.llTime = DateTime.UtcNow.ToFileTimeUtc();
        Send((byte[])data);
    }

    [TestCase]
    public void CleanserStartup()
    {
        service = new CleanserSrv();
        service.Start();
    }

    [TestCase]
    public void CleanserShutdown()
    {
        if (null == service)
        {
            CleanserStartup();
        }
        service.Stop();
    }

    private void ConnectToCleanser(int componentID)
    {
        if (rptSock != null && rptSock.Connected)
        {
            return;
        }
        // Create a TCP/IP socket.
        rptSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

        // Make it run both environments: xblox and stressnet
        string[] szServers;

        szServers = Global.XEnv.GetServerListByInterface(Interface.cleanser);
        IInterfaceInfo face = Config.GetInterface(szServers[0], Interface.cleanser);

        IPEndPoint remoteEP = new IPEndPoint(face.IPAddress, face.Port);
        // Connect to the remote endpoint.
        rptSock.Connect(remoteEP);

        ReportMessageConnect connect = new ReportMessageConnect();
        connect.vcServer = szServers[0];
        connect.usSize = (ushort)szServers[0].Length;
        connect.iComponentID = componentID;
        Send((byte[])connect);
    }



    private void DisconnectFromCleanser()
    {
        if (rptSock != null && rptSock.Connected)
        {
            ReportMessageBase disconnect = new ReportMessageBase();
            disconnect.bMsgType = (byte)RPT_MSG_TYPE.RPT_MSG_DISCONNECT;
            Send((byte[])disconnect);
            try
            {
                rptSock.Shutdown(SocketShutdown.Both);
                rptSock.Close();
                rptSock = null;
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception caught: " + e.Message);
            }
        }
    }


    private void Send(byte[] buffer)
    {
        int sizeSent = rptSock.Send(buffer, SocketFlags.None);
        if (sizeSent != buffer.Length)
        {
            throw new Exception("Failed to send full message: original size = " + buffer.Length + " sent size  = " + sizeSent);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_1_none_12.4.56.0_none_2756e3c643f947fe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.manifest
XP_MANIFEST_PATH=manifests\x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.cat
XP_CATALOG_PATH=manifests\x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.cat
XP_PAYLOAD_PATH=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_1_none_12.4.56.0_none_2756e3c643f947fe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.manifest
XP_MANIFEST_PATH=manifests\x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.cat
XP_CATALOG_PATH=manifests\x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.cat
XP_PAYLOAD_PATH=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_compscommon_none_12.4.56.0_none_ac221954887af642
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=compscommon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92.manifest
XP_MANIFEST_PATH=manifests\msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92.cat
XP_CATALOG_PATH=manifests\msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92.cat
XP_PAYLOAD_PATH=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=compscommon,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\cron\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\cron\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\common\compdefs.cs ===
using System;

namespace xonline.server.comps.common 
{
    public class Comp
    {
        
        //
        // Attribute IDs
        //
        // Format: |Service|Reserved|Datatype|Dataset|IDx4|
        //  Bit 31 indicates service attribute ID (as opposed to title specific attribute)
        //  Bits 26-30 are reserved
        //  Bits 25 indicates a parameter rather than an attribute. This is used for XQS support (X_ATTRIBUTE_DATAFLAG_PARAM)
        //  Bits 24 is reserved
        //  Bits 20-23 indicate attribute datatype as specified in xon.cs
        //  Bits 16-19 indiate the dataset the attribute relates to (a relative grouping value)
        //  Low order 16 bits are the attribute ID
        //       
        public const uint XONLINE_QUERY_ENTITY_ID                 = 0x80000000;
        public const uint XONLINE_QUERY_OWNER_PUID                = 0x80000001;        
        public const uint XONLINE_QUERY_OWNER_GAMERTAG            = 0x81000001;        
        public const uint XONLINE_QUERY_CHANGED_TIME              = 0x80000002;
        
        public const uint XONLINE_COMP_ATTR_ID                    = 0x80010000;
        public const uint XONLINE_COMP_ATTR_REG_OPEN              = 0x80010001;
        public const uint XONLINE_COMP_ATTR_REG_CLOSE             = 0x80010002;
        public const uint XONLINE_COMP_ATTR_COMP_START            = 0x80010003;
        public const uint XONLINE_COMP_ATTR_COMP_CLEANUP          = 0x80010004;
        public const uint XONLINE_COMP_ATTR_COMP_CLEANUP_DAYS     = 0x80010004;     // same value, better name
        public const uint XONLINE_COMP_ATTR_ROUND_FREQUENCY       = 0x80010005;
        public const uint XONLINE_COMP_ATTR_ROUND_INTERVAL        = 0x80010006;
        public const uint XONLINE_COMP_ATTR_ROUND_DAY_MASK        = 0x80010007;
        public const uint XONLINE_COMP_ATTR_ROUNDS                = 0x80010008;
        public const uint XONLINE_COMP_ATTR_CURRENT_ROUND         = 0x80010009;
        public const uint XONLINE_COMP_ATTR_CURRENT_ROUND_START   = 0x8001000A;
        public const uint XONLINE_COMP_ATTR_CURRENT_ROUND_END     = 0x8001000B;
        public const uint XONLINE_COMP_ATTR_ROUND_DURATION_MIN    = 0x8001000B;
        public const uint XONLINE_COMP_ATTR_ROUND_ONE_START       = 0x8001000C;
        public const uint XONLINE_COMP_ATTR_ROUND_ONE_END         = 0x8001000D;
        public const uint XONLINE_COMP_ATTR_NAME                  = 0x8011000E; 
        public const uint XONLINE_COMP_ATTR_APD_OFFSET_MIN        = 0x8001000F;
        public const uint XONLINE_COMP_ATTR_IS_TEAM_COMP          = 0x80010010;
        public const uint XONLINE_COMP_ATTR_TEAM_SIZE             = 0x80010011;
        public const uint XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS      = 0x80010012;
        public const uint XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS     = 0x80010013;
        public const uint XONLINE_COMP_ATTR_MIN_SLOTS             = 0x80010014;
        public const uint XONLINE_COMP_ATTR_BYES                  = 0x80010016;
        public const uint XONLINE_COMP_ATTR_BYES_GRANTED          = 0x80010017;
        public const uint XONLINE_COMP_ATTR_PUBLIC_ENTRANTS       = 0x80010018;
        public const uint XONLINE_COMP_ATTR_PRIVATE_ENTRANTS      = 0x80010019;        
        public const uint XONLINE_COMP_ATTR_REMINDER_MIN          = 0x8001001A;        
        public const uint XONLINE_COMP_ATTR_PLAY_BEFORE_MIN       = 0x8001001B;        
        public const uint XONLINE_COMP_ATTR_PLAY_AFTER_MIN        = 0x8001001C;                
        public const uint XONLINE_COMP_ATTR_STATUS                = 0x8001001D; 
        public const uint XONLINE_COMP_ATTR_DESCRIPTION           = 0x8001001E; 
        public const uint XONLINE_COMP_ATTR_URL                   = 0x8001001F; 
        public const uint XONLINE_COMP_ATTR_LEADERBOARD_ID0       = 0x80010020; 
        public const uint XONLINE_COMP_ATTR_LEADERBOARD_ID1       = 0x80010021; 
        public const uint XONLINE_COMP_ATTR_LEADERBOARD_ID2       = 0x80010022; 
        public const uint XONLINE_COMP_ATTR_LEADERBOARD_ID        = 0x80010020; 
        public const uint XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME    = 0x80010023; 
        public const uint XONLINE_COMP_ATTR_CURRENT_ROUND_APD     = 0x80010024;
               

        public const uint XONLINE_COMP_ATTR_ENTRANT_PUID          = 0x80020000;
        public const uint XONLINE_COMP_ATTR_ENTRANT_GAMERTAG      = 0x81120000;
        public const uint XONLINE_COMP_ATTR_ENTRANT_STATUS        = 0x80020001;
        public const uint XONLINE_COMP_ATTR_ENTRANT_TRUST         = 0x80320002;
        public const uint XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND = 0x80020003;
        public const uint XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT  = 0x80020004;
        public const uint XONLINE_COMP_ATTR_ENTRANT_SEED          = 0x80020005;
        public const uint XONLINE_COMP_ATTR_ENTRANT_ELIMINATED    = 0x80020006;
        public const uint XONLINE_COMP_ATTR_ENTRANT_CURRENT_EVENT = 0x80020007;
        public const uint XONLINE_COMP_ATTR_ENTRANT_CURRENT_START = 0x80020008;
        public const uint XONLINE_COMP_ATTR_ENTRANT_COMP_SORT     = 0x80020009;
        public const uint XONLINE_COMP_ATTR_ENTRANT_CURRENT_INDEX = 0x8002000a;
        public const uint XONLINE_COMP_ATTR_ENTRANT_HRESULT       = 0x8002000b;
        public const uint XONLINE_COMP_ATTR_ENTRANT_SCORE         = 0x8002000c;

        
        public const uint XONLINE_COMP_ATTR_EVENT_ENTITY_ID       = 0x80030000;
        public const uint XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID     = 0x80030001;
        public const uint XONLINE_COMP_ATTR_EVENT_ROUND           = 0x80030002;
        public const uint XONLINE_COMP_ATTR_EVENT_START           = 0x80030003;
        public const uint XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY     = 0x80030006;
        public const uint XONLINE_COMP_ATTR_EVENT_NEXT_START      = 0x80030007;
        public const uint XONLINE_COMP_ATTR_EVENT_P1              = 0x80030008;
        public const uint XONLINE_COMP_ATTR_EVENT_P1_GAMERTAG     = 0x81130008;
        public const uint XONLINE_COMP_ATTR_EVENT_P1_CHECKIN      = 0x80030009;
        public const uint XONLINE_COMP_ATTR_EVENT_P1_TRUST        = 0x8023000A;
        public const uint XONLINE_COMP_ATTR_EVENT_P2              = 0x8003000B;
        public const uint XONLINE_COMP_ATTR_EVENT_P2_GAMERTAG     = 0x8113000B;
        public const uint XONLINE_COMP_ATTR_EVENT_P2_CHECKIN      = 0x8003000C;
        public const uint XONLINE_COMP_ATTR_EVENT_P2_TRUST        = 0x8023000D;
        public const uint XONLINE_COMP_ATTR_EVENT_WINNER          = 0x8003000E;
        public const uint XONLINE_COMP_ATTR_EVENT_LOSER           = 0x8003000F;
        public const uint XONLINE_COMP_ATTR_EVENT_MIN             = 0x80030010;
        public const uint XONLINE_COMP_ATTR_EVENT_MAX             = 0x80030011;
        
        public const uint XONLINE_COMP_ATTR_BRACKET_ROUND         = 0x80040001;
        public const uint XONLINE_COMP_ATTR_BRACKET_INDEX         = 0x80040002;
        public const uint XONLINE_COMP_ATTR_BRACKET_SLOTS         = 0x80040003;
        public const uint XONLINE_COMP_ATTR_BRACKET_ENTRANTS      = 0x80040004;
        public const uint XONLINE_COMP_ATTR_BRACKET_CHECKED_IN    = 0x80040007;
        public const uint XONLINE_COMP_ATTR_BRACKET_BYES          = 0x80040005;
        public const uint XONLINE_COMP_ATTR_BRACKET_BYES_GRANTED  = 0x80040006;
        public const uint XONLINE_COMP_ATTR_BRACKET_END           = 0x80040008;
        public const uint XONLINE_COMP_ATTR_BRACKET_START         = 0x80040009;
        public const uint XONLINE_COMP_ATTR_BRACKET_STATUS        = 0x8004000A;
        public const uint XONLINE_COMP_ATTR_BRACKET_APD           = 0x8004000B;
        public const uint XONLINE_COMP_ATTR_BRACKET_LEADERBOARD   = 0x8004000C;
        // parameters
        public const uint XONLINE_COMP_ATTR_BRACKET_MIN_ROUND     = 0x820400F0;
        public const uint XONLINE_COMP_ATTR_BRACKET_MAX_ROUND     = 0x820400F1;
        

        public const uint XONLINE_COMP_ATTR_LB_ROUND              = 0x80040001;
        public const uint XONLINE_COMP_ATTR_LB_ID                 = 0x80040002;

        public const uint XONLINE_QUERY_CURRENT_TIME              = 0x82000003;
        
        
        //
        // Action IDs
        //

        // Client actions
        public const uint XONLINE_COMP_ACTION_JOIN              = 1;
        public const uint XONLINE_COMP_ACTION_JOIN_PRIVATE      = 2;
        public const uint XONLINE_COMP_ACTION_WITHDRAW          = 3;
        public const uint XONLINE_COMP_ACTION_CHECKIN           = 4;
        public const uint XONLINE_COMP_ACTION_REQUEST_BYE       = 5;
        public const uint XONLINE_COMP_ACTION_REQUEST_PASS      = 6;
        public const uint XONLINE_COMP_ACTION_SUBMIT_RESULTS    = 7;
        public const uint XONLINE_COMP_ACTION_FORFEIT           = 8;
        public const uint XONLINE_COMP_ACTION_CANCEL            = 9;
        public const uint XONLINE_COMP_ACTION_EJECT             = 10;
        public const uint XONLINE_COMP_ACTION_DEBUG_ADVANCE_TIME = 99;

        // Service actions
        public const uint XONLINE_COMP_ACTION_INITALIZE         = 20;    
        public const uint XONLINE_COMP_ACTION_SLOTTING          = 21;
        public const uint XONLINE_COMP_ACTION_PROGRESSION       = 22;
        public const uint XONLINE_COMP_ACTION_FINALIZE          = 23;
        public const uint XONLINE_COMP_ACTION_CLEANUP           = 24;
        public const uint XONLINE_COMP_ACTION_REMINDERS         = 25;
        public const uint XONLINE_COMP_ACTION_AUTO_PROGRESSION  = 26;


        //
        // Interval Constants (these match SQL servers built in interval denominations)
        //
        public const uint XONLINE_COMP_INTERVAL_SECOND          = 1;
        public const uint XONLINE_COMP_INTERVAL_MINUTE          = 2;
        public const uint XONLINE_COMP_INTERVAL_HOUR            = 3;
        public const uint XONLINE_COMP_INTERVAL_DAY             = 4;
        public const uint XONLINE_COMP_INTERVAL_WEEK            = 5;
        public const uint XONLINE_COMP_INTERVAL_DAYOFYEAR       = 6;
        public const uint XONLINE_COMP_INTERVAL_MONTH           = 7;
        public const uint XONLINE_COMP_INTERVAL_QUARTER         = 8;
        public const uint XONLINE_COMP_INTERVAL_YEAR            = 9;
        public const uint XONLINE_COMP_INTERVAL_MAX             = 10;

        
        //
        // Day Mask Constants 
        //
        public const uint XONLINE_COMP_DAY_MASK_ALL             = 0x007F;
        public const uint XONLINE_COMP_DAY_MASK_SUNDAY          = 0x0001;
        public const uint XONLINE_COMP_DAY_MASK_MONDAY          = 0x0002;
        public const uint XONLINE_COMP_DAY_MASK_TUESDAY         = 0x0004;
        public const uint XONLINE_COMP_DAY_MASK_WEDNESDAY       = 0x0008;
        public const uint XONLINE_COMP_DAY_MASK_THURSDAY        = 0x0010;
        public const uint XONLINE_COMP_DAY_MASK_FRIDAY          = 0x0020;
        public const uint XONLINE_COMP_DAY_MASK_SATURDAY        = 0x0040;


        //
        // Shared Min/Max Constants 
        //
        public const uint XONLINE_COMP_MAX_FREQUENCY            = 0x100000;
        public const uint XONLINE_COMP_MIN_DURATION_MINS        = 5;
        public const uint XONLINE_COMP_MIN_JOB_DELAY            = 1;
        public const uint XONLINE_COMP_CHECKIN_WIN_SECS         = 5 * 60;
        public const uint XONLINE_COMP_MIN_CLEANUP_DAYS         = 0;
        public const uint XONLINE_COMP_MAX_CLEANUP_DAYS         = 365;
        public const uint XONLINE_COMP_DEFAULT_CLEANUP_DAYS     = 7;        

        // Shared Entrant Status Codes
        public const uint XONLINE_COMP_STATUS_ENTRANT_REGISTERED       = 0;
        public const uint XONLINE_COMP_STATUS_ENTRANT_PLAYING          = 1;
        public const uint XONLINE_COMP_STATUS_ENTRANT_FORFEIT          = 2;
        public const uint XONLINE_COMP_STATUS_ENTRANT_EJECTED          = 3;
        public const uint XONLINE_COMP_STATUS_ENTRANT_PASS             = 4;
        public const uint XONLINE_COMP_STATUS_ENTRANT_FINAL            = 5;
        public const uint XONLINE_COMP_STATUS_ENTRANT_ELIMINATED       = 0xFFFFFFFF;

        // Shared Competition Status Codes
        public const uint XONLINE_COMP_STATUS_PRE_INIT                 = 0;
        public const uint XONLINE_COMP_STATUS_ACTIVE                   = 1;
        public const uint XONLINE_COMP_STATUS_COMPLETE                 = 2;
        public const uint XONLINE_COMP_STATUS_CANCELED                 = 0xFFFFFFFF;

        
        //
        // Elimination Defines
        //
        public const uint XONLINE_COMP_ELIMINATION_MIN_SLOTS                       = 2;
        public const uint XONLINE_COMP_ELIMINATION_MAX_SLOTS                       = 1024;
        public const uint XONLINE_COMP_ELIMINATION_MAX_ROUNDS                      = 10;
        
        // dataset id offsets        
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET         = 1;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET           = 2;

        public const uint XONLINE_COMP_ELIMINATION_EVENT_ID_MASK                   = 0x0000FFFF;
        
        // Elimination Dataset Procs
        public const uint XONLINE_COMP_ELIMINATION_UPDATEID_MIN                    = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_UPDATEID_ROUND                  = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_UPDATEID_STATUS                 = 0x10002;
        public const uint XONLINE_COMP_ELIMINATION_UPDATEID_SLOTTING               = 0x10003;
        public const uint XONLINE_COMP_ELIMINATION_UPDATEID_MAX                    = 0x10003;

        public const uint XONLINE_COMP_ELIMINATION_CUSTOM_ENTRANTS                 = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_CUSTOM_ADVANCE_TIME             = 0x1000A;
        
        public const uint XONLINE_COMP_ELIMINATION_FIND_PROGRESS_INFO              = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_FIND_SLOT_INFO                  = 0x10002;
        public const uint XONLINE_COMP_ELIMINATION_FIND_CHECKIN_INFO               = 0x10003;
        public const uint XONLINE_COMP_ELIMINATION_FIND_LEADERBOARDS               = 0x10004;
        
        
        
        // Entrants Dataset Procs
        
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_REMOVE_MIN             = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_REMOVE_ALL             = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_REMOVE_MAX             = 0x10001;
        
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_MIN             = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_RESULTS         = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_STATUS          = 0x10002;
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_MAX             = 0x10002;

        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_SEARCH_PUID            = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_ENTRANTS_SEARCH_SEEDS           = 0x10002;
        
        // Events Dataset Procs
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_REMOVE_MIN               = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_REMOVE_ALL               = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_REMOVE_MAX               = 0x10001;
        
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_MIN             = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_CHECKIN         = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_RESULT          = 0x10002;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_ENTRANTS        = 0x10003;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_P1              = 0x10004;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_P2              = 0x10005;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_MAX             = 0x10005;

        public const uint XONLINE_COMP_ELIMINATION_EVENTS_FIND_EVENT               = 0x10001;
        
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_SEARCH_ALL               = 0x10001;
        public const uint XONLINE_COMP_ELIMINATION_EVENTS_SEARCH_ROUND             = 0x10002;



        // 
        // MultiLevel-specific defines
        //        

        // Multilevel bracket status Codes
        public const uint XONLINE_COMP_STATUS_BRACKET_PRE_INIT                 = 0;
        public const uint XONLINE_COMP_STATUS_BRACKET_CHECKIN                  = 1;
        public const uint XONLINE_COMP_STATUS_BRACKET_IN_PROGRESS              = 2;
        public const uint XONLINE_COMP_STATUS_BRACKET_COMPLETE                 = 3;
        public const uint XONLINE_COMP_STATUS_BRACKET_FINAL                    = 4;


        
        // columns
        public const uint XONLINE_COMP_ML_MIN_DURATION_MINS        = 10;
        public const uint XONLINE_COMP_ML_MIN_AUTOPROGRESS_MINS    = 5;
        public const uint XONLINE_COMP_ML_MAX_SLOTS                = 65535;
        public const uint XONLINE_COMP_ML_MAX_ROUNDS               = 62;
        
        
        // dataset id offsets        
        public const uint XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET  = 1;
        public const uint XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET  = 2;
        public const uint XONLINE_COMP_ML_LEADERBOARD_DATASET_OFFSET  = 3;
        
        
        // Multilevel dataset procs
        public const uint XONLINE_COMP_ML_FIND_SLOT_DATA           = 0x10001;
        
        public const uint XONLINE_COMP_ML_UPDATE_ROUND            = 0x10002;
        
        public const uint XONLINE_COMP_ML_CUSTOM_ENTRANTS          = 0x10001;
        public const uint XONLINE_COMP_ML_CUSTOM_ADVANCE_TIME      = 0x1000A;
        
        
        // Multilevel entrant procs
        public const uint XONLINE_COMP_ML_ENTRANTS_SEARCH_PUID     = 0x10001;
        public const uint XONLINE_COMP_ML_ENTRANTS_SEARCH_STATUS   = 0x10002;        
        
        public const uint XONLINE_COMP_ML_ENTRANTS_UPDATE_ROUND    = 0x10001;
        public const uint XONLINE_COMP_ML_ENTRANTS_UPDATE_STATUS   = 0x10002;
        
        // Multilevel bracket procs                                
        public const uint XONLINE_COMP_ML_BRACKET_SEARCH_ROUND     = 0x10001;
        
        public const uint XONLINE_COMP_ML_BRACKET_UPDATEID_SLOT_INFO = 0x10001;
        
        // multilevel leaderboard procs
        public const uint XONLINE_COMP_ML_LEADERBOARDS             = 0x10001;  
        
        public const uint XONLINE_COMP_ML_SCORE_ROUND_0_BIT        = 32;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\common\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_compscommon_none_12.4.56.0_none_ac221954887af642
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=compscommon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92.manifest
XP_MANIFEST_PATH=manifests\msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92.cat
XP_CATALOG_PATH=manifests\msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92.cat
XP_PAYLOAD_PATH=msil_compscommon_no-public-key_12.4.56.0_x-ww_1e26ca92
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=compscommon,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\cron\compJobs.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.querylib;
using xonline.server.cron.plugins.cronlib;


namespace xonline.server.comps.cron 
{
    public class QuerySelectJob : ICronJob
    {
        public bool ShareHealthBlock
        {
            get { return true; }
        }

        public void Execute(uint jobId, uint titleId, ref Hashtable args)
        {
            SelectRequest req = new SelectRequest();
            HResult hr;
            
            XRLUtil.VerifyParam(args.Contains("entityId")  && args["entityId"]  is ulong, "Invalid or missing entityId!");
            XRLUtil.VerifyParam(args.Contains("titleId")   && args["titleId"]   is uint,  "Invalid or missing titleId!");
            XRLUtil.VerifyParam(args.Contains("userId")    && args["userId"]    is ulong, "Invalid or missing userId!");
            XRLUtil.VerifyParam(args.Contains("teamId")    && args["teamId"]    is ulong, "Invalid or missing teamId!");
            XRLUtil.VerifyParam(args.Contains("datasetId") && args["datasetId"] is uint,  "Invalid or missing datasetId!");
            XRLUtil.VerifyParam(args.Contains("actionId")  && args["actionId"]  is uint,  "Invalid or missing actionId!");
            
            
            req.titleId   = (uint)args["titleId"];
            req.userId    = (ulong)args["userId"];
            req.teamId    = (ulong)args["teamId"];
            req.datasetId = (uint)args["datasetId"];
            req.entityId  = (ulong)args["entityId"];
            req.actionId  = (uint)args["actionId"];

            req.attribCount = 0;
            req.attribs = null;
            
            try
            {
                MemoryStream stream = new MemoryStream();
                BinaryWriter writer = new BinaryWriter(stream);
                byte[] respData;
                
                req.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
                writer.Flush();
        
                HTTPAuthData authData = new HTTPAuthData(0, 0, 0, (ulong)args["userId"], (uint)args["titleId"], (uint)XOService.Query, 0);
                hr = XRLUtil.PostXrlRequest(XOService.Query, req.GetXRL(), -1, authData.ConstructBase64String(), stream.ToArray(), null, out respData);
            }
            catch(Exception e)
            {
                // make sure we retry these
                throw new CronJobException(false, "Error calling " + req.GetXRL(), e);
            }
                
            if (HResult.Failed(hr))
            {
                throw new CronJobException(false, "Calling " + req.GetXRL() + " returned hr = " + hr);
            }
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\compUtil.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.querylib;

[assembly: XomAreaDefinition(XomAreaName.computil)]
        
namespace xonline.server.comps.query 
{
    public class CompUtil
    {
        public static int ScheduleSelectJob(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, uint execCount, uint timeoutSecs, DateTime nextExec, uint intervalSecs)
        {
            AddJobRequest  addCronJobReq  = new AddJobRequest();
            AddJobResponse addCronJobResp = new AddJobResponse();
            XRLObject2     xrlo           = (XRLObject2)addCronJobResp;
            Hashtable      jobctx         = new Hashtable();
            HResult        hr;
            
            
            jobctx["entityId"]         = entityId;
            jobctx["titleId"]          = titleId;
            jobctx["userId"]           = userId;
            jobctx["teamId"]           = teamId;
            jobctx["datasetId"]        = datasetId;
            jobctx["actionId"]         = actionId;
            
            
            addCronJobReq.name         = "Comp Select callback: compId: 0x" + entityId.ToString("x") + " action: " + actionId;
            addCronJobReq.titleId      = titleId;
            addCronJobReq.assembly     = "compJobs.dll";
            addCronJobReq.className    = "xonline.server.comps.cron.QuerySelectJob";
            addCronJobReq.argsXml      = PluginUtil.HashtableToXml(jobctx);
            addCronJobReq.execCount    = execCount;
            addCronJobReq.timeoutSecs  = timeoutSecs;
            addCronJobReq.nextExec     = nextExec;
            addCronJobReq.intervalSecs = intervalSecs;
            
    
            hr = XRLUtil.PostXrlRequest(XOService.Cron, addCronJobReq.GetXRL(), addCronJobReq, ref xrlo);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, XEvent.Id.MC_XRL_REQUEST_ERROR_1, "Error adding job!   Calling " + addCronJobReq.GetXRL() + " returned hr = " + hr);
            }

            return addCronJobResp.jobId;
        }
        
        public static float TrustFromBlob(byte [] blob)
        {
            MemoryStream stream = new MemoryStream(blob);
            BinaryReader reader = new BinaryReader(stream);

            return reader.ReadSingle();
        }
        
        public static byte[] BlobFromTrust(float trust)
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);

            writer.Write(trust);

            return stream.ToArray();
        }
        
        
        public static uint CreateLeaderboard(uint titleId, uint templateId)
        {
            ReqCompCreateLb lbCreateReq = new ReqCompCreateLb();
            lbCreateReq._uiTitleId = titleId;
            lbCreateReq._uiTemplateId = templateId;
            
            RepCompCreateLb lbCreateResp = new RepCompCreateLb();
            
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            lbCreateReq.WriteTo(writer);
            
            byte[] reqBuf = stream.ToArray();
            byte[] outBuf;
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Stats, "/xstats/xstatscompcreatelb.ashx", reqBuf, out outBuf);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, XEvent.Id.MC_XRL_REQUEST_ERROR_2, 
                    "Error creating leaderboard!   Calling /xstats/xstatscompcreatelb.ashx returned hr = " + hr);
            }
                
            BinaryReader reader = new BinaryReader(new MemoryStream(outBuf));
            lbCreateResp.ReadFrom(reader);
            
            return lbCreateResp._uiLbId;
        }    
        
        public static void DeleteLeaderboard(uint titleId, uint leaderboardId)
        {
            ReqCompDeleteLb lbDeleteReq = new ReqCompDeleteLb();
            lbDeleteReq._uiTitleId = titleId;
            lbDeleteReq._uiLbId = leaderboardId;
            
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            lbDeleteReq.WriteTo(writer);
            
            byte[] reqBuf = stream.ToArray();
            byte[] outBuf;
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Stats, "/xstats/xstatscompdeletelb.ashx", reqBuf, out outBuf);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, XEvent.Id.MC_XRL_REQUEST_ERROR_3, 
                    "Error creating leaderboard!   Calling /xstats/xstatscompdeletelb.ashx returned hr = " + hr);
            }
                
        }    
                                         
        public static void AdjustJobTimes(uint titleId, ulong entityId, uint adjSecs)
        {
            CronJobWire[] jobs;
            HResult hr;
            int jobId;
                
            hr = CronUtil.FindJobs("Comp Select callback: compId: 0x" + entityId.ToString("x") + " %", out jobs);
            if (HResult.Failed(hr))
            {
                throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA, 
                    "AdjustTime action failed searching for jobs!  Competition is now likely in a bad sate..  hr = " + hr);
            }
            
            
            for (int i = 0; i < jobs.Length; i++)
            {
                if (jobs[i].frontDoor != "")
                {
                    Xom.Trace(XomAreaName.computil, LogLevel.L_WARNING, "Job '" + jobs[i].name + "' is already being executed by " + jobs[i].frontDoor + ".  Skipping.");
                    continue;
                }


                Xom.Trace(XomAreaName.computil, LogLevel.L_LOW, "Adjusting job '" + jobs[i].name + "'-- old time: " + jobs[i].nextExec + "  new time: " + jobs[i].nextExec.AddSeconds(-adjSecs));
                
                hr = CronUtil.RemoveJob(jobs[i].jobId, titleId);
                if (HResult.Failed(hr))
                {
                    if (hr == HResult.XONLINE_E_INVALID_REQUEST)
                    {
                        Xom.Trace(XomAreaName.computil, LogLevel.L_WARNING, "Job '" + jobs[i].name + "' already removed! Skipping to the next job..");
                        continue;
                    }
                
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA_1, 
                        "AdjustTime action failed to remove jobid " + jobs[i].jobId + "!  Competition is now likely in a bad sate..  hr = " + hr);
                }
                
                hr = CronUtil.AddJob(jobs[i].name,
                                     jobs[i].titleId,
                                     jobs[i].assembly,
                                     jobs[i].className,
                                     jobs[i].execCount, 
                                     jobs[i].timeoutSecs,
                                     jobs[i].nextExec.AddSeconds(-adjSecs),
                                     jobs[i].intervalSecs,
                                     jobs[i].argsXml,
                                     out jobId);

                Xom.Trace(XomAreaName.computil, LogLevel.L_LOW, "Re-added job as jobId " + jobId);
            }
        
        }

        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\elimination.cs ===
// 
// Elimination.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Single Elimination Tournament Plugin Classes
// Xbox Online Service
// 
// Author: phansen
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.comps.common;
using xonline.server.comps.query;
using xonline.common.mgmt;
using xonline.server.querylib;

[assembly: XomAreaDefinition(XomAreaName.Elimination)]
[assembly: XomAreaDefinition(XomAreaName.ElimEntrants)]
[assembly: XomAreaDefinition(XomAreaName.ElimEvents)]
[assembly: XomAreaDefinition(XomAreaName.selog)]


namespace xonline.server.comps.query 
{
    //
    // Structure Representing the Event data that is validated for consistency during Slotting & Progression
    //  
    public struct EventData
    {
        public uint     Id;         // EventId
        public ulong    entityId;   // EntityId

        public ulong    p1;         // PUID
        public ulong    entityP1;   // entityId
        public ulong    p2;         // PUID
        public ulong    entityP2;   // entityId

        public ulong    pWinner;    // PUID
    }

    
    //
    // Query Service Plugin definition for Single Elimination Competitions
    //  
    public class Competitions : IQueryAdd, IQueryUpdateId, IQueryRemoveId, IQuerySelect, IQueryFindFromIds, IQuerySearch
    {       
        //
        // Utility methods
        //
        private ulong NextEventIdFromEventId(ulong eventId)
        {
            return (((eventId >> 16) + 1) << 16) + (ulong)(((int)eventId & Comp.XONLINE_COMP_ELIMINATION_EVENT_ID_MASK) / 2);
        }
        
        
        //
        // Plugin Select Action Methods
        //
        private HResult UpdateEntrantCount(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, int offsetEntrants, int offsetPrivateEntrants, bool isTeam)
        {            
            HResult        hr = HResult.XONLINE_E_COMP_ERROR;
            int         i;
            
            try
            {
                QueryAttribute[] attribs = new QueryAttribute[4];
                
                for (i = 0; i < attribs.Length; i++)    
                {
                    attribs[i] = new QueryAttribute(); 
                }
                
                // Setup datastructures for callbacks
    
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_PUBLIC_ENTRANTS;
                attribs[0].lValue = offsetEntrants;
                
                attribs[1].Id = Comp.XONLINE_COMP_ATTR_PRIVATE_ENTRANTS;
                attribs[1].lValue = offsetPrivateEntrants;            
    
                attribs[2].Id = Comp.XONLINE_COMP_ATTR_REG_CLOSE;
                attribs[2].lValue = QueryUtil.UtcNow.ToFileTimeUtc();

                attribs[3].Id = Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP;
                attribs[3].lValue = (isTeam ? 1 : 0);

    
                // ExecCustom calls a custom SP that compares whether we can actually add or subtract a user to a competition without 
                //  violating two constraints:
                //  First: any changes to the entrants count must occur between REG_OPEN and REG_CLOSE for the competition. The 
                //   current time is passed in XONLINE_COMP_ATTR_REG_CLOSE, and is used to check against the registration window for the comp. 
                //  Second: Any changes to the entrants must not violate the total number of entrants allowed in the competition. 
                //  Third: If the competition contains private slots, those slots are reserved for private entrants. 
                hr = Dataset.ExecCustom(source, 
                                    titleId, 
                                    userId, 
                                    teamId, 
                                    datasetId, 
                                    Comp.XONLINE_COMP_ELIMINATION_CUSTOM_ENTRANTS, 
                                    entityId, 
                                    attribs);
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Entrants Relative Update method failed for competition " + entityId + ". hr = " + hr);            
                    // No event here. This is a possible race condition failure 
                }
            }
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "UEC",
                              hr.ToString(),
                              titleId.ToString("x8"),
                              userId.ToString("x8"),
                              teamId.ToString("x8"),
                              datasetId.ToString("x"),
                              entityId.ToString("x"),
                              offsetEntrants.ToString("x"),
                              offsetPrivateEntrants.ToString("x")
                      }));      

            }
            
            return hr;
        }

        
        private HResult UpdateEntrantStatus(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, ulong status)
        {
            HResult              hr = HResult.S_OK;
            int               i;
            QueryAttribute[]  attribs;
            
            attribs = new QueryAttribute[2];
            
            try
            {
                for (i = 0; i < attribs.Length; i++)    
                {
                    attribs[i] = new QueryAttribute(); 
                }
                
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                attribs[0].lValue = (long)entityId;
                
                attribs[1].Id = Comp.XONLINE_COMP_ATTR_STATUS;
                attribs[1].lValue = (long)status;
    
                hr = Dataset.Update(source, 
                                titleId, 
                                0, 
                                0, 
                                datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, 
                                Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_STATUS, 
                                attribs);
    
                if (hr == HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "NOTE: Updating entrant status fro user " + userId + " in competition " + entityId + " returned XONLINE_E_QUERY_ENTITY_NOT_FOUND");            
                    hr = HResult.S_OK;
                }

            
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, XEvent.Id.QUERY_PLUGIN_DATA_ERROR, "Entrants Status Update method failed for competition " + entityId + ". hr = " + hr);
                }
                
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "UES",
                              hr.ToString() ,
                              titleId.ToString("x8") ,
                              userId.ToString("x8") ,
                              teamId.ToString("x8") ,
                              datasetId.ToString("x") ,
                              entityId.ToString("x") ,
                              status.ToString("x") 
                      }));          

            }
                      
                      
            return hr;
        }

        
        private HResult UpdateEntrant(Source source, uint titleId, ulong entrantId, uint datasetId, ulong compId, ulong eventId, ulong entityEvent, ulong eventStart, ulong status)
        {
            HResult              hr = HResult.XONLINE_E_COMP_ERROR;
            int               i;
            QueryAttribute[]  attribs;
            
            attribs = new QueryAttribute[6];
            
            try
            {
            
                for (i = 0; i < attribs.Length; i++)    
                {
                    attribs[i] = new QueryAttribute(); 
                }
                
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                attribs[0].lValue = (long)compId;
    
                attribs[1].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_PUID;
                attribs[1].lValue = (long)entrantId;
    
                attribs[2].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_STATUS;
                attribs[2].lValue = (long)status;
    
                attribs[3].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND;
                attribs[3].lValue = (long)(eventId >> 16);
                
                attribs[4].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_CURRENT_EVENT;
                attribs[4].lValue = (long)entityEvent;
                
                attribs[5].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_CURRENT_START;
                attribs[5].lValue = (long)eventStart;
                
                hr = Dataset.Update(source, 
                                titleId, 
                                0, 
                                0, 
                                datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, 
                                Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_RESULTS, 
                                attribs);
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "UpdateEntrant method failed to update Entrant record " + entrantId + " in competition " + compId + ", Event " + eventId + ". hr = " + hr);
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_1, "UpdateEntrant method failed to update Entrant record " + entrantId + " in competition " + compId + ", Event " + eventId + ". hr = " + hr);
                }
                
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "UEN",
                              hr.ToString(),
                              titleId.ToString("x8"),
                              entrantId.ToString("x8"),
                              datasetId.ToString("x"),
                              compId.ToString("x"),
                              eventId.ToString("x"),
                              entityEvent.ToString("x"),
                              eventStart.ToString("x"),
                              status.ToString("x")
                      }));          

            }
                      
            return hr;            
        }

        
        private HResult ActionJoin(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, QueryAttribute[] attribs, bool fPrivateSlot)
        {
            JoinCounters counters = new JoinCounters(titleId);

            HResult            hr = HResult.XONLINE_E_COMP_ERROR;
            int             i;
            ulong           entityEntrant = 0;
            
            long               sort = 0;                
            long               seed = 0;   

            uint            attribCount = 0;
            QueryAttribute[] joinAttribs;

            uint totalResults;
            QueryAttribute[,] results;
            QueryAttribute[] searchAttribs;
            QueryAttributeSpec[] searchSpecs;
            bool isTeam;
            
            try
            {
                
                searchAttribs = new QueryAttribute[2];
                searchAttribs[0] = new QueryAttribute();
                searchAttribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                searchAttribs[0].lValue = (long)entityId;
                searchAttribs[1] = new QueryAttribute();
                searchAttribs[1].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_PUID;
                searchAttribs[1].lValue = (long)(teamId == 0 ? userId : teamId);
                
                searchSpecs = new QueryAttributeSpec[2];
                searchSpecs[0] = new QueryAttributeSpec();
                searchSpecs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;
                searchSpecs[1] = new QueryAttributeSpec();
                searchSpecs[1].type = Comp.XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT;
                
                
                hr = Dataset.Search(source, titleId, datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, 
                            Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_SEARCH_PUID,
                            0,
                            1,
                            searchAttribs,
                            searchSpecs,
                            out totalResults,
                            out results);
                            
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failure searching for existing entry in comp " + entityId.ToString("x") + "!");            
                    goto end;
                }
                
                if (totalResults > 0)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "User/team " + (teamId == 0 ? userId : teamId) + " already exists in competition " + entityId.ToString("x"));            
                    hr = HResult.XONLINE_E_COMP_ALREADY_REGISTERED;
                    goto end;
                }    
                    
                isTeam = (teamId != 0);
                
                // Increment slots used in the competition
                hr = UpdateEntrantCount(source, titleId, userId, teamId, datasetId, entityId, fPrivateSlot ? 0: 1, fPrivateSlot ? 1: 0, isTeam);
    
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                if (null != attribs)
                {
                    attribCount = (uint)attribs.Length;
                    
                    foreach (QueryAttribute attrib in attribs)
                    {
                        switch (attrib.Id)
                        {
                        case Comp.XONLINE_COMP_ATTR_ENTRANT_COMP_SORT:
                            sort = attrib.lValue;
                            break;

                        case Comp.XONLINE_COMP_ATTR_ENTRANT_SEED:
                            seed = attrib.lValue;
                            break;

                        case Comp.XONLINE_COMP_ATTR_ID:
                        case Comp. XONLINE_COMP_ATTR_STATUS:                        
                        case Comp.XONLINE_COMP_ATTR_ENTRANT_PUID:
                        case Comp. XONLINE_COMP_ATTR_ENTRANT_STATUS:
                        case Comp. XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND:
                        case Comp. XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT:
                        case Comp. XONLINE_COMP_ATTR_ENTRANT_CURRENT_EVENT:
                            hr = HResult.XONLINE_E_COMP_UNEXPECTED;
                            Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Title attemped to set a reserved attribute in the Entrant table on Join!");
                            throw new XRLException(hr, XEvent.Id.COMPS_CODE_48, "Title attemped to set a reserved attribute in the Entrant table on Join!");
                            
                        }
                    }
                }


                // 
                // Rebuild attribs and Add the user/team to the competition
                // 
                joinAttribs = new QueryAttribute[attribCount + 3];
                
                for (i = 0; i < 3; i++)    
                {
                    joinAttribs[i] = new QueryAttribute(); 
                }
                
                // Setup datastructures for callbacks
                joinAttribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                joinAttribs[0].lValue = (long)entityId;

                joinAttribs[1].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_PUID;

                if (0 == teamId)
                {
                    joinAttribs[1].lValue = (long)userId;
                }
                else
                {
                    joinAttribs[1].lValue = (long)teamId;
                }

                joinAttribs[2].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT;
                joinAttribs[2].lValue = fPrivateSlot ? 1 : 0;

                if (attribCount > 0)
                {
                    Array.Copy(attribs, 0, joinAttribs, 3, attribCount);                    
                }

                try 
                {
                    // Add the user to the Entrants table
                    hr = Dataset.Add(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, joinAttribs, out entityEntrant);
                }
                catch (Exception e)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Entrants Add method threw for competition " + entityId + " adding user " +  userId);            
                    
                    if (e is XRLException)
                    {
                        hr = ((XRLException)e).HResult;
                    }    

                    // Re-increment the Entrants counter in the competiton dataset                    
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Attemping rollback of entrant count..");                    
                    UpdateEntrantCount(source, titleId, userId, teamId, datasetId, entityId, fPrivateSlot ? 0: -1, fPrivateSlot ? -1: 0, isTeam);         
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Rollback completed.");                    
                    
                    throw new XRLException(hr, XEvent.Id.COMPS_CODE_49, "Successfully rolled back entrant count.", e);
                }
                
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Entrants Add method failed for competition " + entityId + " adding user " +  userId + ". hr = " + hr);

                    // Re-increment the Entrants counter in the competiton dataset
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Attemping rollback of entrant count..");                    
                    UpdateEntrantCount(source, titleId, userId, teamId, datasetId, entityId, fPrivateSlot ? 0: -1, fPrivateSlot ? -1: 0, isTeam);                    
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Rollback completed.");                    
                }
                else
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Single Elimination Competition " + entityId + " Joined by " + userId);            
                }
                
                
end:            
                ;    
                
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "JIN",
                              hr.ToString(),
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"),
                              entityId.ToString("x16"),
                              fPrivateSlot.ToString(),
                              sort.ToString("x"),
                              seed.ToString("x"),
                              entityEntrant.ToString("x16") 
                      }));          

                counters.EndRequest(HResult.Failed(hr));
            }
                      
                
                
            return hr;
        }

        
        private HResult ActionWithdraw(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            WithdrawCounters counters = new WithdrawCounters(titleId);

            HResult                     hr = HResult.XONLINE_E_COMP_ERROR;
            int                      i;
            bool                     fPrivateSlot = false;
            uint                     totalResults;
            

            QueryAttributeSpec[]     specs;
            QueryAttribute[,]        attribsResults;
            QueryAttribute[]         attribs;
            ulong                    entrantId;
            

            try
            {
                //
                // Find the Entrant in the Entrants table. We need to do this to find out if they are occupying a 
                //  private or public slot in the competition. 
                //
                attribs = new QueryAttribute[2];
                
                for (i = 0; i < attribs.Length; i++)    
                {
                    attribs[i] = new QueryAttribute(); 
                }
                
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                attribs[0].lValue = (long)entityId;
                
                attribs[1].Id = Comp.XONLINE_COMP_ATTR_ENTRANT_PUID;
                attribs[1].lValue = (long)(teamId == 0 ? userId : teamId);
    
                
                specs = new QueryAttributeSpec[2];
    
                for (i = 0; i < specs.Length; i++)    
                {
                    specs[i] = new QueryAttributeSpec(); 
                }
                
                specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;             
                specs[1].type = Comp.XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT; 
                
                hr = Dataset.Search(source, titleId, datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, 
                    Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_SEARCH_PUID, 
                    0, 
                    1, 
                    attribs, specs, 
                    out totalResults, 
                    out attribsResults);
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "Error attempting to find user/team " + attribs[1].lValue + " attempting Withdraw from competition " + entityId + " hr = " + hr);                
                    
                    goto lbError;
                }
    
                if (totalResults == 0) 
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "Failed to find user/team " + attribs[1].lValue + " attempting Withdraw from competition " + entityId);            
    
                    hr = HResult.XONLINE_E_COMP_NOT_REGISTERED;
                    goto lbError;
                }    
                    
                entrantId = (ulong)attribsResults[0,0].lValue;
                fPrivateSlot = attribsResults[0,1].lValue != 0;
    
    
                //
                // Test to see if we can legally withdraw from the competition still
                //
                hr = UpdateEntrantCount(source, titleId, userId, teamId, datasetId, entityId, 0, 0, (teamId != 0));            
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Entrants Withdraw method failed for competition " + entityId + " withdrawing user/team " +  attribs[1].lValue + "Registration period is closed. hr = " + hr);
                    goto lbError;
                }
    
    
                //
                // Remove the user from the Entrants table
                //
                
                hr = Dataset.RemoveId(source & Source.Plugin, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, entrantId);
                
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Entrants Withdraw method failed for competition " + entityId + " withdrawing user/team " +  attribs[1].lValue + ". hr = " + hr);
                    goto lbError;
                }
                
                // Decrement current slots in the competition
                hr = UpdateEntrantCount(source, titleId, userId, teamId, datasetId, entityId, fPrivateSlot ? 0 : -1, fPrivateSlot ? -1 : 0, (teamId != 0));
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "UpdateEntrantCount method failed for competition " + entityId + " withdrawing user/team " +  attribs[1].lValue + ". hr = " + hr);            
                    goto lbError;
                }
                

                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Single Elimination Competition " + entityId + " Withdrawn by " + attribs[1].lValue);            
                
                
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "WDR",
                              hr.ToString(),
                              titleId.ToString("x8"),
                              userId.ToString("x8"),
                              teamId.ToString("x8"),
                              datasetId.ToString("x"),
                              entityId.ToString("x"),
                              fPrivateSlot.ToString() 
                      }));          

                counters.EndRequest(HResult.Failed(hr));
            }
                      
                
            
lbError:
            return hr;
        }

        
        private HResult ActionCheckin(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, QueryAttribute[] attribs)
        {
            CheckinCounters counters = new CheckinCounters(titleId);

            int             i;
            HResult            hr = HResult.XONLINE_E_COMP_ERROR;
            ulong           entityEvent = UInt64.MaxValue;
            float           userTrust;
            DateTime roundStart = DateTime.MinValue;
            DateTime roundEnd = DateTime.MinValue;
            DateTime compStart = DateTime.MinValue;
            uint round = 0;
            bool isTeam = false;
            uint status = 0;
        
            ulong roundEvent = 0;
            ulong p1 = 0;
            ulong p1Checkin = 0;
            byte [] p1Trust = new byte[] { 0 };   
            ulong p2 = 0;
            ulong p2Checkin = 0;
            byte [] p2Trust = new byte[] { 0 };   
            ulong pWinner = 0;
            ulong pLoser = 0;
        
                                              
            try
            {
                // Checkins not allowed from the web
                if (((uint)source & ((uint)Source.Web)) != 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }

                
                // Validate Attbribute Params
                foreach (QueryAttribute attrib in attribs)
                {
                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_EVENT_ENTITY_ID:
                        entityEvent = (ulong)attrib.lValue;
                        break;
                    }
                }
    
                XRLUtil.VerifyParam(entityEvent != UInt64.MaxValue, "Checkin must specify XONLINE_COMP_ATTR_EVENT_ENTITY_ID!\r\n" + QueryUtil.DumpAttribs(attribs));
    
                     
                // make sure the service is good..
                if (QueryHealth.ServiceDown)
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_SERVICE_OUTAGE, XEvent.Id.QUERY_SERVER_HEALTH_WARNING,
                            "Service is currently DOWN according to NPDB.   Failing Checkin for comp " + entityId.ToString("X"));
                }
                     
    
                //
                // Select the Competition configuration data for Checkin, Forfeit, Ejection, and Reminders
                //
                FindCheckinDataResults[] checkinData;
                hr = FindCheckinData.Execute(source, titleId, datasetId, new ulong[] { entityId }, out checkinData);                
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failed to find competition " + entityId + " for checkin. hr = " + hr);
                    goto lbError;
                }
                
                round = (uint)checkinData[0].CurrentRound;
                isTeam = 0 != checkinData[0].IsTeamComp;
                status = (uint)checkinData[0].Status;
                
                roundStart = DateTime.FromFileTimeUtc(checkinData[0].CurrentRoundStart);
                roundEnd = DateTime.FromFileTimeUtc(checkinData[0].CurrentRoundEnd);            
                compStart = DateTime.FromFileTimeUtc(checkinData[0].CompStart);
    
                if (status == Comp.XONLINE_COMP_STATUS_PRE_INIT)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "User " + userId + " attempted to check into competition " + entityId + " prior to competition start.");            
                    
                    // User is attempting to checkin before the competition starts...
                    hr = HResult.XONLINE_E_COMP_CHECKIN_TOO_EARLY;
                    goto lbError;
                }
    
                // Don't allow checkins to competitions that have been cancelled or completed
                if (Comp.XONLINE_COMP_STATUS_ACTIVE != status)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "User " + userId + " attempted to check into competition " + entityId + " after the competition completed.");            
    
                    hr = HResult.XONLINE_E_COMP_CANCELLED;                
                    goto lbError;                
                }            
    
    
                //
                // Verify that the user is checking in to the correct Event. 
                //
                ulong[] entityIds = new ulong[1];
                QueryAttribute[,] attribsResults;
                QueryAttributeSpec[] specs = new QueryAttributeSpec[13];

                entityIds[0] = entityEvent;
                    
                for(i=0; i<specs.Length; i++)          
                {                
                    specs[i] = new QueryAttributeSpec();
                }
                
                specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;
                specs[1].type = Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID;
                specs[2].type = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
                specs[3].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY;
                specs[4].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_START;
                specs[5].type = Comp.XONLINE_COMP_ATTR_EVENT_P1;
                specs[6].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_CHECKIN;
                specs[7].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_TRUST;
                specs[7].len = 4;
                specs[8].type = Comp.XONLINE_COMP_ATTR_EVENT_P2;
                specs[9].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_CHECKIN;
                specs[10].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_TRUST;
                specs[10].len = 4;
                specs[11].type = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
                specs[12].type =Comp.XONLINE_COMP_ATTR_EVENT_LOSER;
    
                hr = Dataset.FindFromIds(source, titleId, 
                    datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                    Comp.XONLINE_COMP_ELIMINATION_EVENTS_FIND_EVENT, 
                    entityIds, 
                    specs,
                    out attribsResults);
                    
                if (HResult.Failed(hr))
                {
                    if (hr == HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                    {
                        hr = HResult.XONLINE_E_COMP_CHECKIN_BAD_EVENT;
                    }
                        
                    // a less-expected error..
                    throw new PluginException(hr, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_2, "Failed to find event " + entityEvent + " for competition " + entityId + ". hr = " + hr);
                }
    
                // Entity found better match the entity we selected!
                if (entityEvent != (ulong)attribsResults[0,0].lValue)
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_3, 
                        "FindFromIds for Event " + entityEvent + " returned unexpected entityId "+(ulong)attribsResults[0,0].lValue );
                }
    
                roundEvent  = (ulong)attribsResults[0,1].lValue;
                p1          = (ulong)attribsResults[0,5].lValue;
                p1Checkin   = (ulong)attribsResults[0,6].lValue;
                p1Trust     =       attribsResults[0,7].binValue;   
                p2          = (ulong)attribsResults[0,8].lValue;
                p2Checkin   = (ulong)attribsResults[0,9].lValue;
                p2Trust     =       attribsResults[0,10].binValue;   
                pWinner     = (ulong)attribsResults[0,11].lValue;
                pLoser      = (ulong)attribsResults[0,12].lValue;
                
    
                if (roundEvent < round)
                {
                    hr = HResult.XONLINE_E_COMP_CHECKIN_BAD_EVENT;
                    goto lbError;
                }
    
    
                if ((roundEvent == round) && (roundEnd < QueryUtil.UtcNow))
                {
                    // User is attempting to checkin for a previous round, or after the current round ended (while auto-progression is running)
                    hr = HResult.XONLINE_E_COMP_CHECKIN_TIME_INVALID;
                    goto lbError;
                }
    
    
                //
                // Pull trust value for current user
                //
                userTrust = 0.0F;
    
                if (AuthToggle.On)
                {
                    userTrust = SGInfo.Current.GetUserTrust(userId);                
                }
    
                
                if (false == isTeam)
                {
                    if ((p1 != userId) && (p2 != userId))
                    {
                        hr = HResult.XONLINE_E_COMP_CHECKIN_BAD_EVENT;
                        goto lbError;                    
                    }
    
                    if (p1 == userId)
                    {
                        p1Checkin = (ulong)QueryUtil.UtcNow.ToFileTimeUtc();
                        p1Trust = CompUtil.BlobFromTrust(userTrust);
                    }
                    else if (p2 == userId)
                    {
                        p2Checkin = (ulong)QueryUtil.UtcNow.ToFileTimeUtc();
                        p2Trust = CompUtil.BlobFromTrust(userTrust);
                    }                
                }
                else
                {
                    if ((p1 != teamId) && (p2 != teamId))
                    {
                        hr = HResult.XONLINE_E_COMP_CHECKIN_BAD_EVENT;
                        goto lbError;                    
                    }

                    if (p1 == teamId)
                    {
                        p1Checkin = (ulong)QueryUtil.UtcNow.ToFileTimeUtc();
                    }
                    else if (p2 == teamId)
                    {
                        p2Checkin = (ulong)QueryUtil.UtcNow.ToFileTimeUtc();
                    }   
                }
    
                
                if (pWinner != 0)
                {
                    // User has previously either forfeited or been ejected. They cannot checkin
                    hr = HResult.XONLINE_E_COMP_CHECKIN_EVENT_SCORED; 
                }
                else if (pLoser != 0)
                {
                    // Opponent either forfeited or was ejected. The user wins by checking in!
                    hr = UpdateEvent(source, 
                                titleId, 
                                datasetId, 
                                entityId, 
                                0,          // p1
                                0,          // p2
                                isTeam ? teamId : userId,     // winner
                                0,          // loser
                                entityEvent, 
                                Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING, 
                                null);

                    if (HResult.Succeeded(hr))
                    {
                        hr = HResult.XONLINE_S_COMP_CHECKIN_EVENT_SCORED;
                    }
                }
                else
                {                               
                    //
                    // Update event with checkin time
                    //
                    attribs = new QueryAttribute[4];
                    
                    for (i = 0; i < attribs.Length; i++)    
                    {
                        attribs[i] = new QueryAttribute(); 
                    }
                    
                    attribs[0].Id = Comp.XONLINE_COMP_ATTR_EVENT_P1_CHECKIN;
                    attribs[0].lValue = (long)p1Checkin;
        
                    attribs[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_P1_TRUST;
                    attribs[1].binValue = p1Trust;
        
                    attribs[2].Id = Comp.XONLINE_COMP_ATTR_EVENT_P2_CHECKIN;
                    attribs[2].lValue = (long)p2Checkin;
        
                    attribs[3].Id = Comp.XONLINE_COMP_ATTR_EVENT_P2_TRUST;
                    attribs[3].binValue = p2Trust;
                    
                    hr = Dataset.UpdateId(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_CHECKIN, entityEvent, attribs);
        
                    if (HResult.Failed(hr))
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Checkin update method failed for Event " + entityEvent + " in competition " + entityId + " hr = " + hr);
                        goto lbError;
                    }
                }
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "User " + userId + " checked in for Event " + entityEvent + " in Single Elimination Competition " + entityId);           
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "CKN", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              userId.ToString("x16"), 
                              teamId.ToString("x16"), 
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"), 
                              entityEvent.ToString("x16"),
                              isTeam.ToString(),
                              round.ToString("x"), 
                              status.ToString("x"),
                              compStart.ToString(),
                              roundStart.ToString(), 
                              roundEnd.ToString(),
                              roundEvent.ToString("x16"),
                              p1.ToString("x16"),
                              p1Checkin.ToString("x16"),
                              ByteConvert.ToString(p1Trust),
                              p2.ToString("x16"),
                              p2Checkin.ToString("x16"),
                              ByteConvert.ToString(p2Trust)
                      }));          

                counters.EndRequest(HResult.Failed(hr));
            }
                      
                
lbError:
            return hr;
        }


        HResult UpdateEvent(Source source, uint titleId, uint datasetId, ulong compId, ulong p1Update, ulong p2Update, ulong pWinnerUpdate, ulong pLoserUpdate, ulong entityEvent, uint loserStatus, QueryAttribute[] updateAttribs)
        {
            //
            // Verify that the users reported in the results are for the correct Event. 
            //
            int                     i;
            HResult                    hr = HResult.S_OK; 
            QueryAttributeSpec []   specs;
            QueryAttribute[]        attribs;
            QueryAttribute[,]       attribsResults;
            ulong []                entityIds = new ulong[1];
            
            ulong eventId = 0;
            ulong round = 0;
            ulong entityNextEvent = 0;
            ulong startNextEvent = 0;
            ulong p1 = 0;
            ulong p1Checkin = 0;
            ulong p2 = 0;
            ulong p2Checkin = 0;
            ulong pWinner = 0;
            ulong pLoser = 0;
            

            try
            {
                // Can't call this on entityEvent 0. That's a nono. 
                if (entityEvent == 0)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "UpdateEvent called on Event 0! ");            
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_4, "UpdateEvent called on Event 0! ");
                    
                    hr = HResult.XONLINE_E_COMP_UNEXPECTED;
                    goto lbError;
                }
                
                
                entityIds[0] = entityEvent;
                
                specs = new QueryAttributeSpec[13];
    
                for(i=0; i<specs.Length; i++)          
                {                
                    specs[i] = new QueryAttributeSpec();
                }
                
                specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;
                specs[1].type = Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID;
                specs[2].type = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
                specs[3].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY;
                specs[4].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_START;
                specs[5].type = Comp.XONLINE_COMP_ATTR_EVENT_P1;
                specs[6].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_CHECKIN;
                specs[7].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_TRUST;
                specs[7].len = 4;
                specs[8].type = Comp.XONLINE_COMP_ATTR_EVENT_P2;
                specs[9].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_CHECKIN;
                specs[10].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_TRUST;
                specs[10].len = 4;
                specs[11].type = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
                specs[12].type =Comp.XONLINE_COMP_ATTR_EVENT_LOSER;
    
                hr = Dataset.FindFromIds(source, titleId, 
                    datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                    Comp.XONLINE_COMP_ELIMINATION_EVENTS_FIND_EVENT, 
                    entityIds, 
                    specs,
                    out attribsResults);
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failed to find event " + entityEvent + " for competition " + compId + ". hr = " + hr);
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_5, "Failed to find event " + entityEvent + " for competition " + compId + ". hr = " + hr);
                    goto lbError;
                }
    
                // Entity found better match the entity we selected!
                if (entityEvent != (ulong)attribsResults[0,0].lValue)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "FindFromIds for Event " + entityEvent + " returned unexpected data. ");            
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_6, "FindFromIds for Event " + entityEvent + " returned unexpected data. ");
                    
                    hr = HResult.XONLINE_E_COMP_UNEXPECTED;
                    goto lbError;
                }
    
                eventId         = (ulong)attribsResults[0,1].lValue;
                round           = (ulong)attribsResults[0,2].lValue;
                entityNextEvent = (ulong)attribsResults[0,3].lValue;
                startNextEvent  = (ulong)attribsResults[0,4].lValue;
                p1              = (ulong)attribsResults[0,5].lValue;
                p1Checkin       = (ulong)attribsResults[0,6].lValue;
                p2              = (ulong)attribsResults[0,8].lValue;
                p2Checkin       = (ulong)attribsResults[0,9].lValue;
                pWinner         = (ulong)attribsResults[0,11].lValue;
                pLoser          = (ulong)attribsResults[0,12].lValue;
    
    
                //
                // See if P1 or P2 are being updated
                //
                if ((p1Update != 0) || (p2Update != 0))
                {
                    if (p1 == 0) p1 = p1Update;
                    if (p2 == 0) p2 = p2Update;

                    if (p2Update == 0)  // Only update p1
                    {
                        attribs = new QueryAttribute[1];
                                    
                        attribs[0] = new QueryAttribute();
                        attribs[0].Id = Comp.XONLINE_COMP_ATTR_EVENT_P1;
                        attribs[0].lValue = (long)p1;
                        
                        hr = Dataset.UpdateId(source, 
                                titleId, 
                                0, 
                                0, 
                                datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                                Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_P1, 
                                entityEvent, 
                                attribs);
                    
                    }
                    else if (p1Update == 0) // Only update p2
                    {
                        attribs = new QueryAttribute[1];
                                    
                        attribs[0] = new QueryAttribute();
                        attribs[0].Id = Comp.XONLINE_COMP_ATTR_EVENT_P2;
                        attribs[0].lValue = (long)p2;
                        
                        hr = Dataset.UpdateId(source, 
                                titleId, 
                                0, 
                                0, 
                                datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                                Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_P2, 
                                entityEvent, 
                                attribs);
                    }
                    else    // update both
                    {                    
                        attribs = new QueryAttribute[2];
                                    
                        attribs[0] = new QueryAttribute();
                        attribs[0].Id = Comp.XONLINE_COMP_ATTR_EVENT_P1;
                        attribs[0].lValue = (long)p1;
                        
                        attribs[1] = new QueryAttribute();
                        attribs[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_P2;
                        attribs[1].lValue = (long)p2;
                        
                        hr = Dataset.UpdateId(source, 
                                titleId, 
                                0, 
                                0, 
                                datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                                Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_ENTRANTS, 
                                entityEvent, 
                                attribs);
                    }
                   
                    if (HResult.Failed(hr))
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "UpdateEvent method failed for competition " + compId + ". Could not update players for event " + entityEvent + " hr = " + hr);
                        Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_7, "UpdateEvent method failed for competition " + compId + ". Could not update players for event " + entityEvent + " hr = " + hr);                    
                        
                        goto lbError;
                    }
                }
                
    
                if ((pWinner != 0) && (pWinner != pWinnerUpdate))
                {
                    // We already scored this event. We can't score it again!
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Results submitted for event " + entityEvent + " in competition " + compId + " but Event was already scored. Aborting.");            

                    // No event here, since this can happen legitimately where a user is ejected while they are playing a game
                    hr = HResult.XONLINE_E_COMP_CHECKIN_EVENT_SCORED;
                    goto lbError;
                }
    
                if ((pLoser != 0) && (pLoser != pLoserUpdate))
                {
                    // We already scored this event. We can't score it again!
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Results submitted for event " + entityEvent + " in competition " + compId + " but Event was already scored. Aborting.");            
                    
                    // No event here, since this can happen legitimately where a user is ejected while they are playing a game
                    hr = HResult.XONLINE_E_COMP_CHECKIN_EVENT_SCORED;
                    goto lbError;
                }
    
    
                //
                // Setup attribs for event result update call. If update attribs are specified, they are assumed to contain both winner/loser attributes
                //
                if (null == updateAttribs)
                {
                    updateAttribs = new QueryAttribute[2];
    
                    updateAttribs[0] = new QueryAttribute();
                    updateAttribs[0].Id = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
                    updateAttribs[0].lValue = (long)pWinnerUpdate;
    
                    updateAttribs[1] = new QueryAttribute();
                    updateAttribs[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_LOSER;
                    updateAttribs[1].lValue = (long)pLoserUpdate;
                }
                
    
                if ((pWinnerUpdate == 0) && (pLoserUpdate != 0))
                {
                    // Caller specified loser but not winner.. Fill in the blank
                    pWinnerUpdate = (pLoserUpdate == p1) ? p2 : p1;
    
                    foreach (QueryAttribute qa in updateAttribs)
                    {
                        if (qa.Id == Comp.XONLINE_COMP_ATTR_EVENT_WINNER)
                        {
                            qa.lValue = (long)pWinnerUpdate;
                        }
                    }
                }
                
                if ((pLoserUpdate == 0) && (pWinnerUpdate != 0))
                {
                    // Caller specified winner but not loser.. Fill in the blank
                    pLoserUpdate = (pWinnerUpdate == p2) ? p1 : p2;
    
                    foreach (QueryAttribute qa in updateAttribs)
                    {
                        if (qa.Id == Comp.XONLINE_COMP_ATTR_EVENT_LOSER)
                        {
                            qa.lValue = (long)pLoserUpdate;
                        }
                    }
                }
                
                
                if (((pWinnerUpdate != 0) && (pWinnerUpdate != p1) && (pWinnerUpdate != p2)) || ((pLoserUpdate != 0) && (pLoserUpdate != p1) && (pLoserUpdate != p2)))
                {
                    // Results submitted for users/teams who are not part of the event!
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Results submitted for event " + entityEvent + " in competition " + compId + " for incorrect PUIDs. Aborting. puidWinner = " + pWinnerUpdate + " puidLoser = " + pLoserUpdate + " puid1 = " + p1 + " puid2 = " + p2);
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_8, "Results submitted for event " + entityEvent + " in competition " + compId + " for incorrect PUIDs. Aborting. puidWinner = " + pWinnerUpdate + " puidLoser = " + pLoserUpdate + " puid1 = " + p1 + " puid2 = " + p2);            
                    
                    hr = HResult.XONLINE_E_COMP_UNEXPECTED;
                    goto lbError;                
                }
    
                
                //
                // Execute Event update. This proc takes the same attributes passed to the Select, which may include title specific attributes. Don't mess with them
                //
                hr = Dataset.UpdateId(source, 
                        titleId, 
                        0, 
                        0, 
                        datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                        Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_RESULT, 
                        entityEvent, 
                        updateAttribs);
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "UpdateEvent method failed for competition " + compId + ". Could not update winner/loser for event " + entityEvent + " hr = " + hr);
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_9, "UpdateEvent method failed for competition " + compId + ". Could not update winner/loser for event " + entityEvent + " hr = " + hr);
                        
                    goto lbError;
                }
    
    
                //
                // Update Winner Entrant record
                //
                if ((0 != pWinnerUpdate) && HResult.Succeeded(hr))
                {
                    hr = UpdateEntrant(source, titleId, pWinnerUpdate, datasetId, compId, NextEventIdFromEventId(eventId), entityNextEvent, startNextEvent, Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING);
    
                    ulong p1Next = (eventId % 2 == 0) ? pWinnerUpdate : 0;
                    ulong p2Next = (eventId % 2 == 0) ? 0: pWinnerUpdate;
    
                    if (entityNextEvent != 0)
                    {
                        hr = UpdateEvent(source, 
                                    titleId, 
                                    datasetId, 
                                    compId, 
                                    p1Next,         // p1
                                    p2Next,         // p2
                                    0,              // winner
                                    0,              // loser
                                    entityNextEvent, 
                                    Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED, 
                                    null);
                    }
                }
    
                
                //
                // Update Loser Entrant record
                //
                if ((0 != pLoserUpdate) && HResult.Succeeded(hr))
                {
                    hr = UpdateEntrant(source, titleId, pLoserUpdate, datasetId, compId, eventId, entityEvent, 0, loserStatus);
                }

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "UEV", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              compId.ToString("x16"), 
                              p1Update.ToString("x16"), 
                              p2Update.ToString("x16"),
                              pWinnerUpdate.ToString("x16"),
                              pLoserUpdate.ToString("x16"),
                              entityEvent.ToString("x16"),
                              loserStatus.ToString("x"),
                              eventId.ToString("x16"),
                              round.ToString("x"),
                              entityNextEvent.ToString("x16"),
                              startNextEvent.ToString("x16")
                        }));       

            }
                      


lbError:
            return hr;
        }
        
        private HResult ActionSubmitResults(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, QueryAttribute[] attribs, Hashtable ctx)
        {
            SubmitResultsCounters counters = new SubmitResultsCounters(titleId);

            HResult            hr = HResult.XONLINE_E_COMP_ERROR;
            ulong           entityEvent = 0;
            ulong           puidWinnerResult = 0;
            ulong           puidLoserResult = 0;
            QueryAttribute[] updateAttribs;
            bool            isFromServer = true;
            

            try
            {
    
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    isFromServer = false;
                }
                
                if (Config.GetBoolSetting(Setting.compPlugins_allowClientResultsSubmissions) == false && isFromServer == false)
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ACCESS_DENIED, XEvent.Id.COMPS_TITLEBUG_0, 
                        "Calling submit results directly from the client, when it should be going through arbitration!");
                }
                    
                
                // Validate Attbribute Params
                foreach (QueryAttribute attrib in attribs)
                {
                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_EVENT_ENTITY_ID:
                        entityEvent = (ulong)attrib.lValue;
                        break;
    
                    case Comp.XONLINE_COMP_ATTR_EVENT_WINNER:
                        puidWinnerResult = (ulong)attrib.lValue;
                        break;
                        
                    case Comp.XONLINE_COMP_ATTR_EVENT_LOSER:
                        puidLoserResult = (ulong)attrib.lValue;
                        break;                    
                    }
                }
    
                XRLUtil.VerifyParam(entityEvent != 0, "Submitting Results for Event entityId 0!\r\n" + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(puidWinnerResult != 0, "Submitting Results for Event with Winner PUID = 0!\r\n" + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(puidLoserResult != 0, "Submitting Results for Event with Loser PUID = 0! 0!\r\n" + QueryUtil.DumpAttribs(attribs));
                
    
                //            
                // Verify that the people reported in the submission for the event are in the arbitration BundledAuthData header
                //
                if (AuthToggle.On)
                {
                    
                    bool             authWinner = false;
                    bool             authLoser = false;
                    BundledAuthData  bundledAuth = (BundledAuthData)ctx["bundledAuth"];
                    TeamTickets      bundledTeams= (TeamTickets)ctx["bundledTickets"];

                    if (isFromServer)
                    {
                        if (null == bundledAuth)
                        {
                            // bundledAuth data was not provided. Results are only allowed to arrive from arbitration. Abort
                            throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_10, 
                                "Results submitted for event " + entityEvent + " in competition " + entityId + " with missing bundled authData! Aborting." );                        
                        }
    
                        if (null == bundledTeams)
                        {
                            // p1 and p2 are users
                            
                            foreach(XUIDAndTrust x in bundledAuth.users)
                            {
                                if (x.qwUserID == puidWinnerResult)
                                {
                                    authWinner = true;
                                }
        
                                if (x.qwUserID == puidLoserResult)
                                {
                                    authLoser = true;
                                }
                            }
                        }
                        else
                        {
                            // p1 and p2 are teams. Each ticket (one per user participating) must contain team p1 or team p2
                            foreach(TeamTicket t in bundledTeams.teamTickets)
                            {
                                bool verifiedTicket = false;
                                
                                if (t.VerifyMembership(t.userID, puidWinnerResult))
                                {
                                    authWinner = true;
                                    verifiedTicket = true;
                                }
    
                                if (t.VerifyMembership(t.userID, puidLoserResult))
                                {
                                    authLoser = true;
                                    verifiedTicket = true;
                                }
    
                                if (false == verifiedTicket)
                                {
                                    // a team ticket exists which has no representation in this event. 
                                    throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_11, 
                                        "Results submitted for event " + entityEvent + " in competition " + entityId + " with a team ticket that does not represent one of the players." );                        
                                }
                            }
    
                            // Now, each participating user must have a team ticket
                            foreach(XUIDAndTrust x in bundledAuth.users)
                            {
                                bool verifiedUser = false;
                                
                                foreach(TeamTicket t in bundledTeams.teamTickets)
                                {
                                    if (t.userID == x.qwUserID)
                                    {
                                        verifiedUser = true;
                                        break;
                                    }
                                }
                                
                                if (false == verifiedUser)
                                {
                                    // a user is missing a valid team ticket in the submission
                                    throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_12, 
                                        "Results submitted for event " + entityEvent + " in competition " + entityId + " with authData for a user that was not on the winning or losing team." );                        
                                 }
                            }
                            
                        }
                    }
                    else //!isFromServer
                    {
                        if (teamId == 0 && (userId == puidWinnerResult || userId == puidLoserResult) || 
                            teamId != 0 && (teamId == puidWinnerResult || teamId == puidLoserResult))
                        {
                            // we only have enough data to verify the current user is a winner or loser. 
                            // 
                            authWinner = true;
                            authLoser = true;
                        }
                    }    
                            
                    
    
                    if ((false == authWinner) || (false == authLoser))
                    {
                        // Results submitted for users/teams who are not part of the auth data submitted!
                        throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_13, 
                            "Results submitted for event " + entityEvent + " in competition " + entityId + " for un-verifiable PUIDs. Aborting. puidWinner = " + puidWinnerResult + "; puidLoser = " + puidLoserResult);                        
                     }                    
                }
    
    
                updateAttribs = new QueryAttribute[attribs.Length - 1];
                Array.Copy(attribs, 1, updateAttribs, 0, updateAttribs.Length);
                
                hr = UpdateEvent(source, 
                            titleId, 
                            datasetId, 
                            entityId, 
                            0,                  // p1
                            0,                  // p2
                            puidWinnerResult,   // winner
                            puidLoserResult,    // loser
                            entityEvent, 
                            Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED, 
                            updateAttribs);
                
                if (hr == HResult.XONLINE_E_COMP_CHECKIN_EVENT_SCORED)
                {
                    hr = HResult.XONLINE_S_COMP_CHECKIN_EVENT_SCORED;
                }
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Results submitted for Single Elimination Competition " + entityId + " for Event " + entityEvent);           

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "SBR", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"),
                              entityEvent.ToString("x16"),
                              puidWinnerResult.ToString("x16"),
                              puidLoserResult.ToString("x16"),
                              isFromServer.ToString()
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
                                      
            return hr;
        }

        
        private HResult ActionCancel(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            CancelCounters counters = new CancelCounters(titleId);

            HResult        hr = HResult.S_OK;
            uint        status = 0xbaaaaaad;
            
            QueryAttribute[] attribs = new QueryAttribute[1];
            
            try
            {
            
                //
                // Find the competition
                //
                FindProgressionDataResults[] compData;
                hr = FindProgressionData.Execute(source, titleId, datasetId, new ulong[] { entityId }, out compData);
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failed to find competition " + entityId + " for cancel. hr = " + hr);
                    goto lbError;
                }
                
                status = (uint)compData[0].Status;
                
                // Don't allow multiple cancels
                if (Comp.XONLINE_COMP_STATUS_CANCELED == compData[0].Status)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "User " + userId + " attempted to cancel competition " + entityId + " after the competition was already cancelled.");            
    
                    hr = HResult.XONLINE_E_COMP_CANCELLED;                
                    goto lbError;                
                }  
                
                //
                // Update Competition entry to mark the competition as cancelled
                //
                UpdateCompStatus updateStatus = new UpdateCompStatus();
                updateStatus.Status = Comp.XONLINE_COMP_STATUS_CANCELED;
    
                hr = updateStatus.Execute(source, titleId, userId, teamId, datasetId, entityId);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Cancel Update method failed for competition " + entityId + ". hr = " + hr);
                }
    
    
                hr = UpdateEntrantStatus(source, titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_STATUS_CANCELED);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Progression Update method failed for Competition " + entityId + " with hr = " + hr);
                }
                
                //
                // schedule cleanup
                //
                CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_ACTION_CLEANUP, 1, 5 * 60, CleanupTimeFromCleanupDays((uint)compData[0].CompCleanup), 0);
                            
                

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "CAN", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"),
                              status.ToString("x")
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
    

lbError:             
            return hr;
        }

        
        private HResult ActionForfeit(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, QueryAttribute[] attribs)
        {
            ForfeitCounters counters = new ForfeitCounters(titleId);

            HResult            hr = HResult.XONLINE_E_COMP_ERROR;
            ulong           entityEvent = 0;
            
            uint round = 0;
            bool isTeam = false;
            uint status = 0;
            
            DateTime roundStart = DateTime.MinValue;
            DateTime roundEnd = DateTime.MinValue;
            DateTime compStart = DateTime.MinValue;


            try
            {
                // Validate Attbribute Params
                foreach (QueryAttribute attrib in attribs)
                {
                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_EVENT_ENTITY_ID:
                        entityEvent = (ulong)attrib.lValue;
                        break;
                    }
                }
    
                XRLUtil.VerifyParam(entityEvent != 0, "Forfeiting for Entrant " + userId + " for Event entityId 0!\r\n" + QueryUtil.DumpAttribs(attribs));
    
    
                //
                // Select the Competition configuration data for Checkin, Forfeit, Ejection, and Reminders
                //
                FindCheckinDataResults[] checkinData;
                hr = FindCheckinData.Execute(source, titleId, datasetId, new ulong[] { entityId }, out checkinData);                
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failed to find competition " + entityId + " for forfeit. hr = " + hr);
                    goto lbError;
                }
                
                round = (uint)checkinData[0].CurrentRound;
                isTeam = 0 != checkinData[0].IsTeamComp;
                status = (uint)checkinData[0].Status;
                
                roundStart = DateTime.FromFileTimeUtc(checkinData[0].CurrentRoundStart);
                roundEnd = DateTime.FromFileTimeUtc(checkinData[0].CurrentRoundEnd);            
                compStart = DateTime.FromFileTimeUtc(checkinData[0].CompStart);

    
                if (compStart > QueryUtil.UtcNow)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "User " + userId + " attempted to forfeit for competition " + entityId + " prior to competition start. User should Withdraw instead");            
                    
                    // User is attempting to forfeit before the competition starts...
                    hr = HResult.XONLINE_E_COMP_CHECKIN_TIME_INVALID;
                    goto lbError;
                }
    
                // Don't allow forfeit to competitions that have not started, or are inactive
                if (Comp.XONLINE_COMP_STATUS_ACTIVE != status)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "User " + userId + " attempted to forfeit for competition " + entityId + " after the competition completed.");            
    
                    hr = HResult.XONLINE_E_COMP_CHECKIN_TIME_INVALID;                
                    goto lbError;                
                }            
    
                // Make sure team forfeits include a teamId    
                if ((true == isTeam) && (teamId == 0))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "User " + userId + " attempted to forfeit for team competition " + entityId + " but teamId is 0!");            
    
                    hr = HResult.XONLINE_E_COMP_INVALID_ENTRANT_TYPE;                
                    goto lbError;                                    
                }

                
                hr = UpdateEvent(source, 
                            titleId, 
                            datasetId, 
                            entityId, 
                            0,          // p1
                            0,          // p2
                            0,          // winner
                            isTeam ? teamId : userId,   // loser
                            entityEvent, 
                            Comp.XONLINE_COMP_STATUS_ENTRANT_FORFEIT, 
                            null);
                
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Forfeit method failed for Event " + entityEvent + " in competition " + entityId + ". hr = " + hr);
                }

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "FOR", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              userId.ToString("x16"), 
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"), 
                              round.ToString("x"),
                              status.ToString("x"),
                              compStart.ToString(),
                              roundStart.ToString(),
                              roundEnd.ToString()
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
            
                
            
lbError:             
            return hr;
        }


        private HResult ActionEject(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, QueryAttribute[] attribs)
        {
            EjectCounters counters = new EjectCounters(titleId);

            HResult            hr = HResult.XONLINE_E_COMP_ERROR;
            ulong           entityEvent = 0;
            ulong           owner = 0;
            ulong           ejectee = 0;            
            bool            isTeam = false;
            uint            status = 0;
            
            try
            {
                // Validate Attbribute Params
                foreach (QueryAttribute attrib in attribs)
                {
                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_EVENT_ENTITY_ID:
                        entityEvent = (ulong)attrib.lValue;
                        break;

                    case Comp.XONLINE_COMP_ATTR_ENTRANT_PUID:
                        ejectee = (ulong)attrib.lValue;
                        break;
                    }
                }
    
                XRLUtil.VerifyParam(ejectee != 0, "Eject called by " + userId + " without specifying the entrant to eject!\r\n" + QueryUtil.DumpAttribs(attribs));
    
    
                //
                // Select the Competition configuration data for Checkin, Forfeit, Ejection, and Reminders
                //
                FindCheckinDataResults[] checkinData;
                hr = FindCheckinData.Execute(source, titleId, datasetId, new ulong[] { entityId }, out checkinData);
                
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failed to find competition " + entityId + " for forfeit. hr = " + hr);
                    goto lbError;
                }
                
                
                isTeam = 0 != checkinData[0].IsTeamComp;
                status = (uint)checkinData[0].Status;
                owner = (ulong)checkinData[0].CompOwner;
                
    
                if (((false == isTeam) && (owner != userId)) ||((true == isTeam)  && (owner != teamId)))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Eject called by " + userId + " when competition " + entityId + " is owned by " + owner);            
                    hr = HResult.XONLINE_E_COMP_ACCESS_DENIED;
                    goto lbError;
                }


                // If ejecting someone after the competition has started, the users current event Id must be presented
                if (Comp.XONLINE_COMP_STATUS_ACTIVE == status)
                {
                    XRLUtil.VerifyParam(entityEvent != 0, "Eject called by " + userId + " without specifying the current event of the ejectee!\r\n" + QueryUtil.DumpAttribs(attribs));
        
                    hr = UpdateEvent(source, 
                            titleId, 
                            datasetId, 
                            entityId, 
                            0,          // player 1
                            0,          // player 2
                            0,          // winner
                            ejectee,    // loser
                            entityEvent, 
                            Comp.XONLINE_COMP_STATUS_ENTRANT_EJECTED, 
                            null);
                }            
                else
                {
                    hr = UpdateEntrant(source, titleId, ejectee, datasetId, entityId, 0, 0, 0, Comp.XONLINE_COMP_STATUS_ENTRANT_EJECTED);        

                    // BUGBUG: In this situation the server will not reclaim the slot, and the XQRY server
                    //  will log an event during slotting that the number of entrants doesn't match the expected number of entrants. 
                    //  To fix this, we would decrement the available slots again after the user is ejected. (Good M1 work item)
                }
                
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Eject method failed for Event " + entityEvent + " in competition " + entityId + ". hr = " + hr);
                }

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "EJT", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              userId.ToString("x16"), 
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              owner.ToString("x16"), 
                              entityId.ToString("x16"), 
                              ejectee.ToString("x16"),
                              entityEvent.ToString("x16"),
                              status.ToString("x")
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
            
                
            
lbError:             
            return hr;
        }


        private DateTime CleanupTimeFromCleanupDays(uint days)
        {
            DateTime    dtCleanup = QueryUtil.UtcNow.AddDays(Comp.XONLINE_COMP_DEFAULT_CLEANUP_DAYS);
            
            if (days > 0)
            {
                dtCleanup = QueryUtil.UtcNow.AddDays(days);
            }
            else if (days == 0)
            {
                dtCleanup = QueryUtil.UtcNow.AddMinutes(5);
            }

            return dtCleanup;
        }

        
        private HResult SafeScheduleJob(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, uint execCount, uint timeoutSecs, DateTime nextExec, uint intervalSecs, out int jobId)
        {
            HResult        hr = HResult.S_OK;
            
            jobId = 0;
            
            try
            {
                // Validate nextExec param - we should never be scheduling jobs in the past!
                if (nextExec < QueryUtil.UtcNow.AddDays(-7))
                {
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_14, "SafeScheduleJob is attempting to schedule a job in the past for entity " + entityId + ". nextExec = " + nextExec + ". Resetting job schedule to current datetime. ");

                    nextExec = QueryUtil.UtcNow;
                }
                
                jobId = CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, entityId, actionId, execCount, timeoutSecs, nextExec, intervalSecs);        
            }
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "SSJ", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"), 
                              actionId.ToString(),
                              execCount.ToString(),
                              timeoutSecs.ToString(),
                              nextExec.ToString(),
                              intervalSecs.ToString(),
                              jobId.ToString("x")
                        }));       
                        
            }

            return hr;
        }


        //
        // Add jobs to the Cron service to facilitate the competitions state machine. This method is called from finally blocks and cannot throw!!!       
        //
        private HResult AddRoundJobs(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint reminderMin, DateTime roundStart, DateTime roundEnd)
        {
            HResult            hr = HResult.S_OK;
            int             reminderJob = 0;
            int             progressionJob;
            
            //
            // SafeScheduleJob logs each scheduled job with params
            //
            
            // Reminder Job
            if (reminderMin > 0)
            {
                hr = SafeScheduleJob(titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_ACTION_REMINDERS, 1, 5 * 60, roundStart.AddMinutes(-reminderMin), 0, out reminderJob);
            }

            // Progression Job
            hr = SafeScheduleJob(titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_ACTION_PROGRESSION, 1, 5 * 60, roundEnd.AddMinutes(Comp.XONLINE_COMP_MIN_JOB_DELAY), 0, out progressionJob);

            return hr;
        }
        
        
        private HResult ActionSlotting(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            SlottingCounters counters = new SlottingCounters(titleId);

            int                   i, j;
            HResult                  hr = HResult.XONLINE_E_COMP_ERROR;
            uint                  results = 0;
            uint                  minEntrants = 0;
            uint                  entrants = 0;
            DateTime              dtStart = DateTime.MinValue;
            DateTime              firstRoundStart = DateTime.MinValue;
            DateTime              firstRoundEnd = DateTime.MinValue;
            uint                  frequency = 0;
            uint                  interval = 0;
            uint                  dayMask = 0;
            uint                  reminderMin = 0;
            ulong                 status = 0;
            uint                  byes = 0;
            bool                  cleanup = true;
            bool                  isFromServer = true;

            int        rounds = 0;        // Total number of rounds in the competition
            int        slots = 0;         // Total slots in the competition if rounded to the nearest power of 2
                                                                                                                                        
            QueryAttributeSpec[]  specs;
            QueryAttribute[,]     attribsEvents;
            QueryAttribute[,]     attribsEntrants;
            QueryAttribute[,]     attribsResults;
            QueryAttribute[]      attribs;
            EventData[][]         eventData = null;
            ulong[]               entityIds;
            ulong[]               leaderboards = new ulong[3];;
            CronJobWire[] jobs = null;


            try
            {
            
            Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "***** SLOTTING COMPETITION 0x" + entityId.ToString("x") + " ********");
            

            if (((uint)source & ((uint)Source.Server)) == 0)
            {
                isFromServer = false;
            }
            
            if (!isFromServer)
            {
                // need to find the slotting job.   Initially, this will be used to validate the user/team making this 
                // request, to ensure theyre the owner.   Once slotting is done, the job will be removed. 
                //
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Looking for slotting job..");    

                
                hr = CronUtil.FindJobs("Comp Select callback: compId: 0x" + entityId.ToString("x") + " action: " + Comp.XONLINE_COMP_ACTION_SLOTTING, out jobs);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA_2, 
                        "Failed to find existing slotting job!");
                }
                
                if (jobs.Length == 0)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Slotting job already gone.");    
                    hr = HResult.XONLINE_E_COMP_UNEXPECTED;
                    goto lbError;
                }
                
                if (jobs.Length > 1)
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, "Attempted to manually advance a competition, but more than one slotting job was scheduled!?.");    
                }
                
                Hashtable jobctx = PluginUtil.XmlToHashtable(jobs[0].argsXml);
                if (userId != (ulong)jobctx["userId"] || teamId != (ulong)jobctx["teamId"])
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "User or team tried to advance the competition but they weren't the owner!.");
                    hr = HResult.XONLINE_E_QUERY_PERMISSION_DENIED;
                    goto lbError;
                }
            }
            
                                
            
            //
            // Select all the Competition configuration data for Slotting and Progression scheduling
            //
            entityIds = new ulong[1];

            entityIds[0] = entityId;
            
            specs = new QueryAttributeSpec[12];

            for(i=0; i<specs.Length; i++)          
            {                
                specs[i] = new QueryAttributeSpec();
            }
            
            specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;
            specs[1].type = Comp.XONLINE_COMP_ATTR_MIN_SLOTS;
            specs[2].type = Comp.XONLINE_COMP_ATTR_PUBLIC_ENTRANTS;
            specs[3].type = Comp.XONLINE_COMP_ATTR_PRIVATE_ENTRANTS;
            specs[4].type = Comp.XONLINE_COMP_ATTR_COMP_START;
            specs[5].type = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
            specs[6].type = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
            specs[7].type = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
            specs[8].type = Comp.XONLINE_COMP_ATTR_ROUND_ONE_START;
            specs[9].type = Comp.XONLINE_COMP_ATTR_ROUND_ONE_END;
            specs[10].type = Comp.XONLINE_COMP_ATTR_REMINDER_MIN;
            specs[11].type = Comp.XONLINE_COMP_ATTR_STATUS;

            hr = Dataset.FindFromIds(source, titleId, datasetId, 
                Comp.XONLINE_COMP_ELIMINATION_FIND_SLOT_INFO, 
                entityIds, 
                specs,
                out attribsResults);

            if (HResult.Failed(hr))
            {
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failed to find competition " + entityId + " for slotting. hr = " + hr);

                hr = HResult.E_INVALIDARG;           
                cleanup = false;
                goto lbError;
            }
            
            minEntrants = (uint)attribsResults[0,1].lValue;
            entrants = (uint)attribsResults[0,2].lValue + (uint)attribsResults[0,3].lValue ;
            dtStart = DateTime.FromFileTimeUtc(attribsResults[0,4].lValue);
            frequency = (uint)attribsResults[0,5].lValue;
            interval = (uint)attribsResults[0,6].lValue;
            dayMask = (uint)attribsResults[0,7].lValue;
            firstRoundStart = DateTime.FromFileTimeUtc(attribsResults[0,8].lValue);
            firstRoundEnd = DateTime.FromFileTimeUtc(attribsResults[0,9].lValue);
            reminderMin = (uint)attribsResults[0,10].lValue;
            status = (ulong)attribsResults[0,11].lValue;

            if (status != Comp.XONLINE_COMP_STATUS_PRE_INIT)
            {
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Competition " + entityId + " was already slotted!");                            
                
                hr = HResult.S_OK;
                goto lbError;
            }

            // Check if we can slot this competition
            if (entrants < minEntrants)
            {
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Not enough entrants for slotting competition " + entityId + ".");            

                if (isFromServer)
                {
                    if (status != Comp.XONLINE_COMP_STATUS_CANCELED)
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Cancelling competition.");
                        
                        ActionCancel(source, titleId, userId, teamId, datasetId, entityId);
                        status = Comp.XONLINE_COMP_STATUS_CANCELED;
                        
                        hr = HResult.S_FALSE;
                    }
                }
                else
                {
                    hr = HResult.XONLINE_E_COMP_TOO_EARLY;
                }
                
                cleanup = false;
                goto lbError;        
            }
            
            
            


            //
            // Select all the Entrants out of the Entrants table, along with their Seed values. 
            //
            attribs = new QueryAttribute[1];
            
            attribs[0] = new QueryAttribute();
            attribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
            attribs[0].lValue = (long)entityId;

            specs = new QueryAttributeSpec[3];
            
            for(i=0; i<specs.Length; i++)          
            {                
                specs[i] = new QueryAttributeSpec();
            }
            
            specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;
            specs[1].type = Comp.XONLINE_COMP_ATTR_ENTRANT_PUID;
            specs[2].type = Comp.XONLINE_COMP_ATTR_ENTRANT_SEED;
            
            hr = Dataset.Search(source, titleId, 
                datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, 
                Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_SEARCH_SEEDS, 
                0,
                Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS,
                attribs,
                specs,
                out results,
                out attribsEntrants);


            if (HResult.Failed(hr))
            {
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Slotting method failed for competition " + entityId + ". Could not select Entrants. hr = " + hr);
                Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_15, "Slotting method failed for competition " + entityId + ". Could not select Entrants. hr = " + hr);
                
                goto lbError;
            }            

            // Don't bother slotting competitions with no Entrants
            if (0 == results)
            {
                throw new XRLException((isFromServer ? HResult.S_FALSE : HResult.XONLINE_E_COMP_ERROR), XEvent.Id.COMPS_CODE_50, "Not slotting competition " + entityId + " because there are no Entrants in the Entrants table. ");            
            }

            if (results != entrants)
            {
                // Log an event, but attempt to continue using the number of rows from the Entrants table. 
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Inconsistency between number of Entrants for competition " + entityId + " Comp column att_80000015 = " + entrants + " Entrants table has " + results + " rows. Continuing");            
                Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_INFO, "Inconsistency between number of Entrants for competition " + entityId + " Comp column att_80000015 = " + entrants + " Entrants table has " + results + " rows. Continuing");            

                entrants = results;
            }


            // The XONLINE_COMP_ELIMINATION_ENTRANTS_SEARCH_SEEDS returns the list of entrants
            //  in attribEntrats, sorted by Seed. All we need to do now is create the events for the competition
            //  and slot the players. 

            // Elimination competitions uses a very simple slotting algorithm: Seed 1 plays Seed N, Seed 2 plays Seed N-1, etc. 
            // BYEs are awarded to the top Y seeds where Y = the number of slots required to bring N to the next complete power of 2

            // Find Y, given N == entrants. 

            rounds = (int)EliminationHelper.RoundsFromEntrants(entrants);

            slots = 1 << rounds;


            //
            // Select all the Events out of the Event table to ensure we don't duplicate events in the event that we are executing a retry. 
            //
            attribs = new QueryAttribute[1];
            
            attribs[0] = new QueryAttribute();
            attribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
            attribs[0].lValue = (long)entityId;
            
            specs = new QueryAttributeSpec[13];

            for(i=0; i<specs.Length; i++)          
            {                
                specs[i] = new QueryAttributeSpec();
            }
            
            specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;
            specs[1].type = Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID;
            specs[2].type = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
            specs[3].type = Comp.XONLINE_COMP_ATTR_EVENT_START;
            specs[4].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY;
            specs[5].type = Comp.XONLINE_COMP_ATTR_EVENT_P1;
            specs[6].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_CHECKIN;
            specs[7].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_TRUST;
            specs[8].type = Comp.XONLINE_COMP_ATTR_EVENT_P2;
            specs[9].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_CHECKIN;
            specs[10].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_TRUST;
            specs[11].type = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
            specs[12].type = Comp.XONLINE_COMP_ATTR_EVENT_LOSER;

            hr = Dataset.Search(source, titleId, 
                datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                Comp.XONLINE_COMP_ELIMINATION_EVENTS_SEARCH_ALL, 
                0,
                Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS,
                attribs,
                specs,
                out results,
                out attribsEvents);

            if (HResult.Failed(hr))
            {
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method failed for competition " + entityId + ". Could not select Events. hr = " + hr);
                goto lbError;
            }            


            // Elimination Events are deterministically related based on the XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID attribute. 
            //   Format: |Reserved|Round|ID|
            //   Bits 20-63 are reserved and must be zero
            //   Bits 16-19 indiate the round the event ID lives in (0 based)
            //   Low order 16 bits are the event ID within the current round
            //  Events in round zero are simply numbered from ID 0 to slots/2
            //  An Event always progresses to Round + 1|ID / 2.
            //  The next event entity in the progression is stored in the Events table to avoid a search by EventId

            // Allocate the jagged array for maintaining Event entityIds
            eventData = new EventData[rounds][];
            
            for (i=(int)rounds; i>0; i--)
            {
                eventData[(int)rounds - i] = new EventData[1 << (i - 1)];
            }

            // Copy the events into their own array for searching later
            if (results > 0)
            {
                for(i=0; i< results; i++)
                {
                    uint     round;
                    uint     eventId;

                    eventId = (uint)attribsEvents[i, 1].lValue;
                    round = eventId >> 16;
                    eventId = eventId & Comp.XONLINE_COMP_ELIMINATION_EVENT_ID_MASK;
                    
                    eventData[round - 1][eventId].Id = (uint)attribsEvents[i, 1].lValue;
                    eventData[round - 1][eventId].entityId = (ulong)attribsEvents[i, 0].lValue;
                    eventData[round - 1][eventId].p1 = (ulong)attribsEvents[i, 5].lValue;
                    eventData[round - 1][eventId].entityP1 = 0;
                    eventData[round - 1][eventId].p2 = (ulong)attribsEvents[i, 8].lValue;
                    eventData[round - 1][eventId].entityP2 = 0;
                }
            }


            // 
            // Slot all the players into the first round
            // 
            // The correct slots are determined by walking backwards
            // through each round, calculating the appropriate seed for each.
            // 
            // Ultimately, the slots need to pass the following checks, for any
            // two players, where
            //   Seed(A) > Seed(B),
            //   Opponent(A) < Opponent(B)
            //
            // Another way to look at it is, if the higher seed wins every event,
            // the top two seeds (1 & 2) should play in the finals. 
            //
            // The trick: the seed index for the two players in each event 
            // should add up to the total number of slots in the round, minus 1.
            //
            int[] p1 = new int[eventData[0].Length];
            int[] p2 = new int[eventData[0].Length];
            p1[0] = 0;
            p2[0] = 1;

            for (int r = 1; r < rounds; r++)
            {
                i = 2 << r;
                
                for (j = (i/2)-1; j >= 0; j--)
                {
                    if (j % 2 == 0)
                    {
                        p1[j] = p1[j/2];
                        p2[j] = (i-1) - p1[j];
                    }
                    else
                    {
                        p2[j] = p2[j/2];
                        p1[j] = (i-1) - p2[j];
                    }    
                }
            }        
                    

            // now put the players in the determined slots. 
            //            
            for (j=0; j<eventData[0].Length; j++)
            {
                
                ulong p1Puid = 0;
                ulong p2Puid = 0;
                ulong p1Entity = 0;
                ulong p2Entity = 0;

                if (p1[j] < entrants)
                {   
                    p1Puid   = (ulong)attribsEntrants[p1[j], 1].lValue;
                    p1Entity = (ulong)attribsEntrants[p1[j], 0].lValue;
                }    
                if (p2[j] < entrants)
                {
                    p2Puid   = (ulong)attribsEntrants[p2[j], 1].lValue;
                    p2Entity = (ulong)attribsEntrants[p2[j], 0].lValue;
                }    
                
                
                
                if ((eventData[0][j].p1 != 0) && (eventData[0][j].p1 != p1Puid))
                {
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_16, "Inconsistency slotting competition " + entityId + 
                            " Overwriting data for p1 in Event " + eventData[0][j].entityId + ". p1 was " + eventData[0][j].p1 + 
                            ", is now " + p1Puid);
                }
                
                eventData[0][j].entityP1 = p1Entity;
                eventData[0][j].p1 = p1Puid;         


                if ((eventData[0][j].p2 != 0) && (eventData[0][j].p2 != p2Puid))
                {
                     Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_17, "Inconsistency slotting competition " + entityId + 
                            " Overwriting data for p2 in Event " + eventData[0][j].entityId + ". p2 was " + eventData[0][j].p2 + 
                            ", is now " + p2Puid);
                }
                
                eventData[0][j].entityP2 = p2Entity;
                eventData[0][j].p2 = p2Puid;                  
                
                
                // handle BYEs
                //
                if (p1Puid == 0)
                {
                    // Award a BYE to p2
                    
                    eventData[0][j].entityP1 = 0;         
                    eventData[0][j].p1 = 0;         
                    
                    // P1 wins by default
                    eventData[0][j].pWinner = p2Puid;

                    // Update second round event
                    if (j % 2 == 0)
                    {
                        // update player 1 of next round
                        if ((eventData[1][j/2].p1 != 0) && (eventData[1][j/2].p1 != p2Puid))
                        {
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_18, "Inconsistency slotting competition " + entityId + 
                                    " Overwriting data for p1 in Event " + eventData[1][j/2].entityId + ". p1 was " + eventData[1][j/2].p1 + 
                                    ", is now " + p2Puid);
                        }
                        
                        eventData[1][j/2].p1 = p2Puid;
                    }
                    else
                    {
                        // update player 2 of next round
                        if ((eventData[1][j/2].p2 != 0) && (eventData[1][j/2].p2 != p2Puid))
                        {
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_19, "Inconsistency slotting competition " + entityId + 
                                    " Overwriting data for p2 in Event " + eventData[1][j/2].entityId + ". p2 was " + eventData[1][j/2].p2 +
                                    ", is now " + p2Puid);
                        }
                        
                        eventData[1][j/2].p2 = p2Puid;
                    }
                    
                    byes++;
                }
                else if (p2Puid == 0)
                {
                    // Award a BYE to P1
                    //
                    eventData[0][j].pWinner = p1Puid;

                    // Update second round event
                    if (j % 2 == 0)
                    {
                        if ((eventData[1][j/2].p1 != 0) && (eventData[1][j/2].p1 != p1Puid))
                        {
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_20, "Inconsistency slotting competition " + entityId + 
                                    " Overwriting data for p1 in Event " + eventData[1][j/2].entityId + ". p1 was " + eventData[1][j/2].p1 + 
                                    ", is now " + p1Puid);
                        }
                        
                        eventData[1][j/2].p1 = p1Puid;
                    }
                    else
                    {
                        if ((eventData[1][j/2].p2 != 0) && (eventData[1][j/2].p2 != p1Puid))
                        {
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_21, "Inconsistency slotting competition " + entityId + 
                                    " Overwriting data for p2 in Event " + eventData[1][j/2].entityId + ". p2 was " + eventData[1][j/2].p2 +
                                    ", is now " + p1Puid);
                        }
                        
                        eventData[1][j/2].p2 = p1Puid;
                    }
                    
                    byes++;
                }                    
            }
            

            
            
            //
            // Setup Static Attribs for all rounds
            //
            attribs = new QueryAttribute[9];
            
            for (i = 0; i < attribs.Length; i++)    
            {
                attribs[i] = new QueryAttribute(); 
            }
            
            attribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
            attribs[0].lValue = (long)entityId;

            attribs[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID;
            attribs[2].Id = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
            attribs[3].Id = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY;
            attribs[4].Id = Comp.XONLINE_COMP_ATTR_EVENT_P1;
            attribs[5].Id = Comp.XONLINE_COMP_ATTR_EVENT_P2;
            attribs[6].Id = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
            attribs[7].Id = Comp.XONLINE_COMP_ATTR_EVENT_START;
            attribs[8].Id = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_START;


            // 
            // Create Events for the competition. Start at round N and work backwards. 
            //             
            for (i=(int)rounds; i>0; i--)
            {
                DateTime    roundStart = firstRoundStart + CompHelper.IntervalToTimeSpan(firstRoundStart, frequency * (uint)(i - 1), interval, (int)dayMask);
                DateTime    nextStart = firstRoundStart + CompHelper.IntervalToTimeSpan(roundStart, frequency * (uint)i, interval, (int)dayMask);

                // Per round values
                attribs[2].lValue = i-1;  
                attribs[7].lValue = roundStart.ToFileTimeUtc();                
                attribs[8].lValue = nextStart.ToFileTimeUtc();

                for (j=0; j<eventData[i -1].Length; j++)
                {
                    uint     eventId;
                    HResult  hrAdd;
                    ulong    entityEvent;
                    
                    eventId = (uint)(((i-1) << 16) + j);
                    
                    attribs[1].lValue = eventId;

                    if (i == rounds)
                    {
                        attribs[3].lValue = 0;
                        attribs[8].lValue = 0;              // No more matches 
                    }
                    else
                    {
                        attribs[3].lValue = (long)eventData[i][j / 2].entityId;
                    }

                    attribs[4].lValue = (long)eventData[i-1][j].p1;
                    attribs[5].lValue = (long)eventData[i-1][j].p2;
                    attribs[6].lValue = (long)eventData[i-1][j].pWinner;
                    
                    if (eventData[i-1][j].entityId == 0)
                    {                
                        hrAdd = Dataset.Add(source, 
                                titleId, 
                                0, 
                                0, 
                                datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                                attribs, 
                                out entityEvent);

                        if (HResult.Failed(hrAdd))
                        {
                            Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Slotting method failed for competition " + entityId + ". Could not add Event. hr = " + hr);
                            hr = hrAdd;
                            // Continue to attempt to add the rest of the Events. Cron service will retry
                        }           
                        else
                        {
                            eventData[i-1][j].Id = eventId;
                            eventData[i-1][j].entityId = entityEvent;                                    
                        }
                    }
                    else
                    {
                        // We found the event we plan to create in attribsEvents. Validate the event to ensure we aren't doing something horribly wrong

                        // Ensure the event we found by index is indeed the event we were supposed to create. Player discrepancies would have been 
                        //  caught earlier during slotting of round 1.
                        if (attribs[1].lValue != (long)eventData[i-1][j].Id)
                        {
                            Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Slotting method error for competition " + entityId + ". EventIds do not match, and skipping Add call anyway for event " + eventData[i][j].Id);            
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_22, "Slotting method error for competition " + entityId + ". EventIds do not match, and skipping Add call anyway for event " + eventData[i][j].Id);      
                            hr = HResult.XONLINE_E_COMP_UNEXPECTED;
                        }            
                    }
                }
            }


            //
            // Iterate over the first round events again, and update all entrants with current event entityId info
            //
            DateTime    secondRoundStart = firstRoundStart + CompHelper.IntervalToTimeSpan(firstRoundStart, frequency, interval, (int)dayMask);
            HResult     hrUpdate;
            
            for (j=0; j<eventData[0].Length; j++)
            {
                
                // only update players in round 0 that have an opponent..
                if (0 != eventData[0][j].p1 && 0 != eventData[0][j].p2)    
                {
                    hrUpdate = UpdateEntrant(source, 
                                titleId, 
                                eventData[0][j].p1,         // PUID
                                datasetId, 
                                entityId,                   // Comp Id
                                eventData[0][j].Id,         // Event Id
                                eventData[0][j].entityId,   // Event entityId
                                (ulong)firstRoundStart.ToFileTimeUtc(),
                                Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING);

                    if (HResult.Failed(hrUpdate))
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Slotting method error for competition " + entityId + ". Failed to update Entrant " + eventData[0][j].entityP1 + " with Event information " + eventData[0][j].Id + ". hr = " + hr);
                        Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_23, "Slotting method error for competition " + entityId + ". Failed to update Entrant " + eventData[0][j].entityP1 + " with Event information " + eventData[0][j].Id + ". hr = " + hrUpdate);
                        hr = hrUpdate;
                    }                              
             
                    hrUpdate = UpdateEntrant(source, 
                                titleId, 
                                eventData[0][j].p2,     // PUID
                                datasetId, 
                                entityId,               // Comp Id
                                eventData[0][j].Id,     // Event Id
                                eventData[0][j].entityId, // Event entity Id
                                (ulong)firstRoundStart.ToFileTimeUtc(),
                                Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING);

                    if (HResult.Failed(hrUpdate))
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Slotting method error for competition " + entityId + ". Failed to update Entrant " + eventData[0][j].entityP2 + " with Event information " + eventData[0][j].Id + ". hr = " + hrUpdate);
                        Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_24, "Slotting method error for competition " + entityId + ". Failed to update Entrant " + eventData[0][j].entityP2 + " with Event information " + eventData[0][j].Id + ". hr = " + hrUpdate);
                        hr = hrUpdate;
                    }         
                }
            }
            
            //
            // Iterate over the second round events, and update all entrants with current event entityId info
            //
            if (rounds > 1)
            {
                for (j = 0; j < eventData[1].Length; j++)
                {
                    
                    if (0 != eventData[1][j].p1)
                    {
                        hrUpdate = UpdateEntrant(source, 
                                    titleId, 
                                    eventData[1][j].p1,         // PUID
                                    datasetId, 
                                    entityId,                   // Comp Id
                                    eventData[1][j].Id,         // Event Id
                                    eventData[1][j].entityId,   // Event entityId
                                    (ulong)secondRoundStart.ToFileTimeUtc(),
                                    Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING);
    
                        if (HResult.Failed(hrUpdate))
                        {
                            Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Slotting method error for competition " + entityId + ". Failed to update Entrant " + eventData[0][j].entityP1 + " with Event information " + eventData[0][j].Id + ". hr = " + hrUpdate);
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_25, "Slotting method error for competition " + entityId + ". Failed to update Entrant " + eventData[0][j].entityP1 + " with Event information " + eventData[0][j].Id + ". hr = " + hrUpdate);
                            hr = hrUpdate;
                        }                              
                    }
                        
                    if (0 != eventData[1][j].p2)
                    {
                        hrUpdate = UpdateEntrant(source, 
                                    titleId, 
                                    eventData[1][j].p2,         // PUID
                                    datasetId, 
                                    entityId,                   // Comp Id
                                    eventData[1][j].Id,         // Event Id
                                    eventData[1][j].entityId,   // Event entityId
                                    (ulong)secondRoundStart.ToFileTimeUtc(),
                                    Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING);
    
                        if (HResult.Failed(hrUpdate))
                        {
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_26, "Slotting method error for competition " + entityId + 
                                    ". Failed to update Entrant entity " + eventData[0][j].entityP2 + 
                                    " with Event information " + eventData[0][j].Id + ". hr = " + hrUpdate);
                            hr = hrUpdate;
                        }                              
                    }
                }
            }

            if (HResult.Failed(hr))
            {
                // Fail out and retry
                goto lbError;
            }


            //
            // Create leaderboards for the competition
            //
            if (HResult.Succeeded(hr))
            {
                uint     cLeaderboards = 0;
                uint     leaderboardTemplate = 0;

                if (ctx.ContainsKey("leaderboardTemplateId"))
                {
                    leaderboardTemplate = (uint)(long)ctx["leaderboardTemplateId"];
                }

                if (ctx.ContainsKey("leaderboards"))
                {
                    cLeaderboards = (uint)(long)ctx["leaderboards"];
                }

                if ((cLeaderboards > 0) && (leaderboardTemplate != 0))
                {
                    if (cLeaderboards > 3)
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Competition plugin context for title " + titleId + ", dataset " + datasetId + " specified " + cLeaderboards + " leaderboards when 3 is the maximum!");            
                        Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_CONFIG_ERROR, "Competition plugin context for title " + titleId + ", dataset " + datasetId + " specified " + cLeaderboards + " leaderboards when 3 is the maximum!");      
                    }
                    else
                    {
                        for (i = 0; i < cLeaderboards; i++)
                        {
                            leaderboards[i] = CompUtil.CreateLeaderboard(titleId, leaderboardTemplate);
                        }
                    }
                }
            }
            
            
            //
            // Update the competition record with current info, and set the competition status flag on all entrants
            //
            if (HResult.Succeeded(hr))
            {
                status = Comp.XONLINE_COMP_STATUS_ACTIVE;
                
                if (!isFromServer)
                {
                    // this was advanced by the owner.  Change the first round start time to start 
                    // right away, leaving enough time to send out advance reminders.
                    //
                    
                    firstRoundStart = DateTime.UtcNow.AddMinutes(reminderMin);
                }
                    
                
                
                attribs = new QueryAttribute[8];
                
                for (i = 0; i < attribs.Length; i++)    
                {
                    attribs[i] = new QueryAttribute(); 
                }
            
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_ROUNDS;
                attribs[0].lValue = (long)rounds;               
                attribs[1].Id = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND;
                attribs[1].lValue = 0;   
                attribs[2].Id = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_START;
                attribs[2].lValue = firstRoundStart.ToFileTimeUtc(); 
                attribs[3].Id = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_END;
                attribs[3].lValue = firstRoundEnd.ToFileTimeUtc(); 
                attribs[4].Id = Comp.XONLINE_COMP_ATTR_STATUS;
                attribs[4].lValue = (long)status;
                attribs[5].Id = Comp.XONLINE_COMP_ATTR_LEADERBOARD_ID0;
                attribs[5].lValue = (long)leaderboards[0];
                attribs[6].Id = Comp.XONLINE_COMP_ATTR_LEADERBOARD_ID1;
                attribs[6].lValue = (long)leaderboards[1];
                attribs[7].Id = Comp.XONLINE_COMP_ATTR_LEADERBOARD_ID2;
                attribs[7].lValue = (long)leaderboards[2];
                
                hr = Dataset.UpdateId(source, 
                                titleId, 
                                userId, 
                                teamId, 
                                datasetId, 
                                Comp.XONLINE_COMP_ELIMINATION_UPDATEID_SLOTTING, 
                                entityId, 
                                attribs);

                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression Update method failed for Competition " + entityId + " with hr = " + hr);

                    // We are going to orphan leaderboards! Attempt to clean them up before we bail. 
                    
                    goto lbError;
                }


                hr = UpdateEntrantStatus(source, titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_STATUS_ACTIVE);

                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression Update method failed for Competition " + entityId + " with hr = " + hr);
                    goto lbError;
                }            
                
                if (!isFromServer)
                {
                    // user advanced call, remove the job
                    CronUtil.RemoveJob(jobs[0].jobId, titleId);
                }    
                    
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Slotting method completed for competition " + entityId);            
            }

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                int         cleanupJob = 0;
                
                if (HResult.Succeeded(hr))
                {
                    if (status != Comp.XONLINE_COMP_STATUS_ACTIVE)
                    {
                        if (cleanup)
                        {
                            //
                            // Add cleanup job
                            //
                            hr = SafeScheduleJob(titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_ACTION_CLEANUP, 1, 5 * 60, QueryUtil.UtcNow.AddDays(1), 0, out cleanupJob);                
                        }
                    }
                    else
                    {
                        //
                        // Schedule reminder and progression jobs for the first round - AddRoundJobs adds another log line of its own
                        //
                        hr = AddRoundJobs(titleId, userId, teamId, datasetId, entityId, reminderMin, firstRoundStart, firstRoundEnd);
                    }
                }

                
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "SLT", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"), 
                              minEntrants.ToString("x"),
                              entrants.ToString("x"),
                              dtStart.ToString(),
                              frequency.ToString("x"),
                              interval.ToString("x"),
                              dayMask.ToString("x"),
                              firstRoundStart.ToString(),
                              firstRoundEnd.ToString(),
                              reminderMin.ToString("x"),
                              rounds.ToString("x"),
                              slots.ToString("x"),
                              byes.ToString("x"),
                              leaderboards[0].ToString("x16") + "," + leaderboards[1].ToString("x16") + "," + leaderboards[2].ToString("x16"),
                              results.ToString("x"),
                              status.ToString("x"),
                              cleanupJob.ToString(),
                              isFromServer.ToString()
                        }));       
                            
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "***** SLOTTING COMPLETE ********");
                        

                counters.EndRequest(HResult.Failed(hr));
            }                       
            
lbError:
            return hr;
        }

        
        private HResult AutoProgress(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong compId, QueryAttribute[,] attribsResults, uint eventIndex, DateTime eventStart, long checkinSecs, out ulong pWinner)
        {
            int                   i;
            HResult                  hr = HResult.S_OK;
            ulong                 entityId = (ulong)attribsResults[eventIndex, 0].lValue;
            ulong                 eventId = (ulong)attribsResults[eventIndex, 1].lValue;
            ulong                 entityNextEvent = (ulong)attribsResults[eventIndex, 2].lValue;
            ulong                 nextEventStart = (ulong)attribsResults[eventIndex, 3].lValue;
            ulong                 p1 = (ulong)attribsResults[eventIndex, 4].lValue;
            ulong                 p1Checkin= (ulong)attribsResults[eventIndex, 5].lValue;
            ulong                 p2 = (ulong)attribsResults[eventIndex, 7].lValue;
            ulong                 p2Checkin = (ulong)attribsResults[eventIndex, 8].lValue;
            ulong                 pLoser = 0;
            QueryAttribute[]      attribs;
            
            DateTime    checkinWindowStart = DateTime.MinValue;
            DateTime    checkinWindowEnd = DateTime.MinValue;
            
            DateTime    p1CheckinTime = DateTime.MinValue;
            DateTime    p2CheckinTime = DateTime.MinValue;
            bool        p1CheckedIn = false;
            bool        p2CheckedIn = false;
            
            float       p1Trust = 0;
            float       p2Trust = 0;

            pWinner = 0;
            
            try
            {
                if ((0 != p1Checkin) || (0 != p2Checkin))
                {
                    // We have enough information to make a decision... Somebody at least tried to play. 
                    if ((0 == p1Checkin) && (0 != p2Checkin))
                    {
                        pWinner = p2;
                        p2CheckedIn = true;
                    }
                    else if ((0 == p2Checkin) && (0 != p1Checkin))
                    {
                        pWinner = p1;
                        p1CheckedIn = true;
                    }
                    else    // Both players checked in at some point
                    {
                        // Find the threshold for the checkin window
                        checkinWindowStart = eventStart.AddSeconds(-checkinSecs);
                        checkinWindowEnd = eventStart.AddSeconds(checkinSecs);
                        
                        p1CheckinTime = DateTime.FromFileTimeUtc((long)p1Checkin);
                        p2CheckinTime = DateTime.FromFileTimeUtc((long)p2Checkin);
    
                        if ((checkinWindowStart < p1CheckinTime) && (p1CheckinTime < checkinWindowEnd))
                        {
                            p1CheckedIn = true;
                        }
                        
                        if ((checkinWindowStart < p2CheckinTime) && (p2CheckinTime < checkinWindowEnd))
                        {
                            p2CheckedIn = true;
                        }
    
                        if ((true == p1CheckedIn) && (false == p2CheckedIn))
                        {
                            pWinner = p1;
                        }
                        else if ((true == p2CheckedIn) && (false == p1CheckedIn))
                        {
                            pWinner = p2;
                        }
                        else if ((true == p1CheckedIn) && (true == p2CheckedIn))
                        {                
                            p1Trust = CompUtil.TrustFromBlob(attribsResults[eventIndex, 6].binValue);
                            p2Trust = CompUtil.TrustFromBlob(attribsResults[eventIndex, 9].binValue);
                    
                            // Both players checked in, but no results submitted. Use trust
                            if (p1Trust > p2Trust)
                            {
                                pWinner = p1;
                            }
                            else if (p2Trust > p1Trust)
                            {
                                pWinner = p2;
                            }
                            else
                            {
                               // Both players checked in, and Trust values are equal. Whoever checked in first wins.
                               pWinner = p1CheckinTime < p2CheckinTime ? p1 : p2;
                            }
                        }
    
                        // if neither player checked in during the 10 min checkin window, both forfeit
                    }
    
                    if (0 != pWinner)
                    {
                        pLoser = pWinner == p1 ? p2 : p1;
          
                        //
                        // Setup Attribs for Event update
                        //
                        attribs = new QueryAttribute[2];
                        
                        for (i = 0; i < attribs.Length; i++)    
                        {
                            attribs[i] = new QueryAttribute(); 
                        }
                        
                        attribs[0].Id = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
                        attribs[0].lValue = (long)pWinner;
    
                        attribs[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_LOSER;
                        attribs[1].lValue = (long)pLoser;
                        
                        hr = Dataset.UpdateId(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_RESULT, entityId, attribs);
    
                        if (HResult.Failed(hr))
                        {
                            Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Auto-Progress Update method failed for Event " + eventId + " in competition " + entityId + ". hr = " + hr);  
                            // REVIEW: throw?          
                        }
    
    
                        //
                        // Update Winner Entrant record
                        //
                        if ((0 != pWinner) && HResult.Succeeded(hr))
                        {
                            hr = UpdateEntrant(source, titleId, pWinner, datasetId, compId, NextEventIdFromEventId(eventId), entityNextEvent, nextEventStart, Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING);
                            // REVIEW: throw on failure?
    
                            ulong p1Next = (eventId % 2 == 0) ? pWinner : 0;
                            ulong p2Next = (eventId % 2 == 0) ? 0 : pWinner;
                    
                            hr = UpdateEvent(source, 
                                        titleId, 
                                        datasetId, 
                                        compId, 
                                        p1Next,     // p1
                                        p2Next,     // p2
                                        0,          // winner
                                        0,          // loser
                                        entityNextEvent, 
                                        Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED, 
                                        null);

                            // REVIEW: throw on failure?
                        }
    
                        
                        //
                        // Update Loser Entrant record
                        //
                        if ((0 != pLoser) && HResult.Succeeded(hr))
                        {
                            hr = UpdateEntrant(source, titleId, pLoser, datasetId, compId, eventId, entityId, 0, Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED);
                            // REVIEW: throw on failure?
                        }                    
                    }
                }
    
                if (0 == pWinner)
                {
                    //
                    // Eliminate both players for not playing the match
                    //
                    if (0 != p1)
                    {
                        hr = UpdateEntrant(source, titleId, p1, datasetId, compId, eventId, entityId, 0, Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED);
                        // REVIEW: throw on failure?
                    }
    
                    if (0 != p2)
                    {
                        hr = UpdateEntrant(source, titleId, p2, datasetId, compId, eventId, entityId, 0, Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED);                
                        // REVIEW: throw on failure?
                    }
                }

                if (false == p1CheckedIn && 0 != p1)
                {
                    // p1 is a no-show. Update arbitration appropriately using p_xqry_update_user_trust
                    hr = Dataset.UpdateQueryTrust(titleId, p1, 0, 1);

              	    Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                                  "UQT", 
                                  hr.ToString(), 
                                  titleId.ToString("x8"), 
                                  p1.ToString("x16"),
                                  p2.ToString("x16"),
    			      "1"
                            }));       
                }

                if (false == p2CheckedIn && 0 != p2)
                {
                    // p2 is a no-show. Update arbitration appropriately using p_xqry_update_user_trust
                    hr = Dataset.UpdateQueryTrust(titleId, p2, 0, 1);

              	    Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                                  "UQT", 
                                  hr.ToString(), 
                                  titleId.ToString("x8"), 
                                  p1.ToString("x16"),
                                  p2.ToString("x16"),
    			      "2"
                            }));       
                }
                
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "APG", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              compId.ToString("x16"), 
                              entityId.ToString("x16"), 
                              eventId.ToString("x16"),
                              eventStart.ToString(),
                              checkinWindowStart.ToString(),
                              checkinWindowEnd.ToString(),
                              p1.ToString("x16"),
                              p1CheckinTime.ToString(),
                              p1Trust.ToString(),
                              p2.ToString("x16"),
                              p2CheckinTime.ToString(),
                              p2Trust.ToString(),
                              pWinner.ToString("x16"),
                              entityNextEvent.ToString("x16"),
                              nextEventStart.ToString("x16")
                        }));       

            }
            
            
            
            return hr;
        }

        
        private HResult ActionProgression(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            ProgressionCounters counters = new ProgressionCounters(titleId);

            int                   i;
            HResult                  hr = HResult.XONLINE_E_COMP_ERROR;
            uint                  curResults = 0;
            uint                  nextResults = 0;
            uint                  frequency = 0;
            uint                  interval = 0;
            uint                  dayMask = 0;
            uint                  reminderMin = 0;
            uint                  cleanupDays = 0;
            uint                  round = 0;
            uint                  rounds = 0;            
            DateTime              currentRoundStart = DateTime.MinValue;
            DateTime              currentRoundEnd = DateTime.MinValue;
            DateTime              nextRoundStart = DateTime.MinValue;
            DateTime              nextRoundEnd = DateTime.MinValue;
            uint                  status = Comp.XONLINE_COMP_STATUS_PRE_INIT;
            uint                  cAutoProgress = 0;
            uint                  cAutoProgressErrors = 0;
            uint                  cUpdated = 0;
            uint                  cUpdateErrors = 0;

            QueryAttributeSpec[]  specs;
            QueryAttribute[,]     attribsResults;
            QueryAttribute[,]     attribsCurEvents;
            QueryAttribute[,]     attribsNextEvents = null;
            QueryAttribute[]      attribs;
            bool []               fUpdate = null;
            ulong []              entityIds;


            try
            {
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "***** PROGRESSING COMPETITION 0x" + entityId.ToString("x") + " ********");
                
                // Service only method. Source.Server flag must be set
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
    
    
                //
                // Select all the Competition configuration data for Progression
                //
                entityIds = new ulong[1];
    
                entityIds[0] = entityId;
                
                specs = new QueryAttributeSpec[11];
    
                for(i=0; i<specs.Length; i++)          
                {                
                    specs[i] = new QueryAttributeSpec();
                }
                
                specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;
                specs[1].type = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
                specs[2].type = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
                specs[3].type = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
                specs[4].type = Comp.XONLINE_COMP_ATTR_ROUNDS;
                specs[5].type = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND;
                specs[6].type = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_START;
                specs[7].type = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_END;
                specs[8].type = Comp.XONLINE_COMP_ATTR_REMINDER_MIN;
                specs[9].type = Comp.XONLINE_COMP_ATTR_COMP_CLEANUP;
                specs[10].type = Comp.XONLINE_COMP_ATTR_STATUS;
    
                hr = Dataset.FindFromIds(source, titleId, datasetId, 
                    Comp.XONLINE_COMP_ELIMINATION_FIND_PROGRESS_INFO, 
                    entityIds, 
                    specs,
                    out attribsResults);
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failed to find competition " + entityId + " for progression. Hr = " +  hr.ToString() );            
                    
                    hr = HResult.S_FALSE;
                    goto lbError;
                }
                
                frequency = (uint)attribsResults[0,1].lValue;
                interval = (uint)attribsResults[0,2].lValue;
                dayMask = (uint)attribsResults[0,3].lValue;
                rounds = (uint)attribsResults[0,4].lValue;
                round = (uint)attribsResults[0,5].lValue;
                currentRoundStart = DateTime.FromFileTimeUtc(attribsResults[0,6].lValue);
                currentRoundEnd = DateTime.FromFileTimeUtc(attribsResults[0,7].lValue);
                reminderMin = (uint)attribsResults[0,8].lValue;
                cleanupDays = (uint)attribsResults[0,9].lValue;
                status = (uint)attribsResults[0,10].lValue;
    
    
                // Don't bother progressing cancelled competitions          
                if (Comp.XONLINE_COMP_STATUS_ACTIVE != status)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Not progressing competition " + entityId + " because it is not active. Status = " + status);            
    
                    hr = HResult.S_FALSE;                
                    goto lbError;                
                }
    
    
                // Make sure the round is over before allowing auto-progression
                if (currentRoundEnd > QueryUtil.UtcNow)
                {
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_27, "Progression attempted for round that is not yet completed in competition " + entityId + " currentRoundEnd: " + currentRoundEnd + " Current time: " + QueryUtil.UtcNow);            
    
                    hr = HResult.XONLINE_E_COMP_UNEXPECTED;         
                    goto lbError;                                
                }
    
    
                //
                // Figure out next round information
                //
                nextRoundStart = currentRoundStart + CompHelper.IntervalToTimeSpan(currentRoundStart, frequency, interval, (int)dayMask);
                nextRoundEnd = currentRoundEnd + CompHelper.IntervalToTimeSpan(currentRoundEnd, frequency, interval, (int)dayMask);
    
                
    
                // Ensure we didn't slip a round due to some service outage. 
                if (QueryHealth.WasServiceDown(currentRoundStart, currentRoundEnd))
                {
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_28, "Service is DOWN. Rescheduling progression job for comptition " + entityId);            
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Service is DOWN. Rescheduling progression job for competition " + entityId);            
                    
                    goto lbUpdateTimes;                                                
                }
                
                
                //
                // Select all the Events out of the Event table for the current round. 
                //
                attribs = new QueryAttribute[2];
                
                for (i = 0; i < attribs.Length; i++)    
                {
                    attribs[i] = new QueryAttribute(); 
                }
                
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                attribs[0].lValue = (long)entityId;
    
                attribs[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
                attribs[1].lValue = (long)round;   
                
                specs = new QueryAttributeSpec[12];
    
                for(i=0; i<specs.Length; i++)          
                {                
                    specs[i] = new QueryAttributeSpec();
                }
                
                specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID; 
                specs[1].type = Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID;
                specs[2].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY;
                specs[3].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_START;
                specs[4].type = Comp.XONLINE_COMP_ATTR_EVENT_P1;
                specs[5].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_CHECKIN;
                specs[6].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_TRUST;
                specs[6].len = 4;                                   
                specs[7].type = Comp.XONLINE_COMP_ATTR_EVENT_P2;
                specs[8].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_CHECKIN;
                specs[9].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_TRUST;
                specs[9].len = 4;                                   
                specs[10].type = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
                specs[11].type = Comp.XONLINE_COMP_ATTR_EVENT_LOSER;
    
                hr = Dataset.Search(source, titleId, 
                    datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                    Comp.XONLINE_COMP_ELIMINATION_EVENTS_SEARCH_ROUND, 
                    0,
                    Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS,
                    attribs,
                    specs,
                    out curResults,
                    out attribsCurEvents);
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method failed for competition " + entityId + ". Could not select Events. hr = " + hr);
                    goto lbError;
                }            
    
                if (0 == curResults)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method failed for competition " + entityId + ". No Events to progress!.");            
    
                    hr = HResult.S_FALSE;
                    goto lbError;
                }            
    
                
                //
                // Select all the Events out of the Event table for the next round. 
                //
                nextResults = 0;
                
                if (rounds > round)
                {
                    attribs[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
                    attribs[1].lValue = (long)round + 1;   
                    
                    hr = Dataset.Search(source, titleId, 
                        datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                        Comp.XONLINE_COMP_ELIMINATION_EVENTS_SEARCH_ROUND, 
                        0,
                        Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS,
                        attribs,
                        specs,
                        out nextResults,
                        out attribsNextEvents);
    
                    if (HResult.Failed(hr))
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method failed for competition " + entityId + ". Could not select Events. hr = " + hr);
                        // REVIEW: throw? log event?
                        
                        goto lbError;
                    }            
    
                    if (nextResults > 0)
                    {
                        fUpdate = new bool[nextResults];
    
                        for (i=0; i<nextResults; i++)
                        {
                            fUpdate[i] = false;
                        }
                    }
                }
    
    
                //
                // Establish the checkin window size. This is typically constant, but a title can override it via the context
                //  object in their plugin configuration info specified in NPDB. 
                //
                long     checkinSeconds = Comp.XONLINE_COMP_CHECKIN_WIN_SECS;
    
                if (ctx.ContainsKey("checkinSeconds"))
                {
                    checkinSeconds = (long)ctx["checkinSeconds"];
                }
                
                //
                // Spin through the events for the current round and ensure they are all scored correctly, and that the next rounds' events are correctly setup
                //
                uint        eventIndex;
                ulong       curEventId;
                ulong       nextEventId;
                uint        nextEventIndex;
                
                for (eventIndex = 0; eventIndex < curResults; eventIndex++)
                {
                    ulong       puidWinner = (ulong)attribsCurEvents[eventIndex, 10].lValue;                
                    HResult        hrProgress = HResult.S_FALSE;
    
                    curEventId = (ulong)attribsCurEvents[eventIndex, 1].lValue;
                    
                    if (((curEventId & Comp.XONLINE_COMP_ELIMINATION_EVENT_ID_MASK) != eventIndex) || (curEventId >> 16 != round))
                    {
                        // Unexpected order of Events!
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method bad Event order. Current Event " + curEventId + " expected Next Event " + eventIndex.ToString("x") + " of round " + round);            
                        Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_29, "Progression method bad Event order. Current Event " + curEventId + " expected Next Event " + eventIndex.ToString("x") + " of round " + round);            
                    }
                
                    if (0 == puidWinner)
                    {
                        // This event was not yet scored properly. 
                        hrProgress = AutoProgress(source, titleId, userId, teamId, datasetId, entityId, attribsCurEvents, eventIndex, currentRoundStart, checkinSeconds, out puidWinner);
    
                        if (HResult.Failed(hrProgress))
                        {
                            // Save the failure for eventual retry
                            hr = hrProgress;
                            cAutoProgressErrors++;
                        }
    
                        if (0 == puidWinner)
                        {
                            // This could happen if nobody shows up for the event. In that case, there is no information
                            //  to form a conclusion about a winner or loser, and both entrants forfeit the match. 
                        }                 
                           
                        cAutoProgress++;
                    }
    
                    if (null != fUpdate)
                    {
                        // Calc next event
                        nextEventId = NextEventIdFromEventId(curEventId);
                        nextEventIndex = (uint)nextEventId & Comp.XONLINE_COMP_ELIMINATION_EVENT_ID_MASK;
                        
                        if (attribsNextEvents[nextEventIndex, 0].lValue != attribsCurEvents[eventIndex, 2].lValue)
                        {
                            // Unexpected order of Events!
                            Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method bad Event order. Current Event " + curEventId + " expected Next Event " + nextEventId + " but has Next Event Id " + ((uint)attribsCurEvents[eventIndex, 2].lValue));            
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_30, "Progression method bad Event order. Current Event " + curEventId + " expected Next Event " + nextEventId + " but has Next Event Id " + ((uint)attribsCurEvents[eventIndex, 2].lValue));            
                        }
    
                        if (nextEventId != (ulong)attribsNextEvents[nextEventIndex, 1].lValue)
                        {
                            // Unexpected order of Events!
                            Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method bad Event order. Next Event " + nextEventId + " expected at index " + nextEventIndex + " but found Event Id " + ((uint)attribsNextEvents[eventIndex, 1].lValue));            
                            Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_31, "Progression method bad Event order. Next Event " + nextEventId + " expected at index " + nextEventIndex + " but found Event Id " + ((uint)attribsNextEvents[eventIndex, 1].lValue));            
                        }
                        else
                        {
                            if (eventIndex % 2 == 0) 
                            {
                                if (attribsNextEvents[nextEventIndex, 4].lValue != (long)puidWinner)
                                {
                                    if (attribsNextEvents[nextEventIndex, 4].lValue != 0)
                                    {
                                        // We are going to overwrite the value recorded in the database for P1!This should not occur
                                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method is overwriting data for Event " + nextEventId + " for attribute P1 (0x80030008). P1 was " + attribsNextEvents[nextEventIndex, 4].lValue);            
                                        Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_32, "Progression method is overwriting data for Event " + nextEventId + " for attribute P1 (0x80030008). P1 was " + attribsNextEvents[nextEventIndex, 4].lValue);            
                                    }
                                    
                                    attribsNextEvents[nextEventIndex, 4].lValue = (long)puidWinner;
                                    fUpdate[nextEventIndex] = true;
                                }
                            }
                            else 
                            {
                                if (attribsNextEvents[nextEventIndex, 7].lValue != (long)puidWinner)
                                {
                                    if (attribsNextEvents[nextEventIndex, 7].lValue != 0)
                                    {
                                        // We are going to overwrite the value recorded in the database for P2!This should not occur
                                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method is overwriting data for Event " + nextEventId + " for attribute P2 (0x8003000B). P2 was " + attribsNextEvents[nextEventIndex, 7].lValue);            
                                        Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_33, "Progression method is overwriting data for Event " + nextEventId + " for attribute P2 (0x8003000B). P2 was " + attribsNextEvents[nextEventIndex, 7].lValue);            
                                    }
                                    
                                    attribsNextEvents[nextEventIndex, 7].lValue = (long)puidWinner;
                                    fUpdate[nextEventIndex] = true;
                                }
                            }
                        }
                    }
                }
    
    
                //
                // Spin through the events for the next round and update any as required
                //
                if (null != fUpdate)
                {
                    HResult        hrUpdate;
                    
                    attribs = new QueryAttribute[2];
                    
                    for (i = 0; i < attribs.Length; i++)    
                    {
                        attribs[i] = new QueryAttribute(); 
                    }
                
                    attribs[0].Id = Comp.XONLINE_COMP_ATTR_EVENT_P1;
                    attribs[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_P2;
    
                    for (nextEventIndex = 0; nextEventIndex < nextResults; nextEventIndex++)
                    {
                        if (fUpdate[nextEventIndex])
                        {
                            attribs[0].lValue = (long)attribsNextEvents[nextEventIndex, 4].lValue;
                            attribs[1].lValue = (long)attribsNextEvents[nextEventIndex, 7].lValue;   
                            
                            if ((attribsNextEvents[nextEventIndex,11].lValue != 0) || (attribsNextEvents[nextEventIndex,10].lValue != 0))
                            {
                                // Complex update because winner or loser is already set
                                hrUpdate = UpdateEvent(source, 
                                            titleId, 
                                            datasetId, 
                                            entityId, 
                                            (ulong)attribsNextEvents[nextEventIndex, 4].lValue,    // p1
                                            (ulong)attribsNextEvents[nextEventIndex, 7].lValue,    // p2
                                            (ulong)attribsNextEvents[nextEventIndex,10].lValue,    // winner
                                            (ulong)attribsNextEvents[nextEventIndex,11].lValue,    // loser
                                            (ulong)attribsNextEvents[nextEventIndex, 0].lValue,    // event entity
                                            Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED, 
                                            null);
                                
                            }
                            else
                            {
                                // Simple update
                                hrUpdate = Dataset.UpdateId(source, 
                                        titleId, 
                                        0, 
                                        0, 
                                        datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                                        Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_ENTRANTS, 
                                        (ulong)attribsNextEvents[nextEventIndex, 0].lValue, 
                                        attribs);
                               
                                if (HResult.Failed(hrUpdate))
                                {
                                      Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression method failed for competition " + entityId + ". Could not update Event in next round. Failed with hr = " + hrUpdate);
                                      hr = hrUpdate;
                                      cUpdateErrors++;
                                      // Continue to attempt to update the remaining Events
                                }    
                            }   
                            
                            cUpdated++;
                        }
                    }
                }
    
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "One or more failures while executing Progression method for competition " + entityId + ". Scheduling retry. hr = " + hr);               
    
                    goto lbError;
                }
    
                
                //
                // Update Current Round + Start Time in the competitions table to flag that progression is finished. 
                //
                round++;
                
                if (null == fUpdate)
                {
                    status = Comp.XONLINE_COMP_STATUS_COMPLETE;
    
                    hr = UpdateEntrantStatus(source, titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_STATUS_COMPLETE);
    
                    if (HResult.Failed(hr))
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression Update method failed for Competition " + entityId + " with hr = " + hr);
                        goto lbError;
                    }                    
                }
    
lbUpdateTimes:
                attribs = new QueryAttribute[5];
                
                for (i = 0; i < attribs.Length; i++)    
                {
                    attribs[i] = new QueryAttribute(); 
                }
                
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_ROUNDS;
                attribs[0].lValue = rounds;            
                attribs[1].Id = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND;
                attribs[1].lValue = round;   
                attribs[2].Id = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_START;
                attribs[2].lValue = nextRoundStart.ToFileTimeUtc();
                attribs[3].Id = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_END;
                attribs[3].lValue = nextRoundEnd.ToFileTimeUtc(); 
                attribs[4].Id = Comp.XONLINE_COMP_ATTR_STATUS;
                attribs[4].lValue = status;
    
                hr = Dataset.UpdateId(source, titleId, userId, teamId, datasetId, Comp.XONLINE_COMP_ELIMINATION_UPDATEID_ROUND, entityId, attribs);
    
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Progression Update method failed for Competition " + entityId + " with hr = " + hr);
    
                    goto lbError;
                }
    
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Progressing Single Elimination Competition " + entityId);            


            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                int     cleanupJob = 0;
                
                if (HResult.Succeeded(hr))
                {
                    switch (status)
                    {
                    case Comp.XONLINE_COMP_STATUS_PRE_INIT:
                        //
                        // Competition was already deleted. Nothing to do
                        //
                        break;
                    case Comp.XONLINE_COMP_STATUS_ACTIVE:
                        //
                        // Add progression job for next round. AddRoundJobs adds its own logline. 
                        //
                        hr = AddRoundJobs(titleId, userId, teamId, datasetId, entityId, reminderMin, nextRoundStart, nextRoundEnd);                    
                        break;
                    case Comp.XONLINE_COMP_STATUS_COMPLETE:
                    case Comp.XONLINE_COMP_STATUS_CANCELED:
                        //
                        // Add cleanup job
                        //
                        hr = SafeScheduleJob(titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_ACTION_CLEANUP, 1, 5 * 60, CleanupTimeFromCleanupDays(cleanupDays), 0, out cleanupJob);
                        break;
                    }
                }
                
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "PRG", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"),
                              status.ToString("x"),
                              currentRoundEnd.ToString(),
                              nextRoundStart.ToString(),
                              nextRoundEnd.ToString(),
                              round.ToString(),
                              QueryHealth.ServiceDown.ToString(),
                              curResults.ToString(),
                              nextResults.ToString(),
                              cAutoProgress.ToString("x"),
                              cAutoProgressErrors.ToString("x"),
                              cUpdated.ToString("x"),
                              cUpdateErrors.ToString("x"),                              
                              cleanupJob.ToString()
                        }));       
                
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "***** PROGRESSION COMPLETE ********");


                counters.EndRequest(HResult.Failed(hr));
            }

lbError:                
            return hr;
        }


        private HResult ActionFinalize(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            FinalizeCounters counters = new FinalizeCounters(titleId);

            // Scheduler invoked competition closing action. 
            
            // Service only method. Source.Server flag must be set
            if (((uint)source & ((uint)Source.Server)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }
            
            // Nothing to do for Single Elimination Competitions
            Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Finalizing Single Elimination Competition " + entityId);            
            
            return HResult.S_OK;
        }


        private HResult ActionDelete(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            DeleteCounters counters = new DeleteCounters(titleId);

            HResult        hr = HResult.XONLINE_E_COMP_ERROR; 

            try
            {
                //
                // Scheduler invoked competition cleanup action. 
                //
                
                // Service only method. Source.Server flag must be set
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
    
                // TODO: Cleanup leaderboards. 
                
                // Delete the competition
                hr = Dataset.RemoveId(source, titleId, userId, teamId, datasetId, entityId);
    
                if (hr == HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    hr = HResult.S_OK;
                }
                
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "ActionDelete method failed for Competition " + entityId + " with hr = " + hr);
                }
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "ActionDelete Compete for Single Elimination Competition " + entityId );            

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "DEL", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              entityId.ToString("x16")
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
                
        
            return hr;
        }

    
        private HResult ActionReminders(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            RemindersCounters counters = new RemindersCounters(titleId);

            HResult                  hr = HResult.XONLINE_E_COMP_ERROR;
            uint                  results = 0;
            
            uint    round = 0;
            bool    isTeam = false;
            uint    status = 0;
            DateTime roundStart = DateTime.MinValue;
            DateTime reminderTime = DateTime.MinValue;
            ArrayList puids = new ArrayList();    
            uint reminderMin = 0;    
            string  compName;
                
            
            
          
            try
            {
                
                // Service only method. Source.Server flag must be set
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
    
    
                //
                // Select the Competition configuration data for Checkin, Forfeit, Ejection, and Reminders
                //
                FindCheckinDataResults[] checkinData;
                hr = FindCheckinData.Execute(source, titleId, datasetId, new ulong[] { entityId }, out checkinData);
                
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Failed to find competition " + entityId + " for reminders. hr = " + hr);
                    
                    hr = HResult.S_FALSE;
                    goto lbError;
                }
                
                round = (uint)checkinData[0].CurrentRound;
                reminderMin = (uint)checkinData[0].ReminderMin; 
                isTeam = 0 != checkinData[0].IsTeamComp;
                status = (uint)checkinData[0].Status;
                compName = checkinData[0].CompName;
                
                roundStart = DateTime.FromFileTimeUtc(checkinData[0].CurrentRoundStart);
                reminderTime = roundStart.AddMinutes(-reminderMin);
    
                // Don't bother sending reminders for inactive competitions          
                if (Comp.XONLINE_COMP_STATUS_ACTIVE != status)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Not sending reminders for competition " + entityId + " because it is not active. Status = " + status);            
    
                    hr = HResult.S_FALSE;                
                    goto lbError;                
                }
    
    
                // Make sure the reminders are relevant 
                if ((reminderTime > QueryUtil.UtcNow) || (roundStart < QueryUtil.UtcNow))
                {
                    // Sending reminders outside of the reminder window. Abort
                    hr = HResult.S_FALSE;                
                    goto lbError;                
                }


                // Make sure this is not a team competition because we don't do list expansion
                if (isTeam)
                {
                    hr = HResult.S_FALSE;                
                    goto lbError;                
                }
    
    
                //
                // Select all the Events out of the Event table for the current round. 
                //
                SelectRound selectRound = new SelectRound();
                SelectRoundResults[] events;
                
                selectRound.CompId = (long)entityId;
                selectRound.Round = round;
                
                hr = selectRound.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, out events);
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Reminder method failed for competition " + entityId + ". Could not select Events. hr = " + hr);
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_34, "Reminders method failed for competition " + entityId + ". Could not select Events. hr = " + hr);
                    goto lbError;
                }            
    
                if (null == events)
                {
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_35, "Reminders method failed for competition " + entityId + ". No Events to send reminders for!");            
    
                    //review: retry?
                    hr = HResult.S_FALSE;
                    goto lbError;
                }            
    
                // Adjust reminderTime a bit more to be able to test whether a player has checked in recently or not
                reminderTime = reminderTime.AddMinutes(-reminderMin);

                
                // 
                // Create the reminder message
                //
                CUserMessage    reminder = new CUserMessage( 
                        0,              // qwSenderPUID - Messages from Live come from PUID zero
                        entityId,       // qwSenderContext, 
                        MsgDefs.XONLINE_MSG_FLAG_COMP_CONTEXT  ,   // flags
                        titleId,        // dwSenderTitleID
                        (ushort)reminderMin,    // expireMinutes
                        MsgDefs.XONLINE_MSG_TYPE_COMP_REMINDER,
                        "LIVE" );  // From

                reminder.AddProperty(MsgDefs.XONLINE_MSG_PROP_COMP_NAME, compName);
                reminder.AddProperty(MsgDefs.XONLINE_MSG_PROP_COMP_START, roundStart);
                reminder.AddProperty(MsgDefs.XONLINE_MSG_PROP_COMP_ROUND, (ushort)round);
               
                for( int i = 0; i < events.Length; i++ ) {
                    // Are there two entrants, and no winner listed
                    if ((events[i].Player1 != 0) && (events[i].Player2 != 0) && (events[i].Winner == 0))
                    {
                        DateTime p1Checkin = DateTime.FromFileTimeUtc(events[i].P1Checkin);
                        DateTime p2Checkin = DateTime.FromFileTimeUtc(events[i].P2Checkin);
                        
                        if (p1Checkin < reminderTime) // If P1 hasn't checked in yet, send him a reminder
                        {
                            puids.Add((ulong)events[i].Player1);
                        }
                        if (p2Checkin < reminderTime) // If P2 hasn't checked in yet, send him a reminder
                        {
                            puids.Add((ulong)events[i].Player2);
                        }
                    }
                }

                // 
                // Send the reminder message to all recipients. 
                //
                HResult hrSend = reminder.SendToList( puids );
                if( hrSend == HResult.S_FALSE ) {
                    // check recipient results to find first failure
                    SendMessageReply reply = reminder.GetResponse();

                    // binary search to first failure
                    int goodFront = -1;
                    int badBack = puids.Count;
                    while( goodFront < badBack - 1 ) {
                        int i = (goodFront + badBack) / 2;
                        RecipientResult result = reply.recipients[i];
                        if( result != null && HResult.Succeeded( result.dwMessageID ) )
                        {
                            goodFront = i;
                        }
                        else
                        {
                            badBack = i;
                        }
                    }
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Reminder method sent " + badBack + " reminders of " + puids.Count + " for competition " + entityId + ".");            
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_36, "Reminder method sent " + badBack + " reminders of " + puids.Count + " for competition " + entityId + ".");                            
                } else if( HResult.Failed( hrSend ) ) {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Reminder method sent 0 reminders of " + puids.Count + " for competition " + entityId + ".");            
                    Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_36, "Reminder method sent 0 reminders of " + puids.Count + " for competition " + entityId + ".");                            
                } // else success
    
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "RMR", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"), 
                              status.ToString("x"),
                              round.ToString("x"),
                              roundStart.ToString(),
                              reminderTime.ToString(),
                              results.ToString("x"),
                              puids.Count.ToString("x")
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }

lbError:             
            return hr;
        }
        
        public HResult ActionAdvanceTime(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, QueryAttribute[] attribs, Hashtable ctx)
        {
            AdvanceTimeCounters counters = new AdvanceTimeCounters(titleId);

            long adj = 0;
            int  i;
            CronJobWire[] jobs;
            int jobId;
            HResult hr = HResult.XONLINE_E_COMP_ERROR;
            
            try
            {
                if (Config.GetBoolSetting(Setting.compPlugins_allowTimeAdjustment) == false)
                {
                    throw new PluginException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.QUERY_PLUGIN_CONFIG_ERROR_1, 
                        "AdjustTime action called when disabled in the config file!!   If in production, bad client?");
                }    
                                        
                
                if (attribs.Length != 1 || attribs[0].Id != Comp.XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "Unexpected list of attributes!  Expected 1 attribute w/ id XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME, instead got " + attribs.Length + " attributes.");
                    
                    hr = HResult.E_INVALIDARG;
                    goto end;
                }    
                
                adj = attribs[0].lValue;
                if (adj == 0)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "Invalid time adjustment value of " + adj);
                    
                    hr = HResult.E_INVALIDARG;
                    goto end;
                }    
                
                // adjustment is conceptualized as "moving forward in time"
                // in reality we simulate the same thing by setting all time fields back by the adjustment value
                // also, since times are stored in filetime, convert adjustment seconds to 100-nanosecond ticks
                //
                attribs[0].lValue *= -10000000;
                 
                // adjust time in comps dataset
                //
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Adjusting time on comps dataset for comp id " + entityId.ToString("x") + "..");
                hr = Dataset.ExecCustom(source, 
                                    titleId, 
                                    userId, 
                                    teamId, 
                                    datasetId, 
                                    Comp.XONLINE_COMP_ELIMINATION_CUSTOM_ADVANCE_TIME, 
                                    entityId, 
                                    attribs);
                                    
                if (HResult.Failed(hr))
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA_3, 
                        "AdjustTime action failed attempting to update comps dataset!  Competition is now likely in a bad sate..  hr = " + hr);
                }
                
                 
                // adjust time in entrants dataset
                //
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Adjusting time on entrants dataset for comp id " + entityId.ToString("x") + "..");
                QueryAttribute[] compAttribs = new QueryAttribute[2];
                
                compAttribs[0] = new QueryAttribute();
                compAttribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                compAttribs[0].lValue = (long)entityId;
                
                compAttribs[1] = new QueryAttribute();
                compAttribs[1].Id = Comp.XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME;
                compAttribs[1].lValue = adj * -10000000;
                
                hr = Dataset.ExecCustom(source, 
                                    titleId, 
                                    userId, 
                                    teamId, 
                                    datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, 
                                    Comp.XONLINE_COMP_ELIMINATION_CUSTOM_ADVANCE_TIME, 
                                    0, 
                                    compAttribs);
                
                if (HResult.Failed(hr))
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA_4, 
                        "AdjustTime action failed attempting to update comps dataset!  Competition is now likely in a bad sate..  hr = " + hr);
                }
                
                    
                // adjust time in events dataset
                //
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Adjusting time on events dataset for comp id " + entityId.ToString("x") + "..");
                hr = Dataset.ExecCustom(source, 
                                    titleId, 
                                    userId, 
                                    teamId, 
                                    datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, 
                                    Comp.XONLINE_COMP_ELIMINATION_CUSTOM_ADVANCE_TIME, 
                                    0, 
                                    compAttribs);
                
                if (HResult.Failed(hr))
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA_5, 
                        "AdjustTime action failed attempting to update comps dataset!  Competition is now likely in a bad sate..  hr = " + hr);
                }
                                    
                
                // adjust job times
                //
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Looking for competition jobs..");    
                
                hr = CronUtil.FindJobs("Comp Select callback: compId: 0x" + entityId.ToString("x") + " %", out jobs);
                if (HResult.Failed(hr)) 
                 {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA_6, 
                        "AdjustTime action failed searching for jobs!  Competition is now likely in a bad sate..  hr = " + hr);
                }
                
                
                for (i = 0; i < jobs.Length; i++)
                {
                    if (jobs[i].frontDoor != "")
                    {
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "Job '" + jobs[i].name + "' is already being executed by " + jobs[i].frontDoor + ".  Skipping.");
                        continue;
                    }
                        
                    
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Adjusting job '" + jobs[i].name + "'-- old time: " + jobs[i].nextExec + "  new time: " + jobs[i].nextExec.AddSeconds(-adj));
                    
                    hr = CronUtil.RemoveJob(jobs[i].jobId, titleId);
                    if (HResult.Failed(hr))
                    {
                        if (hr == HResult.XONLINE_E_INVALID_REQUEST)
                        {
                            Xom.Trace(XomAreaName.Elimination, LogLevel.L_WARNING, "Job '" + jobs[i].name + "' already removed! Skipping to the next job..");
                            continue;
                        }
                    
                        throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.COMPS_CONFIG_10, 
                            "AdjustTime action failed to remove jobid " + jobs[i].jobId + "!  Competition is now likely in a bad sate..  hr = " + hr.ToString());
                    }
                    
                    hr = CronUtil.AddJob(jobs[i].name,
                                         jobs[i].titleId,
                                         jobs[i].assembly,
                                         jobs[i].className,
                                         jobs[i].execCount, 
                                         jobs[i].timeoutSecs,
                                         jobs[i].nextExec.AddSeconds(-adj),
                                         jobs[i].intervalSecs,
                                         jobs[i].argsXml,
                                         out jobId);
                    
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Re-added job as jobId " + jobId);
                }
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_LOW, "Time adjustment complete!  CompId 0x " + entityId.ToString("x") + " was adjusted by " + adj + " s.");
                
                hr = HResult.S_OK;
            
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "ADJ", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"), 
                              adj.ToString()
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
            
end:
            return hr;            
        
        }
        
        
        
        
        
        
        
        
        //
        // Plugin Interface Methods
        //
        public HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, Hashtable ctx)
        {
            AddCompetitionCounters counters = new AddCompetitionCounters(titleId);
            
            // Validate parameters
            DateTime regOpen      = QueryUtil.UtcNow;
            DateTime regClose     = QueryUtil.UtcNow;
            DateTime compStart    = QueryUtil.UtcNow;
            TimeSpan roundLength  = TimeSpan.MinValue;
            uint     cleanupDays  = Comp.XONLINE_COMP_DEFAULT_CLEANUP_DAYS;
            uint     frequency    = 0;
            uint     interval     = 0;
            uint     dayMask      = 0;
            uint     rounds       = 0;               // Total number of rounds in the competition calculated from number of slots
            uint     reminderMin  = 0;
            DateTime roundStart   = QueryUtil.UtcNow;
            DateTime roundEnd     = QueryUtil.UtcNow;
            ulong    publicSlots  = 0;
            ulong    privateSlots  = 0;
            ulong    minSlots     = 0;
            ulong    isTeamComp   = 0;
            ulong    teamSize     = 0;
            int      nonce = (new Random()).Next();
            HResult hr = HResult.S_OK;
            
            try
            {
                ctx["nonce"] = nonce;
                
                foreach (QueryAttribute attrib in attribs)
                {
                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_REG_OPEN:
                        regOpen = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_REG_CLOSE:
                        regClose = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_COMP_START:
                        compStart = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
    
                    case Comp.XONLINE_COMP_ATTR_COMP_CLEANUP:
                        cleanupDays = (uint)attrib.lValue;
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY:
                        frequency = (uint)attrib.lValue;
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL:
                        interval = (uint)attrib.lValue;
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK:
                        dayMask = (uint)attrib.lValue;
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_ROUND_ONE_START:
                        roundStart = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_ROUND_ONE_END:
                        roundEnd = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS:
                        publicSlots = (ulong)attrib.lValue;
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS:
                        privateSlots = (ulong)attrib.lValue;
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_MIN_SLOTS:
                        minSlots = (ulong)attrib.lValue;
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP:
                        isTeamComp = (ulong)attrib.lValue;
                        break;
                
                    case Comp.XONLINE_COMP_ATTR_TEAM_SIZE:
                        teamSize = (ulong)attrib.lValue;
                        break;
    
                    case Comp.XONLINE_COMP_ATTR_REMINDER_MIN:
                        reminderMin = (uint)attrib.lValue;
                        break;
                        
                    // The following attributes must be set to zero if they are included at all in the Add call
                    case Comp.XONLINE_COMP_ATTR_CURRENT_ROUND:
                    case Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_START:
                    case Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_END:
                    case Comp.XONLINE_COMP_ATTR_PUBLIC_ENTRANTS:
                    case Comp.XONLINE_COMP_ATTR_PRIVATE_ENTRANTS:
                    case Comp.XONLINE_COMP_ATTR_STATUS:
                        XRLUtil.VerifyParam((ulong)attrib.lValue == 0,                       "Service controlled attribute must be 0!\r\n"                + QueryUtil.DumpAttribs(attribs));
                        break;
                    }
                }
    
                rounds = EliminationHelper.RoundsFromEntrants((uint)(publicSlots + privateSlots));
    
                roundLength = CompHelper.IntervalToTimeSpan(roundStart, frequency, interval, (int)Comp.XONLINE_COMP_DAY_MASK_ALL); 
    
                XRLUtil.VerifyParam(regClose > QueryUtil.UtcNow,                           "Specified registration close occurs in the past!\r\n"                  + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(regClose > regOpen,                                    "Specified registration close occurs before regOpen!\r\n"               + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(compStart >= regClose,                                 "Specified competition start time before registration close!\r\n"       + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(cleanupDays <= Comp.XONLINE_COMP_MAX_CLEANUP_DAYS,     "Specified cleanup days is more than the allowed max!\r\n"              + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(cleanupDays >=  Comp.XONLINE_COMP_MIN_CLEANUP_DAYS,    "Specified cleanup days is less than the allowed min!\r\n"              + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(roundStart >= compStart,                               "Specified first round start time before competition start!\r\n"       + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(roundStart.AddMinutes(-reminderMin) >= compStart,      "Specified first round start time does not leave sufficient room for reminders after competition start!\r\n"       + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(frequency <= Comp.XONLINE_COMP_MAX_FREQUENCY,          "Specified frequency is greater than max allowed frequency\r\n"         + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(interval <= Comp.XONLINE_COMP_INTERVAL_MAX,            "Specified interval is greater than max allowed interval\r\n"           + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam((dayMask &~ Comp.XONLINE_COMP_DAY_MASK_ALL) == 0,      "Specified day mask uses undefined bits\r\n"                            + QueryUtil.DumpAttribs(attribs));            
                XRLUtil.VerifyParam(roundStart + roundLength > roundEnd,                   "Specified competition round end may run into the next scheduled round!\r\n" + QueryUtil.DumpAttribs(attribs));
    
                XRLUtil.VerifyParam(minSlots >= Comp.XONLINE_COMP_ELIMINATION_MIN_SLOTS,                    "Specified miniumum slots is less than the allowed minimum!\r\n"        + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(privateSlots + publicSlots <= Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS,   "Specified max # of slots is more than the max allowed!\r\n"            + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(minSlots <= privateSlots + publicSlots,                                  "Specified miniumum slots is more than the max slots!\r\n"              + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(isTeamComp == 0 || isTeamComp == 1,                    "IS_TEAM_COMP must be 0 or 1!\r\n"                                      + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(teamId == 0 || (teamId != 0 && isTeamComp == 1),       "Team should only be specified for team competitions!\r\n"              + QueryUtil.DumpAttribs(attribs));
   
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Adding Single Elimination Competition by user " + userId);            

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "CBA", 
                              hr.ToString(), 
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              regOpen.ToString(),
                              regClose.ToString(),
                              compStart.ToString(),
                              cleanupDays.ToString(),
                              rounds.ToString("x"),
                              roundLength.ToString(),
                              frequency.ToString("x"),
                              interval.ToString("x"),
                              dayMask.ToString("x"),
                              roundStart.ToString(),
                              roundEnd.ToString(),
                              publicSlots.ToString("x"),
                              privateSlots.ToString("x"),
                              minSlots.ToString("x"),
                              isTeamComp.ToString("x"),
                              teamSize.ToString("x"),
                              reminderMin.ToString("x"),
                              nonce.ToString("x")
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
                

            return HResult.S_OK;
        }
        

        public HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Single Elimination Competition " + entityId + " added by user " + userId);            
            TitleLog.Write(XOService.Query, titleId, XomLogLevel.Info, "Single Elimination Competition " + entityId + " added by user " + userId);
            

            HResult            hr = HResult.S_OK;
            DateTime        regClose        = QueryUtil.UtcNow;
            int nonce = 0;
            
            try
            {
                nonce = (int)ctx["nonce"];
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_37, e, "Failed to parse nonce in ctx object.");
                // this shouldn't fail the proceedure..
                nonce = -1;
            }                

            try
            {
            
                //
                // Get the params we need from the attribs array
                //
                foreach (QueryAttribute attrib in attribs)
                {
                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_REG_CLOSE:
                        regClose = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
                    }
                }
    
    
                //
                // Add Cron job to perform slotting task
                //
                CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, entityId, Comp.XONLINE_COMP_ACTION_SLOTTING, 1, 5 * 60, regClose.AddMinutes(Comp.XONLINE_COMP_MIN_JOB_DELAY), 0);
                

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "CAA", 
                              hr.ToString(), 
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"),
                              nonce.ToString("x")
                        }));       

            }
                


            return hr;
        }
        
        public HResult BeforeUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            HResult hr = HResult.S_OK;
            
            try
            {
                if ((procIndex >= Comp.XONLINE_COMP_ELIMINATION_UPDATEID_MIN) && (procIndex <= Comp.XONLINE_COMP_ELIMINATION_UPDATEID_MAX))   
                {
                    // Service only method. Either Source.Server or Source.Plugin flags must be set
                    if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
                    {
                        hr = HResult.XONLINE_E_COMP_ACCESS_DENIED;
                        goto end;
                    }
    
                    switch (procIndex)
                    {                
                    case Comp.XONLINE_COMP_ELIMINATION_UPDATEID_ROUND:
                        // Update current round. 
                        // Calculates new round start time
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Single Elimination Competition " + entityId + " Withdrawn by " + userId);            
                        break;
    
                    case Comp.XONLINE_COMP_ELIMINATION_UPDATEID_STATUS:
                        // Set or clear cancelled bit
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Single Elimination Competition " + entityId + " Cancelled by " + userId);            
                        break;
    
                    default:
                        Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Updating Single Elimination Competition " + entityId + " via procIndex " + procIndex);            
                        break;
                    }
                }
                else
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Updating Single Elimination Competition " + entityId + " via procIndex " + procIndex);            
                }

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "CUD", 
                              hr.ToString(), 
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"),
                              procIndex.ToString("x")
                        }));       

            }
            
end:
            return hr;
                
        }
        
        public void AfterUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Single Elimination Competition " + entityId + " updated");            
        }
        
        public HResult BeforeRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            HResult     hr = HResult.S_OK;
            HResult     hrRemove;
            
            try
            {
                // Service only method. Either Source.Server or Source.Plugin flags must be set
                if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
    
    
                QueryAttribute[] attribs = new QueryAttribute[1];
                
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Cleanup Single Elimination Competition " + entityId + " initiated");            
    
                // Setup datastructures for callbacks
                attribs[0] = new QueryAttribute();
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                attribs[0].lValue = (long)entityId;
    
                // Remove all entrants for this competition
                hrRemove = Dataset.Remove(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_DATASET_OFFSET, Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_REMOVE_ALL, attribs);
    
                if (HResult.Failed(hrRemove) && hrRemove != HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Entrants Remove All method failed for competition " + entityId);            
                    hr = hrRemove;
                    // Continue trying to cleanup
                }
    
                // Remove all events for this competition
                hrRemove = Dataset.Remove(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ELIMINATION_EVENTS_DATASET_OFFSET, Comp.XONLINE_COMP_ELIMINATION_EVENTS_REMOVE_ALL, attribs);
    
                if (HResult.Failed(hrRemove) && hrRemove != HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "Events Remove All method failed for competition " + entityId);
                    hr = hrRemove;
                }

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|", new string[] {
                              "CRM", 
                              hr.ToString(), 
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              entityId.ToString("x16")
                        }));       

            }

            return hr;
        }
        
        public void AfterRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.Elimination, LogLevel.L_INFO, "Single Elimination Competition " + entityId + " deleted");            
        }
        

        public HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, Hashtable ctx)
        {
            HResult        hr = HResult.XONLINE_E_QUERY_INVALID_ACTION;
            
            switch (actionId)
            {      
            // Client operations
            case Comp.XONLINE_COMP_ACTION_JOIN:
                hr = ActionJoin(source, titleId, userId, teamId, datasetId, entityId, attribs, false);
                break;

            case Comp.XONLINE_COMP_ACTION_JOIN_PRIVATE:
                hr = ActionJoin(source, titleId, userId, teamId, datasetId, entityId, attribs, true);
                break;

            case Comp.XONLINE_COMP_ACTION_WITHDRAW:
                hr = ActionWithdraw(source, titleId, userId, teamId, datasetId, entityId);
                break;

            case Comp.XONLINE_COMP_ACTION_CHECKIN:
                hr = ActionCheckin(source, titleId, userId, teamId, datasetId, entityId, attribs);
                break;

            case Comp.XONLINE_COMP_ACTION_SUBMIT_RESULTS:
                hr = ActionSubmitResults(source, titleId, userId, teamId, datasetId, entityId, attribs, ctx);
                break;

            case Comp.XONLINE_COMP_ACTION_FORFEIT:
                hr = ActionForfeit(source, titleId, userId, teamId, datasetId, entityId, attribs);
                break;

            case Comp.XONLINE_COMP_ACTION_EJECT:
                hr = ActionEject(source, titleId, userId, teamId, datasetId, entityId, attribs);
                break;
                
            case Comp.XONLINE_COMP_ACTION_CANCEL:
                hr = ActionCancel(source, titleId, userId, teamId, datasetId, entityId);
                break;


            // Service operations (initiated by Cron service)
            case Comp.XONLINE_COMP_ACTION_SLOTTING:
                hr = ActionSlotting(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;

            case Comp.XONLINE_COMP_ACTION_PROGRESSION:
                hr = ActionProgression(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;

            case Comp.XONLINE_COMP_ACTION_FINALIZE:
                hr = ActionFinalize(source, titleId, userId, teamId, datasetId, entityId);
                break;              

            case Comp.XONLINE_COMP_ACTION_CLEANUP:
                hr = ActionDelete(source, titleId, userId, teamId, datasetId, entityId);
                break;              

            case Comp.XONLINE_COMP_ACTION_REMINDERS:
                hr = ActionReminders(source, titleId, userId, teamId, datasetId, entityId);
                break;              
            
            case Comp.XONLINE_COMP_ACTION_DEBUG_ADVANCE_TIME:
                hr = ActionAdvanceTime(source, titleId, userId, teamId, datasetId, entityId, attribs, ctx);
                break;

            default:
                Xom.Trace(XomAreaName.Elimination, LogLevel.L_ERROR, "unknown actionId: " + actionId);            
                break;
            }
            
            return hr;
        }


        public HResult BeforeFind(Source source, uint titleId, uint datasetId, uint procIndex, ulong [] entityIds, Hashtable ctx)
        {
            HResult    hr = HResult.S_OK;
            
            // Service procs are only allowed to be called internally, not directly from the client
            if ((procIndex > 0x10000) && (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0))
            {
                hr = HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }

            return hr;
        }

        
        public HResult BeforeSearch(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            HResult    hr = HResult.S_OK;

            // Service procs are only allowed to be called internally, not directly from the client
            if ((procIndex > 0x10000) && (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0))
            {
                hr = HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }

            return hr;
        }        
    };


    //
    // Query Service Plugin definition for Single Elimination Competitions Entrants Table
    //
    public class Entrants : IQueryAdd, IQueryUpdate, IQueryUpdateId, IQueryRemove, IQueryRemoveId, IQueryFindFromIds, IQuerySearch
    {
        //
        // Plugin Interface Methods
        //
        public HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, Hashtable ctx)
        {
            ulong    compId        = 0;
            ulong    puid          = 0;
            long     privateSlot   = -1;
            
            // Service only method. Either Source.Server or Source.Plugin flags must be set
            if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }           
            
            // Validate parameters
            foreach(QueryAttribute attrib in attribs)
            {
                switch (attrib.Id)
                {
                case Comp.XONLINE_COMP_ATTR_ID:
                    compId = (ulong)attrib.lValue;
                    break;

                case Comp.XONLINE_COMP_ATTR_ENTRANT_PUID:
                    puid = (ulong)attrib.lValue;
                    break;

                case Comp.XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT:
                    privateSlot = attrib.lValue;
                    break;
                    
                case Comp.XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND:
                case Comp.XONLINE_COMP_ATTR_ENTRANT_STATUS:
                    XRLUtil.VerifyParam((ulong)attrib.lValue == 0,               "Service controlled attribute must be 0!\r\n"  + QueryUtil.DumpAttribs(attribs));
                    break;
                };
            }   

            XRLUtil.VerifyParam(privateSlot == 0 || privateSlot == 1,  "ENTRANT_PRIVATE_SLOT must be 0 or 1!\r\n");
            XRLUtil.VerifyParam(compId != 0,         "Competition Entity ID entered is 0!\r\n"      + QueryUtil.DumpAttribs(attribs));
            XRLUtil.VerifyParam(puid != 0,           "PUID entered is 0!\r\n"                       + QueryUtil.DumpAttribs(attribs));
            
            Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Adding Entrant " + puid + " to Single Elimination Competition " + compId);            
            return HResult.S_OK;
        }
        
        public HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Added Entrant " + QueryUtil.GetAttributeValueInt64(attribs, Comp.XONLINE_COMP_ATTR_ENTRANT_PUID) + 
                                           " to Single Elimination Competition " + QueryUtil.GetAttributeValueInt64(attribs, Comp.XONLINE_COMP_ATTR_ID));            

            return HResult.S_OK;
        }
        
        public HResult BeforeUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            // Service only method. Either Source.Server or Source.Plugin flags must be set
            if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }           

            // Validate parameters
            if ((procIndex < Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_MIN) || (procIndex > Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_MAX))   
            {
                return HResult.E_INVALIDARG;
            }

            switch (procIndex)
            {                
            case Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_RESULTS:
                Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Single Elimination Competition Entrants updated results");
                break;

            case Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_UPDATE_STATUS:
                Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Single Elimination Competition Entrant updated status");
                break;

            default:
                Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Updating Entrant(s) via procIndex" + procIndex);            
                break;
            }

            return HResult.S_OK;
        }
        
        public void AfterUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Updated Entrant(s) via procIndex" + procIndex);            
        }
        
        public HResult BeforeUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Updated Entrant via procIndex" + procIndex + ". Unsupported operation! Returning Access Denied");            

            return HResult.XONLINE_E_COMP_ACCESS_DENIED;
        }
        
        public void AfterUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Updated Entrant via procIndex" + procIndex + ". Unsupported operation! Returning Access Denied");            
        }
        
        public HResult BeforeRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            ulong       compId = 0;
            
            // Service only method. Either Source.Server or Source.Plugin flags must be set
            if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }
                        
            // Validate parameters
            if ((procIndex < Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_REMOVE_MIN) || (procIndex > Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_REMOVE_MAX))   
            {
                return HResult.E_INVALIDARG;
            }

            foreach(QueryAttribute attrib in attribs)
            {
                switch (attrib.Id)
                {
                case Comp.XONLINE_COMP_ATTR_ID:     // Competition ID to delete players from
                    compId = (uint)attrib.lValue;
                    break;
                };
            }
            
            switch (procIndex)
            {
            case Comp.XONLINE_COMP_ELIMINATION_ENTRANTS_REMOVE_ALL:
                XRLUtil.VerifyParam(compId != 0,                           "Competition Entity ID entered is 0!\r\n"    + QueryUtil.DumpAttribs(attribs));
                break;                      
            };

            Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Removing Entrant(s) via procIndex" + procIndex + " from Single Elimination Competition " + compId);            

            return HResult.S_OK;
        }
        
        public void AfterRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            Trace.WriteLine("[EliminationEntrants - AfterRemove] Removed Entrant(s) via procIndex" + procIndex + " removed from Single Elimination Competition ");
        }
        
        public HResult BeforeRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            ulong       compId = 0;
            
            // Service only method. Either Source.Server or Source.Plugin flags must be set
            if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }
                        
            Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Removing user " + userId + " from Single Elimination Competition " + compId);            

            return HResult.S_OK;
        }
        
        public void AfterRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEntrants, LogLevel.L_INFO, "Entrant " + userId + " removed from Single Elimination Competition ");            
        }


        public HResult BeforeFind(Source source, uint titleId, uint datasetId, uint procIndex, ulong [] entityIds, Hashtable ctx)
        {
            HResult hr = HResult.S_OK;
            
            // Service procs are only allowed to be called internally, not directly from the client
            if ((procIndex > 0x10000) && (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0))
            {
                hr = HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }

            return hr;
        }

        
        public HResult BeforeSearch(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            HResult    hr = HResult.S_OK;
            
            // Service procs are only allowed to be called internally, not directly from the client
            if ((procIndex > 0x10000) && (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0))
            {
                hr = HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }

            return hr;
        }        
    }            


    //
    // Query Service Plugin definition for Single Elimination Competitions Events Table
    //
    public class Events : IQueryAdd, IQueryUpdate, IQueryUpdateId, IQueryRemove, IQueryRemoveId, IQueryFindFromIds, IQuerySearch
    {
        //
        // Plugin Interface Methods
        //
        public HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, Hashtable ctx)
        {
            ulong    compId         = 0;
            ulong    eventId        = 0;
            ulong    round          = 0;
            
            // Service only method. Either Source.Server or Source.Plugin flags must be set
            if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }
            
            
            // Validate parameters
            foreach(QueryAttribute attrib in attribs)
            {
                switch (attrib.Id)
                {
                case Comp.XONLINE_COMP_ATTR_ID:
                    compId = (ulong)attrib.lValue;
                    break;

                case Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID:
                    eventId = (ulong)attrib.lValue;
                    break;

                case Comp.XONLINE_COMP_ATTR_EVENT_ROUND:
                    round = (ulong)attrib.lValue;
                    break;

                case Comp.XONLINE_COMP_ATTR_EVENT_P1_CHECKIN:                
                case Comp.XONLINE_COMP_ATTR_EVENT_P1_TRUST:
                case Comp.XONLINE_COMP_ATTR_EVENT_P2_CHECKIN:
                case Comp.XONLINE_COMP_ATTR_EVENT_P2_TRUST:
                case Comp.XONLINE_COMP_ATTR_EVENT_LOSER:
                    XRLUtil.VerifyParam((ulong)attrib.lValue == 0,               "Service controlled attribute must be 0!\r\n"  + QueryUtil.DumpAttribs(attribs));
                    break;

                };
            }

            XRLUtil.VerifyParam(compId != 0,                            "Competition Entity ID entered is 0!\r\n"      + QueryUtil.DumpAttribs(attribs));
            //XRLUtil.VerifyParam(eventId != 0,                           "Event ID entered is 0!\r\n"                   + QueryUtil.DumpAttribs(attribs));
            //XRLUtil.VerifyParam(round != 0,                             "Round value entered is 0!\r\n"                + QueryUtil.DumpAttribs(attribs));

            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Adding Event to Single Elimination Competition " + compId);            
            return HResult.S_OK;
        }
        
        public HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Added Event " + entityId + " to Single Elimination Competition");            

            return HResult.S_OK;
        }
        
        public HResult BeforeUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Updated Event(s) via procIndex " + procIndex + ". Unsupported operation! Returning Access Denied");            

            return HResult.XONLINE_E_COMP_ACCESS_DENIED;                        
        }
        
        public void AfterUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Updated Event(s) via procIndex " + procIndex + ". Unsupported operation! Returning Access Denied");            
        }
        
        public HResult BeforeUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            // Validate parameters
            if ((procIndex < Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_MIN) || (procIndex > Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_MAX))   
            {
                return HResult.E_INVALIDARG;
            }

            // Service only method. Either Source.Server or Source.Plugin flags must be set
            if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;            
            }
    
            switch (procIndex)
            {                
            case Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_CHECKIN:
                // Checkin a user and record Trust & Checkin Times
                // Grab Trust rating from the Kerb ticket. 
                Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Checking in Entrant for Event " + entityId);            
                break;

            case Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_RESULT:
                // Score and Event, and set the Winner & Loser fields
                Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Updating the Result for Event " + entityId);            
                break;

            case Comp.XONLINE_COMP_ELIMINATION_EVENTS_UPDATEID_ENTRANTS:
                // Update the P1 & P2 fields
                Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Updating the Entrants for Event " + entityId);            
                break;

            default:
                Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Updating Event(s) via procIndex" + procIndex);            
                break;            
            }

            XRLUtil.VerifyParam(entityId != 0,                           "Update Event Entity ID entered is 0!\r\n"      + QueryUtil.DumpAttribs(attribs));
            
            return HResult.S_OK;
        }
        
        public void AfterUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Updated Event(s) via procIndex " + procIndex);            
        }
        
        public HResult BeforeRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            ulong       compId = 0;
            
            // Service only method. Either Source.Server or Source.Plugin flags must be set
            if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }

            // Validate parameters
            if ((procIndex < Comp.XONLINE_COMP_ELIMINATION_EVENTS_REMOVE_MIN) || (procIndex > Comp.XONLINE_COMP_ELIMINATION_EVENTS_REMOVE_MAX))   
            {
                return HResult.E_INVALIDARG;
            }
            
            foreach(QueryAttribute attrib in attribs)
            {
                switch (attrib.Id)
                {
                case Comp.XONLINE_COMP_ATTR_ID:     // Competition ID to delete players from
                    compId = (ulong)attrib.lValue;
                    break;
                };
            }

            XRLUtil.VerifyParam(compId != 0,                           "Competition Entity ID entered is 0!\r\n"      + QueryUtil.DumpAttribs(attribs));
            
            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Removing Event(s) via procIndex" + procIndex + " from Single Elimination Competition " + compId);            

            return HResult.S_OK;
        }
        
        public void AfterRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Removed Events(s) via procIndex" + procIndex);            
        }
        
        public HResult BeforeRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            ulong       compId = 0;
            
            // Service only method. Either Source.Server or Source.Plugin flags must be set
            if (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0)
            {
                return HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }
                        
            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Removing Event " + entityId + " from Single Elimination Competition " + compId);           
            
            return HResult.S_OK;
        }
        
        public void AfterRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            Xom.Trace(XomAreaName.ElimEvents, LogLevel.L_INFO, "Event " + entityId + " removed from Single Elimination Competition ");            
        }


        public HResult BeforeFind(Source source, uint titleId, uint datasetId, uint procIndex, ulong [] entityIds, Hashtable ctx)
        {
            HResult    hr = HResult.S_OK;
            
            // Service procs are only allowed to be called internally, not directly from the client
            if ((procIndex > 0x10000) && (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0))
            {
                hr = HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }

            return hr;
        }

        
        public HResult BeforeSearch(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx)
        {
            HResult    hr = HResult.S_OK;
            
            // Service procs are only allowed to be called internally, not directly from the client
            if ((procIndex > 0x10000) && (((uint)source & ((uint)Source.Server | (uint)Source.Plugin)) == 0))
            {
                hr = HResult.XONLINE_E_COMP_ACCESS_DENIED;
            }

            return hr;
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\installer.cs ===
using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.server.comps.query
{
    // this class indirectly advertises to installutil that this assembly has installable
    // perf counter bits, which will get installed using the Xom perf counter install magic.
    [RunInstaller(true)]
    public class CompetitionsPerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\titlelog.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;


namespace xonline.common.mgmt
{
    //public enum LogLevel
    //{
    //    L_INF = 0,
    //    L_WRN = 1,
    //    L_ERR = 2
    //}    
    
    public class TitleLog
    {
        public static bool EnableTitleLog
        {
            get 
            {
                return (Config.GetBoolSetting(Setting.query_enableTitleLog));
            }
        }

        //
        // TODO: make this a part of the xmgmt framework
        //
        public static void Write(XOService service, uint titleId, sbyte level, string message)
        {
            if (!EnableTitleLog)
                return;
                
            if (message.Length > XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN)
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_WARNING, "Title Message string too long!  truncating to 400 characters.");
                message = message.Substring(0, XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN);
            }
                
            TitleLogMessage msg = new TitleLogMessage(WindowsIdentity.GetCurrent(), DateTime.UtcNow, service, titleId, level, message);
            ThreadPool.QueueUserWorkItem(new WaitCallback(WriteMessageImpl), msg);
        }
        
        
        public static void WriteMessageImpl(object o)
        {
            TitleLogMessage msg = (TitleLogMessage)o;
            WindowsImpersonationContext impctx = null;
            
            try
            {
                impctx = StartImpersonation(msg.Id);
                    
                AddRequest       request = new AddRequest();
                AddResponse      resp = new AddResponse();
                MemoryStream     stream = new MemoryStream();
                BinaryWriter     writer = new BinaryWriter(stream);
                byte[]           respBuf;
                QueryAttribute[] attribs; 
    
                attribs = new QueryAttribute[4];
                for (int i = 0; i < attribs.Length; i++)   attribs[i] = new QueryAttribute();
                
                attribs[0].Id = XOn.XONLINE_TITLELOG_ATTR_DATE;
                attribs[0].lValue = msg.Time.ToFileTime();
                attribs[1].Id = XOn.XONLINE_TITLELOG_ATTR_SERVICE;
                attribs[1].lValue = (long)msg.Service;
                attribs[2].Id = XOn.XONLINE_TITLELOG_ATTR_SEVERITY;
                attribs[2].lValue = msg.Level;
                attribs[3].Id = XOn.XONLINE_TITLELOG_ATTR_MESSAGE;
                attribs[3].strValue = msg.Message;
                                           
    
                request.titleId = msg.TitleId;
                request.userId = 0;
                request.teamId = 0;
                request.datasetId = XOn.XONLINE_TITLELOG_DATASET_ID;
                request.attribCount = (uint)attribs.Length;
                request.attribs = attribs;
                
                request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
                
                string authData = new HTTPAuthData(0, 0, 0, 0, msg.TitleId, (uint)msg.Service, 0).ConstructBase64String();
                                                                                       
                HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, authData, stream.ToArray(), null, out respBuf);
                if (HResult.Failed(hr) && hr != HResult.XONLINE_E_QUERY_QUOTA_FULL)
                {
                    Xom.NtEvent(XEvent.Id.MGMT_TITLE_LOG_ERROR, "Writing to the query service failed with hr = " + hr);
                }
                
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.MGMT_TITLE_LOG_ERROR_1, e, "Writing to the query service failed.");
            }
            finally
            {
                StopImpersonation(impctx);
            }    
        }
        
        public static WindowsImpersonationContext StartImpersonation(WindowsIdentity id)
        {
            WindowsImpersonationContext impctx = null;
            
            try
            {
                if (id.IsSystem == false)
                {
                    // impersonate the thread that started this
                    impctx = id.Impersonate();
                }
            }
            catch(Exception e)
            {
                Xom.NtEvent( XEvent.Id.CRON_CONFIG_FAILURE, e, "Failed to impersonate {0}", id.Name);
            }
            
            return impctx;
        }
        
        public static void StopImpersonation(WindowsImpersonationContext impctx)
        {
            try
            {
                if (impctx != null)
                {
                    impctx.Undo();
                }
                
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.CRON_CONFIG_FAILURE_1, e, "Failure undoing impersonation.");
            }
        
        }
        
        
    }
    
    class TitleLogMessage
    {
        public TitleLogMessage(WindowsIdentity id, DateTime t, XOService service, uint titleId, sbyte level, string message)
        {
            Id      = id;
            Time    = t;
            TitleId = titleId;
            Service = service;
            Level   = level;
            Message = message;
        }
        
        public DateTime Time;
        public WindowsIdentity Id;
        public uint TitleId;
        public XOService Service;
        public sbyte Level;
        public string Message;
    }
        
    
     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\seperfcounters.cs ===
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// XQRY (ML) Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.protocol;

namespace xonline.server.comps.query 
{
    public class JoinCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public JoinCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            JoinCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            JoinCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                JoinCountersCategory.Current(hexTitleId).FailuresPerSecond,
                JoinCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            JoinCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            JoinCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                JoinCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                JoinCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Join", "Query (SE): Join" )]
	public class JoinCountersCategory : XomPerformanceCounterCategory
	{
		
        static public JoinCountersCategory _instance = new JoinCountersCategory();
        static public JoinCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (JoinCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Join request counters

		[XomPerformanceCounterAttr(
			"Join requests/sec", 
			"Join requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Join total", 
			"Total Join requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Join failures/sec", 
			"Number of unsuccessful results returned by Join per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Join total failures", 
			"Total number unsuccessful results returned by Join in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Join avg. execution time", 
			"Join Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class WithdrawCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public WithdrawCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            WithdrawCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            WithdrawCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                WithdrawCountersCategory.Current(hexTitleId).FailuresPerSecond,
                WithdrawCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            WithdrawCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            WithdrawCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                WithdrawCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                WithdrawCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Withdraw", "Query (SE): Withdraw" )]
	public class WithdrawCountersCategory : XomPerformanceCounterCategory
	{
		
        static public WithdrawCountersCategory _instance = new WithdrawCountersCategory();
        static public WithdrawCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (WithdrawCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Withdraw request counters

		[XomPerformanceCounterAttr(
			"Withdraw requests/sec", 
			"Withdraw requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Withdraw total", 
			"Total Withdraw requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Withdraw failures/sec", 
			"Number of unsuccessful results returned by Withdraw per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Withdraw total failures", 
			"Total number unsuccessful results returned by Withdraw in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Withdraw avg. execution time", 
			"Withdraw Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class CheckinCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public CheckinCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            CheckinCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            CheckinCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                CheckinCountersCategory.Current(hexTitleId).FailuresPerSecond,
                CheckinCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            CheckinCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            CheckinCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                CheckinCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                CheckinCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Checkin", "Query (SE): Checkin" )]
	public class CheckinCountersCategory : XomPerformanceCounterCategory
	{
		
        static public CheckinCountersCategory _instance = new CheckinCountersCategory();
        static public CheckinCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (CheckinCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Checkin request counters

		[XomPerformanceCounterAttr(
			"Checkin requests/sec", 
			"Checkin requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Checkin total", 
			"Total Checkin requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Checkin failures/sec", 
			"Number of unsuccessful results returned by Checkin per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Checkin total failures", 
			"Total number unsuccessful results returned by Checkin in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Checkin avg. execution time", 
			"Checkin Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class SubmitResultsCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public SubmitResultsCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            SubmitResultsCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            SubmitResultsCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                SubmitResultsCountersCategory.Current(hexTitleId).FailuresPerSecond,
                SubmitResultsCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            SubmitResultsCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SubmitResultsCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                SubmitResultsCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                SubmitResultsCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): SubmitResults", "Query (SE): SubmitResults" )]
	public class SubmitResultsCountersCategory : XomPerformanceCounterCategory
	{
		
        static public SubmitResultsCountersCategory _instance = new SubmitResultsCountersCategory();
        static public SubmitResultsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (SubmitResultsCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // SubmitResults request counters

		[XomPerformanceCounterAttr(
			"SubmitResults requests/sec", 
			"SubmitResults requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"SubmitResults total", 
			"Total SubmitResults requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"SubmitResults failures/sec", 
			"Number of unsuccessful results returned by SubmitResults per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"SubmitResults total failures", 
			"Total number unsuccessful results returned by SubmitResults in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"SubmitResults avg. execution time", 
			"SubmitResults Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class CancelCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public CancelCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            CancelCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            CancelCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                CancelCountersCategory.Current(hexTitleId).FailuresPerSecond,
                CancelCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            CancelCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            CancelCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                CancelCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                CancelCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Cancel", "Query (SE): Cancel" )]
	public class CancelCountersCategory : XomPerformanceCounterCategory
	{
		
        static public CancelCountersCategory _instance = new CancelCountersCategory();
        static public CancelCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (CancelCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Cancel request counters

		[XomPerformanceCounterAttr(
			"Cancel requests/sec", 
			"Cancel requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Cancel total", 
			"Total Cancel requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Cancel failures/sec", 
			"Number of unsuccessful results returned by Cancel per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Cancel total failures", 
			"Total number unsuccessful results returned by Cancel in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Cancel avg. execution time", 
			"Cancel Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class ForfeitCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public ForfeitCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            ForfeitCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            ForfeitCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                ForfeitCountersCategory.Current(hexTitleId).FailuresPerSecond,
                ForfeitCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            ForfeitCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            ForfeitCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                ForfeitCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                ForfeitCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Forfeit", "Query (SE): Forfeit" )]
	public class ForfeitCountersCategory : XomPerformanceCounterCategory
	{
		
        static public ForfeitCountersCategory _instance = new ForfeitCountersCategory();
        static public ForfeitCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (ForfeitCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Forfeit request counters

		[XomPerformanceCounterAttr(
			"Forfeit requests/sec", 
			"Forfeit requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Forfeit total", 
			"Total Forfeit requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Forfeit failures/sec", 
			"Number of unsuccessful results returned by Forfeit per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Forfeit total failures", 
			"Total number unsuccessful results returned by Forfeit in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Forfeit avg. execution time", 
			"Forfeit Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class EjectCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public EjectCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            EjectCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            EjectCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                EjectCountersCategory.Current(hexTitleId).FailuresPerSecond,
                EjectCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            EjectCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            EjectCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                EjectCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                EjectCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Eject", "Query (SE): Eject" )]
	public class EjectCountersCategory : XomPerformanceCounterCategory
	{
		
        static public EjectCountersCategory _instance = new EjectCountersCategory();
        static public EjectCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (EjectCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Eject request counters

		[XomPerformanceCounterAttr(
			"Eject requests/sec", 
			"Eject requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Eject total", 
			"Total Eject requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Eject failures/sec", 
			"Number of unsuccessful results returned by Eject per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Eject total failures", 
			"Total number unsuccessful results returned by Eject in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Eject avg. execution time", 
			"Eject Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class SlottingCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public SlottingCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            SlottingCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            SlottingCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                SlottingCountersCategory.Current(hexTitleId).FailuresPerSecond,
                SlottingCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            SlottingCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SlottingCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                SlottingCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                SlottingCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Slotting", "Query (SE): Slotting" )]
	public class SlottingCountersCategory : XomPerformanceCounterCategory
	{
		
        static public SlottingCountersCategory _instance = new SlottingCountersCategory();
        static public SlottingCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (SlottingCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Slotting request counters

		[XomPerformanceCounterAttr(
			"Slotting requests/sec", 
			"Slotting requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Slotting total", 
			"Total Slotting requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Slotting failures/sec", 
			"Number of unsuccessful results returned by Slotting per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Slotting total failures", 
			"Total number unsuccessful results returned by Slotting in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Slotting avg. execution time", 
			"Slotting Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class ProgressionCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public ProgressionCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            ProgressionCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            ProgressionCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                ProgressionCountersCategory.Current(hexTitleId).FailuresPerSecond,
                ProgressionCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            ProgressionCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            ProgressionCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                ProgressionCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                ProgressionCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Progression", "Query (SE): Progression" )]
	public class ProgressionCountersCategory : XomPerformanceCounterCategory
	{
		
        static public ProgressionCountersCategory _instance = new ProgressionCountersCategory();
        static public ProgressionCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (ProgressionCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Progression request counters

		[XomPerformanceCounterAttr(
			"Progression requests/sec", 
			"Progression requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Progression total", 
			"Total Progression requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Progression failures/sec", 
			"Number of unsuccessful results returned by Progression per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Progression total failures", 
			"Total number unsuccessful results returned by Progression in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Progression avg. execution time", 
			"Progression Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class FinalizeCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public FinalizeCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            FinalizeCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            FinalizeCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                FinalizeCountersCategory.Current(hexTitleId).FailuresPerSecond,
                FinalizeCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            FinalizeCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            FinalizeCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                FinalizeCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                FinalizeCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Finalize", "Query (SE): Finalize" )]
	public class FinalizeCountersCategory : XomPerformanceCounterCategory
	{
		
        static public FinalizeCountersCategory _instance = new FinalizeCountersCategory();
        static public FinalizeCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (FinalizeCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Finalize request counters

		[XomPerformanceCounterAttr(
			"Finalize requests/sec", 
			"Finalize requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Finalize total", 
			"Total Finalize requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Finalize failures/sec", 
			"Number of unsuccessful results returned by Finalize per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Finalize total failures", 
			"Total number unsuccessful results returned by Finalize in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Finalize avg. execution time", 
			"Finalize Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class DeleteCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public DeleteCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            DeleteCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            DeleteCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                DeleteCountersCategory.Current(hexTitleId).FailuresPerSecond,
                DeleteCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            DeleteCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            DeleteCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                DeleteCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                DeleteCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Delete", "Query (SE): Delete" )]
	public class DeleteCountersCategory : XomPerformanceCounterCategory
	{
		
        static public DeleteCountersCategory _instance = new DeleteCountersCategory();
        static public DeleteCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (DeleteCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Delete request counters

		[XomPerformanceCounterAttr(
			"Delete requests/sec", 
			"Delete requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Delete total", 
			"Total Delete requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Delete failures/sec", 
			"Number of unsuccessful results returned by Delete per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Delete total failures", 
			"Total number unsuccessful results returned by Delete in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Delete avg. execution time", 
			"Delete Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class RemindersCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public RemindersCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            RemindersCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            RemindersCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                RemindersCountersCategory.Current(hexTitleId).FailuresPerSecond,
                RemindersCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            RemindersCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            RemindersCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                RemindersCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                RemindersCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): Reminders", "Query (SE): Reminders" )]
	public class RemindersCountersCategory : XomPerformanceCounterCategory
	{
		
        static public RemindersCountersCategory _instance = new RemindersCountersCategory();
        static public RemindersCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (RemindersCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Reminders request counters

		[XomPerformanceCounterAttr(
			"Reminders requests/sec", 
			"Reminders requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Reminders total", 
			"Total Reminders requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Reminders failures/sec", 
			"Number of unsuccessful results returned by Reminders per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Reminders total failures", 
			"Total number unsuccessful results returned by Reminders in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Reminders avg. execution time", 
			"Reminders Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class AdvanceTimeCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public AdvanceTimeCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            AdvanceTimeCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            AdvanceTimeCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                AdvanceTimeCountersCategory.Current(hexTitleId).FailuresPerSecond,
                AdvanceTimeCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            AdvanceTimeCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            AdvanceTimeCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                AdvanceTimeCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                AdvanceTimeCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (SE): AdvanceTime", "Query (SE): AdvanceTime" )]
	public class AdvanceTimeCountersCategory : XomPerformanceCounterCategory
	{
		
        static public AdvanceTimeCountersCategory _instance = new AdvanceTimeCountersCategory();
        static public AdvanceTimeCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (AdvanceTimeCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // AdvanceTime request counters

		[XomPerformanceCounterAttr(
			"AdvanceTime requests/sec", 
			"AdvanceTime requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"AdvanceTime total", 
			"Total AdvanceTime requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"AdvanceTime failures/sec", 
			"Number of unsuccessful results returned by AdvanceTime per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"AdvanceTime total failures", 
			"Total number unsuccessful results returned by AdvanceTime in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"AdvanceTime avg. execution time", 
			"AdvanceTime Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}

    public class AddCompetitionCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public AddCompetitionCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            AddCompetitionCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            AddCompetitionCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                AddCompetitionCountersCategory.Current(hexTitleId).FailuresPerSecond,
                AddCompetitionCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            AddCompetitionCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            AddCompetitionCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                AddCompetitionCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                AddCompetitionCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): AddCompetition", "Query (ML): AddCompetition" )]
	public class AddCompetitionCountersCategory : XomPerformanceCounterCategory
	{
		
        static public AddCompetitionCountersCategory _instance = new AddCompetitionCountersCategory();
        static public AddCompetitionCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (AddCompetitionCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // AddCompetition request counters

		[XomPerformanceCounterAttr(
			"AddCompetition requests/sec", 
			"AddCompetition requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"AddCompetition total", 
			"Total AddCompetition requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"AddCompetition failures/sec", 
			"Number of unsuccessful results returned by AddCompetition per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"AddCompetition total failures", 
			"Total number unsuccessful results returned by AddCompetition in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"AddCompetition avg. execution time", 
			"AddCompetition Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\00000673.cs ===
// Autogenerated from e:\xenon\private\ops\query\00000673.xqs on 7/13/2004 5:01:33 PM// DO NOT MAKE CHANGES TO THIS FILE!  They will not be reflected the next time 
// this file is generated.

using System;
using xonline.common;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.querylib;

namespace xonline.server.comps.query
{
    public class AddEliminationCompetitions
    {
        public QueryAttribute[] Attribs;
        public AddEliminationCompetitions()
        {
            Attribs = new QueryAttribute[31];
            Attribs[0] = new QueryAttribute(0x80010001);    // att_reg_open
            Attribs[1] = new QueryAttribute(0x80010002);    // att_reg_close
            Attribs[2] = new QueryAttribute(0x80010003);    // att_comp_start
            Attribs[3] = new QueryAttribute(0x80010004, 7); // att_comp_cleanup
            Attribs[4] = new QueryAttribute(0x80010005);    // att_round_frequency
            Attribs[5] = new QueryAttribute(0x80010006);    // att_round_interval
            Attribs[6] = new QueryAttribute(0x80010007);    // att_round_day_mask
            Attribs[7] = new QueryAttribute(0x8001000c);    // att_round_one_start
            Attribs[8] = new QueryAttribute(0x8001000d);    // att_round_one_end
            Attribs[9] = new QueryAttribute(0x80010010);    // att_is_team_comp
            Attribs[10] = new QueryAttribute(0x80010011);   // att_team_size
            Attribs[11] = new QueryAttribute(0x80010012);   // att_max_public_slots
            Attribs[12] = new QueryAttribute(0x80010013);   // att_max_private_slots
            Attribs[13] = new QueryAttribute(0x80010014);   // att_min_slots
            Attribs[14] = new QueryAttribute(0x8001001a, 0);// att_reminder_min
            Attribs[15] = new QueryAttribute(0x8011000e, "");// att_comp_name
            Attribs[16] = new QueryAttribute(0x80010008, 0);// att_rounds
            Attribs[17] = new QueryAttribute(0x80010009, 0);// att_current_round
            Attribs[18] = new QueryAttribute(0x8001000a, 0);// att_current_round_start
            Attribs[19] = new QueryAttribute(0x8001000b, 0);// att_current_round_end
            Attribs[20] = new QueryAttribute(0x80010018, 0);// att_public_entrants
            Attribs[21] = new QueryAttribute(0x80010019, 0);// att_private_entrants
            Attribs[22] = new QueryAttribute(0x8001001d, 0);// att_status
            Attribs[23] = new QueryAttribute(0x80010020, 0);// att_leaderboard_id1
            Attribs[24] = new QueryAttribute(0x80010021, 0);// att_leaderboard_id2
            Attribs[25] = new QueryAttribute(0x80010022, 0);// att_leaderboard_id3
            Attribs[26] = new QueryAttribute(0x8011001e, "");// att_comp_description
            Attribs[27] = new QueryAttribute(0x8011001f, "");// att_comp_url
            Attribs[28] = new QueryAttribute(0x00010001);   // att_map
            Attribs[29] = new QueryAttribute(0x00110002);   // att_name
            Attribs[30] = new QueryAttribute(0x00210003);   // att_icon
        }

        public long RegOpen
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long RegClose
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long CompStart
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long CompCleanup
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long RoundFrequency
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long RoundInterval
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

        public long RoundDayMask
        {
            get { return (long)Attribs[6].Value; }
            set { Attribs[6].Value = value; }
        }

        public long RoundOneStart
        {
            get { return (long)Attribs[7].Value; }
            set { Attribs[7].Value = value; }
        }

        public long RoundOneEnd
        {
            get { return (long)Attribs[8].Value; }
            set { Attribs[8].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)Attribs[9].Value; }
            set { Attribs[9].Value = value; }
        }

        public long TeamSize
        {
            get { return (long)Attribs[10].Value; }
            set { Attribs[10].Value = value; }
        }

        public long MaxPublicSlots
        {
            get { return (long)Attribs[11].Value; }
            set { Attribs[11].Value = value; }
        }

        public long MaxPrivateSlots
        {
            get { return (long)Attribs[12].Value; }
            set { Attribs[12].Value = value; }
        }

        public long MinSlots
        {
            get { return (long)Attribs[13].Value; }
            set { Attribs[13].Value = value; }
        }

        public long ReminderMin
        {
            get { return (long)Attribs[14].Value; }
            set { Attribs[14].Value = value; }
        }

        public string CompName
        {
            get { return (string)Attribs[15].Value; }
            set { Attribs[15].Value = value; }
        }

        public long Rounds
        {
            get { return (long)Attribs[16].Value; }
            set { Attribs[16].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)Attribs[17].Value; }
            set { Attribs[17].Value = value; }
        }

        public long CurrentRoundStart
        {
            get { return (long)Attribs[18].Value; }
            set { Attribs[18].Value = value; }
        }

        public long CurrentRoundEnd
        {
            get { return (long)Attribs[19].Value; }
            set { Attribs[19].Value = value; }
        }

        public long PublicEntrants
        {
            get { return (long)Attribs[20].Value; }
            set { Attribs[20].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)Attribs[21].Value; }
            set { Attribs[21].Value = value; }
        }

        public long Status
        {
            get { return (long)Attribs[22].Value; }
            set { Attribs[22].Value = value; }
        }

        public long LeaderboardId1
        {
            get { return (long)Attribs[23].Value; }
            set { Attribs[23].Value = value; }
        }

        public long LeaderboardId2
        {
            get { return (long)Attribs[24].Value; }
            set { Attribs[24].Value = value; }
        }

        public long LeaderboardId3
        {
            get { return (long)Attribs[25].Value; }
            set { Attribs[25].Value = value; }
        }

        public string CompDescription
        {
            get { return (string)Attribs[26].Value; }
            set { Attribs[26].Value = value; }
        }

        public string CompUrl
        {
            get { return (string)Attribs[27].Value; }
            set { Attribs[27].Value = value; }
        }

        public long Map
        {
            get { return (long)Attribs[28].Value; }
            set { Attribs[28].Value = value; }
        }

        public string Name
        {
            get { return (string)Attribs[29].Value; }
            set { Attribs[29].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])Attribs[30].Value; }
            set { Attribs[30].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class Enumall
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public Enumall()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82000001);          // owner_id

            Specs = new QueryAttributeSpec[2];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x8011000e, 32);    // att_comp_name
        }

        public long OwnerId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out EnumallResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EnumallResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x2001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EnumallResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EnumallResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out EnumallResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EnumallResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x2001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EnumallResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EnumallResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class EnumallResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public EnumallResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public EnumallResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public string CompName
        {
            get { return (string)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

    }

    public class Getsinglecomp
    {
        public static QueryAttributeSpec[] Specs;

        static Getsinglecomp()
        {

            Specs = new QueryAttributeSpec[19];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80010001, 30);    // att_reg_open
            Specs[2] = new QueryAttributeSpec(0x80010002, 30);    // att_reg_close
            Specs[3] = new QueryAttributeSpec(0x80010003, 30);    // att_comp_start
            Specs[4] = new QueryAttributeSpec(0x80010005, 30);    // att_round_frequency
            Specs[5] = new QueryAttributeSpec(0x80010006, 30);    // att_round_interval
            Specs[6] = new QueryAttributeSpec(0x80010007, 30);    // att_round_day_mask
            Specs[7] = new QueryAttributeSpec(0x8001000c, 30);    // att_round_one_start
            Specs[8] = new QueryAttributeSpec(0x8001000d, 30);    // att_round_one_end
            Specs[9] = new QueryAttributeSpec(0x80010010, 30);    // att_is_team_comp
            Specs[10] = new QueryAttributeSpec(0x8001001d, 30);   // att_status
            Specs[11] = new QueryAttributeSpec(0x8011001e, 400);  // att_comp_description
            Specs[12] = new QueryAttributeSpec(0x80010012, 30);   // att_max_public_slots
            Specs[13] = new QueryAttributeSpec(0x80010013, 30);   // att_max_private_slots
            Specs[14] = new QueryAttributeSpec(0x80010014, 30);   // att_min_slots
            Specs[15] = new QueryAttributeSpec(0x8001001a, 30);   // att_reminder_min
            Specs[16] = new QueryAttributeSpec(0x80010009, 30);   // att_current_round
            Specs[17] = new QueryAttributeSpec(0x8001000a, 30);   // att_current_round_start
            Specs[18] = new QueryAttributeSpec(0x8001000b, 30);   // att_current_round_end
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out GetsinglecompResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x2002, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new GetsinglecompResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new GetsinglecompResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out GetsinglecompResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x2002, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new GetsinglecompResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new GetsinglecompResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class GetsinglecompResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public GetsinglecompResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public GetsinglecompResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long RegOpen
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long RegClose
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long CompStart
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long RoundFrequency
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long RoundInterval
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long RoundDayMask
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long RoundOneStart
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long RoundOneEnd
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public string CompDescription
        {
            get { return (string)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

        public long MaxPublicSlots
        {
            get { return (long)_attribs[12 + _startIndex].Value; }
            set { _attribs[12 + _startIndex].Value = value; }
        }

        public long MaxPrivateSlots
        {
            get { return (long)_attribs[13 + _startIndex].Value; }
            set { _attribs[13 + _startIndex].Value = value; }
        }

        public long MinSlots
        {
            get { return (long)_attribs[14 + _startIndex].Value; }
            set { _attribs[14 + _startIndex].Value = value; }
        }

        public long ReminderMin
        {
            get { return (long)_attribs[15 + _startIndex].Value; }
            set { _attribs[15 + _startIndex].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)_attribs[16 + _startIndex].Value; }
            set { _attribs[16 + _startIndex].Value = value; }
        }

        public long CurrentRoundStart
        {
            get { return (long)_attribs[17 + _startIndex].Value; }
            set { _attribs[17 + _startIndex].Value = value; }
        }

        public long CurrentRoundEnd
        {
            get { return (long)_attribs[18 + _startIndex].Value; }
            set { _attribs[18 + _startIndex].Value = value; }
        }

    }

    public class AvailableCompetitions
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public AvailableCompetitions()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82000003);          // p_current_time

            Specs = new QueryAttributeSpec[17];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80010003, 30);    // att_comp_start
            Specs[2] = new QueryAttributeSpec(0x80010005, 30);    // att_round_frequency
            Specs[3] = new QueryAttributeSpec(0x80010006, 30);    // att_round_interval
            Specs[4] = new QueryAttributeSpec(0x80010007, 30);    // att_round_day_mask
            Specs[5] = new QueryAttributeSpec(0x8001000c, 30);    // att_round_one_start
            Specs[6] = new QueryAttributeSpec(0x8001000d, 30);    // att_round_one_end
            Specs[7] = new QueryAttributeSpec(0x80010010, 30);    // att_is_team_comp
            Specs[8] = new QueryAttributeSpec(0x80010011, 30);    // att_team_size
            Specs[9] = new QueryAttributeSpec(0x80010012, 30);    // att_max_public_slots
            Specs[10] = new QueryAttributeSpec(0x80010013, 30);   // att_max_private_slots
            Specs[11] = new QueryAttributeSpec(0x80010018, 30);   // att_public_entrants
            Specs[12] = new QueryAttributeSpec(0x80010019, 30);   // att_private_entrants
            Specs[13] = new QueryAttributeSpec(0x8001001d, 30);   // att_status
            Specs[14] = new QueryAttributeSpec(0x00010001, 30);   // att_map
            Specs[15] = new QueryAttributeSpec(0x00110002, 200);  // att_name
            Specs[16] = new QueryAttributeSpec(0x00210003, 400);  // att_icon
        }

        public long CurrentTime
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out AvailableCompetitionsResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out AvailableCompetitionsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new AvailableCompetitionsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new AvailableCompetitionsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out AvailableCompetitionsResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out AvailableCompetitionsResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new AvailableCompetitionsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new AvailableCompetitionsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class AvailableCompetitionsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public AvailableCompetitionsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public AvailableCompetitionsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long CompStart
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long RoundFrequency
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long RoundInterval
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long RoundDayMask
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long RoundOneStart
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long RoundOneEnd
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long TeamSize
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long MaxPublicSlots
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long MaxPrivateSlots
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long PublicEntrants
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)_attribs[12 + _startIndex].Value; }
            set { _attribs[12 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[13 + _startIndex].Value; }
            set { _attribs[13 + _startIndex].Value = value; }
        }

        public long Map
        {
            get { return (long)_attribs[14 + _startIndex].Value; }
            set { _attribs[14 + _startIndex].Value = value; }
        }

        public string Name
        {
            get { return (string)_attribs[15 + _startIndex].Value; }
            set { _attribs[15 + _startIndex].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])_attribs[16 + _startIndex].Value; }
            set { _attribs[16 + _startIndex].Value = value; }
        }

    }

    public class CompetitionsICreated
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public CompetitionsICreated()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82000001);          // p_owner_id
            Attribs[1] = new QueryAttribute(0x8201001d, 0);       // p_status

            Specs = new QueryAttributeSpec[17];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80010003, 30);    // att_comp_start
            Specs[2] = new QueryAttributeSpec(0x80010005, 30);    // att_round_frequency
            Specs[3] = new QueryAttributeSpec(0x80010006, 30);    // att_round_interval
            Specs[4] = new QueryAttributeSpec(0x80010007, 30);    // att_round_day_mask
            Specs[5] = new QueryAttributeSpec(0x8001000c, 30);    // att_round_one_start
            Specs[6] = new QueryAttributeSpec(0x8001000d, 30);    // att_round_one_end
            Specs[7] = new QueryAttributeSpec(0x80010010, 30);    // att_is_team_comp
            Specs[8] = new QueryAttributeSpec(0x80010011, 30);    // att_team_size
            Specs[9] = new QueryAttributeSpec(0x80010012, 30);    // att_max_public_slots
            Specs[10] = new QueryAttributeSpec(0x80010013, 30);   // att_max_private_slots
            Specs[11] = new QueryAttributeSpec(0x80010018, 30);   // att_public_entrants
            Specs[12] = new QueryAttributeSpec(0x80010019, 30);   // att_private_entrants
            Specs[13] = new QueryAttributeSpec(0x8001001d, 30);   // att_status
            Specs[14] = new QueryAttributeSpec(0x00010001, 30);   // att_map
            Specs[15] = new QueryAttributeSpec(0x00110002, 200);  // att_name
            Specs[16] = new QueryAttributeSpec(0x00210003, 400);  // att_icon
        }

        public long OwnerId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long Status
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out CompetitionsICreatedResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out CompetitionsICreatedResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x2, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new CompetitionsICreatedResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new CompetitionsICreatedResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out CompetitionsICreatedResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out CompetitionsICreatedResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x2, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new CompetitionsICreatedResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new CompetitionsICreatedResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class CompetitionsICreatedResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public CompetitionsICreatedResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public CompetitionsICreatedResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long CompStart
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long RoundFrequency
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long RoundInterval
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long RoundDayMask
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long RoundOneStart
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long RoundOneEnd
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long TeamSize
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long MaxPublicSlots
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long MaxPrivateSlots
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long PublicEntrants
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)_attribs[12 + _startIndex].Value; }
            set { _attribs[12 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[13 + _startIndex].Value; }
            set { _attribs[13 + _startIndex].Value = value; }
        }

        public long Map
        {
            get { return (long)_attribs[14 + _startIndex].Value; }
            set { _attribs[14 + _startIndex].Value = value; }
        }

        public string Name
        {
            get { return (string)_attribs[15 + _startIndex].Value; }
            set { _attribs[15 + _startIndex].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])_attribs[16 + _startIndex].Value; }
            set { _attribs[16 + _startIndex].Value = value; }
        }

    }

    public class CompetitionDetails
    {
        public static QueryAttributeSpec[] Specs;

        static CompetitionDetails()
        {

            Specs = new QueryAttributeSpec[24];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80000001, 0);     // bi_owner_id
            Specs[2] = new QueryAttributeSpec(0x80000001, 0);     // bi_owner_id
            Specs[3] = new QueryAttributeSpec(0x80010003, 30);    // att_comp_start
            Specs[4] = new QueryAttributeSpec(0x80010004, 30);    // att_comp_cleanup
            Specs[5] = new QueryAttributeSpec(0x80010005, 30);    // att_round_frequency
            Specs[6] = new QueryAttributeSpec(0x80010006, 30);    // att_round_interval
            Specs[7] = new QueryAttributeSpec(0x80010007, 30);    // att_round_day_mask
            Specs[8] = new QueryAttributeSpec(0x80010010, 30);    // att_is_team_comp
            Specs[9] = new QueryAttributeSpec(0x80010011, 30);    // att_team_size
            Specs[10] = new QueryAttributeSpec(0x8001001a, 30);   // att_reminder_min
            Specs[11] = new QueryAttributeSpec(0x80010008, 30);   // att_rounds
            Specs[12] = new QueryAttributeSpec(0x80010009, 30);   // att_current_round
            Specs[13] = new QueryAttributeSpec(0x8001000a, 30);   // att_current_round_start
            Specs[14] = new QueryAttributeSpec(0x8001000b, 30);   // att_current_round_end
            Specs[15] = new QueryAttributeSpec(0x80010018, 30);   // att_public_entrants
            Specs[16] = new QueryAttributeSpec(0x80010019, 30);   // att_private_entrants
            Specs[17] = new QueryAttributeSpec(0x8001001d, 30);   // att_status
            Specs[18] = new QueryAttributeSpec(0x80010020, 30);   // att_leaderboard_id1
            Specs[19] = new QueryAttributeSpec(0x80010021, 30);   // att_leaderboard_id2
            Specs[20] = new QueryAttributeSpec(0x80010022, 30);   // att_leaderboard_id3
            Specs[21] = new QueryAttributeSpec(0x00010001, 30);   // att_map
            Specs[22] = new QueryAttributeSpec(0x00110002, 200);  // att_name
            Specs[23] = new QueryAttributeSpec(0x00210003, 400);  // att_icon
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out CompetitionDetailsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x1, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new CompetitionDetailsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new CompetitionDetailsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out CompetitionDetailsResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x1, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new CompetitionDetailsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new CompetitionDetailsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class CompetitionDetailsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public CompetitionDetailsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public CompetitionDetailsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long XonlineQueryOwnerPuid
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long XonlineQueryOwnerGamertag
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long CompStart
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long CompCleanup
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long RoundFrequency
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long RoundInterval
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long RoundDayMask
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long TeamSize
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long ReminderMin
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long Rounds
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)_attribs[12 + _startIndex].Value; }
            set { _attribs[12 + _startIndex].Value = value; }
        }

        public long CurrentRoundStart
        {
            get { return (long)_attribs[13 + _startIndex].Value; }
            set { _attribs[13 + _startIndex].Value = value; }
        }

        public long CurrentRoundEnd
        {
            get { return (long)_attribs[14 + _startIndex].Value; }
            set { _attribs[14 + _startIndex].Value = value; }
        }

        public long PublicEntrants
        {
            get { return (long)_attribs[15 + _startIndex].Value; }
            set { _attribs[15 + _startIndex].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)_attribs[16 + _startIndex].Value; }
            set { _attribs[16 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[17 + _startIndex].Value; }
            set { _attribs[17 + _startIndex].Value = value; }
        }

        public long LeaderboardId0
        {
            get { return (long)_attribs[18 + _startIndex].Value; }
            set { _attribs[18 + _startIndex].Value = value; }
        }

        public long LeaderboardId1
        {
            get { return (long)_attribs[19 + _startIndex].Value; }
            set { _attribs[19 + _startIndex].Value = value; }
        }

        public long LeaderboardId2
        {
            get { return (long)_attribs[20 + _startIndex].Value; }
            set { _attribs[20 + _startIndex].Value = value; }
        }

        public long Map
        {
            get { return (long)_attribs[21 + _startIndex].Value; }
            set { _attribs[21 + _startIndex].Value = value; }
        }

        public string Name
        {
            get { return (string)_attribs[22 + _startIndex].Value; }
            set { _attribs[22 + _startIndex].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])_attribs[23 + _startIndex].Value; }
            set { _attribs[23 + _startIndex].Value = value; }
        }

    }

    public class UpdateTitleAttributes
    {
        public QueryAttribute[] Attribs;

         public UpdateTitleAttributes()
        {
            Attribs = new QueryAttribute[3];
            Attribs[0] = new QueryAttribute(0x02010001);          // p_map
            Attribs[1] = new QueryAttribute(0x02110002);          // p_name
            Attribs[2] = new QueryAttribute(0x02210003);          // p_icon
        }

        public long Map
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public string Name
        {
            get { return (string)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x1, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x1, entityId, Attribs);
        }
#endif
    }

    public class AdjustCompEntrantCounts
    {
        public QueryAttribute[] Attribs;

         public AdjustCompEntrantCounts()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x82010018, 0);       // XONLINE_COMP_ATTR_PUBLIC_ENTRANTS
            Attribs[1] = new QueryAttribute(0x82010019, 0);       // XONLINE_COMP_ATTR_PRIVATE_ENTRANTS
            Attribs[2] = new QueryAttribute(0x82010002);          // XONLINE_COMP_ATTR_REG_CLOSE
            Attribs[3] = new QueryAttribute(0x82010010);          // XONLINE_COMP_ATTR_IS_TEAM_COMP
        }

        public long PublicEntrants
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long RegClose
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#endif
    }

    public class AdjustTimeFields
    {
        public QueryAttribute[] Attribs;

         public AdjustTimeFields()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010023);          // XONLINE_COMP_ATTR_DEBUG_ADJUST_TIME
        }

        public long DebugAdjustTime
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#endif
    }

    public class FindProgressionData
    {
        public static QueryAttributeSpec[] Specs;

        static FindProgressionData()
        {

            Specs = new QueryAttributeSpec[11];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80010005, 30);    // att_round_frequency
            Specs[2] = new QueryAttributeSpec(0x80010006, 30);    // att_round_interval
            Specs[3] = new QueryAttributeSpec(0x80010007, 30);    // att_round_day_mask
            Specs[4] = new QueryAttributeSpec(0x80010008, 30);    // att_rounds
            Specs[5] = new QueryAttributeSpec(0x80010009, 30);    // att_current_round
            Specs[6] = new QueryAttributeSpec(0x8001000a, 30);    // att_current_round_start
            Specs[7] = new QueryAttributeSpec(0x8001000b, 30);    // att_current_round_end
            Specs[8] = new QueryAttributeSpec(0x8001001a, 30);    // att_reminder_min
            Specs[9] = new QueryAttributeSpec(0x80010004, 30);    // att_comp_cleanup
            Specs[10] = new QueryAttributeSpec(0x8001001d, 30);   // att_status
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out FindProgressionDataResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x10001, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new FindProgressionDataResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindProgressionDataResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out FindProgressionDataResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x10001, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new FindProgressionDataResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindProgressionDataResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class FindProgressionDataResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public FindProgressionDataResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public FindProgressionDataResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long RoundFrequency
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long RoundInterval
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long RoundDayMask
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long Rounds
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long CurrentRoundStart
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long CurrentRoundEnd
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long ReminderMin
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long CompCleanup
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

    }

    public class FindSlottingData
    {
        public static QueryAttributeSpec[] Specs;

        static FindSlottingData()
        {

            Specs = new QueryAttributeSpec[12];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80010014, 30);    // att_min_slots
            Specs[2] = new QueryAttributeSpec(0x80010018, 30);    // att_public_entrants
            Specs[3] = new QueryAttributeSpec(0x80010019, 30);    // att_private_entrants
            Specs[4] = new QueryAttributeSpec(0x80010003, 30);    // att_comp_start
            Specs[5] = new QueryAttributeSpec(0x80010005, 30);    // att_round_frequency
            Specs[6] = new QueryAttributeSpec(0x80010006, 30);    // att_round_interval
            Specs[7] = new QueryAttributeSpec(0x80010007, 30);    // att_round_day_mask
            Specs[8] = new QueryAttributeSpec(0x8001000c, 30);    // att_round_one_start
            Specs[9] = new QueryAttributeSpec(0x8001000d, 30);    // att_round_one_end
            Specs[10] = new QueryAttributeSpec(0x8001001a, 30);   // att_reminder_min
            Specs[11] = new QueryAttributeSpec(0x8001001d, 30);   // att_status
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out FindSlottingDataResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x10002, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new FindSlottingDataResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindSlottingDataResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out FindSlottingDataResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x10002, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new FindSlottingDataResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindSlottingDataResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class FindSlottingDataResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public FindSlottingDataResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public FindSlottingDataResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long MinSlots
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long PublicEntrants
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long CompStart
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long RoundFrequency
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long RoundInterval
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long RoundDayMask
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long RoundOneStart
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long RoundOneEnd
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long ReminderMin
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

    }

    public class FindCheckinData
    {
        public static QueryAttributeSpec[] Specs;

        static FindCheckinData()
        {

            Specs = new QueryAttributeSpec[10];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80010009, 30);    // att_current_round
            Specs[2] = new QueryAttributeSpec(0x8001000a, 30);    // att_current_round_start
            Specs[3] = new QueryAttributeSpec(0x8001000b, 30);    // att_current_round_end
            Specs[4] = new QueryAttributeSpec(0x8001001a, 30);    // att_reminder_min
            Specs[5] = new QueryAttributeSpec(0x80010010, 30);    // att_is_team_comp
            Specs[6] = new QueryAttributeSpec(0x8001001d, 30);    // att_status
            Specs[7] = new QueryAttributeSpec(0x80010003, 30);    // att_comp_start
            Specs[8] = new QueryAttributeSpec(0x80000001, 0);     // bi_owner_id
            Specs[9] = new QueryAttributeSpec(0x8011000e, 32);    // att_comp_name
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out FindCheckinDataResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x10003, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new FindCheckinDataResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindCheckinDataResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out FindCheckinDataResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x10003, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new FindCheckinDataResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindCheckinDataResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class FindCheckinDataResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public FindCheckinDataResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public FindCheckinDataResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long CurrentRoundStart
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long CurrentRoundEnd
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long ReminderMin
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long CompStart
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long CompOwner
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public string CompName
        {
            get { return (string)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

    }

    public class FindLeaderboards
    {
        public static QueryAttributeSpec[] Specs;

        static FindLeaderboards()
        {

            Specs = new QueryAttributeSpec[4];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80010020, 30);    // att_leaderboard_id1
            Specs[2] = new QueryAttributeSpec(0x80010021, 30);    // att_leaderboard_id2
            Specs[3] = new QueryAttributeSpec(0x80010022, 30);    // att_leaderboard_id3
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out FindLeaderboardsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x10004, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new FindLeaderboardsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindLeaderboardsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out FindLeaderboardsResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x10004, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new FindLeaderboardsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindLeaderboardsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class FindLeaderboardsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public FindLeaderboardsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public FindLeaderboardsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long LeaderboardId1
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long LeaderboardId2
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long LeaderboardId3
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

    }

    public class UpdateRound
    {
        public QueryAttribute[] Attribs;

         public UpdateRound()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x82010008, 0);       // p_rounds
            Attribs[1] = new QueryAttribute(0x82010009, 0);       // p_current_round
            Attribs[2] = new QueryAttribute(0x8201000a, 0);       // p_current_round_start
            Attribs[3] = new QueryAttribute(0x8201000b, 0);       // p_current_round_end
            Attribs[4] = new QueryAttribute(0x8201001d, 0);       // p_status
        }

        public long Rounds
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long CurrentRoundStart
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long CurrentRoundEnd
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long Status
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#endif
    }

    public class UpdateCompStatus
    {
        public QueryAttribute[] Attribs;

         public UpdateCompStatus()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x8201001d, 0);       // p_status
        }

        public long Status
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#endif
    }

    public class UpdateSlotting
    {
        public QueryAttribute[] Attribs;

         public UpdateSlotting()
        {
            Attribs = new QueryAttribute[8];
            Attribs[0] = new QueryAttribute(0x82010008, 0);       // p_rounds
            Attribs[1] = new QueryAttribute(0x82010009, 0);       // p_current_round
            Attribs[2] = new QueryAttribute(0x8201000a, 0);       // p_current_round_start
            Attribs[3] = new QueryAttribute(0x8201000b, 0);       // p_current_round_end
            Attribs[4] = new QueryAttribute(0x8201001d, 0);       // p_status
            Attribs[5] = new QueryAttribute(0x82010020, 0);       // p_leaderboard_id1
            Attribs[6] = new QueryAttribute(0x82010021, 0);       // p_leaderboard_id2
            Attribs[7] = new QueryAttribute(0x82010022, 0);       // p_leaderboard_id3
        }

        public long Rounds
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long CurrentRoundStart
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long CurrentRoundEnd
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long Status
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long LeaderboardId1
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

        public long LeaderboardId2
        {
            get { return (long)Attribs[6].Value; }
            set { Attribs[6].Value = value; }
        }

        public long LeaderboardId3
        {
            get { return (long)Attribs[7].Value; }
            set { Attribs[7].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10003, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10003, entityId, Attribs);
        }
#endif
    }

    public class AddEliminationEntrants
    {
        public QueryAttribute[] Attribs;
        public AddEliminationEntrants()
        {
            Attribs = new QueryAttribute[10];
            Attribs[0] = new QueryAttribute(0x80010000, 0); // att_comp_id
            Attribs[1] = new QueryAttribute(0x8001001d, 0); // att_comp_status
            Attribs[2] = new QueryAttribute(0x80020000, 0); // att_puid
            Attribs[3] = new QueryAttribute(0x80020001, 0); // att_status
            Attribs[4] = new QueryAttribute(0x80020003, 0); // att_current_round
            Attribs[5] = new QueryAttribute(0x80020007, 0); // att_current_event
            Attribs[6] = new QueryAttribute(0x80020008, 0); // att_current_start
            Attribs[7] = new QueryAttribute(0x80020009, 0); // att_sort
            Attribs[8] = new QueryAttribute(0x80020004, 0); // att_private_slot
            Attribs[9] = new QueryAttribute(0x80020005, 0); // att_seed
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long CompStatus
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long Puid
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long Status
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long CurrentEvent
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

        public long CurrentStart
        {
            get { return (long)Attribs[6].Value; }
            set { Attribs[6].Value = value; }
        }

        public long Sort
        {
            get { return (long)Attribs[7].Value; }
            set { Attribs[7].Value = value; }
        }

        public long PrivateSlot
        {
            get { return (long)Attribs[8].Value; }
            set { Attribs[8].Value = value; }
        }

        public long Seed
        {
            get { return (long)Attribs[9].Value; }
            set { Attribs[9].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class MyCompetitions
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public MyCompetitions()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82020000, 0);       // p_puid
            Attribs[1] = new QueryAttribute(0x8201001d, 0);       // p_comp_status

            Specs = new QueryAttributeSpec[8];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80010000, 30);    // att_comp_id
            Specs[2] = new QueryAttributeSpec(0x8001001d, 30);    // att_comp_status
            Specs[3] = new QueryAttributeSpec(0x80020001, 30);    // att_status
            Specs[4] = new QueryAttributeSpec(0x80020003, 30);    // att_current_round
            Specs[5] = new QueryAttributeSpec(0x80020007, 30);    // att_current_event
            Specs[6] = new QueryAttributeSpec(0x80020008, 30);    // att_current_start
            Specs[7] = new QueryAttributeSpec(0x80020009, 30);    // att_sort
        }

        public long Puid
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long CompStatus
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out MyCompetitionsResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out MyCompetitionsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new MyCompetitionsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new MyCompetitionsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out MyCompetitionsResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out MyCompetitionsResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new MyCompetitionsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new MyCompetitionsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class MyCompetitionsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public MyCompetitionsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public MyCompetitionsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long CompId
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long CompStatus
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long CurrentEvent
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long CurrentStart
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long Sort
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

    }

    public class CompetitionStandings
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public CompetitionStandings()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // p_comp_id

            Specs = new QueryAttributeSpec[8];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80020000, 30);    // att_puid
            Specs[2] = new QueryAttributeSpec(0x80020000, 30);    // att_puid
            Specs[3] = new QueryAttributeSpec(0x80020001, 30);    // att_status
            Specs[4] = new QueryAttributeSpec(0x80020003, 30);    // att_current_round
            Specs[5] = new QueryAttributeSpec(0x80020007, 30);    // att_current_event
            Specs[6] = new QueryAttributeSpec(0x80020008, 30);    // att_current_start
            Specs[7] = new QueryAttributeSpec(0x80020009, 30);    // att_sort
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out CompetitionStandingsResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out CompetitionStandingsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x2, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new CompetitionStandingsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new CompetitionStandingsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out CompetitionStandingsResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out CompetitionStandingsResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x2, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new CompetitionStandingsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new CompetitionStandingsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class CompetitionStandingsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public CompetitionStandingsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public CompetitionStandingsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long Puid
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long Gamertag
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long CurrentEvent
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long CurrentStart
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long Sort
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

    }

    public class RemoveAllEntrants
    {
        public QueryAttribute[] Attribs;

         public RemoveAllEntrants()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // p_comp_id
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x10001, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x10001, Attribs);        
        }
#endif
    }

    public class CheckPrivateSlot
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public CheckPrivateSlot()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82020000, 0);       // XONLINE_COMP_ATTR_ENTRANT_PUID

            Specs = new QueryAttributeSpec[2];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80020004, 30);    // att_private_slot
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantPuid
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out CheckPrivateSlotResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out CheckPrivateSlotResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new CheckPrivateSlotResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new CheckPrivateSlotResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out CheckPrivateSlotResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out CheckPrivateSlotResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new CheckPrivateSlotResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new CheckPrivateSlotResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class CheckPrivateSlotResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public CheckPrivateSlotResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public CheckPrivateSlotResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long EntrantPrivateSlot
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

    }

    public class GetSortedSeeds
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public GetSortedSeeds()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // p_comp_id

            Specs = new QueryAttributeSpec[3];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80020000, 30);    // att_puid
            Specs[2] = new QueryAttributeSpec(0x80020005, 30);    // att_seed
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out GetSortedSeedsResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out GetSortedSeedsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10002, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new GetSortedSeedsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new GetSortedSeedsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out GetSortedSeedsResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out GetSortedSeedsResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10002, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new GetSortedSeedsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new GetSortedSeedsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class GetSortedSeedsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public GetSortedSeedsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public GetSortedSeedsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long Puid
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long Seed
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

    }

    public class UpdateMatchResults
    {
        public QueryAttribute[] Attribs;

         public UpdateMatchResults()
        {
            Attribs = new QueryAttribute[6];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // p_comp_id
            Attribs[1] = new QueryAttribute(0x82020000, 0);       // p_puid
            Attribs[2] = new QueryAttribute(0x82020001, 0);       // p_status
            Attribs[3] = new QueryAttribute(0x82020003, 0);       // p_current_round
            Attribs[4] = new QueryAttribute(0x82020007, 0);       // p_current_event
            Attribs[5] = new QueryAttribute(0x82020008, 0);       // p_current_start
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long Puid
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long Status
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long CurrentEvent
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long CurrentStart
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10001, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10001, Attribs);
        }
#endif
    }

    public class UpdateEntrantStatus
    {
        public QueryAttribute[] Attribs;

         public UpdateEntrantStatus()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // p_comp_id
            Attribs[1] = new QueryAttribute(0x8201001d, 0);       // p_comp_status
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long CompStatus
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10002, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10002, Attribs);
        }
#endif
    }

    public class AdvanceTimeFields
    {
        public QueryAttribute[] Attribs;

         public AdvanceTimeFields()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82010023);          // XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long DebugAdvanceTime
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#endif
    }

    public class AddEliminationEvents
    {
        public QueryAttribute[] Attribs;
        public AddEliminationEvents()
        {
            Attribs = new QueryAttribute[17];
            Attribs[0] = new QueryAttribute(0x80010000);    // comp_id
            Attribs[1] = new QueryAttribute(0x80030001);    // topology_id
            Attribs[2] = new QueryAttribute(0x80030002);    // round
            Attribs[3] = new QueryAttribute(0x80030003);    // start
            Attribs[4] = new QueryAttribute(0x80030006);    // next_entity
            Attribs[5] = new QueryAttribute(0x80030007);    // next_start
            Attribs[6] = new QueryAttribute(0x80030008);    // player1
            Attribs[7] = new QueryAttribute(0x80030009, 0); // p1_checkin
            Attribs[8] = new QueryAttribute(0x8023000a, new byte[] { 0} );// p1_data
            Attribs[9] = new QueryAttribute(0x8003000b);    // player2
            Attribs[10] = new QueryAttribute(0x8003000c, 0);// p2_checkin
            Attribs[11] = new QueryAttribute(0x8023000d, new byte[] { 0} );// p2_data
            Attribs[12] = new QueryAttribute(0x8003000e, 0);// winner
            Attribs[13] = new QueryAttribute(0x8003000f, 0);// loser
            Attribs[14] = new QueryAttribute(0x00030001, 0);// map
            Attribs[15] = new QueryAttribute(0x00130002, "");// name
            Attribs[16] = new QueryAttribute(0x00230003, new byte[] { 0} );// icon
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long TopologyId
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long Round
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long Start
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long NextEntity
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long NextStart
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

        public long Player1
        {
            get { return (long)Attribs[6].Value; }
            set { Attribs[6].Value = value; }
        }

        public long P1Checkin
        {
            get { return (long)Attribs[7].Value; }
            set { Attribs[7].Value = value; }
        }

        public byte[] P1Data
        {
            get { return (byte[])Attribs[8].Value; }
            set { Attribs[8].Value = value; }
        }

        public long Player2
        {
            get { return (long)Attribs[9].Value; }
            set { Attribs[9].Value = value; }
        }

        public long P2Checkin
        {
            get { return (long)Attribs[10].Value; }
            set { Attribs[10].Value = value; }
        }

        public byte[] P2Data
        {
            get { return (byte[])Attribs[11].Value; }
            set { Attribs[11].Value = value; }
        }

        public long Winner
        {
            get { return (long)Attribs[12].Value; }
            set { Attribs[12].Value = value; }
        }

        public long Loser
        {
            get { return (long)Attribs[13].Value; }
            set { Attribs[13].Value = value; }
        }

        public long Map
        {
            get { return (long)Attribs[14].Value; }
            set { Attribs[14].Value = value; }
        }

        public string Name
        {
            get { return (string)Attribs[15].Value; }
            set { Attribs[15].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])Attribs[16].Value; }
            set { Attribs[16].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class Topology
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public Topology()
        {
            Attribs = new QueryAttribute[3];
            Attribs[0] = new QueryAttribute(0x82010000);          // p_comp_id
            Attribs[1] = new QueryAttribute(0x82030010);          // p_topology_id_min
            Attribs[2] = new QueryAttribute(0x82030011);          // p_topology_id_max

            Specs = new QueryAttributeSpec[15];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80030001, 30);    // topology_id
            Specs[2] = new QueryAttributeSpec(0x80030002, 30);    // round
            Specs[3] = new QueryAttributeSpec(0x80030003, 30);    // start
            Specs[4] = new QueryAttributeSpec(0x80030006, 30);    // next_entity
            Specs[5] = new QueryAttributeSpec(0x80030007, 30);    // next_start
            Specs[6] = new QueryAttributeSpec(0x80030008, 30);    // player1
            Specs[7] = new QueryAttributeSpec(0x80030008, 30);    // player1
            Specs[8] = new QueryAttributeSpec(0x8003000b, 30);    // player2
            Specs[9] = new QueryAttributeSpec(0x8003000b, 30);    // player2
            Specs[10] = new QueryAttributeSpec(0x8003000e, 30);   // winner
            Specs[11] = new QueryAttributeSpec(0x8003000f, 30);   // loser
            Specs[12] = new QueryAttributeSpec(0x00030001, 30);   // map
            Specs[13] = new QueryAttributeSpec(0x00130002, 200);  // name
            Specs[14] = new QueryAttributeSpec(0x00230003, 400);  // icon
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long TopologyIdMin
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long TopologyIdMax
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out TopologyResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out TopologyResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new TopologyResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new TopologyResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out TopologyResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out TopologyResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new TopologyResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new TopologyResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class TopologyResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public TopologyResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public TopologyResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long TopologyId
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long Round
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long Start
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long NextEntity
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long NextStart
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long Player1
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long P1Gamertag
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long Player2
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long P2Gamertag
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long Winner
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long Loser
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

        public long Map
        {
            get { return (long)_attribs[12 + _startIndex].Value; }
            set { _attribs[12 + _startIndex].Value = value; }
        }

        public string Name
        {
            get { return (string)_attribs[13 + _startIndex].Value; }
            set { _attribs[13 + _startIndex].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])_attribs[14 + _startIndex].Value; }
            set { _attribs[14 + _startIndex].Value = value; }
        }

    }

    public class FindEvent
    {
        public static QueryAttributeSpec[] Specs;

        static FindEvent()
        {

            Specs = new QueryAttributeSpec[13];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80030001, 30);    // topology_id
            Specs[2] = new QueryAttributeSpec(0x80030002, 30);    // round
            Specs[3] = new QueryAttributeSpec(0x80030006, 30);    // next_entity
            Specs[4] = new QueryAttributeSpec(0x80030007, 30);    // next_start
            Specs[5] = new QueryAttributeSpec(0x80030008, 30);    // player1
            Specs[6] = new QueryAttributeSpec(0x80030009, 30);    // p1_checkin
            Specs[7] = new QueryAttributeSpec(0x8023000a, 4);     // p1_data
            Specs[8] = new QueryAttributeSpec(0x8003000b, 30);    // player2
            Specs[9] = new QueryAttributeSpec(0x8003000c, 30);    // p2_checkin
            Specs[10] = new QueryAttributeSpec(0x8023000d, 4);    // p2_data
            Specs[11] = new QueryAttributeSpec(0x8003000e, 30);   // winner
            Specs[12] = new QueryAttributeSpec(0x8003000f, 30);   // loser
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out FindEventResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x10001, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new FindEventResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindEventResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out FindEventResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x10001, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new FindEventResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindEventResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class FindEventResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public FindEventResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public FindEventResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long TopologyId
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long Round
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long NextEntity
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long NextStart
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long Player1
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long P1Checkin
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public byte[] P1Data
        {
            get { return (byte[])_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long Player2
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long P2Checkin
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public byte[] P2Data
        {
            get { return (byte[])_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long Winner
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

        public long Loser
        {
            get { return (long)_attribs[12 + _startIndex].Value; }
            set { _attribs[12 + _startIndex].Value = value; }
        }

    }

    public class RemoveAllEvents
    {
        public QueryAttribute[] Attribs;

         public RemoveAllEvents()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000);          // p_comp_id
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x10001, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x10001, Attribs);        
        }
#endif
    }

    public class SelectAll
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public SelectAll()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000);          // p_comp_id

            Specs = new QueryAttributeSpec[13];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80030001, 30);    // topology_id
            Specs[2] = new QueryAttributeSpec(0x80030002, 30);    // round
            Specs[3] = new QueryAttributeSpec(0x80030003, 30);    // start
            Specs[4] = new QueryAttributeSpec(0x80030006, 30);    // next_entity
            Specs[5] = new QueryAttributeSpec(0x80030008, 30);    // player1
            Specs[6] = new QueryAttributeSpec(0x80030009, 30);    // p1_checkin
            Specs[7] = new QueryAttributeSpec(0x8023000a, 4);     // p1_data
            Specs[8] = new QueryAttributeSpec(0x8003000b, 30);    // player2
            Specs[9] = new QueryAttributeSpec(0x8003000c, 30);    // p2_checkin
            Specs[10] = new QueryAttributeSpec(0x8023000d, 4);    // p2_data
            Specs[11] = new QueryAttributeSpec(0x8003000e, 30);   // winner
            Specs[12] = new QueryAttributeSpec(0x8003000f, 30);   // loser
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out SelectAllResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out SelectAllResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new SelectAllResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new SelectAllResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out SelectAllResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out SelectAllResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new SelectAllResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new SelectAllResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class SelectAllResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public SelectAllResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public SelectAllResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long TopologyId
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long Round
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long Start
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long NextEntity
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long Player1
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long P1Checkin
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public byte[] P1Data
        {
            get { return (byte[])_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long Player2
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long P2Checkin
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public byte[] P2Data
        {
            get { return (byte[])_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long Winner
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

        public long Loser
        {
            get { return (long)_attribs[12 + _startIndex].Value; }
            set { _attribs[12 + _startIndex].Value = value; }
        }

    }

    public class SelectRound
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public SelectRound()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010000);          // p_comp_id
            Attribs[1] = new QueryAttribute(0x82030002);          // round

            Specs = new QueryAttributeSpec[12];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80030001, 30);    // topology_id
            Specs[2] = new QueryAttributeSpec(0x80030006, 30);    // next_entity
            Specs[3] = new QueryAttributeSpec(0x80030003, 30);    // start
            Specs[4] = new QueryAttributeSpec(0x80030008, 30);    // player1
            Specs[5] = new QueryAttributeSpec(0x80030009, 30);    // p1_checkin
            Specs[6] = new QueryAttributeSpec(0x8023000a, 4);     // p1_data
            Specs[7] = new QueryAttributeSpec(0x8003000b, 30);    // player2
            Specs[8] = new QueryAttributeSpec(0x8003000c, 30);    // p2_checkin
            Specs[9] = new QueryAttributeSpec(0x8023000d, 4);     // p2_data
            Specs[10] = new QueryAttributeSpec(0x8003000e, 30);   // winner
            Specs[11] = new QueryAttributeSpec(0x8003000f, 30);   // loser
        }

        public long CompId
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long Round
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out SelectRoundResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out SelectRoundResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10002, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new SelectRoundResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new SelectRoundResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out SelectRoundResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out SelectRoundResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10002, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new SelectRoundResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new SelectRoundResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class SelectRoundResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public SelectRoundResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public SelectRoundResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long TopologyId
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long NextEntity
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long Start
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long Player1
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long P1Checkin
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public byte[] P1Trust
        {
            get { return (byte[])_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long Player2
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long P2Checkin
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public byte[] P2Trust
        {
            get { return (byte[])_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long Winner
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long Loser
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

    }

    public class Checkin
    {
        public QueryAttribute[] Attribs;

         public Checkin()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x82030009, 0);       // p1_checkin
            Attribs[1] = new QueryAttribute(0x8223000a, new byte[] { 0} );// p1_data
            Attribs[2] = new QueryAttribute(0x8203000c, 0);       // p2_checkin
            Attribs[3] = new QueryAttribute(0x8223000d, new byte[] { 0} );// p2_data
        }

        public long P1Checkin
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public byte[] P1Data
        {
            get { return (byte[])Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long P2Checkin
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public byte[] P2Data
        {
            get { return (byte[])Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#endif
    }

    public class UpdateResults
    {
        public QueryAttribute[] Attribs;

         public UpdateResults()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x8203000e, 0);       // winner
            Attribs[1] = new QueryAttribute(0x8203000f, 0);       // loser
            Attribs[2] = new QueryAttribute(0x02030001, 0);       // map
            Attribs[3] = new QueryAttribute(0x02130002, "");      // name
            Attribs[4] = new QueryAttribute(0x02230003, new byte[] { 0} );// icon
        }

        public long Winner
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long Loser
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long Map
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public string Name
        {
            get { return (string)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#endif
    }

    public class UpdatePlayers
    {
        public QueryAttribute[] Attribs;

         public UpdatePlayers()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82030008);          // player1
            Attribs[1] = new QueryAttribute(0x8203000b);          // player2
        }

        public long Player1
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long Player2
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10003, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10003, entityId, Attribs);
        }
#endif
    }

    public class UpdatePlayer1
    {
        public QueryAttribute[] Attribs;

         public UpdatePlayer1()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82030008);          // player1
        }

        public long Player1
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10004, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10004, entityId, Attribs);
        }
#endif
    }

    public class UpdatePlayer2
    {
        public QueryAttribute[] Attribs;

         public UpdatePlayer2()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x8203000b);          // player2
        }

        public long Player2
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10005, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10005, entityId, Attribs);
        }
#endif
    }

    public class AdjustEventTimes
    {
        public QueryAttribute[] Attribs;

         public AdjustEventTimes()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010000);          // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82010023);          // XONLINE_COMP_ATTR_DEBUG_ADJUST_TIME
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long DebugAdjustTime
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\ml\mlevents.cs ===
// 
// mlevents.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Multilevel Comp Events
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.server.query.fd;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.comps.common;
using xonline.server.comps.query;


namespace xonline.server.comps.query 
{
    
    public class MLEvents
    {
    

        public static HResult ActionSlotting(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            SlottingCounters counters = new SlottingCounters(titleId);

            HResult               hr = HResult.XONLINE_E_COMP_ERROR;
            uint                  entrants = 0;
            uint totalResults = 0;
            uint rounds = 0;
            uint templateId = 0;
            
                                                    
            FindCompDataResults[] compData;

            Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionSlotting *******");


            //
            // Multilevel slotting simply sets up round 0 slots and byes, based on the number
            // of people who joined the tournament at the time the action runs.  Subsequent 
            // rounds are set up with each progression.
            //

            
            try
            {
                // Service only method. Source.Server flag must be set
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
    
                //
                // Select all the Competition configuration data for Slotting 
                //
                hr = FindCompData.Execute(source, titleId, datasetId, new ulong[] { entityId }, out compData);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure executing FindFromIds!  hr = " + hr);
                }
    
                
                // Don't bother slotting cancelled competitions, or those that have already been slotted
                //
                if (compData[0].Status != Comp.XONLINE_COMP_STATUS_PRE_INIT)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Not slotting competition " + entityId.ToString("8x") + " as it's in the wrong state.  Status: " + compData[0].Status.ToString("x"));            
    
                    hr = HResult.S_OK;
                    goto end;
                }
                
                // make sure enough people joined.
                // 
                entrants = (uint)(compData[0].PublicEntrants + compData[0].PrivateEntrants);
                if (entrants < compData[0].MinSlots)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Not enough entrants for slotting competition " + entityId.ToString("8x") + ". Cancelling instead");            
                    
                    // review: we'll probably wan't to track this case for reporting..
    
                    hr = Multilevel.ActionCancel(source, titleId, userId, teamId, datasetId, entityId, ctx);
    
                    // return a positive hr to the cron service
                    hr = HResult.S_OK;
                    goto end;
                }
                
                
                if (ctx.Contains("roundLeaderboardTemplateId"))
                {
                    templateId = (uint)((long)ctx["roundLeaderboardTemplateId"]);
                }
                
                if (templateId < 0 || templateId > 15)
                {
                    throw new PluginException(
                        HResult.XONLINE_E_COMP_ERROR, "Invalid leaderboard template id " + templateId + "!"
                    );
                }
                
                
                // remove any prior bracket attempts
                // review: need to be smarter about this, as it will leave dangling leaderboards..
                //
                BracketRemoveComp removeBrackets = new BracketRemoveComp();
                removeBrackets.Id = (long)entityId;
                hr = removeBrackets.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET);
                if (hr != HResult.S_OK && hr != HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    throw new PluginException(hr, "Unexpected failure removing prior brackets! hr = " + hr);
                }
                
                rounds = MLUtil.GetRoundCount(entrants);
                uint brackets = 1;
                uint slots = MLUtil.GetSlotCount(entrants);

                ulong bracketEntityId;                                                                           
                DateTime roundStart = DateTime.FromFileTimeUtc(compData[0].CompStart);
                if (roundStart < DateTime.UtcNow)
                {
                    roundStart = DateTime.UtcNow;
                }
                
                DateTime firstRoundApd = roundStart.AddMinutes(compData[0].ApdOffsetMin);
                
                
                for (int i = 0; i < rounds; i++)
                {
                    uint lbId = 0;
                    if (templateId != 0)
                    {
                        lbId = CompUtil.CreateLeaderboard(titleId, templateId);
                    }    
                    
                    for (int j = 0; j < brackets; j++)
                    {
                        AddMultilevelBrackets newBracket = new AddMultilevelBrackets();
                        newBracket.Id = (long)entityId;
                        newBracket.BracketRound = i;
                        newBracket.BracketIndex = j;
                        
                        // only specify entrants + byes for the first round/bracket
                        if (i == 0)
                        {
                            newBracket.BracketEntrants = (i == 0 ? entrants : 0);
                            newBracket.BracketByes = slots - newBracket.BracketEntrants;
                        }
                        else
                        {
                            newBracket.BracketEntrants = 0;
                            newBracket.BracketByes = 0;
                        }
                        
                        newBracket.BracketStart = roundStart.ToFileTimeUtc();
                        newBracket.BracketApd = roundStart.AddMinutes(compData[0].ApdOffsetMin).ToFileTimeUtc();
                        newBracket.BracketEnd = roundStart.AddMinutes(compData[0].RoundDurationMin).ToFileTimeUtc();
                        newBracket.BracketLeaderboard = lbId;
                        newBracket.BracketStatus = i == 0 ? Comp.XONLINE_COMP_STATUS_BRACKET_CHECKIN : Comp.XONLINE_COMP_STATUS_BRACKET_PRE_INIT;
                            
                        hr = newBracket.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out bracketEntityId);
                        if (HResult.Failed(hr))
                        { 
                            throw new PluginException(hr, "Failed to add new bracket! hr = " + hr);
                        }
                        
                        Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Slotting: Round " + i + , Bracket " + i + " has " + 
                                    newBracket.BracketEntrants + " players, " + 
                                    newBracket.BracketByes + " byes.");
                    }
                    
                    roundStart = roundStart.AddMinutes(compData[0].RoundDurationMin);                       
                    brackets *= 2;
                    slots /= 2;
                    
                }
                
                // Update comp status
                //
                UpdateComp updateComp;
                updateComp = new UpdateComp();
                        
                updateComp.Status = Comp.XONLINE_COMP_STATUS_ACTIVE;
                updateComp.CurrentRound = 0;
                
                //
                // create custom leaderboards
                //
                if (ctx.Contains("numCompLeaderboards"))
                {
                    uint numCompLeaderboards = (uint)((long)ctx["numCompLeaderboards"]);
                    if (numCompLeaderboards > 0)
                    {
                        if (!ctx.Contains("compLeaderboardTemplateId"))
                        {
                            throw new PluginException(HResult.XONLINE_E_COMP_ERROR, "Required compLeaderboardTemplateId not specified in plugin context!");
                        }
                        
                        uint compTemplateId = (uint)((long)ctx["compLeaderboardTemplateId"]);
                        if (compTemplateId <= 0 || compTemplateId > 15)
                        {
                            throw new PluginException(HResult.XONLINE_E_COMP_ERROR, "Invalid value for compTemplateId: " + compTemplateId + "!");
                        }
                        
                        Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "[Multilevel " + entityId.ToString("X") + "] Creating comp leaderboards..");
                        
                        updateComp.LeaderboardId0 = CompUtil.CreateLeaderboard(titleId, templateId);
                        
                        if (numCompLeaderboards > 1)
                            updateComp.LeaderboardId1 = CompUtil.CreateLeaderboard(titleId, templateId);    
                        
                        if (numCompLeaderboards > 2)
                            updateComp.LeaderboardId2 = CompUtil.CreateLeaderboard(titleId, templateId);    
                    }
                }
                
                hr = updateComp.Execute(source, titleId, userId, teamId, datasetId, entityId);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure updating comp status!  hr = " + hr);
                }

                
                CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, entityId,
                                Comp.XONLINE_COMP_ACTION_AUTO_PROGRESSION, 
                                1, 
                                5 * 60,         // 5 minutes
                                firstRoundApd,
                                0);
                
                
    
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionSlotting complete *******");
            }
            catch(XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "SLT",
                              hr.ToString(),
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"),
                              entityId.ToString("x16"),
                              rounds.ToString("x"),
                              entrants.ToString("x"),
                              totalResults.ToString("x")
                      }));          

                counters.EndRequest(HResult.Failed(hr));
            }
end:
            return hr;
        }
        
        
        public static HResult ActionAutoProgression(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong compId, Hashtable ctx)
        {
            AutoProgressionCounters counters = new AutoProgressionCounters(titleId);

            HResult               hr = HResult.XONLINE_E_COMP_ERROR;
            uint                  entrants = 0;
            uint byes = 0;
            uint slots = 0;
            uint totalResults = 0;
            uint round = 0;
            DateTime roundProgression;
            
                                                    
            FindCompDataResults[] compData;

            Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionAutoProgression *******");


            //
            // AutoProgression is fired at each round's APD.     Any players that have 
            // requested a pass are moved to the next round, based on the number
            // of people and their trust ratings.
            //
            
            try
            {
                // Service only method. Source.Server flag must be set
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
                
                // load current comp data
                //
                hr = FindCompData.Execute(source, titleId, datasetId, new ulong[] { compId }, out compData);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure executing FindFromIds!  hr = " + hr);
                }
    
                
                // Don't bother auto-progressing cancelled competitions
                //
                if (compData[0].Status != Comp.XONLINE_COMP_STATUS_ACTIVE)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Not autoprogressing competition " + compId.ToString("8x") + " as it's in the wrong state.  Status: " + compData[0].Status.ToString("x"));            
    
                    hr = HResult.S_OK;
                    goto end;
                }
                
                round = (uint)compData[0].CurrentRound;
                // reset this value, as it may have changed due to outage
                roundProgression = DateTime.UtcNow.AddMinutes(compData[0].RoundDurationMin - compData[0].ApdOffsetMin);
                
                // first update all the brackets in this round, to make sure no additional byes come in
                // 
                BracketUpdateStatus updateStatus = new BracketUpdateStatus();
                updateStatus.Id = (long)compId;
                updateStatus.BracketRound = round;
                updateStatus.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_IN_PROGRESS;
                hr = updateStatus.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure updating bracket status for compId " + compId.ToString("x") + "! hr = " + hr);
                }
                    
                // Kick out anyone who hasn't checked in or requested a pass  (status is still REGISTERED)
                //
                EntrantsUpdateStatusInRound elimRegistered = new EntrantsUpdateStatusInRound();
                elimRegistered.Id = (long)compId;
                elimRegistered.EntrantCurrentRound = round;
                elimRegistered.EntrantCurrentStatus = Comp.XONLINE_COMP_STATUS_ENTRANT_REGISTERED;
                elimRegistered.EntrantNewStatus = Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED;
                hr = elimRegistered.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET);
                if (HResult.Failed(hr) && hr != HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    throw new PluginException(hr, "Unexpected failure eliminating registered entrants for compId " + compId.ToString("x") + "! hr = " + hr);
                }
                
                
                // get the list of brackets for this round
                //
                BracketSearchRound searchRound = new BracketSearchRound();
                BracketSearchRoundResults[] currentRoundResults;
                
                searchRound.Id = (long)compId;
                searchRound.BracketRound = round;
                
                hr = searchRound.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out currentRoundResults);
                if (HResult.Failed(hr) || currentRoundResults == null)
                {
                    throw new PluginException(hr, "Unexpected failure searching for brackets in the current round!  hr = " + hr);
                }    
                
                // make sure there was no outage since the last progression attempt
                //
                if (QueryHealth.WasServiceDown(DateTime.UtcNow.AddMinutes(-1 * compData[0].ApdOffsetMin), DateTime.UtcNow))
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Service downtime detected during CHECKIN period!   Delaying autoprogression!");
                    
                    DateTime bracketApd = MLUtil.DelayRound(source, titleId, datasetId, compId, round, 
                                                          DateTime.FromFileTimeUtc(currentRoundResults[0].BracketStart), 
                                                          DateTime.FromFileTimeUtc(currentRoundResults[0].BracketApd), 
                                                          DateTime.FromFileTimeUtc(currentRoundResults[0].BracketEnd), 
                                                          compData[0].RoundDurationMin, 
                                                          compData[0].ApdOffsetMin, 
                                                          true);
                    
                        
                    // reschedule this round's APD
                    CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, compId,
                                Comp.XONLINE_COMP_ACTION_AUTO_PROGRESSION, 
                                1, 
                                5 * 60,         // 5 minutes
                                bracketApd,
                                0);

                    hr = HResult.XONLINE_S_COMP_SERVICE_OUTAGE;                                                                                                                                                  
                    goto end;
                }
                                        
                
                // get the list of brackets for the next round
                //
                BracketSearchRoundResults[] nextRoundResults;
                searchRound.BracketRound = round + 1;
                
                hr = searchRound.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out nextRoundResults);
                if (HResult.Failed(hr) || nextRoundResults == null)
                {
                    throw new PluginException(hr, "Unexpected failure searching for brackets in the current round!  hr = " + hr);
                }    
                
                if (nextRoundResults.Length != currentRoundResults.Length * 2)
                {
                    throw new PluginException(hr, "Unexpected list of brackets!!\r\n" + 
                                                  "Comp: " + compId.ToString("x") + "\r\n" + 
                                                  "current round: " + round + "\r\n" +
                                                  "current round brackets: " +  currentRoundResults.Length + "\r\n" +
                                                  "next round brackets: " + nextRoundResults.Length + "\r\n" + 
                                                  "  (expected " + (currentRoundResults.Length * 2));
                }                                  
                
                
                EntrantsSearchStatus searchEntrant = new EntrantsSearchStatus();
                EntrantsSearchStatusResults[] searchEntrantResults;
                
                searchEntrant.Id = (long)compId;
                searchEntrant.EntrantCurrentRound = round;
                searchEntrant.EntrantStatus = Comp.XONLINE_COMP_STATUS_ENTRANT_PASS;
                
                
                for (uint i = 0; i < currentRoundResults.Length; i++)
                {
                    // get list of people who registered for a pass this round, sorted by trust
                    searchEntrant.EntrantCurrentIndex = currentRoundResults[i].BracketIndex;
                    hr = searchEntrant.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, out searchEntrantResults);
                    
                    if (HResult.Failed(hr))
                    {
                        throw new PluginException(hr, "Unexpected failure searching for entrants! hr = " + hr);
                    }        
                    
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "A total of " + (searchEntrantResults == null ? 0 : searchEntrantResults.Length) + 
                            " entrants registered for a PASS in bracket " + searchEntrant.EntrantCurrentRound + "/" + searchEntrant.EntrantCurrentIndex);
                    
                    if (searchEntrantResults != null)
                    {
                        // half of the people registering for a pass, rounding up, get a win
                        int winnerSlots = searchEntrantResults.Length / 2 + searchEntrantResults.Length % 2;
                        Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, winnerSlots.ToString() + " players requesting PASS get a win.");
                        
                        for (int j = 0; j < searchEntrantResults.Length; j++)
                        {
                            uint index;
                            long score;
                            
                            if (j < winnerSlots)
                            {
                                index = (uint)currentRoundResults[i].BracketIndex * 2;
                                score = MLUtil.UpdateScoreWithWin(searchEntrantResults[j].EntrantScore, round);
                            }
                            else    
                            {
                                // player goes to the loser bracket
                                index = (uint)currentRoundResults[i].BracketIndex * 2 + 1;
                                score = (uint)searchEntrantResults[j].EntrantScore;
                            }
                                
                            MLUtil.updateEntrantRound(source, titleId, datasetId, compId, (ulong)searchEntrantResults[j].EntrantPuid, round + 1, index, score, Comp.XONLINE_COMP_STATUS_ENTRANT_REGISTERED, HResult.S_OK);
                        }
                        
                        // update # of people in winners bracket
                        MLUtil.updateBracketEntrants(source, titleId, datasetId, compId, round + 1, i * 2, winnerSlots, 
                                                     true, compData[0].RoundDurationMin, compData[0].ApdOffsetMin, ctx);
                        
                        if (searchEntrantResults.Length - winnerSlots > 0)
                        {
                            // update # of people in losers bracket
                            MLUtil.updateBracketEntrants(source, titleId, datasetId, compId, round + 1, i * 2 + 1, searchEntrantResults.Length - winnerSlots, 
                                                         true, compData[0].RoundDurationMin, compData[0].ApdOffsetMin, ctx);
                        }    
                    }
                }    
                
                // see if the comp is complete
                if (MLUtil.IsEveryoneDone(source, titleId, datasetId, compId))
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Last of the results submitted, competition is complete!");
                    MLUtil.CompleteComp(source, titleId, datasetId, compId, compData[0]);
                }
                else
                {
                   
                    // schedule progression job
                    //
                    CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, compId,
                                    Comp.XONLINE_COMP_ACTION_PROGRESSION, 
                                    1, 
                                    5 * 60,         // 5 minutes
                                    roundProgression,
                                    0);
                }
                                    
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionAutoProgression Complete! *******");
                
            }
            catch(XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "SLT",
                              hr.ToString(),
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"),
                              compId.ToString("x16"),
                              entrants.ToString("x"),
                              slots.ToString("x"),
                              byes.ToString("x"),
                              totalResults.ToString("x")
                      }));          

                counters.EndRequest(HResult.Failed(hr));
            }
end:
            return hr;
        }


        
        public static HResult ActionProgression(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong compId, Hashtable ctx)
        {
            ProgressionCounters counters = new ProgressionCounters(titleId);

            HResult               hr = HResult.XONLINE_E_COMP_ERROR;
            uint                  entrants = 0;
            uint byes = 0;
            uint totalResults = 0;
            uint round = 0;
            DateTime roundStart;
            DateTime roundApd;
            DateTime roundProgression;
            DateTime nextRoundStart;
            DateTime nextRoundApd;
            DateTime nextRoundProgression;
            bool compComplete = true;
            
                                                    
            FindCompDataResults[] compData;


            //
            // Multilevel progression simply determines the number of byes in teh current 
            // round based on the number of people who completed the previous round
            //
            
            try
            {
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionProgression *******");
                
                
                // Service only method. Source.Server flag must be set
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
    
                //
                // Select all the Competition configuration data for Slotting 
                //
                hr = FindCompData.Execute(source, titleId, datasetId, new ulong[] { compId }, out compData);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure executing FindFromIds!  hr = " + hr);
                }
    
                
                // Don't bother progressing cancelled competitions
                //
                if (compData[0].Status != Comp.XONLINE_COMP_STATUS_ACTIVE)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Not slotting competition " + compId.ToString("x") + " as it's in the wrong state.  Status: " + compData[0].Status.ToString("x"));            
    
                    hr = HResult.S_OK;
                    goto end;
                }
                
                           
                round = (uint)compData[0].CurrentRound;
                nextRoundStart = DateTime.UtcNow;
                nextRoundApd = DateTime.UtcNow.AddMinutes(compData[0].ApdOffsetMin);
                nextRoundProgression = DateTime.UtcNow.AddMinutes(compData[0].RoundDurationMin);

                
                // close all of this round's brackets
                BracketUpdateStatus updateStatus = new BracketUpdateStatus();
                updateStatus.Id = (long)compId;
                updateStatus.BracketRound = round;
                updateStatus.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_COMPLETE;
                
                hr = updateStatus.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure updating bracket status for compId " + compId.ToString("x") + "! hr = " + hr);
                }
                
                // make sure there weren't any outages since last APD attempt
                //
                if (QueryHealth.WasServiceDown(DateTime.UtcNow.AddMinutes(-1 * (compData[0].RoundDurationMin - compData[0].ApdOffsetMin)), DateTime.UtcNow))
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Service downtime detected during progression period!   Delaying autoprogression!");

                    BracketSearchRound currentRound = new BracketSearchRound();
                    currentRound.Id = (long)compId;
                    currentRound.BracketRound = round;
                    
                    BracketSearchRoundResults[] currentRoundResults;
                    hr = currentRound.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out currentRoundResults);
                    if (HResult.Failed(hr))
                    {
                        throw new PluginException(hr, "Unexpected failure updating bracket status for compId " + compId.ToString("x") + "! hr = " + hr);
                    }
                    
                    DateTime bracketProgression = MLUtil.DelayRound(source, titleId, datasetId, compId, round, 
                                                          DateTime.FromFileTimeUtc(currentRoundResults[0].BracketStart), 
                                                          DateTime.FromFileTimeUtc(currentRoundResults[0].BracketApd), 
                                                          DateTime.FromFileTimeUtc(currentRoundResults[0].BracketEnd), 
                                                          compData[0].RoundDurationMin, 
                                                          compData[0].ApdOffsetMin, 
                                                          false);
                    
                        
                    // reschedule this round's APD
                    CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, compId,
                                Comp.XONLINE_COMP_ACTION_PROGRESSION, 
                                1, 
                                5 * 60,         // 5 minutes
                                bracketProgression,
                                0);

                    hr = HResult.XONLINE_S_COMP_SERVICE_OUTAGE;                                                                                                                                                  
                    goto end;
                }
                
                

                // give the boot to anyone still playing in this round
                //
                EntrantsUpdateActiveInRound updateRoundEntrants = new EntrantsUpdateActiveInRound();
                updateRoundEntrants.Id = (long)compId;
                updateRoundEntrants.EntrantCurrentRound = round;
                updateRoundEntrants.EntrantCurrentStatus = Comp.XONLINE_COMP_STATUS_ENTRANT_ELIMINATED;
                hr = updateRoundEntrants.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET);
                if (HResult.Failed(hr) && hr != HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    throw new PluginException(hr, "Unexpected failure updating user round status for compId " + compId.ToString("x") + "! hr = " + hr);
                }
                
                
                
                
                
                // update the # of slots and byes in each of next round brackets
                //
                Bracket[][] brackets = MLUtil.GetTopology(source, titleId, datasetId, compId, round + 1, round + 2);
                
                BracketUpdateidInfo updateInfo = new BracketUpdateidInfo();
                
                updateInfo.BracketStart = nextRoundStart.ToFileTimeUtc();
                updateInfo.BracketApd = nextRoundApd.ToFileTimeUtc();
                updateInfo.BracketEnd = nextRoundProgression.ToFileTimeUtc();

                for (int i = 0; i < brackets[0].Length; i++)
                {
                    brackets[0][i].Slots = MLUtil.GetSlotCount(brackets[0][i].Players);
                    
                    updateInfo.BracketByes = brackets[0][i].Slots - brackets[0][i].Players;
                    updateInfo.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_CHECKIN;
                    
                    if (brackets[0][i].Slots <= 1)
                    {
                        updateInfo.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_FINAL;    

                        if (brackets[0][i].Slots == 1)
                        {
                            EntrantsUpdateStatusInBracket updateBracketEntrants = new EntrantsUpdateStatusInBracket();
                            updateBracketEntrants.Id = (long)compId;
                            updateBracketEntrants.EntrantCurrentRound = round + 1;
                            updateBracketEntrants.EntrantCurrentIndex = i;
                            updateBracketEntrants.EntrantCurrentStatus = Comp.XONLINE_COMP_STATUS_ENTRANT_FINAL;
                            
                            hr = updateBracketEntrants.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET);
                            if (HResult.Failed(hr))
                            {
                                throw new PluginException(hr, "Unexpected failure updating entrant status for compId " + compId.ToString("x") + "! hr = " + hr);
                            }
                        }    
                    }                           
                    else
                    {
                        compComplete = false;
                    }    
                    
                        
                    hr = updateInfo.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, brackets[0][i].EntityId);
                    if (HResult.Failed(hr))
                    {
                        throw new PluginException(hr, "Unexpected failure updating bracket " + brackets[0][i].EntityId.ToString("x"));
                    }
                }
                        
                
                // update the # of slots in the the round following the next round.   This allows us to correctly determine
                // when a given player can play no further.
                //
                roundProgression = nextRoundStart;
                
                if (brackets.Length > 1)
                {
                    roundStart = roundProgression;
                    roundApd = roundStart.AddMinutes(compData[0].ApdOffsetMin);
                    roundProgression = roundStart.AddMinutes(compData[0].RoundDurationMin);
                    
                    updateInfo.BracketStart = roundStart.ToFileTimeUtc();
                    updateInfo.BracketEnd = roundProgression.ToFileTimeUtc();
                    updateInfo.BracketApd = roundApd.ToFileTimeUtc();
                    updateInfo.BracketByes = 0;
                
                    for (int i = 1; i < brackets[1].Length; i++)
                    {
                        if (brackets[0][i/2].Slots == 2)
                        {
                            // final bracket!
                            updateInfo.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_FINAL;
                        }
                        else
                        {
                            updateInfo.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_PRE_INIT;
                        }    
                            
                        
                        // only update if something has changed..
                        if (updateInfo.BracketStatus != brackets[1][i].Status ||
                            updateInfo.BracketStart <= (long)brackets[1][i].Start - 10000000 ||    // allow for a minute slop in times..
                            updateInfo.BracketStart >= (long)brackets[1][i].Start + 10000000)
                        {
                            Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Updating bracket " + (round + 2) + "/" + i + " with new time or status");
                            hr = updateInfo.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, brackets[1][i].EntityId);
                            if (HResult.Failed(hr))
                            {
                                throw new PluginException(hr, "Unexpected failure updating bracket " + brackets[1][i].EntityId.ToString("x"));
                            }
                        }
                    }            
                }    
                            
                
                // see if the comp is complete
                if (MLUtil.IsEveryoneDone(source, titleId, datasetId, compId))
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Last of the results submitted, competition is complete!");
                    MLUtil.CompleteComp(source, titleId, datasetId, compId, compData[0]);
                }
                else
                {
                    // update current round, status for comp
                    UpdateidCompRound updateRound = new UpdateidCompRound();
                    
                    updateRound.CurrentRound = round + 1;
                    updateRound.Status = (compComplete ? Comp.XONLINE_COMP_STATUS_BRACKET_COMPLETE : Comp.XONLINE_COMP_STATUS_ACTIVE);
                    
                    hr = updateRound.Execute(source, titleId, userId, teamId, datasetId, compId);
                    if (HResult.Failed(hr))
                    {
                        throw new PluginException(hr, "Unexpected failure updating comp round for compId " + compId.ToString("x") + ": hr = " + hr);
                    }


                    // schedule next round auto-progression job
                    //
                    CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, compId,
                                    Comp.XONLINE_COMP_ACTION_AUTO_PROGRESSION, 
                                    1, 
                                    5 * 60,         // 5 minutes
                                    nextRoundApd,
                                    0);
                }

                    
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionProgression complete *******");
            }
            catch(XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch(Exception e)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "SLT",
                              hr.ToString(),
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"),
                              compId.ToString("x16"),
                              entrants.ToString("x"),
                              byes.ToString("x"),
                              totalResults.ToString("x")
                      }));          

                counters.EndRequest(HResult.Failed(hr));
            }
end:
            return hr;
        }
        
        public static HResult ActionCleanup(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong compId, Hashtable ctx)
        {
            CleanupCounters counters = new CleanupCounters(titleId);

            HResult hr = HResult.S_OK;
            FindCompDataResults[] compData;
            
            try
            {
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionCleanup *******");
                
                // Service only method. Source.Server flag must be set
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
                
                hr = FindCompData.Execute(source, titleId, datasetId, new ulong[] { compId }, out compData);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure executing FindFromIds!  hr = " + hr);
                }
                
                if (compData[0].Status != Comp.XONLINE_COMP_STATUS_CANCELED && compData[0].Status != Comp.XONLINE_COMP_STATUS_COMPLETE)
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, "Attempt to clean up competition " + compId.ToString("x") + " but it's still active!");
                }
                
                // delete the bracket leaderboards
                //
                BracketSearchLeaderboards findLbs = new BracketSearchLeaderboards();
                BracketSearchLeaderboardsResults[] compLbs;
                
                findLbs.Id = (long)compId;
                hr = findLbs.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out compLbs);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure searching for competition leaderboards!");
                }
                
                if (compLbs != null)
                {
                    for (int i = 0; i < compLbs.Length; i++)
                    {
                        CompUtil.DeleteLeaderboard(titleId, (uint)compLbs[i].BracketLeaderboard);
                    }
                }
                
                // delete the comp leaderboards
                //
                if (compData[0].LeaderboardId0 != 0)
                {
                    CompUtil.DeleteLeaderboard(titleId, (uint)compData[0].LeaderboardId0);
                }
                if (compData[0].LeaderboardId1 != 0)
                {
                    CompUtil.DeleteLeaderboard(titleId, (uint)compData[0].LeaderboardId1);
                }
                if (compData[0].LeaderboardId2 != 0)
                {
                    CompUtil.DeleteLeaderboard(titleId, (uint)compData[0].LeaderboardId2);
                }
                
                // delete brackets
                //
                BracketRemoveComp removeBrackets = new BracketRemoveComp();
                removeBrackets.Id = (long)compId;
                hr = removeBrackets.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET);
                if (HResult.Failed(hr) && hr != HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    throw new PluginException(hr, "Unexpected failure deleteing brackets for comp " + compId.ToString("x") + " hr = " + hr);
                }
                
                    
                // delete entrants
                //
                EntrantsRemoveComp removeEntrants = new EntrantsRemoveComp();
                removeEntrants.Id = (long)compId;
                hr = removeEntrants.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET);
                if (HResult.Failed(hr) && hr != HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    throw new PluginException(hr, "Unexpected failure deleteing entrants for comp " + compId.ToString("x") + " hr = " + hr);
                }
                
                
                // bye-bye comp!
                //
                hr = Dataset.RemoveId(source, titleId, userId, teamId, datasetId, compId);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure deleteing entrants for comp " + compId.ToString("x") + " hr = " + hr);
                }
            }    
            catch(XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionCleanup complete *******");
                
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "DEL", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"),
                              compId.ToString("x"),
                              userId.ToString("x"),
                              teamId.ToString("x")
                        }));       
            

                counters.EndRequest(HResult.Failed(hr));
            }
            
            return hr;       
                
        }    


        
        public static HResult ActionSubmitResults(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong compId, QueryAttribute[] attribs, Hashtable ctx)        
        {
            SubmitResultsCounters counters = new SubmitResultsCounters(titleId);

            HResult         hr = HResult.XONLINE_E_COMP_ERROR;
            long            round = -1;
            long            index = -1;
            long            newIndex = -1;
            ulong           puid  = 0;
            bool            isTeam = false;
            bool            isWinner = false;
            long            score = 0;
            long            status;
            StringBuilder   puidstr = new StringBuilder();
            
            bool            winnersBracketUpdated = false;
            bool            losersBracketUpdated = false;
            ulong[]         updatedPuids = new ulong[attribs.Length];
            long[]          puidScores = new long[attribs.Length];
            string          err = "";            
            int             numWinners = 0;
            int             numLosers = 0;
        
            try
            {
    
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionSubmitResults *******");
                
                
                // Service only method. Source.Server flag must be set
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    return HResult.XONLINE_E_COMP_ACCESS_DENIED;
                }
                
                // count the number of winners and losers
                //
                
                foreach (QueryAttribute attrib in attribs)
                {
                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_EVENT_WINNER:
                        numWinners++;
                        break;
                        
                    case Comp.XONLINE_COMP_ATTR_EVENT_LOSER:
                        numLosers++;
                        break;                    
                        
                    default:
                        throw new PluginException(HResult.E_INVALIDARG, XEvent.Id.MC_BAD_PARAMETER_4,
                            "Invalid attribute " + attrib.Id.ToString("x") + " passed to multilevel SubmitResults!  " +  
                            "Only XONLINE_COMP_ATTR_EVENT_WINNER and XONLINE_COMP_ATTR_EVENT_LOSER are allowed!");
                    }
                }
                
                // make sure there's at least one winner and one loser
                // (progression depends on this)
                if (numWinners == 0 || numLosers == 0)
                { 
                    throw new PluginException(HResult.E_INVALIDARG, XEvent.Id.MC_BAD_PARAMETER_5,
                        "Missing " + (numLosers == 0 ? "loser" : "winner") + " puid!   Qt least one of each must be specified.");
                }    
                
                // find info about the comp 
                //
                FindCompDataResults[] compData;
                hr = FindCompData.Execute(source, titleId, datasetId, new ulong[] { compId }, out compData);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure executing FindFromIds!  hr = " + hr);
                }
                
                
                isTeam = (compData[0].IsTeamComp == 1);
                
                
                // Validate Attbribute Params
                for (int i = 0; i < attribs.Length; i++)
                {
                    QueryAttribute attrib = attribs[i];

                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_EVENT_WINNER:
                        puid = (ulong)attrib.lValue;
                        isWinner = true;
                        break;
                        
                    case Comp.XONLINE_COMP_ATTR_EVENT_LOSER:
                        puid = (ulong)attrib.lValue;
                        isWinner = false;
                        break;                    
                        
                    }
    
                    XRLUtil.VerifyParam(puid != 0, "Submitting Results for Event with puid = 0!\r\n" + QueryUtil.DumpAttribs(attribs));
    
                    // note: this check is done here (instead of outside the loop) so we can have a puid to log the hr to.
                    //
                    if (compData[0].Status == Comp.XONLINE_COMP_STATUS_PRE_INIT)
                    {
                        throw new PluginException(HResult.XONLINE_E_COMP_TOO_EARLY, "Score submitted before comp starts!");
                    }
                    
    
                    //            
                    // Verify that the people reported in the submission for the event are in the arbitration BundledAuthData header
                    //
                    MLUtil.verifyTicket(puid, (BundledAuthData)ctx["bundledAuth"], (TeamTickets)ctx["bundledtickets"]);
                    
                
                    if (XRLUtil.IsTeamPuid(puid) != isTeam)
                    {
                        throw new PluginException(HResult.XONLINE_E_COMP_INVALID_ENTRANT_TYPE, "A team was specified for a non-team competition, or a user was specified for a team competition");
                    }    

                    EntrantsSearchPuidResults entrant = MLUtil.GetEntrant(source, titleId, datasetId, compId, puid);
                
                
                    // make sure they're in the same round
                    //
                    if (round == -1) 
                    {
                        round = entrant.EntrantCurrentRound;
                        
                        if (round < compData[0].CurrentRound)
                        {
                            throw new PluginException(HResult.XONLINE_E_COMP_CHECKIN_BAD_EVENT, "Results submitted for a round prior to the current competition round!");
                        }
                    }    
                        
                    if (index == -1) 
                        index = entrant.EntrantCurrentIndex;
                        
                    if (entrant.EntrantCurrentRound != round ||
                        entrant.EntrantCurrentIndex != index)
                    {
                        throw new PluginException(HResult.XONLINE_E_COMP_CHECKIN_BAD_EVENT, "Player's round/bracket does not match the others!\r\n" + 
                                            "puid " + puid.ToString("x") + " in bracket " + entrant.EntrantCurrentRound + "/" + entrant.EntrantCurrentIndex + "\r\n" +
                                            "others in bracket " + round + "/" + index + "\r\n");
                    }                    

                    puidScores[i] = entrant.EntrantScore;
                    score = MLUtil.UpdateScoreWithWin(entrant.EntrantScore, (uint)round);
                    newIndex = (isWinner ? index * 2 : index * 2 + 1);
                    
                    
                    
                    status = Comp.XONLINE_COMP_STATUS_ENTRANT_REGISTERED;
                    
                
                    // update entrant's round
                    MLUtil.updateEntrantRound(source, titleId, datasetId, compId, puid, round + 1, newIndex, score, status, HResult.S_OK);
                    updatedPuids[i] = puid;
                    
                    puidstr.Append(puid.ToString("x") + "-" + (isWinner ? "W" : "L") + ",");
                    
                }    
                
                // finally, update the brackets
                //                
                MLUtil.updateBracketEntrants(source, titleId, datasetId, compId, round + 1, index * 2, numWinners, true, compData[0].RoundDurationMin, compData[0].ApdOffsetMin, ctx);
                winnersBracketUpdated = true;
                MLUtil.updateBracketEntrants(source, titleId, datasetId, compId, round + 1, index * 2 + 1, numLosers, true, compData[0].RoundDurationMin, compData[0].ApdOffsetMin, ctx);
                losersBracketUpdated = true;
                
                
                if (numWinners == 1 || numLosers == 1)
                {
                    // one or more people finished the comp, see if the comp is complete
                    if (MLUtil.IsEveryoneDone(source, titleId, datasetId, compId))
                    {
                        Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Last of the results submitted, competition is complete!");
                        MLUtil.CompleteComp(source, titleId, datasetId, compId, compData[0]);
                    }
                }
                    
            }    
            catch (XRLException xe)
            {
                err = xe.Message;
                hr = xe.HResult;
                throw;
            }
            catch (Exception e)
            {
                err = e.Message;
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "******* ActionSubmitResults complete *******");
                
                if (HResult.Failed(hr))
                {
                    TitleLog.Write(XOService.Query, titleId, XomLogLevel.Error, "An error occured submitting results for competition " + compId.ToString("x") + ":\r\n" + err);

                    // attempt to roll back any existing work
                    if (winnersBracketUpdated == true)
                    {
                        try {
                            MLUtil.updateBracketEntrants(source, titleId, datasetId, compId, round + 1, index * 2, -1 * numWinners, false, 0, 0, ctx);
                        } 
                        catch(Exception e1) {
                            EventBuilder.LogEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_38, "Failed to roll back update of winner bracket (source failure to follow)", e1);
                        }    
                    }
                    
                    if (losersBracketUpdated == true)
                    {
                        try {
                            MLUtil.updateBracketEntrants(source, titleId, datasetId, compId, round + 1, index * 2, -1 * numLosers, false, 0, 0, ctx);
                        } 
                        catch(Exception e1) {
                            EventBuilder.LogEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_39, "Failed to roll back update of winner bracket (source failure to follow)", e1);
                        }    
                    }
                    
                    // update users with error hr
                    for (int i = 0; i < attribs.Length; i++)
                    {
                        QueryAttribute attrib = attribs[i];
                        try {
                            if (Array.IndexOf(updatedPuids, (ulong)attrib.lValue) != -1)
                            {
                                MLUtil.updateEntrantRound(source, titleId, datasetId, compId, (ulong)updatedPuids[i], round, index, puidScores[i], Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING, hr);
                            }
                            else
                            {
                                MLUtil.updateEntrantStatus(source, titleId, datasetId, compId, (ulong)attrib.lValue, Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING, hr);
                            }     
                        }
                        catch(Exception e5) {
                            EventBuilder.LogEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_40, "Failed to update winner status (source failure to follow)", e5);
                        }
                    }    
                }
            
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "SBR", 
                              hr.ToString(), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"),
                              compId.ToString("x"),
                              round.ToString("x"),
                              index.ToString("x"),
                              isTeam.ToString(),
                              puidstr.ToString()
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
            
            return hr;
        }
    
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\ml\00000673.ml.cs ===
// Autogenerated from 00000673.ml.xqs on 2/9/2004 6:16:23 PM// DO NOT MAKE CHANGES TO THIS FILE!  They will not be reflected the next time 
// this file is generated.

using System;
using xonline.common.protocol;
using xonline.server.querylib;
using xonline.common.service;
using xonline.common.plugins;

namespace xonline.server.comps.query 
{
    public class AddMultilevelComp
    {
        public QueryAttribute[] Attribs;
        public AddMultilevelComp()
        {
            Attribs = new QueryAttribute[20];
            Attribs[0] = new QueryAttribute(0x8011000e, "");// XONLINE_COMP_ATTR_NAME
            Attribs[1] = new QueryAttribute(0x80010001, 0); // XONLINE_COMP_ATTR_REG_OPEN
            Attribs[2] = new QueryAttribute(0x80010002, 0); // XONLINE_COMP_ATTR_REG_CLOSE
            Attribs[3] = new QueryAttribute(0x80010003, 0); // XONLINE_COMP_ATTR_COMP_START
            Attribs[4] = new QueryAttribute(0x80010004, 0); // XONLINE_COMP_ATTR_COMP_CLEANUP_DAYS
            Attribs[5] = new QueryAttribute(0x8001000b, 0); // XONLINE_COMP_ATTR_ROUND_DURATION_MIN
            Attribs[6] = new QueryAttribute(0x8001000f, 0); // XONLINE_COMP_ATTR_APD_OFFSET_MIN
            Attribs[7] = new QueryAttribute(0x80010012, 0); // XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS
            Attribs[8] = new QueryAttribute(0x80010013, 0); // XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS
            Attribs[9] = new QueryAttribute(0x80010014, 0); // XONLINE_COMP_ATTR_MIN_SLOTS
            Attribs[10] = new QueryAttribute(0x80010010, 0);// XONLINE_COMP_ATTR_IS_TEAM_COMP
            Attribs[11] = new QueryAttribute(0x00000001, 0);// MapId
            Attribs[12] = new QueryAttribute(0x00200003, new byte[] { 0x0} );// Icon
            Attribs[13] = new QueryAttribute(0x80010018, 0);// XONLINE_COMP_ATTR_PUBLIC_ENTRANTS
            Attribs[14] = new QueryAttribute(0x80010019, 0);// XONLINE_COMP_ATTR_PRIVATE_ENTRANTS
            Attribs[15] = new QueryAttribute(0x80010009, 0);// XONLINE_COMP_ATTR_CURRENT_ROUND
            Attribs[16] = new QueryAttribute(0x8001001d, 0);// XONLINE_COMP_ATTR_STATUS
            Attribs[17] = new QueryAttribute(0x80010020, 0);// XONLINE_COMP_ATTR_LEADERBOARD_ID0
            Attribs[18] = new QueryAttribute(0x80010021, 0);// XONLINE_COMP_ATTR_LEADERBOARD_ID1
            Attribs[19] = new QueryAttribute(0x80010022, 0);// XONLINE_COMP_ATTR_LEADERBOARD_ID2
        }

        public string Name
        {
            get { return (string)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long RegOpen
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long RegClose
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long CompStart
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long CompCleanupDays
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long RoundDurationMin
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

        public long ApdOffsetMin
        {
            get { return (long)Attribs[6].Value; }
            set { Attribs[6].Value = value; }
        }

        public long MaxPublicSlots
        {
            get { return (long)Attribs[7].Value; }
            set { Attribs[7].Value = value; }
        }

        public long MaxPrivateSlots
        {
            get { return (long)Attribs[8].Value; }
            set { Attribs[8].Value = value; }
        }

        public long MinSlots
        {
            get { return (long)Attribs[9].Value; }
            set { Attribs[9].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)Attribs[10].Value; }
            set { Attribs[10].Value = value; }
        }

        public long Mapid
        {
            get { return (long)Attribs[11].Value; }
            set { Attribs[11].Value = value; }
        }

        public byte[] Icon
        {
            get { return (byte[])Attribs[12].Value; }
            set { Attribs[12].Value = value; }
        }

        public long PublicEntrants
        {
            get { return (long)Attribs[13].Value; }
            set { Attribs[13].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)Attribs[14].Value; }
            set { Attribs[14].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)Attribs[15].Value; }
            set { Attribs[15].Value = value; }
        }

        public long Status
        {
            get { return (long)Attribs[16].Value; }
            set { Attribs[16].Value = value; }
        }

        public long LeaderboardId0
        {
            get { return (long)Attribs[17].Value; }
            set { Attribs[17].Value = value; }
        }

        public long LeaderboardId1
        {
            get { return (long)Attribs[18].Value; }
            set { Attribs[18].Value = value; }
        }

        public long LeaderboardId2
        {
            get { return (long)Attribs[19].Value; }
            set { Attribs[19].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class FindCompData
    {
        public static QueryAttributeSpec[] Specs;

        static FindCompData()
        {

            Specs = new QueryAttributeSpec[17];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80000001, 0);     // bi_owner_id
            Specs[2] = new QueryAttributeSpec(0x80010012, 30);    // XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS
            Specs[3] = new QueryAttributeSpec(0x80010013, 30);    // XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS
            Specs[4] = new QueryAttributeSpec(0x80010014, 30);    // XONLINE_COMP_ATTR_MIN_SLOTS
            Specs[5] = new QueryAttributeSpec(0x80010010, 30);    // XONLINE_COMP_ATTR_IS_TEAM_COMP
            Specs[6] = new QueryAttributeSpec(0x80010018, 30);    // XONLINE_COMP_ATTR_PUBLIC_ENTRANTS
            Specs[7] = new QueryAttributeSpec(0x80010019, 30);    // XONLINE_COMP_ATTR_PRIVATE_ENTRANTS
            Specs[8] = new QueryAttributeSpec(0x8001000b, 30);    // XONLINE_COMP_ATTR_ROUND_DURATION_MIN
            Specs[9] = new QueryAttributeSpec(0x8001000f, 30);    // XONLINE_COMP_ATTR_APD_OFFSET_MIN
            Specs[10] = new QueryAttributeSpec(0x8001001d, 30);   // XONLINE_COMP_ATTR_STATUS
            Specs[11] = new QueryAttributeSpec(0x80010003, 30);   // XONLINE_COMP_ATTR_COMP_START
            Specs[12] = new QueryAttributeSpec(0x80010004, 30);   // XONLINE_COMP_ATTR_COMP_CLEANUP_DAYS
            Specs[13] = new QueryAttributeSpec(0x80010009, 30);   // XONLINE_COMP_ATTR_CURRENT_ROUND
            Specs[14] = new QueryAttributeSpec(0x80010020, 30);   // XONLINE_COMP_ATTR_LEADERBOARD_ID0
            Specs[15] = new QueryAttributeSpec(0x80010021, 30);   // XONLINE_COMP_ATTR_LEADERBOARD_ID1
            Specs[16] = new QueryAttributeSpec(0x80010022, 30);   // XONLINE_COMP_ATTR_LEADERBOARD_ID2
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out FindCompDataResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x10001, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new FindCompDataResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindCompDataResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out FindCompDataResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x10001, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new FindCompDataResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindCompDataResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class FindCompDataResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public FindCompDataResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public FindCompDataResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long Owner
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long MaxPublicSlots
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long MaxPrivateSlots
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long MinSlots
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long PublicEntrants
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long RoundDurationMin
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long ApdOffsetMin
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long Status
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long CompStart
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

        public long CompCleanupDays
        {
            get { return (long)_attribs[12 + _startIndex].Value; }
            set { _attribs[12 + _startIndex].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)_attribs[13 + _startIndex].Value; }
            set { _attribs[13 + _startIndex].Value = value; }
        }

        public long LeaderboardId0
        {
            get { return (long)_attribs[14 + _startIndex].Value; }
            set { _attribs[14 + _startIndex].Value = value; }
        }

        public long LeaderboardId1
        {
            get { return (long)_attribs[15 + _startIndex].Value; }
            set { _attribs[15 + _startIndex].Value = value; }
        }

        public long LeaderboardId2
        {
            get { return (long)_attribs[16 + _startIndex].Value; }
            set { _attribs[16 + _startIndex].Value = value; }
        }

    }

    public class UpdateComp
    {
        public QueryAttribute[] Attribs;

         public UpdateComp()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x8201001d, 0);       // XONLINE_COMP_ATTR_STATUS
            Attribs[1] = new QueryAttribute(0x82010009, 0);       // XONLINE_COMP_ATTR_CURRENT_ROUND
            Attribs[2] = new QueryAttribute(0x82010020, 0);       // XONLINE_COMP_ATTR_LEADERBOARD_ID0
            Attribs[3] = new QueryAttribute(0x82010021, 0);       // XONLINE_COMP_ATTR_LEADERBOARD_ID1
            Attribs[4] = new QueryAttribute(0x82010022, 0);       // XONLINE_COMP_ATTR_LEADERBOARD_ID2
        }

        public long Status
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long CurrentRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long LeaderboardId0
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long LeaderboardId1
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long LeaderboardId2
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#endif
    }

    public class UpdateCompStatus
    {
        public QueryAttribute[] Attribs;

         public UpdateCompStatus()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x8201001d, 0);       // XONLINE_COMP_ATTR_STATUS
        }

        public long Status
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10003, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10003, entityId, Attribs);
        }
#endif
    }

    public class UpdateidCompRound
    {
        public QueryAttribute[] Attribs;

         public UpdateidCompRound()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010009, 0);       // XONLINE_COMP_ATTR_CURRENT_ROUND
            Attribs[1] = new QueryAttribute(0x8201001d, 0);       // XONLINE_COMP_ATTR_STATUS
        }

        public long CurrentRound
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long Status
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#endif
    }

    public class AdjustEntrantCounts
    {
        public QueryAttribute[] Attribs;

         public AdjustEntrantCounts()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x82010018, 0);       // XONLINE_COMP_ATTR_PUBLIC_ENTRANTS
            Attribs[1] = new QueryAttribute(0x82010019, 0);       // XONLINE_COMP_ATTR_PRIVATE_ENTRANTS
            Attribs[2] = new QueryAttribute(0x82010002, 0);       // XONLINE_COMP_ATTR_REG_CLOSE
            Attribs[3] = new QueryAttribute(0x82010010, 0);       // XONLINE_COMP_ATTR_IS_TEAM_COMP
        }

        public long PublicEntrants
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long PrivateEntrants
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long RegClose
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long IsTeamComp
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#endif
    }

    public class AdjustTimeFields
    {
        public QueryAttribute[] Attribs;

         public AdjustTimeFields()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010023);          // XONLINE_COMP_ATTR_DEBUG_ADJUST_TIME
        }

        public long DebugAdjustTime
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#endif
    }

    public class AddMultilevelEntrants
    {
        public QueryAttribute[] Attribs;
        public AddMultilevelEntrants()
        {
            Attribs = new QueryAttribute[9];
            Attribs[0] = new QueryAttribute(0x80010000, 0); // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x80020000, 0); // XONLINE_COMP_ATTR_ENTRANT_ID
            Attribs[2] = new QueryAttribute(0x80020004, 0); // XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT
            Attribs[3] = new QueryAttribute(0x80020003, 0); // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Attribs[4] = new QueryAttribute(0x8002000a, 0); // XONLINE_COMP_ATTR_ENTRANT_CURRENT_INDEX
            Attribs[5] = new QueryAttribute(0x8002000c, 0); // XONLINE_COMP_ATTR_ENTRANT_SCORE
            Attribs[6] = new QueryAttribute(0x80020001, 0); // XONLINE_COMP_ATTR_ENTRANT_STATUS
            Attribs[7] = new QueryAttribute(0x8023000d, new byte[] { 0x0} );// XONLINE_COMP_ATTR_ENTRANT_TRUST
            Attribs[8] = new QueryAttribute(0x8002000b, 0); // XONLINE_COMP_ATTR_ENTRANT_HRESULT
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantId
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long EntrantPrivateSlot
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long EntrantCurrentIndex
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long EntrantScore
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

        public long EntrantStatus
        {
            get { return (long)Attribs[6].Value; }
            set { Attribs[6].Value = value; }
        }

        public byte[] EntrantTrust
        {
            get { return (byte[])Attribs[7].Value; }
            set { Attribs[7].Value = value; }
        }

        public long EntrantHresult
        {
            get { return (long)Attribs[8].Value; }
            set { Attribs[8].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class EntrantsFinalStandings
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public EntrantsFinalStandings()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID

            Specs = new QueryAttributeSpec[6];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80020000, 30);    // XONLINE_COMP_ATTR_ENTRANT_ID
            Specs[2] = new QueryAttributeSpec(0x80020004, 30);    // XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT
            Specs[3] = new QueryAttributeSpec(0x80020003, 30);    // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Specs[4] = new QueryAttributeSpec(0x8002000a, 30);    // XONLINE_COMP_ATTR_ENTRANT_CURRENT_INDEX
            Specs[5] = new QueryAttributeSpec(0x8002000c, 30);    // XONLINE_COMP_ATTR_ENTRANT_SCORE
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out EntrantsFinalStandingsResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EntrantsFinalStandingsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EntrantsFinalStandingsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EntrantsFinalStandingsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out EntrantsFinalStandingsResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EntrantsFinalStandingsResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EntrantsFinalStandingsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EntrantsFinalStandingsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class EntrantsFinalStandingsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public EntrantsFinalStandingsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public EntrantsFinalStandingsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long EntrantId
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long EntrantPrivateSlot
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long EntrantCurrentIndex
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long EntrantScore
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

    }

    public class EntrantsSearchPuid
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public EntrantsSearchPuid()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82020000, 0);       // XONLINE_COMP_ATTR_ENTRANT_PUID

            Specs = new QueryAttributeSpec[7];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80020004, 30);    // XONLINE_COMP_ATTR_ENTRANT_PRIVATE_SLOT
            Specs[2] = new QueryAttributeSpec(0x80020003, 30);    // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Specs[3] = new QueryAttributeSpec(0x8002000a, 30);    // XONLINE_COMP_ATTR_ENTRANT_CURRENT_INDEX
            Specs[4] = new QueryAttributeSpec(0x8002000c, 30);    // XONLINE_COMP_ATTR_ENTRANT_SCORE
            Specs[5] = new QueryAttributeSpec(0x80020001, 30);    // XONLINE_COMP_ATTR_ENTRANT_STATUS
            Specs[6] = new QueryAttributeSpec(0x8002000b, 30);    // XONLINE_COMP_ATTR_ENTRANT_HRESULT
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantPuid
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out EntrantsSearchPuidResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EntrantsSearchPuidResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EntrantsSearchPuidResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EntrantsSearchPuidResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out EntrantsSearchPuidResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EntrantsSearchPuidResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EntrantsSearchPuidResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EntrantsSearchPuidResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class EntrantsSearchPuidResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public EntrantsSearchPuidResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public EntrantsSearchPuidResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long EntrantPrivateSlot
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long EntrantCurrentIndex
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long EntrantScore
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long EntrantStatus
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long EntrantHresult
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

    }

    public class EntrantsSearchStatus
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public EntrantsSearchStatus()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82020003, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Attribs[2] = new QueryAttribute(0x8202000a, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_INDEX
            Attribs[3] = new QueryAttribute(0x82020001, 0);       // XONLINE_COMP_ATTR_ENTRANT_STATUS

            Specs = new QueryAttributeSpec[4];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80020000, 30);    // XONLINE_COMP_ATTR_ENTRANT_ID
            Specs[2] = new QueryAttributeSpec(0x8023000d, 4);     // XONLINE_COMP_ATTR_ENTRANT_TRUST
            Specs[3] = new QueryAttributeSpec(0x8002000c, 30);    // XONLINE_COMP_ATTR_ENTRANT_SCORE
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long EntrantCurrentIndex
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long EntrantStatus
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out EntrantsSearchStatusResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EntrantsSearchStatusResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10002, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EntrantsSearchStatusResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EntrantsSearchStatusResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out EntrantsSearchStatusResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EntrantsSearchStatusResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10002, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EntrantsSearchStatusResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EntrantsSearchStatusResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class EntrantsSearchStatusResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public EntrantsSearchStatusResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public EntrantsSearchStatusResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long EntrantPuid
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public byte[] EntrantTrust
        {
            get { return (byte[])_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long EntrantScore
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

    }

    public class EntrantsSearchActive
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public EntrantsSearchActive()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID

            Specs = new QueryAttributeSpec[5];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80020003, 30);    // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Specs[2] = new QueryAttributeSpec(0x8002000a, 30);    // XONLINE_COMP_ATTR_ENTRANT_CURRENT_INDEX
            Specs[3] = new QueryAttributeSpec(0x8002000c, 30);    // XONLINE_COMP_ATTR_ENTRANT_SCORE
            Specs[4] = new QueryAttributeSpec(0x80020001, 30);    // XONLINE_COMP_ATTR_ENTRANT_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out EntrantsSearchActiveResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EntrantsSearchActiveResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10003, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EntrantsSearchActiveResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EntrantsSearchActiveResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out EntrantsSearchActiveResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out EntrantsSearchActiveResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10003, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new EntrantsSearchActiveResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new EntrantsSearchActiveResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class EntrantsSearchActiveResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public EntrantsSearchActiveResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public EntrantsSearchActiveResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long EntrantCurrentIndex
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long EntrantScore
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long EntrantStatus
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

    }

    public class EntrantsUpdateRound
    {
        public QueryAttribute[] Attribs;

         public EntrantsUpdateRound()
        {
            Attribs = new QueryAttribute[7];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82020000, 0);       // XONLINE_COMP_ATTR_ENTRANT_PUID
            Attribs[2] = new QueryAttribute(0x82020003, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Attribs[3] = new QueryAttribute(0x8202000a, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_INDEX
            Attribs[4] = new QueryAttribute(0x8202000c, 0);       // XONLINE_COMP_ATTR_ENTRANT_SCORE
            Attribs[5] = new QueryAttribute(0x82020001, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_STATUS
            Attribs[6] = new QueryAttribute(0x8202000b, 0);       // XONLINE_COMP_ATTR_ENTRANT_HRESULT
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantPuid
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long EntrantCurrentIndex
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long EntrantScore
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long EntrantCurrentStatus
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

        public long EntrantHresult
        {
            get { return (long)Attribs[6].Value; }
            set { Attribs[6].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10001, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10001, Attribs);
        }
#endif
    }

    public class EntrantsUpdateStatus
    {
        public QueryAttribute[] Attribs;

         public EntrantsUpdateStatus()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82020000, 0);       // XONLINE_COMP_ATTR_ENTRANT_PUID
            Attribs[2] = new QueryAttribute(0x82020001, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_STATUS
            Attribs[3] = new QueryAttribute(0x8202000b, 0);       // XONLINE_COMP_ATTR_ENTRANT_HRESULT
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantPuid
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long EntrantCurrentStatus
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long EntrantHresult
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10002, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10002, Attribs);
        }
#endif
    }

    public class EntrantsUpdateActiveInRound
    {
        public QueryAttribute[] Attribs;

         public EntrantsUpdateActiveInRound()
        {
            Attribs = new QueryAttribute[3];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82020003, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Attribs[2] = new QueryAttribute(0x82020001, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long EntrantCurrentStatus
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10003, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10003, Attribs);
        }
#endif
    }

    public class EntrantsUpdateStatusInBracket
    {
        public QueryAttribute[] Attribs;

         public EntrantsUpdateStatusInBracket()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82020003, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Attribs[2] = new QueryAttribute(0x8202000a, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_INDEX
            Attribs[3] = new QueryAttribute(0x82020001, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long EntrantCurrentIndex
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long EntrantCurrentStatus
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10004, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10004, Attribs);
        }
#endif
    }

    public class EntrantsUpdateStatusInRound
    {
        public QueryAttribute[] Attribs;

         public EntrantsUpdateStatusInRound()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82020003, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_ROUND
            Attribs[2] = new QueryAttribute(0x82020001, 0);       // XONLINE_COMP_ATTR_ENTRANT_CURRENT_STATUS
            Attribs[3] = new QueryAttribute(0x82020021);          // XONLINE_COMP_ATTR_ENTRANT_NEW_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long EntrantCurrentRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long EntrantCurrentStatus
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long EntrantNewStatus
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10005, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10005, Attribs);
        }
#endif
    }

    public class EntrantsRemoveComp
    {
        public QueryAttribute[] Attribs;

         public EntrantsRemoveComp()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x10000, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x10000, Attribs);        
        }
#endif
    }

    public class EntrantsCustomIsEveryoneDone
    {
        public QueryAttribute[] Attribs;

         public EntrantsCustomIsEveryoneDone()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x10005, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10005, entityId, Attribs);
        }
#endif
    }

    public class AddMultilevelBrackets
    {
        public QueryAttribute[] Attribs;
        public AddMultilevelBrackets()
        {
            Attribs = new QueryAttribute[12];
            Attribs[0] = new QueryAttribute(0x80010000, 0); // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x80040001, 0); // XONLINE_COMP_ATTR_BRACKET_ROUND
            Attribs[2] = new QueryAttribute(0x80040002, 0); // XONLINE_COMP_ATTR_BRACKET_INDEX
            Attribs[3] = new QueryAttribute(0x80040004, 0); // XONLINE_COMP_ATTR_BRACKET_ENTRANTS
            Attribs[4] = new QueryAttribute(0x80040007, 0); // XONLINE_COMP_ATTR_BRACKET_CHECKED_IN
            Attribs[5] = new QueryAttribute(0x80040005, 0); // XONLINE_COMP_ATTR_BRACKET_BYES
            Attribs[6] = new QueryAttribute(0x80040006, 0); // XONLINE_COMP_ATTR_BRACKET_BYES_GRANTED
            Attribs[7] = new QueryAttribute(0x80040009, 0); // XONLINE_COMP_ATTR_BRACKET_START
            Attribs[8] = new QueryAttribute(0x8004000b, 0); // XONLINE_COMP_ATTR_BRACKET_APD
            Attribs[9] = new QueryAttribute(0x80040008, 0); // XONLINE_COMP_ATTR_BRACKET_END
            Attribs[10] = new QueryAttribute(0x8004000c, 0);// XONLINE_COMP_ATTR_BRACKET_LEADERBOARD
            Attribs[11] = new QueryAttribute(0x8004000a, 0);// XONLINE_COMP_ATTR_BRACKET_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long BracketIndex
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long BracketEntrants
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long BracketCheckedIn
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long BracketByes
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

        public long BracketByesGranted
        {
            get { return (long)Attribs[6].Value; }
            set { Attribs[6].Value = value; }
        }

        public long BracketStart
        {
            get { return (long)Attribs[7].Value; }
            set { Attribs[7].Value = value; }
        }

        public long BracketApd
        {
            get { return (long)Attribs[8].Value; }
            set { Attribs[8].Value = value; }
        }

        public long BracketEnd
        {
            get { return (long)Attribs[9].Value; }
            set { Attribs[9].Value = value; }
        }

        public long BracketLeaderboard
        {
            get { return (long)Attribs[10].Value; }
            set { Attribs[10].Value = value; }
        }

        public long BracketStatus
        {
            get { return (long)Attribs[11].Value; }
            set { Attribs[11].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class BracketSearchComp
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public BracketSearchComp()
        {
            Attribs = new QueryAttribute[3];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x820400f0);          // XONLINE_COMP_ATTR_BRACKET_MIN_ROUND
            Attribs[2] = new QueryAttribute(0x820400f1);          // XONLINE_COMP_ATTR_BRACKET_MAX_ROUND

            Specs = new QueryAttributeSpec[12];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80040001, 30);    // XONLINE_COMP_ATTR_BRACKET_ROUND
            Specs[2] = new QueryAttributeSpec(0x80040002, 30);    // XONLINE_COMP_ATTR_BRACKET_INDEX
            Specs[3] = new QueryAttributeSpec(0x80040004, 30);    // XONLINE_COMP_ATTR_BRACKET_ENTRANTS
            Specs[4] = new QueryAttributeSpec(0x80040007, 30);    // XONLINE_COMP_ATTR_BRACKET_CHECKED_IN
            Specs[5] = new QueryAttributeSpec(0x80040005, 30);    // XONLINE_COMP_ATTR_BRACKET_BYES
            Specs[6] = new QueryAttributeSpec(0x80040006, 30);    // XONLINE_COMP_ATTR_BRACKET_BYES_GRANTED
            Specs[7] = new QueryAttributeSpec(0x80040009, 30);    // XONLINE_COMP_ATTR_BRACKET_START
            Specs[8] = new QueryAttributeSpec(0x80040008, 30);    // XONLINE_COMP_ATTR_BRACKET_END
            Specs[9] = new QueryAttributeSpec(0x8004000b, 30);    // XONLINE_COMP_ATTR_BRACKET_APD
            Specs[10] = new QueryAttributeSpec(0x8004000c, 30);   // XONLINE_COMP_ATTR_BRACKET_LEADERBOARD
            Specs[11] = new QueryAttributeSpec(0x8004000a, 30);   // XONLINE_COMP_ATTR_BRACKET_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketMinRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long BracketMaxRound
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out BracketSearchCompResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out BracketSearchCompResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new BracketSearchCompResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new BracketSearchCompResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out BracketSearchCompResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out BracketSearchCompResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10001, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new BracketSearchCompResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new BracketSearchCompResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class BracketSearchCompResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public BracketSearchCompResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public BracketSearchCompResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long BracketRound
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long BracketIndex
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long BracketEntrants
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long BracketCheckedIn
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long BracketByes
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long BracketByesGranted
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long BracketStart
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long BracketEnd
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long BracketApd
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long BracketLeaderboard
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

        public long BracketStatus
        {
            get { return (long)_attribs[11 + _startIndex].Value; }
            set { _attribs[11 + _startIndex].Value = value; }
        }

    }

    public class BracketSearchBracket
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public BracketSearchBracket()
        {
            Attribs = new QueryAttribute[3];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82040001, 0);       // XONLINE_COMP_ATTR_BRACKET_ROUND
            Attribs[2] = new QueryAttribute(0x82040002, 0);       // XONLINE_COMP_ATTR_BRACKET_INDEX

            Specs = new QueryAttributeSpec[10];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80040004, 30);    // XONLINE_COMP_ATTR_BRACKET_ENTRANTS
            Specs[2] = new QueryAttributeSpec(0x80040007, 30);    // XONLINE_COMP_ATTR_BRACKET_CHECKED_IN
            Specs[3] = new QueryAttributeSpec(0x80040005, 30);    // XONLINE_COMP_ATTR_BRACKET_BYES
            Specs[4] = new QueryAttributeSpec(0x80040006, 30);    // XONLINE_COMP_ATTR_BRACKET_BYES_GRANTED
            Specs[5] = new QueryAttributeSpec(0x80040009, 30);    // XONLINE_COMP_ATTR_BRACKET_START
            Specs[6] = new QueryAttributeSpec(0x80040008, 30);    // XONLINE_COMP_ATTR_BRACKET_END
            Specs[7] = new QueryAttributeSpec(0x8004000b, 30);    // XONLINE_COMP_ATTR_BRACKET_APD
            Specs[8] = new QueryAttributeSpec(0x8004000c, 30);    // XONLINE_COMP_ATTR_BRACKET_LEADERBOARD
            Specs[9] = new QueryAttributeSpec(0x8004000a, 30);    // XONLINE_COMP_ATTR_BRACKET_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long BracketIndex
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out BracketSearchBracketResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out BracketSearchBracketResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10002, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new BracketSearchBracketResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new BracketSearchBracketResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out BracketSearchBracketResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out BracketSearchBracketResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10002, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new BracketSearchBracketResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new BracketSearchBracketResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class BracketSearchBracketResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public BracketSearchBracketResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public BracketSearchBracketResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long BracketEntrants
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long BracketCheckedIn
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long BracketByes
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long BracketByesGranted
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long BracketStart
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long BracketEnd
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long BracketApd
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long BracketLeaderboard
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long BracketStatus
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

    }

    public class BracketSearchRound
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public BracketSearchRound()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82040001, 0);       // XONLINE_COMP_ATTR_BRACKET_ROUND

            Specs = new QueryAttributeSpec[11];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80040002, 30);    // XONLINE_COMP_ATTR_BRACKET_INDEX
            Specs[2] = new QueryAttributeSpec(0x80040004, 30);    // XONLINE_COMP_ATTR_BRACKET_ENTRANTS
            Specs[3] = new QueryAttributeSpec(0x80040007, 30);    // XONLINE_COMP_ATTR_BRACKET_CHECKED_IN
            Specs[4] = new QueryAttributeSpec(0x80040005, 30);    // XONLINE_COMP_ATTR_BRACKET_BYES
            Specs[5] = new QueryAttributeSpec(0x80040006, 30);    // XONLINE_COMP_ATTR_BRACKET_BYES_GRANTED
            Specs[6] = new QueryAttributeSpec(0x80040009, 30);    // XONLINE_COMP_ATTR_BRACKET_START
            Specs[7] = new QueryAttributeSpec(0x80040008, 30);    // XONLINE_COMP_ATTR_BRACKET_END
            Specs[8] = new QueryAttributeSpec(0x8004000b, 30);    // XONLINE_COMP_ATTR_BRACKET_APD
            Specs[9] = new QueryAttributeSpec(0x8004000c, 30);    // XONLINE_COMP_ATTR_BRACKET_LEADERBOARD
            Specs[10] = new QueryAttributeSpec(0x8004000a, 30);   // XONLINE_COMP_ATTR_BRACKET_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out BracketSearchRoundResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out BracketSearchRoundResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10003, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new BracketSearchRoundResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new BracketSearchRoundResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out BracketSearchRoundResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out BracketSearchRoundResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10003, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new BracketSearchRoundResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new BracketSearchRoundResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class BracketSearchRoundResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public BracketSearchRoundResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public BracketSearchRoundResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long BracketIndex
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long BracketEntrants
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public long BracketCheckedIn
        {
            get { return (long)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public long BracketByes
        {
            get { return (long)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public long BracketByesGranted
        {
            get { return (long)_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

        public long BracketStart
        {
            get { return (long)_attribs[6 + _startIndex].Value; }
            set { _attribs[6 + _startIndex].Value = value; }
        }

        public long BracketEnd
        {
            get { return (long)_attribs[7 + _startIndex].Value; }
            set { _attribs[7 + _startIndex].Value = value; }
        }

        public long BracketApd
        {
            get { return (long)_attribs[8 + _startIndex].Value; }
            set { _attribs[8 + _startIndex].Value = value; }
        }

        public long BracketLeaderboard
        {
            get { return (long)_attribs[9 + _startIndex].Value; }
            set { _attribs[9 + _startIndex].Value = value; }
        }

        public long BracketStatus
        {
            get { return (long)_attribs[10 + _startIndex].Value; }
            set { _attribs[10 + _startIndex].Value = value; }
        }

    }

    public class BracketSearchLeaderboards
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public BracketSearchLeaderboards()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID

            Specs = new QueryAttributeSpec[2];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x8004000c, 30);    // XONLINE_COMP_ATTR_BRACKET_LEADERBOARD
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out BracketSearchLeaderboardsResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out BracketSearchLeaderboardsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x10004, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new BracketSearchLeaderboardsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new BracketSearchLeaderboardsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out BracketSearchLeaderboardsResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out BracketSearchLeaderboardsResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x10004, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new BracketSearchLeaderboardsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new BracketSearchLeaderboardsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class BracketSearchLeaderboardsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public BracketSearchLeaderboardsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public BracketSearchLeaderboardsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long BracketLeaderboard
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

    }

    public class BracketUpdateidInfo
    {
        public QueryAttribute[] Attribs;

         public BracketUpdateidInfo()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x82040005, 0);       // XONLINE_COMP_ATTR_BRACKET_BYES
            Attribs[1] = new QueryAttribute(0x82040009, 0);       // XONLINE_COMP_ATTR_BRACKET_START
            Attribs[2] = new QueryAttribute(0x82040008, 0);       // XONLINE_COMP_ATTR_BRACKET_END
            Attribs[3] = new QueryAttribute(0x8204000b, 0);       // XONLINE_COMP_ATTR_BRACKET_APD
            Attribs[4] = new QueryAttribute(0x8204000a, 0);       // XONLINE_COMP_ATTR_BRACKET_STATUS
        }

        public long BracketByes
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketStart
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long BracketEnd
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long BracketApd
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long BracketStatus
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#endif
    }

    public class BracketUpdateStatus
    {
        public QueryAttribute[] Attribs;

         public BracketUpdateStatus()
        {
            Attribs = new QueryAttribute[3];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82040001, 0);       // XONLINE_COMP_ATTR_BRACKET_ROUND
            Attribs[2] = new QueryAttribute(0x8204000a, 0);       // XONLINE_COMP_ATTR_BRACKET_STATUS
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long BracketStatus
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10003, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10003, Attribs);
        }
#endif
    }

    public class BracketUpdateRoundTimes
    {
        public QueryAttribute[] Attribs;

         public BracketUpdateRoundTimes()
        {
            Attribs = new QueryAttribute[6];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82040001, 0);       // XONLINE_COMP_ATTR_BRACKET_ROUND
            Attribs[2] = new QueryAttribute(0x8204000a, 0);       // XONLINE_COMP_ATTR_BRACKET_STATUS
            Attribs[3] = new QueryAttribute(0x82040009, 0);       // XONLINE_COMP_ATTR_BRACKET_START
            Attribs[4] = new QueryAttribute(0x82040008, 0);       // XONLINE_COMP_ATTR_BRACKET_END
            Attribs[5] = new QueryAttribute(0x8204000b, 0);       // XONLINE_COMP_ATTR_BRACKET_APD
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long BracketStatus
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long BracketStart
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long BracketEnd
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

        public long BracketApd
        {
            get { return (long)Attribs[5].Value; }
            set { Attribs[5].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x10004, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x10004, Attribs);
        }
#endif
    }

    public class BracketRemoveComp
    {
        public QueryAttribute[] Attribs;

         public BracketRemoveComp()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x10001, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x10001, Attribs);        
        }
#endif
    }

    public class BracketCustomUpdateEntrants
    {
        public QueryAttribute[] Attribs;

         public BracketCustomUpdateEntrants()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82040001, 0);       // XONLINE_COMP_ATTR_BRACKET_ROUND
            Attribs[2] = new QueryAttribute(0x82040002, 0);       // XONLINE_COMP_ATTR_BRACKET_INDEX
            Attribs[3] = new QueryAttribute(0x82040004, 0);       // XONLINE_COMP_ATTR_BRACKET_ENTRANTS
            Attribs[4] = new QueryAttribute(0x82040008, 0);       // XONLINE_COMP_ATTR_BRACKET_END
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long BracketIndex
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long BracketEntrants
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long BracketEnd
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10001, entityId, Attribs);
        }
#endif
    }

    public class BracketCustomUpdateByes
    {
        public QueryAttribute[] Attribs;

         public BracketCustomUpdateByes()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82040001, 0);       // XONLINE_COMP_ATTR_BRACKET_ROUND
            Attribs[2] = new QueryAttribute(0x82040002, 0);       // XONLINE_COMP_ATTR_BRACKET_INDEX
            Attribs[3] = new QueryAttribute(0x82040006, 0);       // XONLINE_COMP_ATTR_BRACKET_BYES_GRANTED
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long BracketRound
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long BracketIndex
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public long BracketByesGranted
        {
            get { return (long)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x10002, entityId, Attribs);
        }
#endif
    }

    public class AdjustBracketTimeFields
    {
        public QueryAttribute[] Attribs;

         public AdjustBracketTimeFields()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x82010000, 0);       // XONLINE_COMP_ATTR_ID
            Attribs[1] = new QueryAttribute(0x82010023);          // XONLINE_COMP_ATTR_DEBUG_ADJUST_TIME
        }

        public long Id
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long DebugAdjustTime
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x1000a, entityId, Attribs);
        }
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\ml\mlperfcounters.cs ===
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// XQRY (ML) Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.protocol;

namespace xonline.server.comps.query 
{
    public class AddCompetitionCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public AddCompetitionCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            AddCompetitionCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            AddCompetitionCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                AddCompetitionCountersCategory.Current(hexTitleId).FailuresPerSecond,
                AddCompetitionCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            AddCompetitionCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            AddCompetitionCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                AddCompetitionCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                AddCompetitionCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): AddCompetition", "Query (ML): AddCompetition" )]
	public class AddCompetitionCountersCategory : XomPerformanceCounterCategory
	{
		
        static public AddCompetitionCountersCategory _instance = new AddCompetitionCountersCategory();
        static public AddCompetitionCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (AddCompetitionCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // AddCompetition request counters

		[XomPerformanceCounterAttr(
			"AddCompetition requests/sec", 
			"AddCompetition requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"AddCompetition total", 
			"Total AddCompetition requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"AddCompetition failures/sec", 
			"Number of unsuccessful results returned by AddCompetition per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"AddCompetition total failures", 
			"Total number unsuccessful results returned by AddCompetition in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"AddCompetition avg. execution time", 
			"AddCompetition Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
    public class JoinCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public JoinCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            JoinCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            JoinCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                JoinCountersCategory.Current(hexTitleId).FailuresPerSecond,
                JoinCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            JoinCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            JoinCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                JoinCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                JoinCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): Join", "Query (ML): Join" )]
	public class JoinCountersCategory : XomPerformanceCounterCategory
	{
		
        static public JoinCountersCategory _instance = new JoinCountersCategory();
        static public JoinCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (JoinCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Join request counters

		[XomPerformanceCounterAttr(
			"Join requests/sec", 
			"Join requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Join total", 
			"Total Join requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Join failures/sec", 
			"Number of unsuccessful results returned by Join per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Join total failures", 
			"Total number unsuccessful results returned by Join in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Join avg. execution time", 
			"Join Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class WithdrawCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public WithdrawCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            WithdrawCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            WithdrawCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                WithdrawCountersCategory.Current(hexTitleId).FailuresPerSecond,
                WithdrawCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            WithdrawCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            WithdrawCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                WithdrawCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                WithdrawCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): Withdraw", "Query (ML): Withdraw" )]
	public class WithdrawCountersCategory : XomPerformanceCounterCategory
	{
		
        static public WithdrawCountersCategory _instance = new WithdrawCountersCategory();
        static public WithdrawCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (WithdrawCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Withdraw request counters

		[XomPerformanceCounterAttr(
			"Withdraw requests/sec", 
			"Withdraw requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Withdraw total", 
			"Total Withdraw requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Withdraw failures/sec", 
			"Number of unsuccessful results returned by Withdraw per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Withdraw total failures", 
			"Total number unsuccessful results returned by Withdraw in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Withdraw avg. execution time", 
			"Withdraw Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class CheckinCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public CheckinCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            CheckinCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            CheckinCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                CheckinCountersCategory.Current(hexTitleId).FailuresPerSecond,
                CheckinCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            CheckinCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            CheckinCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                CheckinCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                CheckinCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): Checkin", "Query (ML): Checkin" )]
	public class CheckinCountersCategory : XomPerformanceCounterCategory
	{
		
        static public CheckinCountersCategory _instance = new CheckinCountersCategory();
        static public CheckinCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (CheckinCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Checkin request counters

		[XomPerformanceCounterAttr(
			"Checkin requests/sec", 
			"Checkin requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Checkin total", 
			"Total Checkin requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Checkin failures/sec", 
			"Number of unsuccessful results returned by Checkin per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Checkin total failures", 
			"Total number unsuccessful results returned by Checkin in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Checkin avg. execution time", 
			"Checkin Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class CancelCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public CancelCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            CancelCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            CancelCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                CancelCountersCategory.Current(hexTitleId).FailuresPerSecond,
                CancelCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            CancelCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            CancelCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                CancelCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                CancelCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): Cancel", "Query (ML): Cancel" )]
	public class CancelCountersCategory : XomPerformanceCounterCategory
	{
		
        static public CancelCountersCategory _instance = new CancelCountersCategory();
        static public CancelCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (CancelCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Cancel request counters

		[XomPerformanceCounterAttr(
			"Cancel requests/sec", 
			"Cancel requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Cancel total", 
			"Total Cancel requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Cancel failures/sec", 
			"Number of unsuccessful results returned by Cancel per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Cancel total failures", 
			"Total number unsuccessful results returned by Cancel in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Cancel avg. execution time", 
			"Cancel Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class RequestByeCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public RequestByeCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            RequestByeCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            RequestByeCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                RequestByeCountersCategory.Current(hexTitleId).FailuresPerSecond,
                RequestByeCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            RequestByeCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            RequestByeCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                RequestByeCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                RequestByeCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): RequestBye", "Query (ML): RequestBye" )]
	public class RequestByeCountersCategory : XomPerformanceCounterCategory
	{
		
        static public RequestByeCountersCategory _instance = new RequestByeCountersCategory();
        static public RequestByeCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (RequestByeCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // RequestBye request counters

		[XomPerformanceCounterAttr(
			"RequestBye requests/sec", 
			"RequestBye requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"RequestBye total", 
			"Total RequestBye requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"RequestBye failures/sec", 
			"Number of unsuccessful results returned by RequestBye per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"RequestBye total failures", 
			"Total number unsuccessful results returned by RequestBye in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"RequestBye avg. execution time", 
			"RequestBye Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class RequestPassCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public RequestPassCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            RequestPassCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            RequestPassCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                RequestPassCountersCategory.Current(hexTitleId).FailuresPerSecond,
                RequestPassCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            RequestPassCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            RequestPassCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                RequestPassCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                RequestPassCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): RequestPass", "Query (ML): RequestPass" )]
	public class RequestPassCountersCategory : XomPerformanceCounterCategory
	{
		
        static public RequestPassCountersCategory _instance = new RequestPassCountersCategory();
        static public RequestPassCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (RequestPassCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // RequestPass request counters

		[XomPerformanceCounterAttr(
			"RequestPass requests/sec", 
			"RequestPass requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"RequestPass total", 
			"Total RequestPass requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"RequestPass failures/sec", 
			"Number of unsuccessful results returned by RequestPass per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"RequestPass total failures", 
			"Total number unsuccessful results returned by RequestPass in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"RequestPass avg. execution time", 
			"RequestPass Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class AdvanceTimeCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public AdvanceTimeCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            AdvanceTimeCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            AdvanceTimeCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                AdvanceTimeCountersCategory.Current(hexTitleId).FailuresPerSecond,
                AdvanceTimeCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            AdvanceTimeCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            AdvanceTimeCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                AdvanceTimeCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                AdvanceTimeCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): AdvanceTime", "Query (ML): AdvanceTime" )]
	public class AdvanceTimeCountersCategory : XomPerformanceCounterCategory
	{
		
        static public AdvanceTimeCountersCategory _instance = new AdvanceTimeCountersCategory();
        static public AdvanceTimeCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (AdvanceTimeCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // AdvanceTime request counters

		[XomPerformanceCounterAttr(
			"AdvanceTime requests/sec", 
			"AdvanceTime requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"AdvanceTime total", 
			"Total AdvanceTime requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"AdvanceTime failures/sec", 
			"Number of unsuccessful results returned by AdvanceTime per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"AdvanceTime total failures", 
			"Total number unsuccessful results returned by AdvanceTime in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"AdvanceTime avg. execution time", 
			"AdvanceTime Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    




    public class SlottingCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public SlottingCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            SlottingCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            SlottingCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                SlottingCountersCategory.Current(hexTitleId).FailuresPerSecond,
                SlottingCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            SlottingCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SlottingCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                SlottingCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                SlottingCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): Slotting", "Query (ML): Slotting" )]
	public class SlottingCountersCategory : XomPerformanceCounterCategory
	{
		
        static public SlottingCountersCategory _instance = new SlottingCountersCategory();
        static public SlottingCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (SlottingCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Slotting request counters

		[XomPerformanceCounterAttr(
			"Slotting requests/sec", 
			"Slotting requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Slotting total", 
			"Total Slotting requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Slotting failures/sec", 
			"Number of unsuccessful results returned by Slotting per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Slotting total failures", 
			"Total number unsuccessful results returned by Slotting in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Slotting avg. execution time", 
			"Slotting Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class AutoProgressionCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public AutoProgressionCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            AutoProgressionCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            AutoProgressionCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                AutoProgressionCountersCategory.Current(hexTitleId).FailuresPerSecond,
                AutoProgressionCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            AutoProgressionCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            AutoProgressionCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                AutoProgressionCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                AutoProgressionCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): AutoProgression", "Query (ML): AutoProgression" )]
	public class AutoProgressionCountersCategory : XomPerformanceCounterCategory
	{
		
        static public AutoProgressionCountersCategory _instance = new AutoProgressionCountersCategory();
        static public AutoProgressionCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (AutoProgressionCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // AutoProgression request counters

		[XomPerformanceCounterAttr(
			"AutoProgression requests/sec", 
			"AutoProgression requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"AutoProgression total", 
			"Total AutoProgression requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"AutoProgression failures/sec", 
			"Number of unsuccessful results returned by AutoProgression per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"AutoProgression total failures", 
			"Total number unsuccessful results returned by AutoProgression in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"AutoProgression avg. execution time", 
			"AutoProgression Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class ProgressionCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public ProgressionCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            ProgressionCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            ProgressionCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                ProgressionCountersCategory.Current(hexTitleId).FailuresPerSecond,
                ProgressionCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            ProgressionCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            ProgressionCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                ProgressionCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                ProgressionCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): Progression", "Query (ML): Progression" )]
	public class ProgressionCountersCategory : XomPerformanceCounterCategory
	{
		
        static public ProgressionCountersCategory _instance = new ProgressionCountersCategory();
        static public ProgressionCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (ProgressionCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Progression request counters

		[XomPerformanceCounterAttr(
			"Progression requests/sec", 
			"Progression requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Progression total", 
			"Total Progression requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Progression failures/sec", 
			"Number of unsuccessful results returned by Progression per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Progression total failures", 
			"Total number unsuccessful results returned by Progression in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Progression avg. execution time", 
			"Progression Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class CleanupCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public CleanupCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            CleanupCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            CleanupCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                CleanupCountersCategory.Current(hexTitleId).FailuresPerSecond,
                CleanupCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            CleanupCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            CleanupCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                CleanupCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                CleanupCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): Cleanup", "Query (ML): Cleanup" )]
	public class CleanupCountersCategory : XomPerformanceCounterCategory
	{
		
        static public CleanupCountersCategory _instance = new CleanupCountersCategory();
        static public CleanupCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (CleanupCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Cleanup request counters

		[XomPerformanceCounterAttr(
			"Cleanup requests/sec", 
			"Cleanup requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Cleanup total", 
			"Total Cleanup requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Cleanup failures/sec", 
			"Number of unsuccessful results returned by Cleanup per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Cleanup total failures", 
			"Total number unsuccessful results returned by Cleanup in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Cleanup avg. execution time", 
			"Cleanup Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    public class SubmitResultsCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        public SubmitResultsCounters(uint titleId)
        {
            StartRequest(titleId);
        }
                
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x");
            timeElapsed = new XomRequestTimeElapsed();
            
            SubmitResultsCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            SubmitResultsCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                SubmitResultsCountersCategory.Current(hexTitleId).FailuresPerSecond,
                SubmitResultsCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            SubmitResultsCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SubmitResultsCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                SubmitResultsCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                SubmitResultsCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query (ML): SubmitResults", "Query (ML): SubmitResults" )]
	public class SubmitResultsCountersCategory : XomPerformanceCounterCategory
	{
		
        static public SubmitResultsCountersCategory _instance = new SubmitResultsCountersCategory();
        static public SubmitResultsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (SubmitResultsCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // SubmitResults request counters

		[XomPerformanceCounterAttr(
			"SubmitResults requests/sec", 
			"SubmitResults requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"SubmitResults total", 
			"Total SubmitResults requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"SubmitResults failures/sec", 
			"Number of unsuccessful results returned by SubmitResults per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"SubmitResults total failures", 
			"Total number unsuccessful results returned by SubmitResults in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"SubmitResults avg. execution time", 
			"SubmitResults Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\ml\multilevel.cs ===
// 
// Base.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Query Plugin base classes
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.comps.common;
using xonline.server.comps.query;
using xonline.common.mgmt;
using xonline.server.query.fd;

[assembly: XomAreaDefinition(XomAreaName.mltrace)]
[assembly: XomAreaDefinition(XomAreaName.mllog)]


namespace xonline.server.comps.query 
{
    public class Multilevel : IQueryAdd, IQuerySelect
    {
            
        public HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, Hashtable ctx)
        {
            AddCompetitionCounters counters = new AddCompetitionCounters(titleId);

            DateTime regOpen      = DateTime.UtcNow;
            DateTime regClose     = DateTime.UtcNow;
            DateTime compStart    = DateTime.UtcNow;
            long     cleanupDays  = Comp.XONLINE_COMP_DEFAULT_CLEANUP_DAYS;
            ulong    duration     = 0;
            ulong    apDeadline   = 0;
            ulong    publicSlots  = 0;
            ulong    privateSlots = 0;
            ulong    minSlots     = 0;
            ulong    isTeamComp   = 0;
            ulong    teamSize     = 0;
            int      nonce        = (new Random()).Next();
            uint     hr           = HResult.S_OK;

            
            Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "** Multilevel BeforeAdd **");
            
            try
            {
                ctx["nonce"] = nonce;
                
                foreach (QueryAttribute attrib in attribs)
                {
                    switch (attrib.Id)
                    {
                    case Comp.XONLINE_COMP_ATTR_REG_OPEN:
                        regOpen = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
                        
                    case Comp.XONLINE_COMP_ATTR_REG_CLOSE:
                        regClose = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
                        
                    case Comp.XONLINE_COMP_ATTR_COMP_START:
                        compStart = DateTime.FromFileTimeUtc(attrib.lValue);
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_COMP_CLEANUP:
                        cleanupDays = attrib.lValue;
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_ROUND_DURATION_MIN:
                        duration = (ulong)attrib.lValue;
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_APD_OFFSET_MIN:
                        apDeadline = (ulong)attrib.lValue;
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS:
                        publicSlots = (ulong)attrib.lValue;
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS:
                        privateSlots = (ulong)attrib.lValue;
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_MIN_SLOTS:
                        minSlots = (ulong)attrib.lValue;
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP:
                        isTeamComp = (ulong)attrib.lValue;
                        break;
                    
                    case Comp.XONLINE_COMP_ATTR_TEAM_SIZE:
                        teamSize = (ulong)attrib.lValue;
                        break;

                    case Comp.XONLINE_COMP_ATTR_PUBLIC_ENTRANTS:
                    case Comp.XONLINE_COMP_ATTR_PRIVATE_ENTRANTS:
                    case Comp.XONLINE_COMP_ATTR_CURRENT_ROUND:
                    case Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_START:
                    case Comp.XONLINE_COMP_ATTR_STATUS:
                        XRLUtil.VerifyParam((ulong)attrib.lValue == 0,                       "Service controlled attribute must be 0!\r\n"                + QueryUtil.DumpAttribs(attribs));
                        break;
                    }
                }    
                
                //
                // perform sanity check on the provided attribute values
                //
                if (((uint)source & ((uint)Source.Server)) == 0)
                {
                    XRLUtil.VerifyParam(privateSlots + publicSlots <= 1024, "Specified private/public slots are more than the max slots for a user-created tournament!\r\n"   + QueryUtil.DumpAttribs(attribs));
                    
                    if (ctx.Contains("roundLeaderboardTemplateId"))
                    {
                        XRLUtil.VerifyParam((long)ctx["roundLeaderboardTemplateId"] != 0, "Attempt to create a user-created tournament which has a roundLeaderboardTemplateId defined! Check the XQS file\r\n" + QueryUtil.DumpAttribs(attribs));
                    }  

                    
                }
                else
                {
                    XRLUtil.VerifyParam(privateSlots + publicSlots <= Comp.XONLINE_COMP_ML_MAX_SLOTS, "Specified private/public slots are more than the max slots for a publisher-created tournament!\r\n"   + QueryUtil.DumpAttribs(attribs));
                }
    
                
                XRLUtil.VerifyParam(regClose > DateTime.UtcNow,                               "Specified registration close occurs in the past!\r\n"                  + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(regClose > regOpen,                                       "Specified registration close occurs before regOpen!\r\n"               + QueryUtil.DumpAttribs(attribs));
                // REVIEW: should there be a min delta between reg open and close?
                XRLUtil.VerifyParam(compStart >= regClose,                                    "Specified competition start time is before registration close!\r\n"    + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(duration >= Comp.XONLINE_COMP_ML_MIN_DURATION_MINS,       "Specified duration is less than the mininum allowed duration!\r\n"     + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(cleanupDays <= Comp.XONLINE_COMP_MAX_CLEANUP_DAYS,        "Specified cleanup days is more than the allowed max!\r\n"              + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(cleanupDays >= Comp.XONLINE_COMP_MIN_CLEANUP_DAYS,        "Specified cleanup days is less than the allowed min!\r\n"              + QueryUtil.DumpAttribs(attribs));
                
                // REVIEW: does it make sense for apDeadline == duration?
                XRLUtil.VerifyParam(apDeadline <= duration,                                   "Specified autoprogression deadline is longer than round duration!\r\n" + QueryUtil.DumpAttribs(attribs));
                XRLUtil.VerifyParam(apDeadline >= Comp.XONLINE_COMP_ML_MIN_AUTOPROGRESS_MINS, "Specified autoprogress deadline is too short!\r\n"                     + QueryUtil.DumpAttribs(attribs));
                
                XRLUtil.VerifyParam((isTeamComp == 0 && teamId == 0) || (isTeamComp == 1 && teamId != 0), "Team should only be specified for team competitions!\r\n"  + QueryUtil.DumpAttribs(attribs));
            
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "CBA", 
                              hr.ToString("x8"), 
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              regOpen.ToString(),
                              regClose.ToString(),
                              compStart.ToString(),
                              cleanupDays.ToString(),
                              duration.ToString("x"),
                              apDeadline.ToString(),
                              publicSlots.ToString("x"),
                              privateSlots.ToString("x"),
                              minSlots.ToString("x"),
                              isTeamComp.ToString("x"),
                              teamSize.ToString("x"),
                              nonce.ToString("x")
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
                

            return hr;
        }
        
            
        
        public HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            AddJobRequest  addCronJobReq  = new AddJobRequest();
            AddJobResponse addCronJobResp = new AddJobResponse();
            XRLObject2     xrlo           = (XRLObject2)addCronJobResp;
            Hashtable      jobctx         = new Hashtable();
            uint           hr             = HResult.S_OK;
            int            jobId          = 0;
            int nonce = 0;
            
            Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Multilevel Competition " + entityId + " added by user " + userId);            
            TitleLog.Write(XOService.Query, titleId, XomLogLevel.Info, "Multilevel Competition " + entityId + " added by user " + userId);
            
            try
            {
                nonce = (int)ctx["nonce"];
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.QUERY_PLUGIN_DATA_ERROR_45, e, "Failed to parse nonce in ctx object.");
                // this shouldn't fail the proceedure..
                nonce = -1;
            }                

            try
            {
                // add cron job to perform leaderboard resets and other init tasks 
                //
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Adding init job...");
                
                DateTime compStart = DateTime.FromFileTimeUtc(QueryUtil.GetAttributeValueInt64(attribs, Comp.XONLINE_COMP_ATTR_COMP_START));
                
                
                jobId = CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, entityId,
                                Comp.XONLINE_COMP_ACTION_SLOTTING, 
                                1, 
                                5 * 60,         // 5 minutes
                                compStart,
                                0);
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "... done, jobId=" + jobId);

            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "CAA", 
                              hr.ToString("x8"), 
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"),
                              jobId.ToString("x8"),
                              nonce.ToString("x")
                        }));       

            }
            
            return hr;
            
        }
        

        public static HResult  ActionJoin(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx, bool isPrivateSlot)
        {
            JoinCounters counters = new JoinCounters(titleId);

            uint            hr = HResult.XONLINE_E_COMP_ERROR;
            
            bool isTeam = (teamId != 0);
            EntrantsSearchPuid findPrevEntry;
            EntrantsSearchPuidResults[] results;
            uint totalResults;
            
            AddMultilevelEntrants addEntrant;
            ulong entrantEntityId = 0;
            

            try
            {

                // 
                // Look for dupes
                //
                
                findPrevEntry = new EntrantsSearchPuid();
                findPrevEntry.Id = (long)entityId;
                findPrevEntry.EntrantPuid = (long)(teamId == 0 ? userId : teamId);
                
                hr = findPrevEntry.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, 
                            0, 
                            1, 
                            out totalResults, 
                            out results);
                
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "Failure searching for existing entry in comp " + entityId.ToString("x") + "!");            
                    goto end;
                }
                
                if (totalResults > 0)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "User/team " + (teamId == 0 ? userId : teamId) + " already exists in competition " + entityId.ToString("x"));            
                    hr = HResult.XONLINE_E_COMP_ALREADY_REGISTERED;
                    goto end;
                }    

                    
                //
                // Increment Entrant Count for new entry
                //
                hr = MLUtil.UpdateEntrantCount(source, titleId, 0, 0, datasetId, entityId, isPrivateSlot ? 0: 1, isPrivateSlot ? 1 : 0, isTeam);         
    
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                  
                  
                try 
                {
                    addEntrant = new AddMultilevelEntrants();
                    addEntrant.Id = (long)entityId;    
                    addEntrant.EntrantId = (long)(teamId == 0 ? userId : teamId);
                    addEntrant.EntrantCurrentRound = 0;
                    addEntrant.EntrantPrivateSlot = (isPrivateSlot ? 1 : 0);
                    addEntrant.EntrantStatus = Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING;
                    if (AuthToggle.On)
                    {
                        addEntrant.EntrantTrust = CompUtil.BlobFromTrust(SGInfo.Current.GetUserTrust((ulong)findPrevEntry.EntrantPuid));
                    }
                    
                    addEntrant.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, out entrantEntityId);
                    
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "[Multilevel " + entityId.ToString("X") + "] " + 
                            "Added " + findPrevEntry.EntrantPuid.ToString("x") + " to Entrants table");
                }
                catch (Exception e)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "[Multilevel " + entityId.ToString("X") + "] " + 
                            "Entrants Add method threw adding user " +  userId);            
                    
                    if (e is XRLException)
                    {
                        hr = ((XRLException)e).HResult;
                    }    
                    else
                    {
                        hr = HResult.XONLINE_E_COMP_ERROR;
                    }    

                     
                    // Re-increment the Entrants counter in the competiton dataset                    
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "Attemping rollback of entrant count..");                    
                    MLUtil.UpdateEntrantCount(source, titleId, 0, 0, datasetId, entityId, isPrivateSlot ? 0: -1, isPrivateSlot ? -1: 0, isTeam);         
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "Rollback completed.");                    
                    
                    throw new XRLException(hr, XEvent.Id.COMPS_CODE_51, "Successfully rolled back entrant count", e);
                }
                
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "Entrants Add method failed for competition " + entityId + " adding user " +  userId + ". HR = " + hr.ToString("x8"));            

                    // Re-increment the Entrants counter in the competiton dataset
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "Attemping rollback of entrant count..");                    
                    MLUtil.UpdateEntrantCount(source, titleId, 0, 0, datasetId, entityId, isPrivateSlot ? 0: -1, isPrivateSlot ? -1: 0, isTeam);                    
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "Rollback completed.");                    
                }
                else
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Single mltrace Competition " + entityId + " Joined by " + userId);            
                }
                
                
end:            
                ;    
                
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|, new string[] {
                              "JIN",
                              hr.ToString("x8"),
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"),
                              entityId.ToString("x16"),
                              isPrivateSlot.ToString(),
                              entrantEntityId.ToString("x16") 
                      }));          

                counters.EndRequest(HResult.Failed(hr));
            }
                      
                
                
            return hr;
        }
                

        public static HResult  ActionWithdraw(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            WithdrawCounters counters = new WithdrawCounters(titleId);

            HResult                  hr;
            uint                     totalResults;
            
            
            EntrantsSearchPuid       findPrevEntry;
            EntrantsSearchPuidResults[] results;
            
            //
            // Find the Entrant in the Entrants table. We need to do this to find out if they are occupying a 
            //  private or public slot in the competition. 
            //


            findPrevEntry = new EntrantsSearchPuid();
            findPrevEntry.Id = (long)entityId;
            findPrevEntry.EntrantPuid = (long)(teamId == 0 ? userId : teamId);
            
            hr = findPrevEntry.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, 
                        0, 
                        1, 
                        out totalResults, 
                        out results);
                        
            if (HResult.Failed(hr) || totalResults == 0)
            {
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Failed to find user " + findPrevEntry.EntrantPuid.ToString("x8") + " attempting Withdraw from competition " + entityId.ToString("x8"));
                if (totalResults == 0) 
                {
                    hr = HResult.XONLINE_E_COMP_NOT_REGISTERED;
                }    
                
                goto err;
            }

            
            //
            // Test to see if we can legally withdraw from the competition still
            //
            hr = MLUtil.UpdateEntrantCount(source, titleId, 0, 0, datasetId, entityId, 0, 0, (teamId != 0));         

            if (HResult.Failed(hr))
            {
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "Entrants Withdraw method failed for competition " + entityId.ToString("8x") + " withdrawing user " +  userId.ToString("8x") + "Registration period is closed. Hr = " +  hr.ToString("8x") );            
                goto err;
            }


            //
            // Remove the user from the Entrants table
            //
            hr = Dataset.RemoveId(source & Source.Plugin, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, results[0].EntityId);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Entrants Withdraw method failed for competition " + entityId.ToString("8x") + " withdrawing user " +  userId.ToString("8x") + ". Hr = " +  hr.ToString("8x") );            
            }
            else
            {
                // Increment available slots in the competition
                hr = MLUtil.UpdateEntrantCount(source, titleId, 0, 0, datasetId, entityId, (int)(results[0].EntrantPrivateSlot == 1 ? 0 : -1), (int)(-1 * results[0].EntrantPrivateSlot), (teamId != 0));         
                // review: this technically shouldn't fail.  Should this be logged if it does?
                //   we'll also be left with an empty slot that can't be occupied..
                

                Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Single mltrace Competition " + entityId.ToString("8x") + " Withdrawn by " + userId.ToString("8x"));            
            }
            
err:
            counters.EndRequest(HResult.Failed(hr));
            return hr;
        }
        

        public static HResult  ActionCheckin(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong compId, Hashtable ctx)
        {
            CheckinCounters counters = new CheckinCounters(titleId);

            
            uint hr = HResult.XONLINE_E_COMP_ERROR;
            uint round = 0xffffffff;
            uint index = 0xffffffff;
            ulong puid = 0;
            
            try
            {
                puid = (userId == 0 ? teamId : userId);
                
                // make sure the service is good..
                if (QueryHealth.ServiceDown)
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_SERVICE_OUTAGE, XEvent.Id.QUERY_SERVER_HEALTH_WARNING_1,
                            "Service is currently DOWN according to NPDB.   Failing Checkin for comp " + compId.ToString("X"));
                }
                
                                                                                                      
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Verifying placement for user " + puid.ToString("x") + "..");
                
                EntrantsSearchPuid findEntrant = new EntrantsSearchPuid();
                EntrantsSearchPuidResults[] findEntrantResults;
                
                findEntrant.Id = (long)compId;
                findEntrant.EntrantPuid = (long)puid; 
                hr = findEntrant.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, out findEntrantResults);
                if (HResult.Failed(hr) || findEntrantResults == null)
                {
                    if (findEntrantResults == null) 
                        hr = HResult.XONLINE_E_COMP_NOT_REGISTERED;
                        
                    throw new PluginException(hr, "Failed to find entrant " + puid.ToString("X") + " for verficiation!  " + hr.ToString("x"));
                }
                            
                round = (uint)findEntrantResults[0].EntrantCurrentRound; 
                index = (uint)findEntrantResults[0].EntrantCurrentIndex; 
                
                // get the bracket entrant is currently playing in..
                
                BracketSearchBracket findBracket = new BracketSearchBracket();
                BracketSearchBracketResults[] findBracketResults = null;
                
                findBracket.Id = (long)compId;
                findBracket.BracketRound = round;
                findBracket.BracketIndex = index;
                
                hr = findBracket.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out findBracketResults);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Failed to find bracket " + round + "/" + index + " from entrant " + findEntrant.EntrantPuid.ToString("X") + "!  " + hr.ToString("x"));
                }
                
                if (findBracketResults == null)
                {   
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "User attempted to check in before competition began.");
                    hr = HResult.XONLINE_E_COMP_TOO_EARLY;
                    goto end;
                }
                
                if (findBracketResults[0].BracketStatus == Comp.XONLINE_COMP_STATUS_BRACKET_FINAL)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "User attempted to check in for a final bracket!");
                    hr = HResult.XONLINE_E_COMP_UNEXPECTED;
                    goto end;
                }
                                
                
                if (findEntrantResults[0].EntrantStatus == Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "User attempted to check in for a bracket in which they're already playing!");
                    // this is fine, there's nothing to do
                    hr = HResult.S_OK;
                    goto end;
                }
                
                if (findBracketResults[0].BracketStatus != Comp.XONLINE_COMP_STATUS_BRACKET_CHECKIN &&
                    findBracketResults[0].BracketStatus != Comp.XONLINE_COMP_STATUS_BRACKET_PRE_INIT)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "user attempted to check in for a bracket too late!");
                    hr = HResult.XONLINE_E_COMP_TOO_LATE;
                    goto end;
                }
                
                MLUtil.updateEntrantStatus(source, titleId, datasetId, compId, puid, Comp.XONLINE_COMP_STATUS_ENTRANT_PLAYING, HResult.S_OK);
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "User " +  puid.ToString("x") + " checked in!");
            
            }
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "CKN",
                              hr.ToString("x8"),
                              titleId.ToString("x8"),
                              userId.ToString("x16"),
                              teamId.ToString("x16"),
                              datasetId.ToString("x"),
                              compId.ToString("x16"),
                              round.ToString("x"),
                              index.ToString("x"),
                              QueryHealth.ServiceDown.ToString()
                      }));          

                counters.EndRequest(HResult.Failed(hr));
            }
end:
            return hr;


                
        }                
        
        public static HResult  ActionCancel(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx)
        {
            CancelCounters counters = new CancelCounters(titleId);

            uint        hr = HResult.S_OK;
            FindCompDataResults[] compData;
            
            try
            {
                hr = FindCompData.Execute(source, titleId, datasetId, new ulong[] { entityId }, out compData);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure executing FindFromIds!  0x" + hr.ToString("x"));
                }
    
    
                //
                // Update Competition entry to mark the competition as cancelled
                //
                MLUtil.CancelComp(source, titleId, datasetId, entityId, compData[0]);
            
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "DEL", 
                              hr.ToString("x8"), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"),
                              entityId.ToString("x"),
                              userId.ToString("x"),
                              teamId.ToString("x")
                        }));       
            

                counters.EndRequest(HResult.Failed(hr));
            }
            
            return hr;
        }

        
        public static HResult  ActionRequestBye(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong compId, Hashtable ctx)
        {
            RequestByeCounters counters = new RequestByeCounters(titleId);

            uint round = 0xfffffff;
            uint index = 0xfffffff;
            uint hr = HResult.XONLINE_E_COMP_ERROR;
            long score = 0;
            
            
            try
            {
                
                // get the player's current round/index
                //                    
                EntrantsSearchPuidResults entrant = MLUtil.GetEntrant(source, titleId, datasetId, compId, (userId == 0 ? teamId : userId));
                
                
                round = (uint)entrant.EntrantCurrentRound;
                index = (uint)entrant.EntrantCurrentIndex;
                
                
                // call custom update byes proc
                //
                hr = MLUtil.updateBracketByes(source, titleId, datasetId, compId, round, index, 1);
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "updating bye count failed: " + hr.ToString("x"));
                    goto end;
                }
                
                // update player's score
                //
                score = MLUtil.UpdateScoreWithWin(entrant.EntrantScore, round);
                
                
                
                // advance player
                //
                MLUtil.updateEntrantRound(source, titleId, datasetId, compId, (userId == 0 ? teamId : userId), round + 1, index * 2, score, Comp.XONLINE_COMP_STATUS_ENTRANT_REGISTERED, HResult.S_OK);
                MLUtil.updateBracketEntrants(source, titleId, datasetId, compId, round + 1, index * 2, 1, true, -1, -1, ctx);
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "BYE granted to user/team " + userId.ToString("x") + "/" + teamId.ToString("x")+ " for comp " + compId.ToString("x"));
            
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "SBR", 
                              hr.ToString("x8"), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"),
                              compId.ToString("x"),
                              userId.ToString("x"),
                              teamId.ToString("x"),
                              round.ToString("x"),
                              index.ToString("x")
                        }));       
            

                counters.EndRequest(HResult.Failed(hr));
            }
end:                
            return hr;       
                    
        }    
        
        public static HResult  ActionRequestPass(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong compId, Hashtable ctx)
        {
            RequestPassCounters counters = new RequestPassCounters(titleId);

            uint round = 0xfffffff;
            uint index = 0xfffffff;
            uint hr = HResult.XONLINE_E_COMP_ERROR;
            
            BracketSearchBracket findBracket = new BracketSearchBracket();
            BracketSearchBracketResults[] findBracketResults = null;
            
            try
            {
                EntrantsSearchPuid findEntrant = new EntrantsSearchPuid();
                EntrantsSearchPuidResults[] findEntrantResults;
                
                uint totalResults = 0;
                
                // get the player's current round/index
                //                    
                findEntrant.Id = (long)compId;
                findEntrant.EntrantPuid = (long)(userId == 0 ? teamId : userId); 
                hr = findEntrant.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, out findEntrantResults);
                if (HResult.Failed(hr) || findEntrantResults == null)
                {
                    if (HResult.Succeeded(hr))
                        hr = HResult.XONLINE_E_COMP_NOT_REGISTERED;
                        
                    throw new PluginException(hr, "Failed to find entrant " + findEntrant.EntrantPuid.ToString("X") + " for verficiation!  " + hr.ToString("x"));
                }
                
                round = (uint)findEntrantResults[0].EntrantCurrentRound;
                index = (uint)findEntrantResults[0].EntrantCurrentIndex;
                
                
                findBracket.Id = (long)compId;
                findBracket.BracketRound = round;
                findBracket.BracketIndex = index;
                
                hr = findBracket.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out findBracketResults);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Failed to find bracket " + round + "/" + index + " from entrant " + findEntrant.EntrantPuid.ToString("X") + "!  " + hr.ToString("x"));
                }
                
                if (findBracketResults == null)
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_TOO_EARLY, "User attempted to check in for a bracket before slotting was complete!");
                }
                    
                
                if (findBracketResults[0].BracketStatus != Comp.XONLINE_COMP_STATUS_BRACKET_PRE_INIT &&
                    findBracketResults[0].BracketStatus != Comp.XONLINE_COMP_STATUS_BRACKET_CHECKIN)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "User attempted to request pass when the bracket status is not PRE_APD (current status: " + findBracketResults[0].BracketStatus);
                    hr = HResult.XONLINE_E_COMP_TOO_LATE;
                    goto end;
                }
                
                // pass granted, update user w/ new status
                //
                MLUtil.updateEntrantStatus(source, titleId, datasetId, compId, (ulong)findEntrant.EntrantPuid, Comp.XONLINE_COMP_STATUS_ENTRANT_PASS, HResult.S_OK);
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Pass granted to user/team " + userId.ToString("x") + "/" + teamId.ToString("x")+ " for comp " + compId.ToString("x"));
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.mllog, String.Join("|, new string[] {
                              "PAS", 
                              hr.ToString("x8"), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"),
                              compId.ToString("x"),
                              userId.ToString("x"),
                              teamId.ToString("x"),
                              round.ToString("x"),
                              index.ToString("x"),
                              findBracketResults != null ? DateTime.FromFileTimeUtc(findBracketResults[0].BracketStart).ToString() : "11/15/2001",
                              findBracketResults != null ? DateTime.FromFileTimeUtc(findBracketResults[0].BracketApd).ToString()   : "11/15/2001",
                              findBracketResults != null ? findBracketResults[0].BracketStatus.ToString("x") : "0"
                        }));       
            

                counters.EndRequest(HResult.Failed(hr));
            }
end:                
            return hr;       
        }            
                
        
                                         
        public static HResult  ActionAdvanceTime(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, QueryAttribute[] attribs, Hashtable ctx)
        {
            AdvanceTimeCounters counters = new AdvanceTimeCounters(titleId);

            long adj = 0;
            uint hr = HResult.XONLINE_E_COMP_ERROR;
            
            try
            {
                if (Config.GetBoolSetting(Setting.compPlugins_allowTimeAdjustment) == false)
                {
                    throw new PluginException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.QUERY_PLUGIN_CONFIG_ERROR_2, 
                        "AdjustTime action called when disabled in the config file!!   If in production, bad client?");
                }    
                                        
                
                if (attribs.Length != 1 || attribs[0].Id != Comp.XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Unexpected list of attributes!  Expected 1 attribute w/ id XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME, instead got " + attribs.Length + " attributes.");
                    
                    hr = HResult.E_INVALIDARG;
                    goto end;
                }    
                
                adj = attribs[0].lValue;
                if (adj == 0)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Invalid time adjustment value of " + adj);
                    
                    hr = HResult.E_INVALIDARG;
                    goto end;
                }    
                
                
                // adjustment is conceptualized as "moving forward in time"
                // in reality we simulate the same thing by setting all time fields back by the adjustment value
                // also, since times are stored in filetime, convert adjustment seconds to 100-nanosecond ticks
                //
                attribs[0].lValue *= -10000000;
                 
                // adjust time in comps dataset
                //
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Adjusting time on comps dataset for comp id " + entityId.ToString("x") + "..");
                hr = Dataset.ExecCustom(source, 
                                    titleId, 
                                    userId, 
                                    teamId, 
                                    datasetId, 
                                    Comp.XONLINE_COMP_ML_CUSTOM_ADVANCE_TIME, 
                                    entityId, 
                                    attribs);
                                    
                if (HResult.Failed(hr))
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA_7, 
                        "AdjustTime action failed attempting to update comps dataset!  Competition is now likely in a bad sate..  hr=" + hr.ToString("x8"));
                }
                
                // adjust time in bracket dataset
                //
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Adjusting time on brackets dataset for comp id " + entityId.ToString("x") + "..");
                AdjustBracketTimeFields bracketAdj = new AdjustBracketTimeFields();
                bracketAdj.Id = (long)entityId;
                bracketAdj.DebugAdjustTime = attribs[0].lValue;
                hr = bracketAdj.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, entityId);
                
                if (HResult.Failed(hr))
                {
                    throw new PluginException(HResult.XONLINE_E_COMP_ERROR, XEvent.Id.QUERY_BAD_DATA_8, 
                        "AdjustTime action failed attempting to update comps dataset!  Competition is now likely in a bad sate..  hr=" + hr.ToString("x8"));
                }
                
                
                // adjust job times
                //
                CompUtil.AdjustJobTimes(titleId, entityId, (uint)adj);
                
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_LOW, "Time adjustment complete!  CompId 0x " + entityId.ToString("x") + " was adjusted by " + adj + " s.");
                
                hr = HResult.S_OK;
            
            }    
            catch (XRLException xe)
            {
                hr = xe.HResult;
                throw;
            }
            catch (Exception)
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }    
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|, new string[] {
                              "ADJ", 
                              hr.ToString("x8"), 
                              titleId.ToString("x8"), 
                              datasetId.ToString("x"), 
                              entityId.ToString("x16"), 
                              adj.ToString()
                        }));       

                counters.EndRequest(HResult.Failed(hr));
            }
            
end:
            return hr;            
        
        }
                                         
              
        public HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, Hashtable ctx)
        {
            uint        hr = HResult.XONLINE_E_QUERY_INVALID_ACTION;
            
            switch (actionId)
            {                
            
            // user actions 
            //
            case Comp.XONLINE_COMP_ACTION_JOIN:
                hr = Multilevel.ActionJoin(source, titleId, userId, teamId, datasetId, entityId, ctx, false);
                break;
                                                                                          
            case Comp.XONLINE_COMP_ACTION_JOIN_PRIVATE:
                hr = Multilevel.ActionJoin(source, titleId, userId, teamId, datasetId, entityId, ctx, true);
                break;

            case Comp.XONLINE_COMP_ACTION_WITHDRAW:
                hr = Multilevel.ActionWithdraw(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;

            case Comp.XONLINE_COMP_ACTION_CHECKIN:
                hr = Multilevel.ActionCheckin(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;
            
        	case Comp.XONLINE_COMP_ACTION_REQUEST_BYE:
        		hr = Multilevel.ActionRequestBye(source, titleId, userId, teamId, datasetId, entityId, ctx);
       	    	break;

        	case Comp.XONLINE_COMP_ACTION_REQUEST_PASS:
        		hr = Multilevel.ActionRequestPass(source, titleId, userId, teamId, datasetId, entityId, ctx);
       	    	break;

            case Comp.XONLINE_COMP_ACTION_CANCEL:
                hr = Multilevel.ActionCancel(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;

            case Comp.XONLINE_COMP_ACTION_DEBUG_ADVANCE_TIME:
                hr = Multilevel.ActionAdvanceTime(source, titleId, userId, teamId, datasetId, entityId, attribs, ctx);
                break;
            
            
            // service events 
            //
            case Comp.XONLINE_COMP_ACTION_SLOTTING:
                hr = MLEvents.ActionSlotting(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;
            
            case Comp.XONLINE_COMP_ACTION_SUBMIT_RESULTS:
                hr = MLEvents.ActionSubmitResults(source, titleId, userId, teamId, datasetId, entityId, attribs, ctx);
                break;
            
            case Comp.XONLINE_COMP_ACTION_AUTO_PROGRESSION:
                hr = MLEvents.ActionAutoProgression(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;
            
            case Comp.XONLINE_COMP_ACTION_PROGRESSION:
                hr = MLEvents.ActionProgression(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;

            case Comp.XONLINE_COMP_ACTION_CLEANUP:
                hr = MLEvents.ActionCleanup(source, titleId, userId, teamId, datasetId, entityId, ctx);
                break;

            default:
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "unknown actionId: " + actionId);            
                break;
            }
            
            return hr;
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\query\ml\mlutil.cs ===
// 
// mlutil.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Multilevel Comp Utilities
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.server.query.fd;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.comps.common;
using xonline.server.comps.query;

namespace xonline.server.comps.query 
{
    public struct Bracket 
    {
        public ulong EntityId;
        public ulong Start;
        public ulong End;
        public ulong Apd;
        public uint Players;
        public uint Slots;
        public uint Byes;
        public uint Status;
    }    
    
    public class MLUtil
    {

        public static uint GetRoundCount(uint entrants)
        {
            // find log2(the next power of 2 greater than p)
            uint rounds;
            
            for (rounds = 1; entrants > 0; rounds++)
            {
                entrants = entrants >> 1;
            }
            
            return rounds;       
        }

        
        public static uint GetSlotCount(uint playerCount)
        {
            if (playerCount == 0)
                return 0;
                
            // find the next power of 2 greater than p
            uint n = 1;
            for (uint i = 1; i < 32; i++)
            {
                if (n >= playerCount)
                    return n;
                
                n = n << 1;
            }                                                                                                 
            return 0xffffffff;
        }
        
        public static uint GetBracketId(uint round, uint bracket)
        {
            return (round << 16) | bracket;
        }
            
        public static long UpdateScoreWithWin(long score, uint round)
        {
            return score | ((uint)(1 << (ushort)(Comp.XONLINE_COMP_ML_MAX_ROUNDS - round)));        
        }    
        
            
        public static uint UpdateEntrantCount(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, int offsetEntrants, int offsetPrivateEntrants, bool isTeam)
        {            
            uint        hr = HResult.XONLINE_E_COMP_ERROR;
            AdjustEntrantCounts countAdj = new AdjustEntrantCounts();
            
            // UpdateEntrantCount calls a custom SP that compares whether we can actually add or subtract a user to a competition without 
            //  violating two constraints:
            //  First: any changes to the entrants count must occur between REG_OPEN and REG_CLOSE for the competition. The 
            //   current time is passed in XONLINE_COMP_ATTR_REG_CLOSE, and is used to check against the registration window for the comp. 
            //  Second: Any changes to the entrants must not violate the total number of entrants allowed in the competition. 
            //  Third: If the competition contains private slots, those slots are reserved for private entrants. 
            
            
            try
            {
                countAdj.PublicEntrants = offsetEntrants;
                countAdj.PrivateEntrants = offsetPrivateEntrants;
                countAdj.RegClose = DateTime.Now.ToFileTime();
                countAdj.IsTeamComp = (isTeam ? 1 : 0);
                
                hr = countAdj.Execute(source, titleId, 0, 0, datasetId, entityId);
                if (HResult.Failed(hr))
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_ERROR, "Entrants Relative Update method failed for competition " + entityId + ". hr = " + hr);            
                }
            }
            
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch 
            {
                hr = HResult.XONLINE_E_COMP_ERROR;
                throw;
            }
            finally
            {
                Xom.Log(XomAreaName.selog, String.Join("|, new string[] {
                              "UEC",
                              hr.ToString(),
                              titleId.ToString("x8"),
                              userId.ToString("x8"),
                              teamId.ToString("x8"),
                              datasetId.ToString("x"),
                              entityId.ToString("x"),
                              offsetEntrants.ToString("x"),
                              offsetPrivateEntrants.ToString("x")
                      }));      
            }
            
            return hr;
        }
        
        


        public static Bracket[][] GetTopology(Source source, uint titleId, uint datasetId, ulong compId, uint startRound, uint endRound)
        {
            BracketSearchComp findBrackets = new BracketSearchComp();
            BracketSearchCompResults[] results;
            HResult hr;
            Bracket[][] brackets;
            
            findBrackets.Id = (long)compId;
            findBrackets.BracketMinRound = startRound;
            findBrackets.BracketMaxRound = endRound;
            
            hr = findBrackets.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out results);
            if (HResult.Failed(hr) || results == null)
            {
                throw new PluginException(hr, "Unexpected failure searching for brackets in the current round!  hr = " + hr);
            }    
            
            uint baseRound = (uint)results[0].BracketRound;
            uint rounds = (uint)(results[results.Length-1].BracketRound - baseRound + 1);
            
            brackets = new Bracket[rounds][];
            uint n = 0;
            uint currentRound = baseRound;
            
            // walk through results, determining the number of brackets in each round
            for (int i = 0; i < results.Length; i++)
            {
                if (results[i].BracketRound == currentRound)
                {
                    n++;
                }
                else
                {
                    brackets[currentRound - baseRound] = new Bracket[n];
                    n = 1;
                    currentRound = (uint)results[i].BracketRound;
                }
            }
            
            brackets[brackets.Length-1] = new Bracket[n];
            
            
            // walk though again, this time actually setting the topology data
            for (int i = 0; i < results.Length; i++)
            {
                brackets[results[i].BracketRound - baseRound][results[i].BracketIndex].EntityId = results[i].EntityId;
                brackets[results[i].BracketRound - baseRound][results[i].BracketIndex].Start = (ulong)results[i].BracketStart;
                brackets[results[i].BracketRound - baseRound][results[i].BracketIndex].End = (ulong)results[i].BracketEnd;
                brackets[results[i].BracketRound - baseRound][results[i].BracketIndex].Apd = (ulong)results[i].BracketApd;
                brackets[results[i].BracketRound - baseRound][results[i].BracketIndex].Byes = (uint)results[i].BracketByes;
                brackets[results[i].BracketRound - baseRound][results[i].BracketIndex].Players = (uint)results[i].BracketEntrants;
                brackets[results[i].BracketRound - baseRound][results[i].BracketIndex].Status = (uint)results[i].BracketStatus;
            }
            
            return brackets;
        }
        

        public static EntrantsSearchPuidResults GetEntrant(Source source, uint titleId, uint datasetId, ulong compId, ulong puid)
        {
            EntrantsSearchPuid findEntrant = new EntrantsSearchPuid();
            EntrantsSearchPuidResults[] findEntrantResults;
            
            findEntrant.Id = (long)compId;
            findEntrant.EntrantPuid = (long)puid; 
            HResult hr = findEntrant.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, out findEntrantResults);
            if (HResult.Failed(hr) || findEntrantResults == null)
            {
                if (findEntrantResults == null) 
                    hr = HResult.XONLINE_E_COMP_NOT_REGISTERED;
                    
                throw new PluginException(hr, "Failed to find entrant " + puid.ToString("X") + "!  hr = " + hr);
            }
            
            return findEntrantResults[0];
        }
            
        public static HResult GetBracket(Source source, uint titleId, uint datasetId, ulong compId, long round, long index, out BracketSearchBracketResults bracket)
        {
            BracketSearchBracket findBracket = new BracketSearchBracket();
            BracketSearchBracketResults[] findBracketResults = null;
            HResult hr;
            
            findBracket.Id = (long)compId;
            findBracket.BracketRound = round;
            findBracket.BracketIndex = index;
            
            hr = findBracket.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out findBracketResults);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Unexpected failure searching for bracket " + round + "/" + index);
            }
            
            if (findBracketResults == null)
            {
                hr = HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND;
                bracket = null;
            }
            else
            {
                bracket = findBracketResults[0];
            }
            
            return hr;
        }
        
        public static BracketSearchBracketResults GetOrMakeBracket(Source source, uint titleId, uint datasetId, ulong compId, long round, long index, long roundDurationMin, long apdOffset, Hashtable ctx)
        {
            BracketSearchBracket findBracket = new BracketSearchBracket();
            BracketSearchBracketResults[] findBracketResults = null;
            HResult hr;
            
            findBracket.Id = (long)compId;
            findBracket.BracketRound = round;
            findBracket.BracketIndex = index;
            
            hr = findBracket.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out findBracketResults);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Unexpected failure searching for bracket " + round + "/" + index);
            }
            
            if (findBracketResults == null)
            {
                //
                // bracket not found, so make one..
                //
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Bracket " + round + "/" + index + " not found in comp id " + compId.ToString("x"));
                
                ulong entityId;
                BracketSearchBracketResults prevBracket;
                findBracketResults = new BracketSearchBracketResults[1];
                
                AddMultilevelBrackets addBracket = new AddMultilevelBrackets();
                addBracket.Id = (long)compId;
                addBracket.BracketRound = round;
                addBracket.BracketIndex = index;
                addBracket.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_PRE_INIT;
                
                    
                // look for another bracket to copy times and leaderboard id from..
                //
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Searching for other brackets in the same round..");                
                BracketSearchRound findRoundBracket = new BracketSearchRound();
                findRoundBracket.Id = (long)compId;
                findRoundBracket.BracketRound = round;
                
                BracketSearchRoundResults[] findRoundBracketResults;
                uint totalResults;
                
                hr = findRoundBracket.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, 0, 1, out totalResults, out findRoundBracketResults);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure searching for a bracket in round " + round);
                }
                
                if (findRoundBracketResults != null)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Bracket found!  Copying data for new bracket..");                
                
                    addBracket.BracketLeaderboard = findRoundBracketResults[0].BracketLeaderboard;
                    addBracket.BracketStart = findRoundBracketResults[0].BracketStart;
                    addBracket.BracketApd = findRoundBracketResults[0].BracketApd;
                    addBracket.BracketEnd = findRoundBracketResults[0].BracketEnd;
                }
                else
                {
                    // no other round brackets found, so get the previous round data to derrive times from.   
                    // It's a good assumption the source round/index will exist..
                    //
                    
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "No other brackets in this round found!  Looking a prior brackets..");                
                    
                    hr = GetBracket(source, titleId, datasetId, compId, round-1, index/2, out prevBracket);
                    if (HResult.Failed(hr))
                    {
                        throw new PluginException(hr, "Failed to find a bracket from the previous round! hr = " + hr);
                    }
                    
                    DateTime newBracketStart = DateTime.FromFileTimeUtc(prevBracket.BracketEnd);
                    
                    addBracket.BracketStart = newBracketStart.ToFileTimeUtc();
                    addBracket.BracketApd = newBracketStart.AddMinutes(apdOffset).ToFileTimeUtc();
                    addBracket.BracketEnd = newBracketStart.AddMinutes(roundDurationMin).ToFileTimeUtc();
                    
                    // .. and create a new leaderboard (if necessary)
                    //
                    addBracket.BracketLeaderboard = 0;
                    if (ctx.Contains("roundLeaderboardTemplateId"))
                    {
                        uint templateId = (uint)((long)ctx["roundLeaderboardTemplateId"]);
                        if (templateId != 0)
                        {
                            Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Creating leaderboard for new bracket");                
                            addBracket.BracketLeaderboard = CompUtil.CreateLeaderboard(titleId, templateId);
                        }    
                    }
                    
                }
                
                
                
                try
                {
                    hr = addBracket.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out entityId);
                    if (HResult.Failed(hr))
                    {
                        throw new PluginException(hr, "Unexpected failure adding new bracket for compId " + compId.ToString("x") + ": hr = " + hr);
                    }
                    
                }
                catch(XRLException e)
                {
                    if (e.HResult == HResult.XONLINE_E_QUERY_DUPLICATE_ENTRY)
                    {
                        // this error we can deal with; it means another thread just added the bracket we were looking 
                        // for.   So, try searching for it again.
                        Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Attempt to create new bracket failed!   searching for bracket that must already be there..");
                        
                        hr = GetBracket(source, titleId, datasetId, compId, round, index, out findBracketResults[0]);
                        if (HResult.Failed(hr))
                        {
                            throw new PluginException(hr, "Unexpected failure searching for new bracket for compId " + compId.ToString("x") + ": hr = " + hr);
                        }
                    }
                    else
                    {
                        throw;
                    }
                }
            }    
                
            return findBracketResults[0];
        }        
        
        
        public static uint updateEntrantStatus(Source source, uint titleId, uint datasetId, ulong compId, ulong puid, uint status, HResult hrEntrant)
        {
            EntrantsUpdateStatus entryUpdate = new EntrantsUpdateStatus();
            entryUpdate.Id = (long)compId;
            HResult hr;
            
            entryUpdate.EntrantPuid = (long)puid;
            entryUpdate.EntrantCurrentStatus = status;
            entryUpdate.EntrantHresult = hrEntrant;
            
            hr = entryUpdate.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Failed to update entrant puid " + puid.ToString("x") + ": hr = " + hr);
            }
            
            return hr;
        }
        

        public static uint updateEntrantRound(Source source, uint titleId, uint datasetId, ulong compId, ulong puid, long round, long index, long score, long status, HResult hrEntrant)
        {
            EntrantsUpdateRound entryUpdate = new EntrantsUpdateRound();
            entryUpdate.Id = (long)compId;
            HResult hr; 
            
            entryUpdate.EntrantPuid = (long)puid;
            entryUpdate.EntrantCurrentRound = round;
            entryUpdate.EntrantCurrentIndex = index;
            entryUpdate.EntrantCurrentStatus = status;
            entryUpdate.EntrantScore = score;
            entryUpdate.EntrantHresult = hrEntrant;
            
            hr = entryUpdate.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Failed to update entrant for round " + round + " index " + index + ": hr = " + hr);
            }
            
            return hr;
        }

        
        public static void updateBracketEntrants(Source source, uint titleId, uint datasetId, ulong compId, long round, long index, int entrantsOffset, 
                                                 bool createIfNotFound, long roundDurationMin, long apdOffset, Hashtable ctx)
        {
            BracketCustomUpdateEntrants updateEntrants = new BracketCustomUpdateEntrants();
            HResult hr;
        
            updateEntrants.Id = (long)compId;
            updateEntrants.BracketRound = round;
            updateEntrants.BracketIndex = index;
            updateEntrants.BracketEntrants = entrantsOffset;
            updateEntrants.BracketEnd = DateTime.Now.ToFileTime();
            
            hr = updateEntrants.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, compId);
            if (HResult.Failed(hr) && (hr != HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND || createIfNotFound == false))
            {
                throw new PluginException(hr, "Failed to update bracket for round " + round + " index " + index + ": hr = " + hr);
            }
            
            if (hr == HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
            {
                //
                // bracket not found, so make one..
                //
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Bracket " + round + "/" + index + " not found in comp id " + compId.ToString("x"));
                
                ulong entityId;
                BracketSearchBracketResults prevBracket;
                
                AddMultilevelBrackets addBracket = new AddMultilevelBrackets();
                addBracket.Id = (long)compId;
                addBracket.BracketRound = round;
                addBracket.BracketIndex = index;
                addBracket.BracketEntrants = (entrantsOffset > 0 ? entrantsOffset : 0);
                addBracket.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_PRE_INIT;
                
                    
                // look for another bracket to copy times and leaderboard id from..
                //
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Searching for other brackets in the same round..");                
                BracketSearchRound findRoundBracket = new BracketSearchRound();
                findRoundBracket.Id = (long)compId;
                findRoundBracket.BracketRound = round;
                
                BracketSearchRoundResults[] findRoundBracketResults;
                uint totalResults;
                
                hr = findRoundBracket.Execute(source, titleId, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, 0, 1, out totalResults, out findRoundBracketResults);
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure searching for a bracket in round " + round);
                }
                
                if (findRoundBracketResults != null)
                {
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Bracket found!  Copying data for new bracket..");                
                
                    addBracket.BracketLeaderboard = findRoundBracketResults[0].BracketLeaderboard;
                    addBracket.BracketStart = findRoundBracketResults[0].BracketStart;
                    addBracket.BracketApd = findRoundBracketResults[0].BracketApd;
                    addBracket.BracketEnd = findRoundBracketResults[0].BracketEnd;
                }
                else
                {
                    // no other round brackets found, so get the previous round data to derrive times from.   
                    // It's a good assumption the source round/index will exist..
                    //
                    
                    Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "No other brackets in this round found!  Looking a prior brackets..");                
                    
                    hr = GetBracket(source, titleId, datasetId, compId, round-1, index/2, out prevBracket);
                    if (HResult.Failed(hr))
                    {
                        throw new PluginException(hr, "Failed to find a bracket from the previous round! hr = " + hr);
                    }
                    
                    if (roundDurationMin == -1)
                    {
                        FindCompDataResults[] compData;
                        hr = FindCompData.Execute(source, titleId, datasetId, new ulong[] { compId }, out compData);
                        if (HResult.Failed(hr))
                        {
                            throw new PluginException(hr, "Unexpected failure executing FindFromIds!  hr = " + hr);
                        }
                        
                        roundDurationMin = compData[0].RoundDurationMin;
                        apdOffset = compData[0].ApdOffsetMin;
                    }    
                        
                    
                    DateTime newBracketStart = DateTime.FromFileTimeUtc(prevBracket.BracketEnd);
                    
                    addBracket.BracketStart = newBracketStart.ToFileTimeUtc();
                    addBracket.BracketApd = newBracketStart.AddMinutes(apdOffset).ToFileTimeUtc();
                    addBracket.BracketEnd = newBracketStart.AddMinutes(roundDurationMin).ToFileTimeUtc();
                    
                    // .. and create a new leaderboard (if necessary)
                    //
                    addBracket.BracketLeaderboard = 0;
                    if (ctx.Contains("roundLeaderboardTemplateId"))
                    {
                        uint templateId = (uint)((long)ctx["roundLeaderboardTemplateId"]);
                        if (templateId != 0)
                        {
                            Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Creating leaderboard for new bracket");                
                            addBracket.BracketLeaderboard = CompUtil.CreateLeaderboard(titleId, templateId);
                        }    
                    }
                    
                }
                
                try
                {
                    hr = addBracket.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, out entityId);
                    if (HResult.Failed(hr))
                    {
                        throw new PluginException(hr, "Unexpected failure adding new bracket for compId " + compId.ToString("x") + ": hr = " + hr);
                    }
                    
                }
                catch(XRLException e)
                {
                    if (e.HResult == HResult.XONLINE_E_QUERY_DUPLICATE_ENTRY)
                    {
                        // this error we can deal with; it means another thread just added the bracket we were looking 
                        // for.   So, try searching for it again.
                        Xom.Trace(XomAreaName.mltrace, LogLevel.L_WARNING, "Attempt to create new bracket failed!   searching for bracket that must already be there..");
                        
                        updateBracketEntrants(source, titleId, datasetId, compId, round, index, entrantsOffset, false, 0, 0, ctx);
                    }
                    else
                    {
                        throw;
                    }
                }
            }    
            
            
        }
        
        public static uint updateBracketByes(Source source, uint titleId, uint datasetId, ulong compId, uint round, uint index, int byesOffset)
        {
            BracketCustomUpdateByes updateByes = new BracketCustomUpdateByes();
            HResult hr;
        
            updateByes.Id = (long)compId;
            updateByes.BracketRound = round;
            updateByes.BracketIndex = index;
            updateByes.BracketByesGranted = byesOffset;
            
            hr = updateByes.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET, compId);
            return hr;
        }

        public static void verifyTicket(ulong puid, BundledAuthData bundledAuth, TeamTickets bundledTeams)
        {
                
            if (AuthToggle.On)
            {
                bool             authorized = false;

                if (null == bundledAuth)
                {
                    // bundledAuth data was not provided. Results are only allowed to arrive from arbitration. Abort
                    throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_41, 
                        "Results submitted for puids " + puid + " with missing bundled authData! Aborting." );                        
                }

                if (null == bundledTeams)
                {
                    // p1 and p2 are users
                    
                    foreach(XUIDAndTrust x in bundledAuth.users)
                    {
                        if (x.qwUserID == puid)
                        {
                            authorized = true;
                        }

                    }
                }
                else
                {
                    // p1 and p2 are teams. Each ticket (one per user participating) must contain team p1 or team p2
                    foreach(TeamTicket t in bundledTeams.teamTickets)
                    {
                        bool verifiedTicket = false;
                        
                        if (t.VerifyMembership(t.userID, puid))
                        {
                            authorized = true;
                            verifiedTicket = true;
                        }

                        if (false == verifiedTicket)
                        {
                            // a team ticket exists which has no representation in this event. 
                            throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_42, 
                                "Results submitted for " + puid + " with a team ticket that does not represent one of the players." );                        
                        }
                    }

                    // Now, each participating user must have a team ticket
                    foreach(XUIDAndTrust x in bundledAuth.users)
                    {
                        bool verifiedUser = false;
                        
                        foreach(TeamTicket t in bundledTeams.teamTickets)
                        {
                            if (t.userID == x.qwUserID)
                            {
                                verifiedUser = true;
                                break;
                            }
                        }
                        
                        if (false == verifiedUser)
                        {
                            // a user is missing a valid team ticket in the submission
                            throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_43, 
                                "Results submitted for puid " + puid.ToString("x") + " but they're not on anyone's team!." );                        
                        }
                    }
                    
                }

                if (false == authorized)
                {
                    // Results submitted for users/teams who are not part of the auth data submitted!
                    throw new PluginException(HResult.XONLINE_E_COMP_UNEXPECTED, XEvent.Id.QUERY_PLUGIN_DATA_ERROR_44, 
                        "Results submitted for users/teams who are not part of the auth data submitted!.   puid = " + puid.ToString("x"));                        
                 }                    
            }
        }        
        
        
        
        public static DateTime DelayRound(Source source, uint titleId, uint datasetId, ulong compId, uint round, DateTime roundStart, DateTime roundApd, DateTime roundEnd, long roundDurationMin, long apdOffset, bool isApd)
        {
            DateTime retval;
            HResult hr;
            
            DateTime bracketStart;
            DateTime bracketApd;
            DateTime bracketEnd;
            
            // find the next period without an outage
            bracketStart = roundStart.AddMinutes(roundDurationMin);
            bracketApd = bracketStart.AddMinutes(apdOffset);
            bracketEnd = bracketStart.AddMinutes(roundDurationMin);
            
            while (bracketStart < DateTime.UtcNow || QueryHealth.WasServiceDown(bracketStart, bracketEnd))
            {
                bracketStart = bracketStart.AddMinutes(roundDurationMin);
                bracketApd = bracketStart.AddMinutes(apdOffset);
                bracketEnd = bracketStart.AddMinutes(roundDurationMin);
            }    
            
            
            BracketUpdateRoundTimes updateTimes = new BracketUpdateRoundTimes();
            updateTimes.Id = (long)compId;
            updateTimes.BracketRound = round;
            
            updateTimes.BracketStatus = (isApd ? Comp.XONLINE_COMP_STATUS_BRACKET_CHECKIN : Comp.XONLINE_COMP_STATUS_BRACKET_IN_PROGRESS);
            
            // note: for current round, start doesn't change
            //   same goes for APD, if this is a prgression delay
            updateTimes.BracketStart = roundStart.ToFileTimeUtc();
            updateTimes.BracketApd = (isApd ? bracketApd.ToFileTimeUtc() : roundApd.ToFileTimeUtc());
            updateTimes.BracketEnd = bracketEnd.ToFileTimeUtc();
            
            hr = updateTimes.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Unexpected failure updating bracket times for compId " + compId.ToString("x") + "! hr = " + hr);
            }
            
            Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Round " + round + " in compId " + compId.ToString("x")  + " rescheduled.  old start: " + roundStart + " new start: " + bracketStart + "  APD: " + bracketApd + "  end: " + bracketEnd);
            
            retval = (isApd ? bracketApd : bracketEnd);
            
            // now update all the subsequent rounds
            //
            for (int i = 1; i < 255; i++)
            {
                bracketStart = bracketEnd;
                bracketApd = bracketStart.AddMinutes(apdOffset);
                bracketEnd = bracketStart.AddMinutes(roundDurationMin);
                
                updateTimes.BracketRound = round + i;
                updateTimes.BracketStatus = Comp.XONLINE_COMP_STATUS_BRACKET_PRE_INIT;
                updateTimes.BracketStart = bracketStart.ToFileTimeUtc();
                updateTimes.BracketApd = bracketApd.ToFileTimeUtc();
                updateTimes.BracketEnd = bracketEnd.ToFileTimeUtc();
                
                hr = updateTimes.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_BRACKETS_DATASET_OFFSET);
                if (hr == HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND)
                {
                    // no more rounds, all done
                    break;
                }
                
                if (HResult.Failed(hr))
                {
                    throw new PluginException(hr, "Unexpected failure updating bracket times for compId " + compId.ToString("x") + "! hr = " + hr);
                }
                
                Xom.Trace(XomAreaName.mltrace, LogLevel.L_INFO, "Round " + (round + i) + " in compId " + compId.ToString("x")  + " rescheduled.  new start: " + bracketStart + "  APD: " + bracketApd + "  end: " + bracketEnd);
            }
                        
            return retval;                                                       
                                                       
        }        

        
        public static bool IsEveryoneDone(Source source, uint titleId, uint datasetId, ulong compId)
        {
            EntrantsCustomIsEveryoneDone isDone = new EntrantsCustomIsEveryoneDone();
            HResult hr;
            
            isDone.Id = (long)compId;
            hr = isDone.Execute(source, titleId, 0, 0, datasetId + Comp.XONLINE_COMP_ML_ENTRANTS_DATASET_OFFSET, 0);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Unexpected failure searching for active players in " + compId.ToString("x") + "! hr = " + hr);
            }
            
            return (hr == HResult.S_OK);
        }
                    
                                     
        public static void CompleteComp(Source source, uint titleId, uint datasetId, ulong compId, FindCompDataResults comp)
        {
            ulong userId = (XRLUtil.IsTeamPuid((ulong)comp.Owner) ? 0 : (ulong)comp.Owner);
            ulong teamId = (XRLUtil.IsTeamPuid((ulong)comp.Owner) ? (ulong)comp.Owner : 0);
            HResult hr;
            
            UpdateCompStatus updateStatus = new UpdateCompStatus();
            updateStatus.Status = Comp.XONLINE_COMP_STATUS_COMPLETE;
            
            hr = updateStatus.Execute(source, titleId, userId, teamId, datasetId, compId);
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Unexpected failure marking competition complete!  compId " + compId.ToString("x") + "! hr = " + hr);
            }
            
            // schedule cleanup job
            CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, compId,
                            Comp.XONLINE_COMP_ACTION_CLEANUP, 
                            1, 
                            5 * 60,         // 5 minutes
                            DateTime.UtcNow.AddDays(comp.CompCleanupDays),
                            0);
        }
        

        public static void CancelComp(Source source, uint titleId, uint datasetId, ulong compId, FindCompDataResults comp)
        {
            ulong userId = (XRLUtil.IsTeamPuid((ulong)comp.Owner) ? 0 : (ulong)comp.Owner);
            ulong teamId = (XRLUtil.IsTeamPuid((ulong)comp.Owner) ? (ulong)comp.Owner : 0);
            HResult hr;
            
            UpdateCompStatus updateStatus = new UpdateCompStatus();
            updateStatus.Status = Comp.XONLINE_COMP_STATUS_CANCELED;
            hr = updateStatus.Execute(source, titleId, userId, teamId, datasetId, compId);
            
            if (HResult.Failed(hr))
            {
                throw new PluginException(hr, "Unexpected failure marking competition complete!  compId " + compId.ToString("x") + "! hr = " + hr);
            }
            
            // schedule cleanup job
            CompUtil.ScheduleSelectJob(titleId, userId, teamId, datasetId, compId,
                            Comp.XONLINE_COMP_ACTION_CLEANUP, 
                            1, 
                            5 * 60,         // 5 minutes
                            DateTime.UtcNow.AddDays(comp.CompCleanupDays),
                            0);
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\Category.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using Microsoft.Ems.Common.Utils;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    /// Provides editing and retrieving of Category data in the catalog, and aids in the 
    /// creation of the Category object.
    /// </summary>
    public class Category : ICatalogData
    {
        #region Fields
        private int id;
        private int categorySystemId;
        private int? parentCategoryId;
        private List<CategoryLocale> locales = new List<CategoryLocale>();
        private List<Category> subCategories = new List<Category>();
        private List<CategoryLocaleMap> categoryLocaleMaps = new List<CategoryLocaleMap>();
        private DataChangeType modified;
        #endregion

        #region Contstructors
        /// <summary>
        /// Empty constructor so this class serializes over SOAP.
        /// </summary>
        public Category()
        {
        }

        /// <summary>
        /// Initalizea a new instance of the Category class from a Sql data reader
        /// </summary>
        /// <param name="reader"></param>
        internal Category(SqlDataReader reader)
        {
            id = reader.GetInt32(reader.GetOrdinal("categoryId"));
            categorySystemId = reader.GetInt32(reader.GetOrdinal("categorySystemId"));
            if ( reader.IsDBNull(reader.GetOrdinal("parentCategoryId")))
            {
                parentCategoryId = null;
            }
            else
            {
                parentCategoryId = reader.GetInt32(reader.GetOrdinal("parentCategoryId"));
            }
        }
        #endregion

        #region Properties
        /// <summary>
        ///  Gets the id of this category.
        /// </summary>
        public int Id
        {
            get
            {
                return this.id;
            }
            set
            {
                // We must not allow a categoryId to be the same as its parent id
                if (( parentCategoryId.HasValue ) && ( value == parentCategoryId  ))
                {
                    throw new ArgumentException( "A category cannot be its own parent. CateogryId is the same as the ParentCategoryId." );
                }
                this.id = value;
            }
        }

        /// <summary>
        /// Gets the id of the <c>CategorySystem</c> this Category associated with.
        /// </summary>
        public int CategorySystemId
        {
            get
            {
                return this.categorySystemId;
            }
            set
            {
                // Verify that a category system with this id exists.
                if ( CategorySystem.Get( value ) == null )
                {
                    throw new ArgumentNullException( "CategorySystem" );
                }
                this.categorySystemId = value;
            }
        }

        /// <summary>
        /// Gets the id of the parent Category this Category associated with.  If this is a top level Category for the CategorySystem, the value returned can be null or -1.
        /// </summary>
        public int? ParentCategoryId
        {
            get
            {
                return this.parentCategoryId;
            }
            set
            {
                // If a parent id is specifed:
                if ( value.HasValue )
                {
                    // Verify that the parent for this category is not itself.
                    if ( value == id )
                    {
                        throw new ArgumentException( "A category cannot have itself as its parent. ParentCateogryId is the same as CategoryId." );
                    }

                    // verify that the category actually exists
                    Validate.IsNotNull( CategorySystem.GetCategoryById( value.Value ), "parentCategoryId", "parentCategoryId" );
                }
                this.parentCategoryId = value;
            }
        }

        /// <summary>
        /// Gets the list of immediate children categoris associated with this Category.
        /// SOAP clients should not try to set SubCategoryIds here; this is readonly.  
        /// </summary>
        public Category[] Categories
        {
            get
            {
                return this.subCategories.ToArray();
            }
            set
            {
                this.subCategories.Clear();
                this.subCategories.AddRange(value);
            }
        }

        /// <summary>
        /// Gets or sets the list of <c>CategoryLocale</c> associated with this Category.
        /// </summary>
        public CategoryLocale[] Locales
        {
            get
            {
                return this.locales.ToArray();
            }
            set
            {
                if ( value == null )
                {
                    throw new ArgumentNullException( "Locales" );
                }
                this.locales.Clear();
                this.locales.AddRange(value);
            }
        }

        /// <summary>
        /// Gets or sets all top the <c>CategoryLocaleMap</c> associated with this CategorySystem.
        /// </summary>
        public CategoryLocaleMap[] CategoryLocaleMap
        {
            get
            {
                return this.categoryLocaleMaps.ToArray();
            }
            set
            {
                if ( value == null )
                {
                    throw new ArgumentNullException( "CategoryLocaleMap" );
                }
                this.categoryLocaleMaps.Clear();
                this.categoryLocaleMaps.AddRange(value);
            }
        }

        /// <summary>
        /// Gets or sets the modified state of the object in relation to record in the backing database store.
        /// </summary>
        public virtual DataChangeType Modified
        {
            get
            {
                return this.modified;
            }
            set
            {
                this.modified = value;
            }
        }

        #endregion

        #region Methods
        /// <summary>
        /// Returns the next available id
        /// </summary>
        /// <returns></returns>
        public static int GetAvailableId()
        {
            try
            {
                int retvalue = Convert.ToInt32(SqlHelper.ExecuteScalar(CatalogDatabase.RawCatalogDBConnectionString, CommandType.Text, "select dbo.GenerateIdCategory()"));
                return retvalue;
            }
            catch (SqlException e)
            {
                Utils.Event.RaiseSqlExceptionEvent(e, CatalogDatabase.RawCatalogDBConnectionString, "GenerateIdCategory");
                throw;
            }
        }
        /// <summary>
        /// Get the Category for the given id.
        /// </summary>
        /// <param name="categoryId">The id of the category to retrieve.</param>
        /// <returns>The Catagory for the given id.</returns>
        internal static Category Get(int categoryId)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets all Categories in the Catalog.
        /// </summary>
        /// <returns>The list of categories in the Catalog.</returns>
        internal static List<Category> Get()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Adds a subcategory
        /// </summary>
        /// <param name="subCategory">the subcategory to add </param>
        internal void AddSubCategory( Category subCategory )
        {
            subCategories.Add(subCategory );
        }

        /// <summary>
        /// Adds a CategoryLocale (or sub class there of ).
        /// </summary>
        /// <param name="categoryLocale">the categoryLocale to add </param>
        internal void AddCategoryLocale( CategoryLocale categoryLocale )
        {
            locales.Add( categoryLocale );
        }

        /// <summary>
        /// Adds a CategoryLocaleMap.
        /// </summary>
        /// <param name="categoryLocaleMap">the categoryLocaleMap to add </param>
        internal void AddCategoryLocaleMap( CategoryLocaleMap categoryLocaleMap )
        {
            categoryLocaleMaps.Add( categoryLocaleMap );
        }

        /// <summary>
        /// Saves changes made to the given Category object to the database.
        /// </summary>
        internal static void Save(Category category)
        {
            // Validation. Category must have at least one locale and localeMap before it
            // can be saved.
            if ( category == null )
            {
                throw new ArgumentNullException("Cannot save null category");
            }

            // We already know that the instance must have a non-null locale and locale map array since there
            // is no way to construct or set it so. However, the default is to construct the category with a
            // zero length list for both of these which is not valid - they must have at least one of each. So
            // validate here that at least one has been set.
            Validate.IsLessThanOrEqual(category.Locales.Length, 0, "category.Locales", "category.Locales" );
            Validate.IsLessThanOrEqual(category.CategoryLocaleMap.Length, 0, "category.CategoryLocaleMap", "category.CategoryLocaleMap" );

            // Now we know that we have lists of length one for each of Locale and locale map, make sure that
            // the first entry in each list is not the value 'null'
            if ( category.Locales[0] == null )
            {
                throw new ArgumentNullException( "category.Locale[0]" );
            }
            if ( category.CategoryLocaleMap[0] == null )
            {
                throw new ArgumentNullException( "category.CategoryLocaleMap[0]" );
            }

            // By default, the category is created with zero for a category system. If the user has not set
            // this to somthing else, the value of zero may (probably will) be invalid. Verify that whatever it
            // is set to is valid
            Validate.IsNotNull( CategorySystem.Get( category.categorySystemId ), "categorySystemId", "categorySystemId" );

            // We do not support delete for categories.
            if (category.Modified == DataChangeType.Delete)
            {
                throw new NotSupportedException("Deletion function is not supported in Category class.");
            }

            using (Serialization serializer = new Serialization())
            {
                serializer.SerializeStartElement("Data");
                category.Serialize(serializer);
                serializer.SerializeEndElement();
                Category.Save(serializer.ResultXml);
            }            
        }

        /// <summary>
        /// Saves changes made to the given Category object specified as xml.
        /// </summary>
        /// <param name="xmlCategory">Category data to be save to the database.</param>
        internal static void Save(string xmlCategory)
        {
            try
            {
                SqlHelper.ExecuteNonQuery(
                        CatalogDatabase.RawCatalogDBConnectionString,
                        "CategorySave",
                        xmlCategory);
            }
            catch (SqlException e)
            {
                Event.RaiseSqlExceptionEvent(e, CatalogDatabase.RawCatalogDBConnectionString, "CategorySave");
                throw;
            }
        }

        /// <summary>
        /// Serialize the Category object into xml (for preparation to save to the database).
        /// </summary>
        /// <param name="context">Serialization object instance</param>
        public void Serialize(Serialization context)
        {
            //If this video series is to be added/deleted; mark all children to be added/deleted.
            if (this.modified == DataChangeType.Add || this.modified == DataChangeType.Delete)
            {
                this.SetModified(this.modified, true);
            }

            if (modified != DataChangeType.None)
            {
                // Category
                context.SerializeStartElement("Category");
                context.SerializeDatabaseOperation(this.modified);
                if ( this.Id >= 0 )  // only serialize id if specifically set. -1 indicates 'add'
                {
                    context.SerializeElement("categoryId", this.Id);
                }
                context.SerializeElement("categorySystemId", this.categorySystemId);
                context.SerializeElement("parentCategoryId", this.parentCategoryId );
                context.SerializeEndElement();

                // Serialize the CategoryLocale records
                if ( locales != null )
                {
                    foreach ( CategoryLocale categoryLocale in locales )
                    {
                        if (categoryLocale != null)
                        {
                            categoryLocale.Serialize(context);
                        }
                    }
                }

                // Serialize the CategoryLocaleMap records
                if ( categoryLocaleMaps != null )
                {
                    foreach ( CategoryLocaleMap categoryLocaleMap in categoryLocaleMaps )
                    {
                        if (categoryLocaleMap != null)
                        {
                            categoryLocaleMap.Serialize(context);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Load properties and contained objects to the obejct from a XMLNode and its sub-nodes.
        /// </summary>
        /// <param name="node">XML node with elements represting all properties and contained objects if any</param>
        public void Deserialize(XmlNode node)
        {

        }

        /// <summary>
        /// Sets this object's modified flag.
        /// </summary>
        /// <param name="type">Data change type</param>
        /// <param name="cascade">Indicate whether to cascade down to contained objects.</param>
        public void SetModified(DataChangeType type, bool cascade)
        {
            this.modified = type;
        }

        
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\comps\test\CompsTest\CompsTest.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Comps;
using xonline.common.config;

namespace CompsTest
{
	/// <summary>
	/// <TestSuite>SingleElimination Competitions, Query and Cron Server Test Suite</TestSuite>
	///	<Tester>Michael Fisher</Tester>
	///	<Developer>Peter Hansen</Developer>
	///	<Developer>Steve Lamb</Developer>
	///	<PM>Clinton Fowler</PM>
	///	<Status>Draft</Status>
	/// </summary>
	///	<remarks>
	///	<Goal>Current: Full positive test coverage for single elimination competition plugin.</Goal>
	///	<Goal>Current: Majority negative test coverage for single elimination competition plugin.</Goal>
	///	<Goal>Current: Basic sanity check test coverage for cron service.</Goal>
	///	<Goal>Current: Basic sanity check test coverage for messaging integration.</Goal>
	///	<Goal>Current: Basic sanity check test coverage for arbitration integration.</Goal>
	///	<Goal>Current: Basic sanity check test coverage for stats integration.</Goal>
	///	<Goal>Current: Stress tests covering projected TPS numbers for Tsunami load.</Goal>
	///	<Goal>M1: Expanding negative test cases.</Goal>
	///	<Goal>M1: Full positive and negative test cases for config database items.</Goal>
	///	<Goal>M1: Tests that are data driven on XQS files.</Goal>
	///	<Goal>M1: Possible integration with existing XQS validation test.</Goal>
	///	<NonGoal>Full test coverage for integration points with messaging, arbitration and stats.</NonGoal>
	///	<NonGoal>Test of container environment (.NET, ASP.NET, IIS, Windows).</NonGoal>
	///	<NonGoal>Test of all xcache performance.</NonGoal>
	///	<Related></Related>
	///	<Description>
	///		Competition is a complex service built upon a query wrapper server (query) and a 
	///		scheduling server (cron). Competitions integrates with a number of other services 
	///		including, messaging, teams, xcache and arbitration. Competitions is also extremely 
	///		configuration from the publisher perpsective and in the future will require more 
	///		permutations of additional publisher modeled datasets.
	///	</Description>
	///	</remarks>
    ///	
    [Owner("PaulLy"), TestFrequency("Regression"), TestCasePriority(3), ServerTestFramework.Description("Comps test case")]
	public class CompsTest:TestSuite
	{
		public override void Initialize(System.Xml.XmlDocument config)
		{
			base.Initialize(config);

			GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());

			// Set Title Trust Constants
			CompsGlobal.report.Info("Updating or creating title constants in UODB and then running ReloadTitleParameters management commands."); 
			
			if (false==UodbWS.SetTitleTrustConstants(CompsGlobal.myTitleTrustConstants))
				CompsGlobal.report.Error("Unable to create/update my title id in UODB");

			// Use management command to reload title constants 
			Global.XEnv.ExecuteXmgmtCommand(Interface.xarbInh, "exec :xarbInh ReloadTitleParameters");
		}

		public override void DeinitializeSuite()
		{
		}

		public override TestBaseGroupList GetTests()
		{
			TestBaseGroupList groupList = base.GetTests();
			groupList.Add(new FuncQueryConfigTest());
			groupList.Add(new FuncCronConfigTest());
			return(groupList);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\Article.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Xml.Serialization;
using System.IO;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    /// Provides management of Article data in the catalog, 
    /// and aids in the creation of the Article object.
    /// </summary>
    public class Article
    {
        #region Fields
        private Guid id;
        private int lcid;
        private int providerId;
        private string text;
        private string author;
        private DateTime authoredDate;
        private bool isHidden;
        #endregion

        #region Constructors
        /// <summary>
        /// Empty constructor to work over SOAP.
        /// </summary>
        public Article()
        {
        }
        private Article(SqlDataReader reader)
        {
            this.author = SqlHelper.GetNullableString(reader, "author");
            this.authoredDate = SqlHelper.GetNullableDateTime(reader, "authoredDate");
            this.id = reader.GetGuid(reader.GetOrdinal("articleId"));
            this.isHidden = (reader.GetByte(reader.GetOrdinal("isHidden")) != 0);
            this.lcid = reader.GetInt32(reader.GetOrdinal("lcid"));
            this.providerId = reader.GetInt32(reader.GetOrdinal("metadataProviderId"));
            this.text = reader.GetString(reader.GetOrdinal("articleText"));
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the id of this article.
        /// </summary>
        public Guid Id
        {
            get
            {
                return this.id;
            }
            set
            {
                this.id = value;
            }
        }

        /// <summary>
        /// Gets or sets the lcid associated with this article.
        /// </summary>
        public int Lcid
        {
            get
            {
                return this.lcid;
            }
            set
            {
                this.lcid = value;
            }

        }

        /// <summary>
        /// Gets or sets the provider id of this article.
        /// </summary>
        public int ProviderId
        {
            get
            {
                return this.providerId;
            }
            set
            {
                this.providerId = value;
            }
        }

        /// <summary>
        /// Gets or sets this article text.
        /// </summary>
        public string Text
        {
            get
            {
                return this.text;
            }
            set
            {
                this.text = value;
            }
        }

        /// <summary>
        /// Gets or sets the author of this article.
        /// </summary>
        public string Author
        {
            get
            {
                return this.author;
            }
            set
            {
                this.author = value;
            }
        }

        /// <summary>
        /// Gets or sets the date when this article authored.
        /// </summary>
        public DateTime AuthoredDate
        {
            get
            {
                return this.authoredDate;
            }
            set
            {
                Validate.ValidateDate(ref value);
                this.authoredDate = value;
            }
        }

        /// <summary>
        /// Gets or sets whether this article should be hidden.
        /// </summary>
        public bool IsHidden
        {
            get
            {
                return this.isHidden;
            }
            set
            {
                this.isHidden = value;
            }
        }
        #endregion

        #region Methods
        /// <summary>
        /// Gets a Article for the given id.
        /// </summary>
        /// <param name="id">The id of the article to get</param>
        /// <returns>The Article for the given id.</returns>
        public static Article Get(Guid id)
        {
            // The other overloaded Get is a superset of this one, so we just format the input parameter as an array and use it to avoid code duplication.
            Guid[] ids = new Guid[1];
            ids[0] = id;
            List<Article> retval = Get(ids);
            if (retval.Count == 0)
                return null;
            return retval[0];
        }

        /// <summary>
        /// Gets the list of articles for the given ids.
        /// </summary>
        /// <returns></returns>
        public static List<Article> Get(Guid[] ids)
        {
            // We can get multiple contributors mixed together in the result set.  We will keep them organized in a Dictionary by contributorId
            Dictionary<Guid, Article> articles = new Dictionary<Guid, Article>();

            // remove duplicates if exists
            foreach (Guid id in ids)
            {
                if (!articles.ContainsKey(id))
                {
                    articles.Add(id, null);
                }
            }
            ids = new Guid[articles.Keys.Count];
            int i = 0;
            foreach (Guid id in articles.Keys)
            {
                ids[i++] = id;
            }
            articles.Clear();

            XmlSerializer serializer = new XmlSerializer(typeof(Guid[]));
            TextWriter writer = new StringWriter();
            serializer.Serialize(writer, ids);

            SqlDataReader reader = SqlHelper.ExecuteReader(
                    CatalogDatabase.RawCatalogDBConnectionString,
                    "ArticleGet",
                    writer.ToString());

            // First get all of the Contributor records
            while (reader.Read())
            {
                Guid articleId = reader.GetGuid(reader.GetOrdinal("articleId"));
                articles.Add(articleId, new Article(reader));
            }

            // Move the article values from the Dictionary to a List<Article> to return the result set.
            List<Article> retval = new List<Article>();
            foreach (Article c in articles.Values)
            {
                retval.Add(c);
            }
            return retval;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\AvatarBodyType.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;

using Utils = Microsoft.Ems.Common.Utils;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    /// Provides management of AvatarBodyType data in the catalog, 
    /// </summary>
    public class AvatarBodyType : Utils.IIdentifiable<Int32>
    {
        #region Fields
        private int id;
        private string name;

        private static readonly TimeSpan CacheRefreshPeriod = new TimeSpan(0, 10, 0);
        private static readonly Utils.Cache<AvatarBodyType, Int32> AvatarBodyTypeCache = new Utils.Cache<AvatarBodyType, Int32>(
                        new Utils.Cache<AvatarBodyType, Int32>.CacheDataRetrievalDelegate(GetData),
                        CacheRefreshPeriod);

        #endregion

        #region Contructors
        /// <summary>
        /// Parameterless constructur required for SOAP.
        /// </summary>
        public AvatarBodyType()
        {
        }

        /// <summary>
        /// Instantiates an avatarbody type from a sql data reader.
        /// </summary>
        /// <param name="reader">The sql data reader with the info</param>
        public AvatarBodyType(SqlDataReader reader)
        {
            this.id = reader.GetInt32(reader.GetOrdinal("avatarBodyTypeId"));
            this.name = reader.GetString(reader.GetOrdinal("internalName"));
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets/sets the int that uniquely identifies this AvatarBodyType
        /// </summary>
        public int Id
        {
            get
            {
                return id;
            }
            set
            {
                Validate.IsGreaterThanOrEqual(value, 0, "id", "id");
                id = value;
            }
        }
        /// <summary>
        /// Gets or sets the name assigned to this AvatarBodyType
        /// </summary>
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                Validate.IsNotNull(value, "name", "name");
                Validate.IsNotLongerThan(value, 50, "name", "name");
                name = value;
            }
        }

        /// <summary>
        /// Id to be used by cache
        /// </summary>
        public int PrimaryId
        {
            get { return Id; }
        }
        #endregion

        #region Methods
        /// <summary>
        /// Gets a AvatarBodyType for the given id.
        /// </summary>
        /// <param name="id">The id of the AvatarBodyType to get</param>
        /// <returns>The AvatarBodyType for the given id.</returns>
        public static AvatarBodyType Get(int id)
        {
            return AvatarBodyTypeCache.Get(id);
        }

        /// <summary>
        /// Gets all AvatarBodyType in the catalog.
        /// </summary>
        /// <returns></returns>
        public static List<AvatarBodyType> Get()
        {
            return AvatarBodyTypeCache.Get();
        }

        /// <summary>
        /// Gets all AvatarBodyType from the database.
        /// </summary>
        /// <returns></returns>
        public static List<AvatarBodyType> GetData()
        {
            List<AvatarBodyType> avatarBodyTypes = new List<AvatarBodyType>();

            using (SqlDataReader reader = SqlHelper.ExecuteReader(
                    CatalogDatabase.RawCatalogDBConnectionString,
                    "AvatarBodyTypeGet"
                    ))
            {
                while (reader.Read())
                {
                    avatarBodyTypes.Add(new AvatarBodyType(reader));
                }
            }
            return avatarBodyTypes;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\CatalogDatabase.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Reflection;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    ///  An instantiation of a row form the RawCatalogDB Category table
    /// Categories can have sub categories, but subcategories must be of the same system as their parent category.
    /// </summary>
    /// <remarks>
    /// Category has a static constructor that reads all known categories from the database and keeps them in an organized cache.
    /// </remarks>
    public class CatalogDatabase
    {
        // By default the catalog will point to the local database if it 
        // has not been set.
        private static String rawCatalogDBConnectionString  = "Data Source=localhost;Initial Catalog=RawCatalogDB;Integrated Security=SSPI";
        private static String coreCatalogDBConnectionString = "Data Source=localhost;Initial Catalog=CoreCatalogDB;Integrated Security=SSPI";

        /// <summary>
        /// Get/Set the db connection string for the Raw catalog.
        /// </summary>
        public static String RawCatalogDBConnectionString
        {
            get { return rawCatalogDBConnectionString; }
            set
            {
                if ( String.IsNullOrEmpty( value ))
                {
                    throw new ArgumentException( String.Format( "Invalid value for connection string: [{0}]", value ));
                }
                rawCatalogDBConnectionString = value;
            }
        }
        
        /// <summary>
        /// Get/Set the db connection string for the Core catalog.
        /// </summary>
        public static String CoreCatalogDBConnectionString
        {
            get { return coreCatalogDBConnectionString; }
            set
            {
                if ( String.IsNullOrEmpty( value ))
                {
                    throw new ArgumentException( String.Format( "Invalid value for connection string: [{0}]", value ));
                }
                coreCatalogDBConnectionString = value;
            }
        }

        /// <summary>
        /// This method is used to check the health of the Catalog Web Service
        /// by calling into the database and returning the basic information.
        /// </summary>
        /// <remarks>
        /// Catches exceptions when connecting to the RawCatalogDB and reports any exception, but provides version of web services regardless
        /// </remarks>
        /// <returns>The information string</returns>
        public static string Ping()
        {            
            string libVer = Assembly.GetAssembly(typeof(Microsoft.Ems.Common.Catalog.CatalogDatabase)).GetName().Version.ToString();
	        string info = string.Format("Catalog Library Version={0}", libVer);
	        try {
                   string dbVer = (string)SqlHelper.ExecuteScalar(
                       rawCatalogDBConnectionString,
                       "GetVersion");
                   string dbInfo = (string)SqlHelper.ExecuteScalar(
                       rawCatalogDBConnectionString,
                       "Ping");
                   info = info + string.Format("\nRawCatalogDB Version={0}, {1}",
                           dbVer.Replace("!!Version=", ""), dbInfo);
	        } catch(Exception ex)
	        {
                   info = info + "\nError connecting to RawCatalogDB:\n" + ex.Message;
	        }
                return info;
            }

        // Make the constructor private so that we cannot construct an instance
        private CatalogDatabase()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\CategoryCorporationLocale.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Xml.Serialization;
using System.Xml;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    /// Defines the CategoryCorporationLocale data in the catalog
    /// </summary>
    public class CategoryCorporationLocale : CategoryLocale
    {
        #region Fields
        private String description;
        private String htmlDescription;
        private Uri website;
        private String rssFeatures;
        private String rssAnnouncement;
        private String rssNews;
        private Guid logoImageId;
        private Guid backgroundImageId;
        #endregion

        #region Constructors
        internal CategoryCorporationLocale(SqlDataReader reader)
            :base(reader)
        {
            description = reader.IsDBNull(reader.GetOrdinal("description")) ? String.Empty : reader.GetString(reader.GetOrdinal("description"));
            htmlDescription = reader.IsDBNull(reader.GetOrdinal("htmlDescription")) ? String.Empty : reader.GetString(reader.GetOrdinal("htmlDescription"));

            
            try
            {
                if (!reader.IsDBNull(reader.GetOrdinal("website")))
                    website = new Uri(reader.GetString(reader.GetOrdinal("website")));
            }
            catch ( UriFormatException )
            {
                website = null;
            }
            rssFeatures = reader.IsDBNull(reader.GetOrdinal("rssFeatures")) ? String.Empty : reader.GetString(reader.GetOrdinal("rssFeatures"));
            rssAnnouncement = reader.IsDBNull(reader.GetOrdinal("rssAnnouncements")) ? String.Empty : reader.GetString(reader.GetOrdinal("rssAnnouncements"));
            rssNews = reader.IsDBNull(reader.GetOrdinal("rssNews")) ? String.Empty : reader.GetString(reader.GetOrdinal("rssNews"));
            logoImageId = reader.IsDBNull(reader.GetOrdinal("logoImageId")) ? Guid.Empty : reader.GetGuid(reader.GetOrdinal("logoImageId"));
            backgroundImageId = reader.IsDBNull(reader.GetOrdinal("backgroundImageId")) ? Guid.Empty : reader.GetGuid(reader.GetOrdinal("backgroundImageId"));
        }

        /// <summary>
        /// Empty constructor so this class serializes over SOAP.
        /// </summary>
        public CategoryCorporationLocale()
        {
        }

        #endregion

        #region Properties
        /// <summary>
        ///  Gets the description for this CategoryCorporationLocale.
        /// </summary>
        public String Description
        {
            get
            {
                return description;
            }
            set
            {
                description = value;
            }
        }

        /// <summary>
        /// Gets or sets the HTML description of this CategoryCorporationLocale.
        /// </summary>
        public string HtmlDescription
        {
            get
            {
                return htmlDescription;
            }
            set
            {
                // Allowed to be null or empty
                htmlDescription = value;
            }
        }

        /// <summary>
        /// Gets the web site url for this corporation
        /// </summary>
        public UriBuilder WebSite
        {
            get
            {
                return (( website == null ) ? null : new UriBuilder( website ));
            }
            set
            {
                website = value.Uri;
            }
        }

        /// <summary>
        /// Gets or sets the rssFeatures of this CategoryCorporationLocale.
        /// </summary>
        public string RssFeatures
        {
            get
            {
                return rssFeatures;
            }
            set
            {
                // Allowed to be null or empty
                rssFeatures = value;
            }
        }

        /// <summary>
        /// Gets or sets the RssAnouncements of this CategoryCorporationLocale.
        /// </summary>
        public string RssAnnouncement
        {
            get
            {
                return rssAnnouncement;
            }
            set
            {
                // Allowed to be null or empty
                rssAnnouncement = value;
            }
        }

        /// <summary>
        /// Gets or sets the rssNews of this CategoryCorporationLocale.
        /// </summary>
        public string RssNews
        {
            get
            {
                return rssNews;
            }
            set
            {
                // Allowed to be null or empty
                rssNews = value;
            }
        }

        /// <summary>
        /// Gets or sets the logo image media id of this CategoryCorporationLocale.
        /// </summary>
        public Guid LogoImageId
        {
            get
            {
                return logoImageId;
            }
            set
            {
                // Allowed to be null or empty
                logoImageId = value;
            }
        }

        /// <summary>
        /// Gets or sets the backgroud image of this CategoryCorporationLocale.
        /// </summary>
        public Guid BackgroundImageId
        {
            get
            {
                return backgroundImageId;
            }
            set
            {
                // Allowed to be null or empty
                backgroundImageId = value;
            }
        }

        #endregion

        /// <summary>
        /// Serialize the Category object into xml (for preparation to save to the database).
        /// </summary>
        /// <param name="context">Serialization object instance</param>
        public override void Serialize(Serialization context)
        {
            //If this video series is to be added/deleted; mark all children to be added/deleted.
            if (this.Modified == DataChangeType.Add || this.Modified == DataChangeType.Delete)
            {
                this.SetModified(this.Modified, true);
            }

            //Call base class to serialize media.
            base.Serialize(context);

            // we only save the ccl if it has at least the background and logo image.
            if (( logoImageId == Guid.Empty ) || ( backgroundImageId == Guid.Empty ))
            {
                return;
            }

            if (Modified != DataChangeType.None)
            {
                // Category
                context.SerializeStartElement("CategoryCorporationLocale");
                context.SerializeDatabaseOperation(this.Modified);
                context.SerializeElement("lcid", base.Lcid );
                context.SerializeElement("description", this.description );
                context.SerializeElement("htmlDescription", this.htmlDescription );
                context.SerializeElement("logoImageId", this.logoImageId );
                context.SerializeElement("backgroundImageId", this.backgroundImageId );
                if ( website != null )
                {
                    context.SerializeElement("website", website.ToString() );
                }
                context.SerializeElement("rssFeatures", this.rssFeatures );
                context.SerializeElement("rssAnnouncements", this.rssAnnouncement );
                context.SerializeElement("rssNews", this.rssNews );
                context.SerializeEndElement();
            }
        }

        /// <summary>
        /// Sets this object's modified flag.
        /// </summary>
        /// <param name="type">Data change type</param>
        /// <param name="cascade">Indicate whether to cascade down to contained objects.</param>
        public override void SetModified(DataChangeType type, bool cascade)
        {
            base.SetModified(type, cascade);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\AudioEncoding.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Xml.Serialization;
using System.Data.SqlClient;
using Microsoft.Ems.Common.Utils;


using Utils = Microsoft.Ems.Common.Utils;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    /// Represents an audio encoding type with its localized textual name
    /// </summary>
    public class AudioEncoding : Utils.IKeyed<Int32>
    {
        # region Constants
        private const int nameLength = 50;
        # endregion

        #region Fields
        private Int32 id;
        private String name;
        private DataChangeType modified = DataChangeType.None;
        private static readonly TimeSpan CacheRefreshPeriod =  new TimeSpan( 0, 10, 0 );
        private static readonly Utils.KeyedCache<Int32,AudioEncoding> AudioEncodingCache = new Utils.KeyedCache<Int32,AudioEncoding>(
                        new Utils.KeyedCache<Int32,Catalog.AudioEncoding>.CachedDataLoaderDelegate( GetData ),
                        CacheRefreshPeriod );
        #endregion

        #region Constructors
        /// <summary>
        /// Parameterless constructor required for SOAP
        /// </summary>
        public AudioEncoding()
        {
        }

        /// <summary>
        /// Constructor that takes a db reader
        /// </summary>
        private AudioEncoding( SqlDataReader reader )
        {
            id = reader.GetInt32(reader.GetOrdinal("audioEncodingId"));
            name = reader.GetString(reader.GetOrdinal("name"));
        }
        #endregion

        #region Properties
        /// <summary>
        /// The id for the audio encoding
        /// </summary>
        public Int32 Id
        {
            get { return id; }
            set { id = value; }
        }

        /// <summary>
        /// The name by which the audio encoding is known - for readability purpose only
        /// </summary>
        [XmlElement(IsNullable = true)]
        public String Name
        {
            get
            {
                return name;
            }
            
            set
            {
                Validate.IsNotEmpty(value, "Name", "Name");
                Validate.IsNotLongerThan(value, nameLength, "Name", "Name");
                name = value;
            }
        }
        /// <summary>
        /// Change type for Data modification
        /// </summary>
        public DataChangeType Modified
        {
            get
            {
                return this.modified;
            }
            set
            {
                this.modified = value;
            }
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Get the AudioEncoding for a given id.
        /// </summary>
        /// <param name="id">The id of the AudioEncoding to retrieve</param>
        /// <returns>The AudioEncoding of the given id.</returns>
        internal static AudioEncoding Get(int id)
        {
            return AudioEncodingCache.Get( id );
        }

        /// <summary>
        /// Gets the list of AudioEncodings in the catalog.
        /// </summary>
        /// <returns></returns>
        public static List<AudioEncoding> Get()
        {
            return AudioEncodingCache.Get();
        }
        
        /// <summary>
        /// Gets the list of AudioEncodings from the database.
        /// </summary>
        /// <returns></returns>
        private static List<AudioEncoding> GetData()
        {
            List<AudioEncoding> audioEncodings = new List<AudioEncoding>();
            
            using ( SqlDataReader reader = SqlHelper.ExecuteReader(
                    CatalogDatabase.RawCatalogDBConnectionString,
                    "AudioEncodingGet"
                    ))
            {
                while( reader.Read() )
                {
                    audioEncodings.Add( new AudioEncoding( reader ));
                }
            }
            return audioEncodings;
        }
        /// <summary>
        /// Overloaded save method which has Audio Encoding as the Input Parameter
        /// </summary>
        /// <param name="audioEncoding"></param>
        public static void Save(AudioEncoding audioEncoding)
        {
            if (audioEncoding == null)
            {
                throw new ArgumentNullException("Can not save null audio encoding");
            }

            if (audioEncoding.Id == -1 && string.IsNullOrEmpty(audioEncoding.name))
            {
                return;
            }
            using (Serialization serializer = new Serialization())
            {
                serializer.SerializeStartElement("Data");
                audioEncoding.Serialize(serializer);
                serializer.SerializeEndElement();
                AudioEncoding.Save(serializer.ResultXml);
            }

        }
        /// <summary>
        /// Overloaded save method which has XML as input parameter
        /// </summary>
        /// <param name="xmlAudioEncoding">XML String to save to database</param>
        private static void Save(string xmlAudioEncoding)
        {
            try
            {
                SqlHelper.ExecuteNonQuery(
                        CatalogDatabase.RawCatalogDBConnectionString,
                        "AudioEncodingSave",
                        xmlAudioEncoding);

                //Refresh the AudioEncoding Cache.
                AudioEncodingCache.Refresh();
            }
            catch (SqlException e)
            {
                Event.RaiseSqlExceptionEvent(e, CatalogDatabase.RawCatalogDBConnectionString, "AudioEncodingSave");
                throw;
            }
        }
        /// <summary>
        /// Serialize Method for AudioEncoding object
        /// </summary>
        /// <param name="context"></param>
        public void Serialize(Serialization context)
        {
            if (context != null)
            {
                if (this.modified != DataChangeType.None)
                {
                    context.SerializeStartElement("AudioEncoding");
                    context.SerializeDatabaseOperation(this.modified);
                    if (this.Id != -1)
                    {
                        context.SerializeElement("audioEncodingId", this.Id);
                    }
                    if (!string.IsNullOrEmpty(this.name))
                    {
                        context.SerializeElement("audioEncodingName", this.name);
                    }
                    context.SerializeEndElement();
                }
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\CategoryLocaleMap.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Xml;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    /// Provides a mapping from a locale (lcid) to a different locale - specifying that for the
    /// first locale, the Category data for the second locale should be used
    /// </summary>
    public class CategoryLocaleMap : ICatalogData
    {
        #region Fields
        private Int32 fromLcid;
        private Int32 toLcid;
        private DataChangeType modified;
        #endregion

        #region Constructors
        /// <summary>
        /// Default constructor required for SOAP.
        /// </summary>
        public CategoryLocaleMap()
        {
        }

        /// <summary>
        /// Initialize a new instance of the CategoryLocaleMap class.  
        /// </summary>
        /// <param name="fromLcid">The locale mapping from</param>
        /// <param name="toLcid">The locale to which the from locale is mapped to</param>
        public CategoryLocaleMap(Int32 fromLcid, Int32 toLcid)
        {
            this.fromLcid = fromLcid;
            this.toLcid = toLcid;
        }

        #endregion

        #region Properties
        /// <summary>
        /// Get the 'From' lcid.
        /// </summary>
        public Int32 FromLcid
        {
            get
            {
                return fromLcid;
            }
            set
            {
                fromLcid = value;
            }
        }
        
        /// <summary>
        /// Gets/Sets the Lcid to which the From lcid is mapped
        /// </summary>
        public Int32 ToLcid
        {
            get
            {
                return toLcid;
            }
            set
            {
                toLcid = value;
            }
        }

        /// <summary>
        /// Gets or sets the modified state of the object in relation to record in the backing database store.
        /// </summary>
        public virtual DataChangeType Modified
        {
            get
            {
                return this.modified;
            }
            set
            {
                this.modified = value;
            }
        }

        #endregion

        #region Public Methods        

        /// <summary>
        /// Serialize the CategoryLocaleMap object into xml (for preparation to save to the database).
        /// </summary>
        /// <param name="context">Serialization object instance</param>
        public void Serialize(Serialization context)
        {
            //If this video series is to be added/deleted; mark all children to be added/deleted.
            if (this.modified == DataChangeType.Add || this.modified == DataChangeType.Delete)
            {
                this.SetModified(this.modified, true);
            }

            if (modified != DataChangeType.None)
            {
                // Category
                context.SerializeStartElement("CategoryLocaleMap");
                context.SerializeDatabaseOperation(this.modified);
                context.SerializeElement("lcid", this.fromLcid );
                context.SerializeElement("lcidMap", this.toLcid );
                context.SerializeEndElement();
            }
        }
        #endregion

        /// <summary>
        /// Load properties and contained objects to the obejct from a XMLNode and its sub-nodes.
        /// </summary>
        /// <param name="node">XML node with elements represting all properties and contained objects if any</param>
        public virtual void Deserialize(XmlNode node)
        {

        }

        /// <summary>
        /// Sets this object's modified flag.
        /// </summary>
        /// <param name="type">Data change type</param>
        /// <param name="cascade">Indicate whether to cascade down to contained objects.</param>
        public virtual void SetModified(DataChangeType type, bool cascade)
        {
            this.modified = type;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\Constants.cs ===
using System;
using System.Data.SqlTypes;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    /// Class for constants
    /// </summary>
    public class Constants
    {
        /// <summary>
        /// Represents the Max date which can be stored in SQL db, this is presently set to SQLDatetime.MaxValue
        /// </summary>
        public static readonly DateTime CatalogMaxDate = SqlDateTime.MaxValue.Value;
        /// <summary>
        /// Represents the Min date which can be stored in SQL db, this is presently set to SQLDatetime.MinValue
        /// </summary>
        public static readonly DateTime CatalogMinDate = SqlDateTime.MinValue.Value;
        /// <summary>
        /// Represents the English locale LCID
        /// </summary>
        public static readonly int EnUsLocale = 1033;
        /// <summary>
        /// Payment type Points
        /// </summary>
        public static readonly int PaymentTypePoints = 1;
        /// <summary>
        /// Payment type Token
        /// </summary>
        public static readonly int PaymentTypeToken = 2;
        /// <summary>
        /// Payment type CreditCard
        /// </summary>
        public static readonly int PaymentTypeCreditCard = 3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ContentIngestion\catalog\Contributor.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.Serialization;
using System.IO;
using Microsoft.Ems.Common.Utils;

namespace Microsoft.Ems.Common.Catalog
{
    /// <summary>
    /// Provides editing and retrieving of Contributor data in the catalog, and aids in the 
    /// creation of the Contributor object.
    /// </summary>
    public class Contributor : ICatalogData
    {
        #region constants
        private const int displayBirthDateLength = 50;
        private const int birthPlaceLength = 255;
        private const int displayDeathDateLength = 50;
        private const int deathPlaceLength = 255;
        #endregion

        #region Fields
        private Guid id;
        private int metadataProviderId;
        private DateTime? birthDate;
        private string displayBirthDate;
        private string birthPlace;
        private DateTime? deathDate;
        private string displayDeathDate;
        private string deathPlace;
        private bool isGroup;
        private List<ContributorArticle> articles = new List<ContributorArticle>();
        private List<ContributorAlias> aliases = new List<ContributorAlias>();
        private List<ContributorCategory> categories = new List<ContributorCategory>();
        private List<ContributorLocale> locales = new List<ContributorLocale>();
        private List<ContributorRelationship> relationships = new List<ContributorRelationship>();
        private DataChangeType modified = DataChangeType.None;
        #endregion

        #region Contructors
        /// <summary>
        /// Empty constructor for this class to seralize over SOAP.
        /// </summary>
        public Contributor()
        {
        }

        /// <summary>
        /// Initialize a new instance of the Contributor class and id to be assigned by the system.
        /// </summary>
        /// <param name="metadataProviderId"></param>
        /// <param name="birthDate"></param>
        /// <param name="displayBirthDate"></param>
        /// <param name="birthPlace"></param>
        /// <param name="deathDate"></param>
        /// <param name="displayDeathDate"></param>
        /// <param name="deathPlace"></param>
        /// <param name="isGroup"></param>
        /// <param name="articles"></param>
        /// <param name="aliases"></param>
        /// <param name="categories"></param>
        /// <param name="locales"></param>
        /// <param name="relationships"></param>
        public Contributor(
                    int metadataProviderId,
                    DateTime birthDate,
                    string displayBirthDate,
                    string birthPlace,
                    DateTime deathDate,
                    string displayDeathDate,
                    string deathPlace,
                    bool isGroup,
                    ContributorArticle[] articles,
                    ContributorAlias[] aliases,
                    ContributorCategory[] categories,
                    ContributorLocale[] locales,
                    ContributorRelationship[] relationships)
            : this(Guid.Empty,  // Call the full constructor using Guid.Empty for the unsupplied Id
                   metadataProviderId,
                   birthDate,
                   displayBirthDate,
                   birthPlace,
                   deathDate,
                   displayDeathDate,
                   deathPlace,
                   isGroup,
                   articles,
                   aliases,
                   categories,
                   locales,
                   relationships) { }

        /// <summary>
        /// Initialize a new instance of the Contributor class.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="metadataProviderId"></param>
        /// <param name="birthDate"></param>
        /// <param name="displayBirthDate"></param>
        /// <param name="birthPlace"></param>
        /// <param name="deathDate"></param>
        /// <param name="displayDeathDate"></param>
        /// <param name="deathPlace"></param>
        /// <param name="isGroup"></param>
        /// <param name="articles"></param>
        /// <param name="aliases"></param>
        /// <param name="categories"></param>
        /// <param name="locales"></param>
        /// <param name="relationships"></param>
        public Contributor(Guid id,
                    int metadataProviderId,
                    DateTime birthDate,
                    string displayBirthDate,
                    string birthPlace,
                    DateTime deathDate,
                    string displayDeathDate,
                    string deathPlace,
                    bool isGroup,
                    ContributorArticle[] articles,
                    ContributorAlias[] aliases,
                    ContributorCategory[] categories,
                    ContributorLocale[] locales,
                    ContributorRelationship[] relationships)
        {
            this.id = id;
            this.metadataProviderId = metadataProviderId;
            this.birthDate = birthDate;
            this.displayBirthDate = displayBirthDate;
            this.birthPlace = birthPlace;
            this.deathDate = deathDate;
            this.displayDeathDate = displayDeathDate;
            this.deathPlace = deathPlace;
            this.isGroup = isGroup;
            this.articles.AddRange(articles);
            this.aliases.AddRange(aliases);
            this.categories.AddRange(categories);
            this.relationships.AddRange(relationships);
            // Use the property setter for parameter validation and data conversion to internal dicationary type.
            this.L