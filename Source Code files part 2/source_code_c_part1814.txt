 riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef()
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    //  IObjectWithRegistryKey
    STDMETHODIMP SetKey(HKEY hk);
    STDMETHODIMP GetKey(HKEY *phk);

    //  IQuerySource
    STDMETHODIMP EnumValues(IEnumString **ppenum);
    STDMETHODIMP EnumSources(IEnumString **ppenum);
    STDMETHODIMP QueryValueString(PCWSTR pszSubSource, PCWSTR pszValue, PWSTR *ppsz);
    STDMETHODIMP QueryValueDword(PCWSTR pszSubSource, PCWSTR pszValue, DWORD *pdw);
    STDMETHODIMP QueryValueExists(PCWSTR pszSubSource, PCWSTR pszValue); 
    STDMETHODIMP QueryValueDirect(PCWSTR pszSubSource, PCWSTR pszValue, FLAGGED_BYTE_BLOB **ppblob);
    STDMETHODIMP OpenSource(PCWSTR pszSubSource, BOOL fCreate, IQuerySource **ppqs);
    STDMETHODIMP SetValueDirect(PCWSTR pszSubSource, PCWSTR pszValue, ULONG qvt, DWORD cbData, BYTE *pvData);

protected: // methods

protected: // members
    LONG _cRef;
    HKEY _hk;
};

STDAPI CRegistrySource::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
    QITABENT(CRegistrySource, IQuerySource),
    QITABENT(CRegistrySource, IObjectWithRegistryKey),
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CRegistrySource::Init(HKEY hk, PCWSTR pszSub, BOOL fCreate)
{
    DWORD err;
    if (!fCreate)
        err = RegOpenKeyExWrapW(hk, pszSub, 0, MAXIMUM_ALLOWED, &_hk);
    else
        err = RegCreateKeyExWrapW(hk, pszSub, 0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &_hk, NULL);

    return HRESULT_FROM_WIN32(err);
}

HRESULT CRegistrySource::SetKey(HKEY hk)
{ 
    if (!_hk)
    {
        _hk = SHRegDuplicateHKey(hk);
        if (_hk)
            return S_OK;
    }
    return E_UNEXPECTED;
}

HRESULT CRegistrySource::GetKey(HKEY *phk)
{
    if (_hk)
    {
        *phk = SHRegDuplicateHKey(_hk);
        if (*phk)
            return S_OK;
    }
    *phk = NULL;
    return E_UNEXPECTED;
}

HRESULT CRegistrySource::QueryValueString(PCWSTR pszSubSource, PCWSTR pszValue, PWSTR *ppsz)
{
    HRESULT hr = E_UNEXPECTED;
    WCHAR sz[128];
    DWORD cb = sizeof(sz);
    DWORD dwType;
    LONG err = SHGetValueW(_hk, pszSubSource, pszValue, &dwType, sz, &cb);
    *ppsz = 0;
    if (err == ERROR_SUCCESS)
    {    
        if (dwType == REG_SZ)
        {
            //  if they are querying for the default value, 
            //  then fail if it is empty
            if (pszValue || *sz)
                hr = SHStrDupW(sz, ppsz);
            else
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
        else 
            hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
    }
    else
    {
        if (err == ERROR_MORE_DATA)
        {
            //  retry with an alloc'd buffer
            ASSERT(cb > sizeof(sz));
            hr = SHCoAlloc(cb, ppsz);
            if (SUCCEEDED(hr))
            {
                err = SHGetValueW(_hk, pszSubSource, pszValue, &dwType, *ppsz, &cb);

                if (dwType != REG_SZ)
                    err = ERROR_DATATYPE_MISMATCH;
                    
                if (err)
                {
                    CoTaskMemFree(*ppsz);
                    *ppsz = 0;
                    hr = HRESULT_FROM_WIN32(err);
                }
            }
        }
        else
            hr = HRESULT_FROM_WIN32(err);
    }
    
    return hr;
}

HRESULT CRegistrySource::QueryValueDword(PCWSTR pszSubSource, PCWSTR pszValue, DWORD *pdw)
{
    DWORD cb = sizeof(*pdw);
    //  DWORD dwType;
    LONG err = SHGetValueW(_hk, pszSubSource, pszValue, NULL, pdw, &cb);
    //  dwType check REG_DWORD || REG_BINARY?
    return HRESULT_FROM_WIN32(err);
}

HRESULT CRegistrySource::QueryValueExists(PCWSTR pszSubSource, PCWSTR pszValue)
{
    LONG err = SHGetValueW(_hk, pszSubSource, pszValue, NULL, NULL, NULL);
    return HRESULT_FROM_WIN32(err);
}

HRESULT _SHAllocBlob(DWORD cb, BYTE *pb, FLAGGED_BYTE_BLOB **ppblob)
{
    HRESULT hr = SHCoAlloc(cb + FIELD_OFFSET(FLAGGED_BYTE_BLOB, abData), ppblob);
    if (SUCCEEDED(hr))
    {
        (*ppblob)->clSize = cb;
        if (pb)
            memcpy((*ppblob)->abData, pb, cb);
    }
    return hr;
}

HRESULT CRegistrySource::QueryValueDirect(PCWSTR pszSubSource, PCWSTR pszValue, FLAGGED_BYTE_BLOB **ppblob)
{
    HRESULT hr = E_FAIL;
    BYTE rgch[256];
    DWORD cb = sizeof(rgch);
    DWORD dwType;
    HKEY hk = _hk;
    LONG err = ERROR_SUCCESS;

    *ppblob = 0;
    if (pszSubSource && *pszSubSource)
    {
        err = RegOpenKeyExWrapW(_hk, pszSubSource, 0, KEY_QUERY_VALUE, &hk);
        ASSERT(NO_ERROR == err || !hk);
    }
            
    if (err == ERROR_SUCCESS)
    {
        err = RegQueryValueExWrapW(hk, pszValue, NULL, &dwType, rgch, &cb);
        if (err == ERROR_SUCCESS)
        {
            hr = _SHAllocBlob(cb, rgch, ppblob);
        }
        else
        {
            if (err == ERROR_MORE_DATA)
            {
                //  retry with an alloc'd buffer
                ASSERT(cb > sizeof(rgch));
                hr = _SHAllocBlob(cb, NULL, ppblob);
                if (SUCCEEDED(hr))
                {
                    err = RegQueryValueExWrapW(hk, pszValue, NULL, &dwType, (*ppblob)->abData, &cb);
                    if (err)
                    {
                        CoTaskMemFree(*ppblob);
                        *ppblob = 0;
                    }
                }
            }

            hr = HRESULT_FROM_WIN32(err);
        }
        if (hk != _hk)
            RegCloseKey(hk);
    }


    if (SUCCEEDED(hr))
        (*ppblob)->fFlags = dwType;
        
    return hr;
}

HRESULT CRegistrySource::OpenSource(PCWSTR pszSubSource, BOOL fCreate, IQuerySource **ppqs)
{
    return QuerySourceCreateFromKey(_hk, pszSubSource, fCreate, IID_PPV_ARG(IQuerySource, ppqs));
}

HRESULT CRegistrySource::SetValueDirect(PCWSTR pszSubSource, PCWSTR pszValue, ULONG qvt, DWORD cbData, BYTE *pvData)
{
    LONG err = SHSetValueW(_hk, pszSubSource, pszValue, qvt, pvData, cbData);
    return HRESULT_FROM_WIN32(err);
}

class CRegistryEnum : public CEnumAny<IEnumString, PWSTR>
{
public:
    HRESULT Init(HKEY hk, CRegistrySource *prs)
    { 
        //  we take a ref on the _punk to keep 
        //  the key alive
        _hk = hk;
        _punkKey = SAFECAST(prs, IQuerySource *);
        prs->AddRef();
        
        _cch = _MaxLen();
        if (_cch > ARRAYSIZE(_sz))
        {
            _psz = (PWSTR) LocalAlloc(LPTR, CbFromCchW(_cch));
        }
        else
        {
            _cch = ARRAYSIZE(_sz);
            _psz = _sz;
        }
        return _psz ? S_OK : E_OUTOFMEMORY;
    }

    virtual ~CRegistryEnum() { if (_psz && _psz != _sz) LocalFree(_psz); _punkKey->Release(); }
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);

        
protected:  // methods    
    BOOL _Next(PWSTR *ppsz);
    virtual DWORD _MaxLen() = 0;
    virtual BOOL _RegNext(LONG i) = 0;

protected:
    IUnknown *_punkKey;
    HKEY _hk;
    PWSTR _psz;
    WCHAR _sz[64];
    DWORD _cch;
};

STDAPI CRegistryEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
    QITABENT(CRegistryEnum, IEnumString),
    };

    return QISearch(this, qit, riid, ppvObj);
}

BOOL CRegistryEnum::_Next(PWSTR *ppsz)
{
    return (_RegNext(_cNext) && SUCCEEDED(SHStrDupW(_psz, ppsz)));
}

class CRegistryEnumKeys : public CRegistryEnum
{
protected:  // methods
    DWORD _MaxLen()
    {
        DWORD cch = 0;
        RegQueryInfoKeyWrapW(
            _hk,
            NULL,
            NULL,
            NULL,
            NULL,
            &cch,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
        );
        return cch;
    }

    BOOL _RegNext(LONG i)
    {
        return ERROR_SUCCESS == RegEnumKeyWrapW(_hk, i, _psz, _cch);
    }
};

class CRegistryEnumValues : public CRegistryEnum
{
protected:  // methods
    DWORD _MaxLen()
    {
        DWORD cch = 0;
        RegQueryInfoKeyWrapW(
            _hk,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &cch,
            NULL,
            NULL,
            NULL
        );
        return cch;
    }
    
    BOOL _RegNext(LONG i)
    {
        DWORD cch = _cch;
        return ERROR_SUCCESS == RegEnumValueWrapW(_hk, i, _psz, &cch, NULL, NULL, NULL, NULL);
    }
};

STDMETHODIMP CRegistrySource::EnumValues(IEnumString **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CRegistryEnum *pre = new CRegistryEnumValues();
    *ppenum = 0;
    if (pre)
    {
        hr = pre->Init(_hk, this);
        if (SUCCEEDED(hr))
            *ppenum = pre;
        else
            pre->Release();
    }
    return hr;
}

STDMETHODIMP CRegistrySource::EnumSources(IEnumString **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CRegistryEnum *pre = new CRegistryEnumKeys();
    *ppenum = 0;
    if (pre)
    {
        hr = pre->Init(_hk, this);
        if (SUCCEEDED(hr))
            *ppenum = pre;
        else
            pre->Release();
    }
    return hr;
}

LWSTDAPI QuerySourceCreateFromKey(HKEY hk, PCWSTR pszSub, BOOL fCreate, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CRegistrySource *prs = new CRegistrySource();
    *ppv = 0;
    if (prs)
    {
        hr = prs->Init(hk, pszSub, fCreate);
        if (SUCCEEDED(hr))
            hr = prs->QueryInterface(riid, ppv);
        prs->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\shlwapi.inc ===
#
#  Common settings for shlwapi
#

C_DEFINES       = $(C_DEFINES) -DDBCS

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                new

# The Hydra header files are messed up - you can't include them with
# "#include <hydra\winsta.h>" because they assume they are in sdk\inc,
# so we will add sdk\inc\hydra to the INCLUDES so they sort of work.

INCLUDES=$(INCLUDES);$(TERMSRV_INC_PATH);$(NET_INC_PATH);$(INETCORE_INC_PATH)

MSC_WARNING_LEVEL=/W4


#
#
# Con-fusion
#
# we can't use 123 because rundll32 will activate it, rendering all CPLs manifested	
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=shlwapi.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\security.cpp ===
#include "priv.h"
#include <shlobj.h>
#include <shellp.h>
#include <shdguid.h>
#include "ids.h"
#include <objbase.h>
#include <wininet.h>            // INTERNET_MAX_URL_LENGTH
#include <shellp.h>
#include <commctrl.h>
#include <mluisupp.h>
#include <inetcpl.h>
#include <crypto\md5.h>

#ifdef UNIX
#include <urlmon.h>
#endif

// This will automatically be freed when the process shuts down.
// Creating the ClassFactory for CLSID_InternetSecurityManager
// is really slow, so we cache it because dragging and dropping
// files does a lot of zone checking.
IClassFactory * g_pcf = NULL;

HRESULT _GetCachedZonesManager(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (!g_pcf)
    {
        CoGetClassObject(CLSID_InternetSecurityManager, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&g_pcf);
        SHPinDllOfCLSID(&CLSID_InternetSecurityManager);
    }

    if (g_pcf) 
    {
        hr = g_pcf->CreateInstance(NULL, riid, ppv);
    }
    else
    {
        *ppv = NULL;
        hr = E_FAIL;
    }
    return hr;
}


             
/**********************************************************************\
    FUNCTION: ZoneCheckUrlExCacheW

    DESCRIPTION:

        Call IInternetSecurityManager::ProcessUrlAction using the
        cached one if available.

        pwszUrl - URL to check
        pdwPolicy - Receives resulting policy (optional)
        dwPolicySize - size of policy buffer (usually sizeof(DWORD))
        pdwContext - context (optional)
        dwContextSize - size of context buffer (usually sizeof(DWORD))
        dwActionType - ProcessUrlAction action type code
        dwFlags - Flags for ProcessUrlAction
        pisms - IInternetSecurityMgrSite to use during
                ProcessUrlAction (optional)
        ppismCache - (in/out) IInternetSecurityManager to use

        If ppismCache is NULL, then no cacheing is performed;
        we use a brand new IInternetSecurityManager.

        If ppismCache is non-null, then it used to cache an
        IInternetSecurityManager.  If there is one there already, we
        use it.  If there isn't one there already, we create one and
        save it there.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlExCacheW(LPCWSTR pwzUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms, IInternetSecurityManager ** ppismCache)
{
    HRESULT hr = E_INVALIDARG;

    if (pwzUrl)
    {
        IInternetSecurityManager *psim;

        if (ppismCache && *ppismCache)
        {
            hr = (*ppismCache)->QueryInterface(IID_PPV_ARG(IInternetSecurityManager, &psim));
        }
        else
        {
            hr = _GetCachedZonesManager(IID_PPV_ARG(IInternetSecurityManager, &psim));
            if (SUCCEEDED(hr) && ppismCache)
                psim->QueryInterface(IID_PPV_ARG(IInternetSecurityManager, ppismCache));
        }

        if (SUCCEEDED(hr))
        {
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;

            if (pisms)
                psim->SetSecuritySite(pisms);

            hr = psim->ProcessUrlAction(pwzUrl, dwActionType, 
                                    (BYTE *)(pdwPolicy ? pdwPolicy : &dwPolicy), 
                                    (pdwPolicy ? dwPolicySize : sizeof(dwPolicy)), 
                                    (BYTE *)(pdwContext ? pdwContext : &dwContext), 
                                    (pdwContext ? dwContextSize : sizeof(dwContext)), 
                                    dwFlags, 0);
            TraceMsg(TF_GENERAL, "ZoneCheckUrlExW(\"%ls\") IsFile=%s; NoUI=%s; dwActionType=0x%lx; dwFlags=0x%lx; hr=%lx>",
                     pwzUrl, (dwFlags & PUAF_ISFILE) ? TEXT("Yes") : TEXT("No"),
                     (dwFlags & PUAF_NOUI) ? TEXT("Yes") : TEXT("No"),
                     dwActionType, dwFlags, hr);

            if (pisms)
                psim->SetSecuritySite(NULL);

            psim->Release();
        }
    }
    return hr;
}


/**********************************************************************\
    FUNCTION: ZoneCheckUrlExCacheA

    DESCRIPTION:

        ANSI version of ZoneCheckUrlExCacheW.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlExCacheA(LPCSTR pszUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms, IInternetSecurityManager ** ppismCache)
{
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];

    ASSERT(ARRAYSIZE(wzUrl) > lstrlenA(pszUrl));        // We only work for Urls of INTERNET_MAX_URL_LENGTH or shorter.
    SHAnsiToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));

    return ZoneCheckUrlExCacheW(wzUrl, pdwPolicy, dwPolicySize, pdwContext, dwContextSize, dwActionType, dwFlags, pisms, ppismCache);
}


/**********************************************************************\
    FUNCTION: ZoneCheckUrlExW

    DESCRIPTION:

        Just like ZoneCheckUrlExCacheW, except never caches.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlExW(LPCWSTR pwzUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    return ZoneCheckUrlExCacheW(pwzUrl, pdwPolicy, dwPolicySize, pdwContext, dwContextSize, dwActionType, dwFlags, pisms, NULL);
}


/**********************************************************************\
    FUNCTION: ZoneCheckUrlExA

    DESCRIPTION:

        ANSI version of ZoneCheckUrlExW.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlExA(LPCSTR pszUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];

    ASSERT(ARRAYSIZE(wzUrl) > lstrlenA(pszUrl));        // We only work for Urls of INTERNET_MAX_URL_LENGTH or shorter.
    SHAnsiToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));

    return ZoneCheckUrlExW(wzUrl, pdwPolicy, dwPolicySize, pdwContext, dwContextSize, dwActionType, dwFlags, pisms);
}

             
/**********************************************************************\
    FUNCTION: ZoneCheckUrlW

    DESCRIPTION:

        Just like ZoneCheckUrlExW, except that no context or policy
        information are used.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlW(LPCWSTR pwzUrl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    return ZoneCheckUrlExW(pwzUrl, NULL, 0, NULL, 0, dwActionType, dwFlags, pisms);
}


/**********************************************************************\
    FUNCTION: ZoneCheckUrlA

    DESCRIPTION:
        ANSI version of ZoneCheckUrlW,

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlA(LPCSTR pszUrl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];

    ASSERT(ARRAYSIZE(wzUrl) > lstrlenA(pszUrl));        // We only work for Urls of INTERNET_MAX_URL_LENGTH or shorter.
    SHAnsiToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));

    return ZoneCheckUrlW(wzUrl, dwActionType, dwFlags, pisms);
}


/**********************************************************************\
    FUNCTION: ZoneCheckPathW

    DESCRIPTION:

        Just like ZoneCheckUrlW, except for filenames instead of URLs.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckPathW(LPCWSTR pwzPath, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    ASSERT(!PathIsRelativeW(pwzPath));
    return ZoneCheckUrlW(pwzPath, dwActionType, (dwFlags | PUAF_ISFILE), pisms);
}


/**********************************************************************\
    FUNCTION: ZoneCheckPathA

    DESCRIPTION:
        ANSI version of ZoneCheckPathW,

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckPathA(LPCSTR pszPath, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    WCHAR wzPath[INTERNET_MAX_URL_LENGTH];

    ASSERT(ARRAYSIZE(wzPath) > lstrlenA(pszPath));        // We only work for Urls of INTERNET_MAX_URL_LENGTH or shorter.
    SHAnsiToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));

    return ZoneCheckPathW(wzPath, dwActionType, dwFlags, pisms);
}

/**********************************************************************\
    FUNCTION: ZoneCheckHostEx

    DESCRIPTION:
        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckHostEx(IInternetHostSecurityManager * pihsm, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags)
{
    HRESULT hr;
    DWORD dwPolicy = 0;
    DWORD dwContext = 0;

    ASSERT(IsFlagClear(dwFlags, PUAF_ISFILE));  // This flag is not appropriate here.
    if (!EVAL(pihsm))
        return E_INVALIDARG;

    hr = pihsm->ProcessUrlAction(dwActionType, 
                            (BYTE *)(pdwPolicy ? pdwPolicy : &dwPolicy), 
                            (pdwPolicy ? dwPolicySize : sizeof(dwPolicy)), 
                            (BYTE *)(pdwContext ? pdwContext : &dwContext), 
                            (pdwContext ? dwContextSize : sizeof(dwContext)), 
                            dwFlags, 0);
    TraceMsg(TF_GENERAL, "ZoneCheckHostEx() NoUI=%s; hr=%lx", (dwFlags & PUAF_NOUI) ? TEXT("Yes") : TEXT("No"), hr);

    return hr;
}


/**********************************************************************\
    FUNCTION: ZoneCheckHost

    DESCRIPTION:
        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckHost(IInternetHostSecurityManager * pihsm, DWORD dwActionType, DWORD dwFlags)
{
    return ZoneCheckHostEx(pihsm, NULL, 0, NULL, 0, dwActionType, dwFlags);
}

/**********************************************************************\
    FUNCTION: ZoneComputePaneSize
    
    DESCRIPTION:
        Computes the necessary size for the zones pane in a status bar.

    NOTES
        The longest zone is the following:

        Width of longest zone name +
        Width of " (Mixed)" +
        Width of small icon (SM_CXSMICON) +
        Width of gripper (SM_CXVSCROLL) +
        Four edges (4 * SM_CXEDGE)

    Why four edges?  Because the rectangle is framed in a DrawEdge(),
    which adds two edges on the left and two on the right, for a total
    of four.

    We cache the results of the font measurements for performance.

\**********************************************************************/

#define ZONES_PANE_WIDTH    220 // Size to use if we are desperate

int _ZoneComputePaneStringSize(HWND hwndStatus, HFONT hf)
{
    HDC hdc = GetDC(hwndStatus);
    HFONT hfPrev = SelectFont(hdc, hf);
    SIZE siz, sizMixed;
    HRESULT hrInit, hr;
    int cxZone;
    ZONEATTRIBUTES za;

    // Start with the length of the phrase " (Mixed)"
    MLLoadStringW(IDS_MIXED, za.szDisplayName, ARRAYSIZE(za.szDisplayName));
    GetTextExtentPoint32WrapW(hdc, za.szDisplayName, lstrlenW(za.szDisplayName), &sizMixed);

    cxZone = 0;

    hrInit = SHCoInitialize();
    IInternetZoneManager *pizm;
    hr = CoCreateInstance(CLSID_InternetZoneManager, NULL, CLSCTX_INPROC_SERVER, IID_IInternetZoneManager, (void **)&pizm);
    if (SUCCEEDED(hr)) {
        DWORD dwZoneEnum, dwZoneCount;
        hr = pizm->CreateZoneEnumerator(&dwZoneEnum, &dwZoneCount, 0);
        if (SUCCEEDED(hr)) {
            for (int nIndex=0; (DWORD)nIndex < dwZoneCount; nIndex++)
            {
                DWORD dwZone;
                za.cbSize = sizeof(ZONEATTRIBUTES);
                pizm->GetZoneAt(dwZoneEnum, nIndex, &dwZone);
                pizm->GetZoneAttributes(dwZone, &za);
                GetTextExtentPoint32WrapW(hdc, za.szDisplayName, lstrlenW(za.szDisplayName), &siz);
                if (cxZone < siz.cx)
                    cxZone = siz.cx;
            }
            pizm->DestroyZoneEnumerator(dwZoneEnum);
        }
        pizm->Release();
    }
    SHCoUninitialize(hrInit);

    SelectFont(hdc, hfPrev);
    ReleaseDC(hwndStatus, hdc);

    // If we couldn't get any zones, then use the panic value.
    if (cxZone == 0)
        return ZONES_PANE_WIDTH;
    else
        return cxZone + sizMixed.cx;
}

LOGFONT s_lfStatusBar;          // status bar font (cached metrics)
int s_cxMaxZoneText;            // size of longest zone text (cached)

LWSTDAPI_(int) ZoneComputePaneSize(HWND hwndStatus)
{
    LOGFONT lf;
    HFONT hf = GetWindowFont(hwndStatus);
    GetObject(hf, sizeof(lf), &lf);

    // Warning:  lf.lfFaceName is an ASCIIZ string, and there might be
    // uninitialized garbage there, so zero-fill it for consistency.
    UINT cchFaceName = lstrlen(lf.lfFaceName);
    ZeroMemory(&lf.lfFaceName[cchFaceName], sizeof(TCHAR) * (LF_FACESIZE - cchFaceName));

    if (memcmp(&lf, &s_lfStatusBar, sizeof(LOGFONT)) != 0)
    {
        ENTERCRITICAL;
        s_cxMaxZoneText = _ZoneComputePaneStringSize(hwndStatus, hf);
        s_lfStatusBar = lf;         // Update the cache
        LEAVECRITICAL;
    }

    return s_cxMaxZoneText + 
           GetSystemMetrics(SM_CXSMICON) +
           GetSystemMetrics(SM_CXVSCROLL) +
           GetSystemMetrics(SM_CXEDGE) * 4;
}

/**********************************************************************\
    FUNCTION: ZoneConfigure
    
    DESCRIPTION:
        Displays the Zones configuration control panel.

        pwszUrl is used to specify which zone is chosen as default.
        Inetcpl will choose the zone that the URL belongs to.

\**********************************************************************/

#define MAX_CPL_PAGES   16

BOOL CALLBACK _ZoneAddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_CPL_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

LWSTDAPI_(void) ZoneConfigureW(HWND hwnd, LPCWSTR pwszUrl)
{
    HMODULE hModInetCpl;

    if (hModInetCpl = LoadLibrary(TEXT("inetcpl.cpl")))
    {
        PFNADDINTERNETPROPERTYSHEETSEX pfnAddSheet = (PFNADDINTERNETPROPERTYSHEETSEX)GetProcAddress(hModInetCpl, STR_ADDINTERNETPROPSHEETSEX);
        if (pfnAddSheet)
        {
            IEPROPPAGEINFO iepi = {SIZEOF(iepi)};
            // Load the current url into the properties page
            CHAR szBufA[INTERNET_MAX_URL_LENGTH];
            SHUnicodeToAnsi(pwszUrl, szBufA, ARRAYSIZE(szBufA));
            iepi.pszCurrentURL = szBufA;

            PROPSHEETHEADER psh;
            HPROPSHEETPAGE rPages[MAX_CPL_PAGES];

            psh.dwSize = SIZEOF(psh);
            psh.dwFlags = PSH_PROPTITLE;
            psh.hInstance = MLGetHinst();
            psh.hwndParent = hwnd;
            psh.pszCaption = MAKEINTRESOURCE(IDS_INTERNETSECURITY);
            psh.nPages = 0;
            psh.nStartPage = 0;
            psh.phpage = rPages;

             // we just want the security page.
            iepi.dwFlags = INET_PAGE_SECURITY;

            pfnAddSheet(_ZoneAddPropSheetPage, (LPARAM)&psh, 0, 0, &iepi);

            //
            // Display the property sheet only if the "security" page was 
            // successfully added (it will fail if an IEAK setting says so)
            //
            if (psh.nPages > 0)
            {
                PropertySheet(&psh);
            }
            else
            {
                SHRestrictedMessageBox(hwnd);
            }
        }
        FreeLibrary(hModInetCpl);
    }
}

/**********************************************************************\
    DESCRIPTION:
        Registers or validates an htt/htm template with the shell.

        The WebView customization wizard and the code that installs the default
        WebView templates calls this API to register the templates.

        The shell object model uses this API to grant privileges to execute
        unsafe method calls (e.g. SHELL.APPLICATION) to templates registered
        with this API.  If they aren't registered, they can't call the unsafe methods.

\**********************************************************************/

#define REGSTR_TEMPLATE_REGISTRY (REGSTR_PATH_EXPLORER TEXT("\\TemplateRegistry"))
#define REGSTR_VALUE_KEY (TEXT("Value"))

BOOL GetTemplateValueFromReg(LPTSTR pszValue, DWORD *pdwValue)
{
    DWORD cbValue = sizeof(DWORD);
    BOOL bSuccess;

    if (!(bSuccess = (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_TEMPLATE_REGISTRY, pszValue, NULL, pdwValue, &cbValue))))
    {
        cbValue = sizeof(DWORD);
        bSuccess = (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_TEMPLATE_REGISTRY, pszValue, NULL, pdwValue, &cbValue));
    }
    return bSuccess;
}

BOOL SetTemplateValueInReg(LPTSTR pszValue, DWORD *pdwValue)
{
    return ((ERROR_SUCCESS == SHSetValue(HKEY_LOCAL_MACHINE, REGSTR_TEMPLATE_REGISTRY, pszValue, REG_DWORD, pdwValue, sizeof(DWORD))) ||
            (ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, REGSTR_TEMPLATE_REGISTRY, pszValue, REG_DWORD, pdwValue, sizeof(DWORD))));
}

HRESULT GetTemplateInfoFromHandle(HANDLE h, UCHAR * pKey, DWORD *pdwSize)
{
    HRESULT hres = E_FAIL;
    DWORD  dwSize = GetFileSize(h, NULL);
    LPBYTE pFileBuff = (LPBYTE)LocalAlloc(0, dwSize);
    if (pFileBuff)
    {
        DWORD dwBytesRead;
        if (ReadFile(h, pFileBuff, dwSize, &dwBytesRead, NULL))
        {
            MD5_CTX md5;

            MD5Init(&md5);
            MD5Update(&md5, pFileBuff, dwBytesRead);
            MD5Final(&md5);

            memcpy(pKey, md5.digest, MD5DIGESTLEN);
            *pdwSize = dwSize;
            hres = S_OK;
        }
        LocalFree(pFileBuff);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

// in:
//      pszPath         URL or file system path
// return:
//      S_OK            if pszPath is in the local zone
//      E_ACCESSDENIED  we are not in a local zone
//
// WARNING: Only use this from SHRegisterValidateTemplate
//     because this isn't good enough for general use.
//     It's not good enought to CoCreate IInternetSecurityManager
//     because it needs to be provided from the host
//     via QueryService.  Outlook Express is one example
//     that needs to over ride the default implementation.
//     Using this from SHRegisterValidateTemplate is OK
//     because it still doesn't the registry check.
STDAPI SuperPrivate_ZoneCheckPath(LPCWSTR pszPath, DWORD dwZone)
{
    HRESULT hr = E_ACCESSDENIED;
    IInternetSecurityManager *pSecMgr;
    if (SUCCEEDED(_GetCachedZonesManager(IID_PPV_ARG(IInternetSecurityManager, &pSecMgr)))) 
    {
        DWORD dwZoneID = URLZONE_UNTRUSTED;
        if (SUCCEEDED(pSecMgr->MapUrlToZone(pszPath, &dwZoneID, 0))) 
        {
            if (dwZoneID == dwZone)
            {
                hr = S_OK;      // we are good
            }
        }       
        pSecMgr->Release();
    }
    return hr;
}

// this API takes a Win32 file path
// in:
//      dwFlags     SHRVT_ falgs in shlwapi.h
// out:
//      S_OK        happy

LWSTDAPI SHRegisterValidateTemplate(LPCWSTR pszPath, DWORD dwFlags)
{
    if ((dwFlags & SHRVT_VALID) != dwFlags)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if (dwFlags & SHRVT_VALIDATE)
    {
        hr = SuperPrivate_ZoneCheckPath(pszPath, URLZONE_LOCAL_MACHINE);

        if (FAILED(hr) && (dwFlags & SHRVT_ALLOW_INTRANET))
        {
            hr = SuperPrivate_ZoneCheckPath(pszPath, URLZONE_INTRANET);
        }
    }

    if (S_OK == hr)
    {
        DWORD dwSize;
        UCHAR pKey[MD5DIGESTLEN];

        HANDLE hfile = CreateFileWrapW(pszPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (INVALID_HANDLE_VALUE != hfile)
        {
            hr = GetTemplateInfoFromHandle(hfile, pKey, &dwSize);
            CloseHandle(hfile);
        }
        else
            hr = E_INVALIDARG;

        if (SUCCEEDED(hr))
        {
            BOOL bSuccess;
            TCHAR szTemplate[MAX_PATH];

            DWORD *pdw = (DWORD *)pKey;

            ASSERT(MD5DIGESTLEN == (4 * sizeof(DWORD)));
        
            wsprintf(szTemplate, TEXT("%u%u%u%u"), pdw[0], pdw[1], pdw[2], pdw[3]);

            if (dwFlags & SHRVT_VALIDATE)
            {
                DWORD dwSizeReg;
                bSuccess = (GetTemplateValueFromReg(szTemplate, &dwSizeReg) && (dwSizeReg == dwSize));
                if (!bSuccess && (dwFlags & SHRVT_PROMPTUSER))
                {
                    MSGBOXPARAMS mbp = {sizeof(MSGBOXPARAMS), NULL, g_hinst, MAKEINTRESOURCE(IDS_TEMPLATENOTSECURE), MAKEINTRESOURCE(IDS_SECURITY),
                                        MB_YESNO | MB_DEFBUTTON2 | MB_TASKMODAL | MB_USERICON, MAKEINTRESOURCE(IDI_SECURITY), 0, NULL, 0};

                    // REARCHITECT: posting a msg box with NULL hwnd, this should
                    // could use a site pointer to get an hwnd to go modal against
                    // if one was provided to the API
                    // Are we calling A or W MessageBoxIndirect and does this break on NT/9x?
                    // Doesn't seem to, -justmann
                    bSuccess = (MessageBoxIndirect(&mbp) == IDYES);

                    if (bSuccess && (dwFlags & SHRVT_REGISTERIFPROMPTOK))
                        SetTemplateValueInReg(szTemplate, &dwSize);
                }
            }
            else  if (dwFlags & SHRVT_REGISTER)
            {
                bSuccess = SetTemplateValueInReg(szTemplate, &dwSize);
            }
            hr = bSuccess ? S_OK : E_ACCESSDENIED;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\shperf.c ===
#include "priv.h"
#include "shlwapip.h"
#include "mshtmdbg.h"

#define STOPWATCH_MAX_DESC                  256
#define STOPWATCH_MAX_TITLE                 192
#define STOPWATCH_MAX_BUF                  1024

// Perftags defines and typedefs
typedef PERFTAG (WINAPI *PFN_PERFREGISTER)(char *, char *, char *);
typedef void (WINAPIV *PFN_PERFLOGFN)(PERFTAG, void *, const char *, ...);
typedef char *(WINAPI *PFN_DECODEMESSAGE)(INT);

// IceCAP function typedefs
typedef void (WINAPI *PFN_ICAP)(void);

// MemWatch function typedefs
typedef HRESULT (WINAPI *PFN_MWCONFIG)(DWORD, DWORD, DWORD);
typedef HRESULT (WINAPI *PFN_MWBEGIN)(BOOL, BOOL);
typedef HRESULT (WINAPI *PFN_MWSNAPSHOT)();
typedef HRESULT (WINAPI *PFN_MWEND)(char *);
typedef HRESULT (WINAPI *PFN_MWMARK)(char *);
typedef HRESULT (WINAPI *PFN_MWEXIT)();

#ifndef NO_ETW_TRACING
#include <wmistr.h>
#include <evntrace.h>

typedef TRACEHANDLE (WINAPI *PFN_GTLOGHANDLE)(PVOID);
typedef ULONG       (WINAPI *PFN_REGTRACE)(WMIDPREQUEST,
                                           PVOID,
                                           LPCGUID,
                                           ULONG,
                                           PTRACE_GUID_REGISTRATION,
                                           LPCTSTR,
                                           LPCTSTR,
                                           PTRACEHANDLE
                                           );
typedef ULONG       (WINAPI *PFN_UNREGTRACE)(TRACEHANDLE);
typedef ULONG       (WINAPI *PFN_TRACE)(TRACEHANDLE, PEVENT_TRACE_HEADER);
#endif

// Stopwatch memory buffer
typedef struct _STOPWATCH
{
    DWORD dwId;     // Node identifier
    DWORD dwTID;    // Thread ID;
    DWORD dwType;   // Node type - start, lap, stop, emtpy
    DWORD dwCount;  // Tick count
    DWORD dwFlags;  // Node flags - memlog, debugout
    TCHAR szDesc[STOPWATCH_MAX_DESC];
} STOPWATCH, *PSTOPWATCH;

// Global stopwatch info data
typedef struct _STOPWATCHINFO
{
    DWORD dwStopWatchMode;
    DWORD dwStopWatchProfile;
    DWORD dwStopWatchListIndex;
    DWORD dwStopWatchListMax;
    DWORD dwStopWatchPaintInterval;

    // SPMODE_MSGTRACE data
    DWORD dwStopWatchMaxDispatchTime;
    DWORD dwStopWatchMaxMsgTime;
    DWORD dwStopWatchMsgInterval;
    DWORD dwcStopWatchOverflow;
    DWORD dwStopWatchLastLocation;
    DWORD dwStopWatchTraceMsg;
    DWORD dwStopWatchTraceMsgCnt;
    DWORD *pdwStopWatchMsgTime;

    // SPMODE_MEMWATCH config data and function pointers
    DWORD dwMemWatchPages;
    DWORD dwMemWatchTime;
    DWORD dwMemWatchFlags;
    BOOL fMemWatchConfig;
    HMODULE hModMemWatch;
    PFN_MWCONFIG pfnMemWatchConfig;
    PFN_MWBEGIN pfnMemWatchBegin;
    PFN_MWSNAPSHOT pfnMemWatchSnapShot;
    PFN_MWEND pfnMemWatchEnd;
    PFN_MWMARK pfnMemWatchMark;
    PFN_MWEXIT pfnMemWatchExit;

    // Perftag data and function pointers
    PERFTAG tagStopWatchStart;
    PERFTAG tagStopWatchStop;
    PERFTAG tagStopWatchLap;
    PFN_PERFREGISTER pfnPerfRegister;
    PFN_PERFLOGFN pfnPerfLogFn;
    PFN_DECODEMESSAGE pfnDecodeMessage;

#ifndef NO_ETW_TRACING
    DWORD dwEventTraceMode;
    PFN_GTLOGHANDLE pfnGetLogHandle;
    PFN_REGTRACE    pfnRegisterTraceGuids;
    PFN_UNREGTRACE  pfnUnRegisterTraceGuids;
    PFN_TRACE       pfnTraceEvent;
#endif

    LPTSTR pszClassNames;

    PSTOPWATCH pStopWatchList;

    // IceCAP data and function pointers
    HMODULE hModICAP;
    PFN_ICAP pfnStartCAPAll;
    PFN_ICAP pfnStopCAPAll;

    HANDLE hMapHtmPerfCtl;
    HTMPERFCTL *pHtmPerfCtl;    
} STOPWATCHINFO, *PSTOPWATCHINFO;

#ifndef NO_ETW_TRACING
#define c_szBrowserResourceName TEXT("Browse")

// Used to turn on/off event tracing.  Setting the registry key enable event
// tracing use, but doesn't turn it on.
// {5576F62E-4142-45a8-9516-262A510C13F0}
const GUID c_BrowserControlGuid = {
    0x5576f62e,
    0x4142,
    0x45a8,
    0x95, 0x16, 0x26, 0x2a, 0x51, 0xc, 0x13, 0xf0};

// Maps to the structure sent to ETW.  ETW definition in
// \nt\sdktools\trace\tracedmp\mofdata.guid
// {2B992163-736F-4a68-9153-95BC5F34D884}
const GUID c_BrowserTraceGuid = {
    0x2b992163,
    0x736f,
    0x4a68,
    0x91, 0x53, 0x95, 0xbc, 0x5f, 0x34, 0xd8, 0x84};

TRACE_GUID_REGISTRATION g_BrowserTraceGuidReg[] =
{
    { (LPGUID)&c_BrowserTraceGuid,
      NULL
    }
};

//
//  The mof fields point to the following data.
//    MOF_FIELD            MofData[0]; // Holds ptr to Url Name
//
typedef struct _ETW_BROWSER_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             MofData[1];
} ETW_BROWSER_EVENT, *PETW_BROWSER_EVENT;


static TRACEHANDLE s_hEtwBrowserRegHandle;
static TRACEHANDLE s_hEtwBrowserLogHandle;

// For SHInterlockedCompareExchange
static BOOL  s_fTRUE = TRUE;
static PVOID s_pvEtwBrowserTraceOnFlag = NULL;
static PVOID s_pvEtwBrowserRegistered = NULL;
static PVOID s_pvEtwBrowserRegistering = NULL;
#endif

PSTOPWATCHINFO g_pswi = NULL;

const TCHAR c_szDefClassNames[] = {STOPWATCH_DEFAULT_CLASSNAMES};

void StopWatch_SignalEvent();

//===========================================================================================
// INTERNAL FUNCTIONS
//===========================================================================================

//===========================================================================================
//===========================================================================================

void PerfCtlCallback(DWORD dwArg1, void * pvArg2)
{
    const TCHAR c_szFmtBrowserStop[] = TEXT("Browser Frame Stop (%s)");
    TCHAR szTitle[STOPWATCH_MAX_TITLE];
    TCHAR szText[STOPWATCH_MAX_TITLE + ARRAYSIZE(c_szFmtBrowserStop) + 1];
    LPTSTR ptr = szTitle;
#ifndef UNICODE    
    INT rc;
#endif
    if(g_pswi->dwStopWatchMode & SPMODE_BROWSER)  // Temp hack to deal with ansi,unicode.  This code will go away when we impl hook in mshtml.
    {
//        GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)-1);

#ifndef UNICODE    
        rc = WideCharToMultiByte(CP_ACP, 0, pvArg2, -1, szTitle, STOPWATCH_MAX_TITLE - 1, NULL, NULL);

        if(!rc)
            StrCpyN(szTitle, "ERROR converting wide to multi", ARRAYSIZE(szTitle) - 1);
#else
        ptr = (LPTSTR) pvArg2;
#endif
        wnsprintf(szText, ARRAYSIZE(szText), c_szFmtBrowserStop, ptr);
        StopWatch_Stop(SWID_BROWSER_FRAME, szText, SPMODE_BROWSER | SPMODE_DEBUGOUT);
        if((g_pswi->dwStopWatchMode & (SPMODE_EVENT | SPMODE_BROWSER)) == (SPMODE_EVENT | SPMODE_BROWSER))
        {
            StopWatch_SignalEvent();
        }
    }
}

#ifndef NO_ETW_TRACING
/*++
  Routine Name:
    ulEtwBrowserControlCallback()
 
  Routine Description:
    This is the function we provide to the ETW subsystem as a callback, it is used to 
    start and stop the trace events.
 
  Arguments:
    IN     WMIDPREQUESTCODE  RequestCode      : The function to provide (enable/disable)
    IN     PVOID             Context          : Not used by us.
    IN OUT ULONG            *InOutBufferSize  : The Buffersize
    IN OUT PVOID             Buffer           : The buffer to use for the events
 
  Returns ERROR_SUCCESS on success, or an error code. 
 
--*/
ULONG
ulEtwBrowserControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID pvContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID pvBuffer
    )
{
    ULONG Status;

    if (!s_pvEtwBrowserRegistered) {
        // Registration hasn't happened yet.
        return ERROR_GEN_FAILURE;
    }
    
    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
#if STOPWATCH_DEBUG
            OutputDebugString("shperf.c:ulEtwBrowserControlCallback enable\n");
#endif
            ASSERT(g_pswi->pfnGetLogHandle);
            s_hEtwBrowserLogHandle = g_pswi->pfnGetLogHandle( pvBuffer );
#if STOPWATCH_DEBUG
            if (s_hEtwBrowserLogHandle == INVALID_HANDLE_VALUE) {
                TCHAR szDbg[256];
                wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1,
                          "ulEtwBrowserControlCallback GLE=%u\n", GetLastError());
                OutputDebugString(szDbg);
            }
#endif
            SHInterlockedCompareExchange(&s_pvEtwBrowserTraceOnFlag, &s_fTRUE, NULL);
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
#if STOPWATCH_DEBUG
            OutputDebugString("shperf.c:ulEtwBrowserControlCallback disable\n");
#endif
            SHInterlockedCompareExchange(&s_pvEtwBrowserTraceOnFlag, NULL, &s_fTRUE);
            s_hEtwBrowserLogHandle = 0;
            break;
        }
        default:
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = 0;
    return(Status);
}

/*++
  Routine Name:
    RegisterTracing()
 
  Routine Description:
    Registers us to the ETW tools
 
  Arguments:
 
  Returns ERROR_SUCCESS on success of all registrations.
--*/
ULONG RegisterTracing()
{
    ULONG Status = ERROR_SUCCESS;
    TCHAR szImagePath[MAX_PATH];

    Status = GetModuleFileName(NULL, szImagePath, sizeof(szImagePath)/sizeof(TCHAR));
    if (Status == 0) {
        Status = ERROR_FILE_NOT_FOUND;
    }
    else {
        if (g_pswi->dwEventTraceMode & SPTRACE_BROWSER) {
            PVOID fRegOn;

            // If browser tracing is not registered, register it, preventing
            // anybody else from trying to do this at the same time.

            fRegOn = SHInterlockedCompareExchange(&s_pvEtwBrowserRegistering, &s_fTRUE, NULL);
            if (!fRegOn) {
                if (!s_pvEtwBrowserRegistered) {
                    ASSERT(g_pswi->pfnRegisterTraceGuids);
                    Status = g_pswi->pfnRegisterTraceGuids(
                        ulEtwBrowserControlCallback,
                        NULL,                 
                        (LPGUID)&c_BrowserControlGuid,
                        1,
                        g_BrowserTraceGuidReg,
                        szImagePath,
                        c_szBrowserResourceName,
                        &s_hEtwBrowserRegHandle);
                    
                    if (Status == ERROR_SUCCESS) {
                        SHInterlockedCompareExchange(&s_pvEtwBrowserRegistered, &s_fTRUE, NULL);
                    }
#if STOPWATCH_DEBUG
                    else {
                        OutputDebugString("shperf.c:Registration of event tracing guids failed.\n");
                    }
#endif
                }
                SHInterlockedCompareExchange(&s_pvEtwBrowserRegistering, NULL, &s_fTRUE);
            }
        }
    }
    return Status;
}

/*++
  Routine Name:
    UnRegisterTracing()
 
  Routine Description:
    Deregisters us from the ETW tools
 
  Arguments:
 
  Returns ERROR_SUCCESS on success. a Winerror otherwise.
 
--*/
ULONG UnRegisterTracing()
{
    ULONG Status = ERROR_SUCCESS;

    // If browser tracing is registered, unregister it.
    if (s_pvEtwBrowserRegistered) {
        SHInterlockedCompareExchange(&s_pvEtwBrowserTraceOnFlag, NULL, &s_fTRUE);
        if(g_pswi && g_pswi->pfnUnRegisterTraceGuids) {
            Status = g_pswi->pfnUnRegisterTraceGuids(s_hEtwBrowserRegHandle);
        }
        if (Status == ERROR_SUCCESS) {
            SHInterlockedCompareExchange(&s_pvEtwBrowserRegistered, NULL, &s_fTRUE);
        }
#if STOPWATCH_DEBUG
        else {
            OutputDebugString("shperf.c:UnRegistration of event tracing guids failed.\n");
        }
#endif
    }
    
    return Status;
}

/*++
  Routine Name:  
    EventTraceHandler()
 
  Routine Description:
    If tracing is turned on, this sends the event to the WMI subsystem.
 
  Arguments:
    UCHAR            EventType      : Kind of trace event
    PVOID            Data           : Data associated with event
--*/
void WINAPI EventTraceHandler(UCHAR uchEventType, PVOID pvData)
{
    if ((g_pswi->dwEventTraceMode & SPTRACE_BROWSER)) 
    {
        if (s_pvEtwBrowserTraceOnFlag)
        {
            ETW_BROWSER_EVENT EtwEvent;
            ULONG Status;
            LPWSTR wszUrl = pvData;

            //
            // Record data.
            //
            ZeroMemory(&EtwEvent, sizeof(EtwEvent));
            EtwEvent.Header.Size  = sizeof(ETW_BROWSER_EVENT);
            EtwEvent.Header.Flags = (WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR);
            EtwEvent.Header.Class.Type = uchEventType;
            EtwEvent.Header.Guid  = c_BrowserTraceGuid;

            EtwEvent.MofData[0].DataPtr = (ULONG64)wszUrl;
            EtwEvent.MofData[0].Length  = (wszUrl
                                           ? (wcslen(wszUrl)+1)*sizeof(WCHAR)
                                           : 0);

            ASSERT(g_pswi->pfnTraceEvent);
            Status = g_pswi->pfnTraceEvent(
                s_hEtwBrowserLogHandle,
                (PEVENT_TRACE_HEADER) &EtwEvent);
        
#if STOPWATCH_DEBUG
            if (Status != ERROR_SUCCESS) {
                TCHAR szDbg[256];
                wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1,
                          "shperf.c:Call to trace event failed %I64x GLE=%u\n",
                          s_hEtwBrowserLogHandle, Status);
                OutputDebugString(szDbg);
            }
#endif
        }

        // Signal event when full web page is downloaded.
        if ((uchEventType == EVENT_TRACE_TYPE_BROWSE_LOADEDPARSED) &&
            (g_pswi->dwStopWatchMode & SPMODE_EVENT)) {
            StopWatch_SignalEvent();
        }
    }
}

// Called through a pointer in the shared memory map section.
void PerfCtlEvntCallback(DWORD dwArg1, void * pvArg2)
{
    EventTraceHandler((UCHAR)dwArg1, pvArg2);
}
#endif

//===========================================================================================
//===========================================================================================
HRESULT SetPerfCtl(DWORD dwFlags)
{
    if (dwFlags == HTMPF_CALLBACK_ONLOAD ||
        dwFlags == HTMPF_CALLBACK_ONEVENT)
    {
        char achName[sizeof(HTMPERFCTL_NAME) + 8 + 1];
        wsprintfA(achName, "%s%08lX", HTMPERFCTL_NAME, GetCurrentProcessId());

        if (g_pswi->hMapHtmPerfCtl == NULL)
            g_pswi->hMapHtmPerfCtl = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 4096, achName);
        if (g_pswi->hMapHtmPerfCtl == NULL)
            return(E_FAIL);
        if (g_pswi->pHtmPerfCtl == NULL)
            g_pswi->pHtmPerfCtl = (HTMPERFCTL *)MapViewOfFile(g_pswi->hMapHtmPerfCtl, FILE_MAP_WRITE, 0, 0, 0);
        if (g_pswi->pHtmPerfCtl == NULL)
            return(E_FAIL);

        g_pswi->pHtmPerfCtl->dwSize  = sizeof(HTMPERFCTL);
        g_pswi->pHtmPerfCtl->dwFlags = dwFlags;
#ifndef NO_ETW_TRACING
        if (dwFlags == HTMPF_CALLBACK_ONEVENT) {
            RegisterTracing();
            // Used by clients, like mshtml, to log events.
            g_pswi->pHtmPerfCtl->pfnCall = PerfCtlEvntCallback;
        }
        else
#endif
            g_pswi->pHtmPerfCtl->pfnCall = PerfCtlCallback;

        g_pswi->pHtmPerfCtl->pvHost  = NULL;
    }

    return S_OK;
}


//===========================================================================================
//===========================================================================================
void StopWatch_SignalEvent()
{
    static HANDLE hEvent = NULL;

    if(hEvent == NULL)
    {
        TCHAR szEventName[256];
        wnsprintf(szEventName, ARRAYSIZE(szEventName), TEXT("%s%x"), TEXT("STOPWATCH_STOP_EVENT"), GetCurrentProcessId());
        hEvent = CreateEvent((LPSECURITY_ATTRIBUTES)NULL, FALSE, FALSE, szEventName);
    }
    if(hEvent != NULL)
        SetEvent(hEvent);
}

//===========================================================================================
//===========================================================================================
HRESULT DoMemWatchConfig(VOID)
{
    HRESULT hr = ERROR_SUCCESS;

    if(g_pswi->hModMemWatch == NULL)
    {
        if((g_pswi->hModMemWatch = LoadLibrary("mwshelp.dll")) != NULL)
        {
            g_pswi->pfnMemWatchConfig = (PFN_MWCONFIG) GetProcAddress(g_pswi->hModMemWatch, "MemWatchConfigure");
            g_pswi->pfnMemWatchBegin = (PFN_MWBEGIN) GetProcAddress(g_pswi->hModMemWatch, "MemWatchBegin");
            g_pswi->pfnMemWatchSnapShot = (PFN_MWSNAPSHOT) GetProcAddress(g_pswi->hModMemWatch, "MemWatchSnapShot");
            g_pswi->pfnMemWatchEnd = (PFN_MWEND) GetProcAddress(g_pswi->hModMemWatch, "MemWatchEnd");
            g_pswi->pfnMemWatchMark = (PFN_MWMARK) GetProcAddress(g_pswi->hModMemWatch, "MemWatchMark");
            g_pswi->pfnMemWatchExit = (PFN_MWEXIT) GetProcAddress(g_pswi->hModMemWatch, "MemWatchExit");
        
            if(g_pswi->pfnMemWatchConfig != NULL)
            {
                hr = g_pswi->pfnMemWatchConfig(g_pswi->dwMemWatchPages, g_pswi->dwMemWatchTime, g_pswi->dwMemWatchFlags);
                if(FAILED(hr))
                    g_pswi->dwStopWatchMode &= ~SPMODE_MEMWATCH;
                else
                    g_pswi->fMemWatchConfig = TRUE;
            }
        }
        else
        {
            g_pswi->hModMemWatch = (HMODULE)1;
        }
    }

    return(hr);
}

//===========================================================================================
// Function: VOID InitStopWatchMode(VOID)
//
// If HKLM\software\microsoft\windows\currentversion\explorer\performance\mode key value
// is set to one of the values described below, the stopwatch mode will be enabled by
// setting the global variable g_pswi->dwStopWatchMode.
//
// SPMODE_SHELL    - Allows the flushing of stopwatch timings to a log file
// SPMODE_DEBUGOUT  - Display timing via OutputDebugString. Only timings marked with SPMODE_DEBUGOUT
//                    through the StopWatch_* calls will be displayed.
// SPMODE_TEST      - Used to display test output.  This allow another level of SPMODE_DEBUGOUT
//                    like output.
//
// If HKLM\software\microsoft\windows\currentversion\explorer\performance\nodes key value
// is set, the size of the timing array will be set to this value.  The default is 100 nodes.
//===========================================================================================
#define REGKEY_PERFMODE        REGSTR_PATH_EXPLORER TEXT("\\Performance")

VOID InitStopWatchMode(VOID)
{
    HKEY hkeyPerfMode;
    DWORD dwVal = 0;
    DWORD cbBuffer;
    DWORD dwType;
    TCHAR szClassNames[256];
#if STOPWATCH_DEBUG
    TCHAR szDbg[256];
#endif

    if(NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_PERFMODE, 0L, MAXIMUM_ALLOWED, &hkeyPerfMode))
    {
        cbBuffer = SIZEOF(dwVal);
        if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("Mode"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
        {
            if((dwVal & SPMODES) == 0)    // Low word is mode, high word is paint timer interval
                dwVal |= SPMODE_SHELL;
                
            if((g_pswi = (PSTOPWATCHINFO)LocalAlloc(LPTR, SIZEOF(STOPWATCHINFO))) == NULL)
                dwVal = 0;
        }

        if(dwVal != 0)
        {
            g_pswi->dwStopWatchMode = dwVal;
            g_pswi->dwStopWatchListMax = STOPWATCH_MAX_NODES;
            g_pswi->dwStopWatchPaintInterval = STOPWATCH_DEFAULT_PAINT_INTERVAL;
            g_pswi->dwStopWatchMaxDispatchTime = STOPWATCH_DEFAULT_MAX_DISPATCH_TIME;
            g_pswi->dwStopWatchMaxMsgTime = STOPWATCH_DEFAULT_MAX_MSG_TIME;
            g_pswi->dwStopWatchMsgInterval = STOPWATCH_DEFAULT_MAX_MSG_INTERVAL;
            g_pswi->pszClassNames = (LPTSTR)c_szDefClassNames;
            g_pswi->dwMemWatchPages = MEMWATCH_DEFAULT_PAGES;
            g_pswi->dwMemWatchTime = MEMWATCH_DEFAULT_TIME;
            g_pswi->dwMemWatchFlags = MEMWATCH_DEFAULT_FLAGS;
#ifndef NO_ETW_TRACING
            g_pswi->dwEventTraceMode = 0;
#endif
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("Profile"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwStopWatchProfile = dwVal;
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("Nodes"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwStopWatchListMax = dwVal;
            cbBuffer = SIZEOF(szClassNames);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("ClassNames"), NULL, &dwType, (LPBYTE)&szClassNames, &cbBuffer))
            {
                if((g_pswi->pszClassNames = (LPTSTR)LocalAlloc(LPTR, SIZEOF(LPTSTR) * cbBuffer)) != NULL)
                    CopyMemory(g_pswi->pszClassNames, szClassNames, SIZEOF(LPTSTR) * cbBuffer);
            }
            cbBuffer = SIZEOF(dwVal);
            // begin - Remove this after StopWatch users convert to using PaintInterval key
            g_pswi->dwStopWatchPaintInterval = HIWORD(g_pswi->dwStopWatchMode) ?HIWORD(g_pswi->dwStopWatchMode) :STOPWATCH_DEFAULT_PAINT_INTERVAL;    // Use high word of mode reg key value for interval
            // end - Remove this after StopWatch users convert to using PaintInterval key
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("PaintInterval"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwStopWatchPaintInterval = dwVal;

            // Get MemWatch data
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MWPages"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwMemWatchPages = dwVal;
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MWTime"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwMemWatchTime = dwVal;
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MWFlags"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwMemWatchFlags = dwVal;

#ifndef NO_ETW_TRACING
            if (g_pswi->dwStopWatchMode & SPMODE_EVENTTRACE) {
                // Load the ETW operations individually to make sure the system
                // this proc is running on supports them.
                HMODULE hMod;
                if ((hMod = LoadLibrary("advapi32.dll")) != NULL) {
                    g_pswi->pfnGetLogHandle = (PFN_GTLOGHANDLE) GetProcAddress(hMod, "GetTraceLoggerHandle");
                    g_pswi->pfnUnRegisterTraceGuids = (PFN_UNREGTRACE) GetProcAddress(hMod, "UnregisterTraceGuids");
                    g_pswi->pfnTraceEvent = (PFN_TRACE) GetProcAddress(hMod, "TraceEvent");
                    g_pswi->pfnRegisterTraceGuids =
#if defined(UNICODE) || defined(_UNICODE)
                        (PFN_REGTRACE) GetProcAddress(hMod, "RegisterTraceGuidsW");
#else
                        (PFN_REGTRACE) GetProcAddress(hMod, "RegisterTraceGuidsA");
#endif
                }
                else {
                    g_pswi->pfnGetLogHandle = NULL;
                    g_pswi->pfnUnRegisterTraceGuids = NULL;
                    g_pswi->pfnTraceEvent = NULL;
                    g_pswi->pfnRegisterTraceGuids = NULL;
                }

                if (!hMod                            ||
                    !g_pswi->pfnGetLogHandle         ||
                    !g_pswi->pfnUnRegisterTraceGuids ||
                    !g_pswi->pfnTraceEvent           ||
                    !g_pswi->pfnRegisterTraceGuids) {
                    // Event trace calls will never be made now.
#if STOPWATCH_DEBUG
                    wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1, "~SPMODE_EVENTTRACE load procs from advapi32.dll failed.\n");
                    OutputDebugString(szDbg);
#endif
                    g_pswi->dwStopWatchMode &= ~SPMODE_EVENTTRACE;
                }
                else {
                    // Set type of event tracing before setting up the call back.
                    cbBuffer = SIZEOF(dwVal);
                    if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("EventTrace"), NULL,
                                                   &dwType, (LPBYTE)&dwVal, &cbBuffer)) {
                        g_pswi->dwEventTraceMode = dwVal;
                        // You can only have one callback, so don't allow browser
                        // stopwatch and browser event tracing.
                        g_pswi->dwStopWatchMode &= ~SPMODE_BROWSER;
                    }
                }
            }
#endif

            if(g_pswi->dwStopWatchMode & SPMODES)
            {
#ifndef NO_ETW_TRACING
                SetPerfCtl(g_pswi->dwStopWatchMode & SPMODE_EVENTTRACE
                           // See mshtmdbg.h
                           ? HTMPF_CALLBACK_ONEVENT
                           : HTMPF_CALLBACK_ONLOAD);
#else
                SetPerfCtl(HTMPF_CALLBACK_ONLOAD);
#endif
            }
            
            if(g_pswi->dwStopWatchMode & SPMODE_MSGTRACE)
            {
                cbBuffer = SIZEOF(dwVal);
                if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MaxDispatchTime"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                    g_pswi->dwStopWatchMaxDispatchTime = dwVal;
                cbBuffer = SIZEOF(dwVal);
                if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MaxMsgTime"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                    g_pswi->dwStopWatchMaxMsgTime = dwVal;
                cbBuffer = SIZEOF(dwVal);
                if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MsgInterval"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                    g_pswi->dwStopWatchMsgInterval = dwVal;
                cbBuffer = SIZEOF(dwVal);
                if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("TraceMsg"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                    g_pswi->dwStopWatchTraceMsg = dwVal;

                if((g_pswi->pdwStopWatchMsgTime = (DWORD *)LocalAlloc(LPTR, sizeof(DWORD) * (g_pswi->dwStopWatchMaxMsgTime / g_pswi->dwStopWatchMsgInterval))) == NULL)
                    g_pswi->dwStopWatchMode &= ~SPMODE_MSGTRACE;
            }

            if((g_pswi->pStopWatchList = (PSTOPWATCH)LocalAlloc(LPTR, sizeof(STOPWATCH)* g_pswi->dwStopWatchListMax)) == NULL) {
                g_pswi->dwStopWatchMode = 0;
#ifndef NO_ETW_TRACING
                // Just in case this didn't fail too.
                UnRegisterTracing();
#endif
            }
            if(g_pswi->dwStopWatchMode & SPMODE_PERFTAGS)
            {
                HMODULE hMod;
                if((hMod = LoadLibrary("mshtmdbg.dll")) != NULL)
                {
                    g_pswi->pfnPerfRegister = (PFN_PERFREGISTER) GetProcAddress(hMod, "DbgExPerfRegister");
                    g_pswi->pfnPerfLogFn = (PFN_PERFLOGFN) GetProcAddress(hMod, "DbgExPerfLogFn");
                    g_pswi->pfnDecodeMessage = (PFN_DECODEMESSAGE) GetProcAddress(hMod, "DbgExDecodeMessage");
                }
                else
                {
#if STOPWATCH_DEBUG
                    wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1, "~SPMODE_PERFTAGS loadlib mshtmdbg.dll failed GLE=0x%x\n", GetLastError());
                    OutputDebugString(szDbg);
#endif
                    g_pswi->dwStopWatchMode &= ~SPMODE_PERFTAGS;
                }
                
                if(g_pswi->pfnPerfRegister != NULL)
                {
                    g_pswi->tagStopWatchStart = g_pswi->pfnPerfRegister("tagStopWatchStart", "StopWatchStart", "SHLWAPI StopWatch start time");
                    g_pswi->tagStopWatchStop = g_pswi->pfnPerfRegister("tagStopWatchStop", "StopWatchStop", "SHLWAPI StopWatch stop time");
                    g_pswi->tagStopWatchLap = g_pswi->pfnPerfRegister("tagStopWatchLap", "StopWatchLap", "SHLWAPI StopWatch lap time");
                }
            }
            
#ifdef STOPWATCH_DEBUG
            // Display option values
            {
                LPCTSTR ptr;
                
                wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1, TEXT("StopWatch Mode=0x%x Profile=0x%x Nodes=%d PaintInterval=%d MemBuf=%d bytes\n"),
                    g_pswi->dwStopWatchMode, g_pswi->dwStopWatchProfile, g_pswi->dwStopWatchListMax, g_pswi->dwStopWatchPaintInterval, g_pswi->dwStopWatchListMax * sizeof(STOPWATCH));
                OutputDebugString(szDbg);

                OutputDebugString(TEXT("Stopwatch ClassNames="));
                ptr = g_pswi->pszClassNames;
                while(*ptr)
                {
                    wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1, TEXT("'%s' "), ptr);
                    OutputDebugString(szDbg);
                    ptr = ptr + (lstrlen(ptr) + 1);
                }
                OutputDebugString(TEXT("\n"));
                
                if(g_pswi->dwStopWatchMode & SPMODE_MSGTRACE)
                {
                    wnsprintf(szDbg, ARRAYSIZE(szDbg)-1, TEXT("StopWatch MaxDispatchTime=%dms MaxMsgTime=%dms MsgInterval=%dms TraceMsg=0x%x MemBuf=%d bytes\n"),
                        g_pswi->dwStopWatchMaxDispatchTime, g_pswi->dwStopWatchMaxMsgTime, g_pswi->dwStopWatchMsgInterval, g_pswi->dwStopWatchTraceMsg, sizeof(DWORD) * (g_pswi->dwStopWatchMaxMsgTime / g_pswi->dwStopWatchMsgInterval));
                    OutputDebugString(szDbg);
                }
                
                if(g_pswi->dwStopWatchMode & SPMODE_MEMWATCH)
                {
                    wnsprintf(szDbg, ARRAYSIZE(szDbg)-1, TEXT("StopWatch MemWatch Pages=%d Time=%dms Flags=%d\n"),
                        g_pswi->dwMemWatchPages, g_pswi->dwMemWatchTime, g_pswi->dwMemWatchFlags);
                    OutputDebugString(szDbg);
                }
            }
#endif
        }       //         if(dwVal != 0)
        
        RegCloseKey(hkeyPerfMode);
    }
}

//===========================================================================================
// EXPORTED FUNCTIONS
//===========================================================================================

//===========================================================================================
// Function: DWORD WINAPI StopWatchMode(VOID)
//
// Returns:  The value of the global mode variable.  Modules should use this call, set their
//           own global, and use this global to minimize and overhead when stopwatch mode
//           is not enabled.
//===========================================================================================
DWORD WINAPI StopWatchMode(VOID)
{
    if(g_pswi != NULL)
        return(g_pswi->dwStopWatchMode);
    else
        return(0);
}


//===========================================================================================
//===========================================================================================
const TCHAR c_szBrowserStop[] = TEXT("Browser Frame Stop (%s)");

DWORD MakeStopWatchDesc(DWORD dwId, DWORD dwMarkType, LPCTSTR pszDesc, LPTSTR *ppszText, DWORD dwTextLen)
{
    LPSTR lpszFmt = NULL;
    DWORD dwRC = 0;
    
    switch(SWID(dwId))
    {
        case SWID_BROWSER_FRAME:
            lpszFmt = (LPSTR)c_szBrowserStop;
            break;
        default:
            return(dwRC);
    }

    if(((DWORD)(lstrlen(lpszFmt) + lstrlen(pszDesc)) - 1) < dwTextLen)
        dwRC = wnsprintf(*ppszText, dwTextLen - 1, lpszFmt, pszDesc);
    else
        StrCpyN(*ppszText, TEXT("ERROR:Desc too long!"), dwTextLen -1);

    return(dwRC);
}

#define STARTCAPALL 1
#define STOPCAPALL 2
#define iStartCAPAll() CallICAP(STARTCAPALL)
#define iStopCAPAll() CallICAP(STOPCAPALL)

//===========================================================================================
//===========================================================================================
VOID CallICAP(DWORD dwFunc)
{
    if(g_pswi->hModICAP == NULL)
    {
        if((g_pswi->hModICAP = LoadLibrary("icap.dll")) != NULL)
        {
            g_pswi->pfnStartCAPAll = (PFN_ICAP) GetProcAddress(g_pswi->hModICAP, "StartCAPAll");
            g_pswi->pfnStopCAPAll = (PFN_ICAP) GetProcAddress(g_pswi->hModICAP, "StopCAPAll");
        }
        else
        {
            g_pswi->hModICAP = (HMODULE)1;
        }
    }

    switch(dwFunc)
    {
        case STARTCAPALL:
            if(g_pswi->pfnStartCAPAll != NULL)
                g_pswi->pfnStartCAPAll();
            break;
        case STOPCAPALL:
            if(g_pswi->pfnStopCAPAll != NULL)
                g_pswi->pfnStopCAPAll();
            break;
    }
}

//===========================================================================================
//===========================================================================================
VOID CapBreak(BOOL fStart)
{
    if((g_pswi->dwStopWatchMode & SPMODE_PROFILE) || (g_pswi->pHtmPerfCtl->dwFlags & HTMPF_ENABLE_PROFILE))
    {
        if(fStart)
            iStartCAPAll();
        else
            iStopCAPAll();
    }

    if((g_pswi->dwStopWatchMode & SPMODE_MEMWATCH) || (g_pswi->pHtmPerfCtl->dwFlags & HTMPF_ENABLE_MEMWATCH))
    {
        if(g_pswi->hModMemWatch == NULL)
            DoMemWatchConfig();
            
        if(fStart)
        {
            if(g_pswi->pfnMemWatchBegin != NULL)
            {
                g_pswi->pfnMemWatchBegin(TRUE, FALSE);  // synchronous and don't use timer
            }
        }
        else
        {
            if(g_pswi->pfnMemWatchSnapShot != NULL)
            {
                g_pswi->pfnMemWatchSnapShot();
            }
            
            if(g_pswi->pfnMemWatchEnd != NULL)
            {
                CHAR szOutFile[MAX_PATH];
                DWORD dwLen;
                HRESULT hr;
#if STOPWATCH_DEBUG
                CHAR szDbg[256];
#endif
#ifndef UNIX
                *szOutFile = '\0';
                GetWindowsDirectoryA(szOutFile, ARRAYSIZE(szOutFile) - 1);
                dwLen = lstrlenA(szOutFile);
                if ((dwLen > 0) && (szOutFile[dwLen-1] == '\\'))   // See if windows is installed in the root
                    szOutFile[dwLen-1] = '\0';
                StrNCatA(szOutFile, "\\shperf.mws", ARRAYSIZE(szOutFile) - 1);
#else
                StrCpyNA(szOutFile, ARRAYSIZE(szOutFile) - 1, "shperf.mws");
#endif

                hr = g_pswi->pfnMemWatchEnd(szOutFile);
                
#if STOPWATCH_DEBUG
                switch(hr)
                {
                    case E_FAIL:
                        wnsprintfA(szDbg,  ARRAYSIZE(szDbg) - 1, "MemWatch SaveBuffer:%s failed. GLE:0x%x\n", szOutFile, GetLastError());
                        OutputDebugStringA(szDbg);
                        break;
                    case E_ABORT:
                        wnsprintfA(szDbg,  ARRAYSIZE(szDbg) - 1, "MemWatch SaveBuffer: No data to save.\n");
                        OutputDebugStringA(szDbg);
                        break;
                }
#endif
                if(g_pswi->pfnMemWatchExit != NULL)
                    g_pswi->pfnMemWatchExit();
            }
        }
    }
    
    if(g_pswi->dwStopWatchMode & SPMODE_DEBUGBREAK)
    {
        DebugBreak();
    }
}

//===========================================================================================
// Function: DWORD WINAPI StopWatch(
//               DWORD dwId,        // The unique identifier, SWID_*, used to associate start, lap, and
//                                  // stop timings for a given timing sequence.
//               LPCSTR pszDesc,    // Descriptive text for the timing.
//               DWORD dwMarkType,  // START_NODE, LAP_NODE, STOP_NODE
//               DWORD dwFlags,     // SPMODE_SHELL, SPMODE_DEBUGOUT, SPMODE_*. The timing call is used
//                                     only if g_pswi->dwStopWatchMode contains dwFlags
//               DWORD dwID)        // Unique ID (Thread ID or user-supplied value)
//
// Macros:   StopWatch_Start(dwId, pszDesc, dwFlags)
//           StopWatch_Lap(dwId, pszDesc, dwFlags)
//           StopWatch_Stop(dwId, pszDesc, dwFlags)
//
// Returns:  ERROR_SUCCESS or ERROR_NOT_ENOUGH_MEMORY if out of nodes
//===========================================================================================
DWORD _StopWatch(DWORD dwId, LPCTSTR pszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount, DWORD dwUniqueID)
{
    PSTOPWATCH psp;
#ifdef STOPWATCH_DEBUG
    PSTOPWATCH pspPrev;
#endif    
    DWORD dwDelta = 0;
    DWORD dwRC = ERROR_SUCCESS;
    DWORD dwIndex;
    TCHAR szText[STOPWATCH_MAX_DESC];
    LPTSTR psz;

    if((SWID(dwId) && g_pswi->dwStopWatchProfile) && (dwMarkType == STOP_NODE))
    {
        CapBreak(FALSE);
    }

    if((g_pswi->pStopWatchList != NULL) && ((dwFlags & g_pswi->dwStopWatchMode) & SPMODES))
    {
        ENTERCRITICAL;
        dwIndex = g_pswi->dwStopWatchListIndex++;
        LEAVECRITICAL;

        if(dwIndex < (g_pswi->dwStopWatchListMax-1))
        {
            psp = g_pswi->pStopWatchList + (dwIndex);

            psp->dwCount = (dwCount != 0 ?dwCount :GetPerfTime());       // Save the data
            psp->dwId = dwId;
            psp->dwTID = dwUniqueID ? dwUniqueID : GetCurrentThreadId();
            psp->dwType = dwMarkType;
            psp->dwFlags = dwFlags;

            psz = (LPTSTR)pszDesc;
            if(dwFlags & SPMODE_FORMATTEXT)
            {
                psz = (LPTSTR)szText;
                MakeStopWatchDesc(dwId, dwMarkType, pszDesc, &psz, ARRAYSIZE(szText));
            }
            
            StrCpyN(psp->szDesc, psz, ARRAYSIZE(psp->szDesc)-1);

            if((g_pswi->dwStopWatchMode & SPMODE_PERFTAGS) && (g_pswi->pfnPerfLogFn != NULL))
            {
                if(dwMarkType == START_NODE)
                    g_pswi->pfnPerfLogFn(g_pswi->tagStopWatchStart, IntToPtr(dwId), psz);
                    
                if(dwMarkType == STOP_NODE)
                    g_pswi->pfnPerfLogFn(g_pswi->tagStopWatchStop, IntToPtr(dwId), psz);

                if(dwMarkType == LAP_NODE)
                    g_pswi->pfnPerfLogFn(g_pswi->tagStopWatchLap, IntToPtr(dwId), psz);
            }
    
#ifdef STOPWATCH_DEBUG
            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
            {
                const TCHAR c_szFmt_StopWatch_DbgOut[] = TEXT("StopWatch: 0x%x: %s: Time: %u ms\r\n");
                TCHAR szBuf[STOPWATCH_MAX_DESC + ARRAYSIZE(c_szFmt_StopWatch_DbgOut) + 40];    // 8=dwTID 10=dwDelta
                
                if(psp->dwType > START_NODE)   // Find the previous associated node to get delta time
                {
                    pspPrev = psp - 1;
                    while(pspPrev >= g_pswi->pStopWatchList)
                    {
                        if((SWID(pspPrev->dwId) == SWID(psp->dwId)) &&  // Found a match
                           (pspPrev->dwTID == psp->dwTID) &&
                           (pspPrev->dwType == START_NODE))
                        {
                            dwDelta = psp->dwCount - pspPrev->dwCount;
                            break;
                        }
                        pspPrev--;
                    }
                }

                wnsprintf((LPTSTR)szBuf, ARRAYSIZE(szBuf), c_szFmt_StopWatch_DbgOut, psp->dwTID, psp->szDesc, dwDelta);
                OutputDebugString(szBuf);
            }
#endif

            if((dwMarkType == STOP_NODE) && (g_pswi->dwStopWatchMode & SPMODE_FLUSH) && (SWID(dwId) == SWID_FRAME))
            {
                StopWatchFlush();
            }
        }
        else
        {
            psp = g_pswi->pStopWatchList + (g_pswi->dwStopWatchListMax-1);  // Set the last node to a message so the user knows we ran out or mem
            psp->dwId = 0;
            psp->dwType = OUT_OF_NODES;
            psp->dwFlags = dwFlags;
            wnsprintf(psp->szDesc, STOPWATCH_MAX_DESC, TEXT("Out of perf timing nodes."));

#ifdef STOPWATCH_DEBUG
            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                OutputDebugString(psp->szDesc);
#endif

            dwRC = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if((SWID(dwId) && g_pswi->dwStopWatchProfile) && (dwMarkType == START_NODE))
    {
        CapBreak(TRUE);
    }

    return(dwRC);
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI StopWatchA(DWORD dwId, LPCSTR pszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount)
{
#ifdef UNICODE
    INT rc;
    WCHAR wszDesc[STOPWATCH_MAX_DESC];

    rc = MultiByteToWideChar(CP_ACP, 0, pszDesc, -1, wszDesc, STOPWATCH_MAX_DESC);
  
    if(!rc)
        return(ERROR_NOT_ENOUGH_MEMORY);

    return(_StopWatch(dwId, (LPCTSTR)wszDesc, dwMarkType, dwFlags, dwCount, 0));
#else
    return(_StopWatch(dwId, (LPCTSTR)pszDesc, dwMarkType, dwFlags, dwCount, 0));
#endif
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI StopWatchW(DWORD dwId, LPCWSTR pwszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount)
{
#ifndef UNICODE    
    INT rc;
    CHAR szDesc[STOPWATCH_MAX_DESC];

    rc = WideCharToMultiByte(CP_ACP, 0, pwszDesc, -1, szDesc, STOPWATCH_MAX_DESC, NULL, NULL);
  
    if(!rc)
        return(ERROR_NOT_ENOUGH_MEMORY);

    return(_StopWatch(dwId, (LPCTSTR)szDesc, dwMarkType, dwFlags, dwCount, 0));
#else
    return(_StopWatch(dwId, (LPCTSTR)pwszDesc, dwMarkType, dwFlags, dwCount, 0));
#endif
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI StopWatchExA(DWORD dwId, LPCSTR pszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount, DWORD dwCookie)
{
#ifdef UNICODE
    INT rc;
    WCHAR wszDesc[STOPWATCH_MAX_DESC];

    rc = MultiByteToWideChar(CP_ACP, 0, pszDesc, -1, wszDesc, STOPWATCH_MAX_DESC);
  
    if(!rc)
        return(ERROR_NOT_ENOUGH_MEMORY);

    return(_StopWatch(dwId, (LPCTSTR)wszDesc, dwMarkType, dwFlags, dwCount, dwCookie));
#else
    return(_StopWatch(dwId, (LPCTSTR)pszDesc, dwMarkType, dwFlags, dwCount, dwCookie));
#endif
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI StopWatchExW(DWORD dwId, LPCWSTR pwszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount, DWORD dwCookie)
{
#ifndef UNICODE    
    INT rc;
    CHAR szDesc[STOPWATCH_MAX_DESC];

    rc = WideCharToMultiByte(CP_ACP, 0, pwszDesc, -1, szDesc, STOPWATCH_MAX_DESC, NULL, NULL);
  
    if(!rc)
        return(ERROR_NOT_ENOUGH_MEMORY);

    return(_StopWatch(dwId, (LPCTSTR)szDesc, dwMarkType, dwFlags, dwCount, dwCookie));
#else
    return(_StopWatch(dwId, (LPCTSTR)pwszDesc, dwMarkType, dwFlags, dwCount, dwCookie));
#endif
}

//===========================================================================================
// Function: DWORD WINAPI StopWatchFlush(VOID)
//
// This function will flush any SPMODE_SHELL nodes to windir\shperf.log.  Calling this function
// will also clear all nodes.
//
// Return:   ERROR_SUCCESS if the log file was generated
//           ERROR_NO_DATA if the timing array is empty
//           ERROR_INVALID_DATA if stopwatch mode is not enabled or the timing array does
//              not exist.
//===========================================================================================
DWORD WINAPI StopWatchFlush(VOID)
{
    PSTOPWATCH psp;
    PSTOPWATCH psp1 = NULL;
    BOOL fWroteStartData;
    DWORD dwRC = ERROR_SUCCESS;
    DWORD dwWritten;
    DWORD dwDelta;
    DWORD dwPrevCount;
    DWORD dwCummDelta;
    DWORD dwLen = 0;
    HANDLE hFile;
    SYSTEMTIME st;
    TCHAR szBuf[STOPWATCH_MAX_BUF];
    TCHAR szFileName[MAX_PATH];
#ifdef STOPWATCH_DEBUG
    TCHAR szDbg[512];
#endif

    if((!g_pswi->dwStopWatchMode) || (g_pswi->pStopWatchList == NULL))
    {
        SetLastError(ERROR_INVALID_DATA);
        return(ERROR_INVALID_DATA);
    }

    GetSystemTime(&st);

    if(g_pswi->dwStopWatchListIndex > 0)
    {
        ENTERCRITICAL;
        if(g_pswi->dwStopWatchListIndex > 0)
        {
            g_pswi->dwStopWatchListIndex = 0;

            if(g_pswi->dwStopWatchMode & SPMODES)
            {

#ifdef STOPWATCH_DEBUG
                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                    OutputDebugString(TEXT("Flushing shell perf data to shperf.log\r\n"));
#endif

#ifndef UNIX
                // Used below as well to create msg trace log file
                dwLen = GetWindowsDirectory(szFileName, MAX_PATH);
                szFileName[dwLen] = 0;
                if(dwLen && szFileName[dwLen-1] == TEXT('\\'))   // See if windows is installed in the root
                    szFileName[dwLen-1] = TEXT('\0');
                StrNCat(szFileName, TEXT("\\shperf.log"), ARRAYSIZE(szFileName) -1);
#else
                StrCpyN(szFileName, TEXT("shperf.log"), ARRAYSIZE(szFileName)-1);
#endif

                if((hFile = CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
                {
                    SetFilePointer(hFile, 0, NULL, FILE_END);

                    psp = g_pswi->pStopWatchList;
                    while(psp->dwType != EMPTY_NODE)
                    {
#ifdef STOPWATCH_DEBUG
                        if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                        {
                            wnsprintf(szDbg, ARRAYSIZE(szDbg), TEXT("ID:%d TID:0x%x Type:%d Flgs:%d %s\r\n"),
                                psp->dwId, psp->dwTID, psp->dwType, psp->dwFlags, psp->szDesc);
                            OutputDebugString(szDbg);
                        }
#endif
                        if(psp->dwType == START_NODE)
                        {
                            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%02d%02d%02d%02d%02d%02d\t0x%x\t%s\t%lu\t"), 
                                st.wYear, st.wMonth, st.wDay,
                                st.wHour, st.wMinute, st.wSecond,
                                psp->dwId, psp->szDesc, psp->dwCount);

#ifdef STOPWATCH_DEBUG
                            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                                OutputDebugString(TEXT("Found Start Node\r\n"));
#endif

                            dwDelta = dwCummDelta = 0;
                            dwPrevCount = psp->dwCount;

                            psp1 = psp + 1;
                            fWroteStartData = FALSE;
                            while(psp1->dwType != EMPTY_NODE)
                            {
#ifdef STOPWATCH_DEBUG
                                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                                {
                                    wnsprintf(szDbg, ARRAYSIZE(szDbg), TEXT("  ID:%d TID:0x%x Type:%d Flgs:%d %s\r\n"),
                                        psp1->dwId, psp1->dwTID, psp1->dwType, psp1->dwFlags, psp1->szDesc);
                                    OutputDebugString(szDbg);
                                }
#endif
                                if((SWID(psp1->dwId) == SWID(psp->dwId)) && 
                                   (psp1->dwTID == psp->dwTID))     // Found a matching LAP or STOP node
                                {
                                    if(psp1->dwType != START_NODE)
                                    {
                                        dwDelta = psp1->dwCount - dwPrevCount;
                                        dwCummDelta += dwDelta;

                                        if(!fWroteStartData)
                                        {
                                            fWroteStartData = TRUE;
                                            WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);  // Write out start node data
                                        }
                                        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s\t%lu,%lu,%lu\t"), psp1->szDesc, psp1->dwCount, dwDelta, dwCummDelta);
                                        WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
#ifdef STOPWATCH_DEBUG
                                        if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                                            OutputDebugString(TEXT("  Found Lap/Stop Node\r\n"));
#endif

                                        dwPrevCount = psp1->dwCount;

                                        if(psp1->dwType == STOP_NODE && !(g_pswi->dwStopWatchMode & SPMODE_MARS))
                                            break;
                                    }
                                    else    // We have another start node that matches our Id/TID and we haven't had a stop.  Log as a missing stop.
                                    {
                                        if(!fWroteStartData)
                                        {
                                            fWroteStartData = TRUE;
                                            WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);  // Write out start node data
                                        }
                                        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("ERROR: missing stop time"), psp1->szDesc, psp1->dwCount, dwDelta, dwCummDelta);
                                        WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
                                        break;
                                    }
                                }
                
                                psp1++;
                            }

                            WriteFile(hFile, TEXT("\r\n"), 2, &dwWritten, NULL);
                        }
                        else if(psp->dwType == OUT_OF_NODES)
                        {
                            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%02d%02d%02d%02d%02d%02d\t0x%x\t%s\n"), 
                                st.wYear, st.wMonth, st.wDay,
                                st.wHour, st.wMinute, st.wSecond,
                                psp->dwId, psp->szDesc);
                            WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
                        }
                        psp->dwType = EMPTY_NODE;
                        psp++;
                    }
                    FlushFileBuffers(hFile);
                    CloseHandle(hFile);
                }
                else
                {
#ifdef STOPWATCH_DEBUG
                    wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("CreateFile failed on '%s'.  GLE=%d\n"), szFileName, GetLastError());
                    OutputDebugString(szBuf);
#endif
                    dwRC = ERROR_NO_DATA;
                }
            }
            else    // !(g_pswi->dwStopWatchMode)
            {
                psp = g_pswi->pStopWatchList;
                while(psp->dwType != EMPTY_NODE)
                {
                    psp->dwType = EMPTY_NODE;
                    psp++;
                }
            }
        }           // (g_pswi->dwStopWatchListIndex > 0)
        LEAVECRITICAL;
    }

    if(g_pswi->dwStopWatchMode & SPMODE_MSGTRACE)
    {
        int i;

#ifndef UNIX
        lstrcpy(&szFileName[dwLen], TEXT("\\msgtrace.log"));
#else
        StrCpy(szFileName, TEXT("msgtrace.log"));
#endif

        if((hFile = CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
        {
            SetFilePointer(hFile, 0, NULL, FILE_END);
            
            for (i = 0; i < (int)(g_pswi->dwStopWatchMaxMsgTime / g_pswi->dwStopWatchMsgInterval); ++i)
            {
                wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("%02d%02d%02d%02d%02d%02d\tMsgTrace\t%4d - %4dms\t%d\r\n"),
                    st.wYear, st.wMonth, st.wDay,
                    st.wHour, st.wMinute, st.wSecond,
                    i * g_pswi->dwStopWatchMsgInterval, (i+1)*g_pswi->dwStopWatchMsgInterval-1, *(g_pswi->pdwStopWatchMsgTime + i));
                WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
#ifdef STOPWATCH_DEBUG
                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                    OutputDebugString(szBuf);
#endif
            }
              
            wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("%02d%02d%02d%02d%02d%02d\tMsgTrace\tmsgs >= %dms\t%d\r\n"), 
                st.wYear, st.wMonth, st.wDay,
                st.wHour, st.wMinute, st.wSecond,
                g_pswi->dwStopWatchMaxMsgTime, g_pswi->dwcStopWatchOverflow);
            WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
#ifdef STOPWATCH_DEBUG
            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                OutputDebugString(szBuf);
#endif

            if(g_pswi->dwStopWatchTraceMsg > 0)
            {
                wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("%02d%02d%02d%02d%02d%02d\tMsgTrace\tmsg 0x%x occured %d times.\r\n"), 
                    st.wYear, st.wMonth, st.wDay,
                    st.wHour, st.wMinute, st.wSecond,
                    g_pswi->dwStopWatchTraceMsg, g_pswi->dwStopWatchTraceMsgCnt);
                WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
#ifdef STOPWATCH_DEBUG
                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                    OutputDebugString(szBuf);
#endif
            }
            
            FlushFileBuffers(hFile);
            CloseHandle(hFile);
        }
        else
        {
#ifdef STOPWATCH_DEBUG
            wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("CreateFile failed on '%s'.  GLE=%d\n"), szFileName, GetLastError());
            OutputDebugString(szBuf);
#endif
            dwRC = ERROR_NO_DATA;
        }
    }

    return(dwRC);
}

//===========================================================================================
// The following StopWatch messages are used to drive the timer msg handler.  The timer proc is used
// as a means of delaying while watching paint messages.  If the defined number of timer ticks has 
// passed without getting any paint messages, then we mark the time of the last paint message we've 
// saved as the stop time.
//===========================================================================================
VOID CALLBACK StopWatch_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    StopWatch_TimerHandler(hwnd, 1, SWMSG_TIMER, NULL);
}

//===========================================================================================
//===========================================================================================
BOOL WINAPI StopWatch_TimerHandler(HWND hwnd, UINT uInc, DWORD dwFlag, MSG* pmsg)
{
    static INT iNumTimersRcvd = 0;
    static DWORD dwCnt = 0;
    static BOOL bActive = FALSE;
    static BOOL bHaveFirstPaintMsg = FALSE;

    switch(dwFlag)
    {
        case SWMSG_PAINT:
            if(bActive)
            {
                dwCnt = GetPerfTime();  // Save tick for last paint message
                iNumTimersRcvd = 0;     // Reset timers received count

                if(!bHaveFirstPaintMsg)
                {
                    TCHAR szClassName[40];  // If the class matches and its the first paint msg mark a lap time
                    LPCTSTR ptr;
                    GetClassName(pmsg->hwnd, szClassName, ARRAYSIZE(szClassName)-1);

                    ptr = g_pswi->pszClassNames;
                    while(*ptr)
                    {
                        if(lstrcmpi(szClassName, ptr) == 0)
                        {
                            bHaveFirstPaintMsg = TRUE;
                            StopWatch_LapTimed(SWID_FRAME, TEXT("Shell Frame 1st Paint"), SPMODE_SHELL | SPMODE_DEBUGOUT, dwCnt);
                            break;
                        }
                        ptr = ptr + (lstrlen(ptr) + 1);
                    }
                }
            }
            break;

        case SWMSG_TIMER:
            iNumTimersRcvd += uInc;
            if(iNumTimersRcvd >= 3)     // If we've received this arbitrary # of timer msgs, mark stop time using the saved last paint tick count
            {
                const TCHAR c_szFmtShellStop[] = TEXT("Shell Frame Stop (%s)");
                TCHAR szTitle[STOPWATCH_MAX_TITLE];
                TCHAR szText[ARRAYSIZE(c_szFmtShellStop) + STOPWATCH_MAX_TITLE + 1];

                KillTimer(hwnd, ID_STOPWATCH_TIMER);
                GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)-1);
                wnsprintf(szText, ARRAYSIZE(szText), c_szFmtShellStop, szTitle);
                StopWatch_StopTimed(SWID_FRAME, szText, SPMODE_SHELL | SPMODE_DEBUGOUT, dwCnt);
                bHaveFirstPaintMsg = FALSE;
                bActive = FALSE;  // Done timing

                if((g_pswi->dwStopWatchMode & (SPMODE_EVENT | SPMODE_SHELL)) == (SPMODE_EVENT | SPMODE_SHELL))
                {
                    StopWatch_SignalEvent();
                }
            }
            break;

        case SWMSG_CREATE:
            dwCnt = GetPerfTime();      // Save initial tick in case we don't have a paint when we exceed the # of SWMSG_TIMER above
            iNumTimersRcvd = 0;
            bHaveFirstPaintMsg = FALSE;
            bActive = (BOOL)SetTimer(hwnd, ID_STOPWATCH_TIMER, g_pswi->dwStopWatchPaintInterval, StopWatch_TimerProc);   // Use timer to determine when painting is done
            break;

        case SWMSG_STATUS:
            break;
    }

    return(bActive);   // Timing status active or not
}

//===========================================================================================
// This function is used to key off of WM_KEYDOWN to start timing when navigating inplace
//===========================================================================================
VOID WINAPI StopWatch_CheckMsg(HWND hwnd, MSG msg, LPCSTR lpStr)
{
    TCHAR szText[80];
    
#ifdef STOPWATCH_DEBUG
    if(g_pswi->dwStopWatchMode & SPMODE_TEST)    // Used to verify message assumptions
    {
        wnsprintf((LPTSTR)szText, ARRAYSIZE(szText), TEXT("Hwnd=0x%08x Msg=0x%x\r\n"), msg.hwnd, msg.message);
        OutputDebugString(szText);
    }
#endif

    if(g_pswi->dwStopWatchMode & SPMODE_SHELL)
    {
        if(!StopWatch_TimerHandler(hwnd, 0, SWMSG_STATUS, &msg) &&
            (((msg.message == WM_KEYDOWN) && (msg.wParam == VK_RETURN)) ||
            ((msg.message == WM_KEYDOWN) && (msg.wParam == VK_BACK)))
            )  // Navigating within the same window
        {
            wnsprintf(szText, ARRAYSIZE(szText), TEXT("Shell Frame Same%s"), lpStr);
            StopWatch_TimerHandler(hwnd, 0, SWMSG_CREATE, &msg);
            StopWatch_Start(SWID_FRAME, szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
    }

    // Compute the time it took to get the message. Then increment approp MsgTime bucket
    if(g_pswi->dwStopWatchMode & SPMODE_MSGTRACE)
    {
        DWORD dwTick = GetTickCount();
        DWORD dwElapsed;
#ifdef STOPWATCH_DEBUG
        TCHAR szMsg[256];
#endif

        g_pswi->dwStopWatchLastLocation = 0;
        
        if(dwTick > msg.time)
        {
            dwElapsed = dwTick - msg.time;

            if(dwElapsed >= g_pswi->dwStopWatchMaxMsgTime)
            {
                ++g_pswi->dwcStopWatchOverflow;
                
#ifdef STOPWATCH_DEBUG
                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                {
                    TCHAR szClassName[40]; 
                    TCHAR szMsgName[20];
                
                    GetClassName(msg.hwnd, szClassName, ARRAYSIZE(szClassName) - 1);
                    if(g_pswi->pfnDecodeMessage != NULL)
                        StrCpyN(szMsgName, g_pswi->pfnDecodeMessage(msg.message), ARRAYSIZE(szMsgName) - 1);
                    else
                        wnsprintf(szMsgName, ARRAYSIZE(szMsgName) - 1, "0x%x", msg.message);
                    wnsprintf(szMsg, ARRAYSIZE(szMsg) - 1, TEXT("MsgTrace (%s) loc=%d, ms=%d >= %d, hwnd=%x, wndproc=%x, msg=%s, w=%x, l=%x\r\n"), 
                        szClassName, g_pswi->dwStopWatchLastLocation, dwElapsed, g_pswi->dwStopWatchMaxMsgTime, msg.hwnd, GetClassLongPtr(msg.hwnd, GCLP_WNDPROC), szMsgName, msg.wParam, msg.lParam);
                    OutputDebugString(szMsg);                                
                }
#endif
            }
            else
            {
                ++(*(g_pswi->pdwStopWatchMsgTime + (dwElapsed / g_pswi->dwStopWatchMsgInterval)));
            }
        }

        if(g_pswi->dwStopWatchTraceMsg == msg.message)
            ++g_pswi->dwStopWatchTraceMsgCnt;
            
        g_pswi->dwStopWatchLastLocation = 0;
    }
}

//===========================================================================================
//===========================================================================================
VOID WINAPI StopWatch_SetMsgLastLocation(DWORD dwLast)
{
    g_pswi->dwStopWatchLastLocation = dwLast;
}

//===========================================================================================
// Logs messages that took longer than g_pswi->dwStopWatchMaxDispatchTime to be dispatched
//===========================================================================================
DWORD WINAPI StopWatch_DispatchTime(BOOL fStartTime, MSG msg, DWORD dwStart)
{
    DWORD dwTime = 0;
    TCHAR szMsg[256];
    
    if(fStartTime)
    {
        if(g_pswi->dwStopWatchTraceMsg == msg.message)
            CapBreak(TRUE);

        StopWatch(SWID_MSGDISPATCH, TEXT("+Dispatch"), START_NODE, SPMODE_MSGTRACE | SPMODE_DEBUGOUT, dwStart);

        dwTime = GetPerfTime();

    }
    else
    {
        dwTime = GetPerfTime();
        
        if(g_pswi->dwStopWatchTraceMsg == msg.message)
            CapBreak(FALSE);
            
        if((dwTime - dwStart) >= g_pswi->dwStopWatchMaxDispatchTime)
        {
            TCHAR szClassName[40];
            TCHAR szMsgName[20];

            GetClassName(msg.hwnd, szClassName, ARRAYSIZE(szClassName) - 1);
            if(g_pswi->pfnDecodeMessage != NULL)
                StrCpyN(szMsgName, g_pswi->pfnDecodeMessage(msg.message), ARRAYSIZE(szMsgName) - 1);
            else
                wnsprintf(szMsgName, ARRAYSIZE(szMsgName) - 1, "0x%x", msg.message);
            wnsprintf(szMsg, ARRAYSIZE(szMsg) - 1, TEXT("-Dispatch (%s) ms=%d > %d, hwnd=%x, wndproc=%x, msg=%s(%x), w=%x, l=%x"), 
                szClassName, dwTime - dwStart, g_pswi->dwStopWatchMaxDispatchTime, msg.hwnd, GetClassLongPtr(msg.hwnd, GCLP_WNDPROC), szMsgName, msg.message, msg.wParam, msg.lParam);
                
            StopWatch(SWID_MSGDISPATCH, szMsg, STOP_NODE, SPMODE_MSGTRACE | SPMODE_DEBUGOUT, dwTime);

#ifdef STOPWATCH_DEBUG
            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
            {
                lstrcat(szMsg, "\n");
                OutputDebugString(szMsg);
            }
#endif
        }
    }
    return(dwTime);
}

//===========================================================================================
// Mark shell/browser frame creation start time
//===========================================================================================
VOID WINAPI StopWatch_MarkFrameStart(LPCSTR lpExplStr)
{
    TCHAR szText[80];
    DWORD dwTime = GetPerfTime();
    if(g_pswi->dwStopWatchMode & SPMODE_SHELL)
    {
        wnsprintf(szText, ARRAYSIZE(szText), TEXT("Shell Frame Start%s"), lpExplStr);
        StopWatch_StartTimed(SWID_FRAME, szText, SPMODE_SHELL | SPMODE_DEBUGOUT, dwTime);
    }
    if(g_pswi->dwStopWatchMode & SPMODE_BROWSER)  // Used to get the start of browser total download time
    {
        StopWatch_LapTimed(SWID_BROWSER_FRAME, TEXT("Thread Start"), SPMODE_BROWSER | SPMODE_DEBUGOUT, dwTime);
    }
    if(g_pswi->dwStopWatchMode & SPMODE_JAVA)  // Used to get the start of java applet load time
    {
        StopWatch_StartTimed(SWID_JAVA_APP, TEXT("Java Applet Start"), SPMODE_JAVA | SPMODE_DEBUGOUT, dwTime);
    }
}

//===========================================================================================
// Mark shell/browser navigate in same frame start time
//===========================================================================================
VOID WINAPI StopWatch_MarkSameFrameStart(HWND hwnd)
{
    DWORD dwTime = GetPerfTime();
    
    if(g_pswi->dwStopWatchMode & SPMODE_SHELL)
    {
        StopWatch_TimerHandler(hwnd, 0, SWMSG_CREATE, NULL);
        StopWatch_StartTimed(SWID_FRAME, TEXT("Shell Frame Same"), SPMODE_SHELL | SPMODE_DEBUGOUT, dwTime);
    }
    if(g_pswi->dwStopWatchMode & SPMODE_BROWSER)  // Used to get browser total download time
    {
        StopWatch_StartTimed(SWID_BROWSER_FRAME, TEXT("Browser Frame Same"), SPMODE_BROWSER | SPMODE_DEBUGOUT, dwTime);
    }
    if(g_pswi->dwStopWatchMode & SPMODE_JAVA)  // Used to get java applet load time
    {
        StopWatch_StartTimed(SWID_JAVA_APP, TEXT("Java Applet Same"), SPMODE_JAVA | SPMODE_DEBUGOUT, dwTime);
    }
}

//===========================================================================================
// When browser or java perf timing mode is enabled, use "Done" or "Applet Started" 
// in the status bar to get load time.
//===========================================================================================
VOID WINAPI StopWatch_MarkJavaStop(LPCSTR  lpStringToSend, HWND hwnd, BOOL fChType)
{
    const TCHAR c_szFmtJavaStop[] = TEXT("Java Applet Stop (%s)");
    TCHAR szTitle[STOPWATCH_MAX_TITLE];
    TCHAR szText[STOPWATCH_MAX_TITLE + ARRAYSIZE(c_szFmtJavaStop) + 1];

    if(g_pswi->dwStopWatchMode & SPMODE_JAVA)
    {
        if((lpStringToSend != NULL) && (lstrncmpW((LPWSTR)lpStringToSend, TEXTW("Applet started"), ARRAYSIZE(TEXTW("Applet started"))) == 0))
        {
            GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)-1);
            wnsprintf(szText, ARRAYSIZE(szText), c_szFmtJavaStop, szTitle);
            StopWatch_Stop(SWID_JAVA_APP, szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
    }
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI GetPerfTime(VOID)
{
    static __int64 freq;
    __int64 curtime;

    if (!freq)
        QueryPerformanceFrequency((LARGE_INTEGER *)&freq);

    QueryPerformanceCounter((LARGE_INTEGER *)&curtime);

    ASSERT((((curtime * 1000) / freq) >> 32) == 0);
    
    return (DWORD)((curtime * 1000) / freq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\stream.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: stream.c
//
//  This file contains some of the stream support code that is used by
// the shell.  It also contains the shells implementation of a memory
// stream that is used by the cabinet to allow views to be serialized.
//
// History:
//  08-20-93 KurtE      Added header block and memory stream.
//
//---------------------------------------------------------------------------

#include "priv.h"
#include <new.h>
#include "nullstm.h"

// This code was stolen from shell32.  This is the BETTER_STRONGER_FASTER
// version (smaller and half the allocs), added after Win95 shipped.
#include "stream.h"

EXTERN_C HKEY SHRegDuplicateHKey(HKEY hkey);

// The Win95/NT4/IE4 code did not enforce the grfMode.  Turn this on to enforce:
//#define ENFORCE_GRFMODE // Note: I haven't tested compat issues with this turned on yet... [mikesh]


STDMETHODIMP CMemStream::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IStream) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj=this;
        this->cRef++;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CMemStream::AddRef()
{
    this->cRef++;
    return this->cRef;
}

BOOL CMemStream::WriteToReg()
{
    if (this->cbData)
    {
        return ERROR_SUCCESS == RegSetValueEx(this->hkey, 
            this->szValue[0] ? this->szValue : NULL, 0, REG_BINARY, 
            this->cbData ? this->pBuf : (LPBYTE)"", this->cbData);
    }
    else
    {
        DWORD dwRet = SHDeleteValue(this->hkey, NULL, this->szValue);

        // If the Stream is being stored in the default key, then
        // we should clean up the key. Otherwise, the caller
        // passed us the key, and they need it. It would be rude for us
        // to delete it. Fixes a Start Menu bug (NT#361333) where we would delete the
        // programs key where start menu stores it's stuff on a load, so we 
        // never persist anything. - lamadio (6.25.99)
        if (this->szValue[0] == TEXT('\0'))
        {
            SHDeleteEmptyKey(this->hkey, NULL);
        }

        return ERROR_SUCCESS == dwRet;
    }
}

STDMETHODIMP_(ULONG) CMemStream::Release()
{
    this->cRef--;
    if (this->cRef > 0)
        return this->cRef;

    // If this is backed up by the registry serialize the data
    if (this->hkey)
    {
        // Backed by the registry.
        // Write and cleanup.
        WriteToReg();
        RegCloseKey(this->hkey);
    }

    // Free the data buffer that is allocated to the stream
    if (this->pBuf)
        LocalFree(this->pBuf);

    LocalFree((HLOCAL)this);

    return 0;
}


STDMETHODIMP CMemStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
#ifdef ENFORCE_GRFMODE
    if ((this->grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_WRITE)
    {
        if (pcbRead != NULL)
            *pcbRead = 0;
        return STG_E_ACCESSDENIED;
    }
#endif

    ASSERT(pv);

    // I guess a null read is ok.
    if (!cb)
    {
        if (pcbRead != NULL)
            *pcbRead = 0;
        return S_OK;
    }

    if (this->iSeek >= this->cbData)
    {
        if (pcbRead != NULL)
            *pcbRead = 0;   // nothing read
    }

    else
    {
        if ((this->iSeek + cb) > this->cbData)
            cb = this->cbData - this->iSeek;

        // Now Copy the memory
        ASSERT(this->pBuf);
        CopyMemory(pv, this->pBuf + this->iSeek, cb);
        this->iSeek += (UINT)cb;

        if (pcbRead != NULL)
            *pcbRead = cb;
    }

    return S_OK;
}

LPBYTE CMemStream::GrowBuffer(ULONG cbNew)
{
    if (this->pBuf == NULL)
    {
        this->pBuf = (LPBYTE)LocalAlloc(LPTR, cbNew);
    }
    else
    {
        LPBYTE pTemp = (LPBYTE)LocalReAlloc(this->pBuf, cbNew, LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (pTemp)
        {
            this->pBuf = pTemp;
        }
        else
        {
            TraceMsg(TF_ERROR, "Stream buffer realloc failed");
            return NULL;
        }
    }
    if (this->pBuf)
        this->cbAlloc = cbNew;

    return this->pBuf;
}

#define SIZEINCR    0x1000


STDMETHODIMP CMemStream::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
#ifdef ENFORCE_GRFMODE
    if ((this->grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_READ)
    {
        if (pcbWritten != NULL)
            *pcbWritten = 0;
        return STG_E_ACCESSDENIED;
    }
#endif

    // I guess a null write is ok.
    if (!cb)
    {
        if (pcbWritten != NULL)
            *pcbWritten = 0;
        return S_OK;
    }

    // See if the data will fit into our current buffer
    if ((this->iSeek + cb) > this->cbAlloc)
    {
        // enlarge the buffer
        // Give it a little slop to avoid a lot of reallocs.
        if (GrowBuffer(this->iSeek + (UINT)cb + SIZEINCR) == NULL)
            return STG_E_INSUFFICIENTMEMORY;
    }

    ASSERT(this->pBuf);

    // See if we need to fill the area between the data size and
    // the seek position
    if (this->iSeek > this->cbData)
    {
        ZeroMemory(this->pBuf + this->cbData, this->iSeek - this->cbData);
    }

    CopyMemory(this->pBuf + this->iSeek, pv, cb);
    this->iSeek += (UINT)cb;
    if (this->iSeek > this->cbData)
        this->cbData = this->iSeek;

    if (pcbWritten != NULL)
        *pcbWritten = cb;

    return S_OK;
}

STDMETHODIMP CMemStream::Seek(LARGE_INTEGER dlibMove,
               DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    LONG lNewSeek;

    // Note: curently not testing for error conditions for number wrap...
    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        lNewSeek = (LONG)dlibMove.LowPart;
        break;
    case STREAM_SEEK_CUR:
        lNewSeek = (LONG)this->iSeek + (LONG)dlibMove.LowPart;
        break;
    case STREAM_SEEK_END:
        lNewSeek = (LONG)this->cbData + (LONG)dlibMove.LowPart;
        break;
    default:
        return STG_E_INVALIDPARAMETER;
    }

    if (lNewSeek < 0)
        return STG_E_INVALIDFUNCTION;

    this->iSeek = (UINT)lNewSeek;

    if (plibNewPosition != NULL)
    {
        plibNewPosition->LowPart = (DWORD)lNewSeek;
        plibNewPosition->HighPart = 0;
    }
    return S_OK;
}

STDMETHODIMP CMemStream::SetSize(ULARGE_INTEGER libNewSize)
{
#ifdef ENFORCE_GRFMODE
    if ((this->grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_READ)
    {
        return STG_E_ACCESSDENIED;
    }
#endif

    UINT cbNew = (UINT)libNewSize.LowPart;

    // See if the data will fit into our current buffer
    if (cbNew > this->cbData)
    {
        // See if we have to Enlarge the buffer.
        if (cbNew > this->cbAlloc)
        {
            // enlarge the buffer - Does not check wrap...
            // Give it a little slop to avoid a lot of reallocs.
            if (GrowBuffer(cbNew) == NULL)
                return STG_E_INSUFFICIENTMEMORY;
        }

        // Now fill some memory
        ZeroMemory(this->pBuf + this->cbData, cbNew - this->cbData);
    }

    // Save away the new size.
    this->cbData = cbNew;
    return S_OK;
}

STDMETHODIMP CMemStream::CopyTo(IStream *pstmTo,
             ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
#ifdef ENFORCE_GRFMODE
    if ((this->grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_WRITE)
    {
        if (pcbRead != NULL)
            ZeroMemory(pcbRead, sizeof(pcbRead));
        if (pcbWritten != NULL)
            ZeroMemory(pcbWritten, sizeof(pcbWritten));
        return STG_E_ACCESSDENIED;
    }
#endif

    HRESULT hres = S_OK;
    UINT cbRead = this->cbData - this->iSeek;
    ULONG cbWritten = 0;

    if (cb.HighPart == 0 && cb.LowPart < cbRead)
    {
        cbRead = cb.LowPart;
    }

    if (cbRead > 0)
    {
        hres = pstmTo->Write(this->pBuf + this->iSeek, cbRead, &cbWritten);
        this->iSeek += cbRead;
    }

    if (pcbRead)
    {
        pcbRead->LowPart = cbRead;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten)
    {
        pcbWritten->LowPart = cbWritten;
        pcbWritten->HighPart = 0;
    }

    return hres;
}

STDMETHODIMP CMemStream::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::LockRegion(ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb, DWORD dwLockType)

{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::UnlockRegion(ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

// Trident calls this to determine the size of the structure.
// No reason to not support this one.
STDMETHODIMP CMemStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    ZeroMemory(pstatstg, sizeof(*pstatstg));

    // we have no name
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = this->cbData;
    // blow off modify, create, access times (we don't track anyway)
    pstatstg->grfMode = this->grfMode;
    // we're not transacting, so we have no lock modes
    // we're the null clsid already
    // we're not based on storage, so we have no state or storage bits
    
    return S_OK;
}

STDMETHODIMP CMemStream::Clone(IStream **ppstm)
{
    *ppstm = NULL;
    return E_NOTIMPL;
}

CMemStream *
CreateMemStreamEx(
    LPBYTE  pInit, 
    UINT    cbInit, 
    LPCTSTR pszValue)       OPTIONAL
{
    UINT l_cbAlloc = sizeof(CMemStream) + (pszValue ? lstrlen(pszValue) * sizeof(TCHAR) : 0);
    CMemStream *localthis = (CMemStream *)LocalAlloc(LPTR, l_cbAlloc);
    if (localthis) 
    {
        new (localthis) CMemStream;

        localthis->cRef = 1;

        // See if there is some initial data we should map in here.
        if ((pInit != NULL) && (cbInit > 0))
        {
            if (localthis->GrowBuffer(cbInit) == NULL)
            {
                // Could not allocate buffer!
                LocalFree((HLOCAL)localthis);
                return NULL;
            }

            localthis->cbData = cbInit;
            CopyMemory(localthis->pBuf, pInit, cbInit);
        }

        if (pszValue)
            lstrcpy(localthis->szValue, pszValue);

        // We have no other value to set this to
        localthis->grfMode = STGM_READWRITE;

        return localthis;
    }
    return NULL;
}


STDAPI_(IStream *)
SHCreateMemStream(
    LPBYTE  pInit, 
    UINT    cbInit)
{
    CMemStream *localthis = CreateMemStreamEx(pInit, cbInit, NULL);
    if (localthis) 
        return localthis;
    return NULL;
}


//----------------------------------------------------------------------------
// Open a stream to the reg file given an open key.
// NB pszValue can be NULL.
//
// Win9x exported OpenRegStream which *always* returned a stream, even for read,
// even when there was no data there.  IE4 shell32 delegated to shlwapi's SHOpenRegStream
// which needs to support this sub-optimal behavior.  See NT5 bug 190878 (shell32 fault).
//
STDAPI_(IStream *)
SHOpenRegStreamW(
    HKEY    hkey, 
    LPCWSTR  pszSubkey, 
    LPCWSTR  pszValue,       OPTIONAL
    DWORD   grfMode)
{
    IStream * pstm = SHOpenRegStream2W(hkey, pszSubkey, pszValue, grfMode);
#ifndef UNIX
    if (!pstm)
        pstm = SHConstNullStream();
#endif
    return pstm;
}

STDAPI_(IStream *)
SHOpenRegStreamA(
    HKEY    hkey, 
    LPCSTR  pszSubkey, 
    LPCSTR  pszValue,       OPTIONAL
    DWORD   grfMode)
{
    IStream * pstm = SHOpenRegStream2A(hkey, pszSubkey, pszValue, grfMode);
#ifndef UNIX
    if (!pstm)
        pstm = SHConstNullStream();
#endif
    return pstm;
}

// We should add STGM_CREATE support to the shlwapi streams.  When saving out 
// streams, we currently create the stream with STGM_WRITE (but not STGM_CREATE) 
// so shlwapi goes to all the wasted trouble of reading the old stream data into 
// memory, only to throw it away when we write over it.
// 
// STGM_CREATE means "I don't care about the old values because I'm going to 
// overwrite them anyway."  (It really should be named STGM_TRUNCATEONOPEN.)
// 
STDAPI_(IStream *)
SHOpenRegStream2(
    HKEY    hkey, 
    LPCTSTR pszSubkey, 
    LPCTSTR pszValue,       OPTIONAL
    DWORD   grfMode)
{
    CMemStream *localthis;    // In bed with class...

    RIPMSG(IS_VALID_HANDLE(hkey, KEY), "SHOpenRegStream2: Caller passed invalid hkey");
    RIPMSG(!pszSubkey || IS_VALID_STRING_PTR(pszSubkey, -1), "SHOpenRegStream2: Caller passed invalid pszSubkey");
    RIPMSG(!pszValue || IS_VALID_STRING_PTR(pszValue, -1), "SHOpenRegStream2: Caller passed invalid pszValue");

    // Null keys are illegal.
    if (!hkey)
    {
        return NULL;
    }

    localthis = CreateMemStreamEx(NULL, 0, pszValue);
    if (!localthis)
        return NULL;       // Failed to allocate space

    localthis->grfMode = grfMode;

    // Get the hkey we're going to deal with
    //
    // Did the caller pass us a subkey, and does it contain a string?
    if (pszSubkey && *pszSubkey)
    {
        // Yes; The try to bind to that key.

        // If this stream is one the user mentioned as wanting to write to
        // we need to save away the regkey and value.
        if ((grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE)) != STGM_READ)
        {
            // Store away the key.
            if (RegCreateKey(hkey, pszSubkey, &localthis->hkey) != ERROR_SUCCESS)
            {
                TraceMsg(TF_ERROR, "SHOpenRegStream: Unable to create key.");
                localthis->hkey = NULL; // be paranoid
            }
        }
        else if (RegOpenKey(hkey, pszSubkey, &localthis->hkey) != ERROR_SUCCESS)
        {
            localthis->hkey = NULL; // be paranoid
        }
    }
    else
    {
        localthis->hkey = SHRegDuplicateHKey(hkey);
    }

    // we don't have an hkey, bail
    if (NULL == localthis->hkey)
    {
        localthis->Release();
        return NULL;
    }


    // Now see if we need to initialize the stream.
    if ((grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE)) != STGM_WRITE)
    {
        DWORD dwType;
        DWORD cbData;

        if ((RegQueryValueEx(localthis->hkey, pszValue, NULL, &dwType, NULL, &cbData) == ERROR_SUCCESS) && cbData)
        {
            if (localthis->GrowBuffer(cbData) != NULL)
            {
                ASSERT(localthis->cbAlloc >= cbData);

                // Get the data.
                RegQueryValueEx(localthis->hkey, pszValue, NULL, &dwType, localthis->pBuf, &cbData);

                ASSERT(localthis->cbAlloc >= cbData);

                localthis->cbData = cbData;
            }
            else
            {
                TraceMsg(TF_ERROR, "OpenRegStream: Unable to initialize stream to registry.");
                localthis->Release();
                return NULL;
            }
        }
    }

    if (IsOS(OS_WHISTLERORGREATER))
    {
        // If the stream was opened read-only, then close the key so
        // CMemStream::Release won't try to write the "updates" back out to the
        // registry.
        if ((grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE)) == STGM_READ)
        {
            RegCloseKey(localthis->hkey);
            localthis->hkey = NULL;
        }
    }

    return localthis;
}

#ifdef UNICODE
STDAPI_(IStream *)
SHOpenRegStream2A(
    HKEY    hkey, 
    LPCSTR  pszSubkey, 
    LPCSTR  pszValue,       OPTIONAL
    DWORD   grfMode)
{
    IStream * pstm = NULL;

    RIPMSG(IS_VALID_HANDLE(hkey, KEY), "SHOpenRegStream2A: Caller passed invalid hkey");
    RIPMSG(!pszSubkey || IS_VALID_STRING_PTRA(pszSubkey, -1), "SHOpenRegStream2A: Caller passed invalid pszSubkey");
    RIPMSG(!pszValue || IS_VALID_STRING_PTRA(pszValue, -1), "SHOpenRegStream2A: Caller passed invalid pszValue");

    WCHAR wszSubkey[MAX_PATH];
    if (pszSubkey)
    {
        if (!MultiByteToWideChar(CP_ACP, 0, pszSubkey, -1, wszSubkey, SIZECHARS(wszSubkey)))
            return NULL;
        pszSubkey = (LPCSTR)wszSubkey;
    }

    WCHAR wszValue[MAX_PATH];
    if (pszValue)
    {
        if (!MultiByteToWideChar(CP_ACP, 0, pszValue, -1, wszValue, SIZECHARS(wszValue)))
            return NULL;
        pszValue = (LPCSTR)wszValue;
    }

    pstm = SHOpenRegStream2W(hkey, (LPCWSTR)pszSubkey, (LPCWSTR)pszValue, grfMode);

    return pstm;
}
#else
STDAPI_(IStream *)
SHOpenRegStream2W(
    HKEY    hkey, 
    LPCWSTR pszSubkey, 
    LPCWSTR pszValue,       OPTIONAL
    DWORD   grfMode)
{
    IStream * pstm = NULL;

    RIPMSG(IS_VALID_HANDLE(hkey, KEY), "SHOpenRegStream2W: Caller passed invalid hkey");
    RIPMSG(!pszSubkey || IS_VALID_STRING_PTRW(pszSubkey, -1), "SHOpenRegStream2W: Caller passed invalid pszSubkey");
    RIPMSG(!pszValue || IS_VALID_STRING_PTRW(pszValue, -1), "SHOpenRegStream2W: Caller passed invalid pszValue");

    CHAR szSubkey[MAX_PATH];
    if (pszSubkey)
    {
        if (!WideCharToMultiByte(CP_ACP, 0, pszSubkey, -1, szSubkey, SIZECHARS(szSubkey), NULL, NULL))
            return NULL;
        pszSubkey = (LPCWSTR)szSubkey;
    }

    CHAR szValue[MAX_PATH];
    if (pszValue)
    {
        if (!WideCharToMultiByte(CP_ACP, 0, pszValue, -1, szValue, SIZECHARS(szValue), NULL, NULL))
            return NULL;
        pszValue = (LPCWSTR)szValue;
    }

    pstm = SHOpenRegStream2A(hkey, (LPCSTR)pszSubkey, (LPCSTR)pszValue, grfMode);

    return pstm;
}
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\stream.h ===
#ifndef _STREAM_H_
#define _STREAM_H_

class CMemStream : public IStream {
public:
        STDMETHOD (QueryInterface)(REFIID riid, void **ppvObj);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        STDMETHOD (Read)(void *pv, ULONG cb, ULONG *pcbRead);
        STDMETHOD (Write)(void const *pv, ULONG cb, ULONG *pcbWritten);
        STDMETHOD (Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
        STDMETHOD (SetSize)(ULARGE_INTEGER libNewSize);
        STDMETHOD (CopyTo)(IStream *, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *);
        STDMETHOD (Commit)(DWORD);
        STDMETHOD (Revert)();
        STDMETHOD (LockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD);
        STDMETHOD (UnlockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD);
        STDMETHOD (Stat)(STATSTG *, DWORD);
        STDMETHOD (Clone)(IStream **);

        LPBYTE  GrowBuffer(ULONG);
private:
        BOOL    WriteToReg();

public:
    UINT        cRef;           // Reference count
    LPBYTE      pBuf;           // Buffer pointer
    UINT        cbAlloc;        // The allocated size of the buffer
    UINT        cbData;         // The used size of the buffer
    UINT        iSeek;          // Where we are in the buffer.
    DWORD       grfMode;        // mode used at creation (for Stat, and to enforce)
    // Extra variables that are used for loading and saving to ini files.
    HKEY        hkey;           // Key for writing to registry.
    BITBOOL     fDontCloseKey;  // if caller passes in a key
    TCHAR       szValue[1];     // for reg stream
};

#endif /* _STREAM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\strmwrap.cpp ===
#include "priv.h"


// Stub - CStreamWrap moved to shdocvw

STDAPI SHCreateStreamWrapper(IStream *aStreams[], UINT cStreams, DWORD grfMode, IStream **ppstm)
{
    *ppstm = NULL;

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\strings.h ===
BOOL AnsiFromUnicode(LPSTR * ppszAnsi, LPCWSTR pwszWide, LPSTR pszBuf, int cchBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\strtype.c ===
//+------------------------------------------------------------------------
//
//  File:       strtype.c
//
//  Contents:   widechar character type function (CT_CTYPE1) and (CT_CTYPE3)
//
//  Synopsis:   We do not have wide char support for IsChar functions
//              under Win95.  The Unicode-Wrapper functions we have
//              in core\wrappers all convert to CP_ACP and then call
//              the A version, which means we will have invalid results
//              for any characters which aren't in CP_ACP.
//
//              The solution is to roll our own, which result in these
//              unfortunately large tables.  Here's how it works:
//
//              bits:   fedc ba98 7654 3210
//                      pppp pppp iiib bbbb
//
//              The 'b' bits form a 32-bit bit mask into our data.  The data
//              entrys boolean, and are thus 4-bytes long.  Of the 2^32
//              possible combinations, we in fact have only 218 distinct
//              values of data.  These are stored in adwData.
//
//              The 'p' bits represent a page.  Each page has eight
//              possible entries, represent by 'i'.  In most pages, the
//              bitfields and data are both uniform.
//
//              adwData[abIndex[abType[page]][index]] represents the data
//
//              1 << bits represents the bitmask.
//
//-------------------------------------------------------------------------
#include "priv.h"

#define __BIT_SHIFT 0
#define __INDEX_SHIFT 5
#define __PAGE_SHIFT 8

#define __BIT_MASK 31
#define __INDEX_MASK 7

// straight lookup functions are inlined.

#define ISCHARFUNC(type, wch) \
    (adwData[abIndex[abType1##type[wch>>__PAGE_SHIFT]] \
                          [(wch>>__INDEX_SHIFT)&__INDEX_MASK]] \
            >> (wch&__BIT_MASK)) & 1 
    
const DWORD adwData[218] =
{
#if 0
    0x00000000, 0x7fffffe0, 0xfffffeff, 0xffffffff,  // 0x00-0x03
    0xfffffd3f, 0xffffff00, 0x0000ffff, 0xff800000,  // 0x04-0x07
    0x02ebffff, 0xdfffffff, 0xfffefe2a, 0xbffff000,  // 0x08-0x0b
    0x7ffbffff, 0xffff7ffb, 0xd000ffff, 0xf998ffff,  // 0x0c-0x0f
    0xfff3fdd0, 0x00007fff, 0xfffffe00, 0x7fffffff,  // 0x10-0x13
    0xff000000, 0xffe0e000, 0x7fe00000, 0xffffff3e,  // 0x14-0x17
    0xfffef400, 0x07ffffff, 0xffffffd0, 0x000000ff,  // 0x18-0x1b
    0xd0000000, 0x07f99fff, 0xffbfa3d0, 0x0000000d,  // 0x1c-0x1f
    0xd000d000, 0x07e19fff, 0xffbfb6d0, 0x0000007a,  // 0x20-0x23
    0x07f5dfff, 0xffbfb7d0, 0x80000000, 0xffbfb3d0,  // 0x24-0x27
    0x07e3bd6b, 0x18e3fdd0, 0x07fbbfff, 0xffbff7d0,  // 0x28-0x2b
    0x00000002, 0xffbfffd0, 0xfffeb000, 0xfd000000,  // 0x2c-0x2f
    0x69a40f7f, 0x75360000, 0x0000000d, 0xfd00ffff,  // 0x30-0x33
    0xffffffd1, 0xe0ffffff, 0xffffffe0, 0xfffffdfd,  // 0x34-0x37
    0xfdfdff55, 0xfffffffd, 0xfffffbf8, 0x3bf8f3f0,  // 0x38-0x3b
    0xfff83bf8, 0x0000000f, 0xffd00000, 0x04000000,  // 0x3c-0x3f
    0xfffff81e, 0xffffffee, 0xfff87fff, 0xfffe0000,  // 0x40-0x43
    0xf0000000, 0xfffd0000, 0xfe001f01, 0xfffffefa,  // 0x44-0x47
    0xdbffffff, 0xffffd000, 0x00001fff, 0xffbfffff,  // 0x48-0x4b
    0xbfffffff, 0xffff3fff, 0x0000fff0, 0xfffffff8,  // 0x4c-0x4f
    0x03ffffff, 0x7ffffffe, 0x3f3f3f38, 0x007d0000,  // 0x50-0x53
    0xfff00000, 0x00000001, 0x7fff003f, 0x8000001f,  // 0x54-0x57
    0x8000001e, 0x00000100, 0x00002000, 0xfffffffe,  // 0x58-0x5b
    0xd0000d22, 0x0d000000, 0x3e000000, 0x0000007f,  // 0x5c-0x5f
    0x00400000, 0x00001800, 0x00080011, 0x801fe000,  // 0x60-0x63
    0x003d8000, 0x00000bff, 0x70000000, 0xfffdf800,  // 0x64-0x67
    0x3d008000, 0x0000000b, 0xf99d0100, 0x30003fe0,  // 0x68-0x6b
    0x20000000, 0xe19d0000, 0x0000f800, 0xfddd8000,  // 0x6c-0x6f
    0xf19d0300, 0x00008000, 0x30000000, 0x00000003,  // 0x70-0x73
    0xe3bd0100, 0xfbbd0600, 0xf3bd0100, 0x00014fe1,  // 0x74-0x77
    0x03ff0030, 0x0001ffdd, 0xfafd0000, 0x00000010,  // 0x78-0x7b
    0x00000007, 0xd0070007, 0x00070006, 0xfffeffff,  // 0x7c-0x7f
    0xfe000000, 0x003f003f, 0x003e0000, 0xffffff80,  // 0x80-0x83
    0xe000ffff, 0xffe00000, 0xf8000000, 0xfffffd00,  // 0x84-0x87
    0xfffbffff, 0xffff0000, 0xfffff03f, 0x7bdfffff,  // 0x88-0x8b
    0xff7fffff, 0xfff5e2fe, 0x7f0003ff, 0xfffff8ff,  // 0x8c-0x8f
    0xffff7ffe, 0xffffff01, 0x0000007e, 0x0000001e,  // 0x90-0x93
    0xfffffff1, 0xffff8000, 0xfff0ffff, 0xfffffe1f,  // 0x94-0x97
    0xf000ffff, 0xf87fefff, 0xfef0ebff, 0x7d008000,  // 0x98-0x9b
    0xfefe0000, 0x0000ffd0, 0x00003040, 0x03ff0000,  // 0x9c-0x9f
    0x01ffe000, 0x00008fd0, 0x7e000000, 0xfffffefe,  // 0xa0-0xa3
    0xaaaaaaaa, 0xaaaaaa55, 0x552aaaaa, 0xaaaaaad4,  // 0xa4-0xa7
    0x6b73db8d, 0xa94b7588, 0x0db55552, 0xaaaa682a,  // 0xa8-0xab
    0xaaaaaa00, 0x02eb7fff, 0xdff00000, 0x0000382a,  // 0xac-0xaf
    0xaaaa0000, 0x8000aaaa, 0x5110aaaa, 0xaaa2a880,  // 0xb0-0xb3
    0xaaaaa800, 0xaaaaaa80, 0x00ff00fd, 0x00ff00ff,  // 0xb4-0xb7
    0x00fd0055, 0x00ff0000, 0x00ff00f8, 0x00f800f0,  // 0xb8-0xbb
    0x00f800f8, 0x000003ff, 0x55555555, 0x555555aa,  // 0xbc-0xbf
    0xaad55555, 0x5555552b, 0x948d2472, 0x54948a64,  // 0xc0-0xc3
    0x06daaaad, 0x5555b415, 0x55555500, 0xdfdff5ff,  // 0xc4-0xc7
    0x3ffef026, 0x9f800000, 0x000fffff, 0xfffed600,  // 0xc8-0xcb
    0x1555f000, 0x40005555, 0x28885555, 0x55515440,  // 0xcc-0xcf
    0x555557e0, 0x55555540, 0xff00fd00, 0xff00ff00,  // 0xd0-0xd3
    0xfd00ff00, 0xff00fffd, 0xff00fb00, 0x3b00f300,  // 0xd4-0xd7
    0xff003b00, 0xfe001f00
#else
    0x00000000, 0x07fffffe, 0xff7fffff, 0xffffffff,  // 0x00-0x03
    0xfc3fffff, 0x00ffffff, 0xffff0000, 0x000001ff,  // 0x04-0x07
    0xffffd740, 0xfffffffb, 0x547f7fff, 0x000ffffd,  // 0x08-0x0b
    0xffffdffe, 0xdffeffff, 0xffff0003, 0xffff199f,  // 0x0c-0x0f
    0x033fcfff, 0xfffe0000, 0x007fffff, 0xfffffffe,  // 0x10-0x13
    0x000000ff, 0x000707ff, 0x000007fe, 0x7cffffff,  // 0x14-0x17
    0x002f7fff, 0xffffffe0, 0x03ffffff, 0xff000000,  // 0x18-0x1b
    0x00000003, 0xfff99fe0, 0x03c5fdff, 0xb0000000,  // 0x1c-0x1f
    0x00030003, 0xfff987e0, 0x036dfdff, 0x5e000000,  // 0x20-0x23
    0xfffbafe0, 0x03edfdff, 0x00000001, 0x03cdfdff,  // 0x24-0x27
    0xd63dc7e0, 0x03bfc718, 0xfffddfe0, 0x03effdff,  // 0x28-0x2b
    0x40000000, 0x03fffdff, 0x000d7fff, 0x0000003f,  // 0x2c-0x2f
    0xfef02596, 0x00006cae, 0x30000000, 0xffff003f,  // 0x30-0x33
    0x83ffffff, 0xffffff07, 0x07ffffff, 0x3f3fffff,  // 0x34-0x37
    0xaaff3f3f, 0x3fffffff, 0x1fdfffff, 0x0fcf1fdc,  // 0x38-0x3b
    0x1fdc1fff, 0xf0000000, 0x000003ff, 0x00000020,  // 0x3c-0x3f
    0x781fffff, 0x77ffffff, 0xfffe1fff, 0x00007fff,  // 0x40-0x43
    0x0000000f, 0x00003fff, 0x80f8007f, 0x5f7fffff,  // 0x44-0x47
    0xffffffdb, 0x0003ffff, 0xfff80000, 0xfffffdff,  // 0x48-0x4b
    0xfffffffd, 0xfffcffff, 0x0fff0000, 0x1fffffff,  // 0x4c-0x4f
    0xffffffc0, 0x7ffffffe, 0x1cfcfcfc, 0x00003e00,  // 0x50-0x53
    0x00000fff, 0x80000000, 0xfc00fffe, 0xf8000001,  // 0x54-0x57
    0x78000001, 0x00800000, 0x00040000, 0x7fffffff,  // 0x58-0x5b
    0x44300003, 0x000000b0, 0x0000007c, 0xfe000000,  // 0x5c-0x5f
    0x00000200, 0x00180000, 0x88001000, 0x0007f801,  // 0x60-0x63
    0x00013c00, 0xffd00000, 0x0000000e, 0x001f3fff,  // 0x64-0x67
    0x0001003c, 0xd0000000, 0x0080399f, 0x07fc000c,  // 0x68-0x6b
    0x00000004, 0x00003987, 0x001f0000, 0x00013bbf,  // 0x6c-0x6f
    0x00c0398f, 0x00010000, 0x0000000c, 0xc0000000,  // 0x70-0x73
    0x00803dc7, 0x00603ddf, 0x00803dcf, 0x87f28000,  // 0x74-0x77
    0x0c00ffc0, 0x3bff8000, 0x00003f5f, 0x08000000,  // 0x78-0x7b
    0xe0000000, 0xe000e003, 0x6000e000, 0xffff7fff,  // 0x7c-0x7f
    0x0000007f, 0xfc00fc00, 0x00007c00, 0x01ffffff,  // 0x80-0x83
    0xffff0007, 0x000007ff, 0x0000001f, 0x003fffff,  // 0x84-0x87
    0xffffdfff, 0x0000ffff, 0xfc0fffff, 0xfffff3de,  // 0x88-0x8b
    0xfffffeff, 0x7f47afff, 0xffc000fe, 0xff1fffff,  // 0x8c-0x8f
    0x7ffeffff, 0x80ffffff, 0x7e000000, 0x78000000,  // 0x90-0x93
    0x8fffffff, 0x0001ffff, 0xffff0fff, 0xf87fffff,  // 0x94-0x97
    0xffff000f, 0xfff7fe1f, 0xffd70f7f, 0x0001003e,  // 0x98-0x9b
    0x00007f7f, 0x03ff0000, 0x020c0000, 0x0000ffc0,  // 0x9c-0x9f
    0x0007ff80, 0x03f10000, 0x0000007e, 0x7f7fffff,  // 0xa0-0xa3
    0x55555555, 0xaa555555, 0x555554aa, 0x2b555555,  // 0xa4-0xa7
    0xb1dbced6, 0x11aed295, 0x4aaaadb0, 0x54165555,  // 0xa8-0xab
    0x00555555, 0xfffed740, 0x00000ffb, 0x541c0000,  // 0xac-0xaf
    0x00005555, 0x55550001, 0x5555088a, 0x01154555,  // 0xb0-0xb3
    0x00155555, 0x01555555, 0x3f00ff00, 0xff00ff00,  // 0xb4-0xb7
    0xaa003f00, 0x0000ff00, 0x1f00ff00, 0x0f001f00,  // 0xb8-0xbb
    0x1f001f00, 0xffc00000, 0xaaaaaaaa, 0x55aaaaaa,  // 0xbc-0xbf
    0xaaaaab55, 0xd4aaaaaa, 0x4e243129, 0x2651292a,  // 0xc0-0xc3
    0xb5555b60, 0xa82daaaa, 0x00aaaaaa, 0xffaffbfb,  // 0xc4-0xc7
    0x640f7ffc, 0x000001f9, 0xfffff000, 0x00637fff,  // 0xc8-0xcb
    0x000faaa8, 0xaaaa0002, 0xaaaa1114, 0x022a8aaa,  // 0xcc-0xcf
    0x07eaaaaa, 0x02aaaaaa, 0x003f00ff, 0x00ff00ff,  // 0xd0-0xd3
    0x00ff003f, 0x3fff00ff, 0x00df00ff, 0x00cf00dc,  // 0xd4-0xd7
    0x00dc00ff, 0x00f8007f
#endif
};

const BYTE abIndex[98][8] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x00
    { 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02 }, // 0x01
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04 }, // 0x02
    { 0x05, 0x00, 0x06, 0x03, 0x03, 0x07, 0x00, 0x00 }, // 0x03
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x0a, 0x0b }, // 0x04
    { 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x10 }, // 0x05
    { 0x00, 0x11, 0x12, 0x13, 0x14, 0x00, 0x06, 0x15 }, // 0x06
    { 0x00, 0x01, 0x16, 0x11, 0x03, 0x17, 0x18, 0x00 }, // 0x07
    { 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20 }, // 0x08
    { 0x21, 0x22, 0x23, 0x00, 0x24, 0x25, 0x00, 0x26 }, // 0x09
    { 0x1d, 0x27, 0x1f, 0x1c, 0x28, 0x29, 0x00, 0x00 }, // 0x0a
    { 0x2a, 0x2b, 0x00, 0x1c, 0x2a, 0x2b, 0x2c, 0x1c }, // 0x0b
    { 0x2a, 0x2d, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00 }, // 0x0c
    { 0x13, 0x2e, 0x2f, 0x00, 0x30, 0x31, 0x32, 0x00 }, // 0x0d
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x12 }, // 0x0e
    { 0x03, 0x03, 0x34, 0x03, 0x03, 0x35, 0x03, 0x1a }, // 0x0f
    { 0x03, 0x03, 0x03, 0x03, 0x36, 0x03, 0x03, 0x1a }, // 0x10
    { 0x37, 0x03, 0x38, 0x39, 0x03, 0x3a, 0x3b, 0x3c }, // 0x11
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x03, 0x03, 0x3e }, // 0x12
    { 0x3f, 0x00, 0x13, 0x03, 0x40, 0x13, 0x03, 0x41 }, // 0x13
    { 0x19, 0x42, 0x03, 0x03, 0x43, 0x00, 0x00, 0x00 }, // 0x14
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 }, // 0x15
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x2f, 0x00, 0x00 }, // 0x16
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x44, 0x00, 0x00 }, // 0x17
    { 0x03, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x18
    { 0x46, 0x47, 0x48, 0x03, 0x03, 0x49, 0x4a, 0x4b }, // 0x19
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x4c }, // 0x1a
    { 0x03, 0x39, 0x06, 0x03, 0x4d, 0x03, 0x14, 0x4e }, // 0x1b
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x4f }, // 0x1c
    { 0x00, 0x01, 0x01, 0x50, 0x03, 0x51, 0x52, 0x00 }, // 0x1d
    { 0x53, 0x26, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00 }, // 0x1e
    { 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x1f
    { 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55 }, // 0x21
    { 0x00, 0x56, 0x57, 0x58, 0x00, 0x13, 0x59, 0x59 }, // 0x22
    { 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00 }, // 0x23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5b, 0x3e }, // 0x24
    { 0x03, 0x03, 0x2f, 0x5c, 0x5d, 0x00, 0x00, 0x00 }, // 0x25
    { 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00 }, // 0x26
    { 0x00, 0x00, 0x5f, 0x00, 0x60, 0x06, 0x44, 0x61 }, // 0x27
    { 0x62, 0x00, 0x63, 0x64, 0x00, 0x00, 0x65, 0x45 }, // 0x28
    { 0x66, 0x3d, 0x67, 0x68, 0x66, 0x69, 0x6a, 0x6b }, // 0x29
    { 0x6c, 0x69, 0x6d, 0x6e, 0x66, 0x3d, 0x6f, 0x00 }, // 0x2a
    { 0x66, 0x3d, 0x70, 0x71, 0x72, 0x73, 0x74, 0x00 }, // 0x2b
    { 0x66, 0x73, 0x75, 0x00, 0x72, 0x73, 0x75, 0x00 }, // 0x2c
    { 0x72, 0x73, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x2d
    { 0x00, 0x77, 0x78, 0x00, 0x00, 0x79, 0x7a, 0x00 }, // 0x2e
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b }, // 0x2f
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7d, 0x7e }, // 0x30
    { 0x03, 0x7f, 0x80, 0x81, 0x82, 0x54, 0x06, 0x1c }, // 0x31
    { 0x03, 0x83, 0x4a, 0x03, 0x84, 0x03, 0x03, 0x85 }, // 0x32
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x49 }, // 0x33
    { 0x4c, 0x03, 0x03, 0x36, 0x00, 0x00, 0x00, 0x00 }, // 0x34
    { 0x03, 0x86, 0x85, 0x03, 0x03, 0x03, 0x03, 0x85 }, // 0x35
    { 0x03, 0x03, 0x03, 0x03, 0x87, 0x88, 0x03, 0x89 }, // 0x36
    { 0x8a, 0x03, 0x03, 0x89, 0x00, 0x00, 0x00, 0x00 }, // 0x37
    { 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x00, 0x00 }, // 0x38
    { 0x13, 0x91, 0x00, 0x00, 0x92, 0x00, 0x00, 0x93 }, // 0x39
    { 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00 }, // 0x3a
    { 0x4f, 0x03, 0x44, 0x94, 0x03, 0x95, 0x96, 0x5b }, // 0x3b
    { 0x03, 0x03, 0x03, 0x97, 0x03, 0x03, 0x39, 0x5b }, // 0x3c
    { 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3d
    { 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3e
    { 0x00, 0x98, 0x99, 0x9a, 0x03, 0x03, 0x03, 0x4f }, // 0x3f
    { 0x56, 0x57, 0x58, 0x9b, 0x73, 0x26, 0x00, 0x9c }, // 0x40
    { 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00 }, // 0x41
    { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x9d }, // 0x42
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9f }, // 0x43
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0xa0 }, // 0x44
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00 }, // 0x45
    { 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9d, 0x00 }, // 0x46
    { 0x00, 0x00, 0x00, 0xa1, 0x3e, 0x00, 0x00, 0x00 }, // 0x47
    { 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x48
    { 0x00, 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00 }, // 0x49
    { 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4a
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa3, 0x00 }, // 0x4b
    { 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab }, // 0x4c
    { 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4d
    { 0x00, 0x00, 0x00, 0x00, 0xad, 0xae, 0xaf, 0xb0 }, // 0x4e
    { 0x0c, 0x89, 0x00, 0xa4, 0xb1, 0xa4, 0xb2, 0xb3 }, // 0x4f
    { 0x00, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x50
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x00 }, // 0x51
    { 0xa4, 0xa4, 0xa4, 0xa4, 0xb4, 0xa4, 0xa4, 0xb5 }, // 0x52
    { 0xb6, 0xb7, 0xb8, 0xb9, 0xb7, 0xba, 0xbb, 0xbc }, // 0x53
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x89, 0x00 }, // 0x54
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x55
    { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x55, 0x02 }, // 0x56
    { 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5 }, // 0x57
    { 0xc6, 0x00, 0x06, 0xc7, 0xc8, 0xc9, 0x00, 0x00 }, // 0x58
    { 0x00, 0x00, 0x00, 0x00, 0x71, 0xca, 0xcb, 0xcc }, // 0x59
    { 0x00, 0x06, 0x0d, 0xbe, 0xcd, 0xbe, 0xce, 0xcf }, // 0x5a
    { 0x00, 0x00, 0x00, 0x13, 0x14, 0x00, 0x00, 0x00 }, // 0x5b
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12 }, // 0x5c
    { 0xbe, 0xbe, 0xbe, 0xbe, 0xd0, 0xbe, 0xbe, 0xd1 }, // 0x5d
    { 0xd2, 0xd3, 0xd4, 0xd5, 0xd3, 0xd6, 0xd7, 0xd8 }, // 0x5e
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x87, 0x06, 0x3e }, // 0x5f
    { 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }  // 0x61
};

const BYTE abType1Alpha[256] = // 154
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00,
    0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x00,
    0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d
};

BOOL IsCharSpaceW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x1e; break;
        case 0x20: nType = 0x1f; break;
        case 0x30: nType = 0x20; break;
        case 0xfe: nType = 0x21; break;
        default:   nType = 0x00; break;
    }

#if 0   
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
   
    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >>(wch&__BIT_MASK)) & 1;
}

const BYTE abType1Punct[256] = // 32
{
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x00,
    0x00, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x39, 0x3a, 0x3b, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3d, 0x00, 0x3e, 0x3f, 0x40
};

const BYTE abType1Digit[256] = // 11
{
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00,
    0x00, 0x43, 0x43, 0x44, 0x43, 0x45, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48
};

BOOL IsCharDigitW(WCHAR wch) { return ISCHARFUNC(Digit, wch); }

BOOL IsCharXDigitW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x49; break;
        case 0xff: nType = 0x4a; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >> (wch&__BIT_MASK)) & 1;
#if 0
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
}

const BYTE abType1Upper[256] = // 12
{
    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};

const BYTE abType1Lower[256] = // 13
{
    0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x5e,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x61
};


BOOL IsCharPunctW(WCHAR wch) { return ISCHARFUNC(Punct, wch); }


BOOL IsCharCntrlW(WCHAR wch)
{
    return    (unsigned)(wch - 0x0000) <= (0x001f - 0x0000)
           || (unsigned)(wch - 0x007f) <= (0x009f - 0x007f);
}

// NB (cthrash) WCH_NBSP is considered blank, for compatibility.

BOOL IsCharBlankW(WCHAR wch)
{
    return    wch == 0x0009
           || wch == 0x0020
           || wch == 0x00a0
           || wch == 0x3000
           || wch == 0xfeff;
}


BOOL IsCharAlphaWrapW(WCHAR wch) { return ISCHARFUNC(Alpha, wch); }
BOOL IsCharUpperWrapW(WCHAR wch) { return ISCHARFUNC(Upper, wch); }
BOOL IsCharLowerWrapW(WCHAR wch) { return ISCHARFUNC(Lower, wch); }

BOOL IsCharAlphaNumericWrapW(WCHAR wch)
{
    return ISCHARFUNC(Alpha, wch) || ISCHARFUNC(Digit, wch);
}


static const BYTE abType3PageSub[256] = 
{
    0x00, 0x80, 0x81, 0x82, 0x00, 0x83, 0x84, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 
    0x00, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x8e, 0x8f, 0x90, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x91, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x20, 0x92, 0x00, 0x00, 0x93, 0x94, 0x00
};

static const BYTE abType3Page0[256] = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x09, 0x09, 0x01, 0x09, 0x09, 0x01, 
    0x01, 0x01, 0x00, 0x01, 0x09, 0x01, 0x01, 0x09, 
    0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page32[256] = 
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x11, 0x11, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page48[256] = 
{
    0x11, 0x11, 0x11, 0x00, 0x00, 0x20, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x16, 0x16, 0x04, 0x04, 0x00, 
    0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x12, 0x02, 0x12, 0x02, 
    0x12, 0x02, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 
    0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 
    0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x13, 0x06, 0x02, 0x02, 0x00
};

static const BYTE abType3Page255[256] = 
{
    0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


struct tagType3DualValue
{
    DWORD   adwBitfield[8];
    DWORD   adwValue[2];
}
const aType3DualValue[21] =
{
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page1
      0x00000000, 0x0000000f, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page2
      0x00000000, 0x3f000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x000000b0,   // Page3
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xf8000000, 0x00000000, 0x00000200,   // Page5
      0x40000000, 0x00000009, 0x00180000, 0x00000000, 0x00000001 },
    { 0x88001000, 0x00000000, 0x00000000, 0x00003c00, 0x00000000,   // Page6
      0x00000000, 0x00100000, 0x00000200, 0x00000000, 0x00000001 },
    { 0x00000000, 0x80008000, 0x0c008040, 0x00000000, 0x00000000,   // Page14
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page31
      0xe0000000, 0xe000e003, 0x6000e000, 0x00000000, 0x00000001 },
    { 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000,   // Page33
      0xffffffff, 0xffffffff, 0x000007ff, 0x00000000, 0x00000001 },
    { 0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page34
      0x00000000, 0x00000000, 0xfffc0000, 0x00000001, 0x00000000 },
    { 0x00000002, 0x00000000, 0x00000000, 0xf8000000, 0xffffffff,   // Page35
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0xffffffe0, 0xfffff800, 0xffffffff, 0xffffffff,   // Page36
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffc00000,   // Page37
      0x00002000, 0x00000000, 0xffff8000, 0x00000001, 0x00000000 },
    { 0x03f00000, 0x00000000, 0x00000000, 0xffff0000, 0xffffffff,   // Page38
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0xfffff3de, 0xfffffeff, 0x7f47afff, 0x000000fe, 0xff100000,   // Page39
      0x7ffeffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfffe0000, 0xffffffff, 0x0000001f, 0x00000000,   // Page49
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010 },
    { 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0x00000000,   // Page50
      0x00000000, 0x00000fff, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xff000000, 0x0001ffff, 0x00000000,   // Page51
      0x00000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page159
      0xffffffc0, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff,   // Page250
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xc0000000, 0x00000000, 0x00000000, 0x00000000,   // Page253
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfff90000, 0xfef7fe1f, 0x00000f77, 0x00000000,   // Page254
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 }
};


//
//  CType 3 Flag Bits.
//
//  In the interest of reducing our table complexity, we've here a reduced
//  bitfield.  Only those bits currently used by IE4 are returned by
//  GetStringType3Ex().
//

// These are the flags are they are defined in winnls.h
//

// C3_NONSPACING    0x0001
// C3_DIACRITIC     0x0002
// C3_VOWELMARK     0x0004
// C3_SYMBOL        0x0008
// C3_KATAKANA      0x0010
// C3_HIRAGANA      0x0020
// C3_HALFWIDTH     0x0040
// C3_FULLWIDTH     0x0080
// C3_IDEOGRAPH     0x0100
// C3_KASHIDA       0x0200
// C3_LEXICAL       0x0400
// C3_ALPHA         0x8000

// The supported flags are encoded by shifting them to the right 3 bits.

// C3_SYMBOL       0x0001
// C3_KATAKANA     0x0002
// C3_HIRAGANA     0x0004
// C3_HALFWIDTH    0x0008
// C3_FULLWIDTH    0x0010
// C3_IDEOGRAPH    0x0020

// GetStringType3Ex returns the correct Win32 flags NOT the compressed flags.


BOOL 
GetStringType3ExW(
    LPCWSTR lpSrcStr,    // string arg
    int     cchSrc,      // length (or -1)
    LPWORD  lpCharType ) // output buffer
{
    LPCWSTR  lpStop = lpSrcStr + ((cchSrc == -1) ? MAXLONG : cchSrc);

    while (lpSrcStr < lpStop)
    {
        WCHAR wch = *lpSrcStr++;
        WORD wCharType;
        BYTE bPageSub;

        if (!wch && cchSrc == -1)
            break;

        switch (wch & (unsigned int)0xff00)
        {
            case 0x0000:
                wCharType = abType3Page0[wch];         // Page0: 4 values
                break;
            case 0x2000:
                wCharType = abType3Page32[wch & 0xff]; // Page32: 4 values
                break;
            case 0x3000:
                wCharType = abType3Page48[wch & 0xff];  // Page48: 10 values
                break;
            case 0xff00:
                wCharType = abType3Page255[wch & 0xff]; // Page255: 7 values
                break;
            default:
                bPageSub = abType3PageSub[wch>>8];

                if (bPageSub & 0x80)                  // 21 pages have 2 values
                {
                    const struct tagType3DualValue *p = aType3DualValue +
                        (bPageSub & 0x7f);

                    wCharType = (BYTE) p->adwValue[(p->adwBitfield[(wch>>5)&7]
                        >> (wch & 0x1f)) & 1];
                }
                else                                  // 231 pages have 1 value
                {
                    wCharType = bPageSub;
                }
                break;
        }

        *lpCharType++ = wCharType << 3;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\threads.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    threads.h

Abstract:

    Win32 version of NT wait/timer/thread pool functions

Author:

    Richard L Firth (rfirth) 27-Feb-1998

Notes:

    Original code from NT5/gurdeep

Revision History:

    27-Feb-1998 rfirth
        Created

--*/

//
// manifests
//

#define TPS_IO_WORKER_SIGNATURE     0x49737054  // 'TpsI'
#define TPS_WORKER_SIGNATURE        0x4B737054  // 'TpsK'
#define TPS_TIMER_SIGNATURE         0x54737054  // 'TpsT'
#define TPS_WAITER_SIGNATURE        0x57577054  // 'TpsW'

#define MAX_WAITS   64

//
// global data
//

EXTERN_C BOOL g_bDllTerminating;
extern BOOL g_bTpsTerminating;
extern DWORD g_ActiveRequests;

//
// prototypes for internal functions
//

VOID
TerminateTimers(
    VOID
    );

VOID
TerminateWaiters(
    VOID
    );

VOID
TerminateWorkers(
    VOID
    );

//
// Prototypes for thread pool private functions
//

DWORD
StartThread(
    IN LPTHREAD_START_ROUTINE pfnFunction,
    OUT PHANDLE phThread,
    IN BOOL fSynchronize
    );

DWORD
TpsEnter(
    VOID
    );

#define TpsLeave() \
    InterlockedDecrement((LPLONG)&g_ActiveRequests)

VOID
QueueNullFunc(
    IN HANDLE hThread
    );

#define THREAD_TYPE_WORKER      1
#define THREAD_TYPE_IO_WORKER   2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\time.cpp ===
#include "priv.h"

#ifdef _X86_
#include <w95wraps.h>
#endif

#include "ids.h"

#include <mluisupp.h>

#ifndef DATE_LTRREADING
#define DATE_LTRREADING           0x00000010    //FEATURE: figure out why we have to do this, and fix it. 
#define DATE_RTLREADING           0x00000020    
#endif

/*-------------------------------------------------------------------------
Purpose: Calls GetDateFormat and tries to replace the day with 
         a relative reference like "Today" or "Yesterday".

         Returns the count of characters written to pszBuf.
*/
int GetRelativeDateFormat(
    DWORD dwDateFlags, 
    DWORD * pdwFlags, 
    SYSTEMTIME * pstDate, 
    LPWSTR pszBuf, 
    int cchBuf)
{
    int cch;

    ASSERT(pdwFlags);
    ASSERT(pstDate);
    ASSERT(pszBuf);

    // Assume that no relative date is applied, so clear the bit
    // for now.
    *pdwFlags &= ~FDTF_RELATIVE;
    
    // Get the Win32 date format.  (GetDateFormat's return value includes
    // the null terminator.)
    cch = GetDateFormat(LOCALE_USER_DEFAULT, dwDateFlags, pstDate, NULL, pszBuf, cchBuf);
    if (0 < cch)
    {
        SYSTEMTIME stCurrentTime;
        int iDay = 0;   // 1 = today, -1 = yesterday, 0 = neither today nor yesterday.

        // Now see if the date merits a replacement to "Yesterday" or "Today".
        
        GetLocalTime(&stCurrentTime);      // get the current date 

        // Does it match the current day?
        if (pstDate->wYear == stCurrentTime.wYear   && 
            pstDate->wMonth == stCurrentTime.wMonth &&
            pstDate->wDay == stCurrentTime.wDay)
        {
            // Yes
            iDay = 1;
        }
        else 
        {
            // No; maybe it matches yesterday    
            FILETIME ftYesterday;
            SYSTEMTIME stYesterday;

            // Compute yesterday's date by converting to FILETIME,
            // subtracting one day, then converting back.
            SystemTimeToFileTime(&stCurrentTime, &ftYesterday);
            DecrementFILETIME(&ftYesterday, FT_ONEDAY);
            FileTimeToSystemTime(&ftYesterday, &stYesterday);

            // Does it match yesterday?
            if (pstDate->wYear == stYesterday.wYear   && 
                pstDate->wMonth == stYesterday.wMonth &&
                pstDate->wDay == stYesterday.wDay)
            {
                // Yes
                iDay = -1;
            }
        }

        // Should we try replacing the day?
        if (0 != iDay)
        {
            // Yes
            TCHAR szDayOfWeek[32];
            LPTSTR pszModifier;
            int cchDayOfWeek;

            cchDayOfWeek = MLLoadString((IDS_DAYSOFTHEWEEK + pstDate->wDayOfWeek), 
                                      szDayOfWeek, SIZECHARS(szDayOfWeek));

            // Search for the day of week text in the string we got back.
            // Depending on the user's regional settings, there might not
            // be a day in the long-date format...
            
            pszModifier = StrStr(pszBuf, szDayOfWeek);

            if (pszModifier)
            {
                // We found the day in the string, so replace it with
                // "Today" or "Yesterday"
                TCHAR szTemp[64];
                TCHAR szRelativeDay[32];
                int cchRelativeDay;

                // Save the tail end (the part after the "Monday" string) 
                lstrcpyn(szTemp, &pszModifier[cchDayOfWeek], SIZECHARS(szTemp));
                
                // Load the appropriate string ("Yesterday" or "Today").
                // If the string is empty (localizers might need to do this
                // if this logic isn't locale-friendly), don't bother doing
                // anything.
                cchRelativeDay = MLLoadString((1 == iDay) ? IDS_TODAY : IDS_YESTERDAY, 
                                            szRelativeDay, SIZECHARS(szRelativeDay));
                if (0 < cchRelativeDay)
                {
                    // Make sure that we have enough room for the replacement
                    // (cch already accounts for the null terminator)
                    if (cch - cchDayOfWeek + cchRelativeDay <= cchBuf)
                    {
                        // copy the friendly name over the day of the week
                        lstrcpy(pszModifier, szRelativeDay);

                        // put back the tail end
                        lstrcat(pszModifier, szTemp);
                        cch = cch - cchDayOfWeek + cchRelativeDay;

                        *pdwFlags |= FDTF_RELATIVE;
                    }
                }
            }
        }
    }

    return cch;
}

#define LRM 0x200E // UNICODE Left-to-right mark control character
#define RLM 0x200F // UNICODE Left-to-right mark control character

/*-------------------------------------------------------------------------
Purpose: Constructs a displayname form of the file time.

         *pdwFlags may be NULL, in which case FDTF_DEFAULT is assumed.  Other
         valid flags are:

            FDTF_DEFAULT    "3/29/98 7:48 PM"
            FDTF_SHORTTIME  "7:48 PM"
            FDTF_SHORTDATE  "3/29/98"
            FDTF_LONGDATE   "Monday, March 29, 1998"
            FDTF_LONGTIME   "7:48:33 PM"
            FDTF_RELATIVE   only works with FDTF_LONGDATE.  If possible, 
                            replace the day with "Yesterday" or "Today":
                            "Yesterday, March 29, 1998"

         This function updates *pdwFlags to indicate which sections of the
         string were actually set.  For example, if FDTF_RELATIVE is passed
         in, but no relative date conversion was performed, then FDTF_RELATIVE
         is cleared before returning.

         If the date is the magic "Sorry, I don't know what date it is" value
         that FAT uses, then we return an empty string.

*/
STDAPI_(int) SHFormatDateTimeW(const FILETIME UNALIGNED *puft, DWORD *pdwFlags, LPWSTR pszBuf, UINT ucchBuf)
{
    int cchBuf = ucchBuf;
    int cchBufSav = cchBuf;
    FILETIME ftLocal, ftInput = *puft;       // allign the data

    ASSERT(IS_VALID_READ_PTR(puft, FILETIME));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, WCHAR, cchBuf));
    ASSERT(NULL == pdwFlags || IS_VALID_WRITE_PTR(pdwFlags, DWORD));

    DWORD dwFlags = 0; 
    FileTimeToLocalFileTime(&ftInput, &ftLocal);

    if (FILETIMEtoInt64(ftInput) == FT_NTFS_UNKNOWNGMT ||
        FILETIMEtoInt64(ftLocal) == FT_FAT_UNKNOWNLOCAL)
    {
        // This date is uninitialized.  Don't show a bogus "10/10/72" string.
        if (0 < cchBuf)
            *pszBuf = 0;
    }
    else if (0 < cchBuf)
    {
        int cch;
        SYSTEMTIME st;
        DWORD dwDateFlags = DATE_SHORTDATE;     // default
        DWORD dwTimeFlags = TIME_NOSECONDS;     // default

        dwFlags = pdwFlags ? *pdwFlags : FDTF_DEFAULT;

        // Initialize the flags we're going to use
        if (dwFlags & FDTF_LONGDATE)
            dwDateFlags = DATE_LONGDATE;
        else
            dwFlags &= ~FDTF_RELATIVE;      // can't show relative dates w/o long dates

        if (dwFlags & FDTF_LTRDATE)
            dwDateFlags |= DATE_LTRREADING;
        else if(dwFlags & FDTF_RTLDATE)
            dwDateFlags |= DATE_RTLREADING;

        if (dwFlags & FDTF_LONGTIME)
            dwTimeFlags &= ~TIME_NOSECONDS;

        FileTimeToSystemTime(&ftLocal, &st);

        cchBuf--;       // Account for null terminator first
        
        if (dwFlags & (FDTF_LONGDATE | FDTF_SHORTDATE))
        {
            // Get the date
            if (dwFlags & FDTF_RELATIVE)
                cch = GetRelativeDateFormat(dwDateFlags, &dwFlags, &st, pszBuf, cchBuf);
            else
                cch = GetDateFormat(LOCALE_USER_DEFAULT, dwDateFlags, &st, NULL, pszBuf, cchBuf);
            ASSERT(0 <= cch && cch <= cchBuf);

            if (0 < cch)
            {
                cch--;      // (null terminator was counted above, so don't count it again)
                ASSERT('\0'==pszBuf[cch]);
            }
            else
                dwFlags &= ~(FDTF_LONGDATE | FDTF_SHORTDATE);   // no date, so clear these bits
            cchBuf -= cch;
            pszBuf += cch;

            // Are we tacking on the time too?
            if (dwFlags & (FDTF_SHORTTIME | FDTF_LONGTIME))
            {
                // Yes; for long dates, separate with a comma, otherwise
                // separate with a space.
                if (dwFlags & FDTF_LONGDATE)
                {
                    WCHAR szT[8];
                    
                    cch = MLLoadString(IDS_LONGDATE_SEP, szT, SIZECHARS(szT));
                    StrCpyNW(pszBuf, szT, cchBuf);
                    int cchCopied = min(cchBuf, cch);
                    cchBuf -= cchCopied;
                    pszBuf += cchCopied;
                }
                else
                {
                    if (cchBuf>0)
                    {
                        *pszBuf++ = TEXT(' ');
                        *pszBuf = 0;          // (in case GetTimeFormat doesn't add anything)
                        cchBuf--;
                    }
                }
                // [msadek]; need to insert strong a Unicode control character to simulate
                // a strong run in the opposite base direction to enforce
                // correct display of concatinated string in all cases
                if (dwFlags & FDTF_RTLDATE)
                {
                    if (cchBuf>=2)
                    {
                        *pszBuf++ = LRM; // simulate an opposite run
                        *pszBuf++ = RLM; // force RTL display of the time part.
                        *pszBuf = 0;
                        cchBuf -= 2;
                    }
                }
                else if (dwFlags & FDTF_LTRDATE)
                {
                    if (cchBuf>=2)
                    {
                        *pszBuf++ = RLM; // simulate an opposite run
                        *pszBuf++ = LRM; // force LTR display of the time part.
                        *pszBuf = 0;
                        cchBuf -= 2;                    
                    }
                }
            }
        }

        if (dwFlags & (FDTF_SHORTTIME | FDTF_LONGTIME))
        {
            // Get the time
            cch = GetTimeFormat(LOCALE_USER_DEFAULT, dwTimeFlags, &st, NULL, pszBuf, cchBuf);
            if (0 < cch)
                cch--;      // (null terminator was counted above, so don't count it again)
            else
                dwFlags &= ~(FDTF_LONGTIME | FDTF_SHORTTIME);   // no time, so clear these bits
            cchBuf -= cch;
        }
    }

    if (pdwFlags)
        *pdwFlags = dwFlags;
        
    return cchBufSav - cchBuf;
}

STDAPI_(int) SHFormatDateTimeA(const FILETIME UNALIGNED *pft, DWORD *pdwFlags, LPSTR pszBuf, UINT cchBuf)
{
    WCHAR wsz[256];
    int cchRet = SHFormatDateTimeW(pft, pdwFlags, wsz, SIZECHARS(wsz));
    if (0 < cchRet)
    {
        cchRet = SHUnicodeToAnsi(wsz, pszBuf, cchBuf);
    }
    else if (0 < cchBuf)
    {
        *pszBuf = 0;
    }
    return cchRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\strings.c ===
//============================================================================
//
// DBCS and UNICODE aware string routines
//
//
//============================================================================

#include "priv.h"
#include "ids.h"
#include <winnlsp.h>    // Get private NORM_ flag for StrEqIntl()
#include <shlobj.h>     // STRRET LPCITEMIDLIST

#ifdef _X86_
#include <w95wraps.h>
#endif

#include <mluisupp.h>

#include "varutil.h"

BOOL UnicodeFromAnsi(LPWSTR *, LPCSTR, LPWSTR, int);

#define IS_DIGITA(ch)    InRange(ch, '0', '9')
#define IS_DIGITW(ch)    InRange(ch, L'0', L'9')


#define DM_INTERVAL 0

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else 
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif

__inline BOOL IsAsciiA(char ch)
{
    return !(ch & 0x80);
}

__inline BOOL IsAsciiW(WCHAR ch)
{
    return ch < 128;
}

__inline char Ascii_ToLowerA(char ch)
{
    return (ch >= 'A' && ch <= 'Z') ? (ch - 'A' + 'a') : ch;
}

__inline WCHAR Ascii_ToLowerW(WCHAR ch)
{
    return (ch >= L'A' && ch <= L'Z') ? (ch - L'A' + L'a') : ch;
}


// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand thid


/*
 * StrEndN - Find the end of a string, but no more than n bytes
 * Assumes   lpStart points to start of null terminated string
 *           nBufSize is the maximum length
 * returns ptr to just after the last byte to be included
 */
LPSTR
lstrfns_StrEndNA(
    LPCSTR lpStart,
    int nBufSize)
{
    LPCSTR lpEnd;

    for (lpEnd = lpStart + nBufSize; *lpStart && lpStart < lpEnd;
         lpStart = AnsiNext(lpStart))
        continue;   /* just getting to the end of the string */

    if (lpStart > lpEnd)
    {
        /* We can only get here if the last byte before lpEnd was a lead byte
        */
        lpStart -= 2;
    }
    return((LPSTR)lpStart);
}


LPWSTR lstrfns_StrEndNW(LPCWSTR lpStart, int nBufSize)
{
    LPCWSTR lpEnd;

    for (lpEnd = lpStart + nBufSize; *lpStart && (lpStart < lpEnd);
         lpStart++)
        continue;   /* just getting to the end of the string */

    return((LPWSTR)lpStart);
}


/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


__inline BOOL ChrCmpW_inline(WCHAR w1, WCHAR wMatch)
{
    return(!(w1 == wMatch));
}


/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

#if defined(MWBIG_ENDIAN)
    sz2[0] = LOBYTE(wMatch);
    sz2[1] = HIBYTE(wMatch);
#else
    *(WORD *)sz2 = wMatch;
#endif
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch)
{
    WCHAR sz1[2], sz2[2];

    sz1[0] = w1;
    sz1[1] = '\0';
    sz2[0] = wMatch;
    sz2[1] = '\0';

    return StrCmpIW(sz1, sz2);
}

LPWSTR StrCpyW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    LPWSTR psz = pszDst;

    RIPMSG(NULL!=pszDst, "StrCpyW: Caller passed invalid pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCpyW: Caller passed invalid pszSrc");
    if (pszDst && pszSrc)
    {
        while (*pszDst++ = *pszSrc++)
            ;
    }

    return psz;
}

//***   StrCpyNX[AW] -- just like StrCpyN[AW], but returns ptr to EOS
// NOTES
//  do we really need 'A' version?  (for now we do for shell32 on 'old'
//  platforms that we test on but don't ship)
LPSTR StrCpyNXA(LPSTR pszDst, LPCSTR pszSrc, int cchMax)
{
    RIPMSG(cchMax >= 0, "StrCpyNXA: Caller passed bad cchMax");
    RIPMSG(cchMax < 0 || (pszDst && IS_VALID_WRITE_BUFFER(pszDst, char, cchMax)), "StrCpyNXA: Caller passed bad pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRA(pszSrc, -1), "StrCpyNXA: Caller passed bad pszSrc");

    // NOTE: Cannot use DEBUGWhackPathBuffer before copying because src and
    // dest might overlap.  Must delay whacking until after we're done.

    if (0 < cchMax)
    {
        if (!pszSrc)
            goto NullItOut;

        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if (!(*pszDst++ = *pszSrc++))
            {
                --pszDst;
                break;
            }
        }

        cchMax++;
        // in the cchMax>1 case, pszDst already points at the NULL, but reassigning it doesn't hurt
NullItOut:
        // Whack the unused part of the buffer
        DEBUGWhackPathBufferA(pszDst, cchMax);
        *pszDst = '\0';
    }

    return pszDst;
}

LPWSTR StrCpyNXW(LPWSTR pszDst, LPCWSTR pszSrc, int cchMax)
{
    RIPMSG(cchMax >= 0, "StrCpyNXW: Caller passed bad cchMax");
    RIPMSG(cchMax < 0 || (pszDst && IS_VALID_WRITE_BUFFER(pszDst, WCHAR, cchMax)), "StrCpyNXW: Caller passed bad pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCpyNXW: Caller passed bad pszSrc");

    // NOTE: Cannot use DEBUGWhackPathBuffer before copying because src and
    // dest might overlap.  Must delay whacking until after we're done.

    if (0 < cchMax)
    {
        if (!pszSrc) // a test app passed in a NULL src ptr and we faulted, let's not fault here.
            goto NullItOut;

        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if (!(*pszDst++ = *pszSrc++))
            {
                --pszDst;
                break;
            }
        }

        cchMax++;
        // in the cchMax>1 case, pszDst already points at the NULL, but reassigning it doesn't hurt
NullItOut:
        // Whack the unused part of the buffer
        DEBUGWhackPathBufferW(pszDst, cchMax);
        *pszDst = L'\0';
    }

    return pszDst;
}

LPWSTR StrCpyNW(LPWSTR pszDst, LPCWSTR pszSrc, int cchMax)
{
    StrCpyNXW(pszDst, pszSrc, cchMax);
    return pszDst;
}


LPWSTR StrCatW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    LPWSTR psz = pszDst;

    RIPMSG(pszDst && IS_VALID_STRING_PTRW(pszDst, -1), "StrCatW: Caller passed invalid pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCatW: Caller passed invalid pszSrc");
    if (pszDst && pszSrc)
    {
        while (0 != *pszDst)
            pszDst++;

        while (*pszDst++ = *pszSrc++)
            ;
    }
    return psz;
}

LWSTDAPI_(LPWSTR) StrCatBuffW(LPWSTR pszDest, LPCWSTR pszSrc, int cchDestBuffSize)
{
    RIPMSG(pszDest && IS_VALID_STRING_PTRW(pszDest, -1), "StrCatBuffW: Caller passed invalid pszDest");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCatBuffW: Caller passed invalid pszSrc");
    RIPMSG(cchDestBuffSize >= 0, "StrCatBuffW: Caller passed invalid cchDestBuffSize");
    RIPMSG(!(pszDest && IS_VALID_STRING_PTRW(pszDest, -1)) || cchDestBuffSize<0 || lstrlenW(pszDest)<cchDestBuffSize, "StrCatBuffW: Caller passed odd pszDest - string larger than cchDestBuffSize!");
    DEBUGWhackPathStringW(pszDest, cchDestBuffSize);

    if (pszDest && pszSrc)
    {
        LPWSTR psz = pszDest;

        // we walk forward till we find the end of pszDest, subtracting
        // from cchDestBuffSize as we go.
        while (*psz)
        {
            psz++;
            cchDestBuffSize--;
        }

        if (cchDestBuffSize > 0)
        {
            // call the shlwapi function here because win95 does not have lstrcpynW
            StrCpyNW(psz, pszSrc, cchDestBuffSize);
        }
    }
    return pszDest;
}

 
LWSTDAPI_(LPSTR) StrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize)
{
    RIPMSG(pszDest && IS_VALID_STRING_PTRA(pszDest, -1), "StrCatBuffA: Caller passed invalid pszDest");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRA(pszSrc, -1), "StrCatBuffA: Caller passed invalid pszSrc");
    RIPMSG(cchDestBuffSize >= 0, "StrCatBuffA: Caller passed invalid cchDestBuffSize");
    RIPMSG(!(pszDest && IS_VALID_STRING_PTRA(pszDest, -1)) || cchDestBuffSize<0 || lstrlen(pszDest)<cchDestBuffSize, "StrCatBuffA: Caller passed odd pszDest - string larger than cchDestBuffSize!");
    DEBUGWhackPathStringA(pszDest, cchDestBuffSize);

    if (pszDest && pszSrc)
    {
        LPSTR psz = pszDest;
        
        // we walk forward till we find the end of pszDest, subtracting
        // from cchDestBuffSize as we go.
        while (*psz)
        {
            psz++;
            cchDestBuffSize--;
        }

        if (cchDestBuffSize > 0)
        {
            // Let kernel do the work for us. 
            //
            // WARNING: We might generate a truncated DBCS sting becuase kernel's lstrcpynA
            // dosent check for this. Ask me if I care.
            lstrcpynA(psz, pszSrc, cchDestBuffSize);
        }
    }

    return pszDest;
}
   

/* StrNCat(front, back, count) - append count chars of back onto front
 */
LPSTR StrNCatA(LPSTR front, LPCSTR back, int cchMax)
{
    LPSTR start = front;

    RIPMSG(front && IS_VALID_STRING_PTRA(front, -1), "StrNCatA: Caller passed invalid front");
    RIPMSG(back && IS_VALID_STRING_PTRA(front, cchMax), "StrNCatA: Caller passed invalid back");
    RIPMSG(cchMax >= 0, "StrNCatA: Caller passed invalid cchMax");
    if (front && back)
    {
        while (*front++)
                    ;
        front--;

        lstrcpyn(front, back, cchMax);
    }
    return(start);    
}

LPWSTR StrNCatW(LPWSTR front, LPCWSTR back, int cchMax)
{
    LPWSTR start = front;

    RIPMSG(front && IS_VALID_STRING_PTRW(front, -1), "StrNCatW: Caller passed invalid front");
    RIPMSG(back && IS_VALID_STRING_PTRW(front, cchMax), "StrNCatW: Caller passed invalid back");
    RIPMSG(cchMax >= 0, "StrNCatW: Caller passed invalid cchMax");
    if (front && back)
    {
        while (*front++)
                    ;
        front--;

        StrCpyNW(front, back, cchMax);
    }    
    return(start);    
}

/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch, BOOL fMBCS)
{
    if (fMBCS) {
        for ( ; *lpStart; lpStart = AnsiNext(lpStart))
        {
            if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
                return((LPSTR)lpStart);
        }
    } else {
        for ( ; *lpStart; lpStart++)
        {
            if ((BYTE)*lpStart == LOBYTE(wMatch)) {
                return((LPSTR)lpStart);
            }
        }
    }
    return (NULL);
}

LPSTR StrChrA(LPCSTR lpStart, WORD wMatch)
{
    CPINFO cpinfo;

    RIPMSG(lpStart && IS_VALID_STRING_PTR(lpStart, -1), "StrChrA: caller passed bad lpStart");
    if (!lpStart)
        return NULL;

    return _StrChrA(lpStart, wMatch, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

#ifdef ALIGNMENT_SCENARIO

LPWSTR StrChrSlowW(const UNALIGNED WCHAR *lpStart, WCHAR wMatch)
{
    for ( ; *lpStart; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return NULL;
}
#endif

LPWSTR StrChrW(LPCWSTR lpStart, WCHAR wMatch)
{
    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrChrW: caller passed bad lpStart");
    if (!lpStart)
        return NULL;

    //
    //  raymondc
    //  Apparently, somebody is passing unaligned strings to StrChrW.
    //  Find out who and make them stop.
    //
    RIPMSG(!((ULONG_PTR)lpStart & 1), "StrChrW: caller passed UNALIGNED lpStart"); // Assert alignedness

#ifdef ALIGNMENT_SCENARIO
    //
    //  Since unaligned strings arrive so rarely, put the slow
    //  version in a separate function so the common case stays
    //  fast.  Believe it or not, we call StrChrW so often that
    //  it is now a performance-sensitive function!
    //
    if ((ULONG_PTR)lpStart & 1)
        return StrChrSlowW(lpStart, wMatch);
#endif

    for ( ; *lpStart; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}

/*
 * StrChrN - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */

#ifdef ALIGNMENT_SCENARIO

LPWSTR StrChrSlowNW(const UNALIGNED WCHAR *lpStart, WCHAR wMatch, UINT cchMax)
{
    LPCWSTR lpSentinel = lpStart + cchMax;
    for ( ; *lpStart && lpStart < lpSentinel; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
}
#endif

LPWSTR StrChrNW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax)
{
    LPCWSTR lpSentinel = lpStart + cchMax;

    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrChrNW: caller passed bad lpStart");
    if (!lpStart)
        return NULL;

    //
    //  raymondc
    //  Apparently, somebody is passing unaligned strings to StrChrW.
    //  Find out who and make them stop.
    //
    RIPMSG(!((ULONG_PTR)lpStart & 1), "StrChrNW: caller passed UNALIGNED lpStart"); // Assert alignedness

#ifdef ALIGNMENT_SCENARIO
    //
    //  Since unaligned strings arrive so rarely, put the slow
    //  version in a separate function so the common case stays
    //  fast.  Believe it or not, we call StrChrW so often that
    //  it is now a performance-sensitive function!
    //
    if ((ULONG_PTR)lpStart & 1)
        return StrChrSlowNW(lpStart, wMatch, cchMax);
#endif

    for ( ; *lpStart && lpStart<lpSentinel; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}


/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    RIPMSG(lpStart && IS_VALID_STRING_PTR(lpStart, -1), "StrRChrA: caller passed bad lpStart");
    RIPMSG(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart), "StrRChrA: caller passed bad lpEnd");
    // don't need to check for NULL lpStart

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

LPWSTR StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
    LPCWSTR lpFound = NULL;

    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrRChrW: caller passed bad lpStart");
    RIPMSG(!lpEnd || lpEnd <= lpStart + lstrlenW(lpStart), "StrRChrW: caller passed bad lpEnd");
    // don't need to check for NULL lpStart

    if (!lpEnd)
        lpEnd = lpStart + lstrlenW(lpStart);

    for ( ; lpStart < lpEnd; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPWSTR)lpFound);
}

/*
 * StrChrI - Find first occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR StrChrIA(LPCSTR lpStart, WORD wMatch)
{
    RIPMSG(lpStart && IS_VALID_STRING_PTRA(lpStart, -1), "StrChrIA: caller passed bad lpStart");
    if (lpStart)
    {
        wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

        for ( ; *lpStart; lpStart = AnsiNext(lpStart))
        {
            if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
                return((LPSTR)lpStart);
        }
    }
    return (NULL);
}

LPWSTR StrChrIW(LPCWSTR lpStart, WCHAR wMatch)
{
    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrChrIW: caller passed bad lpStart");
    if (lpStart)
    {
        for ( ; *lpStart; lpStart++)
        {
            if (!ChrCmpIW(*lpStart, wMatch))
                return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}

/*
 * StrChrNI - Find first occurrence of character in string, case insensitive, counted
 *
 */
LPWSTR StrChrNIW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax)
{
    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrChrNIW: caller passed bad lpStart");
    if (lpStart)
    {
        LPCWSTR lpSentinel = lpStart + cchMax;
        
        for ( ; *lpStart && lpStart < lpSentinel; lpStart++)
        {
            if (!ChrCmpIW(*lpStart, wMatch))
                return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}

/*
 * StrRChrI - Find last occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    RIPMSG(lpStart && IS_VALID_STRING_PTRA(lpStart, -1), "StrRChrIA: caller passed bad lpStart");
    RIPMSG(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart), "StrRChrIA: caller passed bad lpEnd");

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}


LPWSTR StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
    LPCWSTR lpFound = NULL;

    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrRChrIW: caller passed bad lpStart");
    RIPMSG(!lpEnd || lpEnd <= lpStart + lstrlenW(lpStart), "StrRChrIW: caller passed bad lpEnd");

    if (!lpEnd)
        lpEnd = lpStart + lstrlenW(lpStart);

    for ( ; lpStart < lpEnd; lpStart++)
    {
        if (!ChrCmpIW(*lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPWSTR)lpFound);
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the first occurrence of a character
         in psz that belongs to the set of characters in pszSet.
         The search does not include the null terminator.

         If psz contains no characters that are in the set of
         characters in pszSet, this function returns NULL.

         This function is DBCS-safe.

Returns: see above
Cond:    --
*/
LPSTR StrPBrkA(LPCSTR psz, LPCSTR pszSet)
{
    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "StrPBrkA: caller passed bad psz");
    RIPMSG(pszSet && IS_VALID_STRING_PTRA(pszSet, -1), "StrPBrkA: caller passed bad pszSet");
    if (psz && pszSet)
    {
        while (*psz)
        {
            LPCSTR pszSetT;
            for (pszSetT = pszSet; *pszSetT; pszSetT = CharNextA(pszSetT))
            {
                if (*psz == *pszSetT)
                {
                    // Found first character that matches
                    return (LPSTR)psz;      // Const -> non-const
                }
            }
            psz = CharNextA(psz);
        }
    }
    return NULL;
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the first occurrence of a character
         in psz that belongs to the set of characters in pszSet.
         The search does not include the null terminator.

Returns: see above
Cond:    --
*/
LPWSTR WINAPI StrPBrkW(LPCWSTR psz, LPCWSTR pszSet)
{
    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "StrPBrkA: caller passed bad psz");
    RIPMSG(pszSet && IS_VALID_STRING_PTRW(pszSet, -1), "StrPBrkA: caller passed bad pszSet");
    if (psz && pszSet)
    {
        while (*psz)
        {
            LPCWSTR pszSetT;
            for (pszSetT = pszSet; *pszSetT; pszSetT++)
            {
                if (*psz == *pszSetT)
                {
                    // Found first character that matches
                    return (LPWSTR)psz;     // Const -> non-const
                }
            }
            psz++;
        }
    }
    return NULL;
}


int WINAPI StrToIntA(LPCSTR lpSrc)
{
    RIPMSG(lpSrc && IS_VALID_STRING_PTRA(lpSrc, -1), "StrToIntA: Caller passed bad lpSrc");
    if (lpSrc)
    {
        int n = 0;
        BOOL bNeg = FALSE;

        if (*lpSrc == '-')
        {
            bNeg = TRUE;
            lpSrc++;
        }

        while (IS_DIGITA(*lpSrc))
        {
            n *= 10;
            n += *lpSrc - '0';
            lpSrc++;
        }
        return bNeg ? -n : n;
    }
    return 0;
}


int WINAPI StrToIntW(LPCWSTR lpSrc)
{
    RIPMSG(lpSrc && IS_VALID_STRING_PTRW(lpSrc, -1), "StrToIntW: Caller passed bad lpSrc");
    if (lpSrc)
    {
        int n = 0;
        BOOL bNeg = FALSE;

        if (*lpSrc == L'-')
        {
            bNeg = TRUE;
            lpSrc++;
        }

        while (IS_DIGITW(*lpSrc))
        {
            n *= 10;
            n += *lpSrc - L'0';
            lpSrc++;
        }
        return bNeg ? -n : n;
    }
    return 0;
}

/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *phRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

        dwFlags are STIF_ bitfield
Cond:    --
*/
BOOL WINAPI StrToInt64ExW(LPCWSTR pszString, DWORD dwFlags, LONGLONG *pllRet)
{
    BOOL bRet;

    RIPMSG(pszString && IS_VALID_STRING_PTRW(pszString, -1), "StrToInt64ExW: caller passed bad pszString");
    if (pszString)
    {
        LONGLONG n;
        BOOL bNeg = FALSE;
        LPCWSTR psz;
        LPCWSTR pszAdj;

        // Skip leading whitespace
        //
        for (psz = pszString; *psz == L' ' || *psz == L'\n' || *psz == L'\t'; psz++)
            ;

        // Determine possible explicit signage
        //
        if (*psz == L'+' || *psz == L'-')
        {
            bNeg = (*psz == L'+') ? FALSE : TRUE;
            psz++;
        }

        // Or is this hexadecimal?
        //
        pszAdj = psz+1;
        if ((STIF_SUPPORT_HEX & dwFlags) &&
            *psz == L'0' && (*pszAdj == L'x' || *pszAdj == L'X'))
        {
            // Yes

            // (Never allow negative sign with hexadecimal numbers)
            bNeg = FALSE;
            psz = pszAdj+1;

            pszAdj = psz;

            // Do the conversion
            //
            for (n = 0; ; psz++)
            {
                if (IS_DIGITW(*psz))
                    n = 0x10 * n + *psz - L'0';
                else
                {
                    WCHAR ch = *psz;
                    int n2;

                    if (ch >= L'a')
                        ch -= L'a' - L'A';

                    n2 = ch - L'A' + 0xA;
                    if (n2 >= 0xA && n2 <= 0xF)
                        n = 0x10 * n + n2;
                    else
                        break;
                }
            }

            // Return TRUE if there was at least one digit
            bRet = (psz != pszAdj);
        }
        else
        {
            // No
            pszAdj = psz;

            // Do the conversion
            for (n = 0; IS_DIGITW(*psz); psz++)
                n = 10 * n + *psz - L'0';

            // Return TRUE if there was at least one digit
            bRet = (psz != pszAdj);
        }

        if (pllRet)
        {
            *pllRet = bNeg ? -n : n;
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

/*----------------------------------------------------------
 Purpose: ansi wrapper for StrToInt64ExW.

 Returns: see StrToInt64ExW
 Cond:    --
 */
BOOL WINAPI StrToInt64ExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    LONGLONG FAR * pllRet)
{
    BOOL bRet;

    RIPMSG(pszString && IS_VALID_STRING_PTRA(pszString, -1), "StrToInt64ExA: caller passed bad pszString");
    if (pszString)
    {
        // Most strings will simply use this temporary buffer, but UnicodeFromAnsi
        // will allocate a buffer if the supplied string is bigger.
        WCHAR szBuf[MAX_PATH];
        LPWSTR pwszString;

        bRet = UnicodeFromAnsi(&pwszString, pszString, szBuf, SIZECHARS(szBuf));
        if (bRet)
        {
            bRet = StrToInt64ExW(pwszString, dwFlags, pllRet);
            UnicodeFromAnsi(&pwszString, NULL, szBuf, 0);
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

/*----------------------------------------------------------
 Purpose: Calls StrToInt64ExA (the real work horse), and 
          then casts down to an int.
 Returns: see StrToInt64ExA
 */
BOOL WINAPI StrToIntExA(
    LPCSTR pszString, 
    DWORD  dwFlags, 
    int   *piRet)
{
    LONGLONG llVal;
    BOOL fReturn;

    RIPMSG(pszString && IS_VALID_STRING_PTRA(pszString, -1), "StrToIntExA: caller passed bad pszString");

    fReturn = StrToInt64ExA(pszString, dwFlags, &llVal);
    *piRet = fReturn ? (int)llVal : 0;
    return(fReturn);
}

/*----------------------------------------------------------
 Purpose: Calls StrToInt64ExW (the real work horse), and 
          then casts down to an int.
 Returns: see StrToInt64ExW
 */
BOOL WINAPI StrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
{
    LONGLONG llVal;
    BOOL fReturn;

    RIPMSG(pwszString && IS_VALID_STRING_PTRW(pwszString, -1), "StrToIntExW: caller passed bad pwszString");

    fReturn = StrToInt64ExW(pwszString, dwFlags, &llVal);
    *piRet = fReturn ? (int)llVal : 0;
    return(fReturn);
}

/*----------------------------------------------------------
 Purpose: Returns an integer value specifying the length of
 the substring in psz that consists entirely of
 characters in pszSet.  If psz begins with a character
 not in pszSet, then this function returns 0.

 This is a DBCS-safe version of the CRT strspn().

 Returns: see above
 Cond:    --
 */
int StrSpnA(LPCSTR psz, LPCSTR pszSet)
{
    LPCSTR pszT = psz;

    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "StrSpnA: caller passed bad psz");
    RIPMSG(pszSet && IS_VALID_STRING_PTRA(pszSet, -1), "StrSpnA: caller passed bad pszSet");
    if (psz && pszSet)
    {
        // Go thru the string to be inspected
        for ( ; *pszT; pszT = CharNextA(pszT))
        {
            LPCSTR pszSetT;
            
            // Go thru the char set
            for (pszSetT = pszSet; *pszSetT; pszSetT = CharNextA(pszSetT))
            {
                if (*pszSetT == *pszT)
                {
                    if ( !IsDBCSLeadByte(*pszSetT) )
                    {
                        break;      // Chars match
                    }
                    else if (pszSetT[1] == pszT[1])
                    {
                        break;      // Chars match
                    }
                }
            }

            // End of char set?
            if (0 == *pszSetT)
            {
                break;      // Yes, no match on this inspected char
            }
        }
    }
    return (int)(pszT - psz);
}


/*----------------------------------------------------------
 Purpose: Returns an integer value specifying the length of
 the substring in psz that consists entirely of
 characters in pszSet.  If psz begins with a character
 not in pszSet, then this function returns 0.

 This is a DBCS-safe version of the CRT strspn().

 Returns: see above
 Cond:    --
 */
STDAPI_(int) StrSpnW(LPCWSTR psz, LPCWSTR pszSet)
{
    LPCWSTR pszT = psz;

    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "StrSpnW: caller passed bad psz");
    RIPMSG(pszSet && IS_VALID_STRING_PTRW(pszSet, -1), "StrSpnW: caller passed bad pszSet");
    if (psz && pszSet)
    {
        // Go thru the string to be inspected
        for ( ; *pszT; pszT++)
        {
            LPCWSTR pszSetT;

            // Go thru the char set
            for (pszSetT = pszSet; *pszSetT != *pszT; pszSetT++)
            {
                if (0 == *pszSetT)
                {
                    // Reached end of char set without finding a match
                    return (int)(pszT - psz);
                }
            }
        }
    }
    return (int)(pszT - psz);
}


// StrCSpn: return index to first char of lpStr that is present in lpSet.
// Includes the NUL in the comparison; if no lpSet chars are found, returns
// the index to the NUL in lpStr.
// Just like CRT strcspn.
//
int StrCSpnA(LPCSTR lpStr, LPCSTR lpSet)
{
    LPCSTR lp = lpStr;

    RIPMSG(lpStr && IS_VALID_STRING_PTRA(lpStr, -1), "StrCSpnA: Caller passed bad lpStr");
    RIPMSG(lpSet && IS_VALID_STRING_PTRA(lpSet, -1), "StrCSpnA: Caller passed bad lpSet");

    if (lpStr && lpSet)
    {
        // nature of the beast: O(lpStr*lpSet) work
        while (*lp)
        {
            if (StrChrA(lpSet, READNATIVEWORD(lp)))
                return (int)(lp-lpStr);
            lp = AnsiNext(lp);
        }
    }
    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet)
{
    LPCWSTR lp = lpStr;

    RIPMSG(lpStr && IS_VALID_STRING_PTRW(lpStr, -1), "StrCSpnW: Caller passed bad lpStr");
    RIPMSG(lpSet && IS_VALID_STRING_PTRW(lpSet, -1), "StrCSpnW: Caller passed bad lpSet");

    if (lpStr && lpSet)
    {
        // nature of the beast: O(lpStr*lpSet) work
        while (*lp)
        {
            if (StrChrW(lpSet, *lp))
                return (int)(lp-lpStr);
            lp++;
        }
    }
    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

// StrCSpnI: case-insensitive version of StrCSpn.
//
int StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet)
{
    LPCSTR lp = lpStr;

    RIPMSG(lpStr && IS_VALID_STRING_PTRA(lpStr, -1), "StrCSpnIA: Caller passed bad lpStr");
    RIPMSG(lpSet && IS_VALID_STRING_PTRA(lpSet, -1), "StrCSpnIA: Caller passed bad lpSet");

    if (lpStr && lpSet)
    {
        // nature of the beast: O(lpStr*lpSet) work
        while (*lp)
        {
            if (StrChrIA(lpSet, READNATIVEWORD(lp)))
                return (int)(lp-lpStr);
            lp = AnsiNext(lp);
        }
    }
    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet)
{
    LPCWSTR lp = lpStr;

    RIPMSG(lpStr && IS_VALID_STRING_PTRW(lpStr, -1), "StrCSpnIW: Caller passed bad lpStr");
    RIPMSG(lpSet && IS_VALID_STRING_PTRW(lpSet, -1), "StrCSpnIW: Caller passed bad lpSet");

    if (lpStr && lpSet)
    {
        // nature of the beast: O(lpStr*lpSet) work
        while (*lp)
        {
            if (StrChrIW(lpSet, *lp))
                return (int)(lp-lpStr);
            lp++;
        }
    }
    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}


/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
int _StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar, BOOL fMBCS)
{
    if (lpStr1 && lpStr2)
    {
        LPCSTR lpszEnd = lpStr1 + nChar;
        char sz1[4];
        char sz2[4];

        if (fMBCS) {
            for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) {
                WORD w1;
                WORD w2;
        
                // If either pointer is at the null terminator already,
                // we want to copy just one byte to make sure we don't read 
                // past the buffer (might be at a page boundary).
        
                w1 = (*lpStr1) ? READNATIVEWORD(lpStr1) : 0;
                w2 = (*lpStr2) ? READNATIVEWORD(lpStr2) : 0;
        
                // (ChrCmpA returns FALSE if the characters match)
        
                // Do the characters match?
                if (ChrCmpA_inline(w1, w2)) 
                {
                    // No; determine the lexical value of the comparison
                    // (since ChrCmp just returns true/false).
        
                    // Since the character may be a DBCS character; we
                    // copy two bytes into each temporary buffer 
                    // (in preparation for the lstrcmp call).
        
                    (*(WORD *)sz1) = w1;
                    (*(WORD *)sz2) = w2;
        
                    // Add null terminators to temp buffers
                    *AnsiNext(sz1) = 0;
                    *AnsiNext(sz2) = 0;
                    return lstrcmpA(sz1, sz2);
                }
            }
        } else {
            for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
                if (*lpStr1 != *lpStr2) {
                    // No; determine the lexical value of the comparison
                    // (since ChrCmp just returns true/false).
                    sz1[0] = *lpStr1;
                    sz2[0] = *lpStr2;
                    sz1[1] = sz2[1] = '\0';
                    return lstrcmpA(sz1, sz2);
                }
            }
        }
    }
    
    return 0;
}

STDAPI_(int) StrCmpNA(LPCSTR psz1, LPCSTR psz2, int nChar)
{
    CPINFO cpinfo;

    RIPMSG(nChar == 0 || (psz1 && IS_VALID_STRING_PTRA(psz1, nChar)), "StrCmpNA: Caller passed bad psz1");
    RIPMSG(nChar == 0 || (psz2 && IS_VALID_STRING_PTRA(psz2, nChar)), "StrCmpNA: Caller passed bad psz2");
    RIPMSG(nChar >= 0, "StrCmpNA: caller passed bad nChar");

    return _StrCmpNA(psz1, psz2, nChar, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

// cch1 and cch2 are the maximum # of chars to compare

int _StrCmpLocaleW(DWORD dwFlags, LPCWSTR psz1, int cch1, LPCWSTR psz2, int cch2)
{
    int i = CompareStringW(GetThreadLocale(), dwFlags, psz1, cch1, psz2, cch2);
    if (!i)
    {
        i = CompareStringW(LOCALE_SYSTEM_DEFAULT, dwFlags, psz1, cch1, psz2, cch2);
    }
    return i - CSTR_EQUAL;
}

int _StrCmpLocaleA(DWORD dwFlags, LPCSTR psz1, int cch1, LPCSTR psz2, int cch2)
{
    int i = CompareStringA(GetThreadLocale(), dwFlags, psz1, cch1, psz2, cch2);
    if (!i)
    {
        i = CompareStringA(LOCALE_SYSTEM_DEFAULT, dwFlags, psz1, cch1, psz2, cch2);
    }
    return i - CSTR_EQUAL;
}


STDAPI_(int) StrCmpNW(LPCWSTR psz1, LPCWSTR psz2, int nChar)
{
    RIPMSG(nChar==0 || (psz1 && IS_VALID_STRING_PTRW(psz1, nChar)), "StrCmpNW: Caller passed bad psz1");
    RIPMSG(nChar==0 || (psz2 && IS_VALID_STRING_PTRW(psz2, nChar)), "StrCmpNW: Caller passed bad psz2");
    RIPMSG(nChar>=0, "StrCmpNA: caller passed bad nChar");

    return _StrCmpLocaleW(NORM_STOP_ON_NULL, psz1, nChar, psz2, nChar);
}

/*
 * Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */

int StrCmpNIA(LPCSTR psz1, LPCSTR psz2, int nChar)
{
    RIPMSG(nChar==0 || (psz1 && IS_VALID_STRING_PTRA(psz1, nChar)), "StrCmpNIA: Caller passed bad psz1");
    RIPMSG(nChar==0 || (psz2 && IS_VALID_STRING_PTRA(psz2, nChar)), "StrCmpNIA: Caller passed bad psz2");
    RIPMSG(nChar>=0, "StrCmpNIA: caller passed bad nChar");

    // Include the (nChar && (!psz1 || !psz2)) cases here so we go through the
    // validation layer and return the appropriate invalid parameter error code
    // instead of faulting on Win95.
    //
    // NOTE!  That this means that StrCmpNI(NULL, NULL, 0) on NT returns -2
    // but StrCmpNI(NULL, NULL, 0) on Win9x returns 0.  This has always been
    // the case -- changing it is too scary for app compat reasons.
    //
    // Actually neither Win95 nor NT support NORM_STOP_ON_NULL for
    // StrCmpLocaleA.  Unfortunately, the failure modes are different
    // so we still have to be careful.
    //
    if (g_bRunningOnNT)
    {
        int nChar1, nChar2;

        if (nChar && (!psz1 || !psz2))
        {
            // This is the error scenario we are forcing through
            nChar1 = nChar;
            nChar2 = nChar;
        }
        else
        {
            // nChar1 = min(nChar, lstrlen(psz1))
            // except that the "for" loop will not read more than nChar
            // characters from psz1 because psz1 might not be NULL-terminated
            for (nChar1 = 0; nChar1 < nChar && psz1[nChar1]; nChar1++) { }

            // And similarly for nChar2
            for (nChar2 = 0; nChar2 < nChar && psz2[nChar2]; nChar2++) { }
        }

        return _StrCmpLocaleA(NORM_IGNORECASE, psz1, nChar1, psz2, nChar2);

    }
    else if (nChar && (!psz1 || !psz2))
    {
        return _StrCmpLocaleA(NORM_IGNORECASE | NORM_STOP_ON_NULL,  psz1, nChar, psz2, nChar);
    }
    else
    {
        int i;
        LPCSTR lpszEnd = psz1 + nChar;

        for ( ; (lpszEnd > psz1) && (*psz1 || *psz2); (psz1 = AnsiNext(psz1)), (psz2 = AnsiNext(psz2))) 
        {
            WORD w1, w2;

            // If either pointer is at the null terminator already,
            // we want to copy just one byte to make sure we don't read 
            // past the buffer (might be at a page boundary).

            if (IsAsciiA(*psz1) && IsAsciiA(*psz2))
            {
                i = Ascii_ToLowerA(*psz1) - Ascii_ToLowerA(*psz2);
            }
            else
            {
                w1 = (*psz1) ? READNATIVEWORD(psz1) : 0;
                w2 = (UINT)(IsDBCSLeadByte(*psz2)) ? (UINT)READNATIVEWORD(psz2) : (WORD)(BYTE)(*psz2);

                i = ChrCmpIA(w1, w2);
            }
            if (i)
            {
                if (i < 0)
                    return -1;
                else
                    return 1;
            }
        }
        return 0;
    }
}

int StrCmpNIW(LPCWSTR psz1, LPCWSTR psz2, int nChar)
{
    RIPMSG(nChar==0 || (psz1 && IS_VALID_STRING_PTRW(psz1, nChar)), "StrCmpNIW: Caller passed bad psz1");
    RIPMSG(nChar==0 || (psz2 && IS_VALID_STRING_PTRW(psz2, nChar)), "StrCmpNIW: Caller passed bad psz2");
    RIPMSG(nChar>=0, "StrCmpNW: caller passed bad nChar");

    return _StrCmpLocaleW(NORM_IGNORECASE | NORM_STOP_ON_NULL, psz1, nChar, psz2, nChar);
}


/*
 * StrRStrI      - Search for last occurrence of a substring
 *
 * Assumes   lpSource points to the null terminated source string
 *           lpLast points to where to search from in the source string
 *           lpLast is not included in the search
 *           lpSrch points to string to search for
 * returns   last occurrence of string if successful; NULL otherwise
 */
LPSTR StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch)
{
    LPCSTR lpFound = NULL;

    RIPMSG(lpSource && IS_VALID_STRING_PTRA(lpSource, -1), "StrRStrIA: Caller passed bad lpSource");
    RIPMSG(!lpLast || (IS_VALID_STRING_PTRA(lpLast, -1) && lpLast>=lpSource && lpLast<=lpSource+lstrlenA(lpSource)), "StrRStrIA: Caller passed bad lpLast");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRA(lpSrch, -1) && *lpSrch, "StrRStrIA: Caller passed bad lpSrch");

    if (!lpLast)
        lpLast = lpSource + lstrlenA(lpSource);

    if (lpSource && lpSrch && *lpSrch)
    {
        WORD   wMatch;
        UINT   uLen;
        LPCSTR  lpStart;
        
        wMatch = READNATIVEWORD(lpSrch);
        wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));
        
        uLen = lstrlenA(lpSrch);
        lpStart = lpSource;
        while (*lpStart && (lpStart < lpLast))
        {
            if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
            {   
                if (StrCmpNIA(lpStart, lpSrch, uLen) == 0)
                    lpFound = lpStart;
            }   
            lpStart = AnsiNext(lpStart);
        }
    }
    return((LPSTR)lpFound);
}

LPWSTR StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch)
{
    LPCWSTR lpFound = NULL;

    RIPMSG(lpSource && IS_VALID_STRING_PTRW(lpSource, -1), "StrRStrIW: Caller passed bad lpSource");
    RIPMSG(!lpLast || (IS_VALID_STRING_PTRW(lpLast, -1) && lpLast>=lpSource && lpLast<=lpSource+lstrlenW(lpSource)), "StrRStrIW: Caller passed bad lpLast");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, -1) && *lpSrch, "StrRStrIW: Caller passed bad lpSrch");

    if (!lpLast)
        lpLast = lpSource + lstrlenW(lpSource);

    if (lpSource && lpSrch && *lpSrch)
    {
        WCHAR   wMatch;
        UINT    uLen;
        LPCWSTR  lpStart;

        wMatch = *lpSrch;
        uLen = lstrlenW(lpSrch);
        lpStart = lpSource;
        while (*lpStart && (lpStart < lpLast))
        {
            if (!ChrCmpIW(*lpStart, wMatch))
            {   
                if (StrCmpNIW(lpStart, lpSrch, uLen) == 0)
                    lpFound = lpStart;
            }   
            lpStart++;
        }
    }
    return((LPWSTR)lpFound);
}

/*
 * StrStr      - Search for first occurrence of a substring
 *
 * Assumes   lpSource points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR StrStrA(LPCSTR lpFirst, LPCSTR lpSrch)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRA(lpFirst, -1), "StrStrA: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRA(lpSrch, -1), "StrStrA: Caller passed bad lpSrch");

    if (lpFirst && lpSrch)
    {
        UINT uLen;
        WORD wMatch;
        CPINFO cpinfo;
        BOOL fMBCS = GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0];

        uLen = (UINT)lstrlenA(lpSrch);
        wMatch = READNATIVEWORD(lpSrch);

        for ( ; (lpFirst=_StrChrA(lpFirst, wMatch, fMBCS))!=0 && _StrCmpNA(lpFirst, lpSrch, uLen, fMBCS);
             lpFirst=AnsiNext(lpFirst))
            continue; /* continue until we hit the end of the string or get a match */
        return((LPSTR)lpFirst);
    }
    return(NULL);
}

LPWSTR StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRW(lpFirst, -1), "StrStrW: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, -1), "StrStrW: Caller passed bad lpSrch");

    if (lpFirst && lpSrch)
    {
        UINT uLen;
        WCHAR wMatch;

        uLen = (UINT)lstrlenW(lpSrch);
        wMatch = *lpSrch;

        for ( ; (lpFirst=StrChrW(lpFirst, wMatch))!=0 && StrCmpNW(lpFirst, lpSrch, uLen);
             lpFirst++)
            continue; /* continue until we hit the end of the string or get a match */

        return (LPWSTR)lpFirst;
    }
    return NULL;
}

/*
 * StrStrN     - Search for first occurrence of a substring
 *
 * Assumes   lpSource points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
 
LPWSTR StrStrNW(LPCWSTR lpFirst, LPCWSTR lpSrch, UINT cchMax)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRW(lpFirst, cchMax), "StrStrW: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, cchMax), "StrStrW: Caller passed bad lpSrch");
    if (lpFirst && lpSrch)
    {
        UINT uLen;
        WCHAR wMatch;
        LPCWSTR lpSentinel = lpFirst+cchMax;

        uLen = (UINT)lstrlenW(lpSrch);
        wMatch = *lpSrch;

        // the first two conditions in this loop signify failure when they eval to false,
        // while the third condition signifies success. We need to special case the second
        // condition at the end of the function because it doesn't automatically cause the
        // right value to be returned
        while((lpFirst=StrChrNW(lpFirst, wMatch, cchMax))!=0 && cchMax>=uLen &&StrCmpNW(lpFirst, lpSrch, uLen))
        {
            lpFirst++;
            cchMax=(UINT)(lpSentinel-lpFirst);
        }/* continue until we hit the end of the string or get a match */

        if(cchMax<uLen)
            return NULL;// we ran out of space
        return (LPWSTR)lpFirst;
    }
    return NULL;
}

/*
 * StrStrI   - Search for first occurrence of a substring, case insensitive
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRA(lpFirst, -1), "StrStrIA: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRA(lpSrch, -1), "StrStrIA: Caller passed bad lpSrch");
    if (lpFirst && lpSrch)
    {
        UINT uLen = (UINT)lstrlenA(lpSrch);
        WORD wMatch = READNATIVEWORD(lpSrch);

        for ( ; (lpFirst = StrChrIA(lpFirst, wMatch)) != 0 && StrCmpNIA(lpFirst, lpSrch, uLen);
             lpFirst=AnsiNext(lpFirst))
            continue; /* continue until we hit the end of the string or get a match */

        return (LPSTR)lpFirst;
    }
    return NULL;
}

LPWSTR StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRW(lpFirst, -1), "StrStrIW: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, -1), "StrStrIW: Caller passed bad lpSrch");
    if (lpFirst && lpSrch)
    {
        UINT uLen = (UINT)lstrlenW(lpSrch);
        WCHAR wMatch = *lpSrch;

        for ( ; (lpFirst = StrChrIW(lpFirst, wMatch)) != 0 && StrCmpNIW(lpFirst, lpSrch, uLen);
             lpFirst++)
            continue; /* continue until we hit the end of the string or get a match */

        return (LPWSTR)lpFirst;
    }
    return NULL;
}

/*
 * StrStrNI   - Search for first occurrence of a substring, case insensitive, counted
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */

LPWSTR StrStrNIW(LPCWSTR lpFirst, LPCWSTR lpSrch, UINT cchMax)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRW(lpFirst, cchMax), "StrStrNIW: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, cchMax), "StrStrNIW: Caller passed bad lpSrch");
    if (lpFirst && lpSrch)
    {
        UINT uLen = (UINT)lstrlenW(lpSrch);
        WCHAR wMatch = *lpSrch;
        LPCWSTR lpSentinel = lpFirst+cchMax;

        // the first two conditions in this loop signify failure when they eval to false,
        // while the third condition signifies success. We need to special case the second
        // condition at the end of the function because it doesn't automatically cause the
        // right value to be returned
        while((lpFirst = StrChrNIW(lpFirst, wMatch, cchMax)) != 0 && cchMax >= uLen && StrCmpNIW(lpFirst, lpSrch, uLen))
        {
            lpFirst++;
            cchMax = (UINT)(lpSentinel - lpFirst);
        }/* continue until we hit the end of the string or get a match */

        if(cchMax<uLen)
            return NULL;// we ran out of space
        return (LPWSTR)lpFirst;
    }
    return NULL;
}


LPSTR StrDupA(LPCSTR psz)
{
    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "StrDupA: Caller passed invalid psz");
    if (psz)
    {
        LPSTR pszRet = (LPSTR)LocalAlloc(LPTR, (lstrlenA(psz) + 1) * sizeof(*pszRet));
        if (pszRet) 
        {
            lstrcpyA(pszRet, psz);
        }
        return pszRet;
    }
    return NULL;
}

LPWSTR StrDupW(LPCWSTR psz)
{
    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "StrDupW: Caller passed invalid psz");
    if (psz)
    {
        LPWSTR pszRet = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(psz) + 1) * sizeof(*pszRet));
        if (pszRet) 
        {
            StrCpyW(pszRet, psz);
        }
        return pszRet;
    }
    return NULL;
}

void _StrOut(LPSTR* ppszBuf, HMODULE hmod, UINT idRes, DWORD* pdwTimeS, int* pdigits, UINT iDiv)
{
    if (*pdigits)
    {
        DWORD dwCur = *pdwTimeS/iDiv;

        if (dwCur || iDiv==1) 
        {
            DWORD dwBase;
            CHAR szBuf[64], szTemplate[64];
            LPSTR pszBuf = szBuf;

            *pdwTimeS -= dwCur*iDiv;
            for (dwBase=1; dwCur/(dwBase*10); dwBase*=10);

            DebugMsg(DM_INTERVAL, TEXT("dwCur, dwBase, *pdwTimeS = %d, %d, %d"), dwCur, dwBase, *pdwTimeS);

            //
            // LATER: We could use atoi if we mathematically trancate
            //  the numbers based on digits.
            //
            for (;dwBase; dwBase/=10, pszBuf++) 
            {
                if (*pdigits) 
                {
                    DWORD i = dwCur/dwBase;
                    dwCur -= i*dwBase;
                    *pszBuf = '0'+(unsigned short)i;
                    (*pdigits)--;
                } 
                else 
                {
                    *pszBuf = '0';
                }
            }
            *pszBuf = '\0';

            MLLoadStringA(idRes, szTemplate, ARRAYSIZE(szTemplate));
            wsprintfA(*ppszBuf, szTemplate, szBuf);
            (*ppszBuf) += lstrlenA(*ppszBuf);
        }
    }
}

void _StrOutW(LPWSTR* ppwszBuf, HMODULE hmod, UINT idRes, DWORD* pdwTimeS, int* pdigits, UINT iDiv)
{
    if (*pdigits)
    {
        DWORD dwCur = *pdwTimeS/iDiv;

        if (dwCur || iDiv==1) 
        {
            DWORD dwBase;
            WCHAR wszBuf[64], wszTemplate[64];
            LPWSTR pwszBuf = wszBuf;

            *pdwTimeS -= dwCur*iDiv;
            for (dwBase=1; dwCur/(dwBase*10); dwBase*=10);

            DebugMsg(DM_INTERVAL, TEXT("dwCur, dwBase, *pdwTimeS = %d, %d, %d"), dwCur, dwBase, *pdwTimeS);

            //
            // LATER: We could use atoi if we mathematically trancate
            //  the numbers based on digits.
            //
            for (;dwBase; dwBase/=10, pwszBuf++) 
            {
                if (*pdigits) 
                {
                    DWORD i = dwCur/dwBase;
                    dwCur -= i*dwBase;
                    *pwszBuf = L'0'+(unsigned short)i;
                    (*pdigits)--;
                } 
                else 
                {
                    *pwszBuf = L'0';
                }
            }
            *pwszBuf = L'\0';

            MLLoadStringW(idRes, wszTemplate, ARRAYSIZE(wszTemplate));
            // NOTE: 256 comes from the work buffer in StrFromTimeIntervalA/W
            wnsprintfW(*ppwszBuf, 256, wszTemplate, wszBuf);
            (*ppwszBuf) += lstrlenW(*ppwszBuf);
        }
    }
}


BOOL _StrFromTimeInterval(LPSTR szBuf, DWORD dwTimeMS, int digits)
{
    DWORD dwTimeS = (dwTimeMS+500)/1000;
    LPSTR pszBuf = szBuf;
    DebugMsg(DM_INTERVAL, TEXT("dwTimeS = %d"), dwTimeS);

    szBuf = '\0';

    _StrOut(&pszBuf, g_hinst, IDS_HOUR, &dwTimeS, &digits, 3600);
    _StrOut(&pszBuf, g_hinst, IDS_MIN, &dwTimeS, &digits, 60);
    _StrOut(&pszBuf, g_hinst, IDS_SEC, &dwTimeS, &digits, 1);

    return TRUE;
}

BOOL _StrFromTimeIntervalW(LPWSTR wszBuf, DWORD dwTimeMS, int digits)
{
    DWORD dwTimeS = (dwTimeMS+500)/1000;
    LPWSTR pwszBuf = wszBuf;
    DebugMsg(DM_INTERVAL, TEXT("dwTimeS = %d"), dwTimeS);

    wszBuf = '\0';

    _StrOutW(&pwszBuf, g_hinst, IDS_HOUR, &dwTimeS, &digits, 3600);
    _StrOutW(&pwszBuf, g_hinst, IDS_MIN, &dwTimeS, &digits, 60);
    _StrOutW(&pwszBuf, g_hinst, IDS_SEC, &dwTimeS, &digits, 1);

    return TRUE;
}


//
//  This API converts a given time-interval (in msec) into a human readable
// string.
//
// Parameters:
//  pszOut   -- Specifies the string buffer. NULL is valid to query size.
//  cchMax   -- Specifies the size of buffer in char/WCHAR
//  dwTimeMS -- Specifies the time interval in msec
//  digits   -- Specifies the minimum number of digits to be displayed
//
// Returns:
//  Number of characters in the buffer (not including the terminator).
//
// Exmaples:
//  dwTimeMS digits     output
//   34000     3         34 sec
//   34000     2         34 sec
//   34000     1         30 sec
//   74000     3         1 min 14 sec
//   74000     2         1 min 10 sec
//   74000     1         1 min
//
int StrFromTimeIntervalA(LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits)
{
    CHAR szBuf[256];
    int cchRet = 0;
    RIPMSG(!pszOut || IS_VALID_WRITE_BUFFER(pszOut, char, cchMax), "StrFromTimeIntervalA: Caller passed invalid pszOut");
    DEBUGWhackPathBufferA(pszOut, cchMax);
    if (_StrFromTimeInterval(szBuf, dwTimeMS, digits)) 
    {
        if (pszOut) 
        {
            lstrcpynA(pszOut, szBuf, cchMax);
            cchRet = lstrlenA(pszOut);
        }
        else 
        {
            cchRet = lstrlenA(szBuf);
        }
    }
    return cchRet;
}

int StrFromTimeIntervalW(LPWSTR pwszOut, UINT cchMax, DWORD dwTimeMS, int digits)
{
    WCHAR wszBuf[256];
    int cchRet = 0;
    RIPMSG(!pwszOut || IS_VALID_WRITE_BUFFER(pwszOut, WCHAR, cchMax), "StrFromTimeIntervalW: Caller passed invalid pszOut");
    DEBUGWhackPathBufferW(pwszOut, cchMax);
    if (_StrFromTimeIntervalW(wszBuf, dwTimeMS, digits)) 
    {
        if (pwszOut) 
        {
            lstrcpynW(pwszOut, wszBuf, cchMax);
            cchRet = lstrlenW(pwszOut);
        }
        else 
        {
            cchRet = lstrlenW(wszBuf);
        }
    }
    return cchRet;
}

/*
 * IntlStrEq
 *
 * returns TRUE if strings are equal, FALSE if not
 */
BOOL StrIsIntlEqualA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) 
{
    DWORD dwFlags = fCaseSens ? LOCALE_USE_CP_ACP : (NORM_IGNORECASE | LOCALE_USE_CP_ACP);

    RIPMSG(lpString1 && IS_VALID_STRING_PTRA(lpString1, nChar), "StrIsIntlEqualA: Caller passed invalid lpString1");
    RIPMSG(lpString2 && IS_VALID_STRING_PTRA(lpString2, nChar), "StrIsIntlEqualA: Caller passed invalid lpString2");
    RIPMSG(nChar >= -1, "StrIsIntlEqualA: Caller passed invalid nChar");

    if (g_bRunningOnNT)
    {
        dwFlags |= NORM_STOP_ON_NULL;   // only supported on NT
    }
    else if (nChar != -1 && lpString1 && lpString2)
    {
        // On Win9x we have to do the check manually
        //
        int cch = 0;
        LPCSTR psz1 = lpString1;
        LPCSTR psz2 = lpString2;

        while(*psz1 != 0 && *psz2 != 0 && cch < nChar) 
        {
            psz1 = CharNextA(psz1);
            psz2 = CharNextA(psz2);
            cch = (int) min(psz1 - lpString1, psz2 - lpString2);
        }

        // add one in for terminating '\0'
        cch++;
        if (cch < nChar)
            nChar = cch;
    }
    return 0 == _StrCmpLocaleA(dwFlags, lpString1, nChar, lpString2, nChar);
}

BOOL StrIsIntlEqualW(BOOL fCaseSens, LPCWSTR psz1, LPCWSTR psz2, int nChar) 
{
    RIPMSG(psz1 && IS_VALID_STRING_PTRW(psz1, nChar), "StrIsIntlEqualW: Caller passed invalid psz1");
    RIPMSG(psz2 && IS_VALID_STRING_PTRW(psz2, nChar), "StrIsIntlEqualW: Caller passed invalid psz2");
    RIPMSG(nChar >= -1, "StrIsIntlEqualW: Caller passed invalid nChar");

    return 0 == _StrCmpLocaleW(fCaseSens ? NORM_STOP_ON_NULL : NORM_IGNORECASE | NORM_STOP_ON_NULL, 
        psz1, nChar, psz2, nChar);
}

// This is stolen from shell32 - util.c

#define LODWORD(_qw)    (DWORD)(_qw)

const short c_aOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

void Int64ToStr(LONGLONG n, LPWSTR lpBuffer)
{
    WCHAR szTemp[40];
    LONGLONG  iChr;

    iChr = 0;

    do {
        szTemp[iChr++] = L'0' + (WCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = L'\0';
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
//  Bonus treat - Win9x doesn't support complex number formats,
//  so we return only the first number.
//
UINT GetNLSGrouping(void)
{
    UINT grouping;
    LPWSTR psz;
    WCHAR szGrouping[32];

    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYSIZE(szGrouping)))
        return 3;

    grouping = 0;
    psz = szGrouping;
    if (g_bRunningOnNT)
    {
        for (;;)
        {
            if (*psz == L'0') break;             // zero - stop

            else if ((UINT)(*psz - L'0') < 10)   // digit - accumulate it
                grouping = grouping * 10 + (UINT)(*psz - L'0');

            else if (*psz)                      // punctuation - ignore it
                { }

            else                                // end of string, no "0" found
            {
                grouping = grouping * 10;       // put zero on end (see examples)
                break;                          // and finished
            }

            psz++;
        }
    }
    else
    {
        // Win9x - take only the first grouping
        grouping = StrToIntW(szGrouping);
    }
    return grouping;
}

// Sizes of various stringized numbers
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)

// takes a DWORD add commas etc to it and puts the result in the buffer
LPWSTR CommifyString(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    WCHAR szNum[MAX_COMMA_NUMBER_SIZE], szSep[5];
    NUMBERFMTW nfmt;

    nfmt.NumDigits = 0;
    nfmt.LeadingZero = 0;
    nfmt.Grouping = GetNLSGrouping();
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder = 0;

    Int64ToStr(n, szNum);

    if (GetNumberFormatW(LOCALE_USER_DEFAULT, 0, szNum, &nfmt, pszBuf, cchBuf) == 0)
        StrCpyNW(pszBuf, szNum, cchBuf);

    return pszBuf;
}

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */

LPWSTR StrFormatByteSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    RIPMSG(pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, WCHAR, cchBuf), "StrFormatByteSizeW: Caller passed invalid pszBuf");
    DEBUGWhackPathBufferW(pszBuf, cchBuf);
    if (pszBuf)
    {
        WCHAR szWholeNum[32], szOrder[32];
        int iOrder;

        // If the size is less than 1024, then the order should be bytes we have nothing
        // more to figure out
        if (n < 1024) 
        {
            wnsprintfW(szWholeNum, ARRAYSIZE(szWholeNum), L"%d", LODWORD(n));
            iOrder = 0;
        }
        else
        {
            UINT uInt, uLen, uDec;
            WCHAR szFormat[8];

            // Find the right order
            for (iOrder = 1; iOrder < ARRAYSIZE(c_aOrders) -1 && n >= 1000L * 1024L; n >>= 10, iOrder++);
                /* do nothing */

            uInt = LODWORD(n >> 10);
            CommifyString(uInt, szWholeNum, ARRAYSIZE(szWholeNum));
            uLen = lstrlenW(szWholeNum);
            if (uLen < 3)
            {
                uDec = LODWORD(n - (LONGLONG)uInt * 1024L) * 1000 / 1024;
                // At this point, uDec should be between 0 and 1000
                // we want get the top one (or two) digits.
                uDec /= 10;
                if (uLen == 2)
                    uDec /= 10;

                // Note that we need to set the format before getting the
                // intl char.
                StrCpyW(szFormat, L"%02d");

                szFormat[2] = TEXT('0') + 3 - uLen;
                GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                               szWholeNum + uLen, ARRAYSIZE(szWholeNum) - uLen);
                uLen = lstrlenW(szWholeNum);
                wnsprintfW(szWholeNum + uLen, ARRAYSIZE(szWholeNum) - uLen, szFormat, uDec);
            }
        }

        MLLoadStringW(c_aOrders[iOrder], szOrder, ARRAYSIZE(szOrder));
        wnsprintfW(pszBuf, cchBuf, szOrder, szWholeNum);
    }
    return pszBuf;
}

// dw - the nubmer to be converted
// pszBuf - buffer for the resulting string
// cchBuf - Max characters in Buffer

LPSTR StrFormatByteSize64A(LONGLONG dw, LPSTR pszBuf, UINT cchBuf)
{
    WCHAR szT[32];

    DEBUGWhackPathBuffer(pszBuf, cchBuf);

    StrFormatByteSizeW(dw, szT, SIZECHARS(szT));

    SHUnicodeToAnsi(szT, pszBuf, cchBuf);
    return pszBuf;
}

LPSTR StrFormatByteSizeA(DWORD dw, LPSTR pszBuf, UINT cchBuf)
{
    return StrFormatByteSize64A((LONGLONG)dw, pszBuf, cchBuf);
}

LPWSTR StrFormatKBSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    RIPMSG(pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, WCHAR, cchBuf), "StrFormatKBSizeW: Caller passed invalid pszBuf");
    DEBUGWhackPathBufferW(pszBuf, cchBuf);
    if (pszBuf)
    {
        static WCHAR s_szOrder[16] = {0};
        WCHAR szNum[64];

        if (s_szOrder[0] == TEXT('\0'))
            LoadStringW(HINST_THISDLL, IDS_ORDERKB, s_szOrder, ARRAYSIZE(s_szOrder));

        CommifyString((n + 1023) / 1024, szNum, ARRAYSIZE(szNum));

        wnsprintfW(pszBuf, cchBuf, s_szOrder, szNum);
    }
    return pszBuf;
}

LPSTR StrFormatKBSizeA(LONGLONG n, LPSTR pszBuf, UINT cchBuf)
{
    WCHAR szNum[64];

    DEBUGWhackPathBufferA(pszBuf, cchBuf);

    StrFormatKBSizeW(n, szNum, ARRAYSIZE(szNum));

    SHUnicodeToAnsi(szNum, pszBuf, cchBuf);
    return pszBuf;
}

//  Win95 does not support the wide-char version of lstrcmp, lstrcmpi
//  Wrapper for lstrcmpW so it works on Win95

int StrCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    RIPMSG(pwsz1 && IS_VALID_STRING_PTRW(pwsz1, -1), "StrCmpW: Caller passed invalid pwsz1");
    RIPMSG(pwsz2 && IS_VALID_STRING_PTRW(pwsz2, -1), "StrCmpW: Caller passed invalid pwsz2");

    return _StrCmpLocaleW(0, pwsz1, -1, pwsz2, -1);
}

// Wrapper for lstrcmpiW so it works on Win95

int StrCmpIW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    RIPMSG(pwsz1 && IS_VALID_STRING_PTRW(pwsz1, -1), "StrCmpIW: Caller passed invalid pwsz1");
    RIPMSG(pwsz2 && IS_VALID_STRING_PTRW(pwsz2, -1), "StrCmpIW: Caller passed invalid pwsz2");

    return _StrCmpLocaleW(NORM_IGNORECASE, pwsz1, -1, pwsz2, -1);
}


/*----------------------------------------------------------
Purpose: Trim the string pszTrimMe of any leading or trailing
         characters that are in pszTrimChars.

Returns: TRUE if anything was stripped

*/
STDAPI_(BOOL) StrTrimA(IN OUT LPSTR pszTrimMe, LPCSTR pszTrimChars)
{
    BOOL bRet = FALSE;

    RIPMSG(pszTrimMe && IS_VALID_STRING_PTRA(pszTrimMe, -1), "StrTrimA: Caller passed invalid pszTrimMe");
    RIPMSG(pszTrimChars && IS_VALID_STRING_PTRA(pszTrimChars, -1), "StrTrimA: Caller passed invalid pszTrimChars");
    if (pszTrimMe && pszTrimChars)
    {
        LPSTR psz;
        LPSTR pszStartMeat;
        LPSTR pszMark = NULL;
    
        /* Trim leading characters. */
        
        psz = pszTrimMe;
        
        while (*psz && StrChrA(pszTrimChars, READNATIVEWORD(psz)))
            psz = CharNextA(psz);
        
        pszStartMeat = psz;
        
        /* Trim trailing characters. */
        
        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)
        
        while (*psz)
        {
            if (StrChrA(pszTrimChars, READNATIVEWORD(psz)))
            {
                if (!pszMark)
                {
                    pszMark = psz;
                }
            }
            else
            {
                pszMark = NULL;
            }
            psz = CharNextA(psz);
        }
        
        // Any trailing characters to clip?
        if (pszMark)
        {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
        }
        
        /* Relocate stripped string. */
        
        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchA(lstrlenA(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);
        
        ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    }
    
    return bRet;
}


/*----------------------------------------------------------
Purpose: Trim the string pszTrimMe of any leading or trailing
         characters that are in pszTrimChars.

Returns: TRUE if anything was stripped

*/
STDAPI_(BOOL) StrTrimW(IN OUT LPWSTR  pszTrimMe, LPCWSTR pszTrimChars)
{
    BOOL bRet = FALSE;

    RIPMSG(pszTrimMe && IS_VALID_STRING_PTRW(pszTrimMe, -1), "StrTrimW: Caller passed invalid pszTrimMe");
    RIPMSG(pszTrimChars && IS_VALID_STRING_PTRW(pszTrimChars, -1), "StrTrimW: Caller passed invalid pszTrimChars");
    if (pszTrimMe && pszTrimChars)
    {
        LPWSTR psz;
        LPWSTR pszStartMeat;
        LPWSTR pszMark = NULL;
    
        /* Trim leading characters. */
        
        psz = pszTrimMe;
        
        while (*psz && StrChrW(pszTrimChars, *psz))
            psz++;
        
        pszStartMeat = psz;
        
        /* Trim trailing characters. */
        
        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)
        
        while (*psz)
        {
            if (StrChrW(pszTrimChars, *psz))
            {
                if (!pszMark)
                {
                    pszMark = psz;
                }
            }
            else
            {
                pszMark = NULL;
            }
            psz++;
        }
        
        // Any trailing characters to clip?
        if (pszMark)
        {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
        }
        
        /* Relocate stripped string. */
        
        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchW(lstrlenW(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);
        
        ASSERT(IS_VALID_STRING_PTRW(pszTrimMe, -1));
    }
    
    return bRet;
}


/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2
*/
LWSTDAPI_(int) StrCmpNCA(LPCSTR pch1, LPCSTR pch2, int n)
{
    if (n == 0)
        return 0;

    while (--n && *pch1 && *pch1 == *pch2)
    {
        pch1++;
        pch2++;
    }

    return *(unsigned char *)pch1 - *(unsigned char *)pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNCW(LPCWSTR pch1, LPCWSTR pch2, int n)
{
    if (n == 0)
        return 0;

    while (--n && *pch1 && *pch1 == *pch2)
    {
        pch1++;
        pch2++;
    }

    return *pch1 - *pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNICA(LPCSTR pch1, LPCSTR pch2, int n)
{
    int ch1, ch2;

    if (n != 0)
    {
        do {

            ch1 = *pch1++;
            if (ch1 >= 'A' && ch1 <= 'Z')
                ch1 += 'a' - 'A';

            ch2 = *pch2++;
            if (ch2 >= 'A' && ch2 <= 'Z')
                ch2 += 'a' - 'A';

        } while ( --n && ch1 && (ch1 == ch2) );

        return ch1 - ch2;
    }
    else
    {
        return 0;
    }
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNICW(LPCWSTR pch1, LPCWSTR pch2, int n)
{
    int ch1, ch2;

    if (n != 0)
    {

        do {

            ch1 = *pch1++;
            if (ch1 >= L'A' && ch1 <= L'Z')
                ch1 += L'a' - L'A';

            ch2 = *pch2++;
            if (ch2 >= L'A' && ch2 <= L'Z')
                ch2 += L'a' - L'A';

        } while ( --n && ch1 && (ch1 == ch2) );

        return ch1 - ch2;
    }
    else
    {
        return 0;
    }
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpCA(LPCSTR pch1, LPCSTR pch2)
{
    while (*pch1 && (*pch1 == *pch2))
    {
        ++pch1;
        ++pch2;
    }   

    return *(unsigned char *)pch1 - *(unsigned char *)pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpCW(LPCWSTR pch1, LPCWSTR pch2)
{
    while (*pch1 && (*pch1 == *pch2))
    {
        ++pch1;
        ++pch2;
    }   

    return *pch1 - *pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpICA(LPCSTR pch1, LPCSTR pch2)
{
    int ch1, ch2;

    do {

        ch1 = *pch1++;
        if (ch1 >= 'A' && ch1 <= 'Z')
            ch1 += 'a' - 'A';

        ch2 = *pch2++;
        if (ch2 >= 'A' && ch2 <= 'Z')
            ch2 += 'a' - 'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpICW(LPCWSTR pch1, LPCWSTR pch2)
{
    int ch1, ch2;

    do {

        ch1 = *pch1++;
        if (ch1 >= L'A' && ch1 <= L'Z')
            ch1 += L'a' - L'A';

        ch2 = *pch2++;
        if (ch2 >= L'A' && ch2 <= L'Z')
            ch2 += L'a' - L'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}

LWSTDAPI StrRetToStrW(STRRET *psr, LPCITEMIDLIST pidl, WCHAR **ppsz)
{
    HRESULT hres = S_OK;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        *ppsz = psr->pOleStr;
        psr->pOleStr = NULL;   // avoid alias
        hres = *ppsz ? S_OK : E_FAIL;
        break;

    case STRRET_OFFSET:
        hres = SHStrDupA(STRRET_OFFPTR(pidl, psr), ppsz);
        break;

    case STRRET_CSTR:
        hres = SHStrDupA(psr->cStr, ppsz);
        break;

    default:
        *ppsz = NULL;
        hres = E_FAIL;
    }
    return hres;
}

LWSTDAPI StrRetToBSTR(STRRET *psr, LPCITEMIDLIST pidl, BSTR *pbstr)
{
    switch (psr->uType)
    {
    case STRRET_WSTR:
    {
        LPWSTR psz = psr->pOleStr;
        psr->pOleStr = NULL;  // avoid alias
        *pbstr = SysAllocString(psz);
        CoTaskMemFree(psz);
        break;
    }
    case STRRET_OFFSET:
        *pbstr = SysAllocStringA(STRRET_OFFPTR(pidl, psr));
        break;

    case STRRET_CSTR:
        *pbstr = SysAllocStringA(psr->cStr);
        break;

    default:
        *pbstr = NULL;
        return E_FAIL;
    }

    return (*pbstr) ? S_OK : E_OUTOFMEMORY;

}


HRESULT DupWideToAnsi(LPCWSTR pwsz, LPSTR *ppsz)
{
    UINT cch = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL) + 1;
    *ppsz = CoTaskMemAlloc(cch * sizeof(**ppsz));
    if (*ppsz)
    {
        SHUnicodeToAnsi(pwsz, *ppsz, cch);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT DupAnsiToAnsi(LPCSTR psz, LPSTR *ppsz)
{
    *ppsz = (LPSTR)CoTaskMemAlloc((lstrlenA(psz) + 1) * sizeof(**ppsz));
    if (*ppsz) 
    {
        lstrcpyA(*ppsz, psz);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

LWSTDAPI StrRetToStrA(STRRET *psr, LPCITEMIDLIST pidl, CHAR **ppsz)
{
    HRESULT hres;
    LPWSTR pwsz;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        hres = DupWideToAnsi(psr->pOleStr, ppsz);
        pwsz = psr->pOleStr;
        psr->pOleStr = NULL;   // avoid alias
        CoTaskMemFree(pwsz);
        break;

    case STRRET_OFFSET:
        hres = DupAnsiToAnsi(STRRET_OFFPTR(pidl, psr), ppsz);
        break;

    case STRRET_CSTR:
        hres = DupAnsiToAnsi(psr->cStr, ppsz);
        break;

    default:
        *ppsz = NULL;
        hres = E_FAIL;
    }
    return hres;
}

STDAPI StrRetToBufA(STRRET *psr, LPCITEMIDLIST pidl, LPSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pszStr = psr->pOleStr;   // temp copy because SHUnicodeToAnsi may overwrite buffer
            if (pszStr)
            {
                SHUnicodeToAnsi(pszStr, pszBuf, cchBuf);
                CoTaskMemFree(pszStr);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;   
                psr->cStr[0] = 0;
                
                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        SHAnsiToAnsi(psr->cStr, pszBuf, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            SHAnsiToAnsi(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

STDAPI StrRetToBufW(STRRET *psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;
    
    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pwszTmp = psr->pOleStr;
            if (pwszTmp)
            {
                StrCpyNW(pszBuf, pwszTmp, cchBuf);
                CoTaskMemFree(pwszTmp);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;   
                psr->cStr[0] = 0;
                
                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        SHAnsiToUnicode(psr->cStr, pszBuf, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            SHAnsiToUnicode(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

// dupe a string using the task allocator for returing from a COM interface
//
STDAPI SHStrDupA(LPCSTR psz, WCHAR **ppwsz)
{
    WCHAR *pwsz;
    DWORD cch;

    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "SHStrDupA: Caller passed invalid psz");

    if (psz)
    {
        cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
        pwsz = (WCHAR *)CoTaskMemAlloc((cch + 1) * SIZEOF(WCHAR));
    }
    else
        pwsz = NULL;

    *((PVOID UNALIGNED64 *) ppwsz) = pwsz;

    if (pwsz)
    {
        MultiByteToWideChar(CP_ACP, 0, psz, -1, *ppwsz, cch);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

// dupe a string using the task allocator for returing from a COM interface
// Sometimes, due to structure packing, the pointer we get is not properly
// aligned for Win64, so we have to do UNALIGNED64.
//
STDAPI SHStrDupW(LPCWSTR psz, WCHAR **ppwsz)
{
    WCHAR *pwsz;
    int cb;

    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "SHStrDupW: Caller passed invalid psz");

    if (psz)
    {
        cb = (lstrlenW(psz) + 1) * SIZEOF(WCHAR);
        pwsz = (WCHAR *)CoTaskMemAlloc(cb);
    }
    else
        pwsz = NULL;
    
    *((PVOID UNALIGNED64 *) ppwsz) = pwsz;

    if (pwsz)
    {
        CopyMemory(pwsz, psz, cb);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

 
STDAPI_(int) StrCmpLogicalW(PCWSTR psz1, PCWSTR psz2)
{
    int iRet = 0;
    int iCmpNum = 0;
    while (iRet == 0 && (*psz1 || *psz2))
    {
        int cch1 = 0;
        int cch2 = 0;
        BOOL fIsDigit1 = IS_DIGITW(*psz1);
        BOOL fIsDigit2 = IS_DIGITW(*psz2);
        ASSERT(fIsDigit1 == TRUE || fIsDigit1 == FALSE);
        ASSERT(fIsDigit2 == TRUE || fIsDigit2 == FALSE);
        //  using bit wise XOR as logical XOR
        //  if the numbers are mismatched then n
        if (fIsDigit1 ^ fIsDigit2)
        {
            iRet = _StrCmpLocaleW(NORM_IGNORECASE, psz1, -1, psz2, -1);
        }
        else if (fIsDigit1 && fIsDigit2)
        {
            int cchZero1 = 0;
            int cchZero2 = 0;

            // eat leading zeros
            while (*psz1 == TEXT('0'))
            {
                psz1++;
                cchZero1++;
            }

            while (*psz2 == TEXT('0'))
            {
                psz2++;
                cchZero2++;
            }
            
            while (IS_DIGITW(psz1[cch1])) 
                cch1++;

            while (IS_DIGITW(psz2[cch2])) 
                cch2++;

            if (cch1 != cch2)
            {
                iRet = cch1 > cch2 ? 1 : -1;
            }
            else 
            {
                //  remember the first numerical difference
                iRet = _StrCmpLocaleW(NORM_IGNORECASE, psz1, cch1, psz2, cch2);
                if (iRet == 0 && iCmpNum == 0 && cchZero1 != cchZero2)
                {
                    iCmpNum = cchZero2 > cchZero1 ? 1 : -1;
                }
            }
        }
        else
        {
            while (psz1[cch1] && !IS_DIGITW(psz1[cch1]))
                cch1++;

            while (psz2[cch2] && !IS_DIGITW(psz2[cch2]))
                cch2++;

            iRet = _StrCmpLocaleW(NORM_IGNORECASE, psz1, cch1, psz2, cch2);

        }

        //  at this point they should be numbers or terminators or different
        psz1 = &psz1[cch1];
        psz2 = &psz2[cch2];
    }

    if (iRet == 0 && iCmpNum)
        iRet = iCmpNum;
    
    return iRet;
}

STDAPI_(DWORD) StrCatChainW(LPWSTR pszDst, DWORD cchDst, DWORD ichAt, LPCWSTR pszSrc)
{
    RIPMSG(pszDst && IS_VALID_STRING_PTRW(pszDst, -1) && (DWORD)lstrlenW(pszDst)<cchDst && IS_VALID_WRITE_BUFFER(pszDst, WCHAR, cchDst), "StrCatChainW: Caller passed invalid pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCatChainW: Caller passed invalid pszSrc");
    
    if (ichAt == -1)
        ichAt = lstrlenW(pszDst);

    if (cchDst > 0)
    {
#ifdef DEBUG
        if (ichAt < cchDst)
            DEBUGWhackPathBufferW(pszDst+ichAt, cchDst-ichAt);
#endif
        while (ichAt < cchDst)
        {
            if (!(pszDst[ichAt] = *pszSrc++))
                break;
                
           ichAt++;
        }

        //  check to make sure we copied a NULL
        if (ichAt == cchDst)
            pszDst[ichAt-1] = 0;
    }

    return ichAt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\thunk.h ===
#define RegSetValueExW      RegSetValueExWrapW
#define CompareStringW      CompareStringWrapW
#define GetFileAttributesW  GetFileAttributesWrapW
#define GetFullPathNameW    GetFullPathNameWrapW
#define SearchPathW         SearchPathWrapW
#define GetWindowsDirectoryW    GetWindowsDirectoryWrapW
#define GetSystemDirectoryW     GetSystemDirectoryWrapW
#define GetEnvironmentVariableW GetEnvironmentVariableWrapW


//+---------------------------------------------------------------------------
//
// NEEDs
//
//  All functions in unicwrap must be bracketed in NEED_<DLLNAME>_WRAPPER
//  to ensure that wrappers are generated only on platforms that require them.
//
//----------------------------------------------------------------------------

#if defined(_X86_)  // X86 platform - use full wrappers
#define NEED_KERNEL32_WRAPPER
#define NEED_USER32_WRAPPER
#define NEED_GDI32_WRAPPER
#define NEED_ADVAPI32_WRAPPER
#define NEED_WINMM_WRAPPER
#define NEED_MPR_WRAPPER
#define NEED_VERSION_WRAPPER
#define NEED_SHELL32_WRAPPER
#define NEED_COMDLG32_WRAPPER
#else                                   // other platform - don't need wrappers
#undef NEED_KERNEL32_WRAPPER
#undef NEED_USER32_WRAPPER
#undef NEED_GDI32_WRAPPER
#undef NEED_ADVAPI32_WRAPPER
#undef NEED_WINMM_WRAPPER
#undef NEED_MPR_WRAPPER
#undef NEED_VERSION_WRAPPER
#undef NEED_SHELL32_WRAPPER
#undef NEED_COMDLG32_WRAPPER
#endif

#define NEED_OLE32_WRAPPER

//+---------------------------------------------------------------------------
//
// Unwrapping
//
//  Based on what we NEED, we disable selected wrappers so we can still
//  build other parts of shlwapi in the unwrapped case.
//
//----------------------------------------------------------------------------

// These wrappers are to be always unwrapped.
//#define GetLongPathNameWrapW GetLongPathNameW
//#define GetLongPathNameWrapA GetLongPathNameA

#ifndef NEED_KERNEL32_WRAPPER
#define CreateDirectoryWrapW CreateDirectoryW
#define CreateEventWrapW CreateEventW
#define CreateFileWrapW CreateFileW
#define DeleteFileWrapW DeleteFileW
#define EnumResourceNamesWrapW EnumResourceNamesW
#define FindFirstFileWrapW FindFirstFileW
#define FindResourceWrapW FindResourceW
#define FormatMessageWrapW FormatMessageW
#define GetCurrentDirectoryWrapW GetCurrentDirectoryW
#undef  GetFileAttributesW
#define GetFileAttributesWrapW GetFileAttributesW
#define GetLocaleInfoWrapW GetLocaleInfoW
#define GetModuleFileNameWrapW GetModuleFileNameW
#undef  SearchPathW
#define SearchPathWrapW SearchPathW
#define GetModuleHandleWrapW GetModuleHandleW
#define SetFileAttributesWrapW SetFileAttributesW
#define GetNumberFormatWrapW GetNumberFormatW
#define FindNextFileWrapW FindNextFileW
#undef  GetFullPathNameW
#define GetFullPathNameWrapW GetFullPathNameW
#define GetShortPathNameWrapW GetShortPathNameW
#define GetStringTypeExWrapW GetStringTypeExW
#define GetPrivateProfileIntWrapW GetPrivateProfileIntW
#define GetProfileStringWrapW GetProfileStringW
#define GetTempFileNameWrapW GetTempFileNameW
#define GetTempPathWrapW GetTempPathW
#undef  GetWindowsDirectoryW
#define GetWindowsDirectoryWrapW GetWindowsDirectoryW
#undef  GetSystemDirectoryW
#define GetSystemDirectoryWrapW GetSystemDirectoryW     
#undef  GetEnvironmentVariableW
#define GetEnvironmentVariableWrapW GetEnvironmentVariableW 
#define LoadLibraryExWrapW LoadLibraryExW
#undef  CompareStringW
#define CompareStringWrapW CompareStringW
#define CopyFileWrapW CopyFileW
#define MoveFileWrapW MoveFileW
#define OpenEventWrapW OpenEventW
#define OutputDebugStringWrapW OutputDebugStringW
#define RemoveDirectoryWrapW RemoveDirectoryW
#define SetCurrentDirectoryWrapW SetCurrentDirectoryW
#define CreateMutexWrapW CreateMutexW
#define ExpandEnvironmentStringsWrapW ExpandEnvironmentStringsW
#define CreateSemaphoreWrapW CreateSemaphoreW
#define IsBadStringPtrWrapW IsBadStringPtrW
#define LoadLibraryWrapW LoadLibraryW
#define GetTimeFormatWrapW GetTimeFormatW
#define GetDateFormatWrapW GetDateFormatW
#define WritePrivateProfileStringWrapW WritePrivateProfileStringW
#define GetPrivateProfileStringWrapW GetPrivateProfileStringW
#define WritePrivateProfileStructWrapW WritePrivateProfileStructW
#define GetPrivateProfileStructWrapW GetPrivateProfileStructW
#define CreateProcessWrapW CreateProcessW
#define GlobalAddAtomWrapW GlobalAddAtomW
#define GlobalFindAtomWrapW GlobalFindAtomW
#endif


#ifndef NEED_USER32_WRAPPER
#define CallWindowProcWrapW CallWindowProcW
#define CallMsgFilterWrapW CallMsgFilterW
#define CharLowerWrapW CharLowerW
#define CharLowerBuffWrapW CharLowerBuffW
#define CharNextWrapW CharNextW
#define CharPrevWrapW CharPrevW
#define CharToOemWrapW CharToOemW
#define CharUpperWrapW CharUpperW
#define CharUpperBuffWrapW CharUpperBuffW
#define CopyAcceleratorTableWrapW CopyAcceleratorTableW
#define CreateAcceleratorTableWrapW CreateAcceleratorTableW
#define CreateWindowExWrapW CreateWindowExW
#define DefWindowProcWrapW DefWindowProcW
#define DispatchMessageWrapW DispatchMessageW
#define DrawTextWrapW DrawTextW
#define FindWindowWrapW FindWindowW
#define FindWindowExWrapW FindWindowExW
#define GetClassInfoWrapW GetClassInfoW
#define GetClassLongWrapW GetClassLongW
#define GetClassNameWrapW GetClassNameW
#define GetClipboardFormatNameWrapW GetClipboardFormatNameW
#define GetDlgItemTextWrapW GetDlgItemTextW
#define GetMessageWrapW GetMessageW
#define MessageBoxWrapW MessageBoxW
#define GetPropWrapW GetPropW
#define GetWindowLongWrapW GetWindowLongW
#define GetWindowTextWrapW GetWindowTextW
#define GetWindowTextLengthWrapW GetWindowTextLengthW
#define IsDialogMessageWrapW IsDialogMessageW
#define LoadAcceleratorsWrapW LoadAcceleratorsW
#define LoadBitmapWrapW LoadBitmapW
#define LoadCursorWrapW LoadCursorW
#define LoadIconWrapW LoadIconW
#define LoadImageWrapW LoadImageW
#define LoadStringWrapW LoadStringW
#define MessageBoxIndirectWrapW MessageBoxIndirectW
#define MessageBoxIndirectWrapW MessageBoxIndirectW
#define ModifyMenuWrapW ModifyMenuW
#define OemToCharWrapW OemToCharW
#define PeekMessageWrapW PeekMessageW
#define PostMessageWrapW PostMessageW
#define PostThreadMessageWrapW PostThreadMessageW
#define RegisterClassWrapW RegisterClassW
#define RegisterClipboardFormatWrapW RegisterClipboardFormatW
#define RegisterWindowMessageWrapW RegisterWindowMessageW
#define RemovePropWrapW RemovePropW
#define SendMessageWrapW SendMessageW
#define SendDlgItemMessageWrapW SendDlgItemMessageW
#define SendMessageWrapW SendMessageW
#define SendMessageTimeoutWrapW SendMessageTimeoutW
#define SetDlgItemTextWrapW SetDlgItemTextW
#define SetPropWrapW SetPropW
#define SetWindowLongWrapW SetWindowLongW
#define SetWindowsHookExWrapW SetWindowsHookExW
#define SetWindowTextWrapW SetWindowTextW
#define SystemParametersInfoWrapW SystemParametersInfoW
#define TranslateAcceleratorWrapW TranslateAcceleratorW
#define UnregisterClassWrapW UnregisterClassW
#define VkKeyScanWrapW VkKeyScanW
#define WinHelpWrapW WinHelpW
#define wvsprintfWrapW wvsprintfW
#define DrawTextExWrapW DrawTextExW
#define RegisterClassExWrapW RegisterClassExW
#define GetClassInfoExWrapW GetClassInfoExW
#define DdeInitializeWrapW DdeInitializeW
#define DdeCreateStringHandleWrapW DdeCreateStringHandleW
#define DdeQueryStringWrapW DdeQueryStringW
#endif

#ifndef NEED_GDI32_WRAPPER
#define CreateDCWrapW CreateDCW
#define CreateICWrapW CreateICW
#define CreateFontIndirectWrapW CreateFontIndirectW
#define EnumFontFamiliesWrapW EnumFontFamiliesW
#define EnumFontFamiliesExWrapW EnumFontFamiliesExW
#define GetObjectWrapW GetObjectW
#define GetTextExtentPoint32WrapW GetTextExtentPoint32W
#define GetTextFaceWrapW GetTextFaceW
#define GetTextMetricsWrapW GetTextMetricsW
#define GetCharacterPlacementWrapW GetCharacterPlacementW
#define GetCharWidth32WrapW GetCharWidth32W
#define ExtTextOutWrapW ExtTextOutW
#define CreateFontWrapW CreateFontW
#define CreateMetaFileWrapW CreateMetaFileW
#define StartDocWrapW StartDocW
#define CreateColorSpaceWrapW CreateColorSpaceW
#endif

#ifndef NEED_ADVAPI32_WRAPPER
#define GetUserNameWrapW GetUserNameW
#define RegCreateKeyWrapW RegCreateKeyW
#define RegCreateKeyExWrapW RegCreateKeyExW
#define RegDeleteKeyWrapW RegDeleteKeyW
#define RegDeleteValueWrapW RegDeleteValueW
#define RegEnumKeyWrapW RegEnumKeyW
#define RegEnumKeyExWrapW RegEnumKeyExW
#define RegOpenKeyWrapW RegOpenKeyW
#define RegOpenKeyExWrapW RegOpenKeyExW
#define RegQueryInfoKeyWrapW RegQueryInfoKeyW
#define RegQueryValueWrapW RegQueryValueW
#define RegQueryValueExWrapW RegQueryValueExW
#define RegSetValueWrapW RegSetValueW
#undef  RegSetValueExW
#define RegSetValueExWrapW RegSetValueExW
#define RegEnumValueWrapW RegEnumValueW
#endif

#ifndef NEED_WINMM_WRAPPER
#define PlaySoundWrapW PlaySoundW
#endif

#ifndef NEED_MPR_WRAPPER
#define WNetRestoreConnectionWrapW WNetRestoreConnectionW
#define WNetGetLastErrorWrapW WNetGetLastErrorW
#endif

#ifndef NEED_VERSION_WRAPPER
#define GetFileVersionInfoSizeWrapW GetFileVersionInfoSizeW
#define GetFileVersionInfoWrapW GetFileVersionInfoW
#define VerQueryValueWrapW VerQueryValueW
#endif

#ifndef NEED_SHELL32_WRAPPER
#define SHBrowseForFolderWrapW SHBrowseForFolderW
#define SHGetPathFromIDListWrapW SHGetPathFromIDListW
#define ShellExecuteExWrapW ShellExecuteExW
#define SHFileOperationWrapW SHFileOperationW
#define ExtractIconExWrapW ExtractIconExW
#define SHGetFileInfoWrapW SHGetFileInfoW
#define DragQueryFileWrapW DragQueryFileW
#define SHDefExtractIconWrapW SHDefExtractIconW
#define ExtractIconWrapW ExtractIconW
#define SHChangeNotifyWrap SHChangeNotify
#endif

#ifndef NEED_COMDLG32_WRAPPER
#define GetSaveFileNameWrapW GetSaveFileNameW
#endif

#ifndef NEED_OLE32_WRAPPER
#define CLSIDFromStringWrap CLSIDFromString
#define CLSIDFromProgIDWrap CLSIDFromProgID
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\tpsclass.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpsclass.h

Abstract:

    Basic classes for Win32 thread pool services functions

    Contents:
        CCriticalSection_NoCtor
        CCriticalSection
        CDoubleLinkedListEntry
        CDoubleLinkedList
        CTimedListEntry
        CTimedList
        CPrioritizedListEntry
        CPrioritizedList

Author:

    Richard L Firth (rfirth) 11-Feb-1998

Notes:

    Some of these classes have no constructor so that we avoid requiring global
    object initialization (via main() e.g.) Therefore, these objects must be
    explicitly initialized through the Init() member

Revision History:

    11-Feb-1998 rfirth
        Created

--*/

// These linked-list helper macros and types are taken from
// ntdef.h and ntrtl.h.  We don't want to include those because
// we have no other reason, and including the nt headers as a
// win32 component causes compilation conflicts.

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
// data
//

extern const char g_cszShlwapi[];
extern DWORD g_ActiveRequests;
extern DWORD g_dwTerminationThreadId;
extern BOOL g_bTpsTerminating;
extern BOOL g_bDeferredWorkerTermination;
extern BOOL g_bDeferredWaiterTermination;
extern BOOL g_bDeferredTimerTermination;

EXTERN_C DWORD g_TpsTls;
EXTERN_C BOOL g_bDllTerminating;

//
// macros
//

#if !defined(ARRAY_ELEMENTS)
#define ARRAY_ELEMENTS(array)   (sizeof(array)/sizeof(array[0]))
#endif

#if !defined(LAST_ELEMENT)
#define LAST_ELEMENT(array)     (ARRAY_ELEMENTS(array) - 1)
#endif

#if !defined(FT2LL)
#define FT2LL(x)                (*(LONGLONG *)&(x))
#endif

//
// classes
//

//
// CCriticalSection_NoCtor - critical section class without constructor or
// destructor for use in global variables
//

class CCriticalSection_NoCtor {

private:

    CRITICAL_SECTION m_critsec;

public:

    VOID Init(VOID) {
        InitializeCriticalSection(&m_critsec);
    }

    VOID Terminate(VOID) {
        DeleteCriticalSection(&m_critsec);
    }

    VOID Acquire(VOID) {
        EnterCriticalSection(&m_critsec);
    }

    VOID Release(VOID) {
        LeaveCriticalSection(&m_critsec);
    }
};

//
// CCriticalSection
//

class CCriticalSection : public CCriticalSection_NoCtor {

public:

    CCriticalSection() {
        Init();
    }

    ~CCriticalSection() {
        Terminate();
    }
};

//
// CDoubleLinkedListEntry/CDoubleLinkedList
//

#define CDoubleLinkedList CDoubleLinkedListEntry

class CDoubleLinkedListEntry {

private:

    LIST_ENTRY m_List;

public:

    VOID Init(VOID) {
        InitializeListHead(&m_List);
    }

    CDoubleLinkedListEntry * Head(VOID) {
        return (CDoubleLinkedListEntry *)&m_List;
    }

    CDoubleLinkedListEntry * Next(VOID) {
        return (CDoubleLinkedListEntry *)m_List.Flink;
    }

    CDoubleLinkedListEntry * Prev(VOID) {
        return (CDoubleLinkedListEntry *)m_List.Blink;
    }

    BOOL IsHead(CDoubleLinkedListEntry * pEntry) {
        return pEntry == Head();
    }

    VOID InsertHead(CDoubleLinkedList * pList) {
        InsertHeadList(&pList->m_List, &m_List);
    }

    VOID InsertTail(CDoubleLinkedList * pList) {
        InsertTailList(&pList->m_List, &m_List);
    }

    VOID Remove(VOID) {
        RemoveEntryList(&m_List);
    }

    CDoubleLinkedListEntry * RemoveHead(VOID) {

        //
        // APPCOMPAT - (compiler?) for some reason, the line:
        //
        //  return (CDoubleLinkedListEntry *)RemoveHeadList(&List);
        //
        // returns the Flink pointer, but doesn't remove it from List
        //

        PLIST_ENTRY pEntry = RemoveHeadList(&m_List);

        return (CDoubleLinkedListEntry *)pEntry;
    }

    CDoubleLinkedListEntry * RemoveTail(VOID) {

        //
        // APPCOMPAT - see RemoveHead()
        //

        PLIST_ENTRY pEntry = RemoveTailList(&m_List);

        return (CDoubleLinkedListEntry *)pEntry;
    }

    BOOL IsEmpty(VOID) {
        return IsListEmpty(&m_List);
    }

    CDoubleLinkedListEntry * FindEntry(CDoubleLinkedListEntry * pEntry) {
        for (CDoubleLinkedListEntry * p = Next(); p != Head(); p = p->Next()) {
            if (p == pEntry) {
                return pEntry;
            }
        }
        return NULL;
    }
};

//
// CTimedListEntry/CTimedList
//

#define CTimedList CTimedListEntry

class CTimedListEntry : public CDoubleLinkedListEntry {

private:

    DWORD m_dwTimeStamp;
    DWORD m_dwWaitTime;

public:

    CTimedListEntry() {
    }

    CTimedListEntry(DWORD dwWaitTime) {
        m_dwTimeStamp = GetTickCount();
        m_dwWaitTime = dwWaitTime;
    }

    VOID Init(VOID) {
        CDoubleLinkedListEntry::Init();
        m_dwTimeStamp = 0;
        m_dwWaitTime = 0;
    }

    DWORD GetTimeStamp(VOID) const {
        return m_dwTimeStamp;
    }

    VOID SetTimeStamp(DWORD dwTimeStamp = GetTickCount()) {
        m_dwTimeStamp = dwTimeStamp;
    }

    DWORD GetWaitTime(VOID) const {
        return m_dwWaitTime;
    }

    VOID SetWaitTime(DWORD dwWaitTime) {
        m_dwWaitTime = dwWaitTime;
    }

    VOID SetExpirationTime(DWORD dwWaitTime) {
        SetTimeStamp();
        SetWaitTime(dwWaitTime);
    }

    BOOL IsTimedOut(DWORD dwTimeNow = GetTickCount()) const {
        return (m_dwWaitTime != INFINITE)
            ? (dwTimeNow >= (m_dwTimeStamp + m_dwWaitTime))
            : FALSE;
    }

    BOOL IsInfiniteTimeout(VOID) const {
        return (m_dwWaitTime == INFINITE);
    }

    DWORD ExpiryTime(VOID) const {
        return m_dwTimeStamp + m_dwWaitTime;
    }

    DWORD TimeToWait(DWORD dwTimeNow = GetTickCount()) {

        DWORD expiryTime = ExpiryTime();

        return IsInfiniteTimeout()
            ? INFINITE
            : ((dwTimeNow >= expiryTime)
                ? 0
                : expiryTime - dwTimeNow);
    }

    //BOOL InsertFront(CDoubleLinkedList * pList) {
    //
    //    DWORD dwExpiryTime = ExpiryTime();
    //    CTimedListEntry * pEntry;
    //
    //    for (pEntry = (CTimedListEntry *)pList->Next();
    //         pEntry != (CTimedListEntry *)pList->Head();
    //         pEntry = (CTimedListEntry *)pEntry->Next()) {
    //        if (dwExpiryTime < pEntry->ExpiryTime()) {
    //            break;
    //        }
    //    }
    //    InsertTail(pEntry);
    //    return this == pList->Next();
    //}

    BOOL InsertBack(CDoubleLinkedList * pList) {

        DWORD dwExpiryTime = ExpiryTime();
        CTimedListEntry * pEntry;

        for (pEntry = (CTimedListEntry *)pList->Prev();
             pEntry != (CTimedListEntry *)pList->Head();
             pEntry = (CTimedListEntry *)pEntry->Prev()) {
            if (dwExpiryTime >= pEntry->ExpiryTime()) {
                break;
            }
        }
        InsertTail(pEntry);
        return this == pList->Next();
    }
};

//
// CPrioritizedListEntry
//

class CPrioritizedListEntry : public CDoubleLinkedListEntry {

private:

    LONG m_lPriority;

public:

    CPrioritizedListEntry(LONG lPriority) {
        m_lPriority = lPriority;
    }

    LONG GetPriority(VOID) const {
        return m_lPriority;
    }

    VOID SetPriority(LONG lPriority) {
        m_lPriority = lPriority;
    }
};

//
// CPrioritizedList
//

class CPrioritizedList : public CDoubleLinkedList {

    //
    // PERF: this really needs to be a btree of list anchors
    //

public:

    VOID
    insert(
        IN CPrioritizedListEntry * pEntry,
        IN LONG lPriority
        ) {
        pEntry->SetPriority(lPriority);
        insert(pEntry);
    }

    VOID
    insert(
        IN CPrioritizedListEntry * pEntry
        ) {

        CPrioritizedListEntry * pCur;

        for (pCur = (CPrioritizedListEntry *)Next();
             pCur != (CPrioritizedListEntry *)Head();
             pCur = (CPrioritizedListEntry *)pCur->Next()) {

            if (pCur->GetPriority() < pEntry->GetPriority()) {
                break;
            }
        }
        pEntry->InsertHead((CDoubleLinkedListEntry *)pCur->Prev());
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\tpstimer.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpstimer.cpp

Abstract:

    Contains Win32 thread pool services timer functions

    Contents:
        TerminateTimers
        SHCreateTimerQueue
        (IECreateTimerQueue)
        SHDeleteTimerQueue
        (IEDeleteTimerQueue)
        SHSetTimerQueueTimer
        (IESetTimerQueueTimer)
        (NTSetTimerQueueTimer)
        SHChangeTimerQueueTimer
        (IEChangeTimerQueueTimer)
        SHCancelTimerQueueTimer
        (IECancelTimerQueueTimer)
        (NTCancelTimerQueueTimer)
        (InitializeTimerThread)
        (TimerCleanup)
        (CreateDefaultTimerQueue)
        (DeleteDefaultTimerQueue)
        (CleanupDefaultTimerQueue)
        (TimerThread)
        (DeleteTimerQueue)
        (AddTimer)
        (ChangeTimer)
        (CancelTimer)

Author:

    Richard L Firth (rfirth) 10-Feb-1998

Environment:

    Win32 user-mode

Notes:

    Code reworked in C++ from NT-specific C code written by Gurdeep Singh Pall
    (gurdeep)

Revision History:

    10-Feb-1998 rfirth
        Created

--*/

#include "priv.h"
#include "threads.h"
#include "tpsclass.h"
#include "tpstimer.h"

//
// private prototypes
//

typedef HANDLE (WINAPI * t_CreateTimerQueue)(VOID);
typedef BOOL (WINAPI * t_DeleteTimerQueue)(HANDLE);
typedef HANDLE (WINAPI * t_SetTimerQueueTimer)(HANDLE,
                                               WAITORTIMERCALLBACKFUNC,
                                               LPVOID,
                                               DWORD,
                                               DWORD,
                                               LPCSTR,
                                               DWORD
                                               );
typedef BOOL (WINAPI * t_ChangeTimerQueueTimer)(HANDLE, HANDLE, DWORD, DWORD);
typedef BOOL (WINAPI * t_CancelTimerQueueTimer)(HANDLE, HANDLE);

// These are KERNEL32 functions that do not match our SHLWAPI APIs
typedef BOOL (WINAPI * t_CreateTimerQueueTimer)(PHANDLE,
                                                HANDLE,
                                                WAITORTIMERCALLBACKFUNC,
                                                LPVOID,
                                                DWORD,
                                                DWORD,
                                                ULONG
                                                );
typedef BOOL (WINAPI * t_DeleteTimerQueueTimer)(HANDLE, HANDLE, HANDLE);

PRIVATE
DWORD
InitializeTimerThread(
    VOID
    );

PRIVATE
VOID
TimerCleanup(
    VOID
    );

PRIVATE
HANDLE
CreateDefaultTimerQueue(
    VOID
    );

PRIVATE
VOID
DeleteDefaultTimerQueue(
    VOID
    );

PRIVATE
VOID
CleanupDefaultTimerQueue(
    VOID
    );

PRIVATE
VOID
TimerThread(
    VOID
    );

PRIVATE
VOID
DeleteTimerQueue(
    IN CTimerQueueDeleteRequest * pRequest
    );

PRIVATE
VOID
AddTimer(
    IN CTimerAddRequest * pRequest
    );

PRIVATE
VOID
ChangeTimer(
    IN CTimerChangeRequest * pRequest
    );

PRIVATE
VOID
CancelTimer(
    IN CTimerCancelRequest * pRequest
    );

//
// global data
//

CTimerQueueList g_TimerQueueList;
HANDLE g_hDefaultTimerQueue = NULL;
HANDLE g_hTimerThread = NULL;
DWORD g_dwTimerId = 0;
LONG g_UID = 0;
BOOL g_bTimerInit = FALSE;
BOOL g_bTimerInitDone = FALSE;
BOOL g_bDeferredTimerTermination = FALSE;

//
//  Forward-declared data.
//
extern t_CreateTimerQueue      _I_CreateTimerQueue;
extern t_DeleteTimerQueue      _I_DeleteTimerQueue;
extern t_SetTimerQueueTimer    _I_SetTimerQueueTimer;
extern t_ChangeTimerQueueTimer _I_ChangeTimerQueueTimer;
extern t_CancelTimerQueueTimer _I_CancelTimerQueueTimer;
extern t_CreateTimerQueueTimer _I_CreateTimerQueueTimer;
extern t_DeleteTimerQueueTimer _I_DeleteTimerQueueTimer;

//
//  Wrappers for NT5 because the Shlwapi version differs slightly from the
//  NT version.
//

LWSTDAPI_(HANDLE)
NTSetTimerQueueTimer(
    IN HANDLE hQueue,
    IN WAITORTIMERCALLBACKFUNC pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    )
{
    //
    //  Translate the flags from TPS flags to WT flags.
    //
    DWORD dwWTFlags = 0;
    if (dwFlags & TPS_EXECUTEIO)    dwWTFlags |= WT_EXECUTEINIOTHREAD;
    if (dwFlags & TPS_LONGEXECTIME) dwWTFlags |= WT_EXECUTELONGFUNCTION;

    HANDLE hTimer;
    if (_I_CreateTimerQueueTimer(&hTimer, hQueue, pfnCallback, pContext, dwDueTime, dwPeriod, dwWTFlags))
    {
        return hTimer;
    }
    return NULL;
}

LWSTDAPI_(BOOL)
NTCancelTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer
    )
{
    return _I_DeleteTimerQueueTimer(hQueue, hTimer, INVALID_HANDLE_VALUE);
}


STDAPI_(void) InitTimerQueue()
{
    if (IsOS(OS_WHISTLERORGREATER))
    {
        HMODULE hKernel32 = GetModuleHandle("KERNEL32.DLL");
        if (hKernel32)
        {
            t_CreateTimerQueue      NTCreateTimerQueue;
            t_DeleteTimerQueue      NTDeleteTimerQueue;
            t_CreateTimerQueueTimer NTCreateTimerQueueTimer;
            t_ChangeTimerQueueTimer NTChangeTimerQueueTimer;
            t_DeleteTimerQueueTimer NTDeleteTimerQueueTimer;

            #define GetKernelProc(fn) \
                    ((NT##fn = (t_##fn)GetProcAddress(hKernel32, #fn)) != NULL)

            if (GetKernelProc(CreateTimerQueue) &&
                GetKernelProc(DeleteTimerQueue) &&
                GetKernelProc(CreateTimerQueueTimer) &&
                GetKernelProc(ChangeTimerQueueTimer) &&
                GetKernelProc(DeleteTimerQueueTimer))
            {
                #define SwitchToNTVersion(fn) (_I_##fn = NT##fn)

                // Redirect the SHLWAPI APIs to the NT versions
                // (They either point directly to the KERNEL API
                // or to our stub functions.)
                SwitchToNTVersion(CreateTimerQueue);
                SwitchToNTVersion(DeleteTimerQueue);
                SwitchToNTVersion(ChangeTimerQueueTimer);
                SwitchToNTVersion(SetTimerQueueTimer);
                SwitchToNTVersion(CancelTimerQueueTimer);

                // Save these values so our stub functions can
                // call the KERNEL API after they do their translation.
                SwitchToNTVersion(CreateTimerQueueTimer);
                SwitchToNTVersion(DeleteTimerQueueTimer);
            }

            #undef GetKernelProc
            #undef SwitchToNTVersion
        }
    }
}


//
// functions
//

VOID
TerminateTimers(
    VOID
    )

/*++

Routine Description:

    Terminate timer thread and global variables

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_bTimerInitDone) {

        DWORD threadId = GetCurrentThreadId();

        if ((g_hTimerThread != NULL) && (threadId != g_dwTimerId)) {
            QueueNullFunc(g_hTimerThread);

            DWORD ticks = GetTickCount();

            while (g_hTimerThread != NULL) {
                SleepEx(0, TRUE);
                if (GetTickCount() - ticks > 10000) {
                    CloseHandle(g_hTimerThread);
                    g_hTimerThread = NULL;
                    break;
                }
            }
        }
        if (g_dwTimerId == threadId) {
            g_bDeferredTimerTermination = TRUE;
        } else {
            TimerCleanup();
        }
    }
}

LWSTDAPI_(HANDLE)
SHCreateTimerQueue(
    VOID
    )
{
    return _I_CreateTimerQueue();
}

LWSTDAPI_(HANDLE)
IECreateTimerQueue(
    VOID
    )

/*++

Routine Description:

    Creates a timer queue

Arguments:

    None.

Return Value:

    HANDLE
        Success - non-NULL pointer to CTimerQueue object

        Failure - NULL. GetLastError() for more info

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    HANDLE hResult = NULL;
    DWORD error = ERROR_SUCCESS;

    if (!g_bTpsTerminating) {
        if (g_hTimerThread == NULL) {
            error = InitializeTimerThread();
        }
        if (error == ERROR_SUCCESS) {

            //
            // timer queue handle is just pointer to timer queue object
            //

            hResult = (HANDLE) new CTimerQueue(&g_TimerQueueList);
        } else {
            SetLastError(error);
        }
    } else {
        SetLastError(ERROR_SHUTDOWN_IN_PROGRESS); // error code? looks valid -justmann
    }
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    return hResult;
}

LWSTDAPI_(BOOL)
SHDeleteTimerQueue(
    IN HANDLE hQueue
    )
{
    return _I_DeleteTimerQueue(hQueue);
}

LWSTDAPI_(BOOL)
IEDeleteTimerQueue(
    IN HANDLE hQueue
    )

/*++

Routine Description:

    Deletes the specified timer queue

Arguments:

    hQueue  - handle of queue to delete; NULL for default timer queue

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    BOOL bSuccess = FALSE;

    if (!g_bTpsTerminating) {
        if (hQueue == NULL) {
            hQueue = g_hDefaultTimerQueue;
        }
        if ((hQueue != NULL) && (g_hTimerThread != NULL)) {

            CTimerQueueDeleteRequest request(hQueue);

            if (QueueUserAPC((PAPCFUNC)DeleteTimerQueue,
                             g_hTimerThread,
                             (ULONG_PTR)&request)) {
                request.WaitForCompletion();
                bSuccess = request.SetThreadStatus();
            } else {
#if DBG
                DWORD error = GetLastError();

                ASSERT(error == ERROR_SUCCESS);
#endif
            }
        } else {
            SetLastError(ERROR_INVALID_PARAMETER); // correct error code?  looks valid -justmann
        }
    } else {
        SetLastError(ERROR_SHUTDOWN_IN_PROGRESS); // error code?  looks valid -justmann
    }
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    return bSuccess;
}

LWSTDAPI_(HANDLE)
SHSetTimerQueueTimer(
    IN HANDLE hQueue,
    IN WAITORTIMERCALLBACKFUNC pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    )
{
    return _I_SetTimerQueueTimer(hQueue, pfnCallback, pContext, dwDueTime, dwPeriod, lpszLibrary, dwFlags);
}

LWSTDAPI_(HANDLE)
IESetTimerQueueTimer(
    IN HANDLE hQueue,
    IN WAITORTIMERCALLBACKFUNC pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Add a timer to a queue

Arguments:

    hQueue      - handle of timer queue; NULL for default queue

    pfnCallback - function to call when timer triggers

    pContext    - parameter to pfnCallback

    dwDueTime   - initial firing time in milliseconds from now

    dwPeriod    - repeating period. 0 for one-shot

    lpszLibrary - if specified, name of library (DLL) to reference

    dwFlags     - flags controlling function:

                    TPS_EXECUTEIO   - Execute callback in I/O thread

Return Value:

    HANDLE
        Success - non-NULL handle

        Failure - NULL. Call GetLastError() for more info

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    HANDLE hTimer = NULL;

    if (!g_bTpsTerminating) {

        DWORD error = ERROR_SUCCESS;

        if (g_hTimerThread == NULL) {
            error = InitializeTimerThread();
        }

        ASSERT(g_hTimerThread != NULL);

        if (error == ERROR_SUCCESS) {
            if (hQueue == NULL) {
                hQueue = CreateDefaultTimerQueue();
            }
            if (hQueue != NULL) {

                CTimerAddRequest * pRequest = new CTimerAddRequest(hQueue,
                                                                   pfnCallback,
                                                                   pContext,
                                                                   dwDueTime,
                                                                   dwPeriod,
                                                                   dwFlags
                                                                   );

                if (pRequest != NULL) {
                    hTimer = pRequest->GetHandle();
                    if (QueueUserAPC((PAPCFUNC)AddTimer,
                                     g_hTimerThread,
                                     (ULONG_PTR)pRequest
                                     )) {
                    } else {
#if DBG
                        error = GetLastError();

                        ASSERT(GetLastError() != ERROR_SUCCESS);
#endif
                        delete pRequest;
                        hTimer = NULL;
#if DBG
                        SetLastError(error);
#endif
                    }
                }
            }
        } else {
            SetLastError(error);
        }
    } else {
        SetLastError(ERROR_SHUTDOWN_IN_PROGRESS); // error code?  looks valid -justmann
    }
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    return hTimer;
}

LWSTDAPI_(BOOL)
SHChangeTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod
    )
{
    return _I_ChangeTimerQueueTimer(hQueue, hTimer, dwDueTime, dwPeriod);
}

LWSTDAPI_(BOOL)
IEChangeTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod
    )

/*++

Routine Description:

    Change the due time or periodicity of a timer

Arguments:

    hQueue      - handle of queue on which timer resides. NULL for default queue

    hTimer      - handle of timer to change

    dwDueTime   - new due time

    dwPeriod    - new period

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    BOOL bSuccess = FALSE;
    DWORD error = ERROR_SHUTDOWN_IN_PROGRESS; // error code?  looks valid -justmann

    if (!g_bTpsTerminating) {
        error = ERROR_OBJECT_NOT_FOUND;
        if (g_hTimerThread != NULL) {
            if (hQueue == NULL) {
                hQueue = g_hDefaultTimerQueue;
            }
            if (hQueue != NULL) {

                CTimerChangeRequest request(hQueue, hTimer, dwDueTime, dwPeriod);

                error = ERROR_SUCCESS; // both paths call SetLastError() if reqd
                if (QueueUserAPC((PAPCFUNC)ChangeTimer,
                                 g_hTimerThread,
                                 (ULONG_PTR)&request
                                 )) {
                    request.WaitForCompletion();
                    bSuccess = request.SetThreadStatus();
                } else {
#if DBG
                    ASSERT(GetLastError() == ERROR_SUCCESS);
#endif
                }
            }
        }
    }
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    if (error != ERROR_SUCCESS) {
        SetLastError(error);
    }
    return bSuccess;
}

LWSTDAPI_(BOOL)
SHCancelTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer
    )
{
    return _I_CancelTimerQueueTimer(hQueue, hTimer);
}

LWSTDAPI_(BOOL)
IECancelTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer
    )

/*++

Routine Description:

    Cancels a timer

Arguments:

    hQueue  - handle to queue on which timer resides

    hTimer  - handle of timer to cancel

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    BOOL bSuccess = FALSE;

    if (!g_bTpsTerminating) {
        if (hQueue == NULL) {
            hQueue = g_hDefaultTimerQueue;
        }
        if ((hQueue != NULL) && (g_hTimerThread != NULL)) {

            CTimerCancelRequest request(hQueue, hTimer);

            if (QueueUserAPC((PAPCFUNC)CancelTimer,
                             g_hTimerThread,
                             (ULONG_PTR)&request
                             )) {
                request.WaitForCompletion();
                bSuccess = request.SetThreadStatus();
            } else {
#if DBG
                DWORD error = GetLastError();

                ASSERT(error == ERROR_SUCCESS);
#endif
            }
        } else {
            SetLastError(ERROR_INVALID_HANDLE);
        }
    } else {
        SetLastError(ERROR_SHUTDOWN_IN_PROGRESS); // error code?  looks valid -justmann
    }
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    return bSuccess;
}

//
// private functions
//

PRIVATE
DWORD
InitializeTimerThread(
    VOID
    )
{
    DWORD error = ERROR_SUCCESS;

    while (!g_bTimerInitDone) {
        if (!InterlockedExchange((LPLONG)&g_bTimerInit, TRUE)) {

            //
            // N.B. if CTimerQueueList::Init() does anything more than just
            // initialize lists then add a Deinit()
            //

            g_TimerQueueList.Init();

            ASSERT(g_hTimerThread == NULL);

            error = StartThread((LPTHREAD_START_ROUTINE)TimerThread,
                                &g_hTimerThread,
                                FALSE
                                );
            if (error == ERROR_SUCCESS) {
                g_bTimerInitDone = TRUE;
            } else {
                InterlockedExchange((LPLONG)&g_bTimerInit, FALSE);
            }
            break;
        } else {
            SleepEx(0, FALSE);
        }
    }
    return error;
}

PRIVATE
VOID
TimerCleanup(
    VOID
    )
{
    while (!g_TimerQueueList.QueueListHead()->IsEmpty()) {

        CTimerQueueDeleteRequest request((CTimerQueue *)
                                    g_TimerQueueList.QueueListHead()->Next());

        DeleteTimerQueue(&request);
    }
    DeleteDefaultTimerQueue();
    g_UID = 0;
    g_bTimerInit = FALSE;
    g_bTimerInitDone = FALSE;
}

BOOL bDefaultQueueInit = FALSE;
BOOL bDefaultQueueInitDone = FALSE;
BOOL bDefaultQueueInitFailed = FALSE;

PRIVATE
HANDLE
CreateDefaultTimerQueue(
    VOID
    )
{
    do {
        if ((g_hDefaultTimerQueue != NULL) || bDefaultQueueInitFailed) {
            return g_hDefaultTimerQueue;
        }
        if (!InterlockedExchange((LPLONG)&bDefaultQueueInit, TRUE)) {
            InterlockedExchange((LPLONG)&bDefaultQueueInitDone, FALSE);
            g_hDefaultTimerQueue = SHCreateTimerQueue();
            if (g_hDefaultTimerQueue == NULL) {
                bDefaultQueueInitFailed = TRUE;
                InterlockedExchange((LPLONG)&bDefaultQueueInit, FALSE);
            }
            InterlockedExchange((LPLONG)&bDefaultQueueInitDone, TRUE);
        } else {
            do {
                SleepEx(0, FALSE);
            } while (!bDefaultQueueInitDone);
        }
    } while (TRUE);
}

PRIVATE
VOID
DeleteDefaultTimerQueue(
    VOID
    )
{
    if (g_hDefaultTimerQueue != NULL) {

        CTimerQueueDeleteRequest request((CTimerQueue *)g_hDefaultTimerQueue);

        DeleteTimerQueue(&request);
        g_hDefaultTimerQueue = NULL;
    }
    CleanupDefaultTimerQueue();
}

PRIVATE
VOID
CleanupDefaultTimerQueue(
    VOID
    )
{
    g_hDefaultTimerQueue = NULL;
    bDefaultQueueInit = FALSE;
    bDefaultQueueInitDone = FALSE;
    bDefaultQueueInitFailed = FALSE;
}

PRIVATE
VOID
TimerThread(
    VOID
    )
{
    g_dwTimerId = GetCurrentThreadId();

    HMODULE hDll = LoadLibrary(g_cszShlwapi);

    ASSERT(hDll != NULL);
    ASSERT(g_TpsTls != 0xFFFFFFFF);

    TlsSetValue(g_TpsTls, (LPVOID)TPS_TIMER_SIGNATURE);

    while (!g_bTpsTerminating || (g_ActiveRequests != 0)) {
        if (g_TimerQueueList.Wait()) {
            if (g_bTpsTerminating && (g_ActiveRequests == 0)) {
                break;
            }
            g_TimerQueueList.ProcessCompletions();
        }
    }

    ASSERT(g_hTimerThread != NULL);

    CloseHandle(g_hTimerThread);
    g_hTimerThread = NULL;
    if (g_dwTimerId == g_dwTerminationThreadId) {
        TimerCleanup();
        g_bTpsTerminating = FALSE;
        g_dwTerminationThreadId = 0;
        g_bDeferredTimerTermination = FALSE;
    }
    g_dwTimerId = 0;
    FreeLibraryAndExitThread(hDll, ERROR_SUCCESS);
}

PRIVATE
VOID
DeleteTimerQueue(
    IN CTimerQueueDeleteRequest * pRequest
    )
{
    CTimerQueue * pQueue = (CTimerQueue *)pRequest->GetQueue();
    DWORD dwStatus = ERROR_INVALID_PARAMETER;

    if (g_TimerQueueList.FindQueue((CDoubleLinkedListEntry *)pQueue) != NULL) {
        pQueue->DeleteTimers();
        if (pQueue == g_hDefaultTimerQueue) {
            CleanupDefaultTimerQueue();
        }
        delete pQueue;
        dwStatus = ERROR_SUCCESS;
    }
    pRequest->SetCompletionStatus(dwStatus);
}

PRIVATE
VOID
AddTimer(
    IN CTimerAddRequest * pRequest
    )
{
    CTimerQueue * pQueue = pRequest->GetQueue();

    //
    // add timer object to global list of timer objects, in expiration time
    // order
    //

    pRequest->InsertBack(g_TimerQueueList.TimerListHead());

    //
    // add timer object to end of timer queue list in no particular order. Only
    // used to delete all objects belonging to queue when queue is deleted
    //

    pRequest->TimerListHead()->InsertTail(pQueue->TimerListHead());
    pRequest->SetComplete();
}

PRIVATE
VOID
ChangeTimer(
    IN CTimerChangeRequest * pRequest
    )
{
    CTimerQueue * pQueue = (CTimerQueue *)pRequest->GetQueue();
    CTimerQueueEntry * pTimer = pQueue->FindTimer(pRequest->GetTimer());
    DWORD dwStatus = ERROR_INVALID_PARAMETER;

    if (pTimer != NULL) {
        pTimer->SetPeriod(pRequest->GetPeriod());
        pTimer->SetExpirationTime(pRequest->GetDueTime());
        dwStatus = ERROR_SUCCESS;
    }
    pRequest->SetCompletionStatus(dwStatus);
}

PRIVATE
VOID
CancelTimer(
    IN CTimerCancelRequest * pRequest
    )
{
    CTimerQueue * pQueue = (CTimerQueue *)pRequest->GetQueue();
    CTimerQueueEntry * pTimer = pQueue->FindTimer(pRequest->GetTimer());
    DWORD dwStatus = ERROR_INVALID_PARAMETER;

    if (pTimer != NULL) {
        if (pTimer->IsInUse()) {
            pTimer->SetCancelled();
        } else {
            pTimer->Remove();
            delete pTimer;
        }
        dwStatus = ERROR_SUCCESS;
    }
    pRequest->SetCompletionStatus(dwStatus);
}

//
//  Definitions of forward-declared data.
//

t_CreateTimerQueue      _I_CreateTimerQueue      = IECreateTimerQueue;
t_DeleteTimerQueue      _I_DeleteTimerQueue      = IEDeleteTimerQueue;
t_SetTimerQueueTimer    _I_SetTimerQueueTimer    = IESetTimerQueueTimer;
t_ChangeTimerQueueTimer _I_ChangeTimerQueueTimer = IEChangeTimerQueueTimer;
t_CancelTimerQueueTimer _I_CancelTimerQueueTimer = IECancelTimerQueueTimer;

//
//  KERNEL functions that our NT stubs use.  Not used if in IE mode.
//
t_CreateTimerQueueTimer _I_CreateTimerQueueTimer = NULL;
t_DeleteTimerQueueTimer _I_DeleteTimerQueueTimer = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\tpsutil.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpsutil.cpp

Abstract:

    Comtains common utility functions for Win32 thread pool services

    Contents:
        StartThread
        TpsEnter
        QueueNullFunc
        (NullFunc)

Author:

    Richard L Firth (rfirth) 10-Feb-1998

Environment:

    Win32 user-mode

Notes:

    Taken from NT-specific code written by Gurdeep Singh Pall (gurdeep)

Revision History:

    10-Feb-1998 rfirth
        Created

--*/

#include "priv.h"
#include "threads.h"

//
// private prototypes
//

PRIVATE
VOID
NullFunc(
    IN LPVOID pUnused
    );

//
// functions
//

DWORD
StartThread(
    IN LPTHREAD_START_ROUTINE pfnFunction,
    OUT PHANDLE phThread,
    IN BOOL fSynchronize
    )

/*++

Routine Description:

    This routine is used start a new thread in the pool. If required, we
    synchronize with the new thread using an auto-reset event that the new
    thread must signal once it has completed its initialization

Arguments:

    pfnFunction     - pointer to thread function to start

    phThread        - pointer to returned thread handle

    fSynchronize    - used to indicate if we need to synchronize with the new
                      thread before returning

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Out of memory

--*/

{
    HANDLE hSyncEvent = NULL;

    if (fSynchronize) {
        hSyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (hSyncEvent == NULL) {
            return GetLastError();
        }
    }

    DWORD dwThreadId;
    HANDLE hThread;
    DWORD error = ERROR_SUCCESS;

    hThread = CreateThread(NULL,        // lpSecurityAttributes
                           0,           // dwStackSize (0 == same as init thread)
                           pfnFunction,
                           (LPVOID)hSyncEvent,
                           0,           // dwCreationFlags
                           &dwThreadId  // throw away
                           );
    if (hThread == NULL) {
        error = GetLastError();
    }
    if (hSyncEvent != NULL) {
        if (hThread != NULL) {

            DWORD status = WaitForSingleObject(hSyncEvent, INFINITE);

            if (status == WAIT_FAILED) {
                error = GetLastError();
            } else if (status == WAIT_TIMEOUT) {
                error = WAIT_TIMEOUT;
            } else if (status != WAIT_OBJECT_0) {
                error = ERROR_GEN_FAILURE; // ?
            }

            if (ERROR_SUCCESS != error)
            {
                CloseHandle(hThread);
                hThread = NULL;
            }
        }
        CloseHandle(hSyncEvent);
    }
    *phThread = hThread;
    return error;
}

DWORD
TpsEnter(
    VOID
    )

/*++

Routine Description:

    synchronize with thread shutting down via SHTerminateThreadPool(). If
    terminating because DLL is unloaded, return error else wait until
    termination completed

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_SHUTDOWN_IN_PROGRESS

--*/

{
    for (; ; ) {
        while (g_bTpsTerminating) {
            if (g_bDllTerminating) {
                return ERROR_SHUTDOWN_IN_PROGRESS; // error code?  looks valid -justmann
            }
            SleepEx(0, TRUE);
        }
        InterlockedIncrement((LPLONG)&g_ActiveRequests);
        if (!g_bTpsTerminating) {
            return ERROR_SUCCESS;
        }
        InterlockedDecrement((LPLONG)&g_ActiveRequests);
    }
}

VOID
QueueNullFunc(
    IN HANDLE hThread
    )

/*++

Routine Description:

    Queues NullFunc as an APC to hThread

Arguments:

    hThread - thread to queue for

Return Value:

    None.

--*/

{
    QueueUserAPC((PAPCFUNC)NullFunc, hThread, NULL);
}

PRIVATE
VOID
NullFunc(
    IN LPVOID pUnused
    )

/*++

Routine Description:

    NULL APC function. Used to allow TerminateThreadPool() to wake up dormant
    APC threads

Arguments:

    pUnused - unused argument pointer

Return Value:

    None.

--*/

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\tpswork.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tpswork.h

Abstract:

    Worker thread classes. Moved out of tpsclass.h

    Contents:
        CIoWorkerThreadInfo
        CIoWorkerRequest
        CThreadPool

Author:

    Richard L Firth (rfirth) 08-Aug-1998

Revision History:

    08-Aug-1998 rfirth
        Created

--*/

//
// manifests
//

#define THREAD_CREATION_DAMPING_TIME    5000
#define NEW_THREAD_THRESHOLD            10
#define MIN_WORKER_THREADS              1
#define MAX_WORKER_THREADS              128
#define MAX_IO_WORKER_THREADS           256
#define MAX_QUEUE_DEPTH                 0
#define THREAD_IDLE_TIMEOUT             60000

#define TPS_ID                          0x80000000

//
// external data
//

extern DWORD g_dwWorkItemId;

//
// classes
//

//
// CIoWorkerThreadInfo
//

class CIoWorkerThreadInfo : public CDoubleLinkedListEntry {

private:

    HANDLE m_hThread;

public:

    CIoWorkerThreadInfo(CDoubleLinkedList * pList) {
        m_hThread = (HANDLE)-1;
        InsertHead(pList);
    }

    ~CIoWorkerThreadInfo() {

        ASSERT(m_hThread == NULL);

    }

    VOID SetHandle(HANDLE hThread) {
        m_hThread = hThread;
    }

    HANDLE GetHandle(VOID) const {
        return m_hThread;
    }
};

//
// CIoWorkerRequest
//

class CIoWorkerRequest {

private:

    LPTHREAD_START_ROUTINE m_pfnCallback;
    LPVOID m_pContext;

public:

    CIoWorkerRequest(LPTHREAD_START_ROUTINE pfnCallback, LPVOID pContext) {
        m_pfnCallback = pfnCallback;
        m_pContext = pContext;
    }

    LPTHREAD_START_ROUTINE GetCallback(VOID) const {
        return m_pfnCallback;
    }

    LPVOID GetContext(VOID) const {
        return m_pContext;
    }
};

//
// CThreadPool - maintains lists of work items, non-IO worker threads and
// IO worker threads
//

class CThreadPool {

private:

    //
    // private classes
    //

    //
    // CWorkItem - queued app-supplied functions, ordered by priority
    //

    class CWorkItem : public CPrioritizedListEntry {

    public:

        FARPROC m_function;
        ULONG_PTR m_context;
        DWORD_PTR m_tag;
        DWORD_PTR m_id;
        DWORD m_flags;
        HINSTANCE m_hInstModule;

        CWorkItem(FARPROC lpfn,
                  ULONG_PTR context,
                  LONG priority,
                  DWORD_PTR tag,
                  DWORD_PTR * pid,
                  LPCSTR pszModule,
                  DWORD flags
                  ) : CPrioritizedListEntry(priority)
        {
            m_function = lpfn;
            m_context = context;
            m_tag = tag;
            m_id = (DWORD_PTR)0;
            m_flags = flags;

            if (pszModule && *pszModule)
            {
                m_hInstModule = LoadLibrary(pszModule);

                if (!m_hInstModule)
                {
                    TraceMsg(TF_WARNING, TEXT("CWorkItem::CWorkItem  - faild to load %hs (error = %d), worker thread could be abanonded!!"), pszModule, GetLastError());
                }
            }
            else
            {
                m_hInstModule = NULL;
            }

            if (pid) {
                m_id = (DWORD_PTR)++g_dwWorkItemId;
                *pid = m_id;
                m_flags |= TPS_ID;
            }
        }

        ~CWorkItem()
        {
            // we used to call FreeLibrary(m_hInstModule) here but we delete the workitem
            // when we grab it off of the queue (in RemoveWorkItem). so we have to wait until
            // we are actually done running the task before we call FreeLibaray()
        }

        BOOL Match(DWORD_PTR Tag, BOOL IsTag) {
            return IsTag
                ? ((m_flags & TPS_TAGGEDITEM) && (m_tag == Tag))
                : ((m_flags & TPS_ID) && (m_id == Tag));
        }

        BOOL IsLongExec(VOID) {
            return (m_flags & TPS_LONGEXECTIME) ? TRUE : FALSE;
        }
    };

    //
    // work item queue variables
    //

    CPrioritizedList m_queue;
    CCriticalSection_NoCtor m_qlock;
    HANDLE m_event;
    DWORD m_error;
    DWORD m_queueSize;
    DWORD m_qFactor;
    DWORD m_minWorkerThreads;
    DWORD m_maxWorkerThreads;
    DWORD m_maxQueueDepth;
    DWORD m_workerIdleTimeout;
    DWORD m_creationDelta;
    DWORD m_totalWorkerThreads;
    DWORD m_availableWorkerThreads;

#if DBG
    DWORD m_queueSizeMax;
    DWORD m_qFactorMax;
    DWORD m_maxWorkerThreadsCreated;
#endif

    //
    // private member functions
    //

    CWorkItem * DequeueWorkItem(VOID) {

        CWorkItem * pItem = NULL;

        if (!m_queue.IsEmpty()) {
            pItem = (CWorkItem *)m_queue.RemoveHead();
            --m_queueSize;
        }
        return pItem;
    }

    VOID
    Worker(
        VOID
        );

public:

    static
    VOID
    WorkerThread(
        VOID
        );

    BOOL Init(VOID) {
        m_queue.Init();
        m_qlock.Init();

        //
        // create auto-reset, initially unsignalled event
        //

        m_event = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_error = (m_event != NULL) ? ERROR_SUCCESS : GetLastError();
        m_queueSize = 0;
        m_qFactor = 0;
        m_minWorkerThreads = MIN_WORKER_THREADS;
        m_maxWorkerThreads = MAX_WORKER_THREADS;
        m_maxQueueDepth = MAX_QUEUE_DEPTH;
        m_workerIdleTimeout = THREAD_IDLE_TIMEOUT;
        m_creationDelta = THREAD_CREATION_DAMPING_TIME;
        m_totalWorkerThreads = 0;
        m_availableWorkerThreads = 0;

#if DBG
        m_queueSizeMax = 0;
        m_qFactorMax = 0;
        m_maxWorkerThreadsCreated = 0;
#endif

        return m_error == ERROR_SUCCESS;
    }

    VOID Terminate(DWORD Limit) {
        PurgeWorkItems();
        TerminateThreads(Limit);
        if (m_event != NULL) {

            BOOL bOk = CloseHandle(m_event);

            ASSERT(bOk);

            m_event = NULL;
        }
        m_qlock.Terminate();

        ASSERT(m_queue.IsEmpty());

//#if DBG
//char buf[256];
//wsprintf(buf,
//         "CThreadPool::Terminate(): m_queueSizeMax = %d, m_maxWorkerThreadsCreated = %d, m_qFactorMax = %d\n",
//         m_queueSizeMax,
//         m_maxWorkerThreadsCreated,
//         m_qFactorMax
//         );
//OutputDebugString(buf);
//#endif
    }

    DWORD GetError() const {
        return m_error;
    }

    VOID
    SetLimits(
        IN DWORD dwMinimumThreads,
        IN DWORD dwMaximumThreads,
        IN DWORD dwMaximumQueueDepth,
        IN DWORD dwThreadIdleTimeout,
        IN DWORD dwThreadCreationDelta
        )
    {
        m_minWorkerThreads = dwMinimumThreads;
        m_maxWorkerThreads = dwMaximumThreads;
        m_maxQueueDepth = dwMaximumQueueDepth;
        m_workerIdleTimeout = dwThreadIdleTimeout;
        m_creationDelta = dwThreadCreationDelta;
    }

    VOID MakeAvailable(VOID) {
        InterlockedIncrement((LPLONG)&m_availableWorkerThreads);
        if (m_qFactor == 0) {
            m_qFactor = 1;
        } else {
            m_qFactor <<= 1;
        }
#if DBG
        if (m_qFactor > m_qFactorMax) {
            m_qFactorMax = m_qFactor;
        }
#endif
    }

    VOID MakeUnavailable(VOID) {
        InterlockedDecrement((LPLONG)&m_availableWorkerThreads);
        m_qFactor >>= 1;
        if ((m_qFactor == 0) && (m_availableWorkerThreads != 0)) {
            m_qFactor = 1;
        }
    }

    DWORD
    QueueWorkItem(
        FARPROC pfnFunction,
        ULONG_PTR pContext,
        LONG lPriority,
        DWORD_PTR dwTag,
        DWORD_PTR * pdwId,
        LPCSTR pszModule,
        DWORD dwFlags
        )
    {
        //
        // add a work item to the queue at the appropriate place and create a
        // thread to handle it if necessary
        //

        CWorkItem * pItem = new CWorkItem(pfnFunction,
                                          pContext,
                                          lPriority,
                                          dwTag,
                                          pdwId,
                                          pszModule,
                                          dwFlags
                                          );

        if (pItem == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        m_qlock.Acquire();

        //
        // demand-thread work-items have the highest priority. Put at head of
        // queue, else insert based on priority
        //

        if (dwFlags & TPS_DEMANDTHREAD) {
            pItem->InsertHead(&m_queue);
        } else {
            m_queue.insert(pItem);
        }
        ++m_queueSize;
#if DBG
        if (m_queueSize > m_queueSizeMax) {
            m_queueSizeMax = m_queueSize;
        }
#endif

        //
        // determine whether we need to create a new thread:
        //
        //  * no available threads
        //  * work queue growing too fast
        //  * all available threads about to be taken by long-exec work items
        //

        BOOL bCreate = FALSE;
        DWORD error = ERROR_SUCCESS;

        if (m_queueSize > (m_availableWorkerThreads * m_qFactor)) {
            bCreate = TRUE;
        } else {

            DWORD i = 0;
            DWORD n = 0;
            CWorkItem * pItem = (CWorkItem *)m_queue.Next();

            while ((pItem != m_queue.Head()) && (i < m_availableWorkerThreads)) {
                if (pItem->IsLongExec()) {
                    ++n;
                }
                pItem = (CWorkItem *)pItem->Next();
                ++i;
            }
            if (n == m_availableWorkerThreads) {
                bCreate = TRUE;
            }
        }
        m_qlock.Release();
        if (bCreate) {
            // if the CreateWorkerThread fails, do NOT pass back an error code to the caller
            // since we've already added the workitem to the queue.  An error code will
            // likely result in the caller freeing the data for the work item. (saml 081799)
            CreateWorkerThread();
        }
        SetEvent(m_event);
        return error;
    }

    DWORD
    RemoveWorkItem(
        FARPROC * ppfnFunction,
        ULONG_PTR * pContext,
        HMODULE* hModuleToFree,
        DWORD * pdwFlags,
        DWORD dwTimeout
        )
    {
        BOOL bFirstTime = TRUE;
        DWORD dwWaitTime = dwTimeout;

        while (TRUE) {

            CWorkItem * pItem;

            //
            // first test the FIFO state without waiting for the event
            //

            if (!m_queue.IsEmpty())
            {
                m_qlock.Acquire();
                pItem = DequeueWorkItem();

                if (pItem != NULL)
                {
                    if (pItem->m_flags & TPS_LONGEXECTIME)
                    {
                        MakeUnavailable();
                    }

                    m_qlock.Release();
                    *ppfnFunction = pItem->m_function;
                    *pContext = pItem->m_context;
                    *pdwFlags = pItem->m_flags & ~TPS_RESERVED_FLAGS;
                    *hModuleToFree = pItem->m_hInstModule;
                    delete pItem;
                    
                    return ERROR_SUCCESS;
                }
                m_qlock.Release();
            }

            DWORD dwStartTime;

            if ((dwTimeout != INFINITE) && bFirstTime) {
                dwStartTime = GetTickCount();
            }

            //
            // if dwTimeout is 0 (poll) and we've already waited unsuccessfully
            // then we're done: we timed out
            //

            if ((dwTimeout == 0) && !bFirstTime) {
                break;
            }

            //
            // wait alertably: process I/O completions while we wait
            //
            // FEATURE - we want MsgWaitForMultipleObjectsEx() here, but Win95
            //          doesn't support it
            //

            DWORD status = MsgWaitForMultipleObjects(1,
                                                     &m_event,
                                                     FALSE,
                                                     dwWaitTime,
                                                     //QS_ALLINPUT
                                                     QS_SENDMESSAGE | QS_KEY
                                                     );

            //
            // quit now if thread pool is terminating
            //

            if (g_bTpsTerminating) {
                break;
            }
            bFirstTime = FALSE;
            if ((status == WAIT_OBJECT_0) || (status == WAIT_IO_COMPLETION)) {

                //
                // we think there is something to remove from the FIFO or I/O
                // completed. If we're not waiting forever, update the time to
                // wait on the next iteration based on the time we started
                //

                if (dwTimeout != INFINITE) {

                    DWORD dwElapsedTime = GetTickCount() - dwStartTime;

                    if (dwElapsedTime > dwTimeout) {

                        //
                        // waited longer than requested. Don't wait again if
                        // we find there's nothing in the FIFO
                        //

                        dwWaitTime = 0;
                    } else {

                        //
                        // amount of time to wait next iteration is amount of
                        // time until expiration of originally specified period
                        //

                        dwWaitTime = dwTimeout - dwElapsedTime;
                    }
                }
                continue;
            } else if (status == WAIT_OBJECT_0 + 1) {

                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    if (msg.message == WM_QUIT) {
                         return WAIT_ABANDONED;
                    } else {
                        DispatchMessage(&msg);
                    }
                }
                continue;
            }

            //
            // WAIT_TIMEOUT (or WAIT_ABANDONED (?))
            //

            break;
        }
        return WAIT_TIMEOUT;
    }

    DWORD RemoveTagged(DWORD_PTR Tag, BOOL IsTag) {

        DWORD count = 0;

        m_qlock.Acquire();

        CPrioritizedListEntry * pEntry = (CPrioritizedListEntry *)m_queue.Next();
        CPrioritizedListEntry * pPrev = (CPrioritizedListEntry *)m_queue.Head();

        while (pEntry != m_queue.Head()) {

            CWorkItem * pItem = (CWorkItem *)pEntry;

            if (pItem->Match(Tag, IsTag)) {
                pItem->Remove();
                --m_queueSize;
                delete pItem;
                ++count;
                if (!IsTag) {
                    break;
                }
            } else {
                pPrev = pEntry;
            }
            pEntry = (CPrioritizedListEntry *)pPrev->Next();
        }
        m_qlock.Release();
        return count;
    }

    DWORD GetQueueSize(VOID) const {
        return m_queueSize;
    }

    VOID PurgeWorkItems(VOID) {
        m_qlock.Acquire();

        CWorkItem * pItem;

        while ((pItem = DequeueWorkItem()) != NULL) {
            delete pItem;
        }
        m_qlock.Release();
    }

    VOID Signal(VOID) {
        if (m_event != NULL) {
            SetEvent(m_event);
        }
    }

    DWORD CreateWorkerThread(VOID) {

        HANDLE hThread;
        DWORD error = ERROR_SUCCESS;

        error = StartThread((LPTHREAD_START_ROUTINE)WorkerThread,
                            &hThread,
                            FALSE
                            );
        if (error == ERROR_SUCCESS) {
            AddWorker();
#if DBG
            if (m_totalWorkerThreads > m_maxWorkerThreadsCreated) {
                m_maxWorkerThreadsCreated = m_totalWorkerThreads;
            }
//char buf[256];
//wsprintf(buf, ">>>> started worker thread. Total = %d/%d. Avail = %d. Factor = %d/%d\n",
//         m_totalWorkerThreads,
//         m_maxWorkerThreadsCreated,
//         m_availableWorkerThreads,
//         m_qFactor,
//         m_qFactorMax
//         );
//OutputDebugString(buf);
#endif
            CloseHandle(hThread); // thread handle not required
            return ERROR_SUCCESS;
        }

        return error;
    }

    VOID TerminateThreads(DWORD Limit) {
        while (m_totalWorkerThreads > Limit) {
            Signal();
            SleepEx(0, FALSE);
        }
    }

    VOID AddWorker(VOID) {
        InterlockedIncrement((LPLONG)&m_totalWorkerThreads);
        MakeAvailable();
    }

    VOID RemoveWorker(VOID) {
        MakeUnavailable();
        InterlockedDecrement((LPLONG)&m_totalWorkerThreads);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\tpstimer.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tpstimer.h

Abstract:

    Timer classes. Moved out of tpsclass.h

    Contents:
        CTimer
        CTimerQueueEntry
        CTimerQueueList
        CTimerQueue
        CTimerRequest
        CTimerQueueDeleteRequest
        CTimerAddRequest
        CTimerChangeRequest
        CTimerCancelRequest

Author:

    Richard L Firth (rfirth) 08-Aug-1998

Revision History:

    08-Aug-1998 rfirth
        Created

--*/

//
// manifests
//

#define TPS_TIMER_IN_USE    0x80000000
#define TPS_TIMER_CANCELLED 0x40000000

//
// external data
//

extern LONG g_UID;

//
// classes
//

//
// CTimer
//

class CTimer {

private:

    HANDLE m_hQueue;    // address of owning queue
    HANDLE m_hTimer;    // timer ordinal
    WAITORTIMERCALLBACKFUNC m_pfnCallback;
    LPVOID m_pContext;
    DWORD m_dwPeriod;
    DWORD m_dwFlags;

public:

    CTimer(HANDLE hQueue,
           WAITORTIMERCALLBACKFUNC pfnCallback,
           LPVOID pContext,
           DWORD dwPeriod,
           DWORD dwFlags
           )
    {
        m_hQueue = hQueue;

        //
        // FEATURE - (prevent this scenario) not industrial-strength: can have 2 timers with same ID
        //

        m_hTimer = IntToPtr(InterlockedIncrement(&g_UID));
        m_pfnCallback = pfnCallback;
        m_pContext = pContext;
        m_dwPeriod = dwPeriod;
        m_dwFlags = dwFlags;
    }

    HANDLE GetHandle(VOID) const {
        return m_hTimer;
    }

    HANDLE GetQueue(VOID) const {
        return m_hQueue;
    }

    VOID Execute(VOID) {
        if (m_dwFlags & TPS_EXECUTEIO) {

            //
            // NT code does nothing with this flag. We should queue
            // request to I/O worker thread
            //

            ASSERT(!(m_dwFlags & TPS_EXECUTEIO));

        }
        m_pfnCallback(m_pContext, TRUE);
    }

    VOID SetPeriod(DWORD dwPeriod) {
        m_dwPeriod = dwPeriod;
    }

    DWORD GetPeriod(VOID) const {
        return m_dwPeriod;
    }

    BOOL IsOneShot(VOID) {
        return GetPeriod() == 0;
    }

    VOID SetInUse(VOID) {
        m_dwFlags |= TPS_TIMER_IN_USE;
    }

    VOID ResetInUse(VOID) {
        m_dwFlags &= ~TPS_TIMER_IN_USE;
    }

    BOOL IsInUse(VOID) {
        return (m_dwFlags & TPS_TIMER_IN_USE) ? TRUE : FALSE;
    }

    VOID SetCancelled(VOID) {
        m_dwFlags |= TPS_TIMER_CANCELLED;
    }

    BOOL IsCancelled(VOID) {
        return (m_dwFlags & TPS_TIMER_CANCELLED) ? TRUE : FALSE;
    }
};

//
// CTimerQueueEntry
//

class CTimerQueueEntry : public CTimedListEntry, public CTimer {

private:

public:

    CDoubleLinkedList m_TimerList;

    CTimerQueueEntry(HANDLE hQueue,
                     WAITORTIMERCALLBACKFUNC pfnCallback,
                     LPVOID pContext,
                     DWORD dwDueTime,
                     DWORD dwPeriod,
                     DWORD dwFlags
                     ) :
                     CTimedListEntry(dwDueTime),
                     CTimer(hQueue,
                            pfnCallback,
                            pContext,
                            dwPeriod,
                            dwFlags
                            )
    {
        CDoubleLinkedListEntry::Init();
        m_TimerList.Init();
    }

    ~CTimerQueueEntry() {
        m_TimerList.Remove();
    }

    VOID SetPeriodicTime(VOID) {
        SetTimeStamp(ExpiryTime());
        SetWaitTime(GetPeriod());
    }

    CDoubleLinkedList * TimerListHead(VOID) {
        return m_TimerList.Head();
    }
};

//
// CTimerQueueList
//

class CTimerQueueList {

private:

    CDoubleLinkedList m_QueueList;
    CDoubleLinkedList m_TimerList;

public:

    VOID Init(VOID) {
        m_QueueList.Init();
        m_TimerList.Init();
    }

    CDoubleLinkedList * QueueListHead(VOID) {
        return m_QueueList.Head();
    }

    CDoubleLinkedList * TimerListHead(VOID) {
        return m_TimerList.Head();
    }

    CDoubleLinkedListEntry * FindQueue(CDoubleLinkedListEntry * pEntry) {
        return m_QueueList.FindEntry(pEntry);
    }

    BOOL Wait(VOID) {

        DWORD dwWaitTime = INFINITE;
        CTimedListEntry * pTimer = (CTimedListEntry * )m_TimerList.Next();

        ASSERT(pTimer != NULL);

        if (pTimer != (CTimedListEntry * )m_TimerList.Head()) {
            dwWaitTime = pTimer->TimeToWait();
        }

        //
        //  HACKHACK (tnoonan):  Can't just check for 0 since
        //  Win95 will always return WAIT_TIMEOUT (despite what
        //  the docs say).
        //

        DWORD dwResult = SleepEx(dwWaitTime, TRUE);

        return (dwResult == 0) || (dwResult == WAIT_TIMEOUT);
    }

    VOID ProcessCompletions(VOID) {

        //
        // run down list of all timers; for each expired timer, execute its
        // completion handler. If one-shot timer, delete it, else reset the
        // timer and re-insert it in the list
        //
        // If a timer is re-inserted further down the list, we may visit it
        // again before we have completed the traversal. This is OK: either it
        // has already expired, in which case we execute again, or it hasn't
        // expired, in which case we terminate the traversal
        //

        CTimerQueueEntry * pTimer;
        CTimerQueueEntry * pNext = (CTimerQueueEntry *)m_TimerList.Next();

        do {
            pTimer = pNext;
            if ((pTimer == (CTimerQueueEntry *)m_TimerList.Head())
            || !pTimer->IsTimedOut()) {
                break;
            }
            pNext = (CTimerQueueEntry * )pTimer->Next();
            pTimer->Remove();
            pTimer->SetInUse();
            pTimer->Execute();
            if (pTimer->IsOneShot() || pTimer->IsCancelled()) {
                delete pTimer;
            } else {
                pTimer->SetPeriodicTime();
                pTimer->ResetInUse();
                pTimer->InsertBack(m_TimerList.Head());
            }
        } while (TRUE);
    }
};

//
// CTimerQueue
//

class CTimerQueue : public CDoubleLinkedList {

private:

    CDoubleLinkedList m_TimerList;

public:

    CTimerQueue(CTimerQueueList * pList) {
        CDoubleLinkedList::Init();
        m_TimerList.Init();
        InsertTail(pList->QueueListHead());
    }

    ~CTimerQueue() {
        Remove();
    }

    CDoubleLinkedList * TimerListHead(VOID) {
        return m_TimerList.Head();
    }

    CTimerQueueEntry * FindTimer(HANDLE hTimer) {

        CDoubleLinkedListEntry * pEntry;

        for (pEntry = m_TimerList.Next();
             pEntry != m_TimerList.Head();
             pEntry = pEntry->Next()) {

            CTimerQueueEntry * pTimer;

            pTimer = CONTAINING_RECORD(pEntry, CTimerQueueEntry, m_TimerList);
            if (pTimer->GetHandle() == hTimer) {
                return pTimer;
            }
        }
        return NULL;
    }

    VOID DeleteTimers(VOID) {

        CDoubleLinkedListEntry * pEntry;

        for (pEntry = m_TimerList.Next();
             pEntry != m_TimerList.Head();
             pEntry = m_TimerList.Next()) {

            CTimerQueueEntry * pTimer;

            pTimer = CONTAINING_RECORD(pEntry, CTimerQueueEntry, m_TimerList);

            //
            // remove timer from global timer list (linked on CDoubleLinkedList)
            //

            pTimer->Remove();

            //
            // timer will be removed from m_TimerList by its destructor
            //

            delete pTimer;
        }
    }
};

//
// CTimerRequest
//

class CTimerRequest {

private:

    BOOL m_bCompleted;
    DWORD m_dwStatus;

public:

    CTimerRequest() {
        m_bCompleted = FALSE;
        m_dwStatus = ERROR_SUCCESS;
    }

    VOID SetComplete(VOID) {
        m_bCompleted = TRUE;
    }

    VOID WaitForCompletion(VOID) {
        while (!m_bCompleted) {
            SleepEx(0, TRUE);
        }
    }

    VOID SetStatus(DWORD dwStatus) {
        m_dwStatus = dwStatus;
    }

    VOID SetCompletionStatus(DWORD dwStatus) {
        SetStatus(dwStatus);
        SetComplete();
    }

    BOOL SetThreadStatus(VOID) {
        if (m_dwStatus == ERROR_SUCCESS) {
            return TRUE;
        }
        SetLastError(m_dwStatus);
        return FALSE;
    }
};

//
// CTimerQueueDeleteRequest
//

class CTimerQueueDeleteRequest : public CTimerRequest {

private:

    HANDLE m_hQueue;

public:

    CTimerQueueDeleteRequest(HANDLE hQueue) : CTimerRequest() {
        m_hQueue = hQueue;
    }

    HANDLE GetQueue(VOID) const {
        return m_hQueue;
    }
};

//
// CTimerAddRequest
//

class CTimerAddRequest : public CTimerQueueEntry, public CTimerRequest {

public:

    CTimerAddRequest(HANDLE hQueue,
                     WAITORTIMERCALLBACKFUNC pfnCallback,
                     LPVOID pContext,
                     DWORD dwDueTime,
                     DWORD dwPeriod,
                     DWORD dwFlags
                     ) :
                     CTimerQueueEntry(hQueue,
                                      pfnCallback,
                                      pContext,
                                      dwDueTime,
                                      dwPeriod,
                                      dwFlags
                                      ),
                     CTimerRequest()
    {
    }

    HANDLE GetHandle(VOID) const {
        return CTimer::GetHandle();
    }

    CTimerQueue * GetQueue(VOID) const {
        return (CTimerQueue *)CTimer::GetQueue();
    }
};

//
// CTimerChangeRequest
//

class CTimerChangeRequest : public CTimerRequest {

private:

    HANDLE m_hQueue;
    HANDLE m_hTimer;
    DWORD m_dwDueTime;
    DWORD m_dwPeriod;

public:

    CTimerChangeRequest(HANDLE hQueue,
                        HANDLE hTimer,
                        DWORD dwDueTime,
                        DWORD dwPeriod
                        ) :
                        CTimerRequest()
    {
        m_hQueue = hQueue;
        m_hTimer = hTimer;
        m_dwDueTime = dwDueTime;
        m_dwPeriod = dwPeriod;
    }

    HANDLE GetQueue(VOID) const {
        return m_hQueue;
    }

    HANDLE GetTimer(VOID) const {
        return m_hTimer;
    }

    DWORD GetDueTime(VOID) const {
        return m_dwDueTime;
    }

    DWORD GetPeriod(VOID) const {
        return m_dwPeriod;
    }
};

//
// CTimerCancelRequest
//

class CTimerCancelRequest : public CTimerRequest {

private:

    HANDLE m_hQueue;
    HANDLE m_hTimer;

public:

    CTimerCancelRequest(HANDLE hQueue, HANDLE hTimer) : CTimerRequest() {
        m_hQueue = hQueue;
        m_hTimer = hTimer;
    }

    HANDLE GetQueue(VOID) const {
        return m_hQueue;
    }

    HANDLE GetTimer(VOID) const {
        return m_hTimer;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\tpswait.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpswait.cpp

Abstract:

    Contains Win32 thread pool services wait functions

    Contents:
        TerminateWaiters
        SHRegisterWaitForSingleObject
        SHUnregisterWait
        (InitializeWaitThreadPool)
        (FindWaitThreadInfo)
        (AddWait)
        (RemoveWait)
        (WaitThread)

Author:

    Richard L Firth (rfirth) 10-Feb-1998

Environment:

    Win32 user-mode

Notes:

    Taken from NT-specific code written by Gurdeep Singh Pall (gurdeep)

Revision History:

    10-Feb-1998 rfirth
        Created

--*/

#include "priv.h"
#include "threads.h"
#include "tpsclass.h"
#include "tpswait.h"

//
// private prototypes
//

PRIVATE
DWORD
InitializeWaitThreadPool(
    VOID
    );

PRIVATE
DWORD
FindWaitThreadInfo(
    OUT CWaitThreadInfo * * pInfo
    );

PRIVATE
VOID
AddWait(
    IN OUT CWaitAddRequest * pRequest
    );

PRIVATE
VOID
RemoveWait(
    IN CWaitRemoveRequest * pRequest
    );

PRIVATE
VOID
WaitThread(
    IN HANDLE hEvent
    );

//
// global data
//

CDoubleLinkedList g_WaitThreads;
CCriticalSection_NoCtor g_WaitCriticalSection;
BOOL g_StartedWaitInitialization = FALSE;
BOOL g_CompletedWaitInitialization = FALSE;
BOOL g_bDeferredWaiterTermination = FALSE;

//
// functions
//

VOID
TerminateWaiters(
    VOID
    )

/*++

Routine Description:

    Terminate waiter threads and global variables

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_CompletedWaitInitialization) {
        g_WaitCriticalSection.Acquire();
        while (!g_WaitThreads.IsEmpty()) {

            CWaitThreadInfo * pInfo;

            pInfo = (CWaitThreadInfo *)g_WaitThreads.RemoveHead();

            HANDLE hThread = pInfo->GetHandle();

            pInfo->SetHandle(NULL);
            QueueNullFunc(hThread);
            SleepEx(0, FALSE);
        }
        g_WaitCriticalSection.Release();
        g_WaitCriticalSection.Terminate();
        g_StartedWaitInitialization = FALSE;
        g_CompletedWaitInitialization = FALSE;
    }
    if (TlsGetValue(g_TpsTls) == (LPVOID)TPS_WAITER_SIGNATURE) {
        g_bDeferredWaiterTermination = TRUE;
    }
}

LWSTDAPI_(HANDLE)
SHRegisterWaitForSingleObject(
    IN HANDLE hObject,
    IN WAITORTIMERCALLBACKFUNC pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwWaitTime,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    This routine adds a new wait request to the pool of objects being waited on.

Arguments:

    hObject     - handle to the object to be waited on

    pfnCallback - routine called when the wait completes or a timeout occurs

    pContext    - opaque pointer passed in as an argument to pfnCallback

    dwWaitTime  - Timeout for the wait in milliseconds. 0 means dont timeout.

    lpszLibrary - if specified, name of library (DLL) to reference

    dwFlags     - flags modifying request:

                    SRWSO_NOREMOVE
                        - once the handle becomes signalled, do not remove it
                          from the handle array. Intended to be used with
                          auto-reset events which become unsignalled again as
                          soon as the waiting thread is made runnable

Return Value:

    HANDLE
        Success - Non-NULL handle of created wait object

        Failure - NULL. Call GetLastError() for error code

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    HANDLE hWait = NULL;
    DWORD error = ERROR_SUCCESS;

    if (g_bTpsTerminating) {
        error = ERROR_SHUTDOWN_IN_PROGRESS; // error code? looks valid - justmann
        goto exit;
    }

    if (dwFlags & SRWSO_INVALID_FLAGS) {
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //DWORD dwHandleFlags;
    //
    //if (!GetHandleInformation(hObject, &dwHandleFlags)) {
    //
    //    //
    //    // error == ERROR_SUCCESS returns GetHandleInformation() last error
    //    //
    //
    //    ASSERT(error == ERROR_SUCCESS);
    //
    //    goto exit;
    //}

    //
    // GetHandleInformation() doesn't work on Win95
    //

    if (WaitForSingleObject(hObject, 0) == WAIT_FAILED) {

        //
        // error == ERROR_SUCCESS returns WaitForSingleObject() last error
        //

        ASSERT(error == ERROR_SUCCESS);

        goto exit;
    }

    if (IsBadCodePtr((FARPROC)pfnCallback)) {
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // initialize wait thread pool if it isn't already done
    //

    if (!g_CompletedWaitInitialization) {
        error = InitializeWaitThreadPool();
        if (error != ERROR_SUCCESS) {
            goto exit;
        }
    }

    //
    // find or create a wait thread that can accomodate another wait request
    //

    CWaitThreadInfo * pInfo;

    error = FindWaitThreadInfo(&pInfo);
    if (error == ERROR_SUCCESS) {

        CWaitAddRequest request(hObject,
                                pfnCallback,
                                pContext,
                                dwWaitTime,
                                dwFlags,
                                pInfo
                                );

        //
        // queue an APC to the wait thread
        //

        BOOL bSuccess = QueueUserAPC((PAPCFUNC)AddWait,
                                     pInfo->GetHandle(),
                                     (ULONG_PTR)&request
                                     );

        ASSERT(bSuccess);

        if (bSuccess) {

            //
            // relinquish the timeslice until the other thread has initialized
            //

            request.WaitForCompletion();

            //
            // the returned handle is the address of the wait object copied to
            // the wait thread's stack
            //

            hWait = request.GetWaitPointer();
        }
        pInfo->Release();
    }

exit:

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
    }
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    return hWait;
}

LWSTDAPI_(BOOL)
SHUnregisterWait(
    IN HANDLE hWait
    )

/*++

Routine Description:

    This routine removes the specified wait from the pool of objects being waited
    on. This routine will block until all callbacks invoked as a result of this
    wait have been executed. This function MUST NOT be invoked inside the
    callback routines.

Arguments:

    hWait   - 'handle' indentifying the wait request

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for error code

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    BOOL bSuccess = FALSE;
    DWORD error = ERROR_SUCCESS;

    if (hWait) {
        if (!g_bTpsTerminating) {

            CWaitThreadInfo * pInfo = ((CWait *)hWait)->GetThreadInfo();
            CWaitRemoveRequest request(hWait);

            //
            // lock the thread control block
            //

            pInfo->Acquire();

            //
            // queue an APC to the wait thread
            //

            if (QueueUserAPC((PAPCFUNC)RemoveWait,
                             pInfo->GetHandle(),
                             (ULONG_PTR)&request
                             )) {

                //
                // relinquish the timeslice until the other thread has initialized
                //

                request.WaitForCompletion();
                if (!(bSuccess = (request.GetWaitPointer() != NULL))) {
                    error = ERROR_OBJECT_NOT_FOUND; // error code? looks valid -justmann
                }
            }

            //
            // release lock to the thread control block
            //

            pInfo->Release();
        } else {
            error = ERROR_SHUTDOWN_IN_PROGRESS; // error code? looks valid -justmann
        }
    } else {
        error = ERROR_INVALID_PARAMETER;
    }
    if (error != ERROR_SUCCESS) {
        SetLastError(error);
    }
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    return bSuccess;
}

//
// private functions
//

PRIVATE
DWORD
InitializeWaitThreadPool(
    VOID
    )

/*++

Routine Description:

    This routine initializes all aspects of the thread pool.

Arguments:

    None

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (!InterlockedExchange((LPLONG)&g_StartedWaitInitialization, TRUE)) {
        g_WaitCriticalSection.Init();
        g_WaitThreads.Init();
        g_CompletedWaitInitialization = TRUE;
    } else {

        //
        // relinquish the timeslice until the other thread has initialized
        //

        while (!g_CompletedWaitInitialization) {
            SleepEx(0, FALSE);  // Sleep(0) without an additional call/return
        }
    }
    return error;
}

PRIVATE
DWORD
FindWaitThreadInfo(
    OUT CWaitThreadInfo * * ppInfo
    )

/*++

Routine Description:

    Walks thru the list of wait threads and finds one which can accomodate
    another wait. If one is not found then a new thread is created.

    This routine returns with the thread's WaitThreadCriticalSecton owned if it
    is successful.

Arguments:

    ppInfo  - pointer to pointer to returned control block

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    HANDLE hThread = NULL;

    //
    // take exclusive lock to the wait threads list
    //

    g_WaitCriticalSection.Acquire();

    do {

        DWORD error;

        //
        // walk thru the list of Wait Threads and find a Wait thread that can
        // accomodate a new wait request
        //

        //
        // *Consider* finding a wait thread with least # of waits to facilitate
        // better load balancing of waits
        //

        for (CWaitThreadInfo * pInfo = (CWaitThreadInfo *)g_WaitThreads.Next();
             !g_WaitThreads.IsHead(pInfo);
             pInfo = (CWaitThreadInfo *)pInfo->Next()) {


            //
            // slight cheese: if hThread is not NULL then its because we just
            // created a new thread. We know we have g_WaitCriticalSection held
            // and no other thread can be accessing the new thread's control
            // block, so we can now write in the handle to be used in future
            // calls to QueueUserAPC. This saves us having to duplicate the
            // thread handle in the new thread
            //

            if (hThread != NULL) {
                pInfo->SetHandle(hThread);
            }

            //
            // take exclusive lock to the wait thread control block
            //

            pInfo->Acquire();

            //
            // wait threads can accomodate up to MAX_WAITS (WaitForMultipleObject
            // limit)
            //

            if (pInfo->IsAvailableEntry()) {

                //
                // found a thread with some wait slots available. Release lock
                // on the wait threads list
                //

                *ppInfo = pInfo;
                g_WaitCriticalSection.Release();
                return ERROR_SUCCESS;
            }

            //
            // release lock to thread control block
            //

            pInfo->Release();
        }

        //
        // if we reach here, we don't have any more wait threads so create more
        //

        error = StartThread((LPTHREAD_START_ROUTINE)WaitThread, &hThread, TRUE);

        //
        // if thread creation fails then return the failure to caller
        //

        if (error != ERROR_SUCCESS) {

            ASSERT(FALSE);

            g_WaitCriticalSection.Release();
            return error;
        }

        //
        // loop back now that we have created another thread and put new wait
        // request in new thread
        //

    } while(TRUE);
}

PRIVATE
VOID
AddWait(
    IN OUT CWaitAddRequest * pRequest
    )

/*++

Routine Description:

    This routine is used for adding waits to the wait thread. It is executed in
    an APC.

Arguments:

    pRequest    - pointer to request object

Return Value:

    None.

--*/

{
    if (!g_bTpsTerminating) {

        CWaitThreadInfo * pInfo = pRequest->GetThreadInfo();
        CWait * pWait = pInfo->GetFreeWaiter();

        //
        // copy relevant fields from request object. C++ knows how to pull CWait
        // object out of CWaitAddRequest object. Insert the wait request object in
        // the list of active waits, in increasing expiration time order
        //

        *pWait = *pRequest;
        pInfo->InsertWaiter(pWait);

        //
        // return to the caller the address of the wait object on the wait thread's
        // stack and indicate to the calling thread that this request is complete
        //

        pRequest->SetWaitPointer(pWait);
    }
    pRequest->SetComplete();
}

PRIVATE
VOID
RemoveWait(
    IN CWaitRemoveRequest * pRequest
    )

/*++

Routine Description:

    This routine is used for deleting the specified wait. It is executed in an
    APC.

Arguments:

    pRequest    - pointer to request object

Return Value:

    None.

--*/

{
    if (!g_bTpsTerminating) {
        if (!pRequest->GetWaitPointer()->GetThreadInfo()->RemoveWaiter(pRequest->GetWaitPointer())) {
            pRequest->SetWaitPointer(NULL);
        }
    }
    pRequest->SetComplete();
}

PRIVATE
VOID
WaitThread(
    IN HANDLE hEvent
    )

/*++

Routine Description:

    This routine is used for all waits in the wait thread pool

Arguments:

    hEvent  - event handle to signal once initialization is complete

Return Value:

    None.

--*/

{
    HMODULE hDll = LoadLibrary(g_cszShlwapi);

    ASSERT(hDll != NULL);
    ASSERT(g_TpsTls != 0xFFFFFFFF);

    TlsSetValue(g_TpsTls, (LPVOID)TPS_WAITER_SIGNATURE);

    CWaitThreadInfo waitInfo(&g_WaitThreads);

    SetEvent(hEvent);

    while (!g_bTpsTerminating || (g_ActiveRequests != 0)) {

        DWORD dwIndex = waitInfo.Wait(waitInfo.GetWaitTime());

        if (g_bTpsTerminating && (g_ActiveRequests == 0)) {
            break;
        }
        if (dwIndex == WAIT_TIMEOUT) {
            waitInfo.ProcessTimeouts();
#pragma warning(push)
#pragma warning(disable:4296)
        } else if ((dwIndex >= WAIT_OBJECT_0)
#pragma warning(pop)
                   && (dwIndex < (WAIT_OBJECT_0 + waitInfo.GetObjectCount()))) {
            waitInfo.ProcessCompletion(dwIndex);
        } else if ((dwIndex == 0xFFFFFFFF) && GetLastError() == ERROR_INVALID_HANDLE) {
            waitInfo.PurgeInvalidHandles();
        } else {

            ASSERT(dwIndex == WAIT_IO_COMPLETION);

        }
    }
    while (waitInfo.GetHandle() != NULL) {
        SleepEx(0, FALSE);
    }
    if (GetCurrentThreadId() == g_dwTerminationThreadId) {
        g_bTpsTerminating = FALSE;
        g_bDeferredWaiterTermination = FALSE;
        g_dwTerminationThreadId = 0;
    }
    FreeLibraryAndExitThread(hDll, ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\tpswork.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpswork.cpp

Abstract:

    Contains Win32 thread pool services worker thread functions

    Contents:
        SHSetThreadPoolLimits
        SHTerminateThreadPool
        SHQueueUserWorkItem
        SHCancelUserWorkItems
        TerminateWorkers
        TpsEnter
        (InitializeWorkerThreadPool)
        (StartIOWorkerThread)
        (QueueIOWorkerRequest)
        (IOWorkerThread)
        (ExecuteIOWorkItem)
        (CThreadPool::WorkerThread)
        (CThreadPool::Worker)

Author:

    Richard L Firth (rfirth) 10-Feb-1998

Environment:

    Win32 user-mode

Revision History:

    10-Feb-1998 rfirth
        Created

    12-Aug-1998 rfirth
        Rewritten for DEMANDTHREAD and LONGEXEC work items. Officially
        divergent from original which was based on NT5 base thread pool API

--*/

#include "priv.h"
#include "threads.h"
#include "tpsclass.h"
#include "tpswork.h"

//
// private prototypes
//
typedef BOOL (WINAPI * t_QueueUserWorkItem)(LPTHREAD_START_ROUTINE, LPVOID, BOOL);

struct WorkItem {
    LPTHREAD_START_ROUTINE  pfnCallback;
    LPVOID                  pContext;
    HMODULE                 hModuleToFree;
};


DWORD
InitializeWorkerThreadPool(
    VOID
    );

PRIVATE
DWORD
StartIOWorkerThread(
    VOID
    );

PRIVATE
DWORD
QueueIOWorkerRequest(
    IN LPTHREAD_START_ROUTINE pfnCallback,
    IN LPVOID pContext
    );

PRIVATE
VOID
IOWorkerThread(
    IN HANDLE hEvent
    );

PRIVATE
VOID
ExecuteIOWorkItem(
    IN CIoWorkerRequest * pPacket
    );


PRIVATE
VOID
ExecuteWorkItem(
    IN WorkItem *pItem
    );

//
// global data
//

BOOL g_StartedWorkerInitialization = FALSE;
BOOL g_CompletedWorkerInitialization = FALSE;
BOOL g_bTpsTerminating = FALSE;

DWORD g_NumIoWorkerThreads = 0;
DWORD g_NumIoWorkRequests = 0;
DWORD g_LastIoThreadCreationTickCount = 0;
DWORD g_MaximumIoThreads = MAX_IO_WORKER_THREADS;
DWORD g_MaximumIoQueueDepth = NEW_THREAD_THRESHOLD;
DWORD g_ThreadCreationDelta = THREAD_CREATION_DAMPING_TIME;

CDoubleLinkedList g_IoWorkerThreads;
CCriticalSection_NoCtor g_IoWorkerCriticalSection;
CThreadPool g_ThreadPool;
DWORD g_dwWorkItemId = 0;

const char g_cszShlwapi[] = "SHLWAPI.DLL";

DWORD g_ActiveRequests = 0;
DWORD g_dwTerminationThreadId = 0;
BOOL g_bDeferredWorkerTermination = FALSE;



//
// functions
//

LWSTDAPI_(BOOL)
SHSetThreadPoolLimits(
    IN PSH_THREAD_POOL_LIMITS pLimits
    )

/*++

Routine Description:

    Change internal settings

Arguments:

    pLimits - pointer to SH_THREAD_POOL_LIMITS structure containing limits
              to set

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. See GetLastError() for more info

--*/

{
    if (!pLimits || (pLimits->dwStructSize != sizeof(SH_THREAD_POOL_LIMITS))) {
        return ERROR_INVALID_PARAMETER;
    }

    BOOL success = FALSE;
    DWORD error = ERROR_SHUTDOWN_IN_PROGRESS; // error code? look valid -justmann

    if (!g_bTpsTerminating) {
        InterlockedIncrement((LPLONG)&g_ActiveRequests);
        if (!g_bTpsTerminating) {
            error = ERROR_SUCCESS;
            if (!g_CompletedWorkerInitialization) {
                error = InitializeWorkerThreadPool();
            }
            if (error == ERROR_SUCCESS) {
                g_ThreadPool.SetLimits(pLimits->dwMinimumWorkerThreads,
                                       pLimits->dwMaximumWorkerThreads,
                                       pLimits->dwMaximumWorkerQueueDepth,
                                       pLimits->dwWorkerThreadIdleTimeout,
                                       pLimits->dwWorkerThreadCreationDelta
                                       );
                g_MaximumIoThreads = pLimits->dwMaximumIoWorkerThreads;
                g_MaximumIoQueueDepth = pLimits->dwMaximumIoWorkerQueueDepth;
                g_ThreadCreationDelta = pLimits->dwIoWorkerThreadCreationDelta;
                success = TRUE;
            }
        }
        InterlockedDecrement((LPLONG)&g_ActiveRequests);
    }
    if (success) {
        return success;
    }
    SetLastError(error);
    return success;
}

LWSTDAPI_(BOOL)
SHTerminateThreadPool(
    VOID
    )

/*++

Routine Description:

    Required to clean up threads before unloading SHLWAPI

Arguments:

    None.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    if (InterlockedExchange((PLONG)&g_bTpsTerminating, TRUE)) {
        return TRUE;
    }

    //
    // wait until all in-progress requests have finished
    //

    while (g_ActiveRequests != 0) {
        SleepEx(0, FALSE);
    }

    //
    // kill all I/O worker threads. Queued work items will be lost
    //

    TerminateWorkers();

    //
    // kill all timer threads
    //

    TerminateTimers();

    //
    // kill all wait threads
    //

    TerminateWaiters();

    if (!g_bDeferredWorkerTermination
        && !g_bDeferredTimerTermination
        && !g_bDeferredWaiterTermination) {
        g_dwTerminationThreadId = 0;
        g_bTpsTerminating = FALSE;
    } else {
        g_dwTerminationThreadId = GetCurrentThreadId();
    }
    return TRUE;
}

LWSTDAPI_(BOOL)
SHQueueUserWorkItem(
    IN LPTHREAD_START_ROUTINE pfnCallback,
    IN LPVOID pContext,
    IN LONG lPriority,
    IN DWORD_PTR dwTag,
    OUT DWORD_PTR * pdwId OPTIONAL,
    IN LPCSTR pszModule OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Queues a work item and associates a user-supplied tag for use by
    SHCancelUserWorkItems()

    N.B. IO work items CANNOT be cancelled due to the fact that they are
    queued as APCs and there is no OS support to revoke an APC

Arguments:

    pfnCallback - caller-supplied function to call

    pContext    - caller-supplied context argument to pfnCallback

    lPriority   - relative priority of non-IO work item. Default is 0

    dwTag       - caller-supplied tag for non-IO work item if TPS_TAGGEDITEM

    pdwId       - pointer to returned ID. Pass NULL if not required. ID will be
                  0 for an IO work item

    pszModule   - if specified, name of library (DLL) to load and free so that
                  the dll will reamin in our process for the lifetime of the work
                  item.

    dwFlags     - flags modifying request:

                    TPS_EXECUTEIO
                        - execute work item in I/O thread. If set, work item
                          cannot be tagged (and therefore cannot be subsequently
                          cancelled) and cannot have an associated priority
                          (both tag and priority are ignored for I/O work items)

                    TPS_TAGGEDITEM
                        - the dwTag field is meaningful

                    TPS_DEMANDTHREAD
                        - a thread will be created for this work item if one is
                          not currently available. DEMANDTHREAD work items are
                          queued at the head of the work queue. That is, they
                          get the highest priority

                    TPS_LONGEXECTIME
                        - caller expects this work item to take relatively long
                          time to complete (e.g. it could be in a UI loop). Work
                          items thus described remove a thread from the pool for
                          an indefinite amount of time

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. See GetLastError() for more info

--*/

{
    DWORD error;
    static t_QueueUserWorkItem pfQueueUserWorkItem = NULL;

    if (dwFlags & TPS_INVALID_FLAGS) {
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    error = TpsEnter();
    if (error != ERROR_SUCCESS) {
        goto exit;
    }

    if (!g_CompletedWorkerInitialization) {
        error = InitializeWorkerThreadPool();
        if (error != ERROR_SUCCESS) {
            goto leave;
        }
    }

    if (!pfQueueUserWorkItem && IsOS(OS_WHISTLERORGREATER))
    {
        HMODULE hKernel32 = GetModuleHandle("KERNEL32.DLL");
        if (hKernel32)
        {
            pfQueueUserWorkItem = (t_QueueUserWorkItem)GetProcAddress(hKernel32, "QueueUserWorkItem");
        }
    }

    if (!(dwFlags & TPS_EXECUTEIO)) 
    {
        if (pfQueueUserWorkItem)
        {
            // Use NT Thread pool!

            WorkItem *pItem = new WorkItem;
            if (pItem)
            {
                pItem->pfnCallback = pfnCallback;
                pItem->pContext = pContext;
                if (pszModule && *pszModule)
                {
                    pItem->hModuleToFree = LoadLibrary(pszModule);
                }
                ULONG uFlags = WT_EXECUTEDEFAULT;
                if (dwFlags & TPS_LONGEXECTIME)
                    uFlags |= WT_EXECUTELONGFUNCTION;

                error = ERROR_SUCCESS;
                if (!pfQueueUserWorkItem((LPTHREAD_START_ROUTINE)ExecuteWorkItem, (PVOID)pItem, uFlags))
                {
                    error = GetLastError();
                    if (pItem->hModuleToFree)
                        FreeLibrary(pItem->hModuleToFree);

                    delete pItem;
                }
            } 
            else 
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            error = g_ThreadPool.QueueWorkItem((FARPROC)pfnCallback,
                                               (ULONG_PTR)pContext,
                                               lPriority,
                                               dwTag,
                                               pdwId,
                                               pszModule,
                                               dwFlags
                                               );
        }
    } 
    else 
    {

        DWORD threshold = (g_NumIoWorkerThreads < g_MaximumIoThreads)
                        ? (g_MaximumIoQueueDepth * g_NumIoWorkerThreads)
                        : 0xffffffff;

        g_IoWorkerCriticalSection.Acquire();

        if ((g_NumIoWorkerThreads == 0)
            || ((g_NumIoWorkRequests > threshold)
            && (g_LastIoThreadCreationTickCount + g_ThreadCreationDelta
                < GetTickCount()))) {
            error = StartIOWorkerThread();
        }
        if (error == ERROR_SUCCESS) {
            error = QueueIOWorkerRequest(pfnCallback, pContext);
        }

        g_IoWorkerCriticalSection.Release();

        if (pdwId != NULL) {
            *pdwId = (DWORD_PTR)NULL;
        }
    }

leave:

    TpsLeave();

exit:

    BOOL success = TRUE;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;
    }
    return success;
}

LWSTDAPI_(DWORD)
SHCancelUserWorkItems(
    IN DWORD_PTR dwTagOrId,
    IN BOOL bTag
    )

/*++

Routine Description:

    Cancels one or more queued work items. By default, if ID is supplied, only
    one work item can be cancelled. If tag is supplied, all work items with same
    tag will be deleted

Arguments:

    dwTagOrId   - user-supplied tag or API-supplied ID of work item(s) to
                  cancel. Used as search key

    bTag        - TRUE if dwTagOrId is tag else ID

Return Value:

    DWORD
        Success - Number of work items successfully cancelled (0..0xFFFFFFFE)

        Failure - 0xFFFFFFFF. Use GetLastError() for more info

                    ERROR_SHUTDOWN_IN_PROGRESS
                        - DLL being unloaded/support terminated

--*/

{
    DWORD error = TpsEnter();
    DWORD result = 0xFFFFFFFF;

    if (error == ERROR_SUCCESS) {
        if (g_CompletedWorkerInitialization) {
            result = g_ThreadPool.RemoveTagged(dwTagOrId, bTag);
        }
        TpsLeave();
    }
    if (result != 0xFFFFFFFF) {
        return result;
    }
    SetLastError(error);
    return result;
}

VOID
TerminateWorkers(
    VOID
    )

/*++

Routine Description:

    Terminate worker threads

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_CompletedWorkerInitialization) {
        g_IoWorkerCriticalSection.Acquire();
        while (!g_IoWorkerThreads.IsEmpty()) {

            CIoWorkerThreadInfo * pInfo;

            pInfo = (CIoWorkerThreadInfo *)g_IoWorkerThreads.RemoveHead();

            HANDLE hThread = pInfo->GetHandle();

            if ((hThread != NULL) && (hThread != (HANDLE)-1)) {
                pInfo->SetHandle(NULL);
                QueueNullFunc(hThread);
                SleepEx(0, TRUE);
            }
        }
        g_IoWorkerCriticalSection.Release();
        g_IoWorkerCriticalSection.Terminate();

        //
        // protect ourselves against termination from within a thread pool
        // thread
        //

        DWORD_PTR sig = (DWORD_PTR)TlsGetValue(g_TpsTls);
        DWORD limit = (sig == TPS_WORKER_SIGNATURE) ? 1 : 0;

        g_ThreadPool.Terminate(limit);

        g_StartedWorkerInitialization = FALSE;
        g_CompletedWorkerInitialization = FALSE;
        g_NumIoWorkerThreads = 0;
        g_NumIoWorkRequests = 0;
        g_LastIoThreadCreationTickCount = 0;
        g_MaximumIoThreads = MAX_IO_WORKER_THREADS;
        g_MaximumIoQueueDepth = NEW_THREAD_THRESHOLD;
        g_ThreadCreationDelta = THREAD_CREATION_DAMPING_TIME;
        g_dwWorkItemId = 0;

        if ((sig == TPS_IO_WORKER_SIGNATURE) || (sig == TPS_WORKER_SIGNATURE)) {
            g_bDeferredWorkerTermination = TRUE;
        }
    }
}

//
// private functions
//

PRIVATE
DWORD
InitializeWorkerThreadPool(
    VOID
    )

/*++

Routine Description:

    This routine initializes all aspects of the thread pool.

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (!InterlockedExchange((LPLONG)&g_StartedWorkerInitialization, TRUE)) {
        g_IoWorkerCriticalSection.Init();
        g_IoWorkerThreads.Init();
        g_ThreadPool.Init();

        //
        // signal that initialization has completed
        //

        g_CompletedWorkerInitialization = TRUE;
    } else {

        //
        // relinquish the timeslice until the other thread has initialized
        //

        while (!g_CompletedWorkerInitialization) {
            SleepEx(0, FALSE);
        }
    }
    if (error == ERROR_SUCCESS) {
        error = g_ThreadPool.GetError();

        ASSERT(error == ERROR_SUCCESS);
    }
    return error;
}

PRIVATE
DWORD
StartIOWorkerThread(
    VOID
    )

/*++

Routine Description:

    This routine starts an I/O worker thread

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    HANDLE hThread;
    DWORD error = StartThread((LPTHREAD_START_ROUTINE)IOWorkerThread,
                              &hThread,
                              TRUE
                              );

    if (error == ERROR_SUCCESS) {

        //
        // update the time at which the current thread was created
        //

        InterlockedExchange((LPLONG)&g_LastIoThreadCreationTickCount,
                            (LONG)GetTickCount()
                            );

        //
        // we have the g_IoWorkerCriticalSection. We know the CIoWorkerThreadInfo
        // added at the head is the one we just created
        //

        ((CIoWorkerThreadInfo *)g_IoWorkerThreads.Next())->SetHandle(hThread);

        //
        // increment the count of the thread type created
        //

        InterlockedIncrement((LPLONG)&g_NumIoWorkerThreads);
    } else {

        //
        // thread creation failed. If there is even one thread present do not
        // return failure since we can still service the work request.
        //

        if (g_NumIoWorkerThreads != 0) {
            error = ERROR_SUCCESS;
        }
    }
    return error;
}

PRIVATE
DWORD
QueueIOWorkerRequest(
    IN LPTHREAD_START_ROUTINE pfnCallback,
    IN LPVOID pContext
    )

/*++

Routine Description:

    This routine queues up the request to be executed in a IO worker thread.

Arguments:

    pfnCallback - Routine that is called by the worker thread

    pContext    - Opaque pointer passed in as an argument to pfnCallback

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    //
    // since we don't have access to the additional stack parameters of
    // NtQueueApcThread, we must allocate a packet off the heap in which
    // to pass the parameters
    //

    //
    // PERF: use a pre-allocated cache of request packets
    //

    CIoWorkerRequest * pPacket = new CIoWorkerRequest(pfnCallback, pContext);

    if (pPacket == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // increment the outstanding work request counter
    //

    InterlockedIncrement((LPLONG)&g_NumIoWorkRequests);

    //
    // in order to implement "fair" assignment of work items between IO worker
    // threads each time remove from head of list and reinsert at back. Keep
    // the pointer for thread handle
    //

    ASSERT(!g_IoWorkerThreads.IsEmpty());

    CIoWorkerThreadInfo * pInfo = (CIoWorkerThreadInfo *)g_IoWorkerThreads.RemoveHead();
    pInfo->InsertTail(&g_IoWorkerThreads);

    //
    // queue an APC to the IO worker thread. The worker thread will free the
    // request packet
    //

    BOOL bOk = QueueUserAPC((PAPCFUNC)ExecuteIOWorkItem,
                            pInfo->GetHandle(),
                            (ULONG_PTR)pPacket
                            );

    DWORD error = ERROR_SUCCESS;

    if (!bOk) {

        //
        // GetLastError() before ASSERT()!
        //

        error = GetLastError();
    }

    return error;
}

PRIVATE
VOID
IOWorkerThread(
    IN HANDLE hEvent
    )

/*++

Routine Description:

    All I/O worker threads execute in this routine. All the work requests execute as APCs
    in this thread.

Arguments:

    hEvent  - event handle signalled when initialization complete

Return Value:

    None.

--*/

{
    HMODULE hDll = LoadLibrary(g_cszShlwapi);
    DWORD dwExitCode = ERROR_OUTOFMEMORY;

    if (hDll) // LoadLibrary can fail under low-memory conditions, even though we're in shlwapi (hence it's loaded already)    
    {
        ASSERT(g_TpsTls != 0xFFFFFFFF);

        TlsSetValue(g_TpsTls, (LPVOID)TPS_IO_WORKER_SIGNATURE);

        CIoWorkerThreadInfo info(g_IoWorkerThreads.Head());

        SetEvent(hEvent);

        while (!g_bTpsTerminating) {
            SleepEx(INFINITE, TRUE);
        }
        InterlockedDecrement((LPLONG)&g_NumIoWorkerThreads);
        while (info.GetHandle() != NULL) {
            SleepEx(0, FALSE);
        }
        if (GetCurrentThreadId() == g_dwTerminationThreadId) {
            g_bTpsTerminating = FALSE;
            g_bDeferredWorkerTermination = FALSE;
            g_dwTerminationThreadId = 0;
        }
        FreeLibrary(hDll);
        dwExitCode = ERROR_SUCCESS;
    }
    ExitThread(dwExitCode);
}

PRIVATE
VOID
ExecuteIOWorkItem(
    IN CIoWorkerRequest * pPacket
    )

/*++

Routine Description:

    Executes an IO Work function. Runs in a APC in the IO Worker thread

Arguments:

    pPacket - pointer to CIoWorkerRequest allocated by the requesting
              thread. We need to free it/return it to packet cache

Return Value:

    None.

--*/

{
    LPTHREAD_START_ROUTINE fn = pPacket->GetCallback();
    LPVOID ctx = pPacket->GetContext();

    delete pPacket;

    if (!g_bTpsTerminating) {
        fn(ctx);
        InterlockedDecrement((LPLONG)&g_NumIoWorkRequests);
    }
}

PRIVATE
VOID
ExecuteWorkItem(
    IN WorkItem *pItem
    )

/*++

Routine Description:

    Executes a regular Work function. Runs in the NT thread pool

Arguments:

    pItem   - context information. Contains the worker function that needs to 
              be run and the hModule to free. We need to free it.

Return Value:

    None.

--*/

{
    HMODULE hModule = pItem->hModuleToFree;
    LPTHREAD_START_ROUTINE pfn = pItem->pfnCallback;
    LPVOID ctx = pItem->pContext;
    delete pItem;
#ifdef DEBUG
    HRESULT hrDebug = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (hrDebug == RPC_E_CHANGED_MODE)
    {
        ASSERTMSG(FALSE, "SHLWAPI Thread pool wrapper: Could not CoInitialize Appartment threaded. We got infected with an MTA!\n");
    }
    else
    {
        CoUninitialize();
    }
#endif

    // Do the work now
    pfn(ctx);

#ifdef DEBUG
    hrDebug = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (hrDebug == RPC_E_CHANGED_MODE)
    {
        ASSERTMSG(FALSE, "SHLWAPI Thread pool wrapper: Could not CoInitialize Appartment threaded. The task at %x forgot to CoUninitialize or "
                            "we got infected with an MTA!\n", pfn);
    }
    else
    {
        CoUninitialize();
    }
#endif

    if (hModule)
        FreeLibrary(hModule);

}

VOID
CThreadPool::WorkerThread(
    VOID
    )

/*++

Routine Description:

    Static thread function. Instantiates the thread pool object pointer and
    calls the non-IO worker member function

Arguments:
    None.

Return Value:

    None.

--*/

{
    HMODULE hDll = LoadLibrary(g_cszShlwapi);
    DWORD dwExitCode = ERROR_OUTOFMEMORY;

    if (hDll) // LoadLibrary can fail under low-memory conditions, even though we're in shlwapi (hence it's loaded already)
    {
        ASSERT(g_TpsTls != 0xFFFFFFFF);

        TlsSetValue(g_TpsTls, (LPVOID)TPS_WORKER_SIGNATURE);

        g_ThreadPool.Worker();

        if (GetCurrentThreadId() == g_dwTerminationThreadId) {
            g_dwTerminationThreadId = 0;
            g_bDeferredWorkerTermination = FALSE;
            g_bTpsTerminating = FALSE;
        }
        FreeLibrary(hDll);
        dwExitCode = ERROR_SUCCESS;
    }
    ExitThread(dwExitCode);
}

VOID
CThreadPool::Worker(
    VOID
    )

/*++

Routine Description:

    All non I/O worker threads execute in this routine. This function will
    terminate when it has not serviced a request for m_workerIdleTimeout mSec

Arguments:

    None.

Return Value:

    None.

--*/

{
    while (!g_bTpsTerminating)
    {
        FARPROC fn;
        ULONG_PTR ctx;
        DWORD flags;
        HMODULE hMouduleToFree = NULL;
        DWORD error = RemoveWorkItem(&fn, &ctx, &hMouduleToFree, &flags, m_workerIdleTimeout);

        ASSERT(error != ERROR_SUCCESS || !(flags & TPS_INVALID_FLAGS));

        if (g_bTpsTerminating)
        {
            break;
        }
        if (error == ERROR_SUCCESS)
        {
            // call the work function
            ((LPTHREAD_START_ROUTINE)fn)((LPVOID)ctx);

            if (hMouduleToFree)
            {
                // we completed the task, so free the hmodule associated with it
                FreeLibrary(hMouduleToFree);
            }

            if (flags & TPS_LONGEXECTIME)
            {
                MakeAvailable();
            }
        }
        else if (error == WAIT_TIMEOUT)
        {
            m_qlock.Acquire();

            if ((m_queueSize == 0) && (m_availableWorkerThreads > m_minWorkerThreads))
            {
                RemoveWorker();
                m_qlock.Release();

                //#if DBG
                //char buf[256];
                //wsprintf(buf, ">>>> terminating worker thread. Total = %d/%d. Avail = %d. Factor = %d/%d\n",
                //         m_totalWorkerThreads,
                //         m_maxWorkerThreadsCreated,
                //         m_availableWorkerThreads,
                //         m_qFactor,
                //         m_qFactorMax
                //         );
                //OutputDebugString(buf);
                //#endif

                return;
            }
            m_qlock.Release();
        }
    }

    //#if DBG
    //char buf[256];
    //wsprintf(buf, ">>>> terminating worker thread. Total = %d/%d. Avail = %d. Factor = %d/%d\n",
    //         m_totalWorkerThreads,
    //         m_maxWorkerThreadsCreated,
    //         m_availableWorkerThreads,
    //         m_qFactor,
    //         m_qFactorMax
    //         );
    //OutputDebugString(buf);
    //#endif

    RemoveWorker();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\uniansi.c ===
//============================================================================
//
// UNICODE and ANSI conversion functions
//
//============================================================================

#include "priv.h"
#include <mlang.h>

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHAnsiToUnicodeNativeCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified Windows code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be a Windows code page.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   int | cchSrc |
 *
 *          Source buffer length, including terminating null.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeNativeCP(UINT uiCP,
                        LPCSTR pszSrc, int cchSrc,
                        LPWSTR pwszDst, int cwchBuf)
{
    int cwchRc = 0;             /* Assume failure */

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRA(pszSrc, -1));
    ASSERT(cchSrc == lstrlenA(pszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));
    ASSERT(pszSrc != NULL);
    ASSERT(uiCP != 1200 && uiCP != 65000 && uiCP != 50000 && uiCP != 65001);
    ASSERT(pwszDst);
    ASSERT(cwchBuf);

    cwchRc = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc, pwszDst, cwchBuf);
    if (cwchRc) {
        /*
         *  The output buffer was big enough; no double-buffering
         *  needed.
         */
    } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        /*
         *  The output buffer wasn't big enough.  Need to double-buffer.
         */

        int cwchNeeded = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                             NULL, 0);

        ASSERT(cwchRc == 0);        /* In case we fail later */
        if (cwchNeeded) {
            LPWSTR pwsz = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                             cwchNeeded * SIZEOF(WCHAR));
            if (pwsz) {
                cwchRc = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                             pwsz, cwchNeeded);
                if (cwchRc) {
                    StrCpyNW(pwszDst, pwsz, cwchBuf);
                    cwchRc = cwchBuf;
                }
                LocalFree(pwsz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in MultiByteToWideChar");
    }

    return cwchRc;
}

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHAnsiToUnicodeInetCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified Internet code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be an Internet code page.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   int | cchSrc |
 *
 *          Source buffer length, including terminating null.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeInetCP(UINT uiCP,
                      LPCSTR pszSrc, int cchSrc,
                      LPWSTR pwszDst, int cwchBuf)
{
    int cchSrcT, cwchNeeded;
    int cwchRc = 0;             /* Assume failure */
    HRESULT hres;
    DWORD dwMode;

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRA(pszSrc, -1));
    ASSERT(cchSrc == lstrlenA(pszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));
    ASSERT(pszSrc != NULL);
    ASSERT(uiCP == 1200 || uiCP == 65000 || uiCP == 65001);
    ASSERT(pwszDst);
    ASSERT(cwchBuf);

    cchSrcT = cchSrc;
    cwchNeeded = cwchBuf;

    dwMode = 0;
    hres = ConvertINetMultiByteToUnicode(&dwMode, uiCP, pszSrc,
                                         &cchSrcT, pwszDst, &cwchNeeded);
    if (SUCCEEDED(hres)) {
        if (cchSrcT >= cchSrc) {
            /*
             *  The output buffer was big enough; no double-buffering
             *  needed.
             */
            cwchRc = cwchNeeded;
        } else {
            /*
             *  The output buffer wasn't big enough.  Need to double-buffer.
             */
            LPWSTR pwsz = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                             cwchNeeded * SIZEOF(WCHAR));
            if (pwsz) {
                dwMode = 0;
                hres = ConvertINetMultiByteToUnicode(&dwMode, uiCP, pszSrc,
                                            &cchSrc, pwsz, &cwchNeeded);
                if (SUCCEEDED(hres)) {
                    StrCpyNW(pwszDst, pwsz, cwchBuf);
                    cwchRc = cwchBuf;
                }
                LocalFree(pwsz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in ConvertInetMultiByteToUnicode");
    }

    return cwchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHAnsiToUnicodeCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified code page, which can be either a native
 *          Windows code page or an Internet code page.
 *          If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeCP(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    int cwchRc = 0;             /* Assume failure */

    RIPMSG(IS_VALID_STRING_PTRA(pszSrc, -1), "Caller of SHAnsiToUnicodeCP passed in a NULL pszSrc!");
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));

    /*
     *  Sanity check - NULL source string is treated as a null string.
     */
    if (pszSrc == NULL) {
        pszSrc = "";
    }

    /*
     *  Sanity check - Output buffer must be non-NULL and must be of
     *  nonzero size.
     */
    if (pwszDst && cwchBuf) {

        int cchSrc;

        pwszDst[0] = 0;         /* In case of error */

        cchSrc = lstrlenA(pszSrc) + 1;

        /*
         *  Decide what kind of code page it is.
         */
        switch (uiCP) {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // Fall through
        case 50000:                     // "User Defined"
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
            cwchRc = SHAnsiToUnicodeInetCP(uiCP, pszSrc, cchSrc, pwszDst, cwchBuf);
            break;

        default:
            cwchRc = SHAnsiToUnicodeNativeCP(uiCP, pszSrc, cchSrc, pwszDst, cwchBuf);
            break;
        }
    }

    return cwchRc;
}

// This function exists to make sure SHAnsiToAnsi and SHUnicodeToAnsi
// have the same return value.  Callers use SHTCharToAnsi and don't know
// when it callapses to SHAnsiToAnsi.
int SHAnsiToAnsi(LPCSTR pszSrc, LPSTR pszDst, int cchBuf)
{
    int cchRc = 0;          /* Assume failure */

    if (cchBuf)
    {
        // APP COMPAT! WARNING!  Sony PictureGear passes too-small buffers to
        // SHGetPathFromIDList (which uses SHAnsiToAnsi eventually), so we
        // must be careful to pass the actual buffer size to SHTruncateString
        // and not the theoretical maximum (rarely attained).

        LPSTR pszEnd = StrCpyNXA(pszDst, pszSrc, cchBuf);
        cchRc = (int)(pszEnd - pszDst) + 1;
        cchRc = SHTruncateString(pszDst, cchRc) + 1;
    }

    return cchRc;
}

// This function exists to make sure SHUnicodeToUnicode and SHUnicodeToAnsi
// have the same return value.  Callers use SHTCharToUnicode and don't know
// when it callapses to SHUnicodeToUnicode.
int SHUnicodeToUnicode(LPCWSTR pwzSrc, LPWSTR pwzDst, int cchBuf)
{
    return (int) (StrCpyNXW(pwzDst, pwzSrc, cchBuf) - pwzDst + 1); // size including terminator
}


/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHAnsiToUnicode |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          <c CP_ACP> code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *
 */

int
SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    return SHAnsiToUnicodeCP(CP_ACP, pszSrc, pwszDst, cwchBuf);
}

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHUnicodeToAnsiNativeCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified Windows code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be a Windows code page.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   int | cwchSrc |
 *
 *          Number of characters in source buffer, including terminating
 *          null.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 */

int
SHUnicodeToAnsiNativeCP(UINT uiCP,
                        LPCWSTR pwszSrc, int cwchSrc,
                        LPSTR pszDst, int cchBuf)

{
    int cchRc = 0;          /* Assume failure */

#ifdef DEBUG
    BOOL fVerify = TRUE;
    BOOL fLossy;
    if (uiCP == CP_ACPNOVALIDATE) {
        // -1 means use CP_ACP, but do *not* verify
        // kind of a hack, but it's DEBUG and leaves 99% of callers unchanged
        uiCP = CP_ACP;
        fVerify = FALSE;
    }
#define USUALLY_NULL    (&fLossy)
#else
#define USUALLY_NULL    NULL
#endif

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRW(pwszSrc, -1));
    ASSERT(cwchSrc == lstrlenW(pwszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));
    ASSERT(uiCP != 1200 && uiCP != 65000 && uiCP != 50000 && uiCP != 65001);
    ASSERT(pwszSrc);
    ASSERT(pszDst);
    ASSERT(cchBuf);

    cchRc = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc, pszDst, cchBuf,
                                NULL, USUALLY_NULL);
    if (cchRc) {
        /*
         *  The output buffer was big enough; no double-buffering
         *  needed.
         */
    } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        /*
         *  The output buffer wasn't big enough.  Need to double-buffer.
         */

        int cchNeeded = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc,
                                            NULL, 0, NULL, NULL);

        ASSERT(cchRc == 0);         /* In case we fail later */
        if (cchNeeded) {
            LPSTR psz = (LPSTR)LocalAlloc(LMEM_FIXED,
                                          cchNeeded * SIZEOF(CHAR));
            if (psz) {
                cchRc = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc,
                                            psz, cchNeeded, NULL, USUALLY_NULL);
                if (cchRc) {
                    // lstrcpyn doesn't check if it's chopping a DBCS char
                    // so we need to use SHTruncateString.
                    //
                    // Add 1 because SHTruncateString doesn't count
                    // the trailing null but we do
                    //
                    // Assert that we meet the preconditions for
                    // SHTruncateString to return a valid value.
                    //
                    ASSERT(cchRc > cchBuf);
                    cchRc = SHTruncateString(psz, cchBuf) + 1;
                    lstrcpynA(pszDst, psz, cchBuf);
                }
                LocalFree(psz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in WideCharToMultiByte");
    }

#ifdef DEBUG
    TBOOL(!fVerify || !fLossy);
#endif

    return cchRc;
}

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHUnicodeToAnsiInetCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified Internet code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be an Internet code page.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   int | cwchSrc |
 *
 *          Number of characters in source buffer, including terminating
 *          null.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 */

int
SHUnicodeToAnsiInetCP(UINT uiCP,
                      LPCWSTR pwszSrc, int cwchSrc,
                      LPSTR pszDst, int cchBuf)
{
    int cwchSrcT, cchNeeded;
    int cchRc = 0;          /* Assume failure */
    DWORD dwMode;
    HRESULT hres;

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRW(pwszSrc, -1));
    ASSERT(cwchSrc == lstrlenW(pwszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));
    ASSERT(uiCP == 1200 || uiCP == 65000 || uiCP == 65001);
    ASSERT(pwszSrc);
    ASSERT(pszDst);
    ASSERT(cchBuf);

    /*
     *  Note that not all encodings translate a null terminator into a null
     *  terminator, so we have to save the NUL for last.
     */

    cwchSrc--;                          /* Save the NUL for last */
    cwchSrcT = cwchSrc;
    cchNeeded = cchBuf - 1;             /* Save the NUL for last */

    dwMode = 0;                         /* Start fresh */
    hres = ConvertINetUnicodeToMultiByte(&dwMode, uiCP, pwszSrc,
                                         &cwchSrcT, pszDst, &cchNeeded);
    if (SUCCEEDED(hres)) {
        if (cwchSrcT >= cwchSrc) {
            /*
             *  The output buffer was big enough; no double-buffering
             *  needed.  Translate the NUL manually.
             */
            ASSERT(cchNeeded < cchBuf);
            pszDst[cchNeeded] = TEXT('\0');
            cchRc = cchNeeded + 1;
        } else {
            /*
             *  The output buffer wasn't big enough.  Need to double-buffer.
             */
            LPSTR psz = (LPSTR)LocalAlloc(LMEM_FIXED,
                                          cchNeeded * SIZEOF(CHAR));
            if (psz) {
                dwMode = 0;             /* Start fresh */
                hres = ConvertINetUnicodeToMultiByte(&dwMode, uiCP, pwszSrc,
                                            &cwchSrc, psz, &cchNeeded);
                if (SUCCEEDED(hres)) {
                    // lstrcpyn doesn't check if it's chopping a DBCS char
                    // so we need to use SHTruncateString.
                    //
                    // Add 1 because SHTruncateString doesn't count
                    // the trailing null but we do
                    //
                    // Assert that we meet the preconditions for
                    // SHTruncateString to return a valid value.
                    //
                    ASSERT(cchNeeded > cchBuf);
                    cchRc = SHTruncateString(psz, cchBuf) + 1;
                    lstrcpynA(pszDst, psz, cchBuf);
                }
                LocalFree(psz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in ConvertInetUnicodeToMultiByte");
    }

    return cchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHUnicodeToAnsiCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified code page, which can be either a native
 *          Windows code page or an Internet code page.
 *          If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 *
 */

int
SHUnicodeToAnsiCP(UINT uiCP, LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf)
{
    int cchRc = 0;              /* Assume failure */
#ifdef DEBUG
#define GET_CP(uiCP)    (((uiCP) == CP_ACPNOVALIDATE) ? CP_ACP : (uiCP))
#else
#define GET_CP(uiCP)    uiCP
#endif

    RIPMSG(IS_VALID_STRING_PTRW(pwszSrc, -1), "Caller of SHUnicodeToAnsiCP passed in a NULL pwszSrc!");
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));

    /*
     *  Sanity check - NULL source string is treated as a null string.
     */
    if (pwszSrc == NULL) {
        pwszSrc = L"";
    }

    /*
     *  Sanity check - Output buffer must be non-NULL and must be of
     *  nonzero size.
     */
    if (pszDst && cchBuf) {

        int cwchSrc;

        pszDst[0] = 0;          /* In case of error */

        cwchSrc = lstrlenW(pwszSrc) + 1; /* Yes, Win9x has lstrlenW */

        /*
         *  Decide what kind of code page it is.
         */
        switch (GET_CP(uiCP)) {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // Fall through
        case 50000:                     // "User Defined"
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
            cchRc = SHUnicodeToAnsiInetCP(GET_CP(uiCP), pwszSrc, cwchSrc, pszDst, cchBuf);
            break;

        default:
            cchRc = SHUnicodeToAnsiNativeCP(uiCP, pwszSrc, cwchSrc, pszDst, cchBuf);
            break;
        }
    }

    return cchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHUnicodeToAnsi |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          <c CP_ACP> code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 *
 */

int
SHUnicodeToAnsi(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf)
{
    return SHUnicodeToAnsiCP(CP_ACP, pwszSrc, pszDst, cchBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\unicwrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       unicwrap.h
//
//  Contents:   Wrappers for all Unicode functions used in the Forms^3 project.
//
//----------------------------------------------------------------------------

#ifndef _UNICWRAP_HXX_
#define _UNICWRAP_HXX_

#include "cstrinout.h"

#endif // _UNICWRAP_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\tpswait.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tpswait.h

Abstract:

    Wait classes. Moved out of tpsclass.h

    Contents:
        CWait
        CWaitRequest
        CWaitAddRequest
        CWaitRemoveRequest
        CWaitThreadInfo

Author:

    Richard L Firth (rfirth) 08-Aug-1998

Revision History:

    08-Aug-1998 rfirth
        Created

--*/

//
// forward declarations
//

class CWaitThreadInfo;

//
// classes
//

//
// CWait
//

class CWait : public CTimedListEntry {

private:

    HANDLE m_hObject;
    WAITORTIMERCALLBACKFUNC m_pCallback;
    LPVOID m_pContext;
    CWaitThreadInfo * m_pThreadInfo;
    DWORD m_dwFlags;

public:

    CWait(HANDLE hObject,
          WAITORTIMERCALLBACKFUNC pCallback,
          LPVOID pContext,
          DWORD dwWaitTime,
          DWORD dwFlags,
          CWaitThreadInfo * pInfo
          ) : CTimedListEntry(dwWaitTime) {
        m_hObject = hObject;
        m_pCallback = pCallback;
        m_pContext = pContext;
        m_pThreadInfo = pInfo;
        m_dwFlags = dwFlags;
    }

    CWait() {
    }

    CWait * Next(VOID) {
        return (CWait *)CTimedListEntry::Next();
    }

    CWaitThreadInfo * GetThreadInfo(VOID) const {
        return m_pThreadInfo;
    }

    VOID Execute(BOOL bTimeout) {

        //
        // execute function in this thread if required to do so, else we run
        // the callback in a non-I/O worker thread
        //

        //
        // APPCOMPAT - can't do this: the callback types for Wait & Work requests
        //          are different: one takes 2 parameters, the other one. We
        //          can't make this change until this issue is resolved with
        //          NT guys
        //

        //if (m_dwFlags & WT_EXECUTEINWAITTHREAD) {
            m_pCallback(m_pContext, bTimeout != 0);
        //} else {
        //
        //    //
        //    //  would have to allocate object from heap to hold callback
        //    //          function, context & bTimeout parameters in order to pass
        //    //          them to worker thread (we only have access to one APC
        //    //          parameter and we'd have to nominate different APC)
        //    //
        //
        //    Ie_QueueUserWorkItem((LPTHREAD_START_ROUTINE)m_pCallback,
        //                         m_pContext,
        //                         FALSE
        //                         );
        //}
    }

    HANDLE GetHandle(VOID) const {
        return m_hObject;
    }

    BOOL IsNoRemoveItem(VOID) {
        return (m_dwFlags & SRWSO_NOREMOVE) ? TRUE : FALSE;
    }
};

//
// CWaitRequest
//

class CWaitRequest {

private:

    BOOL m_bCompleted;
    CWait * m_pWait;

public:

    CWaitRequest() {
        m_bCompleted = FALSE;
    }

    CWaitRequest(CWait * pWait) {
        m_bCompleted = FALSE;
        m_pWait = pWait;
    }

    VOID SetComplete(VOID) {
        m_bCompleted = TRUE;
    }

    VOID WaitForCompletion(VOID) {
        while (!m_bCompleted) {
            SleepEx(0, TRUE);
        }
    }

    VOID SetWaitPointer(CWait * pWait) {
        m_pWait = pWait;
    }

    CWait * GetWaitPointer(VOID) const {
        return m_pWait;
    }
};

//
// CWaitAddRequest
//

class CWaitAddRequest : public CWait, public CWaitRequest {

public:

    CWaitAddRequest(HANDLE hObject,
                    WAITORTIMERCALLBACKFUNC pCallback,
                    LPVOID pContext,
                    DWORD dwWaitTime,
                    DWORD dwFlags,
                    CWaitThreadInfo * pInfo
                    ) :
                    CWait(hObject, pCallback, pContext, dwWaitTime, dwFlags, pInfo),
                    CWaitRequest()
    {
    }
};

//
// CWaitRemoveRequest
//

class CWaitRemoveRequest : public CWaitRequest {

public:

    CWaitRemoveRequest(HANDLE hWait) : CWaitRequest((CWait *)hWait) {
    }
};

//
// CWaitThreadInfo
//

class CWaitThreadInfo : public CDoubleLinkedList, public CCriticalSection {

private:

    HANDLE m_hThread;
    DWORD m_dwObjectCount;
    HANDLE m_Objects[MAXIMUM_WAIT_OBJECTS];
    CWait * m_pWaiters[MAXIMUM_WAIT_OBJECTS];
    CWait m_Waiters[MAXIMUM_WAIT_OBJECTS];
    CDoubleLinkedList m_FreeList;
    CDoubleLinkedList m_WaitList;

public:

    CWaitThreadInfo(CDoubleLinkedList * pList) {
        CDoubleLinkedList::Init();
        m_hThread = NULL;
        m_dwObjectCount = 0;
        m_FreeList.Init();
        m_WaitList.Init();
        for (int i = 0; i < ARRAY_ELEMENTS(m_Waiters); ++i) {
            m_Waiters[i].InsertTail(&m_FreeList);
        }
        InsertHead(pList);
    }

    VOID SetHandle(HANDLE hThread) {
        m_hThread = hThread;
    }

    HANDLE GetHandle(VOID) const {
        return m_hThread;
    }

    DWORD GetObjectCount(VOID) const {
        return m_dwObjectCount;
    }

    BOOL IsAvailableEntry(VOID) const {
        return m_dwObjectCount < ARRAY_ELEMENTS(m_Objects);
    }

    BOOL IsInvalidHandle(DWORD dwIndex) {

        ASSERT(dwIndex < m_dwObjectCount);

        //
        // GetHandleInformation() doesn't exist on Win95
        //
        //
        //DWORD dwHandleFlags;
        //
        //return !GetHandleInformation(m_Objects[dwIndex], &dwHandleFlags);

        DWORD status = WaitForSingleObject(m_Objects[dwIndex], 0);

        if ((status == WAIT_FAILED) && (GetLastError() == ERROR_INVALID_HANDLE)) {
//#if DBG
//char buf[128];
//wsprintf(buf, "IsInvalidHandle(%d): handle %#x is invalid\n", dwIndex, m_Objects[dwIndex]);
//OutputDebugString(buf);
//#endif
            return TRUE;
        }
        return FALSE;
    }

    VOID Compress(DWORD dwIndex, DWORD dwCount = 1) {

        ASSERT(dwCount != 0);
        ASSERT((int)m_dwObjectCount > 0);

        if ((dwIndex + dwCount) < m_dwObjectCount) {
            RtlMoveMemory(&m_Objects[dwIndex],
                          &m_Objects[dwIndex + dwCount],
                          sizeof(m_Objects[0]) * (m_dwObjectCount - (dwIndex + dwCount))
                          );
            RtlMoveMemory(&m_pWaiters[dwIndex],
                          &m_pWaiters[dwIndex + dwCount],
                          sizeof(m_pWaiters[0]) * (m_dwObjectCount - (dwIndex + dwCount))
                          );
        }
        m_dwObjectCount -= dwCount;
    }

    VOID Expand(DWORD dwIndex) {
        RtlMoveMemory(&m_Objects[dwIndex],
                      &m_Objects[dwIndex + 1],
                      sizeof(m_Objects[0]) * (m_dwObjectCount - dwIndex)
                      );
        RtlMoveMemory(&m_pWaiters[dwIndex],
                      &m_pWaiters[dwIndex + 1],
                      sizeof(m_pWaiters[0]) * (m_dwObjectCount - dwIndex)
                      );
        ++m_dwObjectCount;

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));
    }

    //DWORD BuildList(VOID) {
    //
    //    //
    //    // PERF: only rebuild from changed index
    //    //
    //
    //    m_dwObjectCount = 0;
    //    for (CWait * pWait = (CWait *)m_WaitList.Next();
    //         pWait = pWait->Next();
    //         !m_WaitList.IsHead(pWait)) {
    //        m_pWaiters[m_dwObjectCount] = pWait;
    //        m_Objects[m_dwObjectCount] = pWait->GetHandle();
    //        ++m_dwObjectCount;
    //    }
    //    return GetWaitTime();
    //}

    DWORD Wait(DWORD dwTimeout = INFINITE) {

        //
        // if no objects in list, sleep alertably for the timeout period
        //

        if (m_dwObjectCount == 0) {
            SleepEx(dwTimeout, TRUE);
            return WAIT_IO_COMPLETION;
        }

        //
        // else wait alertably for the timeout period
        //

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        return WaitForMultipleObjectsEx(m_dwObjectCount,
                                        m_Objects,
                                        FALSE,  // fWaitAll
                                        dwTimeout,
                                        TRUE    // fAlertable
                                        );
    }

    DWORD GetWaitTime(VOID) {

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        if (m_dwObjectCount != 0) {

            CWait * pWaiter = m_pWaiters[0];
            DWORD dwWaitTime = pWaiter->GetWaitTime();

            if (dwWaitTime != INFINITE) {

                DWORD dwTimeNow = GetTickCount();
                DWORD dwTimeStamp = pWaiter->GetTimeStamp();

                if (dwTimeNow > dwTimeStamp + dwWaitTime) {

                    //
                    // first object expired already
                    //

                    return 0;
                }

                //
                // number of milliseconds until next waiter expires
                //

                return (dwTimeStamp + dwWaitTime) - dwTimeNow;
            }
        }

        //
        // nothing in list
        //

        return INFINITE;
    }

    CWait * GetFreeWaiter(VOID) {
        return (CWait *)m_FreeList.RemoveHead();
    }

    VOID InsertWaiter(CWait * pWait) {

        DWORD dwIndex = 0;
        BOOL bAtEnd = TRUE;
        CDoubleLinkedListEntry * pHead = m_WaitList.Head();

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        if ((m_dwObjectCount != 0) && !pWait->IsInfiniteTimeout()) {

            //
            // not infinite timeout. Find place in list to insert this object
            //

            //
            // PERF: typically, new wait will be longer than most currently in
            //       list, so should start from end of non-infinite timeouts
            //       and work backwards
            //

            for (; dwIndex < m_dwObjectCount; ++dwIndex) {
                if (pWait->ExpiryTime() < m_pWaiters[dwIndex]->ExpiryTime()) {
                    pHead = m_pWaiters[dwIndex]->Head();
                    bAtEnd = (dwIndex == (m_dwObjectCount - 1));
                    break;
                }
            }
        }

        //
        // insert the new wait object at the correct location
        //

        pWait->InsertTail(pHead);
        if (!bAtEnd && (m_dwObjectCount != 0)) {
            Expand(dwIndex);
        } else {
            dwIndex = m_dwObjectCount;
            ++m_dwObjectCount;
        }

        //
        // update object list and pointer list
        //

        m_Objects[dwIndex] = pWait->GetHandle();
        m_pWaiters[dwIndex] = pWait;
    }

    VOID RemoveWaiter(CWait * pWait, DWORD dwIndex) {

        //
        // remove the waiter from the wait list and add it back to the
        // free list
        //

        pWait->Remove();
        pWait->InsertTail(&m_FreeList);

        //
        // if the object was not at the end of the list then compress
        // the list
        //

        if (dwIndex != (m_dwObjectCount - 1)) {
            Compress(dwIndex, 1);
        } else {
            --m_dwObjectCount;
        }
    }

    VOID RemoveWaiter(DWORD dwIndex) {

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        RemoveWaiter(m_pWaiters[dwIndex], dwIndex);
    }

    BOOL RemoveWaiter(CWait * pWait) {

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        for (DWORD dwIndex = 0; dwIndex < m_dwObjectCount; ++dwIndex) {
            if (m_pWaiters[dwIndex] == pWait) {
                RemoveWaiter(pWait, dwIndex);
                return TRUE;
            }
        }
        return FALSE;
    }

    VOID ProcessTimeouts(VOID) {

        DWORD dwTimeNow = GetTickCount();
        DWORD dwCount = 0;

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        while (dwCount < m_dwObjectCount) {

            CWait * pWait = m_pWaiters[dwCount];

            //
            // if waiter has expired, invoke its callback then remove it from
            // the wait list and add back to the free list
            //

            if (pWait->IsTimedOut(dwTimeNow)) {
                pWait->Execute(TRUE);
                pWait->Remove();
                pWait->InsertTail(&m_FreeList);
                ++dwCount;
            } else {

                //
                // quit loop at first non-timed-out entry
                //

                break;
            }
        }

        ASSERT(dwCount != 0);

        if (dwCount != 0) {
            Compress(0, dwCount);
        }
    }

    VOID PurgeInvalidHandles(VOID) {

        DWORD dwCount = 0;
        DWORD dwIndex = 0;
        DWORD dwIndexStart = 0;

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        while (dwIndex < m_dwObjectCount) {

            CWait * pWait = m_pWaiters[dwIndex];

            //
            // if handle has become invalid, invoke the callback then remove it
            // from the wait list and add back to the free list
            //

            if (IsInvalidHandle(dwIndex)) {
                pWait->Execute(FALSE);
                pWait->Remove();
                pWait->InsertTail(&m_FreeList);
                if (dwIndexStart == 0) {
                    dwIndexStart = dwIndex;
                }
                ++dwCount;
            } else if (dwCount != 0) {
                Compress(dwIndexStart, dwCount);
                dwIndex = dwIndexStart - 1;
                dwIndexStart = 0;
                dwCount = 0;
            }
            ++dwIndex;
        }
        if (dwCount != 0) {
            Compress(dwIndexStart, dwCount);
        }
    }

    VOID ProcessCompletion(DWORD dwIndex) {

        CWait * pWait = m_pWaiters[dwIndex];

        pWait->Execute(FALSE);
        if (!pWait->IsNoRemoveItem()) {
            RemoveWaiter(dwIndex);
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\unixstuff.h ===
#ifdef UNICODE
#define WNetGetResourceInformation WNetGetResourceInformationW 
#else
#define WNetGetResourceInformation WNetGetResourceInformationA
#endif

#ifdef __cplusplus
PRIVATE HRESULT UnixWininetCopyUrlForParse(PSHSTRW pstrDst, LPCWSTR pszSrc);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\uastrfnc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       uastrfnc.cpp
//
//  Contents:   Unaligned UNICODE lstr functions for MIPS, PPC, ALPHA
//
//  Classes:
//
//  Functions:
//
//  History:    1-11-95   davepl   Created
//
//--------------------------------------------------------------------------

// NOTE (DavePl) None of these pay any heed to locale!

#include "priv.h"
#pragma  hdrstop

#ifdef ALIGNMENT_MACHINE

#ifdef UNIX
#define _alloca alloca
#endif /* UNIX */

//+-------------------------------------------------------------------------
//
//  Function:   ualstrcpynW
//
//  Synopsis:   UNALIGNED UNICODE version of lstrcpyn
//
//  Arguments:  [lpString1]  -- dest string
//              [lpString2]  -- source string
//              [iMaxLength] -- max chars to copy
//
//  Returns:
//
//  History:    1-11-95   davepl   NT Port
//
//  Notes:
//
//--------------------------------------------------------------------------

UNALIGNED WCHAR *  ualstrcpynW(UNALIGNED WCHAR * lpString1,
                               UNALIGNED const WCHAR * lpString2,
                               int iMaxLength)
{
    UNALIGNED WCHAR * src;
    UNALIGNED WCHAR * dst;

    src = (UNALIGNED WCHAR *)lpString2;
    dst = lpString1;

    while(iMaxLength && *src)
    {
        *dst++ = *src++;
        iMaxLength--;
    }

    if ( iMaxLength )
    {
        *dst = '\0';
    }
    else
    {
        dst--;
        *dst = '\0';
    }
    return dst;
}

//+-------------------------------------------------------------------------
//
//  Function:   ualstrcmpiW
//
//  Synopsis:   UNALIGNED UNICODE wrap of lstrcmpi
//
//  Arguments:  [dst] -- first string
//              [src] -- string to comapre to
//
//  Returns:
//
//  History:    1-11-95   davepl   Created
//              4-20-98   scotthan localized, bug 141655
//
//--------------------------------------------------------------------------
int ualstrcmpiW (UNALIGNED const WCHAR * dst, UNALIGNED const WCHAR * src)
{
    WCHAR  *pwszDst, *pwszSrc; 
    int    cb ;

    //  Make aligned copies on the stack if appropriate...
    //  PERF - not the most inefficient tact (scotthan)
    //  note: _alloca should always succeed, unless out of stack
    if( IS_ALIGNED( dst ) )
        pwszDst = (WCHAR*)dst ;
    else
    {
        cb = (ualstrlenW( dst ) + 1) * sizeof(WCHAR) ;
        pwszDst = (WCHAR*)_alloca( cb ) ;
        CopyMemory( pwszDst, dst, cb ) ;
    }

    if( IS_ALIGNED( src ) )
        pwszSrc = (WCHAR*)src ;
    else
    {
        cb = (ualstrlenW( src ) + 1) * sizeof(WCHAR) ;
        pwszSrc = (WCHAR*)_alloca( cb ) ;
        CopyMemory( pwszSrc, src, cb ) ;
    }

    //  Call the aligned method.
    //  Note: if this ever runs on Win95, we should call StrCmpIW instead.
    return lstrcmpiW( pwszDst, pwszSrc ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   ualstrcmpW
//
//  Synopsis:   UNALIGNED UNICODE wrap of lstrcmp
//
//  Arguments:  [dst] -- first string
//              [src] -- string to comapre to
//
//  Returns:
//
//  History:    1-11-95   davepl   Created
//              4-29-98   scotthan localized, bug 164091
//
//--------------------------------------------------------------------------
int ualstrcmpW (UNALIGNED const WCHAR * src, UNALIGNED const WCHAR * dst)
{
    WCHAR  *pwszDst, *pwszSrc; 
    int    cb ;

    //  Make aligned copies on the stack if appropriate...
    //  PERF - not the most inefficient tact (scotthan)
    //  note: _alloca should always succeed, unless out of stack
    if( IS_ALIGNED( dst ) )
        pwszDst = (WCHAR*)dst ;
    else
    {
        cb = (ualstrlenW( dst ) + 1) * sizeof(WCHAR) ;
        pwszDst = (WCHAR*)_alloca( cb ) ;
        CopyMemory( pwszDst, dst, cb ) ;
    }

    if( IS_ALIGNED( src ) )
        pwszSrc = (WCHAR*)src ;
    else
    {
        cb = (ualstrlenW( src ) + 1) * sizeof(WCHAR) ;
        pwszSrc = (WCHAR*)_alloca( cb ) ;
        CopyMemory( pwszSrc, src, cb ) ;
    }

    //  Call the aligned method.
    //  Note: if this ever runs on Win95, we should call StrCmpW instead.
    return lstrcmpW( pwszDst, pwszSrc ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   ualstrlenW
//
//  Synopsis:   UNALIGNED UNICODE version of lstrlen
//
//  Arguments:  [wcs] -- string to return length of
//
//  Returns:
//
//  History:    1-11-95   davepl   NT Port
//
//  Notes:
//
//--------------------------------------------------------------------------

size_t ualstrlenW (UNALIGNED const WCHAR * wcs)
{
    UNALIGNED const WCHAR *eos = wcs;

    while( *eos++ )
    {
        NULL;
    }

    return( (size_t) (eos - wcs - 1) );
}

//+-------------------------------------------------------------------------
//
//  Function:   ualstrcpyW
//
//  Synopsis:   UNALIGNED UNICODE version of lstrcpy
//
//  Arguments:  [dst] -- string to copy to
//              [src] -- string to copy from
//
//  Returns:
//
//  History:    1-11-95   davepl   NT Port
//
//  Notes:
//
//--------------------------------------------------------------------------

UNALIGNED WCHAR * ualstrcpyW(UNALIGNED WCHAR * dst, UNALIGNED const WCHAR * src)
{
    UNALIGNED WCHAR * cp = dst;

    while( *cp++ = *src++ )
        NULL ;

    return( dst );
}

#endif // ALIGNMENT_MACHINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\unixstuff.c ===
/*
 * AR: Varma: REVIEW:
 * File contains wrappers for few symbols in shlwapi.src, that were exported
 * as an alias to other symbols. Chose wrappers instead of macros as they are
 * exported as an alias.
 */

#include "priv.h"

BOOL IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) {
    return StrIsIntlEqualA(fCaseSens, lpString1, lpString2, nChar);
}

BOOL IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar) {
    return StrIsIntlEqualW(fCaseSens, lpString1, lpString2, nChar);
}

STDAPI_(DWORD) SHDeleteOrphanKeyA( IN  HKEY    hkey, IN  LPCSTR  pszSubKey)
{
    return SHDeleteEmptyKeyA( hkey, pszSubKey );
}
 
STDAPI_(DWORD) SHDeleteOrphanKeyW( IN  HKEY    hkey, IN  LPCWSTR  pszSubKey)
{
    return SHDeleteEmptyKeyW( hkey, pszSubKey );
}
 
STDAPI_(BOOL) IsCharAlphaW(WCHAR wch) { return IsCharAlphaWrap(wch); }
STDAPI_(BOOL) IsCharAlphaNumericW(WCHAR wch) { return IsCharAlphaNumericWrap(wch); }
STDAPI_(BOOL) IsCharUpperW(WCHAR wch) { return IsCharUpperWrap(wch); }
STDAPI_(BOOL) IsCharLowerW(WCHAR wch) { return IsCharLowerWrap(wch); }


EXTERN_C HANDLE MapHandle(HANDLE hData, DWORD dwSource, DWORD dwDest, DWORD dwDesiredAccess, DWORD dwFlags)
{
    return SHMapHandle( hData, dwSource, dwDest, dwDesiredAccess, dwFlags );
}

int DrawTextExW(HDC hdc, LPWSTR lpchTextW, int cchTextW, LPRECT lprc, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams)
{
    int    iResult = 0;
    LPSTR  lpchTextA = NULL;
    int    cchTextA = -1;

    cchTextA = WideCharToMultiByte(CP_ACP, 0, lpchTextW, cchTextW, NULL, 0, NULL, NULL);
    ASSERT(cchTextA > 0);

    lpchTextA = (LPSTR) LocalAlloc(LPTR, cchTextA+1);
    if (!lpchTextA)
       goto cleanup;

    iResult = WideCharToMultiByte(CP_ACP, 0, lpchTextW, cchTextW, lpchTextA, cchTextA, NULL, NULL);

    if (iResult <= 0)
       goto cleanup;
    
    iResult = DrawTextExA(hdc, lpchTextA, cchTextA, lprc, dwDTFormat, lpDTParams);

cleanup:

    if (lpchTextA)
       LocalFree(lpchTextA);

    return iResult;
}

int SHAnsiToAnsiOld(LPCSTR pszSrc, LPSTR pszDst, int cchBuf)
{
   return SHAnsiToAnsi( pszSrc, pszDst, cchBuf );
}

int SHUnicodeToUnicodeOld(LPCWSTR pszSrc, LPWSTR pszDst, int cchBuf)
{
   return SHUnicodeToUnicode( pszSrc, pszDst, cchBuf );
}

// HtmlHelp Stubs.
HWND WINAPI HtmlHelpA( HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD dwData)
{
    MwNotYetImplemented("HtmlHelpA");
    return 0;
}

HWND WINAPI HtmlHelpW( HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD dwData)
{
    MwNotYetImplemented("HtmlHelpW");
    return 0;
}

HWND MLHtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD dwData, DWORD dwCrossCodePage)
{
    MwNotYetImplemented("MLHtmlHelpA");
    return 0;
}

HWND MLHtmlHelpW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD dwData, DWORD dwCrossCodePage)
{
    MwNotYetImplemented("MLHtmlHelpW");
    return 0;
}

LWSTDAPI SHCreateStreamOnFileAOld(LPCSTR pszFile, DWORD grfMode, IStream** ppstm)
{
    return SHCreateStreamOnFileA(pszFile, grfMode, ppstm);
}

LWSTDAPI SHCreateStreamOnFileWOld(LPCWSTR pwszFile, DWORD grfMode, IStream** ppstm)
{
    return SHCreateStreamOnFileW(pwszFile, grfMode, ppstm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\srccpp\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\urlpars.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    urlpars.cpp

Abstract:

    Contains all the worker routines for Combine and Canonicalize

    Contents:
        (ConvertChar)

Author:

    Zeke Lucas (zekel) 16-Dez-96

    Ahsan Kabir (akabir): UrlCombine parser rewritten in July-Sept98

Environment:

    Win32(s) user-mode DLL

Revision History:

    there is about one percent of this derived
    from the Spyglass or MSHTML/WININET codebase

--*/

#include "priv.h"
#include <shstr.h>

#ifdef UNIX
#include <shlobj.h>
#endif

#include <intshcut.h>

#ifdef _X86_
#include <w95wraps.h>
#endif

#include <shlwapip.h>

#ifdef UNIX
#include "unixstuff.h"
#endif
#include <wininet.h>

#define DM_PERF     0           // perf stats

#define PF_LOGSCHEMEHITS    0x00000001

#ifndef CPP_FUNCTIONS
#define CPP_FUNCTIONS
#include <crtfree.h>
#endif

#define USE_FAST_PARSER
#ifdef DEBUG
//#define PROOFREAD_PARSES
#endif

// Same as in wininet; however, this is only theoretical, since urls aren't necessarily so
// constrained. However, this is true throughout the product, so we'll have to do this.

#define INTERNET_MAX_PATH_LENGTH    2048
#define INTERNET_MAX_SCHEME_LENGTH  32

#define HEX_ESCAPE L'%'
#define HEX_ESCAPE_A '%'

#define TERMSTR(pch)      *(pch) = L'\0'

// (WCHAR) 8 is backspace
#define DEADSEGCHAR       ((WCHAR) 8)
#define KILLSEG(pch)      *(pch) = DEADSEGCHAR

#define CR          L'\r'
#define LF          L'\n'
#define TAB         L'\t'
#define SPC         L' '
#define SLASH       L'/'
#define WHACK       L'\\'
#define QUERY       L'?'
#define POUND       L'#'
#define SEMICOLON   L';'
#define COLON       L':'
#define BAR         L'|'
#define DOT         L'.'
#define AT          L'@'

#define UPF_SCHEME_OPAQUE           0x00000001  //  should not be treated as heriarchical
#define UPF_SCHEME_INTERNET         0x00000002
#define UPF_SCHEME_NOHISTORY        0x00000004
#define UPF_SCHEME_CONVERT          0x00000008  //  treat slashes and whacks as equiv
#define UPF_SCHEME_DONTCORRECT      0x00000010  //  Don't try to autocorrect to this scheme


#define UPF_SEG_ABSOLUTE            0x00000100  //  the initial segment is the root
#define UPF_SEG_LOCKFIRST           0x00000200  //  this is for file parsing
#define UPF_SEG_EMPTYSEG            0x00000400  //  this was an empty string, but is still important
#define UPF_EXSEG_DIRECTORY         0x00001000  //  the final segment is a "directory" (trailing slash)

#define UPF_FILEISPATHURL           0x10000000  //  this is for file paths, dont unescape because they are actually dos paths
//
//  the masks are for inheritance purposes during BlendParts
//  if you inherit that part you inherit that mask
//
#define UPF_SCHEME_MASK             0x000000FF
#define UPF_SEG_MASK                0x00000F00
#define UPF_EXSEG_MASK              0x0000F000


//  right now these masks are unused, and can be recycled
#define UPF_SERVER_MASK             0x000F0000
#define UPF_QUERY_MASK              0x0F000000

extern "C" int _StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar, BOOL fMBCS);
extern "C" LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch, BOOL fMBCS);
typedef struct _UrlParts
{
    DWORD   dwFlags;
    LPWSTR  pszScheme;
    URL_SCHEME eScheme;
    LPWSTR  pszServer;
    LPWSTR  pszSegments;
    DWORD   cSegments;
    LPWSTR  pszExtraSegs;
    DWORD   cExtraSegs;
    LPWSTR  pszQuery;
    LPWSTR  pszFragment;
} URLPARTS, *PURLPARTS;


HRESULT SHUrlParse(LPCWSTR pszBase, LPCWSTR pszUrl, PSHSTRW pstrOut, DWORD dwFlags);
HRESULT SHUrlCreateFromPath(LPCWSTR pszPath, PSHSTRW pstrOut, DWORD dwFlags);

// Ansi wrappers might overwrite the unicode core's return value
// We should try to prevent that
HRESULT ReconcileHresults(HRESULT hr1, HRESULT hr2)
{
    return (hr2==S_OK) ? hr1 : hr2;
}



PRIVATE CONST WORD isSafe[96] =

/*   Bit 0       alphadigit     -- 'a' to 'z', '0' to '9', 'A' to 'Z'
**   Bit 1       Hex            -- '0' to '9', 'a' to 'f', 'A' to 'F'
**   Bit 2       valid scheme   -- alphadigit | "-" | "." | "+"
**   Bit 3       mark           -- "%" | "$"| "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")" | ","
*/
/*   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
//    {0, 8, 0, 0, 8, 8, 0, 8, 8, 8, 8, 4, 8,12,12, 0,    /* 2x   !"#$%&'()*+,-./  */
// IE4 BETA1: allow + through unmolested.  Should consider other options
// post beta1.  12feb97 tonyci
    {0, 8, 0, 0, 8, 8, 0, 8, 8, 8, 8, 12, 8,12,12, 0,    /* 2x   !"#$%&'()*+,-./  */
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 0, 8, 0, 0,    /* 3x  0123456789:;<=>?  */
     8, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 4x  @ABCDEFGHIJKLMNO  */
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 8,    /* 5X  PQRSTUVWXYZ[\]^_  */
     0, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 6x  `abcdefghijklmno  */
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 8, 0};   /* 7X  pqrstuvwxyz{|}~  DEL */

PRIVATE const WCHAR hex[] = L"0123456789ABCDEF";

PRIVATE inline BOOL IsSafe(WCHAR ch, WORD mask)
{
    if(((ch > 31 ) && (ch < 128) && (isSafe[ch - 32] & mask)))
        return TRUE;

    return FALSE;
}

#define IsAlphaDigit(c)         IsSafe(c, 1)
#define IsHex(c)                IsSafe(c, 2)
#define IsValidSchemeCharA(c)    IsSafe(c, 5)
#define IsSafePathChar(c)       ((c > 0xff) || IsSafe(c, 9))
#define IsUpper(c)              ((c) >= 'A' && (c) <= 'Z')

PRIVATE inline BOOL IsAsciiCharW(WCHAR ch)
{
    return (!(ch >> 8) && ((CHAR) ch));
}

PRIVATE inline WCHAR Ascii_ToLowerW(WCHAR ch)
{
    return (ch >= L'A' && ch <= L'Z') ? (ch - L'A' + L'a') : ch;
}

BOOL IsValidSchemeCharW(WCHAR ch)
{
    if(IsAsciiCharW(ch))
        return IsSafe( (CHAR) ch, 5);
    return FALSE;
}



WCHAR const c_szHttpScheme[]           = L"http";
WCHAR const c_szFileScheme[]           = L"file";
WCHAR const c_szFTPScheme[]            = L"ftp";
WCHAR const c_szGopherScheme[]         = L"gopher";
WCHAR const c_szMailToScheme[]         = L"mailto";
WCHAR const c_szNewsScheme[]           = L"news";
WCHAR const c_szNNTPScheme[]           = L"nntp";
WCHAR const c_szTelnetScheme[]         = L"telnet";
WCHAR const c_szWAISScheme[]           = L"wais";
WCHAR const c_szMkScheme[]             = L"mk";
WCHAR const c_szHttpsScheme[]          = L"https";
WCHAR const c_szLocalScheme[]          = L"local";
WCHAR const c_szShellScheme[]          = L"shell";
WCHAR const c_szJSScheme[]             = L"javascript";
WCHAR const c_szVSScheme[]             = L"vbscript";
WCHAR const c_szAboutScheme[]          = L"about";
WCHAR const c_szSnewsScheme[]          = L"snews";
WCHAR const c_szResScheme[]            = L"res";
WCHAR const c_szRootedScheme[]         = L"ms-shell-rooted";
WCHAR const c_szIDListScheme[]         = L"ms-shell-idlist";
WCHAR const c_szMsHelpScheme[]         = L"hcp";

const struct
{
    LPCWSTR pszScheme;
    URL_SCHEME eScheme;
    DWORD cchScheme;
    DWORD dwFlags;
} g_mpUrlSchemeTypes[] =
    {
    // Because we use a linear search, sort this in the order of
    // most common usage.
    { c_szHttpScheme,   URL_SCHEME_HTTP,      SIZECHARS(c_szHttpScheme) - 1,     UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szFileScheme,   URL_SCHEME_FILE,      SIZECHARS(c_szFileScheme) - 1,     UPF_SCHEME_CONVERT},
    { c_szFTPScheme,    URL_SCHEME_FTP,       SIZECHARS(c_szFTPScheme) - 1,      UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szHttpsScheme,  URL_SCHEME_HTTPS,     SIZECHARS(c_szHttpsScheme) -1,     UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT|UPF_SCHEME_DONTCORRECT},
    { c_szNewsScheme,   URL_SCHEME_NEWS,      SIZECHARS(c_szNewsScheme) - 1,     UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szMailToScheme, URL_SCHEME_MAILTO,    SIZECHARS(c_szMailToScheme) - 1,   UPF_SCHEME_OPAQUE},
    { c_szGopherScheme, URL_SCHEME_GOPHER,    SIZECHARS(c_szGopherScheme) - 1,   UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szNNTPScheme,   URL_SCHEME_NNTP,      SIZECHARS(c_szNNTPScheme) - 1,     UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szTelnetScheme, URL_SCHEME_TELNET,    SIZECHARS(c_szTelnetScheme) - 1,   UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szWAISScheme,   URL_SCHEME_WAIS,      SIZECHARS(c_szWAISScheme) - 1,     0},
    { c_szMkScheme,     URL_SCHEME_MK,        SIZECHARS(c_szMkScheme) - 1,       UPF_SCHEME_NOHISTORY},
    { c_szShellScheme,  URL_SCHEME_SHELL,     SIZECHARS(c_szShellScheme) - 1,    UPF_SCHEME_OPAQUE},
    { c_szLocalScheme,  URL_SCHEME_LOCAL,     SIZECHARS(c_szLocalScheme) - 1,    0},
    { c_szJSScheme,     URL_SCHEME_JAVASCRIPT,SIZECHARS(c_szJSScheme) - 1,       UPF_SCHEME_OPAQUE|UPF_SCHEME_NOHISTORY},
    { c_szVSScheme,     URL_SCHEME_VBSCRIPT,  SIZECHARS(c_szVSScheme) - 1,       UPF_SCHEME_OPAQUE|UPF_SCHEME_NOHISTORY},
    { c_szSnewsScheme,  URL_SCHEME_SNEWS,     SIZECHARS(c_szSnewsScheme) - 1,    UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szAboutScheme,  URL_SCHEME_ABOUT,     SIZECHARS(c_szAboutScheme) - 1,    UPF_SCHEME_OPAQUE|UPF_SCHEME_NOHISTORY},
    { c_szResScheme,    URL_SCHEME_RES,       SIZECHARS(c_szResScheme) - 1,      UPF_SCHEME_NOHISTORY},
    { c_szRootedScheme, URL_SCHEME_MSSHELLROOTED, SIZECHARS(c_szRootedScheme) - 1, 0},
    { c_szIDListScheme, URL_SCHEME_MSSHELLIDLIST, SIZECHARS(c_szIDListScheme) - 1, 0},
    { c_szMsHelpScheme, URL_SCHEME_MSHELP,    SIZECHARS(c_szMsHelpScheme) - 1,   0},
    };

PRIVATE int _StrCmpNMixed(LPCSTR psz, LPCWSTR pwz, DWORD cch)
{
    int iRet = 0;

    //
    //  we dont have to real mbcs conversion here because we are
    //  guaranteed to have only ascii chars here
    //

    for (;cch; psz++, pwz++, cch--)
    {
        WCHAR ch = *psz;
        if (ch != *pwz)
        {
            //
            //  this makes it case insensitive
            if (IsUpper(ch) && (ch + 32) == *pwz)
                continue;

            if(ch > *pwz)
                iRet = 1;
            else
                iRet = -1;
            break;
        }
    }

    return iRet;
}

//***   g_iScheme -- cache for g_mpUrlSchemeTypes
// DESCRIPTION
//  we call GetSchemeTypeAndFlags many times for the same scheme.  if
//  it's the 0th table entry, no biggee.  if it's a later entry linear
//  search isnt very good.  add a 1-element MRU cache.  even for the most common
//  (by far) case of "http" (0th entry), we *still* win due to the cheaper
//  StrCmpC and skipped loop.
// NOTES
//  g_iScheme refs/sets are atomic so no need for lock
int g_iScheme;      // last guy we hit

#ifdef DEBUG
int g_cSTTot, g_cSTHit, g_cSTHit0;
#endif

//
//  all of the pszScheme to nScheme functions are necessary at this point
//  because some parsing is vioent, and some is necessarily soft
//
PRIVATE URL_SCHEME
GetSchemeTypeAndFlagsW(LPCWSTR pszScheme, DWORD cchScheme, LPDWORD pdwFlags)
{
    DWORD i;

    ASSERT(pszScheme);


#ifdef DEBUG
    if ((g_cSTTot % 10) == 0)
        TraceMsg(DM_PERF, "gstaf: tot=%d hit=%d hit0=%d", g_cSTTot, g_cSTHit, g_cSTHit0);
#endif
    DBEXEC(TRUE, g_cSTTot++);
    // check cache 1st
    i = g_iScheme;
    if (cchScheme == g_mpUrlSchemeTypes[i].cchScheme
      && StrCmpNCW(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme) == 0)
    {
        DBEXEC(TRUE, i == 0 ? g_cSTHit0++ : g_cSTHit++);
Lhit:
        if (pdwFlags)
            *pdwFlags = g_mpUrlSchemeTypes[i].dwFlags;

        // update cache (unconditionally)
        g_iScheme = i;

        return g_mpUrlSchemeTypes[i].eScheme;
    }

    for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
    {
        if(cchScheme == g_mpUrlSchemeTypes[i].cchScheme
          && 0 == StrCmpNIW(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme))
            goto Lhit;
    }

    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return URL_SCHEME_UNKNOWN;
}

PRIVATE URL_SCHEME
GetSchemeTypeAndFlagsA(LPCSTR pszScheme, DWORD cchScheme, LPDWORD pdwFlags)
{
    DWORD i;

    ASSERT(pszScheme);


    for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
    {
        if(0 == _StrCmpNMixed(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme))
        {
            if (pdwFlags)
                *pdwFlags = g_mpUrlSchemeTypes[i].dwFlags;
            return g_mpUrlSchemeTypes[i].eScheme;
        }
    }

    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return URL_SCHEME_UNKNOWN;
}

PRIVATE DWORD GetSchemeFlags(URL_SCHEME eScheme)
{
    DWORD i;

    for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
    {
        if(eScheme == g_mpUrlSchemeTypes[i].eScheme)
        {
            return g_mpUrlSchemeTypes[i].dwFlags;
        }
    }
    return 0;
}


/*----------------------------------------------------------
Purpose: Return the scheme ordinal type (URL_SCHEME_*) based on the
         URL string.


Returns: URL_SCHEME_ ordinal
Cond:    --
*/

PRIVATE inline BOOL IsSameSchemeW(LPCWSTR pszLocal, LPCWSTR pszGlobal, DWORD cch)
{
    ASSERT(pszLocal);
    ASSERT(pszGlobal);
    ASSERT(cch);

    return !StrCmpNIW(pszLocal, pszGlobal, cch);
}

PRIVATE BOOL IsSameSchemeA(LPCSTR pszLocal, LPCWSTR pszGlobal, DWORD cch)
{
    ASSERT(pszLocal);
    ASSERT(pszGlobal);
    ASSERT(cch);

    return !_StrCmpNMixed(pszLocal, pszGlobal, cch);
}


PRIVATE URL_SCHEME
SchemeTypeFromStringA(
   LPCSTR psz,
   DWORD cch)
{
   DWORD i;

   // psz is a counted string (by cch), not a null-terminated string,
   // so use IS_VALID_READ_BUFFER instead of IS_VALID_STRING_PTRA.
   ASSERT(IS_VALID_READ_BUFFER(psz, CHAR, cch));
   ASSERT(cch);
   // We use a linear search.  A binary search wouldn't pay off
   // because the list isn't big enough, and we can sort the list
   // according to the most popular protocol schemes and pay off
   // bigger.

   for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
   {
       if(cch == g_mpUrlSchemeTypes[i].cchScheme &&
           IsSameSchemeA(psz, g_mpUrlSchemeTypes[i].pszScheme, cch))
            return g_mpUrlSchemeTypes[i].eScheme;
   }

   return URL_SCHEME_UNKNOWN;
}


PRIVATE URL_SCHEME
SchemeTypeFromStringW(
   LPCWSTR psz,
   DWORD cch)
{
   DWORD i;

   // psz is a counted string (by cch), not a null-terminated string,
   // so use IS_VALID_READ_BUFFER instead of IS_VALID_STRING_PTRW.
   ASSERT(IS_VALID_READ_BUFFER(psz, WCHAR, cch));
   ASSERT(cch);

   // We use a linear search.  A binary search wouldn't pay off
   // because the list isn't big enough, and we can sort the list
   // according to the most popular protocol schemes and pay off
   // bigger.

   for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
   {
       if(cch == g_mpUrlSchemeTypes[i].cchScheme &&
           IsSameSchemeW(psz, g_mpUrlSchemeTypes[i].pszScheme, cch))
            return g_mpUrlSchemeTypes[i].eScheme;
   }

   return URL_SCHEME_UNKNOWN;
}

//
//  these are used during path fumbling that i do
//  each string between a path delimiter ( '/' or '\')
//  is a segment.  we dont ever really care about
//  empty ("") segments, so it is best to use
//  NextLiveSegment().
//
inline PRIVATE LPWSTR
NextSegment(LPWSTR psz)
{
    ASSERT (psz);
    return psz + lstrlenW(psz) + 1;
}

#define IsLiveSegment(p)    ((p) && (*p) != DEADSEGCHAR)

PRIVATE LPWSTR
NextLiveSegment(LPWSTR pszSeg, DWORD *piSeg, DWORD cSegs)
{
    if(pszSeg) do
    {
        //
        //  count the number of dead segments that we skip.
        //  if the segment isnt dead, then we can just skip one,
        //  the current one.
        //
        DWORD cSkip;
        for (cSkip = 0; (*pszSeg) == DEADSEGCHAR; pszSeg++, cSkip++);
        cSkip = cSkip ? cSkip : 1;

        if((*piSeg) + cSkip < cSegs)
        {

            pszSeg = NextSegment(pszSeg);
            (*piSeg) += cSkip;
        }
        else
            pszSeg = NULL;

    } while (pszSeg && (*pszSeg == DEADSEGCHAR));

    return pszSeg;
}

PRIVATE LPWSTR
LastLiveSegment(LPWSTR pszSeg, DWORD cSegs, BOOL fFailIfFirst)
{
    DWORD iSeg = 0;
    LPWSTR pszLast = NULL;
    BOOL fLastIsFirst = FALSE;

    if(cSegs)
    {
        if(IsLiveSegment(pszSeg))
        {
            pszLast = pszSeg;
            fLastIsFirst = TRUE;
        }

        while(pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs))
        {
            if(!pszLast)
                fLastIsFirst = TRUE;
            else
                fLastIsFirst = FALSE;

            pszLast = pszSeg;
        }

        if(fFailIfFirst && fLastIsFirst)
            pszLast = NULL;
    }

    return pszLast;
}

PRIVATE LPWSTR
FirstLiveSegment(LPWSTR pszSeg, DWORD *piSeg, DWORD cSegs)
{
    ASSERT(piSeg);

    *piSeg = 0;

    if(!pszSeg || !cSegs)
        return NULL;

    if(!IsLiveSegment(pszSeg))
        pszSeg = NextLiveSegment(pszSeg, piSeg, cSegs);

    return pszSeg;
}

inline BOOL IsDosDrive(LPCWSTR p)
{
    return (*p && p[1] == COLON);
}

inline BOOL IsDosPath(LPCWSTR p)
{
    return (*p == WHACK ||  IsDosDrive(p));
}

inline BOOL IsDriveUrl(const WCHAR *p)
{
    return (*p && p[1] == BAR);
}

inline BOOL IsDrive(LPCWSTR p)
{
    return (IsDosDrive(p) || IsDriveUrl(p));
}

inline BOOL IsSeparator(const WCHAR *p)
{
    return (*p == SLASH || *p == WHACK );
}

inline BOOL IsAbsolute(const WCHAR *p)
{
#ifndef UNIX
    return (IsSeparator(p) || IsDrive(p));
#else
    return (IsSeparator(p)) ;
#endif
}

#define IsUNC(pathW) PathIsUNCW(pathW)

inline BOOL IsDot(LPCWSTR p)     // if p == "." return TRUE
{
    return (*p == DOT && !p[1]);
}

inline BOOL IsDotDot(LPCWSTR p)  // if p == ".." return TRUE
{
    return (*p == DOT && p[1] == DOT && !p[2]);
}

//+---------------------------------------------------------------------------
//
//  Method:     ConvertChar
//
//  Synopsis:
//
//  Arguments:  [szStr] --
//              [cIn] --
//              [cOut] --
//
//  Returns:
//
//  History:    03-20-96    JoeS (Joe Souza)    Created
//
//  Notes:
//
//----------------------------------------------------------------------------
static void ConvertChar(LPWSTR ptr, WCHAR cIn, WCHAR cOut, BOOL fProtectExtra)
{
    while (*ptr)
    {
        if (fProtectExtra && (*ptr == QUERY || *ptr == POUND ))
        {
            break;
        }

        if (*ptr == cIn)
        {
            *ptr = cOut;
        }

        ptr++;
    }
}

PUBLIC void WininetFixFileSlashes(WCHAR *p)
{
    // NB: This function assumes that p points to a file URL.
    // The file URL *MUST* be of the form "file://...".
    // HTParse() guarantees that this will be so.

    int schemelen = 0;

    schemelen = SIZECHARS(L"file://") - 1;

    /* In UNIX system, we don't need to convert the SLASH to WHACK */
    if (p && lstrlenW(p) > schemelen)
    {
#ifdef UNIX
        ConvertChar(p + schemelen, WHACK, SLASH, TRUE);
#else
        ConvertChar(p + schemelen, SLASH, WHACK, TRUE);
#endif
    }
}

//
//  in the URL spec, it says that all whitespace should be ignored
//  due to the fact that it is possible to introduce
//  new whitespace and eliminate other whitespace
//  however, we are only going to strip out TAB CR LF
//  because we consider SPACE's to be significant.
//

PRIVATE inline BOOL IsInsignificantWhite(WCHAR ch)
{
    return (ch == TAB ||
            ch == CR ||
            ch == LF);
}

#define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)

PRIVATE void TrimAndStripInsignificantWhite(WCHAR *psz)
{
    ASSERT(psz);

    if(*psz)
    {

        LPCWSTR pszSrc = psz;
        LPWSTR pszDest = psz;
        LPWSTR pszLastSpace = NULL;

        // first trim the front side by just moving the source pointer.
        while(*pszSrc && IsWhite(*pszSrc)) {
            pszSrc++;
        }

        //
        // Copy the body stripping "insignificant" white spaces.
        // Remember the last white space to trim trailing space later.
        //
        while (*pszSrc)
        {
            if(IsInsignificantWhite(*pszSrc)) {
                pszSrc++;
            } else {
                if (IsWhite(*pszSrc)) {
                    if (pszLastSpace==NULL) {
                        pszLastSpace = pszDest;
                    }
                } else {
                    pszLastSpace = NULL;
                }

                *pszDest++ = *pszSrc++;
            }
        }

        // Trim the trailing space
        if (pszLastSpace) {
            *pszLastSpace = L'\0';
        } else {
            *pszDest = L'\0';
        }

    }

#if 0
    // APPCOMPAT - NETSCAPE compatibility - zekel 29-JAN-97
    //  we want to leave one space in the string
    if(*psz== L'\0')
    {
        psz[0] = SPC;
        psz[1] = L'\0';
    }
#endif

}


struct EXTKEY
{
    PCSTR  szExt;
    PCWSTR wszExt;
    DWORD cchExt;
};

const EXTKEY ExtTable[] = {
       {    ".html",        L".html",           ARRAYSIZE(".html") - 1 },
       {    ".htm",         L".htm",            ARRAYSIZE(".htm") - 1  },
       {    ".xml",         L".xml",            ARRAYSIZE(".xml") - 1  },
       {    ".doc",         L".doc",            ARRAYSIZE(".doc") - 1  },
       {    ".xls",         L".xls",            ARRAYSIZE(".xls") - 1  },
       {    ".ppt",         L".ppt",            ARRAYSIZE(".ppt") - 1  },
       {    ".rtf",         L".rtf",            ARRAYSIZE(".rtf") - 1  },
       {    ".dot",         L".dot",            ARRAYSIZE(".dot") - 1  },
       {    ".xlw",         L".xlw",            ARRAYSIZE(".xlw") - 1  },
       {    ".pps",         L".pps",            ARRAYSIZE(".pps") - 1  },
       {    ".xlt",         L".xlt",            ARRAYSIZE(".xlt") - 1  },
       {    ".hta",         L".hta",            ARRAYSIZE(".hta") - 1  },
       {    ".pot",         L".pot",            ARRAYSIZE(".pot") - 1  }
};

inline BOOL CompareExtA(PCSTR psz, DWORD_PTR cch)
{
    for (DWORD i=0; i < ARRAYSIZE(ExtTable); i++)
    {
        if (ExtTable[i].cchExt>cch)
            continue;

        if (!StrCmpNIA(psz - (LONG_PTR)ExtTable[i].cchExt, ExtTable[i].szExt, ExtTable[i].cchExt))
            return TRUE;
    }
    return FALSE;
}

inline BOOL CompareExtW(PCWSTR pwsz, DWORD_PTR cch)
{
    for (DWORD i=0; i < ARRAYSIZE(ExtTable); i++)
    {
        if (ExtTable[i].cchExt>cch)
            continue;

        if (!StrCmpNIW(pwsz - (LONG_PTR)ExtTable[i].cchExt, ExtTable[i].wszExt, ExtTable[i].cchExt))
            return TRUE;
    }
    return FALSE;
}


PRIVATE LPCSTR FindFragmentA(LPCSTR psz, BOOL fMBCS, BOOL fIsFile)
{
    CHAR *pch = _StrChrA(psz, POUND, fMBCS);
    if(pch && fIsFile)
    {
        CHAR *pchQuery = _StrChrA(psz, QUERY, fMBCS);
        if (pchQuery && (pchQuery < pch))
            goto exit;

        do
        {
            LONG_PTR cch = pch - psz;

            // REARCHITECT: we shouldn't hardcode ".htm".
            //  #s are significant in dospaths - zekel 9-JUL-97
            //  so we want to check the path in front and make sure
            //  that it is an html file.  we believe this heuristic should work
            //  in about 99% of all cases.
            //
            // if it is not an html file it is not a hash
            if (CompareExtA(pch, cch))
            {
                break;
            }
        } while (pch = _StrChrA(++pch, POUND, fMBCS));
    }
exit:
    return pch;
}

PRIVATE LPCWSTR FindFragmentW(LPCWSTR psz, BOOL fIsFile)
{
    WCHAR *pch = StrChrW(psz, POUND);
    if(pch && fIsFile)
    {
        WCHAR *pchQuery = StrChrW(psz, QUERY);
        if (pchQuery && (pchQuery < pch))
            goto exit;

        do
        {
            LONG_PTR cch = pch - psz;

            // REARCHITECT: we shouldn't hardcode ".htm".
            //  #s are significant in dospaths - zekel 9-JUL-97
            //  so we want to check the path in front and make sure
            //  that it is an html file.  we believe this heuristic should work
            //  in about 99% of all cases.
            //
            // if it is not an html file it is not a hash
            if (CompareExtW(pch, cch))
            {
                break;
            }

        } while (pch = StrChrW(++pch, POUND));
    }
exit:
    return pch;
}

PRIVATE VOID BreakFragment(LPWSTR *ppsz, PURLPARTS parts)
{
    ASSERT(ppsz);
    ASSERT(*ppsz);

    //
    //  Opaque URLs are not allowed to use fragments - zekel 27-feb-97
    //  Is it possible for an opaque URL to use a fragment?
    //  right now we assume not.  i suspect so but will leave it this way for now
    //  this is especially important to javascript and vbscript
    //  FEATURE: this might be worth investigation, but probably can't change this code
    //
    if(!**ppsz || parts->dwFlags & UPF_SCHEME_OPAQUE)
        return;

    WCHAR *pch = (LPWSTR) FindFragmentW(*ppsz, parts->eScheme == URL_SCHEME_FILE);

    if (pch)
    {
        TERMSTR(pch);
        parts->pszFragment = pch +1;
    }
}

PRIVATE inline BOOL IsUrlPrefixA(LPCSTR psz)
{
    //
    // Optimized for this particular case. Notice that most of it
    // will be lego-ized out anyway.
    //
    if (psz[0]=='u' || psz[0]=='U') {
        if (psz[1]=='r' || psz[1]=='R') {
            if (psz[2]=='l' || psz[2]=='L') {
                return TRUE;
            }
        }
    }
    return FALSE;
    // return !StrCmpNIA(psz, c_szURLPrefixA, c_cchURLPrefix);
}

PRIVATE inline BOOL IsUrlPrefixW(LPCWSTR psz)
{
    //
    // Optimized for this particular case. Notice that most of it
    // will be lego-ized out anyway.
    //
    if (psz[0]==L'u' || psz[0]==L'U') {
        if (psz[1]==L'r' || psz[1]==L'R') {
            if (psz[2]==L'l' || psz[2]==L'L') {
                return TRUE;
            }
        }
    }
    return FALSE;
    // return !StrCmpNIW(psz, c_szURLPrefixW, c_cchURLPrefix);
}

//
//  if FindScheme() succeeds, it returns a pointer to the scheme,
//  and the cch holds the count of chars for the scheme
//  if it fails, and cch is non-zero then cch is how much should be skipped.
//  this is to allow "URL:/foo/bar", a relative URL with the "URL:" prefix.
//
LPCSTR FindSchemeA(LPCSTR psz, LPDWORD pcchScheme)
{
    LPCSTR pch;
    DWORD cch;

    ASSERT(pcchScheme);
    ASSERT(psz);

    *pcchScheme = 0;

    for (pch = psz, cch = 0; *pch; pch++, cch++)
    {
        if (*pch == ':')
        {
            if (IsUrlPrefixA(psz))
            {
                psz = pch +1;

                //  set pcchScheme to skip past "URL:"
                *pcchScheme = cch + 1;

                //  reset cch for the scheme len
                cch = -1;
                continue;
            }
            else
            {
                //
                //  Scheme found if it is at least two characters
                if(cch > 1)
                {
                    *pcchScheme = cch;
                    return psz;
                }
                break;
            }
        }
        if(!IsValidSchemeCharA(*pch))
            break;
    }

    return NULL;
}

//
//  FindSchemeW() around for Perf reasons for ParseURL()
//  Any changes in either FindScheme() needs to reflected in the other
//
LPCWSTR FindSchemeW(LPCWSTR psz, LPDWORD pcchScheme, BOOL fAllowSemicolon = FALSE)
{
    LPCWSTR pch;
    DWORD cch;

    ASSERT(pcchScheme);
    ASSERT(psz);

    *pcchScheme = 0;

    for (pch = psz, cch = 0; *pch; pch++, cch++)
    {

        if (*pch == L':' ||

            // Autocorrect permits a semicolon typo
            (fAllowSemicolon && *pch == L';'))
        {
            if (IsUrlPrefixW(psz))
            {
                psz = pch +1;

                //  set pcchScheme to skip past "URL:"
                *pcchScheme = cch + 1;

                //  reset cch for the scheme len
                cch = -1;
                continue;
            }
            else
            {
                //
                //  Scheme found if it is at least two characters
                if(cch > 1)
                {
                    *pcchScheme = cch;
                    return psz;
                }
                break;
            }
        }
        if(!IsValidSchemeCharW(*pch))
            break;
    }

    return NULL;
}

PRIVATE DWORD
CountSlashes(LPCWSTR *ppsz)
{
    DWORD cSlashes = 0;
    LPCWSTR pch = *ppsz;

    while (IsSeparator(pch))
    {
        *ppsz = pch;
        pch++;
        cSlashes++;
    }

    return cSlashes;
}


PRIVATE LPCWSTR
FindDosPath(LPCWSTR psz)
{
    if (IsDosDrive(psz) || IsUNC(psz))
    {
        return psz;
    }
    else
    {
        DWORD cch;
        LPCWSTR pszScheme = FindSchemeW(psz, &cch);

        if (pszScheme && URL_SCHEME_FILE == GetSchemeTypeAndFlagsW(pszScheme, cch, NULL))
        {
            LPCWSTR pch = psz + cch + 1;
            DWORD c = CountSlashes(&pch);

            switch (c)
            {
            case 2:
                if(IsDosDrive(++pch))
                    return pch;
                break;

            case 4:
                return --pch;
            }
        }
    }
    return NULL;
}


/*+++

  WininetCopyUrlForParse()
    this copies the url and prepends a "file://" if necessary
    This should never be called except from wininet
    everyone else should be calling UrlCreateFromPath()

  Parameters
  IN -
    pszDst      the destination buffer
    pszSrc      source buffer

  OUT -
    pszDst      is filled with a Live URL

  Returns
  VOID

  NOTE - Assume "file:" if no scheme and it looks like fully-qualified file path.
---*/
static const WCHAR c_szFileSchemeString[] = L"file://";

PRIVATE HRESULT
WininetCopyUrlForParse(PSHSTRW pstrDst, LPCWSTR pszSrc)
{
#ifndef UNIX
    if (IsDrive(pszSrc) || IsUNC(pszSrc))
    {
        //
        // NOTE: the first SetStr will always succeed
        // because the default buffer is more than "file://"
        pstrDst->SetStr(c_szFileSchemeString);
        return pstrDst->Append(pszSrc);
    }
    else
#endif /* !UNIX */
        return pstrDst->SetStr(pszSrc);

}

PRIVATE HRESULT
CopyUrlForParse(LPCWSTR pszUrl, PSHSTRW pstrUrl, DWORD dwFlags)
{
    LPCWSTR pch;
    HRESULT hr;
    //
    //  now we will make copies of the URLs so that we can rip them apart
    //  WininetCopyUrlForParse() will prepend a file: if it wants...
    //

    if(dwFlags & URL_WININET_COMPATIBILITY)
    {
        hr = WininetCopyUrlForParse(pstrUrl, pszUrl);
    }
    else if(pch = FindDosPath(pszUrl))
    {
        hr = SHUrlCreateFromPath(pch, pstrUrl, dwFlags);
    }
    else
    {
        hr = pstrUrl->SetStr(pszUrl);
    }

    // Trim leading and trailing whitespace
    // Remove tab and CRLF characters.  Netscape does this.
    if(SUCCEEDED(hr))
        TrimAndStripInsignificantWhite(pstrUrl->GetInplaceStr());


    return hr;
}


PRIVATE VOID BreakScheme(LPWSTR *ppsz, PURLPARTS parts)
{
    if(!**ppsz || IsDrive(*ppsz))
        return;

    DWORD cch;

    //
    //  if FindScheme() succeeds, it returns a pointer to the scheme,
    //  and the cch holds the count of chars for the scheme
    //  if it fails, and cch is none zero then cch is how much should be skipped.
    //  this is to allow "URL:/foo/bar", a relative URL with the "URL:" prefix.
    //
    if(NULL != (parts->pszScheme = (LPWSTR) FindSchemeW(*ppsz, &cch)))
    {
        parts->pszScheme[cch] = '\0';
        CharLowerW(parts->pszScheme);

        //  put the pointer past the scheme for next Break()
        *ppsz = parts->pszScheme + cch + 1;


#ifdef DEBUG
        if (g_dwPrototype & PF_LOGSCHEMEHITS)
        {
            //  this is for logging of url schemes, to make sure that we have the right order
            int c = GetPrivateProfileIntW(L"SchemeHits", parts->pszScheme, 0, L"UrlPars.ini");
            WCHAR szc[25];
            wsprintfW(szc, L"%d", ++c);
            WritePrivateProfileStringW(L"SchemeHits", parts->pszScheme, szc, L"UrlPars.ini");
        }
#endif //DEBUG


        parts->eScheme = GetSchemeTypeAndFlagsW(parts->pszScheme, cch, &parts->dwFlags);
    }
    else if (cch)
        *ppsz += cch + 1;
}


PRIVATE VOID BreakQuery(LPWSTR *ppsz, PURLPARTS parts)
{
    WCHAR *pch;

    if(!**ppsz)
        return;

    if(parts->dwFlags & UPF_SCHEME_OPAQUE)
        return;

    pch = StrChrW(*ppsz, QUERY);

    //
    //  APPCOMPAT NETSCAPE COMPATBILITY - zekel - 27-JAN-97
    //  we will also get http://foo#frag?query
    //  even tho legally it should be http://foo?query#frag
    //  of course we will put it back together the right way.
    //
    if(!pch && parts->pszFragment)
        pch = StrChrW(parts->pszFragment, QUERY);

    //  found our query string...
    if (pch)
    {
        TERMSTR(pch);
        parts->pszQuery = pch + 1;
    }
}

PRIVATE VOID MkBreakServer(LPWSTR *ppsz, PURLPARTS parts)
{
    //
    //  NOTE:  we dont convert WHACKs to SLASHs because mk can be of the
    //  form <mk:@class:\\Server\Share\file.itl/path/in/the/file.gif
    //  and we want to preserve the DOS/UNC path as it is
    //

    if (**ppsz == TEXT('@'))
    {
        WCHAR *pch;
        // treat everything to separator as host
        //
        parts->pszServer = *ppsz;

        pch = StrChrW(*ppsz ,SLASH);
        if (pch)
        {
            parts->dwFlags |= UPF_SEG_ABSOLUTE;
            TERMSTR(pch);
            *ppsz = pch + 1;
        }
        else
            *ppsz += lstrlenW(*ppsz);
    }
}

PRIVATE VOID DefaultBreakServer(LPWSTR *ppsz, PURLPARTS parts)
{
    if (**ppsz == SLASH)
    {
        parts->dwFlags |= UPF_SEG_ABSOLUTE;

        (*ppsz)++;

        if (**ppsz == SLASH)
        {
            // we have a winner!
            WCHAR * pch;

            parts->pszServer = (*ppsz) + 1;

            pch = StrChrW(parts->pszServer, SLASH);

            if(pch)
            {
                TERMSTR(pch);
                *ppsz = pch + 1;
            }
            else
                *ppsz = *ppsz + lstrlenW(*ppsz);
        }
    }
    else if(parts->pszScheme)
        parts->dwFlags |= UPF_SCHEME_OPAQUE;
}

PRIVATE VOID FileBreakServer(LPWSTR *ppsz, PURLPARTS parts)
{
    LPWSTR pch;

    //  CountSlashes() will set *ppsz to the last slash
    DWORD cSlashes = CountSlashes((LPCWSTR *)ppsz);

    if(cSlashes || IsDrive(*ppsz))
        parts->dwFlags |= UPF_SEG_ABSOLUTE;

    switch (cSlashes)
    {
    case 0:
        break;

    case 4:
        // we identify file://\\UNC as a true DOS path with no escaped characters
        parts->dwFlags |= UPF_FILEISPATHURL;

        // fall through

    case 2:
        if(IsDrive((*ppsz) + 1))
        {
            //  this is a root drive
            TERMSTR(*ppsz);
            parts->pszServer = *ppsz;
            (*ppsz)++;
            // we identify file://C:\PATH as a true DOS path with no escaped characters
            parts->dwFlags |= UPF_FILEISPATHURL;
            break;
        } //else fallthru to UNC handling
        // fall through

    case 5:
    case 6:
        //
        // cases like "file:////..." or "file://///..."
        // we see this as a UNC path
        // lets set the server
        //
        parts->pszServer = ++(*ppsz);
        for(pch = *ppsz; *pch && !IsSeparator(pch); pch++);

        if(pch && *pch)
        {
            TERMSTR(pch);
            *ppsz = pch + 1;
        }
        else
            *ppsz = pch + lstrlenW(pch);
        break;

    case 1:
        //
        //we think of "file:/..." as on the local machine
        // so we have zero length pszServer
        //
    case 3:
        //
        //we think of file:///... as properly normalized on the local machine
        // so we have zero length pszServer
        //
    default:
        //  there is just too many, we pretend that there is just one and ignore
        //  the rest
        TERMSTR(*ppsz);
        parts->pszServer = *ppsz;
        (*ppsz)++;
        break;
    }

    //  detect file://localserver/c:/path
    if(parts->pszServer && !StrCmpIW(parts->pszServer, L"localhost"))
        parts->pszServer = NULL;
}

PRIVATE VOID BreakServer(LPWSTR *ppsz, PURLPARTS parts, BOOL fConvert)
{
    if(!**ppsz || parts->dwFlags & UPF_SCHEME_OPAQUE)
        return;

    //
    //  APPCOMPAT - we pretend that whacks are the equiv of slashes - zekel 17-MAR-97
    //  this is because the internet uses slashes and DOS
    //  uses whacks.  so for useability's sake we allow both.
    //  but not in all cases.  in particular, the "mk:" stream
    //  protocol depends upon the buggy behavior of one of IE30's
    //  many URL parsers treating relative URLs with whacks as one
    //  segment.
    //  NOTE:  IE30 had inconsistent behavior WRT URLs.  so we handled
    //  this case differently depending on when we saw, looked, touched, or
    //  played with these URLs.  wininet would always convert, but mshtml
    //  sometimes would other times not.
    //
    //  with MK: we cannot convert the base, or the relative
    //  but in breakpath we have to allow for the use of WHACK
    //  to indicate a root path
    //
    //  we dont have to fProtectExtra because query and fragments
    //  are already broken off if necessary.
    if (fConvert)
        ConvertChar(*ppsz, WHACK, SLASH, FALSE);

    switch(parts->eScheme)
    {
    case URL_SCHEME_FILE:
        FileBreakServer(ppsz, parts);
        break;

    case URL_SCHEME_MK:
        MkBreakServer(ppsz, parts);
        break;

    default:
        DefaultBreakServer(ppsz, parts);
        break;
    }
}

PRIVATE VOID DefaultBreakSegments(LPWSTR psz, PURLPARTS parts)
{
    WCHAR *pch;

    while (pch = StrChrW(psz, SLASH))
    {
        parts->cSegments++;
        TERMSTR(pch);
        psz = pch + 1;
    }

    if(!*psz || IsDot(psz) || IsDotDot(psz))
    {
        if (!*psz && parts->cSegments > 1)
            parts->cSegments--;

        parts->dwFlags |= UPF_EXSEG_DIRECTORY;
    }
}

PRIVATE VOID DefaultBreakPath(LPWSTR *ppsz, PURLPARTS parts)
{
    if(!**ppsz)
        return;

    //
    //  this will keep the drive letter from being backed up over
    //  during canonicalization.  if we want keep the UNC share
    //  from being backed up we should do it here
    //  or in FileBreakServer() similarly
    //
    if(IsDrive(*ppsz))
    {
        parts->dwFlags |= UPF_SEG_LOCKFIRST;
        // also convert "c|" to "c:"
    }

    parts->pszSegments = *ppsz;
    parts->cSegments = 1;

    if(!(parts->dwFlags & UPF_SCHEME_OPAQUE))
        DefaultBreakSegments(parts->pszSegments, parts);

}

PRIVATE VOID BreakPath(LPWSTR *ppsz, PURLPARTS parts)
{
    if(!**ppsz)
        return;

    if (parts->dwFlags & UPF_SCHEME_OPAQUE)
    {
        parts->pszSegments = *ppsz;
        parts->cSegments = 1;
    }
    else
    {
        //
        //  we only need to check for absolute when there was
        //  no server segment.  if there was a server segment,
        //  then absolute has already been set, and we need
        //  to preserve any separators that exist in the path
        //
        if(!parts->pszServer && IsSeparator(*ppsz))
        {
            parts->dwFlags |= UPF_SEG_ABSOLUTE;
            (*ppsz)++;
        }

        DefaultBreakPath(ppsz, parts);
    }
}


BOOL _ShouldBreakBase(PURLPARTS parts, LPCWSTR pszBase)
{
    if (pszBase)
    {
        if (!parts->pszScheme)
            return TRUE;

        DWORD cch;
        LPCWSTR pszScheme = FindSchemeW(pszBase, &cch);

        //  this means that this will only optimize on known schemes
        //  if both urls use URL_SCHEME_UNKNOWN...then we parse both.
        if (pszScheme && parts->eScheme == GetSchemeTypeAndFlagsW(pszScheme, cch, NULL))
            return TRUE;

    }

    return FALSE;
}

/*+++

  BreakUrl()
    Break a URL for its consituent parts

  Parameters
  IN -
            the URL to crack open, need not be fully qualified

  OUT -
    parts       absolute or relative may be nonzero (but not both).
                host, anchor and access may be nonzero if they were specified.
                Any which are nonzero point to zero terminated strings.

  Returns
    VOID

  Details -

  WARNING !! function munges the incoming buffer

---*/

#define BreakUrl(s, p)         BreakUrls(s, p, NULL, NULL, NULL, 0)

//
//  **BreakUrls()**
//  RETURNS
//  S_OK        if the two urls need to be blended
//  S_FALSE     if pszUrl is absolute, or there is no pszBase
//  failure     some sort of memory allocation error
//
PRIVATE HRESULT
BreakUrls(LPWSTR pszUrl, PURLPARTS parts, LPCWSTR pszBase, PSHSTRW pstrBase, PURLPARTS partsBase, DWORD dwFlags)
{
    HRESULT hr = S_FALSE;
    ASSERT(pszUrl && parts);

    ZeroMemory(parts, SIZEOF(URLPARTS));

    if(!*pszUrl)
        parts->dwFlags |= UPF_SEG_EMPTYSEG;

    //
    //  WARNING: this order is specific, according to the proposed standard
    //
    if(*pszUrl || pszBase)
    {
        BOOL fConvert;

        BreakScheme(&pszUrl, parts);
        BreakFragment(&pszUrl, parts);
        BreakQuery(&pszUrl, parts);

        //
        //  this is the first time that we need to access
        //  pszBase if it exists, so this is when we copy and parse
        //
        if (_ShouldBreakBase(parts, pszBase))
        {
            hr = CopyUrlForParse(pszBase, pstrBase, dwFlags);

            //  this will be some kind of memory error
            if(FAILED(hr))
                return hr;

            // ASSERT(hr != S_FALSE);

            BreakUrl(pstrBase->GetInplaceStr(), partsBase);
            fConvert = (partsBase->dwFlags & UPF_SCHEME_CONVERT);
        }
        else
            fConvert = (parts->dwFlags & UPF_SCHEME_CONVERT);

        BreakServer(&pszUrl, parts, fConvert);
        BreakPath(&pszUrl, parts);
    }

    return hr;
}


/*+++
  BlendParts()  & all dependant Blend* functions
        Blends the parts structures into one, taking the relavent
        bits from each one and dumping the unused data.

  Parameters
  IN -
    partsUrl        the primary or relative parts   - Takes precedence
    partsBase       the base or referrers parts

  OUT -
    partsOut        the combined result

  Returns
  VOID -

  NOTE:  this will frequently NULL out the entire partsBase.
---*/

PRIVATE VOID
BlendScheme(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    if(partsUrl->pszScheme)
    {
        LPCWSTR pszScheme = partsOut->pszScheme = partsUrl->pszScheme;
        URL_SCHEME eScheme = partsOut->eScheme = partsUrl->eScheme;

        partsOut->dwFlags |= (partsUrl->dwFlags & UPF_SCHEME_MASK);

        //
        //  this checks to make sure that these are the same scheme, and
        //  that the scheme is allowed to be used in relative URLs
        //  file: is not allowed to because of weirdness with drive letters
        //  and \\UNC\shares
        //
        if ((eScheme && (eScheme != partsBase->eScheme) || eScheme == URL_SCHEME_FILE) ||
            (!partsBase->pszScheme) ||
            (partsBase->pszScheme && StrCmpW(pszScheme, partsBase->pszScheme)))
        {
            //  they are different schemes.  DUMP partsBase.

            ZeroMemory(partsBase, SIZEOF(URLPARTS));
        }
    }
    else
    {
        partsOut->pszScheme = partsBase->pszScheme;
        partsOut->eScheme = partsBase->eScheme;
        partsOut->dwFlags |= (partsBase->dwFlags & UPF_SCHEME_MASK);
    }
}

PRIVATE VOID
BlendServer(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    ASSERT(partsUrl && partsBase && partsOut);

    //
    //  if we have different hosts then everything but the pszAccess is DUMPED
    //
    if(partsUrl->pszServer)
    {
        partsOut->pszServer = partsUrl->pszServer;
        // NOTUSED partsOut->dwFlags |= (partsUrl->dwFlags & UPF_SERVER_MASK);

        if ((partsBase->pszServer && StrCmpW(partsUrl->pszServer, partsBase->pszServer)))
        {
            //  they are different Servers.  DUMP partsBase.

            ZeroMemory(partsBase, SIZEOF(URLPARTS));
        }
    }
    else
    {
        partsOut->pszServer = partsBase->pszServer;
        // NOTUSED partsOut->dwFlags |= (partsBase->dwFlags & UPF_SERVER_MASK);
    }
}

PRIVATE VOID
BlendPath(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    ASSERT(partsUrl && partsBase && partsOut);

    if (partsUrl->dwFlags & UPF_SEG_ABSOLUTE)
    {
        if((partsBase->dwFlags & UPF_SEG_LOCKFIRST) &&
            !(partsUrl->dwFlags & UPF_SEG_LOCKFIRST))
        {
            // this keeps the drive letters when necessary
            partsOut->pszSegments = partsBase->pszSegments;
            partsOut->cSegments = 1;  // only keep the first segment
            partsOut->dwFlags |= (partsBase->dwFlags & UPF_SEG_MASK) ;

            partsOut->pszExtraSegs = partsUrl->pszSegments;
            partsOut->cExtraSegs = partsUrl->cSegments;
            partsOut->dwFlags |= (partsUrl->dwFlags & UPF_EXSEG_MASK);
        }
        else
        {


            //  just use the absolute path

            partsOut->pszSegments = partsUrl->pszSegments;
            partsOut->cSegments = partsUrl->cSegments;
            partsOut->dwFlags |= (partsUrl->dwFlags & (UPF_SEG_MASK |UPF_EXSEG_MASK) );
        }

        ZeroMemory(partsBase, SIZEOF(URLPARTS));

    }
    else if ((partsBase->dwFlags & UPF_SEG_ABSOLUTE))
    {
        //  Adopt path not name
        partsOut->pszSegments = partsBase->pszSegments;
        partsOut->cSegments = partsBase->cSegments;
        partsOut->dwFlags |= (partsBase->dwFlags & UPF_SEG_MASK );

        if(partsUrl->cSegments || partsUrl->dwFlags & UPF_SEG_EMPTYSEG)
        {
            //
            // this a relative path that needs to be combined
            //

            partsOut->pszExtraSegs = partsUrl->pszSegments;
            partsOut->cExtraSegs = partsUrl->cSegments;
            partsOut->dwFlags |= (partsUrl->dwFlags & UPF_EXSEG_MASK );

            if (!(partsBase->dwFlags & UPF_EXSEG_DIRECTORY))
            {
                //
                //  knock off the file name segment
                //  as long as the it isnt the first or the first is not locked
                //  or it isnt a dotdot.  in the case of http://site/dir/, dir/ is
                //  not actually killed, only the NULL terminator following it is.
                //
                LPWSTR pszLast = LastLiveSegment(partsOut->pszSegments, partsOut->cSegments, partsOut->dwFlags & UPF_SEG_LOCKFIRST);

                if(pszLast && !IsDotDot(pszLast))
                {
                    if(partsUrl->dwFlags & UPF_SEG_EMPTYSEG)
                        partsOut->dwFlags |= UPF_EXSEG_DIRECTORY;

                    KILLSEG(pszLast);
                }
            }
        }
        else
            partsOut->dwFlags |= (partsBase->dwFlags & UPF_EXSEG_MASK);
    }
    else if (partsUrl->cSegments)
    {
        partsOut->pszSegments = partsUrl->pszSegments;
        partsOut->cSegments = partsUrl->cSegments;
        partsOut->dwFlags |= (partsUrl->dwFlags & (UPF_SEG_MASK |UPF_EXSEG_MASK) );
    }
    else if (partsBase->cSegments)
    {
        partsOut->pszSegments = partsBase->pszSegments;
        partsOut->cSegments = partsBase->cSegments;
        partsOut->dwFlags |= (partsBase->dwFlags & (UPF_SEG_MASK |UPF_EXSEG_MASK) );

    }

    //  regardless, we want to zero if we have relative segs
    if (partsUrl->cSegments)
        ZeroMemory(partsBase, SIZEOF(URLPARTS));

}

PRIVATE VOID
BlendQuery(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    if(partsUrl->pszQuery)
    {
        LPCWSTR pszQuery = partsOut->pszQuery = partsUrl->pszQuery;

        // NOTUSED partsOut->dwFlags |= (partsUrl->dwFlags & UPF_Query_MASK);

        if ((partsBase->pszQuery && StrCmpW(pszQuery, partsBase->pszQuery)))
        {
            //  they are different Querys.  DUMP partsBase.

            ZeroMemory(partsBase, SIZEOF(URLPARTS));
        }
    }
    else
    {
        partsOut->pszQuery = partsBase->pszQuery;
        // NOTUSED partsOut->dwFlags |= (partsBase->dwFlags & UPF_Query_MASK);
    }
}

PRIVATE VOID
BlendFragment(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    if(partsUrl->pszFragment || partsUrl->cSegments)
    {
        LPCWSTR pszFragment = partsOut->pszFragment = partsUrl->pszFragment;

        // NOTUSED partsOut->dwFlags |= (partsUrl->dwFlags & UPF_Fragment_MASK);

        if ((partsBase->pszFragment && StrCmpW(pszFragment, partsBase->pszFragment)))
        {
            //  they are different Fragments.  DUMP partsBase.

            ZeroMemory(partsBase, SIZEOF(URLPARTS));
        }
    }
    else
    {
        partsOut->pszFragment = partsBase->pszFragment;
        // NOTUSED partsOut->dwFlags |= (partsBase->dwFlags & UPF_Fragment_MASK);
    }
}

PRIVATE VOID
BlendParts(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    //
    //  partsUrl always takes priority over partsBase
    //

    ASSERT(partsUrl && partsBase && partsOut);

    ZeroMemory(partsOut, SIZEOF(URLPARTS));

    BlendScheme( partsUrl,  partsBase,  partsOut);
    BlendServer( partsUrl,  partsBase,  partsOut);
    BlendPath( partsUrl,  partsBase,  partsOut);
    BlendQuery( partsUrl,  partsBase,  partsOut);
    BlendFragment( partsUrl,  partsBase,  partsOut);

}

PRIVATE VOID
CanonServer(PURLPARTS parts)
{
    //
    //  we only do stuff if this server is an internet style
    //  server.  that way it uses FQDNs and IP port numbers
    //
    if (parts->pszServer && (parts->dwFlags & UPF_SCHEME_INTERNET))
    {

        LPWSTR pszName = StrRChrW(parts->pszServer, NULL, L'@');

        if(!pszName)
            pszName = parts->pszServer;

        //  this should just point to the FQDN:Port
        CharLowerW(pszName);

        //
        //  Ignore default port numbers, and trailing dots on FQDNs
        //  which will only cause identical adresses to look different
        //
        {
            WCHAR *pch = StrChrW(pszName, COLON);

            if (pch && parts->eScheme)
            {
                BOOL fIgnorePort = FALSE;

                //
                //  FEATURE we should actually be getting this from
                //  the services file to find out the default protocol port
                //  but we dont think that most people will change them - zekel 17-Dec-96
                //
                switch(parts->eScheme)
                {
                case URL_SCHEME_HTTP:
                        if(StrCmpW(pch, L":80") == 0)
                            fIgnorePort = TRUE;
                        break;

                case URL_SCHEME_FTP:
                        if(StrCmpW(pch, L":21") == 0)
                            fIgnorePort = TRUE;
                        break;

                case URL_SCHEME_GOPHER:
                        if(StrCmpW(pch, L":70") == 0)
                            fIgnorePort = TRUE;
                        break;

                case URL_SCHEME_HTTPS:
                        if(StrCmpW(pch, L":443") == 0)
                            fIgnorePort = TRUE;
                        break;

                default:
                    break;
                }
                if(fIgnorePort)
                    TERMSTR(pch);  // It is the default: ignore it
            }

        }
    }
}


PRIVATE VOID
CanonCombineSegs(PURLPARTS parts)
{
    ASSERT(parts);
    ASSERT(parts->pszExtraSegs && parts->cExtraSegs);

    LPWSTR pszLast = LastLiveSegment(parts->pszSegments, parts->cSegments, parts->dwFlags & UPF_SEG_LOCKFIRST);

    LPWSTR pszExtra = parts->pszExtraSegs;
    DWORD iExtra = 0;
    DWORD cExtras = parts->cExtraSegs;

    if(!IsLiveSegment(pszExtra))
        pszExtra = NextLiveSegment(pszExtra, &iExtra, cExtras);

    while(pszExtra && IsDotDot(pszExtra))
    {
        if (pszLast)
            KILLSEG(pszLast);

        KILLSEG(pszExtra);

        pszLast = LastLiveSegment(parts->pszSegments, parts->cSegments, parts->dwFlags & UPF_SEG_LOCKFIRST);
        pszExtra = NextLiveSegment(pszExtra, &iExtra, cExtras);
    }
}

PRIVATE VOID
CanonSegments(LPWSTR pszSeg,
              DWORD cSegs,
              BOOL fLockFirst)

{
    DWORD  iSeg = 0;
    LPWSTR pszLastSeg = NULL;
    LPWSTR pszFirstSeg = pszSeg;
    BOOL fLastIsFirst = TRUE;
    BOOL fFirstSeg = TRUE;

    ASSERT (pszSeg && cSegs);

    pszSeg = FirstLiveSegment(pszSeg, &iSeg, cSegs);

    while (pszSeg)
    {
        if(IsDot(pszSeg))
        {
            //  if it is just a "." we can discard the segment
            KILLSEG(pszSeg);
        }

        else if(IsDotDot(pszSeg))
        {
            //  if it is ".." then we discard it and the last seg

            //
            //  if we are at the first (root) or
            //  the last is the root and it is locked
            //  then we dont want to do anything
            //
            if(pszLastSeg && !IsDotDot(pszLastSeg) && !(fLastIsFirst && fLockFirst))
            {
                KILLSEG(pszLastSeg);
                pszLastSeg = NULL;
                KILLSEG(pszSeg);
            }
        }

        if(IsLiveSegment(pszSeg))
        {
            if(!pszLastSeg && fFirstSeg)
                fLastIsFirst = TRUE;
            else
                fLastIsFirst = FALSE;

            pszLastSeg = pszSeg;
            fFirstSeg = FALSE;
        }
        else
        {
            pszLastSeg = LastLiveSegment(pszFirstSeg, iSeg, fLockFirst);
        }

        pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);

    }
}

PRIVATE VOID
CanonPath(PURLPARTS parts)
{

    ASSERT(parts);

    if(parts->cSegments)
        CanonSegments(parts->pszSegments, parts->cSegments, (parts->dwFlags & UPF_SEG_LOCKFIRST));

    if(parts->cExtraSegs)
        CanonSegments(parts->pszExtraSegs, parts->cExtraSegs, FALSE);

    if(parts->cExtraSegs)
        CanonCombineSegs(parts);
}


PRIVATE VOID
CanonParts(PURLPARTS parts)
{
    ASSERT(parts);

    //CanonScheme(parts);
    CanonServer(parts);
    CanonPath(parts);
    //CanonQuery(parts);
    //CanonFragment(parts);
}

PRIVATE HRESULT
BuildScheme(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(parts && pstr);

    if(parts->pszScheme)
    {
        hr = pstr->Append(parts->pszScheme);
        if(SUCCEEDED(hr))
            hr = pstr->Append(COLON);
    }

    return hr;

}

PRIVATE HRESULT
BuildServer(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(parts && pstr);

    switch(parts->eScheme)
    {
    case URL_SCHEME_MK:
    // CraigC's "mk:" has no // but acts like it does
        break;

    case URL_SCHEME_FILE:
        if ((dwFlags & URL_WININET_COMPATIBILITY) || (dwFlags & URL_FILE_USE_PATHURL))
        {
            if(parts->pszServer && *parts->pszServer)
                hr = pstr->Append(L"////");
            else if (parts->pszSegments && IsDrive(parts->pszSegments))
                hr = pstr->Append(SLASH);
            else if (parts->dwFlags & UPF_SEG_ABSOLUTE)
                hr = pstr->Append(L"//");
        }
        else if (parts->dwFlags & UPF_SEG_ABSOLUTE)
            hr = pstr->Append(L"//");
        break;

    default:
        if(parts->pszServer && SUCCEEDED(hr))
            hr = pstr->Append(L"//");
        break;
    }

    if(parts->pszServer && SUCCEEDED(hr))
            hr = pstr->Append(parts->pszServer);

    return hr;
}

PRIVATE HRESULT
BuildSegments(LPWSTR pszSeg, DWORD cSegs, PSHSTRW pstr, BOOL fRoot, BOOL *pfSlashLast)
{
    DWORD iSeg = 0;
    HRESULT hr = S_FALSE;

    *pfSlashLast = FALSE;

    ASSERT(pszSeg && pstr);

    pszSeg = FirstLiveSegment(pszSeg, &iSeg, cSegs);

    if(!fRoot && pszSeg)
    {
        hr = pstr->Append(pszSeg);

        if(SUCCEEDED(hr))
            pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);
        else
            pszSeg = NULL;
    }

    while (pszSeg)
    {
        hr = pstr->Append(SLASH);
        if(SUCCEEDED(hr) && *pszSeg)
        {
            hr = pstr->Append(pszSeg);
            *pfSlashLast = FALSE;
        }
        else
            *pfSlashLast = TRUE;

        if(SUCCEEDED(hr))
            pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);
        else
            break;
    }

    return hr;

}


PRIVATE HRESULT
BuildPath(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;
    BOOL fSlashLast = FALSE;
    DWORD iSeg;
    LPWSTR pszSegFirst = NULL;

    ASSERT(parts && pstr);

    if(parts->cSegments)
    {
        hr = BuildSegments(parts->pszSegments, parts->cSegments, pstr, parts->dwFlags & UPF_SEG_ABSOLUTE, &fSlashLast);

        if (fSlashLast)
            pstr->Append(SLASH);


    }

    if(SUCCEEDED(hr) && parts->cExtraSegs)
    {
        BOOL f = fSlashLast;

        hr = BuildSegments(parts->pszExtraSegs, parts->cExtraSegs, pstr, !fSlashLast, &fSlashLast);

        if (fSlashLast)
            pstr->Append(SLASH);

        if (hr == S_FALSE)
            fSlashLast = f;

    }

    //  trailing slash on a server name for IIS
    if( !fSlashLast &&
        (
          (parts->dwFlags & UPF_EXSEG_DIRECTORY) ||
          //  if this is just a server name by itself
          (!FirstLiveSegment(parts->pszSegments, &iSeg, parts->cSegments) &&
          !FirstLiveSegment(parts->pszExtraSegs, &iSeg, parts->cExtraSegs) &&
          parts->dwFlags & UPF_SEG_ABSOLUTE)
        )
      )
      {
        hr = pstr->Append(SLASH);
      }

    return hr;
}



PRIVATE HRESULT
BuildQuery(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(parts && pstr);

    if(parts->pszQuery)
    {
        hr = pstr->Append(QUERY);
        if(SUCCEEDED(hr))
            hr = pstr->Append(parts->pszQuery);
    }

    return hr;

}

PRIVATE HRESULT
BuildFragment(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(parts && pstr);

    if(parts->pszFragment)
    {
        hr = pstr->Append(POUND);
        if(SUCCEEDED(hr))
            hr = pstr->Append(parts->pszFragment);
    }

    return hr;

}

PRIVATE HRESULT
BuildUrl(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr;

    ASSERT(parts && pstr);

    if(
        (SUCCEEDED(hr = BuildScheme(parts, dwFlags, pstr)))      &&
        (SUCCEEDED(hr = BuildServer(parts, dwFlags, pstr)))      &&
        (SUCCEEDED(hr = BuildPath(parts, dwFlags, pstr)))        &&
        (SUCCEEDED(hr = BuildQuery(parts, dwFlags, pstr)))
        )
        hr = BuildFragment(parts, dwFlags, pstr);

    return hr;
}

/*+++

  SHUrlEscape()
    Escapes an URL
    right now, i am only escaping stuff in the Path part of the URL

  Parameters
  IN -
    pszUrl      URL to examine
    pstrOut     SHSTR destination
    dwFlags     the relevant URL_* flags,

  Returns
  HRESULT -
    SUCCESS     S_OK
    ERROR       only E_OUTOFMEMORY


  Helper Routines
    Escape*(part)           each part gets its own escape routine (ie EscapeScheme)
    EscapeSpaces            will only escape spaces (WININET compatibility mostly)
    EscapeSegmentsGetNeededSize     gets the required size of destination buffer for all path segments
    EscapeLiveSegment               does the work of escaping each path segment
---*/

PRIVATE HRESULT
EscapeSpaces(LPCWSTR psz, PSHSTRW pstr, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    LPCWSTR pch;
    DWORD cSpaces = 0;


    ASSERT(psz && pstr);


    pstr->Reset();

    for (pch = psz; *pch; pch++)
    {
        if (*pch == SPC)
            cSpaces++;
    }

    if(cSpaces)
    {
        hr = pstr->SetSize(lstrlenW(psz) + cSpaces * 2 + 1);
        if(SUCCEEDED(hr))
        {
            LPWSTR pchOut = pstr->GetInplaceStr();

            for (pch = psz; *pch; pch++)
            {
                if ((*pch == POUND || *pch == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
                {
                    StrCpyW(pchOut, pch);
                    pchOut += lstrlenW(pchOut);
                    break;
                }

                if (*pch == SPC)
                {
                    *pchOut++ = HEX_ESCAPE;
                    *pchOut++ = L'2';
                    *pchOut++ = L'0';
                }
                else
                {
                    *pchOut++ = *pch;
                }
            }

            TERMSTR(pchOut);
        }

    }
    else
        hr = pstr->SetStr(psz);

    return hr;
}


inline PRIVATE HRESULT
EscapeScheme(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    ASSERT(partsUrl && partsOut);

    partsOut->pszScheme = partsUrl->pszScheme;
    partsOut->eScheme = partsUrl->eScheme;

    return S_OK;
}

inline PRIVATE HRESULT
EscapeServer(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    ASSERT(partsUrl && partsOut);

    partsOut->pszServer = partsUrl->pszServer;

    return S_OK;
}

inline PRIVATE HRESULT
EscapeQuery(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    ASSERT(partsUrl && partsOut);

    partsOut->pszQuery = partsUrl->pszQuery;

    return S_OK;
}

inline PRIVATE HRESULT
EscapeFragment(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    ASSERT(partsUrl && partsOut);

    partsOut->pszFragment = partsUrl->pszFragment;

    return S_OK;
}

PRIVATE BOOL
GetEscapeStringSize(LPWSTR psz, DWORD dwFlags, LPDWORD pcch)

{
    BOOL fResize = FALSE;
    ASSERT(psz);
    ASSERT(pcch);


    for (*pcch = 0; *psz; psz++)
    {
        (*pcch)++;

        if(!IsSafePathChar(*psz) ||
            ((dwFlags & URL_ESCAPE_PERCENT) && (*psz == HEX_ESCAPE)))
        {
            fResize = TRUE;
            *pcch += 2;
        }

    }

    // for the NULL term
    (*pcch)++;

    return fResize;
}

PRIVATE DWORD
EscapeSegmentsGetNeededSize(LPWSTR pszSegments, DWORD cSegs, DWORD dwFlags)
{
    DWORD cchNeeded = 0;
    BOOL fResize = FALSE;
    LPWSTR pszSeg;
    DWORD iSeg;

    ASSERT(pszSegments && cSegs);

    pszSeg = FirstLiveSegment(pszSegments, &iSeg, cSegs);

    while (IsLiveSegment(pszSeg))
    {
        DWORD cch;

        if(GetEscapeStringSize(pszSeg, dwFlags, &cch))
            fResize = TRUE;
        cchNeeded += cch;

        pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);
    }

    return fResize ? cchNeeded : 0;
}

PRIVATE VOID
EscapeString(LPCWSTR pszSeg, DWORD dwFlags, LPWSTR *ppchOut)
{
    LPWSTR pchIn;   // This pointer has been trusted to not modify it's contents, just iterate.
    LPWSTR pchOut = *ppchOut;
    WCHAR ch;

    for (pchIn = (LPWSTR)pszSeg; *pchIn; pchIn++)
    {
        ch = *pchIn;

        if (!IsSafePathChar(ch) ||
            ((dwFlags & URL_ESCAPE_PERCENT) && (ch == HEX_ESCAPE)))
        {
            *pchOut++ = HEX_ESCAPE;
            *pchOut++ = hex[(ch >> 4) & 15];
            *pchOut++ = hex[ch & 15];

        }
        else
            *pchOut++ = *pchIn;
    }

    TERMSTR(pchOut);

    // move past the terminator
    pchOut++;

    *ppchOut = pchOut;

}

PRIVATE HRESULT
EscapeSegments(LPWSTR pszSegments, DWORD cSegs, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    DWORD cchNeeded;

    HRESULT hr = S_OK;

    ASSERT(pszSegments && cSegs && partsOut && pstr);

    cchNeeded = EscapeSegmentsGetNeededSize(pszSegments, cSegs, dwFlags);

    if(cchNeeded)
    {
        ASSERT(pstr);

        hr = pstr->SetSize(cchNeeded);

        if(SUCCEEDED(hr))
        {
            LPWSTR pchOut = pstr->GetInplaceStr();
            LPWSTR pszSeg;
            DWORD iSeg;

            partsOut->pszSegments = pchOut;
            partsOut->cSegments = 0;

            pszSeg = FirstLiveSegment(pszSegments, &iSeg, cSegs);

            while (IsLiveSegment(pszSeg))
            {
                EscapeString(pszSeg, dwFlags, &pchOut);
                partsOut->cSegments++;

                pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);
            }


        }

    }
    else
    {
        partsOut->cSegments = cSegs;
        partsOut->pszSegments = pszSegments;
    }


    return hr;
}

PRIVATE HRESULT
EscapePath(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(partsUrl && partsOut && pstr);

    if(partsUrl->cSegments)
    {
        hr = EscapeSegments(partsUrl->pszSegments, partsUrl->cSegments, dwFlags, partsOut, pstr);

    }
    else
    {
        partsOut->cSegments = 0;
        partsOut->pszSegments = NULL;
    }

    return hr;
}

HRESULT
SHUrlEscape (LPCWSTR pszUrl,
             PSHSTRW pstrOut,
             DWORD dwFlags)
{
#ifdef TESTING_SPACES_ONLY
    return EscapeSpaces(pszUrl, pstrOut, dwFlags);
#else //TESTING_SPACES_ONLY

    SHSTRW strUrl;
    HRESULT hr;

    ASSERT(pszUrl && pstrOut);
    if(!pszUrl || !pstrOut)
        return E_INVALIDARG;

    //
    //  EscapeSpaces is remarkably poor,
    //  but so is this kind of functionality...
    //  it doesnt do any kind of real parsing, it
    //  only looks for spaces and escapes them...
    //
    if(dwFlags & URL_ESCAPE_SPACES_ONLY)
        return EscapeSpaces(pszUrl, pstrOut, dwFlags);

    //  We are just passed a segment so we only want to
    //  escape that and nothing else.  Don't look for
    //  URL pieces.
    if(dwFlags & URL_ESCAPE_SEGMENT_ONLY)
    {
        URLPARTS partsOut;
        SHSTRW strTemp;

        EscapeSegments((LPWSTR)pszUrl, 1, dwFlags, &partsOut, &strTemp);
        pstrOut->SetStr(partsOut.pszSegments);
        return S_OK;
    }

    pstrOut->Reset();

    hr = strUrl.SetStr(pszUrl);

    if(SUCCEEDED(hr))
    {
        URLPARTS partsUrl, partsOut;
        SHSTRW strPath;

        BreakUrl(strUrl.GetInplaceStr(), &partsUrl);

        ZeroMemory(&partsOut, SIZEOF(URLPARTS));
        //
        //  NOTE the only function here that is really active right now is the EscapePath
        //  if some other part needs to be escaped, then add a new SHSTR in the 4th param
        //  and change the appropriate subroutine
        //

        if(
            (SUCCEEDED(hr = EscapeScheme(&partsUrl, dwFlags, &partsOut, NULL)))
            && (SUCCEEDED(hr = EscapeServer(&partsUrl, dwFlags, &partsOut, NULL)))
            && (SUCCEEDED(hr = EscapePath(&partsUrl, dwFlags, &partsOut, &strPath)))
            && (SUCCEEDED(hr = EscapeQuery(&partsUrl, dwFlags, &partsOut, NULL)))
            && (SUCCEEDED(hr = EscapeFragment(&partsUrl, dwFlags, &partsOut, NULL)))
           )
        {
            partsOut.dwFlags = partsUrl.dwFlags;

            hr = BuildUrl(&partsOut, dwFlags, pstrOut);
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
#endif //TESTING_SPACES_ONLY
}


/*+++

  SHUrlUnescape()
    Unescapes a string in place.  this is ok because
    it should never grow

  Parameters
  IN -
    psz         string to unescape inplace
    dwFlags     the relevant URL_* flags,

  Returns
  HRESULT -
    SUCCESS     S_OK
    ERROR       DOESNT error right now


  Helper Routines
    HexToWord               takes a hexdigit and returns WORD with the right number or -1
    IsEscapedChar           looks at a ptr for "%XX" where X is a hexdigit
    TranslateEscapedChar    translates "%XX" to an 8 bit char
---*/

PRIVATE WORD
HexToWord(WCHAR ch)
{
    if(ch >= TEXT('0') && ch <= TEXT('9'))
        return (WORD) ch - TEXT('0');
    if(ch >= TEXT('A') && ch <= TEXT('F'))
        return (WORD) ch - TEXT('A') + 10;
    if(ch >= TEXT('a') && ch <= TEXT('f'))
        return (WORD) ch - TEXT('a') + 10;

    ASSERT(FALSE);  //we have tried to use a non-hex number
    return (WORD) -1;
}

PRIVATE BOOL inline
IsEscapedOctetW(LPCWSTR pch)
{
    return (pch[0] == HEX_ESCAPE && IsHex(pch[1]) && IsHex(pch[2])) ? TRUE : FALSE;
}

PRIVATE BOOL inline
IsEscapedOctetA(LPCSTR pch)
{
    return (pch[0] == HEX_ESCAPE_A && IsHex((WCHAR)pch[1]) && IsHex((WCHAR)pch[2])) ? TRUE : FALSE;
}

PRIVATE WCHAR
TranslateEscapedOctetW(LPCWSTR pch)
{
    WCHAR ch;
    ASSERT(IsEscapedOctetW(pch));

    pch++;
    ch = (WCHAR) HexToWord(*pch++) * 16; // hi nibble
    ch += HexToWord(*pch); // lo nibble

    return ch;
}

PRIVATE CHAR
TranslateEscapedOctetA(LPCSTR pch)
{
    CHAR ch;
    ASSERT(IsEscapedOctetA(pch));

    pch++;
    ch = (CHAR) HexToWord(*pch++) * 16; // hi nibble
    ch += HexToWord(*pch); // lo nibble

    return ch;
}


HRESULT SHUrlUnescapeA(LPSTR psz, DWORD dwFlags)
{
    CHAR *pchSrc = psz;
    CHAR *pchDst = psz;

    while (*pchSrc)
    {
        if ((*pchSrc == POUND || *pchSrc == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
        {
            StrCpyA(pchDst, pchSrc);
            pchDst += lstrlenA(pchDst);
            break;
        }

        if (IsEscapedOctetA(pchSrc))
        {
            CHAR ch =  TranslateEscapedOctetA(pchSrc);

            *pchDst++ = ch;

            pchSrc += 3; // enuff for "%XX"
        }
        else
        {
            *pchDst++ = *pchSrc++;
        }
    }

    TERMSTR(pchDst);

    return S_OK;
}


HRESULT SHUrlUnescapeW(LPWSTR psz, DWORD dwFlags)
{
    WCHAR *pchSrc = psz;
    WCHAR *pchDst = psz;

    while (*pchSrc)
    {
        if ((*pchSrc == POUND || *pchSrc == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
        {
            StrCpyW(pchDst, pchSrc);
            pchDst += lstrlenW(pchDst);
            break;
        }

        if (IsEscapedOctetW(pchSrc))
        {
            WCHAR ch =  TranslateEscapedOctetW(pchSrc);
            
            *pchDst++ = ch;
            
            pchSrc += 3; // enuff for "%XX"
        }
        else
        {
            *pchDst++ = *pchSrc++;
        }
    }

    TERMSTR(pchDst);

    return S_OK;
}

PRIVATE HRESULT
BuildDosPath(PURLPARTS parts, PSHSTRW pstrOut, DWORD dwFlags)
{
    HRESULT hr;
    //  this will disable a preceding slash when there is a drive
    if(parts->pszSegments && IsDrive(parts->pszSegments))
        parts->dwFlags = (parts->dwFlags & ~UPF_SEG_ABSOLUTE);


    //  if there is a zero length server then
    //  we skip building it
    if(parts->pszServer && !*parts->pszServer)
        parts->pszServer = NULL;


    //  this prevents all the special file goo checking
    parts->eScheme = URL_SCHEME_UNKNOWN;

    //
    //  then go ahead and put the path together
    if( (SUCCEEDED(hr = BuildServer(parts, dwFlags, pstrOut))) &&
        (!parts->cSegments || SUCCEEDED(hr = BuildPath(parts, dwFlags, pstrOut)))
      )
    {
        //  then decode it cuz paths arent escaped
        if (IsFlagSet(dwFlags, URL_FILE_USE_PATHURL))
            WininetFixFileSlashes(pstrOut->GetInplaceStr());
        else
#ifndef UNIX
            ConvertChar(pstrOut->GetInplaceStr(), SLASH, WHACK, TRUE);
#else
            ConvertChar(pstrOut->GetInplaceStr(), WHACK, SLASH, TRUE);
#endif

        if(IsFlagClear(parts->dwFlags, UPF_FILEISPATHURL))
            SHUrlUnescapeW(pstrOut->GetInplaceStr(), dwFlags);

        if(IsDriveUrl(*pstrOut))
        {
            LPWSTR pszTemp = pstrOut->GetInplaceStr();

            pszTemp[1] = COLON;
        }
    }

    return hr;

}
HRESULT
SHPathCreateFromUrl(LPCWSTR pszUrl, PSHSTRW pstrOut, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strUrl;

    ASSERT(pszUrl && pstrOut);

    pstrOut->Reset();
    hr = strUrl.SetStr(pszUrl);

    if(SUCCEEDED(hr))
    {
        URLPARTS partsUrl;

        //  first we need to break it open
        BreakUrl(strUrl.GetInplaceStr(), &partsUrl);

        //  then we make sure it is a file:
        if(partsUrl.eScheme == URL_SCHEME_FILE)
        {
            hr = BuildDosPath(&partsUrl, pstrOut, dwFlags);
        }
        else
            hr = E_INVALIDARG;
    }
    return hr;
}


HRESULT
SHUrlCreateFromPath(LPCWSTR pszPath, PSHSTRW pstrOut, DWORD dwFlags)
{
        HRESULT hr;
        SHSTRW strPath;
        ASSERT(pszPath && pstrOut);

        if(PathIsURLW(pszPath))
        {
            if(SUCCEEDED(hr = pstrOut->SetStr(pszPath)))
                return S_FALSE;
            else
                return hr;
        }


        pstrOut->Reset();
        hr = strPath.SetStr(pszPath);

        TrimAndStripInsignificantWhite(strPath.GetInplaceStr());

        if(SUCCEEDED(hr))
        {
            URLPARTS partsIn, partsOut;
            SHSTRW strEscapedPath, strEscapedServer;
            LPWSTR pch = strPath.GetInplaceStr();

            ZeroMemory(&partsIn, SIZEOF(URLPARTS));

            partsIn.pszScheme = (LPWSTR)c_szFileScheme;
            partsIn.eScheme = URL_SCHEME_FILE;
            partsIn.dwFlags = UPF_SCHEME_CONVERT;

            //  first break the path
            BreakFragment(&pch, &partsIn);
            BreakServer(&pch, &partsIn, TRUE);
            BreakPath(&pch, &partsIn);

            partsOut = partsIn;

            //  then escape the path if we arent using path URLs
            if (IsFlagClear(dwFlags, URL_FILE_USE_PATHURL))
            {
                hr = EscapePath(&partsIn, dwFlags | URL_ESCAPE_PERCENT, &partsOut, &strEscapedPath);

                if(SUCCEEDED(hr) && partsOut.pszServer)
                {
                    //
                    //  i am treating the pszServer exactly like a path segment
                    //

                    DWORD cchNeeded;

                    if(GetEscapeStringSize(partsOut.pszServer, dwFlags | URL_ESCAPE_PERCENT, &cchNeeded) &&
                        SUCCEEDED(hr = strEscapedServer.SetSize(cchNeeded)))
                    {
                        pch = strEscapedServer.GetInplaceStr();

                        EscapeString(partsOut.pszServer, dwFlags | URL_ESCAPE_PERCENT, &pch);
                        partsOut.pszServer = strEscapedServer.GetInplaceStr();
                    }
                }
            }

            if(!partsOut.pszServer && IsFlagSet(partsOut.dwFlags, UPF_SEG_ABSOLUTE))
                partsOut.pszServer = L"";

            //  then build the URL
            if(SUCCEEDED(hr))
            {
                if(URL_SCHEME_FILE == partsOut.eScheme && IsFlagSet(dwFlags, URL_FILE_USE_PATHURL))
                {
                    if (SUCCEEDED(hr = pstrOut->SetStr(c_szFileSchemeString)))
                        hr = BuildDosPath(&partsOut, pstrOut, dwFlags);
                }
                else
                    hr = BuildUrl(&partsOut, dwFlags, pstrOut);
            }

            if (SUCCEEDED(hr) && (IsFlagSet(dwFlags, URL_WININET_COMPATIBILITY)))
                WininetFixFileSlashes(pstrOut->GetInplaceStr());
        }

        return hr;
}


/*+++

  SHUrlParse()
    Canonicalize an URL
    or Combine and Canonicalize two URLs

  Parameters
  IN -
    pszBase     the base or referring URL, may be NULL
    pszUrl      the relative URL
    dwFlags     the relevant URL_* flags,

  Returns
  HRESULT -
    SUCCESS     S_OK
    ERROR       appropriate error, usually just E_OUTOFMEMORY;

  NOTE:  pszUrl will always take precedence over pszBase.

---*/
HRESULT SHUrlParse(LPCWSTR pszBase, LPCWSTR pszUrl, PSHSTRW pstrOut, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    URLPARTS partsUrl, partsOut, partsBase;

    SHSTRW strBase;
    SHSTRW strUrl;
    ASSERT(pszUrl);
    ASSERT(pstrOut);

    TraceMsgW(TF_URL | TF_FUNC, "entering SHUrlParse(%s, %s, 0x%X", pszBase,pszUrl ? pszUrl : L"NULL", dwFlags);

    pstrOut->Reset();

    //
    // Don't bother parsing if all we have in an inter-page link as the
    // pszUrl and no pszBase to parse
    //

    if (pszUrl[0] == POUND && (!pszBase || !*pszBase))
    {
        hr = pstrOut->SetStr(pszUrl);

        goto quit;
    }


    //
    //  for Perf reasons we want to parse the relative url first.
    //  if it is an absolute URL, we need never look at the base.
    //

    hr = CopyUrlForParse(pszUrl, &strUrl, dwFlags);

    if(FAILED(hr))
        goto quit;

    // -- Cybersitter compat ----
    // Some bug fix broke the original parser. No time to go back and
    // fix it, but since we know what to expect, we'll return this straight instead.
    // Basically, when we canonicalize ://, we produce :///
    if (!StrCmpW(strUrl, L"://"))
    {
        hr = pstrOut->SetStr(L":///");
        goto quit;
    }

    //
    //  BreakUrls will decide if it is necessary to look at the relative
    //
    hr = BreakUrls(strUrl.GetInplaceStr(), &partsUrl, pszBase, &strBase, &partsBase, dwFlags);

    if(FAILED(hr))
        goto quit;

    if(S_OK == hr)    {
        //
        //  this is where the real combination logic happens
        //  this first parts is the one that takes precedence
        //
        BlendParts(&partsUrl, &partsBase, &partsOut);
    }
    else
        partsOut = partsUrl;


    //
    //  we will now do the work of putting it together
    //  if these fail, it is because we are out of memory.
    //

    if (!(dwFlags & URL_DONT_SIMPLIFY))
        CanonParts(&partsOut);

    if(URL_SCHEME_FILE == partsOut.eScheme && IsFlagSet(dwFlags, URL_FILE_USE_PATHURL))
    {
        if (SUCCEEDED(hr = pstrOut->SetStr(c_szFileSchemeString)))
            hr = BuildDosPath(&partsOut, pstrOut, dwFlags);
    }
    else
        hr = BuildUrl(&partsOut, dwFlags, pstrOut);


    if(SUCCEEDED(hr))
    {
        if (dwFlags & URL_UNESCAPE)
            SHUrlUnescapeW(pstrOut->GetInplaceStr(), dwFlags);

        if (dwFlags & URL_ESCAPE_SPACES_ONLY || dwFlags & URL_ESCAPE_UNSAFE)
        {
            //
            //  we are going to reuse strUrl here
            //
            hr = strUrl.SetStr(*pstrOut);

            if(SUCCEEDED(hr))
                hr = SHUrlEscape(strUrl, pstrOut, dwFlags);
        }
    }

    if (SUCCEEDED(hr) &&
        (IsFlagSet(dwFlags, URL_WININET_COMPATIBILITY))  &&
        (partsOut.eScheme == URL_SCHEME_FILE))
        WininetFixFileSlashes(pstrOut->GetInplaceStr());


quit:


    if(FAILED(hr))
    {
        pstrOut->Reset();
        TraceMsg(TF_URL | TF_FUNC, TEXT("FAILED SHUrlParse() hr = 0x%X\n"), hr);
    }
    else
        TraceMsgW(TF_URL | TF_FUNC, "SUCCEEDED SHUrlParse() %s\n", (LPCWSTR)*pstrOut);


    return hr;

}

typedef struct _LOGON {
    LPWSTR pszUser;
    LPWSTR pszPass;
    LPWSTR pszHost;
    LPWSTR pszPort;
} LOGON, *PLOGON;

PRIVATE void
BreakLogon(LPWSTR psz, PLOGON plo)
{
    ASSERT(psz);
    ASSERT(plo);

    WCHAR *pch = StrChrW(psz, L'@');
    if(pch)
    {
        TERMSTR(pch);
        plo->pszHost = pch + 1;

        plo->pszUser = psz;
        pch = StrChrW(psz, COLON);
        if (pch)
        {
            TERMSTR(pch);
            plo->pszPass = pch + 1;
        }
    }
    else
        plo->pszHost = psz;

    pch = StrChrW(plo->pszHost, COLON);
    if (pch)
    {
        TERMSTR(pch);
        plo->pszPort = pch + 1;
    }
}

PRIVATE HRESULT
InternetGetPart(DWORD dwPart, PURLPARTS parts, PSHSTRW pstr, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    if(parts->pszServer)
    {
        LOGON lo = {0};

        BreakLogon(parts->pszServer, &lo);

        switch (dwPart)
        {
        case URL_PART_HOSTNAME:
            hr = pstr->Append(lo.pszHost);
            break;

        case URL_PART_USERNAME:
            hr = pstr->Append(lo.pszUser);
            break;

        case URL_PART_PASSWORD:
            hr = pstr->Append(lo.pszPass);
            break;

        case URL_PART_PORT:
            hr = pstr->Append(lo.pszPort);
            break;

        default:
            ASSERT(FALSE);
        }
    }
    return hr;
}

PRIVATE HRESULT
SHUrlGetPart(PSHSTRW pstrIn, PSHSTRW pstrOut, DWORD dwPart, DWORD dwFlags)
{
    ASSERT(pstrIn);
    ASSERT(pstrOut);
    ASSERT(dwPart);

    HRESULT hr = S_OK;

    URLPARTS parts;

    BreakUrl(pstrIn->GetInplaceStr(), &parts);

    if(dwFlags & URL_PARTFLAG_KEEPSCHEME)
    {
        hr = pstrOut->SetStr(parts.pszScheme);
        if(SUCCEEDED(hr))
            hr = pstrOut->Append(COLON);
    }
    else
        pstrOut->Reset();

    if(SUCCEEDED(hr))
    {
        switch (dwPart)
        {
        case URL_PART_SCHEME:
            hr = pstrOut->SetStr(parts.pszScheme);
            break;

        case URL_PART_HOSTNAME:
            if (parts.eScheme == URL_SCHEME_FILE)
            {
                hr = pstrOut->SetStr(parts.pszServer);
                break;
            }
            // else fall through
        case URL_PART_USERNAME:
        case URL_PART_PASSWORD:
        case URL_PART_PORT:
            if(parts.dwFlags & UPF_SCHEME_INTERNET)
            {
                hr = InternetGetPart(dwPart, &parts, pstrOut, dwFlags);
            }
            else
                hr = E_FAIL;
            break;

        case URL_PART_QUERY:
            hr = pstrOut->SetStr(parts.pszQuery);
            break;

        default:
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

#define c_szURLPrefixesKey "Software\\Microsoft\\Windows\\CurrentVersion\\URL\\Prefixes"
const WCHAR c_szDefaultURLPrefixKey[]   = L"Software\\Microsoft\\Windows\\CurrentVersion\\URL\\DefaultPrefix";

PRIVATE inline LPCWSTR SkipLeadingSlashes(LPCWSTR psz)
{
    // Skip two leading slashes.

    if (psz[0] == SLASH && psz[1] == SLASH)
        psz += 2;

    return psz;
}

PRIVATE HRESULT
UrlGuessScheme(LPCWSTR pszUrl, PSHSTRW pstr)
{
    HRESULT hr = S_FALSE;

    ASSERT(pszUrl && pstr);

    HKEY hkeyPrefixes;

    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, c_szURLPrefixesKey, 0, KEY_QUERY_VALUE, &hkeyPrefixes)
        == ERROR_SUCCESS)
    {
        DWORD dwiValue;
        CHAR rgchValueName[MAX_PATH];
        DWORD cchValueName = SIZECHARS(rgchValueName);
        DWORD dwType;
        CHAR rgchPrefix[MAX_PATH];
        DWORD cbPrefix = SIZEOF(rgchPrefix);

        //  need to get past the initial two slashes if applicable
        pszUrl = SkipLeadingSlashes(pszUrl);

        for (dwiValue = 0;
             RegEnumValueA(hkeyPrefixes, dwiValue, rgchValueName,
                          &cchValueName, NULL, &dwType, (PBYTE)rgchPrefix,
                          &cbPrefix) == ERROR_SUCCESS;
             dwiValue++)
        {
            WCHAR wszValue[MAX_PATH];

            MultiByteToWideChar(CP_ACP, 0, rgchValueName, -1, wszValue, ARRAYSIZE(wszValue));

            //  we check to make sure that we match and there is something more
            if (!StrCmpNIW(pszUrl, wszValue, cchValueName) && pszUrl[cchValueName])
            {
                MultiByteToWideChar(CP_ACP, 0, rgchPrefix, -1, wszValue, ARRAYSIZE(wszValue));
                if(SUCCEEDED(hr = pstr->SetStr(wszValue)))
                    hr = pstr->Append(pszUrl);
                break;
            }

            cchValueName = SIZECHARS(rgchValueName);
            cbPrefix = SIZEOF(rgchPrefix);
        }

        RegCloseKey(hkeyPrefixes);
    }

    return(hr);
}

/*----------------------------------------------------------
Purpose: Grabs the default URL prefix in the registry and applies
         it to the given URL.

Returns: S_OK
         S_FALSE if there is no default prefix

*/
const WCHAR c_szDefaultScheme[] = L"http://";

HRESULT
UrlApplyDefaultScheme(
    LPCWSTR pszUrl,
    PSHSTRW pstr)
{
    HRESULT hr = S_FALSE;
    WCHAR szDef[MAX_PATH];
    DWORD cbSize = SIZEOF(szDef);

    ASSERT(pszUrl && pstr);
    ASSERT(!PathIsURLW(pszUrl));

    DWORD dwType;
    if (NO_ERROR == SHRegGetUSValueW(c_szDefaultURLPrefixKey, NULL, &dwType, (LPVOID)szDef, &cbSize, TRUE, (LPVOID)c_szDefaultScheme, SIZEOF(c_szDefaultScheme)))
    {
        pszUrl = SkipLeadingSlashes(pszUrl);

        if(SUCCEEDED(hr = pstr->SetStr(szDef)))
            hr = pstr->Append(pszUrl);
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: Guesses a URL protocol based upon a list in the registry,
         compared to the first few characters of the given
         URL suffix.

Returns: S_OK if a URL protocol is determined
         S_FALSE if there were no problems but no prefix was prepended

*/
HRESULT
SHUrlApplyScheme(
    LPCWSTR pszUrl,
    PSHSTRW pstrOut,
    DWORD dwFlags)
{
    HRESULT hr = S_FALSE;

    ASSERT(IS_VALID_STRING_PTRW(pszUrl, -1));

    //
    // if there is already scheme there, we do nothing
    //  unless the caller insists.  this is to support
    //  a string that looks like www.foo.com:8001.
    //  this is a site that needs to be guessed at but
    //  it also could be a valid scheme since '.' and '-'
    //  are both valid scheme chars.
    //
    DWORD cch;
    if((dwFlags & URL_APPLY_FORCEAPPLY) || !FindSchemeW(pszUrl, &cch))
    {
        if(dwFlags & URL_APPLY_GUESSSCHEME)
            hr = UrlGuessScheme(pszUrl, pstrOut);

        if (hr != S_OK && (dwFlags & URL_APPLY_GUESSFILE))
        {
            LPCWSTR psz = FindDosPath(pszUrl);

            //  only change hr if we actually converted.
            if(psz && SUCCEEDED(SHUrlCreateFromPath(psz, pstrOut, 0)))
                hr = S_OK;
        }

        if (hr != S_OK && (dwFlags & URL_APPLY_DEFAULT || !dwFlags))
            hr = UrlApplyDefaultScheme(pszUrl, pstrOut);
    }

    return hr;
}



PRIVATE HRESULT
CopyOutA(PSHSTRA pstr, LPSTR psz, LPDWORD pcch)
{
    HRESULT hr = S_OK;
    DWORD cch;
    ASSERT(pstr);
    ASSERT(psz);
    ASSERT(pcch);

    cch = pstr->GetLen();
    if((*pcch > cch) && psz)
        lstrcpyA(psz, pstr->GetStr());
    else
        hr = E_POINTER;

    *pcch = cch + (FAILED(hr) ? 1 : 0);

    return hr;
}

//***   StrCopyOutW --
// NOTES
//  WARNING: must match semantics of CopyOutW! (esp. the *pcchOut part)
PRIVATE HRESULT
StrCopyOutW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut)
{
    DWORD cch;

    cch = lstrlenW(pszIn);
    if (cch < *pcchOut && pszOut) {
        *pcchOut = cch;
        StrCpyW(pszOut, pszIn);
        return S_OK;
    }
    else {
        *pcchOut = cch + 1;
        return E_POINTER;
    }
}

//***
// NOTES
//  WARNING: StrCopyOutW must match this func, so if you change this change
// it too
PRIVATE HRESULT
CopyOutW(PSHSTRW pstr, LPWSTR psz, LPDWORD pcch)
{
    HRESULT hr = S_OK;
    DWORD cch;
    ASSERT(pstr);
    ASSERT(psz);
    ASSERT(pcch);

    cch = pstr->GetLen();
    if((*pcch > cch) && psz)
        StrCpyW(psz, pstr->GetStr());
    else
        hr = E_POINTER;

    *pcch = cch + (FAILED(hr) ? 1 : 0);

    return hr;
}


LWSTDAPI
UrlCanonicalizeA(LPCSTR pszIn,
                LPSTR pszOut,
                LPDWORD pcchOut,
                DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlCanonicalizeA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlCanonicalizeA: Caller passed invalid pcchOut");
    RIPMSG(NULL==pcchOut || (pszOut && IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlCanonicalizeA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut == pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn
        || !pszOut
        || !pcchOut
        || !*pcchOut)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineA("", pszIn, pszOut, pcchOut, dwFlags);
    }
    return hr;

}


LWSTDAPI
UrlEscapeA(LPCSTR pszIn,
           LPSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlEscapeA: Caller passed invalid pszin");
    RIPMSG(NULL!=pcchOut, "UrlEscapeA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlEscapeA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszOut)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut)
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strUrl;

        if(SUCCEEDED(strUrl.SetStr(pszIn)))
            hr = SHUrlEscape(strUrl, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
            hr = ReconcileHresults(hr, straOut.SetStr(strwOut));
    }

    if(SUCCEEDED(hr))
        hr = ReconcileHresults(hr, CopyOutA(&straOut, pszOut, pcchOut));

    return hr;
}

LWSTDAPI
UrlGetPartA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlGetPartA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlGetPartA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlGetPartA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut || dwPart == URL_PART_NONE)
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwIn;

        if(SUCCEEDED(strwIn.SetStr(pszIn)))
            hr = SHUrlGetPart(&strwIn, &strwOut, dwPart, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
            hr = ReconcileHresults(hr, straOut.SetStr(strwOut));
    }

    if(SUCCEEDED(hr))
        hr = ReconcileHresults(hr, CopyOutA(&straOut, pszOut, pcchOut));

    return hr;

}

LWSTDAPI_(BOOL) UrlIsA(LPCSTR pszURL, URLIS UrlIs)
{
    BOOL fRet = FALSE;

    RIPMSG(pszURL && IS_VALID_STRING_PTRA(pszURL, -1), "UrlIsA: Caller passed invalid pszURL");
    if(pszURL)
    {
        DWORD cchScheme, dwFlags;
        LPCSTR pszScheme = FindSchemeA(pszURL, &cchScheme);

        if(pszScheme)
        {
            URL_SCHEME eScheme = GetSchemeTypeAndFlagsA(pszScheme, cchScheme, &dwFlags);

            switch (UrlIs)
            {
            case URLIS_URL:
                fRet = TRUE;
                break;

            case URLIS_OPAQUE:
                fRet = (dwFlags & UPF_SCHEME_OPAQUE);
                break;

            case URLIS_NOHISTORY:
                fRet = (dwFlags & UPF_SCHEME_NOHISTORY);
                break;

            case URLIS_FILEURL:
                fRet = (eScheme == URL_SCHEME_FILE);
                break;

            default:
                //  if it cant be done quck and dirty
                //  then we need to thunk to the wide version
                SHSTRW strUrl;
                if (SUCCEEDED(strUrl.SetStr(pszURL)))
                {
                    fRet = UrlIsW(strUrl, UrlIs);
                }
            }
        }
    }
    return fRet;
}

LWSTDAPI_(BOOL) UrlIsW(LPCWSTR pszURL, URLIS UrlIs)
{
    BOOL fRet = FALSE;

    RIPMSG(NULL!=pszURL && IS_VALID_STRING_PTRW(pszURL, -1), "UrlIsW: Caller passed invalid pszURL");
    if(pszURL)
    {
        DWORD cchScheme, dwFlags;
        LPCWSTR pszScheme = FindSchemeW(pszURL, &cchScheme);

        if(pszScheme)
        {
            SHSTRW str;
            URL_SCHEME eScheme = GetSchemeTypeAndFlagsW(pszScheme, cchScheme, &dwFlags);

            switch (UrlIs)
            {
            case URLIS_URL:
                fRet = TRUE;
                break;

            case URLIS_OPAQUE:
                fRet = (dwFlags & UPF_SCHEME_OPAQUE);
                break;

            case URLIS_NOHISTORY:
                fRet = (dwFlags & UPF_SCHEME_NOHISTORY);
                break;

            case URLIS_FILEURL:
                fRet = (eScheme == URL_SCHEME_FILE);
                break;

            case URLIS_APPLIABLE:
                if (eScheme == URL_SCHEME_UNKNOWN)
                {
                    if (S_OK == UrlGuessScheme(pszURL, &str))
                        fRet = TRUE;
                }
                break;

            //  these cases need a broken URL
            case URLIS_DIRECTORY:
            case URLIS_HASQUERY:
                {
                    URLPARTS parts;

                    if (SUCCEEDED(str.SetStr(pszURL))
                    &&  SUCCEEDED(BreakUrl(str.GetInplaceStr(), &parts)))
                    {
                        switch(UrlIs)
                        {
                        case URLIS_DIRECTORY:
                            //  if the last seg has a trailing slash, or
                            //  if there are no path segments at all...
                            fRet = (!parts.cSegments || (parts.dwFlags & UPF_EXSEG_DIRECTORY));
                            break;

                        case URLIS_HASQUERY:
                            fRet = (parts.pszQuery && *parts.pszQuery);
                            break;

                        default:
                            ASSERT(FALSE);
                            break;
                        }
                    }
                }
                break;

            default:
                AssertMsg(FALSE, "UrlIs() called with invalid flag");

            }
        }
    }
    return fRet;
}


LWSTDAPI_(BOOL) UrlIsOpaqueA(LPCSTR pszURL)
{
    return UrlIsA(pszURL, URLIS_OPAQUE);
}

LWSTDAPI_(BOOL) UrlIsOpaqueW(LPCWSTR pszURL)
{
    return UrlIsW(pszURL, URLIS_OPAQUE);
}


LWSTDAPI_(BOOL) UrlIsNoHistoryA(LPCSTR pszURL)
{
    return UrlIsA(pszURL, URLIS_NOHISTORY);
}

LWSTDAPI_(BOOL) UrlIsNoHistoryW(LPCWSTR pszURL)
{
    return UrlIsW(pszURL, URLIS_NOHISTORY);
}

LWSTDAPI_(LPCSTR) UrlGetLocationA(LPCSTR pszURL)
{
    CPINFO cpinfo;
    BOOL fMBCS = (GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);

    RIPMSG(pszURL && IS_VALID_STRING_PTRA(pszURL, -1), "UrlGetLocationA: Caller passed invalid pszURL");
    if(pszURL)
    {
        DWORD cchScheme, dwFlags;
        LPCSTR pszScheme = FindSchemeA(pszURL, &cchScheme);
        if(pszScheme)
        {
            URL_SCHEME eScheme = GetSchemeTypeAndFlagsA(pszScheme, cchScheme, &dwFlags);

            return (dwFlags & UPF_SCHEME_OPAQUE) ? NULL : FindFragmentA(pszURL, fMBCS, (eScheme == URL_SCHEME_FILE));
        }
    }
    return NULL;
}

LWSTDAPI_(LPCWSTR) UrlGetLocationW(LPCWSTR wzURL)
{
    RIPMSG(wzURL && IS_VALID_STRING_PTRW(wzURL, -1), "UrlGetLocationW: Caller passed invalid wzURL");
    if(wzURL)
    {
        DWORD cchScheme, dwFlags;
        LPCWSTR pszScheme = FindSchemeW(wzURL, &cchScheme);
        if(pszScheme)
        {
            URL_SCHEME eScheme = GetSchemeTypeAndFlagsW(pszScheme, cchScheme, &dwFlags);

            return (dwFlags & UPF_SCHEME_OPAQUE) ? NULL : FindFragmentW(wzURL, (eScheme == URL_SCHEME_FILE));
        }
    }
    return NULL;
}


LWSTDAPI_(int) UrlCompareA(LPCSTR psz1, LPCSTR psz2, BOOL fIgnoreSlash)
{
    RIPMSG(psz1 && IS_VALID_STRING_PTRA(psz1, -1), "UrlCompareA: Caller passed invalid psz1");
    RIPMSG(psz2 && IS_VALID_STRING_PTRA(psz1, -1), "UrlCompareA: Caller passed invalid psz2");
    if (psz1 && psz2)
    {
        SHSTRW str1, str2;

        if(SUCCEEDED(str1.SetStr(psz1)) && SUCCEEDED(str2.SetStr(psz2)) &&
            SUCCEEDED(SHUrlUnescapeW(str1.GetInplaceStr(), 0)) && SUCCEEDED(SHUrlUnescapeW(str2.GetInplaceStr(), 0)) )
        {
            if(fIgnoreSlash)
            {
                LPWSTR pch;

                pch = str1.GetInplaceStr() + str1.GetLen() - 1;
                if(*pch == SLASH)
                    TERMSTR(pch);

                pch = str2.GetInplaceStr() + str2.GetLen() - 1;
                if(*pch == SLASH)
                    TERMSTR(pch);
            }

            return StrCmpW(str1, str2);
        }
    }

    return lstrcmpA(psz1, psz2);
}

LWSTDAPI
UrlUnescapeA(LPSTR pszUrl, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    RIPMSG(pszUrl && IS_VALID_STRING_PTRA(pszUrl, -1), "UrlUnescapeA: Caller passed invalid pszUrl");

    if(dwFlags & URL_UNESCAPE_INPLACE)
    {
        return SHUrlUnescapeA(pszUrl, dwFlags);
    }

    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlUnescapeA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlUnescapeA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszUrl)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszUrl
        || !pcchOut
        || !*pcchOut
        || !pszOut)
    {
        return E_INVALIDARG;
    }

    SHSTRA str;
    HRESULT hr = str.SetStr(pszUrl);
    if(SUCCEEDED(hr))
    {
        SHUrlUnescapeA(str.GetInplaceStr(), dwFlags);
        hr = CopyOutA(&str, pszOut, pcchOut);
    }
    return hr;
}




LWSTDAPI
PathCreateFromUrlA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "PathCreateFromUrlA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "PathCreateFromUrlA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "PathCreateFromUrlA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwIn;

        if(SUCCEEDED(strwIn.SetStr(pszIn)))
            hr = SHPathCreateFromUrl(strwIn, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
            hr = straOut.SetStr(strwOut);
    }

    if(SUCCEEDED(hr) )
        hr = CopyOutA(&straOut, pszOut, pcchOut);

    return hr;
}

LWSTDAPI
UrlCreateFromPathA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlCreateFromPathA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlCreateFromPathA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlCreateFromPathA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwIn;

        if(SUCCEEDED(strwIn.SetStr(pszIn)))
            hr = SHUrlCreateFromPath(strwIn, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
        {
            hr = ReconcileHresults(hr, straOut.SetStr(strwOut));
        }
    }

    if(SUCCEEDED(hr) )
        hr = ReconcileHresults(hr, CopyOutA(&straOut, pszOut, pcchOut));

    return hr;

}

LWSTDAPI
UrlApplySchemeA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlApplySchemeA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlApplySchemeA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlApplySchemeA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwIn;

        if(SUCCEEDED(strwIn.SetStr(pszIn)))
            hr = SHUrlApplyScheme(strwIn, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(S_OK == (hr))
            hr = straOut.SetStr(strwOut);
    }

    if(S_OK == (hr))
        hr = CopyOutA(&straOut, pszOut, pcchOut);

    return hr;

}

// PERF_CACHE
//***   g_szUCCanon -- 1-element cache for UrlCanonicalizeW
// DESCRIPTION
//  it turns out a large # of our calls a) are for the same thing,
// and b) have pszOut(canon)=pszIn(raw).  so cache the most recent guy.
LONG g_lockUC;
WCHAR g_szUCCanon[64];      // post-canon guy (also used for pre-canon check)
DWORD g_dwUCFlags;

#ifdef DEBUG
int g_cUCTot, g_cUCHit;
#endif

LWSTDAPI
UrlCanonicalizeW(LPCWSTR pszUrl,
           LPWSTR pszCanonicalized,
           LPDWORD pcchCanonicalized,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strwOut;

    RIPMSG(pszUrl && IS_VALID_STRING_PTRW(pszUrl, -1), "UrlCanonicalizeW: Caller passed invalid pszUrl");
    RIPMSG(NULL!=pcchCanonicalized && IS_VALID_WRITE_PTR(pcchCanonicalized, DWORD), "UrlCanonicalizeW: Caller passed invalid pcchCanonicalized");
    RIPMSG(NULL==pcchCanonicalized || (pszCanonicalized && IS_VALID_WRITE_BUFFER(pszCanonicalized, char, *pcchCanonicalized)), "UrlCanonicalizeW: Caller passed invalid pszCanonicalized");
#ifdef DEBUG
    if (pcchCanonicalized)
    {
        if (pszCanonicalized == pszUrl)
            DEBUGWhackPathStringW(pszCanonicalized, *pcchCanonicalized);
        else
            DEBUGWhackPathBufferW(pszCanonicalized, *pcchCanonicalized);
    }
#endif

    if (!pszUrl
        || !pszCanonicalized
        || !pcchCanonicalized
        || !*pcchCanonicalized)
    {
        hr = E_INVALIDARG;
    }
    else
    {
#ifdef DEBUG
        if ((g_cUCTot % 10) == 0)
            TraceMsg(DM_PERF, "uc: tot=%d hit=%d", g_cUCTot, g_cUCHit);
#endif

        DBEXEC(TRUE, g_cUCTot++);
        // try the cache 1st
        if (InterlockedExchange(&g_lockUC, 1) == 0) {
            hr = E_FAIL;
            if ((g_dwUCFlags==dwFlags)
                &&
                (!(dwFlags & URL_ESCAPE_PERCENT))
                &&
                StrCmpCW(pszUrl, g_szUCCanon) == 0)
            {
                DBEXEC(TRUE, g_cUCHit++);
                DWORD cchTmp = *pcchCanonicalized;
                hr = StrCopyOutW(g_szUCCanon, pszCanonicalized, pcchCanonicalized);
                if (FAILED(hr))
                    *pcchCanonicalized = cchTmp;    // restore!
            }
            InterlockedExchange(&g_lockUC, 0);
            if (SUCCEEDED(hr))
                return hr;
        }

        hr = UrlCombineW(L"", pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags);
        if (SUCCEEDED(hr) && *pcchCanonicalized < ARRAYSIZE(g_szUCCanon)) {
            if (InterlockedExchange(&g_lockUC, 1) == 0) {
                StrCpyW(g_szUCCanon, pszCanonicalized);
                g_dwUCFlags = dwFlags;
                InterlockedExchange(&g_lockUC, 0);
            }
        }
    }

    return hr;
}

LWSTDAPI
UrlEscapeW(LPCWSTR pszUrl,
           LPWSTR pszEscaped,
           LPDWORD pcchEscaped,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strwOut;

    RIPMSG(pszUrl && IS_VALID_STRING_PTRW(pszUrl, -1), "UrlEscapeW: Caller passed invalid pszUrl");
    RIPMSG(NULL!=pcchEscaped && IS_VALID_WRITE_PTR(pcchEscaped, DWORD), "UrlEscapeW: Caller passed invalid pcchEscaped");
    RIPMSG(pszEscaped && (NULL==pcchEscaped || IS_VALID_WRITE_BUFFER(pszEscaped, WCHAR, *pcchEscaped)), "UrlEscapeW: Caller passed invalid pszEscaped");
#ifdef DEBUG
    if (pcchEscaped)
    {
        if (pszEscaped==pszUrl)
            DEBUGWhackPathStringW(pszEscaped, *pcchEscaped);
        else
            DEBUGWhackPathBufferW(pszEscaped, *pcchEscaped);
    }
#endif

    if (!pszUrl || !pszEscaped ||
        !pcchEscaped || !*pcchEscaped)
        hr = E_INVALIDARG;
    else
    {
        hr = SHUrlEscape(pszUrl, &strwOut, dwFlags);
    }

    if(SUCCEEDED(hr) )
        hr = CopyOutW(&strwOut, pszEscaped, pcchEscaped);

    return hr;
}


LWSTDAPI_(int) UrlCompareW(LPCWSTR psz1, LPCWSTR psz2, BOOL fIgnoreSlash)
{
    RIPMSG(psz1 && IS_VALID_STRING_PTRW(psz1, -1), "UrlCompareW: Caller passed invalid psz1");
    RIPMSG(psz2 && IS_VALID_STRING_PTRW(psz1, -1), "UrlCompareW: Caller passed invalid psz2");
    if (psz1 && psz2)
    {
        SHSTRW str1, str2;

        if( SUCCEEDED(str1.SetStr(psz1)) && SUCCEEDED(str2.SetStr(psz2)) &&
            SUCCEEDED(SHUrlUnescapeW(str1.GetInplaceStr(), 0)) && SUCCEEDED(SHUrlUnescapeW(str2.GetInplaceStr(), 0)))
        {
            if(fIgnoreSlash)
            {
                LPWSTR pch;

                pch = str1.GetInplaceStr() + str1.GetLen() - 1;
                if(*pch == SLASH)
                    TERMSTR(pch);

                pch = str2.GetInplaceStr() + str2.GetLen() - 1;
                if(*pch == SLASH)
                    TERMSTR(pch);
            }

            return StrCmpW(str1, str2);
        }
    }

    return StrCmpW(psz1, psz2);
}



LWSTDAPI
UrlUnescapeW(LPWSTR pszUrl, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    RIPMSG(pszUrl && IS_VALID_STRING_PTRW(pszUrl, -1), "UrlUnescapeW: Caller passed invalid pszUrl");

    if(dwFlags & URL_UNESCAPE_INPLACE)
    {
        return SHUrlUnescapeW(pszUrl, dwFlags);
    }

    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlUnescapeW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "UrlUnescapeW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszUrl)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszUrl
        || !pcchOut
        || !*pcchOut
        || !pszOut)
    {
        return E_INVALIDARG;
    }

    SHSTRW str;
    HRESULT hr = str.SetStr(pszUrl);
    if(SUCCEEDED(hr))
    {
        SHUrlUnescapeW(str.GetInplaceStr(), dwFlags);
        hr = CopyOutW(&str, pszOut, pcchOut);
    }

    return hr;
}


LWSTDAPI
PathCreateFromUrlW
           (LPCWSTR pszIn,
           LPWSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRW(pszIn, -1), "PathCreateFromUrlW: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "PathCreateFromUrlW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "PathCreateFromUrlW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
        hr = SHPathCreateFromUrl(pszIn, &strOut, dwFlags);

    if(SUCCEEDED(hr) )
        hr = CopyOutW(&strOut, pszOut, pcchOut);

    return hr;

}

LWSTDAPI
UrlCreateFromPathW
           (LPCWSTR pszIn,
           LPWSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRW(pszIn, -1), "UrlCreateFromPathW: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlCreateFromPathW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "UrlCreateFromPathW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
        hr = SHUrlCreateFromPath(pszIn, &strOut, dwFlags);

    if(SUCCEEDED(hr) )
        hr = ReconcileHresults(hr, CopyOutW(&strOut, pszOut, pcchOut));

    return hr;

}

LWSTDAPI
UrlGetPartW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags)
{
    SHSTRW strIn, strOut;
    HRESULT hr;

    RIPMSG(pszIn && IS_VALID_STRING_PTRW(pszIn, -1), "UrlGetPartW: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlGetPartW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "UrlGetPartW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut || !dwPart)
        hr = E_INVALIDARG;
    else if (SUCCEEDED(hr = strIn.SetStr(pszIn)))
        hr = SHUrlGetPart(&strIn, &strOut, dwPart, dwFlags);

    if(SUCCEEDED(hr) )
        hr = CopyOutW(&strOut, pszOut, pcchOut);

    return hr;
}


LWSTDAPI
UrlApplySchemeW
           (LPCWSTR pszIn,
           LPWSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRW(pszIn, -1), "UrlApplySchemeW: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlApplySchemeW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "UrlApplySchemeW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
        hr = SHUrlApplyScheme(pszIn, &strOut, dwFlags);

    if(S_OK == (hr))
        hr = CopyOutW(&strOut, pszOut, pcchOut);

    return hr;

}

//
//  this is the same table used by both URLMON and WININET's cache
//
const static BYTE Translate[256] =
{
    1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
    87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
    49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
    12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
    176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
    178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
    102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
    166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
    121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
    193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
    6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
    84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
    249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
    230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
    44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
    163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
};

PRIVATE void _HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash)
{
    DWORD i, j;
    //  seed the hash
    for (i = cbHash; i-- > 0;)
        pbHash[i] = (BYTE) i;

    //  do the hash
    for (j = cbData; j-- > 0;)
    {
        for (i = cbHash; i-- > 0;)
            pbHash[i] = Translate[pbHash[i] ^ pbData[j]];
    }
}

LWSTDAPI
HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash)
{
    RIPMSG(pbData && IS_VALID_READ_BUFFER(pbData, BYTE, cbData), "HashData: Caller passed invalid pbData");
    RIPMSG(pbHash && IS_VALID_WRITE_BUFFER(pbHash, BYTE, cbHash), "HashData: Caller passed invalid pbHash");
    if (pbData && pbHash)
    {
        _HashData(pbData, cbData, pbHash, cbHash);
        return S_OK;
    }
    return E_INVALIDARG;
}


LWSTDAPI
UrlHashA(LPCSTR psz, LPBYTE pb, DWORD cb)
{
    HRESULT hr = E_INVALIDARG;

    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "UrlHashA: Caller passed invalid psz");
    RIPMSG(pb && IS_VALID_WRITE_BUFFER(pb, BYTE, cb), "UrlHashA: Caller passed invalid pb");
    if (psz && pb)
    {
        _HashData((LPBYTE) psz, lstrlenA(psz), pb, cb);
        return S_OK;
    }

    return hr;
}


LWSTDAPI
UrlHashW(LPCWSTR psz, LPBYTE pb, DWORD cb)
{
    HRESULT hr;

    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "UrlHashW: Caller passed invalid psz");
    RIPMSG(pb && IS_VALID_WRITE_BUFFER(pb, BYTE, cb), "UrlHashW: Caller passed invalid pb");
    if (psz && pb)
    {
        SHSTRA str;
        if (SUCCEEDED( hr = str.SetStr(psz)))
            hr = UrlHashA(str, pb, cb);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



/***************************** ParseURL Functions *****************************/
//  these were originally in URL.DLL and then moved to shlwapi.
//  i just added them from url.c for reuse of code.
//  ParseURL now does no MBCS thunks, to keep it fast.
//
//  declarations for ParseURL() APIs
//

typedef const PARSEDURLA   CPARSEDURLA;
typedef const PARSEDURLA * PCPARSEDURLA;

typedef const PARSEDURLW   CPARSEDURLW;
typedef const PARSEDURLW * PCPARSEDURLW;


#ifdef DEBUG

BOOL
IsValidPCPARSEDURLA(
   LPCSTR pcszURL,
   PCPARSEDURLA pcpu)
{
   return(IS_VALID_READ_PTR(pcpu, CPARSEDURLA) &&
          (IS_VALID_STRING_PTRA(pcpu->pszProtocol, -1) &&
           EVAL(IsStringContainedA(pcszURL, pcpu->pszProtocol)) &&
           EVAL(pcpu->cchProtocol < (UINT)lstrlenA(pcpu->pszProtocol))) &&
          (IS_VALID_STRING_PTRA(pcpu->pszSuffix, -1) &&
           EVAL(IsStringContainedA(pcszURL, pcpu->pszSuffix)) &&
           EVAL(pcpu->cchSuffix <= (UINT)lstrlenA(pcpu->pszSuffix))) &&
          EVAL(pcpu->cchProtocol + pcpu->cchSuffix < (UINT)lstrlenA(pcszURL)));
}

BOOL
IsValidPCPARSEDURLW(
   LPCWSTR pcszURL,
   PCPARSEDURLW pcpu)
{
   return(IS_VALID_READ_PTR(pcpu, CPARSEDURLW) &&
          (IS_VALID_STRING_PTRW(pcpu->pszProtocol, -1) &&
           EVAL(IsStringContainedW(pcszURL, pcpu->pszProtocol)) &&
           EVAL(pcpu->cchProtocol < (UINT)lstrlenW(pcpu->pszProtocol))) &&
          (IS_VALID_STRING_PTRW(pcpu->pszSuffix, -1) &&
           EVAL(IsStringContainedW(pcszURL, pcpu->pszSuffix)) &&
           EVAL(pcpu->cchSuffix <= (UINT)lstrlenW(pcpu->pszSuffix))) &&
          EVAL(pcpu->cchProtocol + pcpu->cchSuffix < (UINT)lstrlenW(pcszURL)));
}

#endif


/*----------------------------------------------------------
Purpose: Parse the given path into the PARSEDURL structure.

  ******
  ******  This function must not do any extraneous
  ******  things.  It must be small and fast.
  ******

    Returns: NOERROR if a valid URL format
    URL_E_INVALID_SYNTAX if not

      Cond:    --
*/
STDMETHODIMP
ParseURLA(
          LPCSTR pcszURL,
          PPARSEDURLA ppu)
{
    HRESULT hr = E_INVALIDARG;

    RIP(IS_VALID_STRING_PTRA(pcszURL, -1));
    RIP(IS_VALID_WRITE_PTR(ppu, PARSEDURLA));

    if (pcszURL && ppu && SIZEOF(*ppu) == ppu->cbSize)
    {
        DWORD cch;
        hr = URL_E_INVALID_SYNTAX;      // assume error

        ppu->pszProtocol = FindSchemeA(pcszURL, &cch);

        if(ppu->pszProtocol)
        {
            ppu->cchProtocol = cch;

            // Determine protocol scheme number
            ppu->nScheme = SchemeTypeFromStringA(ppu->pszProtocol, cch);

            ppu->pszSuffix = ppu->pszProtocol + cch + 1;

            //
            //  APPCOMPAT - Backwards compatibility - zekel 28-feb-97
            //  ParseURL() believes in file: urls like "file://C:\foo\bar"
            //  and some pieces of code will use it to get the Dos Path.
            //  new code should always call PathCreateFromUrl() to
            //  get the dos path of a file: URL.
            //
            //  i am leaving this behavior in case some compat stuff is out there.
            //
            if (URL_SCHEME_FILE == ppu->nScheme &&
                '/' == ppu->pszSuffix[0] && '/' == ppu->pszSuffix[1])
            {
                // Yes; skip the "//"
                ppu->pszSuffix += 2;

#ifndef UNIX
                // FOR UNIX: If we have /vobs/build, we don't want to make
                // There might be a third slash.  Skip it.
                if ('/' == *ppu->pszSuffix)
                    ppu->pszSuffix++;
#endif

            }

            ppu->cchSuffix = lstrlenA(ppu->pszSuffix);

            hr = S_OK;
        }
    }

#ifdef DEBUG
    if (hr == S_OK)
    {
        CHAR rgchDebugProtocol[MAX_PATH];
        CHAR rgchDebugSuffix[MAX_PATH];

        // (+ 1) for null terminator.

        lstrcpynA(rgchDebugProtocol, ppu->pszProtocol,
            min(ppu->cchProtocol + 1, SIZECHARS(rgchDebugProtocol)));

        // (+ 1) for null terminator.

        lstrcpynA(rgchDebugSuffix, ppu->pszSuffix,
            min(ppu->cchSuffix + 1, SIZECHARS(rgchDebugSuffix)));

        TraceMsgA(TF_URL, "ParseURL(): Parsed protocol \"%s\" and suffix \"%s\" from URL \"%s\".",
            rgchDebugProtocol,
            rgchDebugSuffix,
            pcszURL);
    }
    else
    {
        TraceMsgA(TF_URL, "ParseURL(): Failed to parse \"%s\"", pcszURL);
    }
#endif


    ASSERT(FAILED(hr) ||
        EVAL(IsValidPCPARSEDURLA(pcszURL, ppu)));

    return(hr);
}


/*----------------------------------------------------------
Purpose: Parse the given path into the PARSEDURL structure.

  ******
  ******  This function must not do any extraneous
  ******  things.  It must be small and fast.
  ******

    Returns: NOERROR if a valid URL format
    URL_E_INVALID_SYNTAX if not

      Cond:    --
*/
STDMETHODIMP
ParseURLW(
          LPCWSTR pcszURL,
          PPARSEDURLW ppu)
{
    HRESULT hr = E_INVALIDARG;

    RIP(IS_VALID_STRING_PTRW(pcszURL, -1));
    RIP(IS_VALID_WRITE_PTR(ppu, PARSEDURLW));

    if (pcszURL && ppu && SIZEOF(*ppu) == ppu->cbSize)
    {
        DWORD cch;
        hr = URL_E_INVALID_SYNTAX;      // assume error

        ppu->pszProtocol = FindSchemeW(pcszURL, &cch);

        if(ppu->pszProtocol)
        {
            ppu->cchProtocol = cch;

            // Determine protocol scheme number
            ppu->nScheme = SchemeTypeFromStringW(ppu->pszProtocol, cch);

            ppu->pszSuffix = ppu->pszProtocol + cch + 1;

            //
            //  APPCOMPAT - Backwards compatibility - zekel 28-feb-97
            //  ParseURL() believes in file: urls like "file://C:\foo\bar"
            //  and some pieces of code will use it to get the Dos Path.
            //  new code should always call PathCreateFromUrl() to
            //  get the dos path of a file: URL.
            //
            //  i am leaving this behavior in case some compat stuff is out there.
            //
            if (URL_SCHEME_FILE == ppu->nScheme &&
                '/' == ppu->pszSuffix[0] && '/' == ppu->pszSuffix[1])
            {
                // Yes; skip the "//"
                ppu->pszSuffix += 2;

#ifndef UNIX
                // There might be a third slash.  Skip it.
                // IEUNIX - On UNIX, it's a root directory, so don't skip it!
                if ('/' == *ppu->pszSuffix)
                    ppu->pszSuffix++;
#endif
            }

            ppu->cchSuffix = lstrlenW(ppu->pszSuffix);

            hr = S_OK;
        }
    }


#ifdef DEBUG
    if (hr==S_OK)
    {
        WCHAR rgchDebugProtocol[MAX_PATH];
        WCHAR rgchDebugSuffix[MAX_PATH];

        // (+ 1) for null terminator.

        StrCpyNW(rgchDebugProtocol, ppu->pszProtocol,
            min(ppu->cchProtocol + 1, SIZECHARS(rgchDebugProtocol)));

        // (+ 1) for null terminator.

        StrCpyNW(rgchDebugSuffix, ppu->pszSuffix,
            min(ppu->cchSuffix + 1, SIZECHARS(rgchDebugSuffix)));

        TraceMsg(TF_URL, "ParseURL(): Parsed protocol \"%s\" and suffix \"%s\" from URL \"%s\".",
            rgchDebugProtocol,
            rgchDebugSuffix,
            pcszURL);
    }
    else
    {
        TraceMsg(TF_URL, "ParseURL(): Failed to parse \"%s\"", pcszURL);
    }
#endif

    ASSERT(FAILED(hr) ||
        EVAL(IsValidPCPARSEDURLW(pcszURL, ppu)));

    return(hr);
}

#ifdef USE_FAST_PARSER

// GetSchemeTypeAndFlagsSpecialW
// performs the same behavior as GetSchemeTypeAndFlagsW plus, when successful
// copies the canonicalised form of the scheme back.

PRIVATE URL_SCHEME
GetSchemeTypeAndFlagsSpecialW(LPWSTR pszScheme, DWORD cchScheme, LPDWORD pdwFlags)
{
    DWORD i;

    ASSERT(pszScheme);


#ifdef DEBUG
    if ((g_cSTTot % 10) == 0)
        TraceMsg(DM_PERF, "gstaf: tot=%d hit=%d hit0=%d", g_cSTTot, g_cSTHit, g_cSTHit0);
#endif
    DBEXEC(TRUE, g_cSTTot++);
    // check cache 1st
    i = g_iScheme;
    if (cchScheme == g_mpUrlSchemeTypes[i].cchScheme
      && StrCmpNCW(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme) == 0)
    {
        DBEXEC(TRUE, i == 0 ? g_cSTHit0++ : g_cSTHit++);
Lhit:
        if (pdwFlags)
            *pdwFlags = g_mpUrlSchemeTypes[i].dwFlags;

        // update cache (unconditionally)
        g_iScheme = i;

        // We need to do this because the scheme might not be canonicalised
        memcpy(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme*sizeof(WCHAR));
        return g_mpUrlSchemeTypes[i].eScheme;
    }

    for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
    {
        if(cchScheme == g_mpUrlSchemeTypes[i].cchScheme
          && 0 == StrCmpNIW(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme))
            goto Lhit;
    }

    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return URL_SCHEME_UNKNOWN;
}



// URL_STRING --------------------------------------------------------------------------------------

// is a container for the combined URL. It attempts to construct a string from the information
// fed into it. If there is not enough buffer space available, it will measure how much additional
// space will be required to hold the string.

WCHAR wszBogus[] = L"";


// US_* are the various modes of transforming characters fed into the container.
// US_NOTHING   do nothing to the character.
// US_UNESCAPE  turn entries of the form %xx into the unescaped form
// US_ESCAPE_UNSAFE transform invalid path characters into %xx sequences
// US_ESCAPE_SPACES transform only spaces in to %20 sequences

enum
{
    US_NOTHING,
    US_UNESCAPE,
    US_ESCAPE_UNSAFE,
    US_ESCAPE_SPACES
};

class URL_STRING
{
protected:
    URL_SCHEME _eScheme;
    DWORD _ccWork, _ccMark, _ccLastWhite, _ccQuery, _ccFragment, _ccBuffer, _dwSchemeInfo;
    DWORD _dwOldFlags, _dwFlags, _dwMode;
    BOOL _fFixSlashes, _fExpecting, _fError;
    WCHAR _wchLast, _wszInternalString[256];
    PWSTR _pszWork;

    VOID baseAccept(WCHAR wch);
    VOID TrackWhiteSpace(WCHAR wch);

public:
    URL_STRING(DWORD dwFlags);
    ~URL_STRING();

    VOID CleanAccept(WCHAR wch);
    VOID Accept(WCHAR wch);
    VOID Accept(PWSTR a_psz);
    VOID Contract(BOOL fContractLevel = TRUE);
    VOID TrimEndWhiteSpace();

    PWSTR GetStart();
    LONG GetTotalLength();
    BOOL AnyProblems();

    VOID NoteScheme(URL_SCHEME a_eScheme, DWORD a_dwSchemeInfo);
    VOID AddSchemeNote(DWORD a_dwSchemeInfo);
    DWORD GetSchemeNotes();
    URL_SCHEME QueryScheme();

    VOID Mark();
    VOID ClearMark();
    VOID EraseMarkedText();
    DWORD CompareMarkWith(PWSTR psz);
    DWORD CompareLast(PCWSTR psz, DWORD cc);

    VOID EnableMunging();
    VOID DisableMunging();
    VOID DisableSlashFixing();
    VOID BackupFlags();
    VOID RestoreFlags();
    VOID AddFlagNote(DWORD dwFlag);

    VOID NotifyQuery();
    VOID NotifyFragment();
    VOID DropQuery();
    VOID DropFragment();
};

// -------------------------------------------------------------------------------

URL_STRING::URL_STRING(DWORD dwFlags)
{
    _ccBuffer = ARRAYSIZE(_wszInternalString);
    _ccWork = 1;
    _pszWork = _wszInternalString;
    _ccQuery = _ccFragment = _ccMark = 0;

    _eScheme = URL_SCHEME_UNKNOWN;
    _dwOldFlags = _dwFlags = dwFlags;
    _dwMode = US_NOTHING;

    _fFixSlashes = TRUE;
    _fError = _fExpecting = FALSE;
}

URL_STRING::~URL_STRING()
{
    if (_ccBuffer > ARRAYSIZE(_wszInternalString))
    {
        LocalFree(_pszWork);
    }
}

// -------------------------------------------------------------------------------
// These are the standard functions used for adding characters to an url.

VOID URL_STRING::baseAccept(WCHAR wch)
{
    _pszWork[_ccWork-1] = (_fFixSlashes
                    ? ((wch!=WHACK) ? wch : SLASH)
                    : wch);
    _ccWork++;
    if (_ccWork>_ccBuffer)
    {
        if (!_fError)
        {
            PWSTR psz = (PWSTR)LocalAlloc(LPTR, 2*_ccBuffer*sizeof(WCHAR));
            if (!psz)
            {
                _ccWork--;
                _fError = TRUE;
                return;
            }
            memcpy(psz, _pszWork, (_ccWork-1)*sizeof(WCHAR));
            if (_ccBuffer>ARRAYSIZE(_wszInternalString))
            {
                LocalFree(_pszWork);
            }
            _ccBuffer *= 2;
            _pszWork = psz;
        }
        else
        {
            _ccWork--;
        }
    }
}


VOID URL_STRING::TrackWhiteSpace(WCHAR wch)
{
    if (IsWhite(wch))
    {
        if (!_ccLastWhite)
        {
            _ccLastWhite = _ccWork;
        }
    }
    else
    {
        _ccLastWhite = 0;
    }
}


// -- URL_STRING::Accept ----------------------------
// Based on the current munging mode, transform the character into the
// desired form and add it to the string.

VOID URL_STRING::Accept(WCHAR wch)
{
    TrackWhiteSpace(wch);

    switch (_dwMode)
    {
    case US_NOTHING:
        break;

    case US_UNESCAPE:
        if (_fExpecting)
        {
            if (!IsHex(wch))
            {
                baseAccept(HEX_ESCAPE);
                if (_wchLast!=L'\0')
                {
                    baseAccept(_wchLast);
                }
                _fExpecting = FALSE;
                break;
            }
            else if (_wchLast!=L'\0')
            {
                wch = (HexToWord(_wchLast)*16) + HexToWord(wch);
                TrackWhiteSpace(wch);
                _fExpecting = FALSE;
                if ((wch==WHACK) && _fFixSlashes)
                {
                    _fFixSlashes = FALSE;
                    baseAccept(wch);
                    _fFixSlashes = TRUE;
                    return;
                }
                break;
            }
            else
            {
                _wchLast = wch;
            }
            return;
        }
        if (wch==HEX_ESCAPE)
        {
            _fExpecting = TRUE;
            _wchLast = L'\0';
            return;
        }
        break;

     case US_ESCAPE_UNSAFE:
        if ((wch==SLASH)
            ||
            (wch==WHACK && _fFixSlashes)
            ||
            (IsSafePathChar(wch) && (wch!=HEX_ESCAPE || !(_dwFlags & URL_ESCAPE_PERCENT))))
        {
            break;
        }

        baseAccept(L'%');
        baseAccept(hex[(wch >> 4) & 15]);
        baseAccept(hex[wch & 15]);
        return;

    case US_ESCAPE_SPACES:
        if (wch==SPC)
        {
            baseAccept(L'%');
            baseAccept(L'2');
            baseAccept(L'0');
            return;
        }
        break;
     default:
        ASSERT(FALSE);
    }
    baseAccept(wch);
}

// -- Accept --------------------------------
// Accept only a string
VOID URL_STRING::Accept(PWSTR psz)
{
    while (*psz)
    {
        Accept(*psz);
        psz++;
    }
}

// -- Contract
// Whenever we call Contract, we're pointing past the last separator. We want to
// omit the segment between this separator and the one before it.
// This should be used ONLY when we're examining the path segment of the urls.

VOID URL_STRING::Contract(BOOL fContractLevel)
{
    ASSERT(_ccWork && _ccMark);

    // _ccWork is 1 after wherever the next character will be placed
    // subtract +1 to derive what the last character in the url is
    DWORD _ccEnd = _ccWork-1 - 1;
    if (_eScheme!=URL_SCHEME_MK)
    {
        if (!fContractLevel && (_pszWork[_ccEnd]==SLASH || _pszWork[_ccEnd]==WHACK))
        {
            return;
        }
        do
        {
            _ccEnd--;
        }
        while ((_ccEnd>=_ccMark-1) && _pszWork[_ccEnd]!=SLASH && _pszWork[_ccEnd]!=WHACK);
    }
    else
    {
        if (!fContractLevel && (_pszWork[_ccEnd]==SLASH))
        {
            return;
        }
        do
        {
            _ccEnd--;
        }
        while ((_ccEnd>=_ccMark-1) && _pszWork[_ccEnd]!=SLASH);
    }
    if (_ccEnd<_ccMark-1)
    {
        _ccEnd = _ccMark-1;
    }
    else
    {
        _ccEnd++;
    }
    _ccWork = _ccEnd + 1;
}

VOID URL_STRING::TrimEndWhiteSpace()
{
    if (_ccLastWhite)
    {
        _ccWork = _ccLastWhite;
        _ccLastWhite = 0;
    }
}


VOID URL_STRING::CleanAccept(WCHAR wch)
{
    baseAccept(wch);
}


// -------------------------------------------------------------------------------
// These member functions return information about the url that is being formed

PWSTR URL_STRING::GetStart()
{
    return _pszWork;
}

LONG URL_STRING::GetTotalLength()
{
    return _ccWork - 1;
}

BOOL URL_STRING::AnyProblems()
{
    return _fError;
}

// -------------------------------------------------------------------------------

VOID URL_STRING::NoteScheme(URL_SCHEME a_eScheme, DWORD a_dwSchemeInfo)
{
    _eScheme = a_eScheme;
    _dwSchemeInfo = a_dwSchemeInfo;
    _fFixSlashes = a_dwSchemeInfo & UPF_SCHEME_CONVERT;
}

VOID URL_STRING::AddSchemeNote(DWORD a_dwSchemeInfo)
{
    _dwSchemeInfo |= a_dwSchemeInfo;
    _fFixSlashes = _dwSchemeInfo & UPF_SCHEME_CONVERT;
}

DWORD URL_STRING::GetSchemeNotes()
{
    return _dwSchemeInfo;
}

URL_SCHEME URL_STRING::QueryScheme()
{
    return _eScheme;
}

// -------------------------------------------------------------------------------

VOID URL_STRING::Mark()
{
    _ccMark = _ccWork;
}

VOID URL_STRING::ClearMark()
{
    _ccMark = 0;
}

VOID URL_STRING::EraseMarkedText()
{
    if (_ccMark)
    {
        _ccWork = _ccMark;
        _ccMark = 0;
    }
}

DWORD URL_STRING::CompareMarkWith(PWSTR psz)
{
    if (_ccMark)
    {
        *(_pszWork + _ccWork - 1) = L'\0';
        return (StrCmpW(_pszWork + _ccMark - 1, psz));
    }
    // In other words, return that the string isn't present.
    return 1;
}

DWORD URL_STRING::CompareLast(PCWSTR psz, DWORD cc)
{
    if (_ccWork > cc)
    {
        return StrCmpNIW(_pszWork + _ccWork - 1 - cc, psz, cc);
    }
    return 1;
}


// -------------------------------------------------------------------------------

VOID URL_STRING::NotifyQuery()
{
    if (!_ccQuery)
    {
        _ccQuery = _ccWork;
    }
}

VOID URL_STRING::NotifyFragment()
{
    if (!_ccFragment)
    {
        _ccFragment = _ccWork;
        CleanAccept(POUND);
    }
}

VOID URL_STRING::DropQuery()
{
    if (_ccQuery)
    {
        _ccWork = _ccQuery;
        _ccQuery = _ccFragment = 0;
    }
}

VOID URL_STRING::DropFragment()
{
    if (_ccFragment)
    {
        _ccWork = _ccFragment;
        _ccFragment = 0;
    }
}

// -------------------------------------------------------------------------------
// These member functions are for determining how the url's characters are going
// to be represented

VOID URL_STRING::EnableMunging()
{
    _dwMode = US_NOTHING;

    // For opaque urls, munge ONLY if we're explicitly asked to URL_ESCAPE or URL_UNESCAPE,
    // but NOT URL_ESCAPE_SPACES_ONLY

    // For query and fragment, never allow for URL_ESCAPE_UNSAFE and for
    //    others ONLY when URL_DONT_ESCAPE_EXTRA_INFO is specified

    if ((_dwSchemeInfo & UPF_SCHEME_OPAQUE)
        && (_dwFlags & URL_ESCAPE_SPACES_ONLY))
        return;

    if ((_ccQuery || _ccFragment)
        && ((_dwFlags & (URL_DONT_ESCAPE_EXTRA_INFO | URL_ESCAPE_UNSAFE))))
        return;

    if (_dwFlags & URL_UNESCAPE)
    {
        _dwMode = US_UNESCAPE;
    }
    else if (_dwFlags & URL_ESCAPE_UNSAFE)
    {
        _dwMode = US_ESCAPE_UNSAFE;
    }
    else if (_dwFlags & URL_ESCAPE_SPACES_ONLY)
    {
        _dwMode = US_ESCAPE_SPACES;
    }
}

VOID URL_STRING::DisableMunging()
{
    _dwMode = US_NOTHING;
}

VOID URL_STRING::DisableSlashFixing()
{
    _fFixSlashes = FALSE;
}

VOID URL_STRING::AddFlagNote(DWORD dwFlag)
{
    _dwFlags |= dwFlag;
}

VOID URL_STRING::BackupFlags()
{
    _dwOldFlags = _dwFlags;
}

VOID URL_STRING::RestoreFlags()
{
    ASSERT((_eScheme==URL_SCHEME_FILE) || (_dwFlags==_dwOldFlags));
    _dwFlags = _dwOldFlags;
    EnableMunging();
}

// -------------------------------------------------------------------------------


// URL ------------------------------------------------------------------------------------
// The URL class is used to examine the base and relative URLs to determine what
// will go into the URL_STRING container. The difference should be clear:
// URL instances look, but don't touch. URL_STRINGs are used solely to build urls.


class URL
{
private:
    PCWSTR _pszUrl, _pszWork;
    URL_SCHEME _eScheme;
    DWORD _dwSchemeNotes, _dwFlags;
    BOOL _fPathCompressionOn;
    BOOL _fIgnoreQuery;

    WCHAR SmallForm(WCHAR wch);
    BOOL IsAlpha(WCHAR ch);
    PCWSTR IsUrlPrefix(PCWSTR psz);
    BOOL IsLocalDrive(PCWSTR psz);
    BOOL IsQualifiedDrive(PCWSTR psz);
    BOOL DetectSymbols(WCHAR wch1, WCHAR wch2 = '\0', WCHAR wch3 = '\0');

    PCWSTR NextChar(PCWSTR psz);
    PCWSTR FeedUntil(PCWSTR psz, URL_STRING* pus, WCHAR wchDelim1 = '\0', WCHAR wchDelim2 = '\0', WCHAR wchDelim3 = '\0', WCHAR wchDelim4 = '\0');

    BOOL DetectFileServer();
    BOOL DetectMkServer();
    BOOL DefaultDetectServer();
    VOID FeedDefaultServer(URL_STRING* pus);
    VOID FeedFileServer(URL_STRING* pus);
    VOID FeedFtpServer(URL_STRING* pus);
    VOID FeedHttpServer(URL_STRING* pus);
    VOID FeedMkServer(URL_STRING* pus);
    PCWSTR FeedPort(PCWSTR psz, URL_STRING* pus);

public:
    VOID Setup(PCWSTR pszInUrl, DWORD a_dwFlags = 0);
    VOID Reset();
    BOOL IsReset();

    BOOL DetectAndFeedScheme(URL_STRING* pus, BOOL fReconcileSchemes = FALSE);
    VOID SetScheme(URL_SCHEME eScheme, DWORD dwFlag);
    URL_SCHEME GetScheme();
    VOID AddSchemeNote(DWORD dwFlag);
    DWORD GetSchemeNotes();

    BOOL DetectServer();
    BOOL DetectAbsolutePath();
    BOOL DetectPath();
    BOOL DetectQueryOrFragment();
    BOOL DetectQuery();
    BOOL DetectLocalDrive();
    BOOL DetectSlash();
    BOOL DetectAnything();
    WCHAR PeekNext();

    VOID FeedPath(URL_STRING* pus, BOOL fMarkServer = TRUE);
    PCWSTR CopySegment(PCWSTR psz, URL_STRING* pus, BOOL* pfContinue);
    DWORD DetectDots(PCWSTR* ppsz);
    VOID StopPathCompression();

    VOID FeedServer(URL_STRING* pus);
    VOID FeedLocalDrive(URL_STRING* pus);
    VOID FeedQueryAndFragment(URL_STRING* pus);
    VOID IgnoreQuery();
};

// -------------------------------------------------------------------------------

VOID URL::Setup(PCWSTR pszInUrl, DWORD a_dwFlags)
{
    while (*pszInUrl && IsWhite(*pszInUrl))
    {
        pszInUrl++;
    }
    _pszWork = _pszUrl = pszInUrl;
    _eScheme = URL_SCHEME_UNKNOWN;
    _dwSchemeNotes = 0;
    _dwFlags = a_dwFlags;
    _fPathCompressionOn = TRUE;
    _fIgnoreQuery = FALSE;
}

VOID URL::Reset()
{
    _pszWork = wszBogus;
}

BOOL URL::IsReset()
{
    return (_pszWork==wszBogus);
}

// -------------------------------------------------------------------------------

inline WCHAR URL::SmallForm(WCHAR wch)
{
    return (wch < L'A' || wch > L'Z') ? wch : (wch - L'A' + L'a');
}

inline BOOL URL::IsAlpha(WCHAR ch)
{
    return ((ch >= 'a') && (ch <= 'z'))
           ||
           ((ch >= 'A') && (ch <= 'Z'));
}


inline PCWSTR URL::IsUrlPrefix(PCWSTR psz)
{
    // We want to skip instances of "URL:"
    psz = NextChar(psz);
    if (*psz==L'u' || *psz==L'U')
    {
        psz = NextChar(psz+1);
        if (*psz==L'r' || *psz==L'R')
        {
            psz = NextChar(psz+1);
            if (*psz==L'l' || *psz==L'L')
            {
                psz = NextChar(psz+1);
                if (*psz==COLON)
                {
                    return NextChar(psz+1);
                }
            }
        }
    }
    return NULL;
}

inline BOOL URL::IsLocalDrive(PCWSTR psz)
{
    psz = NextChar(psz);
    return (IsAlpha(*psz)
            &&
            ((*NextChar(psz+1)==COLON) || (*NextChar(psz+1)==BAR)));
}

// -- IsQualifiedDrive --------
// On Win32 systems, a qualified drive is either
// i. <letter>:  or ii. \\UNC\
// Under unix, it's only /.

inline BOOL URL::IsQualifiedDrive(PCWSTR psz)
{
    psz = NextChar(psz);
    BOOL fResult = IsLocalDrive(psz);
    if (!fResult && *psz==WHACK)
    {
        psz = NextChar(psz+1);
        fResult = *psz==WHACK;
    }
    return fResult;
}

// -- DetectSymbols -------------
// This is used to help determine what part of the URL we have reached.
inline BOOL URL::DetectSymbols(WCHAR wch1, WCHAR wch2, WCHAR wch3)
{
    ASSERT(_pszWork);
    PCWSTR psz = NextChar(_pszWork);
    return (*psz && (*psz==wch1 || *psz==wch2 || *psz==wch3));
}

BOOL URL::DetectSlash()
{
    return DetectSymbols(SLASH, WHACK);
}

BOOL URL::DetectAnything()
{
    return (*NextChar(_pszWork)!=L'\0');
}

// -- NextChar -------------------------------------
// We use NextChar instead of *psz because we want to
// ignore characters such as TAB, CR, etc.
inline PCWSTR URL::NextChar(PCWSTR psz)
{
    while (IsInsignificantWhite(*psz))
    {
        psz++;
    }
    return psz;
}

WCHAR URL::PeekNext()
{
    return (*NextChar(NextChar(_pszWork)+1));
}


// -------------------------------------------------------------------------------

inline PCWSTR URL::FeedUntil(PCWSTR psz, URL_STRING* pus, WCHAR wchDelim1, WCHAR wchDelim2, WCHAR wchDelim3, WCHAR wchDelim4)
{
    psz = NextChar(psz);
    while (*psz && *psz!=wchDelim1 && *psz!=wchDelim2 && *psz!=wchDelim3 && *psz!=wchDelim4)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    return psz;
}

// -------------------------------------------------------------------------------

VOID URL::SetScheme(URL_SCHEME eScheme, DWORD dwFlag)
{
    _eScheme = eScheme;
    _dwSchemeNotes = dwFlag;
}

URL_SCHEME URL::GetScheme()
{
    return _eScheme;
}

VOID URL::AddSchemeNote(DWORD dwFlag)
{
    _dwSchemeNotes |= dwFlag;
}

DWORD URL::GetSchemeNotes()
{
    return _dwSchemeNotes;
}

BOOL URL::DetectAndFeedScheme(URL_STRING* pus, BOOL fReconcileSchemes)
{
    ASSERT(_pszWork);
    ASSERT(!fReconcileSchemes || (fReconcileSchemes && pus->QueryScheme()!=URL_SCHEME_FILE));

    PCWSTR psz = NextChar(_pszWork);
    BOOL fResult = (IsQualifiedDrive(_pszWork));
    if (fResult)
    {
        //
        // Detected a File URL that isn't explicitly marked as such, ie C:\foo,
        //   in this case, we need to confirm that we're not overwriting
        //   a fully qualified relative URL with an Accept("file:"), although
        //   if the relative URL is the same scheme as the base, we now
        //   need to make the BASE-file URL take precedence.
        //

        _eScheme = URL_SCHEME_FILE;

        if (!fReconcileSchemes)
        {
            pus->Accept((PWSTR)c_szFileScheme);
            pus->Accept(COLON);
            _dwSchemeNotes = g_mpUrlSchemeTypes[1].dwFlags;
            pus->NoteScheme(_eScheme, _dwSchemeNotes);
            pus->AddFlagNote(URL_ESCAPE_PERCENT | URL_ESCAPE_UNSAFE);
        }
        else if (pus->QueryScheme() != URL_SCHEME_FILE)
        {
            Reset();
        }

        goto exit;
    }

    for (;;)
    {
        while (IsValidSchemeCharW(*psz))
        {
            psz = NextChar(psz + 1);
        }
        if (*psz!=COLON)
        {
            break;
        }
        if (IsUrlPrefix(_pszWork))
        {
        // However, we want to skip instances of URL:
            _pszWork = psz = NextChar(psz+1);
            continue;
        }

        DWORD ccScheme = 0;
        PCWSTR pszClone = NextChar(_pszWork);

        if (!fReconcileSchemes)
        {
            while (pszClone<=psz)
            {
                pus->Accept(SmallForm(*pszClone));
                ccScheme++;
                pszClone = NextChar(pszClone+1);
            }
            _pszWork = pszClone;
            // Subtract one for the colon
            ccScheme--;
            // BUG BUG Since we're smallifying the scheme above, we might be able to
            // avoid calling this func, call GetSchemeTypeAndFlags instead.
            _eScheme = GetSchemeTypeAndFlagsSpecialW(pus->GetStart(), ccScheme, &_dwSchemeNotes);
            pus->NoteScheme(_eScheme, _dwSchemeNotes);
        }
        else
        {
            PWSTR pszKnownScheme = pus->GetStart();
            while (pszClone<=psz && SmallForm(*pszClone)==*pszKnownScheme)
            {
                pszClone = NextChar(pszClone+1);
                pszKnownScheme++;
            }
            if (pszClone<=psz)
            {
                Reset();
            }
            else
            {
                _pszWork = pszClone;
            }
        }
        fResult = TRUE;
        break;
    }
 exit:
    return fResult;
}

// -------------------------------------------------------------------------------

BOOL URL::DetectServer()
{
    ASSERT(_pszWork);
    BOOL fRet;

    switch (_eScheme)
    {
    case URL_SCHEME_FILE:
        fRet = DetectFileServer();
        break;

    case URL_SCHEME_MK:
        fRet = DetectMkServer();
        break;

    default:
        fRet = DefaultDetectServer();
        break;
    }
    return fRet;
}

BOOL URL::DetectLocalDrive()
{
    return IsLocalDrive(_pszWork);
}

BOOL URL::DetectFileServer()
{
    ASSERT(_pszWork);
    PCWSTR psz = _pszWork;

    BOOL fResult = IsLocalDrive(_pszWork);
    if (fResult)
    {
        _dwSchemeNotes |= UPF_FILEISPATHURL;
    }
    else
    {
        fResult = DetectSymbols(SLASH, WHACK);
    }
    return fResult;
}

BOOL URL::DetectMkServer()
{
    ASSERT(_pszWork);
    PCWSTR psz = NextChar(_pszWork);
    BOOL fResult = (*psz==L'@');
    if (fResult)
    {
        _pszWork = NextChar(psz + 1);
    }
    return fResult;
}

BOOL URL::DefaultDetectServer()
{
    BOOL fResult = FALSE;
    if (DetectSymbols(SLASH, WHACK))
    {
        PCWSTR psz = NextChar(_pszWork + 1);
        fResult = ((*psz==SLASH) || (*psz==WHACK));
    }
    return fResult;
}

VOID URL::FeedServer(URL_STRING* pus)
{
    ASSERT(_pszWork);
    switch (_eScheme)
    {
    case URL_SCHEME_FILE:
        FeedFileServer(pus);
        break;

    case URL_SCHEME_MK:
        FeedMkServer(pus);
        break;

    case URL_SCHEME_FTP:
        FeedFtpServer(pus);
        break;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
        FeedHttpServer(pus);
        break;

    default:
        FeedDefaultServer(pus);
        break;
    }
}

VOID URL::FeedMkServer(URL_STRING* pus)
{
    ASSERT(_pszWork);
    pus->EnableMunging();
    pus->Accept(L'@');
    _pszWork = FeedUntil(_pszWork, pus, SLASH);
    if (!*_pszWork)
    {
        pus->TrimEndWhiteSpace();
    }
    else
    {
        _pszWork = NextChar(_pszWork+1);
    }
    pus->Accept(SLASH);
}

VOID URL::FeedLocalDrive(URL_STRING* pus)
{
    pus->Accept(*NextChar(_pszWork));
    _pszWork = NextChar(_pszWork+1);
    pus->Accept(*_pszWork);
    _pszWork = NextChar(_pszWork+1);
    pus->DisableMunging();
}

VOID URL::FeedFileServer(URL_STRING* pus)
{
    PCWSTR psz = NextChar(_pszWork);

    // pus->BackupFlags();
    while (*psz==SLASH || *psz==WHACK)
    {
        psz = NextChar(psz+1);
    }

    DWORD dwSlashes = (DWORD)(psz - _pszWork);
    switch (dwSlashes)
    {
    case 4:
        pus->AddFlagNote(URL_ESCAPE_PERCENT | URL_ESCAPE_UNSAFE);
        _dwSchemeNotes |= UPF_FILEISPATHURL;
     // 4 to 6 slashes == 1 UNC
    case 2:
        if (IsLocalDrive(psz))
        {
            pus->AddFlagNote(URL_ESCAPE_PERCENT | URL_ESCAPE_UNSAFE);
        }

    case 5:
    case 6:
        pus->Accept(SLASH);
        pus->Accept(SLASH);
         if (!IsLocalDrive(psz))
        {
            pus->EnableMunging();
            psz = FeedUntil(psz, pus, SLASH, WHACK);
            if (!*psz)
            {
                pus->TrimEndWhiteSpace();
                Reset();
            }
            else
            {
                _pszWork = NextChar(psz+1);
            }
        }
        else
        {
            _pszWork = psz;
        }
        pus->Accept(SLASH);
        break;

    // If there are no slashes, then it can't be a UNC.
    case 0:
        if (IsLocalDrive(psz))
        {
            pus->AddFlagNote(URL_ESCAPE_PERCENT | URL_ESCAPE_UNSAFE);
        }


    // We think of "file:/" and "file:///" to be on the local machine
    // And if there are more slashes than we typically handle, we'll treat them as 1.
    case 1:
    case 3:
    // This is a not-good-case
    default:
        pus->Accept(SLASH);
        pus->Accept(SLASH);
        pus->Accept(SLASH);
        _pszWork = NextChar(psz);
        break;
    }
}


VOID URL::FeedFtpServer(URL_STRING* pus)
{
    ASSERT(_pszWork);

    PCWSTR psz = NextChar(_pszWork);

    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }

    pus->EnableMunging();

    // The following is a grotesque and gruesome hack. We need to preserve case for
    // embedded username/password

    _pszWork = psz;

    BOOL fPossibleUserPasswordCombo = FALSE;
    while (*psz && *psz!=SLASH && *psz!=POUND && *psz!=QUERY)
    {
        if (*psz==L'@')
        {
            fPossibleUserPasswordCombo = TRUE;
            break;
        }
        psz = NextChar(psz+1);
    }

    psz = _pszWork;
    if (fPossibleUserPasswordCombo)
    {
        while (*psz!=L'@')
        {
            pus->Accept(*psz);
            psz = NextChar(psz+1);
        }
    }

    // This still leaves the issue of slashes, colons, ?s, @s, and #s in passwords; I guess they
    // ought to be escaped. (You just can't win, sometimes.)

    while (*psz && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND)
    {
        pus->Accept(SmallForm(*psz));
        psz = NextChar(psz+1);
    }

    if (*psz==COLON)
    {
        psz = FeedPort(psz, pus);
    }
    pus->DisableMunging();

    _pszWork = psz;
    if (!*psz)
    {
        pus->TrimEndWhiteSpace();
        pus->Accept(SLASH);
    }
    else
    {
        if (*psz==QUERY || *psz==POUND)
        {
            pus->Accept(SLASH);
        }
        else
        {
            pus->Accept(*psz);
            _pszWork = NextChar(psz+1);
        }
    }
}


VOID URL::FeedHttpServer(URL_STRING* pus)
{
// This is a version of FeedDefaultServer, stripped of non-essentials.
// This includes a hack to enable username/password combos in http urls.

    ASSERT(_pszWork);

    PCWSTR psz = NextChar(_pszWork);

    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }

    pus->EnableMunging();

    // WARNING! FeedPort also calls Mark(). Must be careful that they don't overlap.
    pus->Mark();
    PCWSTR pszRestart = psz;
    
    while (*psz && *psz!=WHACK && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND && *psz!=AT)
    {
        pus->Accept(SmallForm(*psz));
        psz = NextChar(psz+1);
    }

    if (*psz==COLON)
    {
        // We either have a port or a password. 
        PCWSTR pszPort = psz;
        do
        {
            psz = NextChar(psz+1);
        }
        while (*psz && *psz!=WHACK && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND && *psz!=AT);
        if (*psz!=AT)
        {
            psz = FeedPort(pszPort, pus);
        }
    }

    if (*psz==AT)
    {
        // We've hit a username/password combo. So we have to undo our case-changing 
        psz = pszRestart;
        pus->EraseMarkedText();
        while (*psz!=AT)
        {
            pus->Accept(*psz);
            psz = NextChar(psz+1);
        }

        // Now we carry on as before
        while (*psz && *psz!=WHACK && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND)
        {
            pus->Accept(SmallForm(*psz));
            psz = NextChar(psz+1);
        }
        if (*psz==COLON)
        {
            psz = FeedPort(psz, pus);
        }
    }

    pus->ClearMark();
    pus->DisableMunging();

    _pszWork = psz;
    if (!*psz)
    {
        pus->TrimEndWhiteSpace();
        if ((_eScheme!=URL_SCHEME_UNKNOWN) && !(_dwSchemeNotes & UPF_SCHEME_OPAQUE))
        {
            pus->Accept(SLASH);
        }
    }
    else
    {
        if (*psz==QUERY || *psz==POUND)
        {
            pus->Accept(SLASH);
        }
        else
        {
            pus->Accept(*psz);
            _pszWork = NextChar(psz+1);
        }
    }
}


VOID URL::FeedDefaultServer(URL_STRING* pus)
{
    ASSERT(_pszWork);

    PCWSTR psz = NextChar(_pszWork);
    if (!(_dwSchemeNotes & UPF_SCHEME_INTERNET))
    {
        pus->DisableSlashFixing();
    }

    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    if (_dwSchemeNotes & UPF_SCHEME_INTERNET)
    {
        pus->EnableMunging();

        while (*psz && *psz!=WHACK && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND)
        {
            pus->Accept(SmallForm(*psz));
            psz = NextChar(psz+1);
        }
        if (*psz==COLON)
        {
            psz = FeedPort(psz, pus);
        }
        pus->DisableMunging();
    }
    else
    {
        while (*psz && *psz!=SLASH)
        {
            pus->Accept(*psz);
            psz = NextChar(psz+1);
        }
    }
    _pszWork = psz;
    if (!*psz)
    {
        pus->TrimEndWhiteSpace();
        if ((_eScheme!=URL_SCHEME_UNKNOWN) && !(_dwSchemeNotes & UPF_SCHEME_OPAQUE))
        {
            pus->Accept(SLASH);
        }
    }
    else
    {
        if (*psz==QUERY || *psz==POUND)
        {
            pus->Accept(SLASH);
        }
        else
        {
            pus->Accept(*psz);
            _pszWork = NextChar(psz+1);
        }
    }
}

PCWSTR URL::FeedPort(PCWSTR psz, URL_STRING* pus)
{
    BOOL fIgnorePort = FALSE;
    pus->Mark();
    psz = FeedUntil(psz, pus, SLASH, WHACK, POUND, QUERY);

    if (!(_dwFlags & URL_DONT_SIMPLIFY))
    {
        // Here, decide whether or not to ignore the port
        //  FEATURE we should actually be getting this from
        //  the services file to find out the default protocol port
        //  but we dont think that most people will change them - zekel 17-Dec-96
        switch(_eScheme)
        {
        case URL_SCHEME_HTTP:
            if (pus->CompareMarkWith(L":80")==0)
                fIgnorePort = TRUE;
            break;

        case URL_SCHEME_HTTPS:
            if (pus->CompareMarkWith(L":443")==0)
                fIgnorePort = TRUE;
            break;

        case URL_SCHEME_FTP:
            if (pus->CompareMarkWith(L":21")==0)
                fIgnorePort = TRUE;
            break;

        case URL_SCHEME_GOPHER:
            if (pus->CompareMarkWith(L":70")==0)
                fIgnorePort = TRUE;
            break;
        }
    }
    if (fIgnorePort)
    {
        pus->EraseMarkedText();
    }
    else
    {
        pus->ClearMark();
    }
    return psz;
}

// -------------------------------------------------------------------------------

BOOL URL::DetectAbsolutePath()
{
    BOOL fResult = FALSE;
    if (_dwSchemeNotes & UPF_SCHEME_OPAQUE)
    {
        fResult = TRUE;
    }
    else if (DetectSymbols(SLASH, WHACK))
    {
        fResult = TRUE;
        _pszWork = NextChar(_pszWork+1);
    }
    return fResult;
}

BOOL URL::DetectPath()
{
    return (*NextChar(_pszWork) && !DetectSymbols(QUERY, POUND));
}

VOID URL::FeedPath(URL_STRING* pus, BOOL fMarkServer)
{
    ASSERT(_pszWork);
    PCWSTR psz = NextChar(_pszWork);
    if (fMarkServer)
    {
        pus->Mark();
    }
    if (_dwSchemeNotes & UPF_SCHEME_OPAQUE)
    {
        _pszWork = FeedUntil(psz, pus);
        pus->TrimEndWhiteSpace();
    }
    else
    {
        DWORD cDots;
        BOOL fContinue = TRUE;
        do
        {
            cDots = 0;
            PCWSTR pszTmp = psz;
            if (_fPathCompressionOn)
            {
                cDots = DetectDots(&psz);
            }

            if (cDots)
            {
                if (cDots==2)
                {
                    pus->Contract();
                }
                continue;
            }
            psz = CopySegment(pszTmp, pus, &fContinue);
        }
        while (fContinue);
        _pszWork = psz;
        if (!*_pszWork)
        {
            pus->TrimEndWhiteSpace();
        }
    }
}

// pfContinue indicates whether there's anything following that would
// be of relevance to a path
PCWSTR URL::CopySegment(PCWSTR psz, URL_STRING* pus, BOOL* pfContinue)
{
    ASSERT(pfContinue);
    BOOL fStop = FALSE;
    psz = NextChar(psz);
    while (!fStop)
    {
        switch (*psz)
        {
        case POUND:
            if (_eScheme==URL_SCHEME_FILE)
            {
                // Since #s are valid for dos paths, we have to accept them except
                // for when they follow a .htm/.html file (See FindFragmentA/W)
                 // However, some inconsistencies may still arise...
                for (DWORD i=0; i < ARRAYSIZE(ExtTable); i++)
                {
                    if (!pus->CompareLast(ExtTable[i].wszExt, ExtTable[i].cchExt))
                        break;
                }
                // If we haven't found a matching file extension, we'll treat as a filename character.
                if (i==ARRAYSIZE(ExtTable))
                {
                    pus->Accept(*psz);
                    psz = NextChar(psz+1);
                    break;
                }
            }
            goto next;

        case QUERY:
            // We're going to support query as a legitimate character in file urls.
            // *sigh*
             if (_eScheme==URL_SCHEME_FILE)
            {
                if (_fIgnoreQuery)
                {
                    psz = wszBogus;
                }
                else
                {
                    pus->CleanAccept(*psz);
                    psz = NextChar(psz+1);
                    break;
                }
            }
        case L'\0':
        next:
            *pfContinue = FALSE;
            fStop = TRUE;
            break;

        case SLASH:
        case WHACK:
            fStop = TRUE;
            // fall through

        default:
            pus->Accept(*psz);
            psz = NextChar(psz+1);
            break;
        }
    }
    return psz;
}

DWORD URL::DetectDots(PCWSTR* ppsz)
{
    PCWSTR psz;
    if (ppsz)
    {
        psz = *ppsz;
    }
    else
    {
        psz = NextChar(_pszWork);
    }

    DWORD cDots = 0;
    if (*psz==DOT)
    {
        psz = NextChar(psz+1);
        cDots++;
        if (*psz==DOT)
        {
            psz = NextChar(psz+1);
            cDots++;
        }
        switch (*psz)
        {
        case WHACK:
            if (_eScheme==URL_SCHEME_MK)
            {
                cDots = 0;
            }

        case SLASH:
            psz = NextChar(psz+1);
            break;

        case QUERY:
        case POUND:
        case L'\0':
            break;
         default:
            cDots = 0;
            break;
        }
    }
    if (ppsz)
    {
        *ppsz = psz;
    }
    return cDots;
}

VOID URL::StopPathCompression()
{
    _fPathCompressionOn = FALSE;
}


// -------------------------------------------------------------------------------

BOOL URL::DetectQueryOrFragment()
{
    return (DetectSymbols(QUERY, POUND));
}

BOOL URL::DetectQuery()
{
    return (DetectSymbols(QUERY));
}

VOID URL::IgnoreQuery()
{
    ASSERT(_eScheme==URL_SCHEME_FILE);
    _fIgnoreQuery = TRUE;
}

VOID URL::FeedQueryAndFragment(URL_STRING* pus)
{
    ASSERT(_pszWork);
    if (_dwSchemeNotes & UPF_SCHEME_OPAQUE)
    {
        PCWSTR psz = NextChar(_pszWork);
        while (*psz)
        {
            pus->Accept(*psz);
            psz = NextChar(psz+1);
        }
        _pszWork = psz;
        return;
    }

    PCWSTR psz = NextChar(_pszWork);

    // This is okay since *psz must equal { ? | # }
    if (*psz==QUERY)
    {
        pus->CleanAccept(QUERY);
    }

    // By munging, I mean taking an URL of form http://a/b#c?d and producing http://a/b?d#c
    // We do this by default; however, we won't do this when we've been passed a fragment only
    // as a relative url

    // Query's always override.

    if (*psz==QUERY)
    {
        pus->DropQuery();
        pus->NotifyQuery();
        pus->EnableMunging();

        psz = NextChar(psz+1);
        while (*psz)
        {
            if (*psz==POUND)
            {
                pus->NotifyFragment();
            }
            else
            {
                pus->Accept(*psz);
            }
            psz = NextChar(psz+1);
        }
    }
    else
    {
        // This line of code will determine whether we've been passed a fragment for a relative url
        // For properly formed base urls, this won't matter.
        BOOL fMunge = psz!=NextChar(_pszUrl);

        pus->DropFragment();
        pus->NotifyFragment();
        pus->EnableMunging();

        psz = NextChar(psz+1);

        // The following line is bogus. It just keeps going until the end. Not good.
        // We MAY or MAY NOT fix this, depending on how much people scream at me.
        // This may be an issue for Netscape compatibility.

        // What we could do is: when either query or fragment would be blank, preserve as is.
        // This would minimise breaking compatibility across the board.
        // -- AKABIR, 09/28/98
        while ((*psz==QUERY && !fMunge) || *psz)
        {
            if (*psz==QUERY)
            {
                pus->CleanAccept(QUERY);
            }
            else
            {
                pus->Accept(*psz);
            }
            psz = NextChar(psz+1);
        }

        if (*psz==QUERY)
        {
            pus->DropFragment();
            pus->NotifyQuery();
            pus->CleanAccept(*psz);
            psz = NextChar(psz+1);
            while (*psz)
            {
                pus->Accept(*psz);
                psz = NextChar(psz+1);
            }
            pus->TrimEndWhiteSpace();

            pus->NotifyFragment();
            psz = NextChar(_pszWork);
            pus->CleanAccept(*psz);
            psz = NextChar(psz+1);
            while (*psz!=QUERY)
            {
                pus->Accept(*psz);
                psz = NextChar(psz+1);
            }
        }
    }
    pus->TrimEndWhiteSpace();
    pus->ClearMark();
}

// -------------------------------------------------------------------------------

HRESULT
BlendUrls(URL& urlBase, URL& urlRelative, URL_STRING* pusOut, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    // -- SCHEME --------------------------------------------------------------------------
    // Examine each url's scheme.
    // We won't continue to use urlBase IF
    // 1. their tokenized schemes are not identical
    // 2. the scheme is a file
    // 3. the actual string schemes are not identical

    //  this checks to make sure that these are the same scheme, and
    //  that the scheme is allowed to be used in relative URLs
    //  file: is not allowed to because of weirdness with drive letters
    //  and \\UNC\shares

    BOOL fBaseServerDetected = FALSE, fRelativeServerDetected = FALSE;
    BOOL fDetectAbsoluteRelPath = FALSE;
    BOOL fDetectedRelScheme = urlRelative.DetectAndFeedScheme(pusOut);
    BOOL fDetectedBaseScheme = FALSE;
    if (fDetectedRelScheme
        && ((pusOut->QueryScheme()==URL_SCHEME_FILE)
           || (urlRelative.GetSchemeNotes() & UPF_SCHEME_OPAQUE)))
    {
        urlBase.Reset();
    }
    else if ((fDetectedBaseScheme = urlBase.DetectAndFeedScheme(pusOut, fDetectedRelScheme)))
    {
        if (!fDetectedRelScheme)
        {
            urlRelative.SetScheme(urlBase.GetScheme(), urlBase.GetSchemeNotes());
        }
    }

    // We fall back on the original parser for those cases we don't handle yet.
    // (dwFlags & URL_FILE_USE_PATHURL) || (dwFlags & URL_WININET_COMPATIBILITY)
    if (((pusOut->QueryScheme()==URL_SCHEME_FILE)
         || (!(fDetectedRelScheme || fDetectedBaseScheme)))
        && ((dwFlags & URL_FILE_USE_PATHURL) || (dwFlags & URL_WININET_COMPATIBILITY)))
    {
        hr = E_FAIL;
        goto exit;
    }


    if ((pusOut->QueryScheme()==URL_SCHEME_UNKNOWN))
    {
        // BUG BUG For IE4 compat, we need to use the old parser. However
        // if we're passed URL_PLUGGABLE_PROTOCOL, we'll use this parser.

        if (!(dwFlags & URL_PLUGGABLE_PROTOCOL))
        {
            hr = E_FAIL;
            goto exit;
        }

        urlRelative.StopPathCompression();

            // Same schemes, so now we look at the base url to divine the opacity
        if (urlBase.DetectAnything() && !urlBase.IsReset())
        {
            if (!urlBase.DetectSlash())
            {
                if (!urlRelative.DetectQueryOrFragment())
                {
                    urlBase.Reset();
                }
                urlBase.AddSchemeNote(UPF_SCHEME_OPAQUE);
                urlRelative.AddSchemeNote(UPF_SCHEME_OPAQUE);
                pusOut->AddSchemeNote(UPF_SCHEME_OPAQUE);
            }
        }
        else if (!urlRelative.DetectSlash())
        {
            // If urlBase is reset, that means the schemes are different,
            // so we only have urlRelative to figure out opacity.

            urlRelative.AddSchemeNote(UPF_SCHEME_OPAQUE);
            pusOut->AddSchemeNote(UPF_SCHEME_OPAQUE);
        }
    }
    else if (pusOut->QueryScheme()==URL_SCHEME_FTP)
    {
        // For ftp urls, we'll assume that we're being passed properly formed urls.
        // Some ftp sites allow backslashes in their object filenames, so we should
        // allow access to these. Also, domain passwords would otherwise need escaping.
        pusOut->DisableSlashFixing();
    }

    if (dwFlags & URL_DONT_SIMPLIFY)
    {
        urlBase.StopPathCompression();
        urlRelative.StopPathCompression();
    }

    // -- SERVER --------------------------------------------------------------------------
    // Decide on the server to use.
    // Question: if urlBase and UrlRelative have the same explicit server, isn't it pointless
    // to continue looking at url base anyway?

    pusOut->EnableMunging();
    if (!(pusOut->GetSchemeNotes() & UPF_SCHEME_OPAQUE))
    {
        if (urlRelative.DetectServer()
            && !(urlBase.DetectServer() && (urlRelative.PeekNext()!=SLASH) && (urlRelative.PeekNext()!=WHACK)))
        {
            fRelativeServerDetected = TRUE;
            urlRelative.FeedServer(pusOut);
            urlBase.Reset();
        }
        else if (urlBase.DetectServer())
        {
            fBaseServerDetected = TRUE;
            urlBase.FeedServer(pusOut);
        }
    }

    // -- PATH ----------------------------------------------------------------------------
    // Figure out the path
    // If the relative url has a path, and it starts with a slash/whack, forget about the
    // base's path and stuff. Otherwise, inherit the base and attach the relative
    // Potential problem: when rel path is empty, we expect to knock of the last base segment

    if (pusOut->QueryScheme()==URL_SCHEME_FILE)
    {
        // Hack for back compat
        // If the relative url consists of a query string, we'll append that to
        // our resultant url, rather than the base's query string
        if (urlRelative.DetectQuery())
        {
            urlBase.IgnoreQuery();
        }
        else
        {

            BOOL fResult1 = urlRelative.DetectAbsolutePath();
            BOOL fResult2 = urlRelative.DetectLocalDrive();

            if (fResult2)
            {
                urlBase.Reset();
                urlRelative.FeedLocalDrive(pusOut);
                if (urlRelative.DetectAbsolutePath())
                {
                    pusOut->Accept(SLASH);
                }
            }
            else
            {
                if (urlBase.DetectLocalDrive())
                {
                    urlBase.FeedLocalDrive(pusOut);
                    if (fResult1)
                    {
                        pusOut->Accept(SLASH);
                        urlBase.Reset();
                    }
                    else if (urlBase.DetectAbsolutePath())
                    {
                        pusOut->Accept(SLASH);
                    }
                }
                else if (fResult1)
                {
                    if (fRelativeServerDetected)
                    {
                        pusOut->Accept(SLASH);
                    }
                    urlBase.Reset();
                }
            }
        }
    }
    else if (pusOut->QueryScheme()==URL_SCHEME_UNKNOWN)
    {
        if (pusOut->GetSchemeNotes() & UPF_SCHEME_OPAQUE)
        {
            if (!urlRelative.DetectAnything())
            {
                urlRelative.Reset();
            }
        }
        else
        {
        // This code fragment is for urls with unknown schemes, that are to be
        // treated hierarchically. Note that the authority (which has been passed in
        // already) is terminated with /, ?, or \0. The / is *optional*, and should be
        // appended if and only if the urls being combined call for it.
            if (urlBase.IsReset())
            {
            // At this point, we're examining only the relative url. We've been brought to
            // a stop by the presence of /, ? or \0. So
                if (urlRelative.DetectSlash() && !fDetectedRelScheme)
                {
                    pusOut->Accept(SLASH);
                }
            }
            else
            {
            // In this case, we have both the relative and base urls to look at.
            // What's the terminator for the base url
                if ((urlRelative.DetectSlash()
                        || (!urlBase.DetectAnything()
                           && urlRelative.DetectAnything()
                           && !urlRelative.DetectQuery()))
                    && !fDetectedRelScheme)
                {
                    pusOut->Accept(SLASH);
                }
            }
        }
    }

    pusOut->EnableMunging();

    if ((fBaseServerDetected && (fDetectAbsoluteRelPath = urlRelative.DetectAbsolutePath())))
    {
        if (!fRelativeServerDetected)
        {
            pusOut->RestoreFlags();
        }
        if (fDetectAbsoluteRelPath && urlRelative.DetectDots(NULL))
        {
            urlRelative.StopPathCompression();
        }
        urlRelative.FeedPath(pusOut);
        urlBase.Reset();
    }
    else if (urlBase.DetectPath())
    {
        urlBase.FeedPath(pusOut);
        // We don't want to contract the base path's free segment if
        // a. the scheme is opaque
        // b. the relative url has a path
        // c. the relative url has no path, just a fragment/query
        if (!(urlBase.GetSchemeNotes() & UPF_SCHEME_OPAQUE))
        {
            pusOut->RestoreFlags();

            if (urlRelative.DetectPath()
               || !urlRelative.DetectQueryOrFragment())
            {
                if (urlRelative.DetectPath() || !fDetectedRelScheme)
                {
                    pusOut->Contract(FALSE);
                }
                if (fDetectedRelScheme)
                {
                    urlRelative.StopPathCompression();
                }
                urlRelative.FeedPath(pusOut, FALSE);
                urlBase.Reset();
            }
            else
            {
                urlRelative.FeedPath(pusOut, FALSE);
            }
        }
        else
        {
            urlRelative.StopPathCompression();
            urlRelative.FeedPath(pusOut, FALSE);
        }
    }
    else if (urlRelative.DetectPath())
    {
        if (!fRelativeServerDetected)
        {
            pusOut->RestoreFlags();
        }
        else if (urlRelative.DetectDots(NULL))
        {
            urlRelative.StopPathCompression();
        }
        urlRelative.FeedPath(pusOut);
        urlBase.Reset();
    }
    pusOut->ClearMark();

    pusOut->DisableSlashFixing();
    // -- QUERY AND FRAGMENT -----------------------------------------------------------
    // Figure out the query
    if (urlBase.DetectQueryOrFragment())
    {
        urlBase.FeedQueryAndFragment(pusOut);
    }
    if (urlRelative.DetectQueryOrFragment())
    {
        urlRelative.FeedQueryAndFragment(pusOut);
    }
    pusOut->CleanAccept(L'\0');

    if (pusOut->AnyProblems())
    {
        hr = E_OUTOFMEMORY;
    }
exit:
    return hr;
}


HRESULT
FormUrlCombineResultW(LPCWSTR pszBase,
           LPCWSTR pszRelative,
           LPWSTR pszCombined,
           LPDWORD pcchCombined,
           DWORD dwFlags)
{
    if ((dwFlags & URL_ESCAPE_UNSAFE)
        && (dwFlags & URL_ESCAPE_SPACES_ONLY))
    {
    // In the original parser, ESCAPE_SPACES_ONLY takes precedence over ESCAPE_UNSAFE
    // Deactivate UNSAFE
        dwFlags ^= URL_ESCAPE_UNSAFE;
    }

    DWORD dwTempFlags = dwFlags;
    if (dwFlags & URL_UNESCAPE)
    {
        if (dwFlags & URL_ESCAPE_UNSAFE)
        {
            dwTempFlags ^= URL_ESCAPE_UNSAFE;
        }
        if (dwFlags & URL_ESCAPE_SPACES_ONLY)
        {
            dwTempFlags ^= URL_ESCAPE_SPACES_ONLY;
        }
    }

    // Make a copy of the relative url if the client wants to either
    // a. unescape and escape the URL (since roundtripping is not guaranteed), or
    // b. use the same location for relative URL's buffer for the combined url
    HRESULT hr;
    URL curlBase, curlRelative;
    curlBase.Setup((PWSTR)pszBase);
    curlRelative.Setup((PWSTR)pszRelative);
    URL_STRING us(dwTempFlags);

    hr = BlendUrls(curlBase, curlRelative, &us, dwTempFlags);

    if (SUCCEEDED(hr))
    {
        DWORD ccBuffer = us.GetTotalLength();
        if ((dwFlags & URL_UNESCAPE)
            && (dwFlags & (URL_ESCAPE_UNSAFE | URL_ESCAPE_SPACES_ONLY)))
        {
            // No need to strip out URL_UNESCAPE
            hr = UrlEscapeW(us.GetStart(), pszCombined, pcchCombined, dwFlags);
            goto exit;
        }
        if (ccBuffer > *pcchCombined)
        {
            hr = E_POINTER;
        }
        else if (pszCombined)
        {
            memcpy(pszCombined, us.GetStart(), ccBuffer*sizeof(WCHAR));
            // We return only the number of characters, not buffer size required.
            ccBuffer--;
        }
        *pcchCombined = ccBuffer;
    }
    else if (hr==E_FAIL)
    {
//        ASSERT(((dwFlags & URL_FILE_USE_PATHURL) || (dwFlags & URL_WININET_COMPATIBILITY)));

        // We fall back on the original parser for those cases we don't handle yet.
        // We should do this if and only if the new parser
        // doesn't handle the flags cited above
        // or we're passed a pluggable protocol without the forcing flag.
        SHSTRW strwOut;
        hr = SHUrlParse(pszBase, pszRelative, &strwOut, dwFlags);
        if(SUCCEEDED(hr))
        {
            hr = ReconcileHresults(hr, CopyOutW(&strwOut, pszCombined, pcchCombined));
        }
    }

exit:
    return hr;
}

HRESULT
FormUrlCombineResultA(LPCSTR pszBase,
           LPCSTR pszRelative,
           LPSTR pszCombined,
           LPDWORD pcchCombined,
           DWORD dwFlags)
{
    if ((dwFlags & URL_ESCAPE_UNSAFE)
        &&
        (dwFlags & URL_ESCAPE_SPACES_ONLY))
    {
    // In the original parser, ESCAPE_SPACES_ONLY takes precedence over ESCAPE_UNSAFE
    // Deactivate UNSAFE
        dwFlags ^= URL_ESCAPE_UNSAFE;
    }

    // Make a copy of the relative url if the client wants to either
    // a. unescape and escape the URL (since roundtripping is not guaranteed), or
    // b. use the same location for relative URL's buffer for the combined url
    SHSTRW strwBase;
    SHSTRW strwRelative;
    HRESULT hr;

    if (!(SUCCEEDED(strwBase.SetStr(pszBase)) && SUCCEEDED(strwRelative.SetStr(pszRelative))))
    {
        return E_OUTOFMEMORY;
    }

    DWORD dwTempFlags = dwFlags;
    if (dwFlags & URL_UNESCAPE)
    {
        if (dwFlags & URL_ESCAPE_UNSAFE)
        {
            dwTempFlags ^= URL_ESCAPE_UNSAFE;
        }
        if (dwFlags & URL_ESCAPE_SPACES_ONLY)
        {
            dwTempFlags ^= URL_ESCAPE_SPACES_ONLY;
        }
    }

    URL curlBase, curlRelative;
    curlBase.Setup(strwBase);
    curlRelative.Setup(strwRelative);
    URL_STRING us(dwTempFlags);

    hr = BlendUrls(curlBase, curlRelative, &us, dwTempFlags);

    if (SUCCEEDED(hr))
    {
        SHSTRA straOut;
        if ((dwFlags & URL_UNESCAPE)
            && (dwFlags & (URL_ESCAPE_UNSAFE | URL_ESCAPE_SPACES_ONLY)))
        {
            SHSTRW strwTemp;
            // No need to strip out URL_UNESCAPE
            hr = SHUrlEscape(us.GetStart(), &strwTemp, dwFlags);
            hr = ReconcileHresults(hr, straOut.SetStr(strwTemp));
        }
        else
        {
            hr = straOut.SetStr(us.GetStart());
        }
        if (SUCCEEDED(hr))
        {
            hr = CopyOutA(&straOut, pszCombined, pcchCombined);
        }
    }
    else if (hr==E_FAIL)
    {
//        ASSERT(((dwFlags & URL_FILE_USE_PATHURL) || (dwFlags & URL_WININET_COMPATIBILITY)));

        // We fall back on the original parser for those cases we don't handle yet.
        // We should do this if and only if the new parser
        // doesn't handle the flags cited above
        SHSTRW strwOut;

        hr = SHUrlParse(strwBase, strwRelative, &strwOut, dwFlags);
        if (SUCCEEDED(hr))
        {
            SHSTRA straOut;
            hr = ReconcileHresults(hr, straOut.SetStr(strwOut));
            if(SUCCEEDED(hr))
                hr = ReconcileHresults(hr, CopyOutA(&straOut, pszCombined, pcchCombined));
        }
    }

    return hr;
}


#ifdef PROOFREAD_PARSES

EXTERN_C DWORD g_dwProofMode;

enum
{
    PP_COMPARE,
    PP_ORIGINAL_ONLY,
    PP_NEW_ONLY
};

//#define SHOW_MESSAGEBOX

VOID LogData(PWSTR pszMsg)
{
    SHSTRA str;
    str.SetStr(pszMsg);
    CHAR szFileName[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    CHAR szComputerName[MAX_PATH];
    HANDLE hResultsFile = NULL;
    strcpy(szFileName, "\\\\BANYAN\\IPTD\\AKABIR\\1315\\");
    if (!GetComputerNameA(szComputerName, &dwSize))
    {
        goto exit;
    }
    lstrcatA(szFileName, szComputerName);
    hResultsFile = CreateFileA( szFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        0,
                        NULL);
    if (INVALID_HANDLE_VALUE == hResultsFile)
        hResultsFile = NULL;
    if (hResultsFile)
    {
        if (SetFilePointer(hResultsFile, 0, NULL, FILE_END)==0xFFFFFFFF)
        {
            goto exit;
        }
        DWORD dwFoo;
        if (0==WriteFile(hResultsFile, (PVOID)(PSTR)str, lstrlenW(pszMsg), &dwFoo, NULL))
        {
            DWORD dwE = GetLastError();
        }
    }
exit:
    if (hResultsFile)
    {
        CloseHandle(hResultsFile);
    }
}

HRESULT ProofreadParses(HRESULT hr,
           LPCWSTR pszBase,
           LPCWSTR pszRelative,
           LPWSTR pszCombined,
           PDWORD pcchCombined,
           DWORD dwFlags,
           DWORD dwSize
           )
{
    static WCHAR szLast[2084];
    SHSTRW strwOut;

switch(g_dwProofMode)
{
case PP_COMPARE:
    {
    HRESULT hr2 = SHUrlParse(pszBase, pszRelative, &strwOut, dwFlags);
    WCHAR wstr[2084];
    DWORD ccLen = min(2084, dwSize), ccUrl = SUCCEEDED(hr) ? *pcchCombined : 0;
    if(SUCCEEDED(hr2))
    {
        hr2 = CopyOutW(&strwOut, wstr, &ccLen);
        if (hr2 == E_POINTER && hr == E_POINTER)
        {
            goto exitpoint;
        }
        // Check if cached combine equals the new parser's result
        if (!StrCmpW(pszCombined, szLast))
        {
            goto exitpoint;
        }
        // Check if cached combine equals the old parser's result
        if (!StrCmpW(wstr, szLast))
        {
            *pcchCombined = ccLen;
            StrCpyNW(pszCombined, wstr, ccLen + 1);
            hr = hr2;
            goto exitpoint;
        }
        if (SUCCEEDED(hr))
        {
            StrCpyNW(szLast, wstr, ccLen);

            if (!StrCmpW(wstr, pszCombined))
            {
                goto exitpoint;
            }

            DWORD dwBogus;
            if ((dwFlags & URL_ESCAPE_SPACES_ONLY) && !(dwFlags & URL_UNESCAPE))
            {
                PCWSTR psz = FindSchemeW(pszCombined, &dwBogus);
                DWORD dw;
                if (psz
                    &&
                    (URL_SCHEME_UNKNOWN
                        !=GetSchemeTypeAndFlagsW(psz, dwBogus, &dw))
                    &&
                    (dw & UPF_SCHEME_OPAQUE))
                {
                    goto exitpoint;
                }
            }

            // Filter
            // base: "http://foo/bar/"
            // rel:  ""
            // old:  "http://foo/bar"
            // new:  "http://foo/bar/"
            if ((*pszRelative==L'\0')
                &&
                (!StrCmpNW(pszCombined, wstr, ccLen))
                &&
                (ccUrl==(ccLen+1))
                &&
                (pszCombined[ccLen]==L'/'))
            {
                goto exitpoint;
            }

            // Filter
            // base: "http://foo/bar/what?ho"
            // rel:  ""
            // old:  "http://foo/bar/?ho"
            // new:  "http://foo/bar/"
            if ((*pszRelative==L'\0')
                &&
                (!StrCmpNW(pszCombined, wstr, ccUrl))
                &&
                (wstr[ccUrl]==QUERY))
            {
                goto exitpoint;
            }

            // Filter
            // base: "http://foo/bar/what?ho"
            // rel:  "/"
            // old:  "http://foo"
            // new:  "http://foo/"
            if ((*pszRelative==L'/')
                &&
                (!StrCmpNW(pszCombined, wstr, ccLen))
                &&
                (ccUrl==(ccLen+1))
                &&
                (pszCombined[ccLen]==L'/'))
            {
                goto exitpoint;
            }

            WCHAR wmsg[8192];
            wnsprintfW(wmsg,
                    ARRAYSIZE(wmsg),
                    L"Flags:%#x\nBase:\"%s\"\nRelative:\"%s\"\nOriginal result:\"%s\"\nNew result:\"%s\"\nUse original, not new, result?\n",
                    dwFlags,
                    pszBase,
                    pszRelative,
                    wstr,
                    pszCombined
                    );
#ifdef SHOW_MESSAGEBOX
            if (IDYES==MessageBoxW(
                NULL,
                wmsg,
                L"CONTACT AKABIR: URLCOMBINE FAILURE",
                MB_YESNO | MB_ICONERROR | MB_TASKMODAL))
            {
                StrCpyNW(pszCombined, wstr, dwSize);
                *pcchCombined = ccLen;
            }
            else
            {
                StrCpyNW(szLast, pszCombined, *pcchCombined);
            }
#endif
            LogData(wmsg);
        }
        else
        {
            WCHAR wmsg[8192];
            wnsprintfW(wmsg,
                    ARRAYSIZE(wmsg),
                    L"Flags:%#x\nBase:\"%s\"\nRelative:\"%s\"\nFAILED:%#x\nExpected:\"%s\"\n",
                    dwFlags,
                    pszBase,
                    pszRelative,
                    hr,
                    wstr);
#ifdef SHOW_MESSAGEBOX
            MessageBoxW(
                NULL,
                wmsg,
                L"CONTACT AKABIR: URLCOMBINE FAILURE",
                MB_OK | MB_ICONERROR | MB_TASKMODAL);
#endif
            StrCpyNW(pszCombined, wstr, dwSize);
            *pcchCombined = ccLen;
            LogData(wmsg);
        }
        hr = hr2;
    }
    }
    break;

case PP_NEW_ONLY:
    break;

case PP_ORIGINAL_ONLY:
    {
    hr = SHUrlParse(pszBase, pszRelative, &strwOut, dwFlags);
    if(SUCCEEDED(hr))
    {
        hr = CopyOutW(&strwOut, pszCombined, pcchCombined);
    }
    }
    break;
    }

exitpoint:
    return hr;
}

#endif //PROOFREAD_PARSES

LWSTDAPI
UrlCombineW(LPCWSTR pszBase,
           LPCWSTR pszRelative,
           LPWSTR pszCombined,
           LPDWORD pcchCombined,
           DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if (pszBase && pszRelative && pcchCombined)
    {
        RIP(IS_VALID_STRING_PTRW(pszBase, INTERNET_MAX_PATH_LENGTH));
        RIP(IS_VALID_STRING_PTRW(pszRelative, INTERNET_MAX_PATH_LENGTH));
        RIP(IS_VALID_WRITE_PTR(pcchCombined, DWORD));
        RIP((!pszCombined || IS_VALID_WRITE_BUFFER(pszCombined, WCHAR, *pcchCombined)));

#ifdef PROOFREAD_PARSES
        DWORD dwSize = *pcchCombined;
#endif

        hr = FormUrlCombineResultW(pszBase, pszRelative, pszCombined, pcchCombined, dwFlags);

#ifdef PROOFREAD_PARSES
        hr = ProofreadParses(hr, pszBase, pszRelative, pszCombined, pcchCombined, dwFlags, dwSize);
#endif
    }
    return hr;
}

LWSTDAPI
UrlCombineA(LPCSTR pszBase,
           LPCSTR pszRelative,
           LPSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;

    if (!pszBase
        || !pszRelative
        || !pcchOut)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        RIP(IS_VALID_STRING_PTRA(pszBase, INTERNET_MAX_PATH_LENGTH));
        RIP(IS_VALID_STRING_PTRA(pszRelative, INTERNET_MAX_PATH_LENGTH));
        RIP(IS_VALID_WRITE_PTR(pcchOut, DWORD));
        RIP((!pszOut || IS_VALID_WRITE_BUFFER(pszOut, CHAR, *pcchOut)));

        hr = FormUrlCombineResultA(pszBase, pszRelative, pszOut, pcchOut, dwFlags);
    }

    return hr;
}

#else // end USE_FAST_PARSER

LWSTDAPI
UrlCombineW(LPCWSTR pszBase,
           LPCWSTR pszRelative,
           LPWSTR pszCombined,
           LPDWORD pcchCombined,
           DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    RIPMSG(pszBase && IS_VALID_STRING_PTRW(pszBase, -1), "UrlCombineW: Caller passed invalid pszBase");
    RIPMSG(pszRelative && IS_VALID_STRING_PTRW(pszRelative, -1), "UrlCombineW: Caller passed invalid pszRelative");
    RIPMSG(NULL!=pcchOut, "UrlCombineW: Caller passed invalid pcchOut");
    RIPMSG(NULL==pcchOut || (pszOut && IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlCombineW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut == pszBase || pszOut == pszRelative)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (pszBase && pszRelative && pcchCombined)
    {
        SHSTRW strwOut;
        hr = SHUrlParse(pszBase, pszRelative, &strwOut, dwFlags);
        if(SUCCEEDED(hr))
        {
            hr = CopyOutW(&strwOut, pszCombined, pcchCombined);
        }
    }
    return hr;
}

LWSTDAPI
UrlCombineA(LPCSTR pszBase,
           LPCSTR pszRelative,
           LPSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszBase && IS_VALID_STRING_PTRA(pszBase, -1), "UrlCombineA: Caller passed invalid pszBase");
    RIPMSG(pszRelative && IS_VALID_STRING_PTRA(pszRelative, -1), "UrlCombineA: Caller passed invalid pszRelative");
    RIPMSG(NULL!=pcchOut, "UrlCombineA: Caller passed invalid pcchOut");
    RIPMSG(NULL==pcchOut || (pszOut && IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlCombineA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut == pszBase || pszOut == pszRelative)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszBase || !pszRelative || !pcchOut)
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwBase;
        SHSTRW strwRelative;

        if(SUCCEEDED(strwBase.SetStr(pszBase)) && SUCCEEDED(strwRelative.SetStr(pszRelative)))
            hr = SHUrlParse((LPWSTR) strwBase, (LPWSTR)strwRelative, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
            hr = straOut.SetStr(strwOut);
    }

    if(SUCCEEDED(hr) )
        hr = CopyOutA(&straOut, pszOut, pcchOut);

    return hr;
}

#endif // !USE_FAST_PARSER


//
// Combines the desired scheme with the string after the scheme with a : in between.  For
// some protocols, a // is placed after the colon.
//

PRIVATE HRESULT ColonSlashSlashW
(
    LPCWSTR pszScheme,       // url protocol (lower-case)
    LPCWSTR pszAfterScheme,  // string to append after the protocol
    LPWSTR pszTranslatedUrl, // output buffer
    int cchMax               // size of output buffer
)
{
    StrCpyNW(pszTranslatedUrl, pszScheme, cchMax);

    // Append : after scheme and possibly a // as well.
    int cchScheme = lstrlenW(pszScheme);
    if (cchMax > cchScheme + 3)
    {
        pszTranslatedUrl[cchScheme] = L':';

        // Number of characters to skip over in the buffer (how many non alphanums originally
        // followed the protocol)
        int cchSkip = 0;

        // Number of characters past the protocol: to skip over in the URL (Do we insert slashes?)
        int cchSlashes = 0;


        // Modify this conditional to include any other protocols to always follow with ://
        // Right now, http, https and ftp are automatic
        if (!StrCmpW(pszScheme, L"http") || !StrCmpW(pszScheme, L"ftp") || !StrCmpW(pszScheme, L"https") )
        {
            //
            // When preparing to copy the contents of pszAfterScheme into pszUrl, we can
            // skip over as many as 3 non alpha numeric characters, since we are adding ://
            // to the protocol directly
            //
            while ((cchSkip < 3) && pszAfterScheme[cchSkip] && !IsCharAlphaNumericW(pszAfterScheme[cchSkip]))
            {
                cchSkip++;
            }
            pszTranslatedUrl[cchScheme+1] = L'/';
            pszTranslatedUrl[cchScheme+2] = L'/';
            pszTranslatedUrl[cchScheme+3] = L'\0';
            cchSlashes = 2;
        }
        else
        // some other protocol
        {
            // just skip over colon
            cchSkip = 1;
            pszTranslatedUrl[cchScheme+1] = L'\0';

        }

        // Copy the rest of the Url from the UrlBuffer into the Url
        StrCatBuffW(pszTranslatedUrl, pszAfterScheme + cchSkip, cchMax);
    }

    return S_OK;
}

//
// Scans the url for a scheme and if it does not match the known schemes, then
// a closest match is found.
//
LWSTDAPI
UrlFixupW
(
    LPCWSTR pcszUrl,         // URL to correct
    LPWSTR pszTranslatedUrl, // buffer for corrected url (can be same as pcszUrl)
    DWORD cchMax             // size of pszTranslatedUrl
    )
{
    HRESULT hr = S_OK;

    //
    // Find the scheme
    //
    WCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    ULONG cchScheme = 0;
    LPCWSTR pszScheme = FindSchemeW(pcszUrl, &cchScheme, TRUE);
    if (NULL == pszScheme || cchScheme > (ARRAYSIZE(szScheme)-1))
    {
        // No scheme found
        return S_FALSE;
    }

    for (ULONG cch=0; cch < cchScheme; ++cch, ++pszScheme)
    {
        szScheme[cch] = Ascii_ToLowerW(*pszScheme);
    }
    szScheme[cch] = L'\0';
    LPCWSTR pszAfterScheme = pszScheme;

    //
    // If input and output buffers are the same, copy the stuff after the scheme
    // to another buffer so it doesn't get clobbered when we recombine.
    //
    WCHAR szBuf[INTERNET_MAX_PATH_LENGTH];
    if (pcszUrl == pszTranslatedUrl)
    {
        StrCpyNW(szBuf, pszAfterScheme, ARRAYSIZE(szBuf));
        pszAfterScheme = szBuf;
    }

    //
    // See if it matches any of our known schemes
    //
    BOOL fKnownScheme = FALSE;
    for (ULONG i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); ++i)
    {
        if (StrCmpW(szScheme, g_mpUrlSchemeTypes[i].pszScheme) == 0)
        {
            fKnownScheme = TRUE;
            break;
        }
    }

    //
    // If it matches a known scheme, then just fix :// if it's ftp or http
    //
    if (fKnownScheme ||

        // Check for pluggable protocols too
        NO_ERROR == SHGetValueW(HKEY_CLASSES_ROOT, szScheme, L"URL Protocol",
                               NULL, NULL, NULL))
    {
        ColonSlashSlashW(szScheme, pszAfterScheme, pszTranslatedUrl, cchMax);
        return S_OK;
    }

    //
    // Try to find a good match for the mispelled scheme
    //

    // These are weights used in the heuristic for the protocol matching
    // iFloor is roughly the minimum percentage of characters that must match in
    // order to make a change
    const int cFloor = 60;

    // A match in the first character has the greatest weight
    const int cCorrectFirstChar = 150;

    // Any other matched character
    const int cCorrectChar = 100;

    // The weight given to a character that only matches the preceding
    // or subsequent character in the protocol
    const int cOffByOneChar = 80;

    // We penalize characters that are off by one, but if we have already
    // observed the offset and subsequent characters continue the offset, we add this
    const int cOffsetBonus = 20;

    // The value of the best "match" found so far. Higher is a better match.
    int iBestEval = 0;

    // The protocol that's the best fit for the misspelled one
    LPCWSTR pszBestMatch = NULL;

    ULONG cchProt;
    for (ULONG j = 0; j < ARRAYSIZE(g_mpUrlSchemeTypes); ++j)
    {
        // Is this one we don't correct to?
        //
        // Note:  https is removed from this list.  The potential for an intended "http" to
        // be corrected to "https" is too high, and "http" is far more common.  All this
        // means is that if someone wants to get to an https site, they have to have it right.
        //
        if (IsFlagSet(g_mpUrlSchemeTypes[j].dwFlags, UPF_SCHEME_DONTCORRECT))
            continue;

        LPCWSTR pszProtocol = g_mpUrlSchemeTypes[j].pszScheme;
        cchProt = g_mpUrlSchemeTypes[j].cchScheme;

        // Evaluation of the fit of the currently tested protocol
        int iEval = 0;

        //
        // Keep track of the positive or negative offset in the protocol
        // such as "qhttp" instead of "http" or "elnet" instead of "telnet'
        //
        int iPosOffset = 0;
        int iNegOffset = 0;

        //
        // The first character has the most weight. "htp" corrects
        // to "http" and not "ftp"    "ftt" corrects to "ftp"
        //
        if (*szScheme == *pszProtocol)
        {
            iEval += cCorrectFirstChar;
        }

        // Check for a negative offset
        else if(*szScheme == pszProtocol[1])
        {
            iEval += cOffByOneChar;
            iNegOffset = 1;
        }

        //
        // We go through the characters in the protocol, even to the
        // terminating null if iPosOffset == 1 (it is never more than 1)
        // This is so the final "p" in "qhttp" gets a chance to be compared
        //
        for (i=1; i < cchProt + iPosOffset; i++)
        {
            // No points for null terminations matching
            if (szScheme[i] == L'\0')
                break;

            //
            // Check for adjacent character match
            //
            if (szScheme[i] == pszProtocol[i])
            {
                iEval += cCorrectChar;
            }
            else
            {
                if (szScheme[i] == pszProtocol[i - 1])
                {
                    iEval += cOffByOneChar;
                    if (iPosOffset)
                        iEval += cOffsetBonus;
                    else
                        iPosOffset = 1;
                }
                else
                {
                    if(szScheme[i] == pszProtocol[i + 1])
                    {
                        iEval += cOffByOneChar;
                        if (iNegOffset)
                            iEval += cOffsetBonus;
                        else
                            iNegOffset = 1;
                    }
                }
            }
        }

        // Divide the Evaluated value by the MAX(cchScheme, cchProt)
        iEval = iEval / (cchScheme > cchProt ? cchScheme : cchProt);

        // A new best match?
        if (iEval > iBestEval)
        {
            iBestEval = iEval;
            pszBestMatch = pszProtocol;

            //
            // If we found an unquestionably good match (only 1 non-firstchar typo),
            // break out of the loop
            //
            if (iEval >= 100)
                break;
         }
    }

    // If a good enough match was found, then correct url
    if (iBestEval >= cFloor)
    {
        ColonSlashSlashW(pszBestMatch, pszAfterScheme, pszTranslatedUrl,cchMax);
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}



// This is a port of InternetCrackUrl from wininet.
// NTRAID:108139 akabir We REALLY NEED TO CLEAN THIS CODE UP.
// RAID 109209

// A lot of the stuff is redundant with the other code available, but we 
// need to be careful not to cause any regressions. Thus, I'm leaving it in for now.

//
// UrlSchemeList - the list of schemes that we support
//

typedef struct {
    LPWSTR SchemeName;
    DWORD SchemeLength;
    SHINTERNET_SCHEME SchemeType;
    BOOL NeedSlashes;
} URL_SCHEME_INFO;

#define UrlUnescapeInPlaceW(pszUrl, dwFlags)    UrlUnescapeW(pszUrl, NULL, NULL, dwFlags | URL_UNESCAPE_INPLACE)


// NOTE MEGA REDUNDANCY. We could use the similar table above and check for opaque. However
// we'd have to modify that table
PRIVATE
URL_SCHEME_INFO
UrlSchemeList[] = {
    NULL,            0,  SHINTERNET_SCHEME_DEFAULT,    FALSE,  
    L"ftp",          3,  SHINTERNET_SCHEME_FTP,        TRUE,   
    L"gopher",       6,  SHINTERNET_SCHEME_GOPHER,     TRUE,   
    L"http",         4,  SHINTERNET_SCHEME_HTTP,       TRUE,   
    L"https",        5,  SHINTERNET_SCHEME_HTTPS,      TRUE,   
    L"file",         4,  SHINTERNET_SCHEME_FILE,       TRUE,   
    L"news",         4,  SHINTERNET_SCHEME_NEWS,       FALSE,  
    L"mailto",       6,  SHINTERNET_SCHEME_MAILTO,     FALSE,  
    L"socks",        5,  SHINTERNET_SCHEME_SOCKS,      FALSE,  
    L"javascript",   10, SHINTERNET_SCHEME_JAVASCRIPT, FALSE,  
    L"vbscript",     8,  SHINTERNET_SCHEME_VBSCRIPT,   FALSE,  
    L"res",          3,  SHINTERNET_SCHEME_RES,        TRUE
};

#define NUMBER_OF_URL_SCHEMES   ARRAYSIZE(UrlSchemeList)

// swiped from wininet\macros.h
#define IsDigit(c) (((c) >= L'0') && ((c) <= L'9'))
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

BOOL ScanSchemes(LPWSTR pszToCheck, DWORD ccStr, PDWORD pwResult)
{
    for (DWORD i=0; i<NUMBER_OF_URL_SCHEMES; i++)
    {
        if ((UrlSchemeList[i].SchemeLength == ccStr)
            && (StrCmpNIW(UrlSchemeList[i].SchemeName, pszToCheck, ccStr)==0))
        {
            *pwResult = i;
            return TRUE;
        }
    }
    return FALSE;
}

#define ProbeWriteStringBufferW(a, b) ProbeWriteBuffer((LPVOID)a, (b*sizeof(WCHAR)));
#define PAGE_SIZE   4096


DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for writeability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;
            *end = b;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
                *p = b;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {
        //
        // zero-length buffer
        //

        error = ERROR_SUCCESS;
    }

    return error;
}


DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for readability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_INVALID_PARAMETER;
    }

    return error;
}


DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a wide string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}


DWORD
DecodeUrl(
    IN LPWSTR Url,
    IN DWORD UrlLength,
    OUT LPWSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )

/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/

{
// NOTE We can replace this function with UrlUnescapeInPlace

    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {
        WCHAR ch;

        if (*Url == L'%') {

            //
            // REVIEW - would %00 ever appear in an URL?
            //
            if (IsHex(*(Url+1)) && IsHex(*(Url+2)))
            {
                ch = TranslateEscapedOctetW(Url);
                Url += 3;
            } else {
                return ERROR_INTERNET_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}




DWORD
DecodeUrlInSitu(
    IN LPWSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
// NOTE We can replace this function with UrlUnescapeInPlace
    DWORD stringLength = *BufferLength;
    return DecodeUrl(BufferAddress,
                     stringLength,
                     BufferAddress,
                     BufferLength);
}


DWORD
GetUrlAddressInfo(
    IN OUT LPWSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPWSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPWSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )

/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL

--*/

{
    LPWSTR pString;
    LPWSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    while ((*pString!=SLASH) && (*pString != L'\0') && (length != 0)) {
        if (*pString==HEX_ESCAPE) {
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //
            *partEscape = TRUE;
        }
        if (*pString==COLON) {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                // ISSUE Note that passwords might contain colons, and thus not work in this 
                // case
                return ERROR_INTERNET_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }
        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_INTERNET_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


DWORD
GetUrlAddress(
    IN OUT LPWSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPWSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPWSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPWSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPSHINTERNET_PORT lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/

{
    LPWSTR pAt;
    DWORD urlLength;
    LPWSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    WCHAR portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPWSTR pPortNumber;
    DWORD error;
    LPWSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = lstrlenW(pUrl);

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    pAt = NULL;
    for (DWORD i = 0; i < urlLength; ++i) {
        if (pUrl[i]==SLASH) {
            break;
        } else if (pUrl[i]==AT) {
            pAt = &pUrl[i];
            break;
        }
    }

    if (pAt != NULL) {
        DWORD addressPartLength;
        LPWSTR userName;
        DWORD userNameLength;
        LPWSTR password;
        DWORD passwordLength;

        addressPartLength = (DWORD) (pAt - pUrl);
        urlLength -= addressPartLength;
        error = GetUrlAddressInfo(&pUrl,
                                  &addressPartLength,
                                  &userName,
                                  &userNameLength,
                                  &part1Escape,
                                  &password,
                                  &passwordLength,
                                  &part2Escape
                                  );
        if (error != ERROR_SUCCESS) {
            return error;
        }

        //
        // ensure there is no address information unparsed before the '@'
        //

        ASSERT(addressPartLength == 0);
        ASSERT(pUrl == pAt);

        if (ARGUMENT_PRESENT(lpszUserName)) {

            ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            //
            // convert the user name in situ
            //

            if (part1Escape) {
                ASSERT(userName != NULL);
                ASSERT(userNameLength != 0);

                error = DecodeUrlInSitu(userName, &userNameLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszUserName = userName;
            *lpdwUserNameLength = userNameLength;
        }

        if (ARGUMENT_PRESENT(lpszPassword)) {
            // convert the password in situ
            if (part2Escape) {
                ASSERT(userName != NULL);
                ASSERT(userNameLength != 0);
                ASSERT(password != NULL);
                ASSERT(passwordLength != 0);

                error = DecodeUrlInSitu(password, &passwordLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszPassword = password;
            *lpdwPasswordLength = passwordLength;
        }

        //
        // the URL pointer now points at the host:port fields (remember that
        // ExtractAddressParts() must have bumped pUrl up to the end of the
        // password field (if present) which ends at pAt)
        //

        ++pUrl;

        //
        // similarly, bump urlLength to account for the '@'
        //

        --urlLength;
    } else {
        //
        // no '@' therefore no username or password
        //

        if (ARGUMENT_PRESENT(lpszUserName)) {
            ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            *lpszUserName = NULL;
            *lpdwUserNameLength = 0;
        }
        if (ARGUMENT_PRESENT(lpszPassword)) {
            ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));

            *lpszPassword = NULL;
            *lpdwPasswordLength = 0;
        }
    }

    //
    // now get the host name and the optional port
    //

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // the URL address information MUST contain the host name
    //

//  if ((hostName == NULL) || (hostNameLength == 0)) {
//      return ERROR_INTERNET_INVALID_URL;
//  }

    if (ARGUMENT_PRESENT(lpszHostName)) {
        ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape) {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS) {
                return error;
            }
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (ARGUMENT_PRESENT(lpPort)) {
        if (portNumberLength != 0) {
            DWORD i;
            DWORD port;

            ASSERT(pPortNumber != NULL);

            if (part2Escape) {
                error = DecodeUrlInSitu(pPortNumber, &portNumberLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }

            //
            // ensure all characters in the port number buffer are numeric, and
            // calculate the port number at the same time
            //

            for (i = 0, port = 0; i < portNumberLength; ++i) {
                if (!IsDigit(*pPortNumber)) {
                    return ERROR_INTERNET_INVALID_URL;
                }
                port = port * 10 + (int)(*pPortNumber++ - L'0');
                // We won't allow ports larger than 65535 ((2^16)-1)
                // We have to check this every time to make sure that someone
                // doesn't try to overflow a DWORD.
                if (port > 65535) 
                {
                    return ERROR_INTERNET_INVALID_URL;
                }
            }
            *lpPort = (SHINTERNET_PORT)port;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = TRUE;
            }
        } else {
            *lpPort = INTERNET_INVALID_PORT_NUMBER;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = FALSE;
            }
        }
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    return ERROR_SUCCESS;
}


DWORD
CrackUrl(
    IN OUT LPWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPSHINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPWSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPWSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPSHINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPWSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPWSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPWSTR* lpszUrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPWSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl                 - pointer to URL to crack. This buffer WILL BE
                              OVERWRITTEN if it contains escape sequences that
                              we will convert back to ANSI characters

    dwUrlLength             - if not 0, string length of lpszUrl

    bEscape                 - TRUE if we are to escape the url-path

    lpSchemeType            - returned scheme type - e.g. INTERNET_SCHEME_HTTP

    lpszSchemeName          - returned scheme name

    lpdwSchemeNameLength    - length of scheme name

    lpszHostName            - returned host name

    lpdwHostNameLength      - length of host name buffer

    lpServerPort            - returned server port if present in the URL, else 0

    lpszUserName            - returned user name if present

    lpdwUserNameLength      - length of user name buffer

    lpszPassword            - returned password if present

    lpdwPasswordLength      - length of password buffer

    lpszUrlPath             - returned, canonicalized URL path

    lpdwUrlPathLength       - length of url-path buffer

    lpszExtraInfo           - returned search string or intra-page link if present

    lpdwExtraInfoLength     - length of extra info buffer

    pHavePort               - returned boolean indicating whether port was specified

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_UNRECOGNIZED_SCHEME

--*/

{
    DWORD error;
    DWORD schemeLength;
    SHINTERNET_SCHEME schemeType;

    //
    // if dwUrlLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwUrlLength == 0) {
        dwUrlLength = lstrlenW(lpszUrl);
    }

    //
    // get parser based on the protocol name
    //

    for (schemeLength = 0; lpszUrl[schemeLength]!=COLON; ++schemeLength) {
        if ((dwUrlLength == 0) || (lpszUrl[schemeLength] == '\0')) {
            //
            // no ':' in URL? Bogus (dude)
            //
            error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
            goto quit;
        }
        --dwUrlLength;
    }

    DWORD i;
    int skip;
    BOOL isGeneric;
    BOOL needSlashes;
    BOOL haveSlashes;

    isGeneric = FALSE;
    needSlashes = FALSE;
    haveSlashes = FALSE;

    schemeType = SHINTERNET_SCHEME_UNKNOWN;

    if (ScanSchemes(lpszUrl, schemeLength, &i)) 
    {
        schemeType = UrlSchemeList[i].SchemeType;
        needSlashes = UrlSchemeList[i].NeedSlashes;
    }

    skip = 1;       // skip ':'

    if ((dwUrlLength > 3) && (StrCmpNIW(&lpszUrl[schemeLength], L"://", 3) == 0)) {
        skip = 3;   // skip "://"
        haveSlashes = TRUE;
    }

    if (schemeType == SHINTERNET_SCHEME_FILE)
        isGeneric = TRUE;

    if (schemeType == SHINTERNET_SCHEME_NEWS ||
        schemeType == SHINTERNET_SCHEME_UNKNOWN) {
        //
        //  urls can be hierarchical or opaque.  if the slashes
        //  exist, then we should assume hierarchical
        //  when we dont know the scheme or it is news:.
        //  otherwise it is opaque (isGeneric)
        //

        needSlashes = haveSlashes;
        isGeneric = !haveSlashes;
    }

    //
    // If we don't have slashes, make sure we don't need them.
    // If we have slashes, make sure they are required.
    //

    if ((!haveSlashes && !needSlashes) || (haveSlashes && needSlashes)) {
        if (ARGUMENT_PRESENT(lpSchemeType)) {
            *lpSchemeType = schemeType;
        }
        if (ARGUMENT_PRESENT(lpszSchemeName)) {
            *lpszSchemeName = lpszUrl;
            *lpdwSchemeNameLength = schemeLength;
        }
        lpszUrl += schemeLength + skip;
        dwUrlLength -= skip;

        if (SHINTERNET_SCHEME_RES == schemeType) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            PWSTR psz = lpszUrl;
            while (*lpszUrl && *lpszUrl!=SLASH)
                lpszUrl++;

            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = psz;
                *lpdwHostNameLength = (DWORD)(lpszUrl - psz);
                dwUrlLength -= *lpdwHostNameLength;
                error = DecodeUrlInSitu(*lpszHostName, lpdwHostNameLength);
            }
        } else if (isGeneric) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = NULL;
                *lpdwHostNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            error = ERROR_SUCCESS;
        } else {
            error = GetUrlAddress(&lpszUrl,
                                  &dwUrlLength,
                                  lpszUserName,
                                  lpdwUserNameLength,
                                  lpszPassword,
                                  lpdwPasswordLength,
                                  lpszHostName,
                                  lpdwHostNameLength,
                                  lpServerPort,
                                  pHavePort
                                  );
        }
        if (bEscape && (error == ERROR_SUCCESS)) {
            error = DecodeUrlInSitu(lpszUrl, &dwUrlLength);
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszExtraInfo)) {
            *lpdwExtraInfoLength = 0;
            for (i = 0; i < (int)dwUrlLength; i++) {
                if (lpszUrl[i] == '?' || lpszUrl[i] == '#') {
                    *lpszExtraInfo = &lpszUrl[i];
                    *lpdwExtraInfoLength = dwUrlLength - i;
                    dwUrlLength -= *lpdwExtraInfoLength;
                }
            }
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszUrlPath)) {
            *lpszUrlPath = lpszUrl;
            *lpdwUrlPathLength = dwUrlLength;
        }
    } else {
        error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
    }

quit:

    return error;
}



BOOL
WINAPI
UrlCrackW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPSHURL_COMPONENTSW lpUrlComponents
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    lpszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if lpszUrl is ASCIIZ string, else length of lpszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DWORD error = ERROR_SUCCESS;

    // validate parameters
    if (ARGUMENT_PRESENT(lpszUrl)) {
        if (!dwUrlLength) {
            error = ProbeStringW((LPWSTR)lpszUrl, &dwUrlLength);
        } else if (IsBadReadPtr((LPVOID)lpszUrl, dwUrlLength*sizeof(WCHAR))) {
            error = ERROR_INVALID_PARAMETER;
        }
    } else {
        error = ERROR_INVALID_PARAMETER;
    }
    if (error != ERROR_SUCCESS) 
    {
        goto quit;
    }

    if (IsBadWritePtr(lpUrlComponents, sizeof(*lpUrlComponents))
        || (lpUrlComponents->dwStructSize != sizeof(*lpUrlComponents)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // we only allow two flags for this API
    //

    if (dwFlags & ~(ICU_ESCAPE | ICU_DECODE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // get the individual components to return. If they reference a buffer then
    // check it for writeability
    //

    LPWSTR lpUrl;
    LPWSTR urlCopy;
    SHINTERNET_SCHEME schemeType;
    LPWSTR schemeName;
    DWORD schemeNameLength;
    LPWSTR hostName;
    DWORD hostNameLength;
    SHINTERNET_PORT nPort;
    LPWSTR userName;
    DWORD userNameLength;
    LPWSTR password;
    DWORD passwordLength;
    LPWSTR urlPath;
    DWORD urlPathLength;
    LPWSTR extraInfo;
    DWORD extraInfoLength;
    BOOL copyComponent;
    BOOL havePort;

    copyComponent = FALSE;

    schemeName = lpUrlComponents->lpszScheme;
    schemeNameLength = lpUrlComponents->dwSchemeLength;
    if ((schemeName != NULL) && (schemeNameLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)schemeName, schemeNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *schemeName = '\0';
        copyComponent = TRUE;
    }

    hostName = lpUrlComponents->lpszHostName;
    hostNameLength = lpUrlComponents->dwHostNameLength;
    if ((hostName != NULL) && (hostNameLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)hostName, hostNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *hostName = '\0';
        copyComponent = TRUE;
    }

    userName = lpUrlComponents->lpszUserName;
    userNameLength = lpUrlComponents->dwUserNameLength;
    if ((userName != NULL) && (userNameLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)userName, userNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *userName = '\0';
        copyComponent = TRUE;
    }

    password = lpUrlComponents->lpszPassword;
    passwordLength = lpUrlComponents->dwPasswordLength;
    if ((password != NULL) && (passwordLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)password, passwordLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *password = '\0';
        copyComponent = TRUE;
    }

    urlPath = lpUrlComponents->lpszUrlPath;
    urlPathLength = lpUrlComponents->dwUrlPathLength;
    if ((urlPath != NULL) && (urlPathLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)urlPath, urlPathLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *urlPath = '\0';
        copyComponent = TRUE;
    }

    extraInfo = lpUrlComponents->lpszExtraInfo;
    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
    if ((extraInfo != NULL) && (extraInfoLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)extraInfo, extraInfoLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *extraInfo = '\0';
        copyComponent = TRUE;
    }

    //
    // we can only escape or decode the URL if the caller has provided us with
    // buffers to write the escaped strings into
    //

    if (dwFlags & (ICU_ESCAPE | ICU_DECODE)) {
        if (!copyComponent) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // create a copy of the URL. CrackUrl() will modify this in situ. We
        // need to copy the results back to the user's buffer(s)
        //

        DWORD dw = dwUrlLength;
        if (!dw)
        {
            dw = lstrlenW(lpszUrl);
        }
        urlCopy = new WCHAR[dw+1];
        if (urlCopy == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        memcpy(urlCopy, lpszUrl, (dw+1)*sizeof(WCHAR));
        lpUrl = urlCopy;
    } else {
        lpUrl = (LPWSTR)lpszUrl;
        urlCopy = NULL;
    }

    //
    // crack the URL into its constituent parts
    //

    error = CrackUrl(lpUrl,
                     dwUrlLength,
                     (dwFlags & ICU_ESCAPE) ? TRUE : FALSE,
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &nPort,
                     &userName,
                     &userNameLength,
                     &password,
                     &passwordLength,
                     &urlPath,
                     &urlPathLength,
                     extraInfoLength ? &extraInfo : NULL,
                     extraInfoLength ? &extraInfoLength : 0,
                     &havePort
                     );
    if (error != ERROR_SUCCESS) {
        goto crack_error;
    }

    BOOL copyFailure;

    copyFailure = FALSE;

    //
    // update the URL_COMPONENTS structure based on the results, and what was
    // asked for
    //

    if (lpUrlComponents->lpszScheme != NULL) {
        if (lpUrlComponents->dwSchemeLength > schemeNameLength) {
            memcpy(lpUrlComponents->lpszScheme, schemeName, schemeNameLength*sizeof(WCHAR));
            lpUrlComponents->lpszScheme[schemeNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszScheme, 0);
            }
        } else {
            ++schemeNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    } else if (lpUrlComponents->dwSchemeLength != 0) {
        lpUrlComponents->lpszScheme = schemeName;
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    }

    if (lpUrlComponents->lpszHostName != NULL) {
        if (lpUrlComponents->dwHostNameLength > hostNameLength) {
            memcpy(lpUrlComponents->lpszHostName, hostName, hostNameLength*sizeof(WCHAR));
            lpUrlComponents->lpszHostName[hostNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszHostName, 0);
            }
        } else {
            ++hostNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwHostNameLength = hostNameLength;
    } else if (lpUrlComponents->dwHostNameLength != 0) {
        lpUrlComponents->lpszHostName = hostName;
        lpUrlComponents->dwHostNameLength = hostNameLength;
    }

    if (lpUrlComponents->lpszUserName != NULL) {
        if (lpUrlComponents->dwUserNameLength > userNameLength) {
            memcpy(lpUrlComponents->lpszUserName, userName, userNameLength*sizeof(WCHAR));
            lpUrlComponents->lpszUserName[userNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszUserName, 0);
            }
        } else {
            ++userNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwUserNameLength = userNameLength;
    } else if (lpUrlComponents->dwUserNameLength != 0) {
        lpUrlComponents->lpszUserName = userName;
        lpUrlComponents->dwUserNameLength = userNameLength;
    }

    if (lpUrlComponents->lpszPassword != NULL) {
        if (lpUrlComponents->dwPasswordLength > passwordLength) {
            memcpy(lpUrlComponents->lpszPassword, password, passwordLength*sizeof(WCHAR));
            lpUrlComponents->lpszPassword[passwordLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszPassword, 0);
            }
        } else {
            ++passwordLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwPasswordLength = passwordLength;
    } else if (lpUrlComponents->dwPasswordLength != 0) {
        lpUrlComponents->lpszPassword = password;
        lpUrlComponents->dwPasswordLength = passwordLength;
    }

    if (lpUrlComponents->lpszUrlPath != NULL) {
        if(schemeType == SHINTERNET_SCHEME_FILE) 
        {
            //
            //  for file: urls we return the path component
            //  as a valid dos path.
            //

            copyFailure = FAILED(PathCreateFromUrlW(lpUrl, lpUrlComponents->lpszUrlPath, &(lpUrlComponents->dwUrlPathLength), 0));
        } 
        else if (lpUrlComponents->dwUrlPathLength > urlPathLength) {
            memcpy(lpUrlComponents->lpszUrlPath, urlPath, urlPathLength*sizeof(WCHAR));
            lpUrlComponents->lpszUrlPath[urlPathLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszUrlPath, 0);
            }
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        } else {
            ++urlPathLength;
            copyFailure = TRUE;
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        }
    } else if (lpUrlComponents->dwUrlPathLength != 0) {
        lpUrlComponents->lpszUrlPath = urlPath;
        lpUrlComponents->dwUrlPathLength = urlPathLength;
    }

    if (lpUrlComponents->lpszExtraInfo != NULL) {
        if (lpUrlComponents->dwExtraInfoLength > extraInfoLength) {
            memcpy(lpUrlComponents->lpszExtraInfo, extraInfo, extraInfoLength*sizeof(WCHAR));
            lpUrlComponents->lpszExtraInfo[extraInfoLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszExtraInfo, 0);
            }
        } else {
            ++extraInfoLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    } else if (lpUrlComponents->dwExtraInfoLength != 0) {
        lpUrlComponents->lpszExtraInfo = extraInfo;
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    }

    //
    // we may have failed to copy one or more components because we didn't have
    // enough buffer space.
    //
    // N.B. Don't change error below here. If need be, move this test lower
    //

    if (copyFailure) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    
    //
    // copy the scheme type
    //

    lpUrlComponents->nScheme = schemeType;

    //
    // convert 0 port (not in URL) to default value for scheme
    //

    if (nPort == INTERNET_INVALID_PORT_NUMBER && !havePort) {
        switch (schemeType) {
        case SHINTERNET_SCHEME_FTP:
            nPort = INTERNET_DEFAULT_FTP_PORT;
            break;

        case SHINTERNET_SCHEME_GOPHER:
            nPort = INTERNET_DEFAULT_GOPHER_PORT;
            break;

        case SHINTERNET_SCHEME_HTTP:
            nPort = INTERNET_DEFAULT_HTTP_PORT;
            break;

        case SHINTERNET_SCHEME_HTTPS:
            nPort = INTERNET_DEFAULT_HTTPS_PORT;
            break;
        }
    }
    lpUrlComponents->nPort = nPort;

crack_error:

    if (urlCopy != NULL) {
        delete [] urlCopy;
    }

quit:
//    return HRESULT_FROM_WIN32(error);
    if (error!=ERROR_SUCCESS)
    {
        SetLastError(error);
    }
    return error==ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\dll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\unicwrap.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       unicwrap.cpp
//
//  Contents:   Wrappers for all Unicode functions used in MSHTML.
//              Any Unicode parameters/structure fields/buffers are converted
//              to ANSI, and then the corresponding ANSI version of the function
//              is called.
//
//----------------------------------------------------------------------------

// This file expects to be compiled UNICODE

//----------------------------------------------------------------------------
//
//  HOW TO WRITE A WRAPPER
//
//----------------------------------------------------------------------------
//
//  Suppose you want to write a wrapper for CreateMutex.
//
//  -   Look up CreateMutex and see that it is a function in KERNEL32.DLL.
//      If your function is in some other DLL, make the appropriate changes
//      to the instructions below.
//
//  -   Write a wrapper for your function, wrapped inside the appropriate
//      #ifdef for the DLL being wrapped.
//
//          #ifdef NEED_KERNEL32_WRAPPER
//          STDAPI_(HANDLE) WINAPI
//          CreateMutexWrapW(...)
//          {
//              VALIDATE_PROTOTYPE(CreateMutex);
//              blahblahblah
//          }
//          #endif // NEED_KERNEL32_WRAPPER
//
//  -   If your wrapped function is in a DLL other than KERNEL32,
//      USER32, GDI32, or ADVAPI32, then you need to write a delay-load
//      stub in dllload.c.
//
//      Furthermore, if the delay-load stub uses DELAY_MAP instead of
//      DELAY_LOAD (SHELL32, WINMM, COMDLG32), then the line
//
//          VALIDATE_PROTOTYPE(WrappedFunction)
//
//      needs to be changed to
//
//          VALIDATE_PROTOTYPE_DELAYLOAD(WrappedFunction, _WrappedFunction)
//
//  -   Add a line for your function to thunk.h.  In our case, we would
//      look for the #ifndef NEED_KERNEL32_WRAPPER section and add the
//      line
//
//          #define CreateMutexWrapW CreateMutexW
//
//      (This prevents shlwapi from trying to call a nonexistent wrapper.)
//
//  -   Add a line for your function to shlwapi.src.
//
//          KERNEL32_WRAP(CreateMutexW)     @nnn NONAME PRIVATE
//
//  -   If your wrapper is high-frequency, you may want to use
//      FORWARD_AW or THUNK_AW to make it faster on NT.
//
//----------------------------------------------------------------------------

// WARNING: if you add a new call to FORWARD_AW or THUNK_AW (or modify the
// macros), make sure you build this file on both x86 and non-x86 (or
// alternately, build w/ PERF_ASM=0 on x86) to make sure there are no
// syntax errors.  the macros are *very* different between x86 and non-x86,
// so successful compilation on one platform in no way guarantees success
// on the other.  i speak from experience, not theory...

#include "priv.h"
#define _SHELL32_
#define _SHDOCVW_
#include <shellapi.h>
#include <commctrl.h>       // for treeview
#include "unicwrap.h"
#include <wininet.h>            // INTERNET_MAX_URL_LENGTH
#include <winnetp.h>
#include "mlui.h"

#include <platform.h>
#include "apithk.h"

#define DM_PERF     0    // perf stats

#ifndef ANSI_SHELL32_ON_UNIX
#define UseUnicodeShell32() ( g_bRunningOnNT )
#else
#define UseUnicodeShell32() ( FALSE )
#endif

//
//  Do this in every wrapper function to make sure the wrapper
//  prototype matches the function it is intending to replace.
//
#define VALIDATE_PROTOTYPE(f) if (f##W == f##WrapW) 0
#define VALIDATE_PROTOTYPEA(f) if (f##A == f##WrapA) 0
#define VALIDATE_PROTOTYPEX(f) if (f == f##Wrap) 0
#define VALIDATE_PROTOTYPE_DELAYLOAD(fWrap, fDelay) if (fDelay##W == fWrap##WrapW) 0
#define VALIDATE_PROTOTYPE_DELAYLOADX(fWrap, fDelay) if (fDelay == fWrap##Wrap) 0
#define VALIDATE_PROTOTYPE_NO_W(f) if (f## == f##Wrap) 0


//
//  Do this in every wrapper function that has an output parameter.
//  It raises assertion failures on the main code path so that
//  the same assertions are raised on NT and 95.  The CStrOut class
//  doesn't like it when you say that an output buffer is NULL yet
//  has nonzero length.  Without this macro, the bug would go undetected
//  on NT and appear only on Win95.
//
// FEATURE raymondc - Turn this on after fixing all the RIPs it catches
// (otherwise we assert too much)
#if 0
#define VALIDATE_OUTBUF(s, cch) ASSERT((s) != NULL || (cch) == 0)
#else
#define VALIDATE_OUTBUF(s, cch)
#endif

// compiler should do this opt for us (call-thunk => jmp), but it doesn't
// so we do it ourselves (i raided it and they're adding it to vc6.x so
// hopefully we'll get it someday)
#if _X86_
#define PERF_ASM        1       // turn on inline-asm opts
#endif

// todo??? #ifdef SUNDOWN    #undef PERF_ASM

#if PERF_ASM // {

// APPCOMPAT workaround compiler bug
// compiler should know this, but doesn't, so we make it explicit
#define IMPORT_PTR  dword ptr       // doesn't work for sundown


//***   FORWARD_AW, THUNK_AW -- simple forwarders and thunks
// ENTRY/EXIT
//  - declare function w/ FORWARD_API
//  - if you're using THUNK_AW, create the 'A' thunk helper
//  - make the body FORWARD_AW or THUNK_AW.
//  - make sure there's *no* other code in the func.  o.w. you'll get bogus
//  code.
// EXAMPLE
//  int FORWARD_API WINAPI FooWrapW(int i, void *p)
//  {
//      VALIDATE_PROTOTYPE(Foo);
//
//      FORWARD_AW(Foo, (i, p));
//  }
//
//  int WINAPI BarAThunk(HWND hwnd, WPARAM wParam)
//  {
//      ... ansi thunk helper ...
//  }
//
//  int FORWARD_API WINAPI BarWrapW(HWND hwnd, WPARAM wParam)
//  {
//      VALIDATE_PROTOTYPE(Bar);
//
//      THUNK_AW(Bar, (hwnd, wParam));
//  }
// NOTES
//  - WARNING: can only be used for 'simple' thunks (NAKED => no non-global
//  vars, etc.).
//  - WARNING: calling func must be declared FORWARD_API.  if not you'll
//  get bogus code.  happily if you forget you get the (obscure) error
//  message "error C4035: 'FooW': no return value"
//  - note that the macro ends up w/ an extra ";" from the caller, oh well...
//  - TODO: perf: better still would be to have a g_pfnCallWndProc, init
//  it 1x, and then jmp indirect w/o the test.  it would cost us a ptr but
//  we only do it for the top-2 funcs (CallWindowProc and SendMessage)
#define FORWARD_API     _declspec(naked)

#define FORWARD_AW(_fn, _args) \
    if (g_bRunningOnNT) { \
        _asm { jmp     IMPORT_PTR _fn##W } \
    } \
    _asm { jmp     IMPORT_PTR _fn##A }

#define THUNK_AW(_fn, _args) \
    if (g_bRunningOnNT) { \
        _asm { jmp     IMPORT_PTR _fn##W } \
    } \
    _asm { jmp     _fn##AThunk }    // n.b. no IMPORT_PTR

#else // }{

#define FORWARD_API     /*NOTHING*/

#define FORWARD_AW(_fn, _args) \
    if (g_bRunningOnNT) { \
        return _fn##W _args; \
    } \
    return _fn##A _args;

#define THUNK_AW(_fn, _args) \
    if (g_bRunningOnNT) { \
        return _fn##W _args; \
    } \
    return _fn##AThunk _args;

#endif // }

//
//  Windows 95 and NT5 do not have the hbmpItem field in their MENUITEMINFO
//  structure.
//
#if (_WIN32_WINNT >= 0x0500)
#define MENUITEMINFOSIZE_WIN95  FIELD_OFFSET(MENUITEMINFOW, hbmpItem)
#else
#define MENUITEMINFOSIZE_WIN95  sizeof(MENUITEMINFOW)
#endif


//
// FEATURE - Undefine functions that are defined in thunk.h
//          These are duplicates of functions defined here
//          and should be deleted from thunk.c.

#undef RegSetValueExW
#undef CompareStringW
#undef GetFileAttributesW
#undef GetFullPathNameW
#undef SearchPathW
#undef GetWindowsDirectoryW
#undef GetSystemDirectoryW
#undef GetEnvironmentVariableW

// Undefine mappings
#undef CharLowerW


//
// FEATURE - There are numerous registry functions that are duplicated
//          here and in reg.c
//

//
//  Some W functions are implemented on Win95, so complain if anybody
//  writes thunks for them.
//
//  Though Win95's implementation of TextOutW is incomplete for FE languages.
//  Remove this section when we implement FE-aware TextOutW for Win95.
//
#if defined(TextOutWrap)
#error Do not write thunks for TextOutW; Win95 supports it.
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
    if (_pstr != _ach && HIWORD64(_pstr) != 0 && !IsAtom())
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
    if (_pwstr != _awch && HIWORD64(_pwstr) != 0)
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD64(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch)
{
    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    ASSERT(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //
    // Since the passed in buffer may not be null terminated, we have
    // a problem if cch==ARRAYSIZE(_awch), because MultiByteToWideChar
    // will succeed, and we won't be able to null terminate the string!
    // Decrease our buffer by one for this case.
    //
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _awch, ARRAYSIZE(_awch)-1);

    if (_cwchLen > 0)
    {
        // Some callers don't NULL terminate.
        //
        // We could check "if (-1 != cch)" before doing this,
        // but always doing the null is less code.
        //
        _awch[_cwchLen] = 0;

        if (0 == _awch[_cwchLen-1]) // account for terminator
            _cwchLen--;

        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    cchBufReq = MultiByteToWideChar( CP_ACP, 0, pstr, cch, NULL, 0 );

    // Again, leave room for null termination
    cchBufReq++;

    ASSERT(cchBufReq > 0);
    _pwstr = new WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _pwstr, cchBufReq );

#if DBG == 1 /* { */
    if (0 == _cwchLen)
    {
        int errcode = GetLastError();
        ASSERT(0 && "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    // Again, make sure we're always null terminated
    ASSERT(_cwchLen < cchBufReq);
    _pwstr[_cwchLen] = 0;

    if (0 == _pwstr[_cwchLen-1]) // account for terminator
        _cwchLen--;

}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline this function or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr) : CConvertStr(CP_ACP)
{
    Init(pwstr, -1);
}


CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr) : CConvertStr(uCP)
{
    Init(pwstr, -1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//  Note:       We ignore AreFileApisANSI() and always use CP_ACP.
//              The reason is that nobody uses SetFileApisToOEM() except
//              console apps, and once you set file APIs to OEM, you
//              cannot call shell/user/gdi APIs, since they assume ANSI
//              regardless of the FileApis setting.  So you end up in
//              this horrible messy state where the filename APIs interpret
//              the strings as OEM but SHELL32 interprets the strings
//              as ANSI and you end up with a big mess.
//
//----------------------------------------------------------------------------

void
CStrIn::Init(LPCWSTR pwstr, int cwch)
{
    int cchBufReq;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pwstr) == 0 || IsAtom())
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    if ( cwch == 0 )
    {
        *_ach = '\0';
        _pstr = _ach;
        return;
    }

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _ach, ARRAYSIZE(_ach)-1, NULL, NULL);

    if (_cchLen > 0)
    {
        // This is DBCS safe since byte before _cchLen is last character
        _ach[_cchLen] = 0;
        // this may not be safe if the last character
        // was a multibyte character...
        if (_ach[_cchLen-1]==0)
            _cchLen--;          // account for terminator
        _pstr = _ach;
        return;
    }


    cchBufReq = WideCharToMultiByte(
            CP_ACP, 0, pwstr, cwch, NULL, 0, NULL, NULL);

    cchBufReq++;

    ASSERT(cchBufReq > 0);
    _pstr = new char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _pstr, cchBufReq, NULL, NULL);
#if DBG == 1 /* { */
    if (_cchLen < 0)
    {
        errcode = GetLastError();
        ASSERT(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

    // Again, make sure we're always null terminated
    ASSERT(_cchLen < cchBufReq);
    _pstr[_cchLen] = 0;
    if (0 == _pstr[_cchLen-1]) // account for terminator
        _cchLen--;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(LPCWSTR pwstr)
{
    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    ASSERT(HIWORD64(pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, (int)(pwstrT - pwstr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CPPFIn::CPPFIn
//
//  Synopsis:   Inits the class.  Truncates the filename to MAX_PATH
//              so Win9x DBCS won't fault.  Win9x SBCS silently truncates
//              to MAX_PATH, so we're bug-for-bug compatible.
//
//----------------------------------------------------------------------------

CPPFIn::CPPFIn(LPCWSTR pwstr)
{
    SHUnicodeToAnsi(pwstr, _ach, ARRAYSIZE(_ach));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwchBuf);
}

CStrOut::CStrOut(UINT uCP, LPWSTR pwstr, int cwchBuf) : CConvertStr(uCP)
{
    Init(pwstr, cwchBuf);
}

void
CStrOut::Init(LPWSTR pwstr, int cwchBuf) 
{
    ASSERT(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        // Force cwchBuf = 0 because many callers (in particular, registry
        // munging functions) pass garbage as the length because they know
        // it will be ignored.
        _cwchBuf = 0;
        _pstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAYSIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    _pstr = new char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _pstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::CStrOutW
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pstr]    -- The MBCS buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cchBuf]  -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOutW::CStrOutW(LPSTR pstr, int cchBuf)
{
    ASSERT(cchBuf >= 0);

    _pstr = pstr;
    _cchBuf = cchBuf;

    if (!pstr)
    {
        // Force cchBuf = 0 because many callers (in particular, registry
        // munging functions) pass garbage as the length because they know
        // it will be ignored.
        _cchBuf = 0;
        _pwstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pstr));

    // Initialize buffer in case Windows API returns an error.
    _awch[0] = 0;

    // Use preallocated buffer if big enough.
    if (cchBuf <= ARRAYSIZE(_awch))
    {
        _pwstr = _awch;
        return;
    }

    // Allocate buffer.
    _pwstr = new WCHAR[cchBuf];
    if (!_pwstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cchBuf > 0);
        _pstr[0] = 0;
        _cchBuf = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _pwstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertIncludingNul()
{
    int cch;

    if (!_pstr)
        return 0;

    cch = SHAnsiToUnicodeCP(_uCP, _pstr, _pwstr, _cwchBuf);

#if DBG == 1 /* { */
    if (cch == 0 && _cwchBuf > 0)
    {
        int errcode = GetLastError();
        ASSERT(0 && "SHAnsiToUnicode failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from Unicode to MBCS
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOutW::ConvertIncludingNul()
{
    int cch;

    if (!_pwstr)
        return 0;

    cch = SHUnicodeToAnsi(_pwstr, _pstr, _cchBuf);

#if DBG == 1 /* { */
    if (cch == 0 && _cchBuf > 0)
    {
        int errcode = GetLastError();
        ASSERT(0 && "SHUnicodeToAnsi failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertExcludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count EXCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertExcludingNul()
{
    int ret = ConvertIncludingNul();
    if (ret > 0)
    {
        ret -= 1;
    }
    return ret;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
    ConvertIncludingNul();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::~CStrOutW
//
//  Synopsis:   Converts the buffer from Unicode to MBCS.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOutW::~CStrOutW()
{
    ConvertIncludingNul();
}

#ifdef NEED_KERNEL32_WRAPPER
//+---------------------------------------------------------------------------
//
//  Class:      CWin32FindDataInOut
//
//  Purpose:    Converts WIN32_FIND_DATA structures from UNICODE to ANSI
//              on the way in, then ANSI to UNICODE on the way out.
//
//----------------------------------------------------------------------------

class CWin32FindDataInOut
{
public:
    operator LPWIN32_FIND_DATAA();
    CWin32FindDataInOut(LPWIN32_FIND_DATAW pfdW);
    ~CWin32FindDataInOut();

protected:
    LPWIN32_FIND_DATAW _pfdW;
    WIN32_FIND_DATAA _fdA;
};

//+---------------------------------------------------------------------------
//
//  Member:     CWin32FindDataInOut::CWin32FindDataInOut
//
//  Synopsis:   Convert the non-string fields to ANSI.  You'd think this
//              isn't necessary, but it is, because Win95 puts secret
//              goo into the dwReserved fields that must be preserved.
//
//----------------------------------------------------------------------------

inline
CWin32FindDataInOut::CWin32FindDataInOut(LPWIN32_FIND_DATAW pfdW) :
    _pfdW(pfdW)
{
    memcpy(&_fdA, _pfdW, FIELD_OFFSET(WIN32_FIND_DATA, cFileName));

    _fdA.cFileName[0]          = '\0';
    _fdA.cAlternateFileName[0] = '\0';
}

//+---------------------------------------------------------------------------
//
//  Member:     CWin32FindDataInOut::~CWin32FindDataInOut
//
//  Synopsis:   Convert all the fields from ANSI back to UNICODE.
//
//----------------------------------------------------------------------------

inline
CWin32FindDataInOut::~CWin32FindDataInOut()
{
    memcpy(_pfdW, &_fdA, FIELD_OFFSET(WIN32_FIND_DATA, cFileName));

    SHAnsiToUnicode(_fdA.cFileName, _pfdW->cFileName, ARRAYSIZE(_pfdW->cFileName));
    SHAnsiToUnicode(_fdA.cAlternateFileName, _pfdW->cAlternateFileName, ARRAYSIZE(_pfdW->cAlternateFileName));
}

//+---------------------------------------------------------------------------
//
//  Member:     CWin32FindDataInOut::operator LPWIN32_FIND_DATAA
//
//  Synopsis:   Returns the WIN32_FIND_DATAA.
//
//----------------------------------------------------------------------------

inline
CWin32FindDataInOut::operator LPWIN32_FIND_DATAA()
{
    return &_fdA;
}
#endif // NEED_KERNEL32_WRAPPER

//+------------------------------------------------------------------------
//
//  Implementation of the wrapped functions
//
//-------------------------------------------------------------------------

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI
AppendMenuWrapW(
        HMENU   hMenu,
        UINT    uFlags,
        UINT_PTR uIDnewItem,
        LPCWSTR lpnewItem)
{
    VALIDATE_PROTOTYPE(AppendMenu);

    // Make the InsertMenu wrapper do all the work
    return InsertMenuWrapW(hMenu, (UINT)-1,
                           uFlags | MF_BYPOSITION, uIDnewItem, lpnewItem);
}

UINT GetLocaleAnsiCodePage(LCID Locale) 
{
    WCHAR szCodePage[7];

    UINT uiRetVal;
    
    if (0 != GetLocaleInfoWrapW(Locale, LOCALE_IDEFAULTANSICODEPAGE, szCodePage, ARRAYSIZE(szCodePage)))    
    {
        uiRetVal = StrToInt(szCodePage);
    }
    else
    {
        uiRetVal = CP_ACP;
    }

    return uiRetVal;
}

#ifdef NEED_USER32_WRAPPER

LRESULT FORWARD_API WINAPI
CallWindowProcWrapW(
    WNDPROC lpPrevWndFunc,
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    VALIDATE_PROTOTYPE(CallWindowProc);

    // perf: better still would be to have a g_pfnCallWndProc, init it 1x,
    // and then jmp indirect w/o the test.  it would cost us a ptr but we
    // only do it for the top-2 funcs (CallWindowProc and SendMessage)
    FORWARD_AW(CallWindowProc, (lpPrevWndFunc, hWnd, Msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

STDAPI_(BOOL FORWARD_API) CallMsgFilterWrapW(LPMSG lpMsg, int nCode)
{
    VALIDATE_PROTOTYPE(CallMsgFilter);

    FORWARD_AW(CallMsgFilter, (lpMsg, nCode));
}

#endif // NEED_USER32_WRAPPER



//----------------------------------------------------------------------
//
// function:    CharLowerWrapW( LPWSTR pch )
//
// purpose:     Converts character to lowercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Lowercased character or string.  In the string case,
//              the lowercasing is done inplace.
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

LPWSTR WINAPI
CharLowerWrapW( LPWSTR pch )
{
    VALIDATE_PROTOTYPE(CharLower);

    if (g_bRunningOnNT)
    {
        return CharLowerW( pch );
    }

    if (!HIWORD64(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharLowerBuffWrapW( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharLowerBuffWrapW( pch, lstrlenW(pch) );
    }

    return pch;
}

#endif // NEED_USER32_WRAPPER


//----------------------------------------------------------------------
//
// function:    CharLowerBuffWrapW( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to lowercase.  String must be cch
//              characters in length.
//
// returns:     Character count (cch).  The lowercasing is done inplace.
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

DWORD WINAPI
CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength )
{
    VALIDATE_PROTOTYPE(CharLowerBuff);

    if (g_bRunningOnNT)
    {
        return CharLowerBuffW( pch, cchLength );
    }

    DWORD cch;

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharUpperWrapW(ch))
        {
            if (ch < 0x0100)
            {
                *pch += 32;             // Get Latin-1 out of the way first
            }
            else if (ch < 0x0531)
            {
                if (ch < 0x0391)
                {
                    if (ch < 0x01cd)
                    {
                        if (ch <= 0x178)
                        {
                            if (ch < 0x0178)
                            {
                                *pch += (ch == 0x0130) ? 0 : 1;
                            }
                            else
                            {
                                *pch -= 121;
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                            {  // 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
            /* 0x0179-0x17f */           1,   0,   1,   0,   1,   0,   0,
            /* 0x0180-0x187 */      0, 210,   1,   0,   1,   0, 206,   1,
            /* 0x0188-0x18f */      0, 205, 205,   1,   0,   0,  79, 202,
            /* 0x0190-0x197 */    203,   1,   0, 205, 207,   0, 211, 209,
            /* 0x0198-0x19f */      1,   0,   0,   0, 211, 213,   0, 214,
            /* 0x01a0-0x1a7 */      1,   0,   1,   0,   1,   0,   0,   1,
            /* 0x01a8-0x1af */      0, 218,   0,   0,   1,   0, 218,   1,
            /* 0x01b0-0x1b7 */      0, 217, 217,   1,   0,   1,   0, 219,
            /* 0x01b8-0x1bf */      1,   0,   0,   0,   1,   0,   0,   0,
            /* 0x01c0-0x1c7 */      0,   0,   0,   0,   2,   0,   0,   2,
            /* 0x01c8-0x1cb */      0,   0,   2,   0
                            };

                            *pch += abLookup[ch-0x0179];
                        }
                    }
                    else if (ch < 0x0386)
                    {
                        switch (ch)
                        {
                            case 0x01f1: *pch += 2; break;
                            case 0x01f2: break;
                            default: *pch += 1;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                            { 38, 0, 37, 37, 37, 0, 64, 0, 63, 63 };

                        *pch += abLookup[ch-0x0386];
                    }
                }
                else
                {
                    if (ch < 0x0410)
                    {
                        if (ch < 0x0401)
                        {
                            if (ch < 0x03e2)
                            {
                                if (!InRange(ch, 0x03d2, 0x03d4) &&
                                    !(InRange(ch, 0x3da, 0x03e0) & !(ch & 1)))
                                {
                                    *pch += 32;
                                }
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else
                        {
                            *pch += 80;
                        }
                    }
                    else
                    {
                        if (ch < 0x0460)
                        {
                            *pch += 32;
                        }
                        else
                        {
                            *pch += 1;
                        }
                    }
                }
            }
            else
            {
                if (ch < 0x2160)
                {
                    if (ch < 0x1fba)
                    {
                        if (ch < 0x1f08)
                        {
                            if (ch < 0x1e00)
                            {
                                *pch += 48;
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else if (!(InRange(ch, 0x1f88, 0x1faf) && (ch & 15)>7))
                        {
                            *pch -= 8;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                        {  // 8    9    a    b    c    d    e    f
                              0,   0,  74,  74,   0,   0,   0,   0,
                             86,  86,  86,  86,   0,   0,   0,   0,
                              8,   8, 100, 100,   0,   0,   0,   0,
                              8,   8, 112, 112,   7,   0,   0,   0,
                            128, 128, 126, 126,   0,   0,   0,   0
                        };
                        int i = (ch-0x1fb0);

                        *pch -= (int)abLookup[((i>>1) & ~7) | (i & 7)];
                    }
                }
                else
                {
                    if (ch < 0xff21)
                    {
                        if (ch < 0x24b6)
                        {
                            *pch += 16;
                        }
                        else
                        {
                            *pch += 26;
                        }
                    }
                    else
                    {
                        *pch += 32;
                    }
                }
            }
        }
        else
        {
            // These are Unicode Number Forms.  They have lowercase counter-
            // parts, but are not considered uppercase.  Why, I don't know.

            if (InRange(ch, 0x2160, 0x216f))
            {
                *pch += 16;
            }
        }
    }

    return cchLength;
}

#endif // NEED_USER32_WRAPPER

//
// REARCHITECT - Do CharNextWrap and CharPrevWrap need to call the
//          CharNextW, CharPrevW on WinNT?  Couldn't these be MACROS?
//

LPWSTR WINAPI
CharNextWrapW(LPCWSTR lpszCurrent)
{
    VALIDATE_PROTOTYPE(CharNext);

    if (*lpszCurrent)
    {
        return (LPWSTR) lpszCurrent + 1;
    }
    else
    {
        return (LPWSTR) lpszCurrent;
    }
}

LPWSTR WINAPI
CharPrevWrapW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
{
    VALIDATE_PROTOTYPE(CharPrev);

    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}


#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
CharToOemWrapW(LPCWSTR lpszSrc, LPSTR lpszDst)
{
    VALIDATE_PROTOTYPE(CharToOem);

    if (g_bRunningOnNT)
    {
        CharToOemW(lpszSrc, lpszDst);
    }

    CStrIn  str(lpszSrc);

    return CharToOemA(str, lpszDst);
}

#endif // NEED_USER32_WRAPPER

//----------------------------------------------------------------------
//
// function:    CharUpperWrapW( LPWSTR pch )
//
// purpose:     Converts character to uppercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Uppercased character or string.  In the string case,
//              the uppercasing is done inplace.
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

LPWSTR WINAPI
CharUpperWrapW( LPWSTR pch )
{
    VALIDATE_PROTOTYPE(CharUpper);

    if (g_bRunningOnNT)
    {
        return CharUpperW( pch );
    }

    if (!HIWORD64(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharUpperBuffWrapW( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharUpperBuffWrapW( pch, lstrlenW(pch) );
    }

    return pch;
}

#endif // NEED_USER32_WRAPPER


//----------------------------------------------------------------------
//
// function:    CharUpperBuffWrapW( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to uppercase.  String must be cch
//              characters in length.  Note that this function is
//              is messier that CharLowerBuffWrap, and the reason for
//              this is many Unicode characters are considered uppercase,
//              even when they don't have an uppercase counterpart.
//
// returns:     Character count (cch).  The uppercasing is done inplace.
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

DWORD WINAPI
CharUpperBuffWrapW( LPWSTR pch, DWORD cchLength )
{
    VALIDATE_PROTOTYPE(CharUpperBuff);

    if (g_bRunningOnNT)
    {
        return CharUpperBuffW( pch, cchLength );
    }

    DWORD cch;

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharLowerWrapW(ch))
        {
            if (ch < 0x00ff)
            {
                *pch -= ((ch != 0xdf) << 5);
            }
            else if (ch < 0x03b1)
            {
                if (ch < 0x01f5)
                {
                    if (ch < 0x01ce)
                    {
                        if (ch < 0x017f)
                        {
                            if (ch < 0x0101)
                            {
                                *pch += 121;
                            }
                            else
                            {
                                *pch -= (ch != 0x0131 &&
                                         ch != 0x0138 &&
                                         ch != 0x0149);
                            }
                        }
                        else if (ch < 0x01c9)
                        {
                            static const BYTE abMask[] =
                            {                       // 6543210f edcba987
                                0xfc, 0xbf,         // 11111100 10111111
                                0xbf, 0x67,         // 10111111 01100111
                                0xff, 0xef,         // 11111111 11101111
                                0xff, 0xf7,         // 11111111 11110111
                                0xbf, 0xfd          // 10111111 11111101
                            };

                            int i = ch - 0x017f;

                            *pch -= ((abMask[i>>3] >> (i&7)) & 1) +
                                    (ch == 0x01c6);
                        }
                        else
                        {
                            *pch -= ((ch != 0x01cb)<<1);
                        }
                    }
                    else
                    {
                        if (ch < 0x01df)
                        {
                            if (ch < 0x01dd)
                            {
                                *pch -= 1;
                            }
                            else
                            {
                                *pch -= 79;
                            }
                        }
                        else
                        {
                            *pch -= 1 + (ch == 0x01f3) -
                                    InRange(ch,0x01f0,0x01f2);
                        }
                    }
                }
                else if (ch < 0x0253)
                {
                    *pch -= (ch < 0x0250);
                }
                else if (ch < 0x03ac)
                {
                    static const BYTE abLookup[] =
                    {// 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
    /* 0x0253-0x0257 */                210, 206,   0, 205, 205,
    /* 0x0258-0x025f */   0, 202,   0, 203,   0,   0,   0,   0,
    /* 0x0260-0x0267 */ 205,   0,   0, 207,   0,   0,   0,   0,
    /* 0x0268-0x026f */ 209, 211,   0,   0,   0,   0,   0, 211,
    /* 0x0270-0x0277 */   0,   0, 213,   0,   0, 214,   0,   0,
    /* 0x0278-0x027f */   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0x0280-0x0287 */   0,   0,   0, 218,   0,   0,   0,   0,
    /* 0x0288-0x028f */ 218,   0, 217, 217,   0,   0,   0,   0,
    /* 0x0290-0x0297 */   0,   0, 219
                    };

                    if (ch <= 0x0292)
                    {
                        *pch -= abLookup[ch - 0x0253];
                    }
                }
                else
                {
                    *pch -= (ch == 0x03b0) ? 0 : (37 + (ch == 0x03ac));
                }
            }
            else
            {
                if (ch < 0x0561)
                {
                    if (ch < 0x0451)
                    {
                        if (ch < 0x03e3)
                        {
                            if (ch < 0x03cc)
                            {
                                *pch -= 32 - (ch == 0x03c2);
                            }
                            else
                            {
                                int i = (ch < 0x03d0);
                                *pch -= (i<<6) - i + (ch == 0x03cc);
                            }
                        }
                        else if (ch < 0x0430)
                        {
                            *pch -= (ch < 0x03f0);
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                    else if (ch < 0x0461)
                    {
                        *pch -= 80;
                    }
                    else
                    {
                        *pch -= 1;
                    }
                }
                else
                {
                    if (ch < 0x1fb0)
                    {
                        if (ch < 0x1f70)
                        {
                            if (ch < 0x1e01)
                            {
                                int i = ch != 0x0587 && ch < 0x10d0;
                                *pch -= ((i<<5)+(i<<4)); /* 48 */
                            }
                            else if (ch < 0x1f00)
                            {
                                *pch -= !InRange(ch, 0x1e96, 0x1e9a);
                            }
                            else
                            {
                                int i = !InRange(ch, 0x1f50, 0x1f56)||(ch & 1);
                                *pch += (i<<3);
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                                { 74, 86, 86, 100, 128, 112, 126 };

                            if ( ch <= 0x1f7d )
                            {
                                *pch += abLookup[(ch-0x1f70)>>1];
                            }
                        }
                    }
                    else
                    {
                        if (ch < 0x24d0)
                        {
                            if (ch < 0x1fe5)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 8 : 0;
                            }
                            else if (ch < 0x2170)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 7 : 0;
                            }
                            else
                            {
                                *pch -= ((ch > 0x24b5)<<4);
                            }
                        }
                        else if (ch < 0xff41)
                        {
                            int i = !InRange(ch, 0xfb00, 0xfb17);
                            *pch -= (i<<4)+(i<<3)+(i<<1); /* 26 */
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                }
            }
        }
        else
        {
            int i = InRange(ch, 0x2170, 0x217f);
            *pch -= (i<<4);
        }
    }

    return cchLength;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int FORWARD_API WINAPI
CopyAcceleratorTableWrapW(
        HACCEL  hAccelSrc,
        LPACCEL lpAccelDst,
        int     cAccelEntries)
{
    VALIDATE_PROTOTYPE(CopyAcceleratorTable);

    FORWARD_AW(CopyAcceleratorTable, (hAccelSrc, lpAccelDst, cAccelEntries));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HACCEL FORWARD_API WINAPI
CreateAcceleratorTableWrapW(LPACCEL lpAccel, int cEntries)
{
    VALIDATE_PROTOTYPE(CreateAcceleratorTable);

    FORWARD_AW(CreateAcceleratorTable, (lpAccel, cEntries));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER
typedef HDC (*FnCreateHDCA)(LPCSTR, LPCSTR, LPCSTR, CONST DEVMODEA *);

HDC WINAPI
CreateHDCWrapW(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData,
        FnCreateHDCA        pfn)
{
    DEVMODEA *  pdevmode = NULL;
    CStrIn      strDriver(lpszDriver);
    CStrIn      strDevice(lpszDevice);
    CStrIn      strOutput(lpszOutput);
    HDC         hdcReturn = 0;

    if (lpInitData)
    {
        pdevmode = (DEVMODEA *) LocalAlloc( LPTR, lpInitData->dmSize + lpInitData->dmDriverExtra );

        if (pdevmode)
        {
            // LPBYTE->LPSTR casts below
            SHUnicodeToAnsi(lpInitData->dmDeviceName, (LPSTR)pdevmode->dmDeviceName, ARRAYSIZE(pdevmode->dmDeviceName));
            memcpy(&pdevmode->dmSpecVersion,
                    &lpInitData->dmSpecVersion,
                    FIELD_OFFSET(DEVMODEW,dmFormName) - FIELD_OFFSET(DEVMODEW,dmSpecVersion));
            SHUnicodeToAnsi(lpInitData->dmFormName, (LPSTR)pdevmode->dmFormName, ARRAYSIZE(pdevmode->dmFormName));
            memcpy(&pdevmode->dmLogPixels,
                    &lpInitData->dmLogPixels,
                    lpInitData->dmDriverExtra + lpInitData->dmSize - FIELD_OFFSET(DEVMODEW, dmLogPixels));

            pdevmode->dmSize -= (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME);
        }
    }

    hdcReturn = (*pfn)(strDriver, strDevice, strOutput, pdevmode);

    if (pdevmode)
    {
        LocalFree(pdevmode);
    }

    return hdcReturn;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

HDC WINAPI
CreateDCWrapW(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
    VALIDATE_PROTOTYPE(CreateDC);

    if (g_bRunningOnNT)
    {
        return CreateDCW(lpszDriver, lpszDevice, lpszOutput, lpInitData);
    }
    return CreateHDCWrapW(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateDCA);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

HDC WINAPI
CreateICWrapW(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
    VALIDATE_PROTOTYPE(CreateIC);

    if (g_bRunningOnNT)
    {
        return CreateICW(lpszDriver, lpszDevice, lpszOutput, lpInitData);
    }

    return CreateHDCWrapW(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateICA);
}

#endif // NEED_GDI32_WRAPPER


#undef CreateDialogIndirectParamW

HWND WINAPI
CreateDialogIndirectParamWrapW(
        HINSTANCE       hInstance,
        LPCDLGTEMPLATEW hDialogTemplate,
        HWND            hWndParent,
        DLGPROC         lpDialogFunc,
        LPARAM          dwInitParam)
{
    VALIDATE_PROTOTYPE(CreateDialogIndirectParam);

    if (fDoMungeUI(hInstance))
    {
        return MLCreateDialogIndirectParamI(
                    hInstance,
                    hDialogTemplate,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam);
    }
    
    if (g_bRunningOnNT)
    {
        return CreateDialogIndirectParamW(
                    hInstance,
                    hDialogTemplate,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam);
    }

    return CreateDialogIndirectParamA(
                hInstance,
                hDialogTemplate,
                hWndParent,
                lpDialogFunc,
                dwInitParam);
}


#undef CreateDialogParamW

HWND WINAPI
CreateDialogParamWrapW(
        HINSTANCE   hInstance,
        LPCWSTR     lpTemplateName,
        HWND        hWndParent,
        DLGPROC     lpDialogFunc,
        LPARAM      dwInitParam)
{
    VALIDATE_PROTOTYPE(CreateDialogParam);
    ASSERT(HIWORD64(lpTemplateName) == 0);

    if (fDoMungeUI(hInstance))
        return MLCreateDialogParamI(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        
    if (g_bRunningOnNT)
    {
        return CreateDialogParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
    }

    return CreateDialogParamA(hInstance, (LPSTR) lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}


#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
CreateDirectoryWrapW(
        LPCWSTR                 lpPathName,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes)
{
    VALIDATE_PROTOTYPE(CreateDirectory);

    if (g_bRunningOnNT)
    {
        return CreateDirectoryW(lpPathName, lpSecurityAttributes);
    }

    CStrIn  str(lpPathName);

    ASSERT(!lpSecurityAttributes);
    return CreateDirectoryA(str, lpSecurityAttributes);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI
CreateEventWrapW(
        LPSECURITY_ATTRIBUTES   lpEventAttributes,
        BOOL                    bManualReset,
        BOOL                    bInitialState,
        LPCWSTR                 lpName)
{
    VALIDATE_PROTOTYPE(CreateEvent);

    //Totally bogus assert.
    //ASSERT(!lpName);

    // cast means we can't use FORWARD_AW
    if (g_bRunningOnNT)
    {
        return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
    }

    return CreateEventA(lpEventAttributes, bManualReset, bInitialState, (LPCSTR)lpName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI
CreateFileWrapW(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile)
{
    VALIDATE_PROTOTYPE(CreateFile);

    if (g_bRunningOnNT)
    {
        return CreateFileW(
                lpFileName,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);
    }

    CStrIn  str(lpFileName);

    return CreateFileA(
            str,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

HFONT WINAPI
CreateFontIndirectWrapW(CONST LOGFONTW * plfw)
{
    VALIDATE_PROTOTYPE(CreateFontIndirect);

    if (g_bRunningOnNT)
    {
        return CreateFontIndirectW(plfw);
    }

    LOGFONTA  lfa;
    HFONT     hFont;

    memcpy(&lfa, plfw, FIELD_OFFSET(LOGFONTA, lfFaceName));
    SHUnicodeToAnsi(plfw->lfFaceName, lfa.lfFaceName, ARRAYSIZE(lfa.lfFaceName));
    hFont = CreateFontIndirectA(&lfa);

    return hFont;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HWND WINAPI
CreateWindowExWrapW(
        DWORD       dwExStyle,
        LPCWSTR     lpClassName,
        LPCWSTR     lpWindowName,
        DWORD       dwStyle,
        int         X,
        int         Y,
        int         nWidth,
        int         nHeight,
        HWND        hWndParent,
        HMENU       hMenu,
        HINSTANCE   hInstance,
        LPVOID      lpParam)
{
    VALIDATE_PROTOTYPE(CreateWindowEx);

    if (g_bRunningOnNT)
    {
        return CreateWindowExW(
                dwExStyle,
                lpClassName,
                lpWindowName,
                dwStyle,
                X,
                Y,
                nWidth,
                nHeight,
                hWndParent,
                hMenu,
                hInstance,
                lpParam);
    }

    CStrIn  strClass(lpClassName);
    CStrIn  strWindow(lpWindowName);

    return CreateWindowExA(
            dwExStyle,
            strClass,
            strWindow,
            dwStyle,
            X,
            Y,
            nWidth,
            nHeight,
            hWndParent,
            hMenu,
            hInstance,
            lpParam);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LRESULT FORWARD_API WINAPI DefWindowProcWrapW(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    VALIDATE_PROTOTYPE(DefWindowProc);

    FORWARD_AW(DefWindowProc, (hWnd, msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI DeleteFileWrapW(LPCWSTR pwsz)
{
    VALIDATE_PROTOTYPE(DeleteFile);

    if (g_bRunningOnNT)
    {
        return DeleteFileW(pwsz);
    }

    CStrIn  str(pwsz);

    return DeleteFileA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#undef DialogBoxIndirectParamW

INT_PTR WINAPI
DialogBoxIndirectParamWrapW(
        HINSTANCE       hInstance,
        LPCDLGTEMPLATEW hDialogTemplate,
        HWND            hWndParent,
        DLGPROC         lpDialogFunc,
        LPARAM          dwInitParam)
{
    VALIDATE_PROTOTYPE(DialogBoxIndirectParam);

    if (fDoMungeUI(hInstance))
        return MLDialogBoxIndirectParamI(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);

    if (g_bRunningOnNT)
    {
        return DialogBoxIndirectParamW(
                    hInstance,
                    hDialogTemplate,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam);
    }

    return DialogBoxIndirectParamA(
                hInstance,
                hDialogTemplate,
                hWndParent,
                lpDialogFunc,
                dwInitParam);
}


#undef DialogBoxParamW

INT_PTR WINAPI
DialogBoxParamWrapW(
        HINSTANCE   hInstance,
        LPCWSTR     lpszTemplate,
        HWND        hWndParent,
        DLGPROC     lpDialogFunc,
        LPARAM      dwInitParam)
{
    VALIDATE_PROTOTYPE(DialogBoxParam);
    ASSERT(HIWORD64(lpszTemplate) == 0);

    if (fDoMungeUI(hInstance))
        return MLDialogBoxParamI(hInstance, lpszTemplate, hWndParent, lpDialogFunc, dwInitParam);

    if (g_bRunningOnNT)
    {
        return DialogBoxParamW(
                    hInstance,
                    lpszTemplate,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam);
    }

    return DialogBoxParamA(hInstance, (LPCSTR) lpszTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

#ifdef NEED_USER32_WRAPPER

LRESULT FORWARD_API WINAPI
DispatchMessageWrapW(CONST MSG * lpMsg)
{
    VALIDATE_PROTOTYPE(DispatchMessage);

    FORWARD_AW(DispatchMessage, (lpMsg));
}

#endif // NEED_USER32_WRAPPER

BOOL _MayNeedFontLinking(LPCWSTR lpStr, UINT cch)
{
#ifndef UNIX
    //
    // Scan the string to see if we might need to use font linking to draw it.
    // If you've got a better way of doing this, I'd love to hear it.
    //
    BOOL fRet = FALSE;

    int cChars = ((cch == -1) ? lstrlenW(lpStr) : cch);

    for (int i=0; i < cChars; i++)
    {
        if (lpStr[i] > 127)
        {
            fRet = TRUE;
            break;
        }
    }
    return fRet;
#else
    return FALSE;
#endif
}

#ifdef NEED_USER32_WRAPPER

int WINAPI
DrawTextWrapW(
        HDC     hDC,
        LPCWSTR lpString,
        int     nCount,
        LPRECT  lpRect,
        UINT    uFormat)
{
    VALIDATE_PROTOTYPE(DrawText);

    if (_MayNeedFontLinking(lpString, nCount))
    {
        return DrawTextFLW(hDC, lpString, nCount, lpRect, uFormat);
    }
    else if (g_bRunningOnNT)
    {
        return DrawTextW(hDC, lpString, nCount, lpRect, uFormat);
    }
    CStrIn  str(lpString, nCount);
    return DrawTextA(hDC, str, str.strlen(), lpRect, uFormat);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

struct EFFSTAT
{
    LPARAM          lParam;
    FONTENUMPROC    lpEnumFontProc;
    BOOL            fFamilySpecified;
};

int CALLBACK
EnumFontFamiliesCallbackWrap(
        ENUMLOGFONTA *  lpelf,
        NEWTEXTMETRIC * lpntm,
        DWORD           FontType,
        LPARAM          lParam)
{
    ENUMLOGFONTW    elf;

    //  Convert strings from ANSI to Unicode
    if (((EFFSTAT *)lParam)->fFamilySpecified && (FontType & TRUETYPE_FONTTYPE) )
    {
        // LPBYTE->LPCSTR cast below
        SHAnsiToUnicode((LPCSTR)lpelf->elfFullName, elf.elfFullName, ARRAYSIZE(elf.elfFullName));
        SHAnsiToUnicode((LPCSTR)lpelf->elfStyle, elf.elfStyle, ARRAYSIZE(elf.elfStyle));
    }
    else
    {
        elf.elfStyle[0] = L'\0';
        elf.elfFullName[0] = L'\0';
    }

    SHAnsiToUnicode(lpelf->elfLogFont.lfFaceName, elf.elfLogFont.lfFaceName, ARRAYSIZE(elf.elfLogFont.lfFaceName));

    //  Copy the non-string data
    memcpy(
            &elf.elfLogFont,
            &lpelf->elfLogFont,
            FIELD_OFFSET(LOGFONTA, lfFaceName));

    //  Chain to the original callback function
    return (*((EFFSTAT *) lParam)->lpEnumFontProc)(
            (const LOGFONTW *)&elf,
            (const TEXTMETRICW *) lpntm,
            FontType,
            ((EFFSTAT *) lParam)->lParam);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

int WINAPI
EnumFontFamiliesWrapW(
        HDC          hdc,
        LPCWSTR      lpszFamily,
        FONTENUMPROC lpEnumFontProc,
        LPARAM       lParam)
{
    VALIDATE_PROTOTYPE(EnumFontFamilies);

    if (g_bRunningOnNT)
    {
        return EnumFontFamiliesW(
                hdc,
                lpszFamily,
                lpEnumFontProc,
                lParam);
    }

    CStrIn  str(lpszFamily);
    EFFSTAT effstat;

    effstat.lParam = lParam;
    effstat.lpEnumFontProc = lpEnumFontProc;
    effstat.fFamilySpecified = lpszFamily != NULL;

    return EnumFontFamiliesA(
            hdc,
            str,
            (FONTENUMPROCA) EnumFontFamiliesCallbackWrap,
            (LPARAM) &effstat);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

int WINAPI
EnumFontFamiliesExWrapW(
        HDC          hdc,
        LPLOGFONTW   lplfw,
        FONTENUMPROC lpEnumFontProc,
        LPARAM       lParam,
        DWORD        dwFlags )
{
    VALIDATE_PROTOTYPE(EnumFontFamiliesEx);

    if (g_bRunningOnNT)
    {
        return EnumFontFamiliesExW(
                hdc,
                lplfw,
                lpEnumFontProc,
                lParam,
                dwFlags);
    }

    LOGFONTA lfa;
    CStrIn   str(lplfw->lfFaceName);
    EFFSTAT  effstat;

    ASSERT( FIELD_OFFSET(LOGFONTW, lfFaceName) == FIELD_OFFSET(LOGFONTA, lfFaceName) );

    memcpy( &lfa, lplfw, sizeof(LOGFONTA) - FIELD_OFFSET(LOGFONTA, lfFaceName) );
    memcpy( lfa.lfFaceName, str, LF_FACESIZE );
    lfa.lfFaceName[LF_FACESIZE - 1] = 0x00;

    effstat.lParam = lParam;
    effstat.lpEnumFontProc = lpEnumFontProc;
    effstat.fFamilySpecified = lplfw->lfFaceName != NULL;

    return EnumFontFamiliesExA(
            hdc,
            &lfa,
            (FONTENUMPROCA) EnumFontFamiliesCallbackWrap,
            (LPARAM) &effstat,
            dwFlags );
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
EnumResourceNamesWrapW(
        HINSTANCE        hModule,
        LPCWSTR          lpType,
        ENUMRESNAMEPROCW lpEnumFunc,
        LPARAM           lParam)
{
    VALIDATE_PROTOTYPE(EnumResourceNames);
    ASSERT(HIWORD64(lpType) == 0);

    if (g_bRunningOnNT)
    {
        return EnumResourceNamesW(hModule, lpType, lpEnumFunc, lParam);
    }

    return EnumResourceNamesA(hModule, (LPCSTR) lpType, (ENUMRESNAMEPROCA)lpEnumFunc, lParam);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI
FindFirstFileWrapW(
        LPCWSTR             lpFileName,
        LPWIN32_FIND_DATAW  pwszFd)
{
    VALIDATE_PROTOTYPE(FindFirstFile);

    if (g_bRunningOnNT)
    {
        return FindFirstFileW(lpFileName, pwszFd);
    }

    CStrIn              str(lpFileName);
    CWin32FindDataInOut fd(pwszFd);

    return FindFirstFileA(str, fd);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HRSRC WINAPI
FindResourceWrapW(HINSTANCE hModule, LPCWSTR lpName, LPCWSTR lpType)
{
    VALIDATE_PROTOTYPE(FindResource);

    if (g_bRunningOnNT)
    {
        return FindResourceW(hModule, lpName, lpType);
    }

    // NOTE: The FindResourceW exists on Win9x, but Win95 and Win98
    // have a bug where they make two bogus call to LocalFree to try
    // to free up the passed-in buffers that they did not allocate.
    //
    // We work around by always wrapping.  Another solution that Godot uses:
    //
    // For win95/98 only:
    // 1) Copy the two params to stack-alloc'ed variables
    // 2) Call the "W" function with the variables from step #1
    // 3) Clear out last error when it is ERROR_INVALID_HANDLE (the error that the 
    //    bogus LocalFree call in the OS will cause
    // This gives proper Unicode behavior to both functions on all Win9x platforms.

    CStrIn  strName(lpName);
    CStrIn strType(lpType);

    return FindResourceA(hModule, strName, strType);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HWND WINAPI
FindWindowWrapW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
{
    VALIDATE_PROTOTYPE(FindWindow);

    if (g_bRunningOnNT)
    {
        return FindWindowW(lpClassName, lpWindowName);
    }

    // Let FindWindowExWrapW do the thunking
    return FindWindowExWrapW(NULL, NULL, lpClassName, lpWindowName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HWND WINAPI
FindWindowExWrapW(HWND hwndParent, HWND hwndChildAfter, LPCWSTR pwzClassName, LPCWSTR pwzWindowName)
{
    VALIDATE_PROTOTYPE(FindWindowEx);

    if (g_bRunningOnNT)
        return FindWindowExW(hwndParent, hwndChildAfter, pwzClassName, pwzWindowName);


    CStrIn  strClass(pwzClassName);
    CStrIn  strWindow(pwzWindowName);

    return FindWindowExA(hwndParent, hwndChildAfter, strClass, strWindow);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

//
// FindNextArgInfo - Finds the argument format and argument number from a FormatMessage like template
//
// Returns - True if arg is wide string, False if other
//
BOOL FindNextArgInfo(LPCWSTR *pszTemplate, UINT *puiNum, LPWSTR pszFormat, UINT cchFormat)
{
    BOOL fRet = FALSE;
    
    if(*pszTemplate == NULL)
        return(FALSE);

    LPCWSTR psz = *pszTemplate;
    LPCWSTR pszT1 = NULL;
    LPCWSTR pszT2 = NULL;
    LPWSTR pszFmt = pszFormat;
    BOOL fHaveStart = FALSE;
    UINT cchFmt;

    *puiNum = 0;

    if(cchFormat > 0)
    {
        *pszFmt = TEXT('%');
        pszFmt++;
        cchFormat--;
    }

    if(*psz >= TEXT('1') && *psz <= TEXT('9'))
    {
        for(; *psz; psz++)
        {
            if(*psz == TEXT('!'))
            {
                if(fHaveStart)  // Done
                {
                    pszT2 = ++psz;  // Mark end of type
                    break;
                }
                else
                {
                    fHaveStart = TRUE;
                    psz++;
                    if(pszT1 == NULL)
                        pszT1 = psz;  // Mark start of arg format string
                }
            }

            if(!fHaveStart) // Get arg number
            {
                if(*psz >= TEXT('0') && *psz <= TEXT('9'))
                    *puiNum = (*puiNum * 10) + (*psz - TEXT('0'));
                else
                    break;
            }
        }

        if(*puiNum == 0)
            return(FALSE);
    }
    else    // Special format specifier
    {
        pszT1 = psz;
        pszT2 = psz+1;
    }

    if(pszT1 != NULL)    // We have an arg format string
    {
        cchFmt = cchFormat;
        if(cchFmt > (UINT)(pszT2 - pszT1))
            cchFmt = (pszT2 - pszT1); 
        StrCpyN(pszFmt, pszT1, cchFmt);

        // Is argument type a string
        if(StrChrI(pszFormat, TEXT('s')))
        {
            fRet = TRUE;
        }
        else
        {
            cchFmt = cchFormat;
            if(cchFmt > (UINT)(pszT2 - *pszTemplate)+1)
                cchFmt = (pszT2 - *pszTemplate)+1; 
            StrCpyN(pszFmt, *pszTemplate, cchFmt);
        }
    }
    else    // No arg format string, FormatMessage default is !s!
    {
        pszT2 = psz;
        fRet = TRUE;
        cchFmt = cchFormat;
        if(cchFmt > 3)
            cchFmt = 3;
        StrCpyN(pszFmt, TEXT("ws"), cchFmt);
    }

    *pszTemplate = pszT2;   // Move template string beyond this format specifier

    return(fRet);
}

//
// The following is used to work around Win9x FormatMessage problems related to converting 
// DBCS strings to Unicode.
//                     
#define FML_BUFFER_SIZE 1024
#define FML_BUFFER_INC   256

DWORD
FormatMessageLiteW(
    DWORD       dwFlags,
    LPCWSTR     lpSource,
    PVOID *     pDest,
    DWORD       nSize,
    va_list *   Arguments)
{
    BOOL fIsStr;
    UINT uiNum;
    UINT uiDataCnt = 0;
    va_list pArgList = *Arguments;
    va_list pArgList2;
    WCHAR *pszBuf2;
    WCHAR szFmt[256];
    VOID *pData[10];
    LPCWSTR psz = lpSource;
    LPCWSTR psz1 = NULL;
    LPWSTR lpBuffer;
    INT cchBufUsed = 0;
    INT cchBuf2;
    INT cch;

    if(lpSource == NULL || pDest == NULL || Arguments == NULL)
        return(0);

    if(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
    {
        nSize = max(nSize, FML_BUFFER_SIZE);
        if((lpBuffer = (WCHAR *)LocalAlloc(LPTR, nSize * sizeof(WCHAR))) == NULL)
            return(0);
    }
    else
    {
        if(nSize == 0)
            return(0);
        lpBuffer = (LPWSTR)pDest;
    }

    cchBuf2 = nSize + lstrlen(lpSource);
    if((pszBuf2 = (WCHAR *)LocalAlloc(LPTR, cchBuf2 * sizeof(WCHAR))) != NULL)
    {
        *lpBuffer = TEXT('\0');
        while(*psz)
        {
            if(*psz == TEXT('%'))
            {
                psz++;
                if(psz1 != NULL)    // Copy any previous text to the buffer
                {
                    if((cch = psz - psz1) > (INT)(nSize - cchBufUsed))
                    {
                        if(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
                        {
                            LPWSTR lpRealloc;
                            nSize = max(FML_BUFFER_INC, cch);
                            if((lpRealloc = (WCHAR *)LocalReAlloc(lpBuffer, nSize * sizeof(WCHAR), LMEM_ZEROINIT | LMEM_MOVEABLE)) == NULL)
                            {
                                LocalFree(lpBuffer);
                                LocalFree(pszBuf2);
                                return(0);
                            }
                            lpBuffer = lpRealloc;
                        }
                        else
                        {
                            RIPMSG(FALSE, "Output buffer not large enough.  Truncating.");
                            cch = nSize - cchBufUsed;
                        }
                    }
                    StrCpyNW(lpBuffer+cchBufUsed, psz1, cch);
                    cchBufUsed += cch-1;
                    psz1 = NULL;
                }

                fIsStr = FindNextArgInfo(&psz, &uiNum, szFmt, ARRAYSIZE(szFmt));

                if(fIsStr)
                {
                    if(uiNum > uiDataCnt)
                    {
                        for(UINT i = uiDataCnt; i < uiNum; i++)    // Find the iTH argument
                        {
                            pData[i] = va_arg(pArgList, VOID *);
                            uiDataCnt++;
                        }
                    }
                        
                    cch = wnsprintfW(pszBuf2, cchBuf2, szFmt, pData[uiNum-1]);
                    if(cch == cchBuf2)
                    {
                        RIPMSG(FALSE, "Param buffer may be too small. Output string may be truncated.");
                    }
                }
                else
                {
                    // Call FormatMessage on non-string arguments
                    pArgList2 = *Arguments;
                    CStrIn strSource(CP_ACP, (LPCWSTR)szFmt, -1);
                    CStrOut str(pszBuf2, cchBuf2);
                    FormatMessageA(FORMAT_MESSAGE_FROM_STRING, strSource, 0, 0, str, str.BufSize(), &pArgList2);
                    cch = str.ConvertExcludingNul();
                }

                if(cch > 0)
                {
                    if(cch > (INT)(nSize - cchBufUsed))
                    {
                        if(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
                        {
                            LPWSTR lpRealloc;
                            nSize += max(FML_BUFFER_INC, cch);
                            if((lpRealloc = (WCHAR *)LocalReAlloc(lpBuffer, nSize * sizeof(WCHAR), LMEM_ZEROINIT | LMEM_MOVEABLE)) == NULL)
                            {
                                LocalFree(lpBuffer);
                                LocalFree(pszBuf2);
                                return(0);
                            }
                            lpBuffer = lpRealloc;
                        }
                        else
                        {
                            RIPMSG(FALSE, "Output buffer not large enough.  Truncating.");
                            cch = nSize - cchBufUsed;
                        }
                    }
                    StrCpyW(lpBuffer+cchBufUsed, pszBuf2);
                    cchBufUsed += cch;
                }
                else
                {
                    RIPMSG(FALSE, "Argument string conversion failed.  Argument not copied to output buffer");
                }
                continue;
            }

            if(psz1 == NULL)
                psz1 = psz;    // Start of text block

            psz++;
        }

        if(psz1)    // Copy any remaining text to the output buffer
        {
            if((cch = (psz - psz1)+1) > (INT)(nSize - cchBufUsed))
            {
                if(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
                {
                    LPWSTR lpRealloc;
                    nSize = max(FML_BUFFER_INC, cch);
                    if((lpRealloc = (WCHAR *)LocalReAlloc(lpBuffer, nSize * sizeof(WCHAR), LMEM_ZEROINIT | LMEM_MOVEABLE)) == NULL)
                    {
                        LocalFree(lpBuffer);
                        LocalFree(pszBuf2);
                        return(0);
                    }
                    lpBuffer = lpRealloc;
                }
                else
                {
                    RIPMSG(FALSE, "Output buffer not large enough.  Truncating.");
                    cch = nSize - cchBufUsed;
                }
            }
            StrCpyNW(lpBuffer+cchBufUsed, psz1, cch);
            cchBufUsed += cch - 1;  // substract the null from the count
        }

        LocalFree(pszBuf2);
        pszBuf2 = NULL;
    }

    if(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
    {
        *pDest = (PVOID *)lpBuffer;
    }
    
    return((DWORD)cchBufUsed);
}

DWORD WINAPI
FormatMessageWrapW(
    DWORD       dwFlags,
    LPCVOID     lpSource,
    DWORD       dwMessageId,
    DWORD       dwLanguageId,
    LPWSTR      lpBuffer,
    DWORD       nSize,
    va_list *   Arguments)
{
    VALIDATE_PROTOTYPE(FormatMessage);
    if (!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER))
    {
        VALIDATE_OUTBUF(lpBuffer, nSize);
    }

    DWORD dwResult;

    if (g_bRunningOnNT)
    {
        dwResult = FormatMessageW(
                       dwFlags,
                       lpSource,
                       dwMessageId,
                       dwLanguageId,
                       lpBuffer,
                       nSize,
                       Arguments);
    }
    else
    {
        #ifdef DEBUG
        // If a source string is passed, make sure that all string insertions
        // have explicit character set markers.  Otherwise, you get random
        // behavior depending on whether we need to thunk to ANSI or not.
        // (We are not clever enough to thunk the inserts; that's the caller's
        // responsibility.)
        //
        if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
        {
            LPCWSTR pwsz;
            for (pwsz = (LPCWSTR)lpSource; *pwsz; pwsz++)
            {
                if (*pwsz == L'%')
                {
                    pwsz++;
                    // Found an insertion.  Get the digit or two.
                    if (*pwsz == L'0')
                        continue;       // "%0" is special
                    if (*pwsz < L'0' || *pwsz > L'9')
                        continue;        // skip % followed by nondigit
                    pwsz++;            // Skip the digit
                    if (*pwsz >= L'0' && *pwsz <= L'9')
                        pwsz++;        // Skip the optional second digit
                    // The next character MUST be an exclamation point!
                    ASSERT(*pwsz == L'!' &&
                           "FormatMessageWrapW: All string insertions must have explicit character sets.");
                    // I'm not going to validate that the insertion contains
                    // an explicit character set override because if you went
                    // so far as to do a %n!...!, you'll get the last bit right too.
                }
            }
        }
        #endif

        //
        //  FORMAT_MESSAGE_FROM_STRING means that the source is a string.
        //  Otherwise, it's an opaque LPVOID (aka, an atom).
        //
        if(((dwFlags == FORMAT_MESSAGE_FROM_STRING) || 
            (dwFlags == (FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER))) &&
           (dwMessageId == 0) && (dwLanguageId == 0))
        {
            TraceMsg(TF_WARNING, "This is a lite version of FormatMessage.  It may not act as you expect.");
            dwResult = FormatMessageLiteW(dwFlags, (LPCWSTR)lpSource, (PVOID *)lpBuffer, nSize, Arguments);
        }
        else
        {
            CStrIn strSource((dwFlags & FORMAT_MESSAGE_FROM_STRING) ? CP_ACP : CP_ATOM,
                             (LPCWSTR)lpSource, -1);

            if (!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER))
            {
                CStrOut str(lpBuffer, nSize);
                FormatMessageA(
                        dwFlags,
                        strSource,
                        dwMessageId,
                        dwLanguageId,
                        str,
                        str.BufSize(),
                        Arguments);         // We don't handle Arguments != NULL

                dwResult = str.ConvertExcludingNul();
            }
            else
            {
                LPSTR pszBuffer = NULL;
                LPWSTR * ppwzOut = (LPWSTR *)lpBuffer;

                *ppwzOut = NULL;
                FormatMessageA(
                        dwFlags,
                        strSource,
                        dwMessageId,
                        dwLanguageId,
                        (LPSTR)&pszBuffer,
                        0,
                        Arguments);

                if (pszBuffer)
                {
                    DWORD cchSize = (lstrlenA(pszBuffer) + 1);
                    LPWSTR pszThunkedBuffer;

                    if (cchSize < nSize)
                        cchSize = nSize;

                    pszThunkedBuffer = (LPWSTR) LocalAlloc(LPTR, cchSize * sizeof(WCHAR));
                    if (pszThunkedBuffer)
                    {
                        *ppwzOut = pszThunkedBuffer;
                        SHAnsiToUnicode(pszBuffer, pszThunkedBuffer, cchSize);
                    }

                    LocalFree(pszBuffer);
                }
                dwResult = (*ppwzOut ? lstrlenW(*ppwzOut) : 0);
            }
        }
    }

    return dwResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
GetClassInfoWrapW(HINSTANCE hModule, LPCWSTR lpClassName, LPWNDCLASSW lpWndClassW)
{
    VALIDATE_PROTOTYPE(GetClassInfo);

    if (g_bRunningOnNT)
    {
        return GetClassInfoW(hModule, lpClassName, lpWndClassW);
    }

    BOOL    ret;

    CStrIn  strClassName(lpClassName);

    ASSERT(sizeof(WNDCLASSA) == sizeof(WNDCLASSW));

    ret = GetClassInfoA(hModule, strClassName, (LPWNDCLASSA) lpWndClassW);

    lpWndClassW->lpszMenuName = NULL;
    lpWndClassW->lpszClassName = NULL;
    return ret;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

DWORD FORWARD_API WINAPI
GetClassLongWrapW(HWND hWnd, int nIndex)
{
    VALIDATE_PROTOTYPE(GetClassLong);

    FORWARD_AW(GetClassLong, (hWnd, nIndex));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetClassNameWrapW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
{
    VALIDATE_PROTOTYPE(GetClassName);
    VALIDATE_OUTBUF(lpClassName, nMaxCount);

    if (g_bRunningOnNT)
    {
        return GetClassNameW(hWnd, lpClassName, nMaxCount);
    }

    CStrOut strClassName(lpClassName, nMaxCount);

    GetClassNameA(hWnd, strClassName, strClassName.BufSize());
    return strClassName.ConvertIncludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetClipboardFormatNameWrapW(UINT format, LPWSTR lpFormatName, int cchFormatName)
{
    VALIDATE_PROTOTYPE(GetClipboardFormatName);
    VALIDATE_OUTBUF(lpFormatName, cchFormatName);

    if (g_bRunningOnNT)
    {
        return GetClipboardFormatNameW(format, lpFormatName, cchFormatName);
    }

    CStrOut strFormatName(lpFormatName, cchFormatName);

    GetClipboardFormatNameA(format, strFormatName, strFormatName.BufSize());
    return strFormatName.ConvertIncludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetCurrentDirectoryWrapW(DWORD nBufferLength, LPWSTR lpBuffer)
{
    VALIDATE_PROTOTYPE(GetCurrentDirectory);
    VALIDATE_OUTBUF(lpBuffer, nBufferLength);

    if (g_bRunningOnNT)
    {
        return GetCurrentDirectoryW(nBufferLength, lpBuffer);
    }

    CStrOut str(lpBuffer, nBufferLength);

    GetCurrentDirectoryA(str.BufSize(), str);
    return str.ConvertExcludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

UINT WINAPI
GetDlgItemTextWrapW(
        HWND    hWndDlg,
        int     idControl,
        LPWSTR  lpsz,
        int     cchMax)
{
    VALIDATE_PROTOTYPE(GetDlgItemText);
    VALIDATE_OUTBUF(lpsz, cchMax);

    HWND hWnd = GetDlgItem(hWndDlg, idControl);

    if (hWnd)
        return GetWindowTextWrapW(hWnd, lpsz, cchMax);

    /*
     * If we couldn't find the window, just null terminate lpch so that the
     * app doesn't gp fault if it tries to run through the text.
      */
    if (cchMax)
        *lpsz = (WCHAR)0;

    return 0;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetFileAttributesWrapW(LPCWSTR lpFileName)
{
    VALIDATE_PROTOTYPE(GetFileAttributes);

    if (g_bRunningOnNT)
    {
        return GetFileAttributesW(lpFileName);
    }

    CStrIn  str(lpFileName);

    return GetFileAttributesA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI
GetLocaleInfoWrapW(LCID Locale, LCTYPE LCType, LPWSTR lpsz, int cchData)
{
    VALIDATE_PROTOTYPE(GetLocaleInfo);
    VALIDATE_OUTBUF(lpsz, cchData);

    if (g_bRunningOnNT)
    {
        return GetLocaleInfoW(Locale, LCType, lpsz, cchData);
    }

    CStrOut str(lpsz, cchData);

    GetLocaleInfoA(Locale, LCType, str, str.BufSize());
    return str.ConvertIncludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
GetMessageWrapW(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax)
{
    VALIDATE_PROTOTYPE(GetMessage);

    FORWARD_AW(GetMessage, (lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetModuleFileNameWrapW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize)
{
    VALIDATE_PROTOTYPE(GetModuleFileName);
    VALIDATE_OUTBUF(pwszFilename, nSize);

    if (g_bRunningOnNT)
    {
        return GetModuleFileNameW(hModule, pwszFilename, nSize);
    }

    CStrOut str(pwszFilename, nSize);

    GetModuleFileNameA(hModule, str, str.BufSize());
    return str.ConvertIncludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

UINT WINAPI
GetSystemDirectoryWrapW(LPWSTR lpBuffer, UINT uSize)
{
    VALIDATE_PROTOTYPE(GetSystemDirectory);
    VALIDATE_OUTBUF(lpBuffer, uSize);

    if (g_bRunningOnNT)
    {
        return GetSystemDirectoryW(lpBuffer, uSize);
    }

    CStrOut str(lpBuffer, uSize);

    GetSystemDirectoryA(str, str.BufSize());
    return str.ConvertExcludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
SearchPathWrapW(
        LPCWSTR lpPathName,
        LPCWSTR lpFileName,
        LPCWSTR lpExtension,
        DWORD   cchReturnBuffer,
        LPWSTR  lpReturnBuffer,
        LPWSTR *  plpfilePart)
{
    VALIDATE_PROTOTYPE(SearchPath);
    VALIDATE_OUTBUF(lpReturnBuffer, cchReturnBuffer);

    if (g_bRunningOnNT)
    {
        return SearchPathW(
            lpPathName,
            lpFileName,
            lpExtension,
            cchReturnBuffer,
            lpReturnBuffer,
            plpfilePart);
    }

    CStrIn  strPath(lpPathName);
    CStrIn  strFile(lpFileName);
    CStrIn  strExtension(lpExtension);
    CStrOut strReturnBuffer(lpReturnBuffer, cchReturnBuffer);

    DWORD dwLen = SearchPathA(
            strPath,
            strFile,
            strExtension,
            strReturnBuffer.BufSize(),
            strReturnBuffer,
            (LPSTR *)plpfilePart);

    //
    // Getting the correct value for plpfilePart requires
    // a strrchr on the converted string.  If this value
    // is needed, just add the code to do it here.
    //

    *plpfilePart = NULL;

    if (cchReturnBuffer == 0)
        dwLen = 2*dwLen;
    else
        dwLen = strReturnBuffer.ConvertExcludingNul();

    return dwLen;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HMODULE WINAPI
GetModuleHandleWrapW(LPCWSTR lpModuleName)
{
    VALIDATE_PROTOTYPE(GetModuleHandle);

    if (g_bRunningOnNT)
    {
        return GetModuleHandleW(lpModuleName);
    }

    CStrIn  str(lpModuleName);
    return GetModuleHandleA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

int WINAPI
GetObjectWrapW(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
    VALIDATE_PROTOTYPE(GetObject);

    if (g_bRunningOnNT)
    {
        return GetObjectW(hgdiObj, cbBuffer, lpvObj);
    }

    int nRet;

    if(cbBuffer != sizeof(LOGFONTW))
    {
        nRet = GetObjectA(hgdiObj, cbBuffer, lpvObj);
    }
    else
    {
        LOGFONTA lfa;

        nRet = GetObjectA(hgdiObj, sizeof(lfa), &lfa);
        if (nRet > 0)
        {
            memcpy(lpvObj, &lfa, FIELD_OFFSET(LOGFONTW, lfFaceName));
            SHAnsiToUnicode(lfa.lfFaceName, ((LOGFONTW*)lpvObj)->lfFaceName, ARRAYSIZE(((LOGFONTW*)lpvObj)->lfFaceName));
            nRet = sizeof(LOGFONTW);
        }
    }

    return nRet;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

LPITEMIDLIST WINAPI SHBrowseForFolderWrapW(LPBROWSEINFOW pbiW)
{
    if (UseUnicodeShell32())
    {
        return SHBrowseForFolderW(pbiW);
    }

    LPITEMIDLIST pidl = NULL;
    ASSERT(pbiW);
    if (pbiW)
    {
        CStrIn strTitle(pbiW->lpszTitle);
        CStrOut strDisplayName(pbiW->pszDisplayName, MAX_PATH);
        BROWSEINFOA biA;

        biA = * (LPBROWSEINFOA) pbiW;
        biA.lpszTitle = strTitle;
        biA.pszDisplayName = strDisplayName;

        pidl = SHBrowseForFolderA(&biA);
        if (pidl)
        {
            strDisplayName.ConvertIncludingNul();
        }
    }

    return pidl;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

BOOL WINAPI SHGetPathFromIDListWrapW(LPCITEMIDLIST pidl, LPWSTR pwzPath)
{
    if (UseUnicodeShell32())
    {
        return SHGetPathFromIDListW(pidl, pwzPath);
    }

    CStrOut strPathOut(pwzPath, MAX_PATH);
    BOOL fResult = SHGetPathFromIDListA(pidl, strPathOut);
    if (fResult)
    {
        strPathOut.ConvertIncludingNul();
    }

    return fResult;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER
BOOL WINAPI ShellExecuteExWrapW(LPSHELLEXECUTEINFOW pExecInfoW)
{
    if (g_bRunningOnNT)
    {
        return ShellExecuteExW(pExecInfoW);
    }

    BOOL fResult = FALSE;
    ASSERT(pExecInfoW);
    if (pExecInfoW)
    {
        SHELLEXECUTEINFOA ExecInfoA;

        CStrIn strVerb(pExecInfoW->lpVerb);
        CStrIn strParameters(pExecInfoW->lpParameters);
        CStrIn strDirectory(pExecInfoW->lpDirectory);
        CStrIn strClass(pExecInfoW->lpClass);
        CHAR szFile[MAX_PATH + INTERNET_MAX_URL_LENGTH + 2];


        ExecInfoA = *(LPSHELLEXECUTEINFOA) pExecInfoW;
        ExecInfoA.lpVerb = strVerb;
        ExecInfoA.lpParameters = strParameters;
        ExecInfoA.lpDirectory = strDirectory;
        ExecInfoA.lpClass = strClass;

        if (pExecInfoW->lpFile)
        {
            ExecInfoA.lpFile = szFile;
            SHUnicodeToAnsi(pExecInfoW->lpFile, szFile, ARRAYSIZE(szFile));

            // SEE_MASK_FILEANDURL passes "file\0url".  What a hack!
            if (pExecInfoW->fMask & SEE_MASK_FILEANDURL)
            {
                // We are so lucky that Win9x implements lstrlenW
                int cch = lstrlenW(pExecInfoW->lpFile) + 1;
                cch += lstrlenW(pExecInfoW->lpFile + cch) + 1;
                if (!WideCharToMultiByte(CP_ACP, 0, pExecInfoW->lpFile, cch, szFile, ARRAYSIZE(szFile), NULL, NULL))
                {
                    // Return a completely random error code
                    pExecInfoW->hInstApp = (HINSTANCE)SE_ERR_OOM;
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return FALSE;
                }
            }
        }

        fResult = ShellExecuteExA(&ExecInfoA);

        // Out parameters
        pExecInfoW->hInstApp = ExecInfoA.hInstApp;
        pExecInfoW->hProcess = ExecInfoA.hProcess;
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return fResult;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

int WINAPI SHFileOperationWrapW(LPSHFILEOPSTRUCTW pFileOpW)
{
    // We don't thunk multiple files.
    ASSERT(pFileOpW);
    ASSERT(!(pFileOpW->fFlags & FOF_MULTIDESTFILES));

    if (UseUnicodeShell32())
    {
        return SHFileOperationW(pFileOpW);
    }

    int nResult = 1;    // non-Zero is failure.
    if (pFileOpW)
    {
        SHFILEOPSTRUCTA FileOpA;
        CStrIn strTo(pFileOpW->pTo);
        CStrIn strFrom(pFileOpW->pFrom);
        CStrIn strProgressTitle(pFileOpW->lpszProgressTitle);

        FileOpA = *(LPSHFILEOPSTRUCTA) pFileOpW;
        FileOpA.pFrom = strFrom;
        FileOpA.pTo = strTo;
        FileOpA.lpszProgressTitle = strProgressTitle;


        nResult = SHFileOperationA(&FileOpA);
    }

    return nResult;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

UINT WINAPI ExtractIconExWrapW(LPCWSTR pwzFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons)
{
    if (UseUnicodeShell32())
    {
        return ExtractIconExW(pwzFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
    }

    CStrIn str(pwzFile);
    return ExtractIconExA(str, nIconIndex, phiconLarge, phiconSmall, nIcons);
}

#endif // NEED_SHELL32_WRAPPER


#ifdef NEED_SHELL32_WRAPPER
//
// Shell_GetCachedImageIndexWrapA/W are exported from shlwapi.
// Only the W version should be in NEED_SHELL32_WRAPPER
int WINAPI Shell_GetCachedImageIndexWrapW(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    if (UseUnicodeShell32())
    {
        return Shell_GetCachedImageIndex(pszIconPath, iIconIndex, uIconFlags);
    }

    CStrIn  strIconPath(pszIconPath);
    return Shell_GetCachedImageIndex((LPCWSTR)((void*)(strIconPath)), iIconIndex, uIconFlags);
}
#endif // NEED_SHELL32_WRAPPER

int WINAPI Shell_GetCachedImageIndexWrapA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    if (UseUnicodeShell32())
    {
        WCHAR szIconPath[MAX_PATH];
        SHAnsiToUnicode(pszIconPath, szIconPath, ARRAYSIZE(szIconPath));
        return Shell_GetCachedImageIndex(szIconPath, iIconIndex, uIconFlags);
    }
    
    return Shell_GetCachedImageIndex((LPCWSTR)((void*)(pszIconPath)), iIconIndex, uIconFlags);
}


#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI SetFileAttributesWrapW(LPCWSTR pwzFile, DWORD dwFileAttributes)
{
    VALIDATE_PROTOTYPE(SetFileAttributes);

    if (g_bRunningOnNT)
        return SetFileAttributesW(pwzFile, dwFileAttributes);

    CStrIn  str(pwzFile);
    return SetFileAttributesA(str, dwFileAttributes);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI GetNumberFormatWrapW(LCID Locale, DWORD dwFlags, LPCWSTR pwzValue, CONST NUMBERFMTW * pFormatW, LPWSTR pwzNumberStr, int cchNumber)
{
    VALIDATE_PROTOTYPE(GetNumberFormat);

    if (g_bRunningOnNT)
        return GetNumberFormatW(Locale, dwFlags, pwzValue, pFormatW, pwzNumberStr, cchNumber);

    int nResult;
    NUMBERFMTA FormatA;
    CStrIn  strValue(pwzValue);
    CStrIn  strDecimalSep(pFormatW ? pFormatW->lpDecimalSep : NULL);
    CStrIn  strThousandSep(pFormatW ? pFormatW->lpThousandSep : NULL);
    CStrOut strNumberStr(pwzNumberStr, cchNumber);

    if (pFormatW)
    {
        FormatA = *(NUMBERFMTA *) pFormatW;
        FormatA.lpDecimalSep = strDecimalSep;
        FormatA.lpThousandSep = strThousandSep;
    }

    nResult = GetNumberFormatA(Locale, dwFlags, strValue, (pFormatW ? &FormatA : NULL), strNumberStr, strNumberStr.BufSize());
    if (ERROR_SUCCESS == nResult)
        strNumberStr.ConvertIncludingNul();

    return nResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI MessageBoxWrapW(HWND hwnd, LPCWSTR pwzText, LPCWSTR pwzCaption, UINT uType)
{
    VALIDATE_PROTOTYPE(MessageBox);

    if (g_bRunningOnNT)
        return MessageBoxW(hwnd, pwzText, pwzCaption, uType);

    CStrIn  strCaption(pwzCaption);
    CStrIn  strText(pwzText);
    return MessageBoxA(hwnd, strText, strCaption, uType);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI FindNextFileWrapW(HANDLE hSearchHandle, LPWIN32_FIND_DATAW pFindFileDataW)
{
    VALIDATE_PROTOTYPE(FindNextFile);

    if (g_bRunningOnNT)
        return FindNextFileW(hSearchHandle, pFindFileDataW);

    CWin32FindDataInOut fd(pFindFileDataW);
    return FindNextFileA(hSearchHandle, fd);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

//--------------------------------------------------------------
//      GetFullPathNameWrap
//--------------------------------------------------------------

DWORD
WINAPI
GetFullPathNameWrapW( LPCWSTR lpFileName,
                     DWORD  nBufferLength,
                     LPWSTR lpBuffer,
                     LPWSTR *lpFilePart)
{
    VALIDATE_PROTOTYPE(GetFullPathName);
    VALIDATE_OUTBUF(lpBuffer, nBufferLength);

    if (g_bRunningOnNT)
    {
        return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);
    }

    CStrIn  strIn(lpFileName);
    CStrOut  strOut(lpBuffer,nBufferLength);
    LPSTR   pFile;
    DWORD   dwRet;

    dwRet = GetFullPathNameA(strIn, nBufferLength, strOut, &pFile);
    strOut.ConvertIncludingNul();
    // REARCHITECT raymondc - This is wrong if we had to do DBCS or related goo
    *lpFilePart = lpBuffer + (pFile - strOut);
    return dwRet;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetShortPathNameWrapW(
    LPCWSTR lpszLongPath,
    LPWSTR  lpszShortPath,
    DWORD   cchBuffer)
{
    VALIDATE_PROTOTYPE(GetShortPathName);

    if (g_bRunningOnNT)
    {
        return GetShortPathNameW(lpszLongPath, lpszShortPath, cchBuffer);

    }

    CStrIn strLongPath(lpszLongPath);
    CStrOut strShortPath(lpszShortPath, cchBuffer);

    return GetShortPathNameA(strLongPath, strShortPath, strShortPath.BufSize());
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
GetStringTypeExWrapW(LCID lcid, DWORD dwInfoType, LPCTSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
{
    VALIDATE_PROTOTYPE(GetStringTypeEx);

    if (g_bRunningOnNT)
    {
        return GetStringTypeExW(lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType);
    }

    CStrIn  str(lpSrcStr, cchSrc);
    return GetStringTypeExA(lcid, dwInfoType, str, str.strlen(), lpCharType);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

UINT WINAPI
GetPrivateProfileIntWrapW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        INT     nDefault,
        LPCWSTR lpFileName)
{
    VALIDATE_PROTOTYPE(GetPrivateProfileInt);

    if (g_bRunningOnNT)
    {
        return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, lpFileName);
    }

    CStrIn  strApp(lpAppName);
    CStrIn  strKey(lpKeyName);
    CPPFIn  strFile(lpFileName); // PrivateProfile filename needs special class

    return GetPrivateProfileIntA(strApp, strKey, nDefault, strFile);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetProfileStringWrapW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        LPCWSTR lpDefault,
        LPWSTR  lpBuffer,
        DWORD   dwBuffersize)
{
    VALIDATE_PROTOTYPE(GetProfileString);
    VALIDATE_OUTBUF(lpBuffer, dwBuffersize);

    if (g_bRunningOnNT)
    {
        return GetProfileStringW(lpAppName, lpKeyName, lpDefault, lpBuffer, dwBuffersize);
    }

    CStrIn  strApp(lpAppName);
    CStrIn  strKey(lpKeyName);
    CStrIn  strDefault(lpDefault);
    CStrOut strBuffer(lpBuffer, dwBuffersize);

    GetProfileStringA(strApp, strKey, strDefault, strBuffer, dwBuffersize);
    return strBuffer.ConvertIncludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HANDLE WINAPI
GetPropWrapW(HWND hWnd, LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(GetProp);

    if (g_bRunningOnNT)
    {
        return GetPropW(hWnd, lpString);
    }

    CStrIn  str(lpString);

    return GetPropA(hWnd, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

UINT WINAPI
GetTempFileNameWrapW(
        LPCWSTR lpPathName,
        LPCWSTR lpPrefixString,
        UINT    uUnique,
        LPWSTR  lpTempFileName)
{
    VALIDATE_PROTOTYPE(GetTempFileName);
    VALIDATE_OUTBUF(lpTempFileName, MAX_PATH);

    if (g_bRunningOnNT)
    {
        return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);
    }


    CStrIn  strPath(lpPathName);
    CStrIn  strPrefix(lpPrefixString);
    CStrOut strFileName(lpTempFileName, MAX_PATH);

    return GetTempFileNameA(strPath, strPrefix, uUnique, strFileName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetTempPathWrapW(DWORD nBufferLength, LPWSTR lpBuffer)
{
    VALIDATE_PROTOTYPE(GetTempPath);
    VALIDATE_OUTBUF(lpBuffer, nBufferLength);

    if (g_bRunningOnNT)
    {
        return GetTempPathW(nBufferLength, lpBuffer);
    }


    CStrOut str(lpBuffer, nBufferLength);

    GetTempPathA(str.BufSize(), str);
    return str.ConvertExcludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

BOOL APIENTRY
GetTextExtentPoint32WrapW(
        HDC     hdc,
        LPCWSTR pwsz,
        int     cb,
        LPSIZE  pSize)
{
    VALIDATE_PROTOTYPE(GetTextExtentPoint32);

    if (_MayNeedFontLinking(pwsz, cb))
    {
        return GetTextExtentPointFLW(hdc, pwsz, cb, pSize);
    }
    else if (g_bRunningOnNT)
    {
        return GetTextExtentPoint32W(hdc, pwsz, cb, pSize);
    }

    CStrIn str(pwsz,cb);

    return GetTextExtentPoint32A(hdc, str, str.strlen(), pSize);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

int WINAPI
GetTextFaceWrapW(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName)
{
    VALIDATE_PROTOTYPE(GetTextFace);
    VALIDATE_OUTBUF(lpFaceName, cch);

    if (g_bRunningOnNT)
    {
        return GetTextFaceW(hdc, cch, lpFaceName);
    }


    CStrOut str(lpFaceName, cch);

    GetTextFaceA(hdc, str.BufSize(), str);
    return str.ConvertIncludingNul();
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

BOOL WINAPI
GetTextMetricsWrapW(HDC hdc, LPTEXTMETRICW lptm)
{
    VALIDATE_PROTOTYPE(GetTextMetrics);

    if (g_bRunningOnNT)
    {
        return GetTextMetricsW(hdc, lptm);
    }


   BOOL         ret;
   TEXTMETRICA  tm;

    ret = GetTextMetricsA(hdc, &tm);

    if (ret)
    {
        lptm->tmHeight              = tm.tmHeight;
        lptm->tmAscent              = tm.tmAscent;
        lptm->tmDescent             = tm.tmDescent;
        lptm->tmInternalLeading     = tm.tmInternalLeading;
        lptm->tmExternalLeading     = tm.tmExternalLeading;
        lptm->tmAveCharWidth        = tm.tmAveCharWidth;
        lptm->tmMaxCharWidth        = tm.tmMaxCharWidth;
        lptm->tmWeight              = tm.tmWeight;
        lptm->tmOverhang            = tm.tmOverhang;
        lptm->tmDigitizedAspectX    = tm.tmDigitizedAspectX;
        lptm->tmDigitizedAspectY    = tm.tmDigitizedAspectY;
        lptm->tmItalic              = tm.tmItalic;
        lptm->tmUnderlined          = tm.tmUnderlined;
        lptm->tmStruckOut           = tm.tmStruckOut;
        lptm->tmPitchAndFamily      = tm.tmPitchAndFamily;
        lptm->tmCharSet             = tm.tmCharSet;

        // LPBYTE -> LPCSTR casts below
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&tm.tmFirstChar, 1, &lptm->tmFirstChar, 1);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&tm.tmLastChar, 1, &lptm->tmLastChar, 1);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&tm.tmDefaultChar, 1, &lptm->tmDefaultChar, 1);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&tm.tmBreakChar, 1, &lptm->tmBreakChar, 1);
    }

    return ret;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

BOOL WINAPI GetUserNameWrapW(LPWSTR pszBuffer, LPDWORD pcch)
{
    VALIDATE_PROTOTYPE(GetUserName);

    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = GetUserNameW(pszBuffer, pcch);
    }
    else
    {
        CStrOut stroBuffer(pszBuffer, *pcch);

        fRet = GetUserNameA(stroBuffer, pcch);

        if (fRet)
            *pcch = stroBuffer.ConvertIncludingNul();
    }

    return fRet;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LONG FORWARD_API WINAPI
GetWindowLongWrapW(HWND hWnd, int nIndex)
{
    VALIDATE_PROTOTYPE(GetWindowLong);

    FORWARD_AW(GetWindowLong, (hWnd, nIndex));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetWindowTextWrapW(HWND hWnd, LPWSTR lpString, int nMaxCount)
{
    VALIDATE_PROTOTYPE(GetWindowText);
    VALIDATE_OUTBUF(lpString, nMaxCount);

    if (MLIsEnabled(hWnd))
        return MLGetControlTextI(hWnd, lpString, nMaxCount);

    if (g_bRunningOnNT)
    {
        return GetWindowTextW(hWnd, lpString, nMaxCount);
    }


    CStrOut str(lpString, nMaxCount);

    GetWindowTextA(hWnd, str, str.BufSize());
    return str.ConvertExcludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetWindowTextLengthWrapW(HWND hWnd)
{
    VALIDATE_PROTOTYPE(GetWindowTextLength);

    if (g_bRunningOnNT)
    {
        return GetWindowTextLengthW(hWnd);
    }

    return GetWindowTextLengthA(hWnd);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

UINT WINAPI
GetWindowsDirectoryWrapW(LPWSTR lpWinPath, UINT cch)
{
    VALIDATE_PROTOTYPE(GetWindowsDirectory);
    VALIDATE_OUTBUF(lpWinPath, cch);

    if (g_bRunningOnNT)
    {
        return GetWindowsDirectoryW(lpWinPath, cch);
    }

    CStrOut str(lpWinPath, cch);

    GetWindowsDirectoryA(str, str.BufSize());

    return str.ConvertExcludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

STDAPI_(DWORD) WINAPI
GetEnvironmentVariableWrapW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
{
    VALIDATE_PROTOTYPE(GetEnvironmentVariable);
    VALIDATE_OUTBUF(lpBuffer, nSize);

    if (g_bRunningOnNT)
    {
        return GetEnvironmentVariableW(lpName,lpBuffer, nSize);
    }

    CStrOut str(lpBuffer, nSize);
    CStrIn  strName(lpName);

    GetEnvironmentVariableA(strName, str, str.BufSize());
    return str.ConvertExcludingNul();

}


#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
IsDialogMessageWrapW(HWND hWndDlg, LPMSG lpMsg)
{
    VALIDATE_PROTOTYPE(IsDialogMessage);

    FORWARD_AW(IsDialogMessage, (hWndDlg, lpMsg));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HACCEL WINAPI
LoadAcceleratorsWrapW(HINSTANCE hInstance, LPCWSTR lpTableName)
{
    VALIDATE_PROTOTYPE(LoadAccelerators);
    ASSERT(HIWORD64(lpTableName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadAcceleratorsW(hInstance, lpTableName);
    }

    return LoadAcceleratorsA(hInstance, (LPCSTR) lpTableName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HBITMAP WINAPI
LoadBitmapWrapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
    VALIDATE_PROTOTYPE(LoadBitmap);
    ASSERT(HIWORD64(lpBitmapName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadBitmapW(hInstance, lpBitmapName);
    }

    return LoadBitmapA(hInstance, (LPCSTR) lpBitmapName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HCURSOR WINAPI
LoadCursorWrapW(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
    VALIDATE_PROTOTYPE(LoadCursor);
    ASSERT(HIWORD64(lpCursorName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadCursorW(hInstance, lpCursorName);
    }

    return LoadCursorA(hInstance, (LPCSTR) lpCursorName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HICON WINAPI
LoadIconWrapW(HINSTANCE hInstance, LPCWSTR lpIconName)
{
    VALIDATE_PROTOTYPE(LoadIcon);
    ASSERT(HIWORD64(lpIconName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadIconW(hInstance, lpIconName);
    }

    return LoadIconA(hInstance, (LPCSTR) lpIconName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

//+-------------------------------------------------------------------------
// Returns an icon from a dll/exe loaded as a datafile.  Note that this is 
// very similar to the standard LoadImage API.  However, LoadImage does
// not work properly (returns bogus icons) on win95/98 when the dll is
// loaded as a datafile.  (Stevepro 18-Sept-98)
//--------------------------------------------------------------------------
HICON _LoadIconFromInstanceA
(
    HINSTANCE hInstance,    // instance containing the icon
    LPCSTR pszName,         // name or id of icon
    int cxDesired,
    int cyDesired,
    UINT fuLoad             // load flags, LR_DEFAULTCOLOR | LR_MONOCHROME
) 
{ 
    HICON hIcon;

    UINT fUnsupportedFlags = ~(LR_DEFAULTCOLOR | LR_MONOCHROME);
    if (fuLoad & fUnsupportedFlags)
    {
        // We saw a flag that we don't support, so default to the standard API
        hIcon = (HICON)LoadImageA(hInstance, pszName, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
    }
    else
    {
        // Find the group icon 
        HRSRC hRsrc; 
        HGLOBAL hGlobal; 
        PBYTE pIconDir;

        if ((hRsrc = FindResourceA(hInstance, pszName, (LPCSTR)RT_GROUP_ICON)) == NULL ||
            (hGlobal = LoadResource(hInstance, hRsrc)) == NULL || 
            (pIconDir = (PBYTE)LockResource(hGlobal)) == NULL)
        {
            // Note that FreeResource and UnlockResource are obsolete APIs, so we just exit.
            return NULL; 
        }
 
        // Find the icon that best matches the desired size 
        int nID = LookupIconIdFromDirectoryEx(pIconDir, TRUE, cxDesired, cyDesired, fuLoad); 

        PBYTE pbRes; 
        if (0 == nID ||
            (hRsrc = FindResourceA(hInstance, MAKEINTRESOURCEA(nID), (LPCSTR)RT_ICON)) == NULL ||
            (hGlobal = LoadResource(hInstance, hRsrc)) == NULL || 
            (pbRes = (PBYTE)LockResource(hGlobal)) == NULL)
        {
            return NULL; 
        }

        // Let the OS make us an icon 
        LPBITMAPINFOHEADER pbmh = (LPBITMAPINFOHEADER)pbRes;
        hIcon = CreateIconFromResourceEx(pbRes, SizeofResource(hInstance, hRsrc), TRUE, 0x00030000,  
                pbmh->biWidth, pbmh->biHeight/2, fuLoad); 
     
        // It failed, odds are good we're on NT so try the non-Ex way 
        if (hIcon == NULL) 
        { 
            // We would break on NT if we try with a 16bpp image 
            if(pbmh->biBitCount != 16) 
            { 
                hIcon = CreateIconFromResource(pbRes, SizeofResource(hInstance, hRsrc), TRUE, 0x00030000); 
            } 
        } 
    }

    return hIcon; 
}

HANDLE WINAPI
LoadImageWrapA(
        HINSTANCE hInstance,
        LPCSTR lpName,
        UINT uType,
        int cxDesired,
        int cyDesired,
        UINT fuLoad)
{
    VALIDATE_PROTOTYPE(LoadImage);

    //
    // If the hInstance is loaded as a datafile, LoadImage returns the 
    // wrong icons on win95/98.  (Kernel can't find the datafile and uses
    // null instead)
    //
    // APPCOMPAT: Should also fix loading other resource types from datafiles
    //
    if (!g_bRunningOnNT && uType == IMAGE_ICON)
    {
        return _LoadIconFromInstanceA(
                hInstance,
                lpName,
                cxDesired,
                cyDesired,
                fuLoad);
    }

    return LoadImageA(
        hInstance,
        lpName,
        uType,
        cxDesired,
        cyDesired,
        fuLoad);
}


HANDLE WINAPI
LoadImageWrapW(
        HINSTANCE hInstance,
        LPCWSTR lpName,
        UINT uType,
        int cxDesired,
        int cyDesired,
        UINT fuLoad)
{
    VALIDATE_PROTOTYPE(LoadImage);

    if (g_bRunningOnNT)
    {
        return LoadImageW(
            hInstance,
            lpName,
            uType,
            cxDesired,
            cyDesired,
            fuLoad);
    }

    CStrIn  str(lpName);

    return LoadImageWrapA(
            hInstance,
            str,
            uType,
            cxDesired,
            cyDesired,
            fuLoad);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HINSTANCE WINAPI
LoadLibraryExWrapW(
        LPCWSTR lpLibFileName,
        HANDLE  hFile,
        DWORD   dwFlags)
{
    VALIDATE_PROTOTYPE(LoadLibraryEx);

    if (g_bRunningOnNT)
        return LoadLibraryExW(lpLibFileName, hFile, dwFlags);

    CStrIn  str(lpLibFileName);

    // Win9X will crash if the pathname is longer than MAX_PATH bytes.

    if (str.strlen() >= MAX_PATH)
    {
        SetLastError( ERROR_BAD_PATHNAME );
        return NULL;
    }
    else
    {
        return LoadLibraryExA(str, hFile, dwFlags);
    }
}

#endif // NEED_KERNEL32_WRAPPER

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL fDoMungeLangId(LANGID lidUI);

BOOL NeedMenuOwnerDraw(void)
{
    // FEATURE: need to be improved
    //         It checks whether current UI language is cross codepage or not
    if (g_bRunningOnNT5OrHigher)
        return FALSE;

    return fDoMungeLangId(MLGetUILanguage());
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

#define PUI_OWNERDRAW_SIG   0xFFFF0000

// NOTE: This structure is only visible from subclassed OwnerDrawSubclassProc
//       with WM_DRAWITEM and WM_MEASUREITEM. All other places won't see this
//       structure. We restore original format MENUITEMINFO structure without
//       MFT_OWNERDRAW flag unless it's a real owner draw item.
//       For this, we do/undo munge in Get/SetMenuItemInfo and InsertMenuItem.

typedef struct tagPUIMENUITEM
{
    DWORD  dwSig;       // signature for this structure
    HMENU  hmenu;       // menu handle
    UINT   fMask;       // original MENUITEMINFO fMask value
    UINT   fType;       // original MENUITEMINFO fType value
    DWORD_PTR dwItemData; // original MENUITEMINFO dwItemData value
    LPWSTR lpwz;        // unicode menu string
    UINT   cch;         // number of character for menu string
    UINT   iTabLength;
} PUIMENUITEM, *LPPUIMENUITEM;

void MungeMenuItem(HMENU hMenu, LPCMENUITEMINFOW lpmiiW, LPMENUITEMINFOW lpmiiNewW)
{
    if (lpmiiW && lpmiiNewW)
    {
        *lpmiiNewW = *lpmiiW;

        if ((MIIM_TYPE & lpmiiW->fMask) && !(MFT_NONSTRING & lpmiiW->fType))
        {
            LPWSTR lpmenuText = (LPWSTR)lpmiiW->dwTypeData;

            if (lpmenuText)
            {
                LPPUIMENUITEM lpItem = (LPPUIMENUITEM)LocalAlloc(LPTR, sizeof(PUIMENUITEM));

                if (lpItem)
                {
                    lpItem->dwSig = PUI_OWNERDRAW_SIG;
                    lpItem->hmenu = hMenu;
                    lpItem->fMask = lpmiiW->fMask;
                    lpItem->fType = lpmiiW->fType;
                    lpItem->dwItemData = lpmiiW->dwItemData;
                    lpItem->cch = lstrlenW(lpmenuText);
                    lpItem->lpwz = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (lpItem->cch + 1));
                    if (lpItem->lpwz)
                        StrCpyNW(lpItem->lpwz, lpmenuText, lpItem->cch + 1);
                    else
                        lpItem->cch = 0;

                    lpmiiNewW->fType |= MFT_OWNERDRAW;
                    lpmiiNewW->fMask |= MIIM_DATA;
                    lpmiiNewW->dwItemData = (ULONG_PTR)lpItem;
                    lpmiiNewW->dwTypeData = 0;
                    lpmiiNewW->cch = 0;
                }
            }
        }
    }
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

void DeleteOwnerDrawMenuItem(HMENU hMenu, UINT uItem, BOOL fByPosition);

void DeleteOwnerDrawMenu(HMENU hMenu)
{
    int i, nItem = GetMenuItemCount(hMenu);

    for (i = 0; i < nItem; i++)
        DeleteOwnerDrawMenuItem(hMenu, i, TRUE);
}

void DeleteOwnerDrawMenuItem(HMENU hMenu, UINT uItem, BOOL fByPosition)
{
    MENUITEMINFOA miiA;

    miiA.cbSize = sizeof(miiA);
    miiA.fMask = MIIM_TYPE | MIIM_ID | MIIM_SUBMENU | MIIM_DATA;
    miiA.cch = 0;
    if (GetMenuItemInfoA(hMenu, uItem, fByPosition, &miiA))
    {
        if (miiA.hSubMenu)
            DeleteOwnerDrawMenu(miiA.hSubMenu);
        else
        {
            if ((MIIM_TYPE & miiA.fMask) && (MFT_OWNERDRAW & miiA.fType))
            {
                LPPUIMENUITEM lpItem = (LPPUIMENUITEM)miiA.dwItemData;

                if (!IsBadReadPtr(lpItem, sizeof(lpItem->dwSig)) && PUI_OWNERDRAW_SIG == lpItem->dwSig && !(MFT_OWNERDRAW & lpItem->fType))
                {
                    if (lpItem->lpwz && lpItem->cch)
                        LocalFree(lpItem->lpwz);
                    LocalFree(lpItem);
                }
            }
        }
    }
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI
DeleteMenuWrap(HMENU hMenu, UINT uPosition, UINT uFlags)
{
    VALIDATE_PROTOTYPEX(DeleteMenu);

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();

    if (bOwnerDraw)
        DeleteOwnerDrawMenuItem(hMenu, uPosition, (MF_BYPOSITION & uFlags)? TRUE: FALSE);

    return DeleteMenu(hMenu, uPosition, uFlags);
}


// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI
DestroyMenuWrap(HMENU hMenu)
{
    VALIDATE_PROTOTYPEX(DestroyMenu);

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();

    if (bOwnerDraw)
        DeleteOwnerDrawMenu(hMenu);

    return DestroyMenu(hMenu);
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

LPBYTE MenuLoadMENUTemplates(LPBYTE lpMenuTemplate, HMENU *phMenu)
{
    HMENU hMenu;
    UINT menuFlags = 0;
    ULONG_PTR menuId = 0;
    LPWSTR lpmenuText;
    MENUITEMINFO mii;

    if (!(hMenu = CreateMenu()))
        goto memoryerror;

    do
    {
        // Get the menu flags.
        menuFlags = (UINT)(*(WORD *)lpMenuTemplate);
        lpMenuTemplate += 2;
        if (menuFlags & ~MF_VALID) {
            goto memoryerror;
        }

        if (!(menuFlags & MF_POPUP))
        {
            menuId = *(WORD *)lpMenuTemplate;
            lpMenuTemplate += 2;
        }

        lpmenuText = (LPWSTR)lpMenuTemplate;

        if (*lpmenuText)    // If a string exists, then skip to the end of it.
            lpMenuTemplate += lstrlenW(lpmenuText) * sizeof(WCHAR);
        else
            lpmenuText = NULL;

        // Skip over terminating NULL of the string (or the single NULL if empty string).
        lpMenuTemplate += sizeof(WCHAR);
        lpMenuTemplate = (BYTE *)(((ULONG_PTR)lpMenuTemplate + 1) & ~1);    // word align

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;

        if (menuFlags & MF_POPUP)
        {
            mii.fMask |= MIIM_SUBMENU;
            lpMenuTemplate = MenuLoadMENUTemplates(lpMenuTemplate, (HMENU *)&menuId);
            if (!lpMenuTemplate)
                goto memoryerror;
            mii.hSubMenu = (HMENU)menuId;
        }

        // Don't allow bitmaps from the resource file.
        if (menuFlags & MF_BITMAP)
            menuFlags = (UINT)((menuFlags | MFT_RIGHTJUSTIFY) & ~MF_BITMAP);

        // We have to take out MFS_HILITE since that bit marks the end of a menu in
        // a resource file.  Since we shouldn't have any pre hilited items in the
        // menu anyway, this is no big deal.
        mii.fState = (menuFlags & MFS_OLDAPI_MASK) & ~MFS_HILITE;
        mii.fType = (menuFlags & MFT_OLDAPI_MASK);
        if (menuFlags & MFT_OWNERDRAW)
        {
            mii.fMask |= MIIM_DATA;
            mii.dwItemData = (ULONG_PTR) lpmenuText;
            lpmenuText = 0;
        }

        mii.dwTypeData = (LPTSTR)lpmenuText;
        mii.cch = (UINT)-1;
        mii.wID = (UINT)menuId;

        if (!InsertMenuItemWrapW(hMenu, 0xFFFFFFFF, TRUE, &mii))
        {
            if (menuFlags & MF_POPUP)
                DestroyMenuWrap(mii.hSubMenu);
            goto memoryerror;
        }
    } while (!(menuFlags & MF_END));

    *phMenu = hMenu;
    return lpMenuTemplate;

memoryerror:
    if (hMenu != NULL)
        DestroyMenuWrap(hMenu);
    *phMenu = NULL;
    return NULL;
}

PMENUITEMTEMPLATE2 MenuLoadMENUEXTemplates(PMENUITEMTEMPLATE2 lpMenuTemplate, HMENU *phMenu, WORD wResInfo)
{
    HMENU hMenu;
    HMENU hSubMenu;
    long menuId = 0;
    LPWSTR lpmenuText;
    MENUITEMINFO mii;
    UINT cch = 0;
    DWORD dwHelpID;

    if (!(hMenu = CreateMenu()))
        goto memoryerror;

    do
    {
        if (!(wResInfo & MFR_POPUP))
        {
            // If the PREVIOUS wResInfo field was not a POPUP, the
            // dwHelpID field is not there.  Back up so things fit.
            lpMenuTemplate = (PMENUITEMTEMPLATE2)(((LPBYTE)lpMenuTemplate) - sizeof(lpMenuTemplate->dwHelpID));
            dwHelpID = 0;
        }
        else
            dwHelpID = lpMenuTemplate->dwHelpID;

        menuId = lpMenuTemplate->menuId;

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;

        mii.fType = lpMenuTemplate->fType;
        if (mii.fType & ~MFT_MASK)
            goto memoryerror;

        mii.fState  = lpMenuTemplate->fState;
        if (mii.fState & ~MFS_MASK)
            goto memoryerror;

        wResInfo = lpMenuTemplate->wResInfo;
        if (wResInfo & ~(MF_END | MFR_POPUP))
            goto memoryerror;

        if (dwHelpID)
            SetMenuContextHelpId(hMenu,dwHelpID);

        if (lpMenuTemplate->mtString[0])
            lpmenuText = lpMenuTemplate->mtString;
        else
            lpmenuText = NULL;

        cch = lstrlenW(lpmenuText);
        mii.dwTypeData = (LPTSTR) lpmenuText;

        // skip to next menu item template (DWORD boundary)
        lpMenuTemplate = (PMENUITEMTEMPLATE2)
                (((LPBYTE)lpMenuTemplate) +
                sizeof(MENUITEMTEMPLATE2) +
                ((cch * sizeof(WCHAR) + 3) & ~3));

        if (mii.fType & MFT_OWNERDRAW)
        {
            mii.fMask |= MIIM_DATA;
            mii.dwItemData = (ULONG_PTR) mii.dwTypeData;
            mii.dwTypeData = 0;
        }

        if (wResInfo & MFR_POPUP)
        {
            mii.fMask |= MIIM_SUBMENU;
            lpMenuTemplate = MenuLoadMENUEXTemplates(lpMenuTemplate, &hSubMenu, MFR_POPUP);
            if (lpMenuTemplate == NULL)
                goto memoryerror;
            mii.hSubMenu = hSubMenu;
        }

        // Don't allow bitmaps from the resource file.
        if (mii.fType & MFT_BITMAP)
            mii.fType = (mii.fType | MFT_RIGHTJUSTIFY) & ~MFT_BITMAP;

        mii.cch = (UINT)-1;
        mii.wID = menuId;
        if (!InsertMenuItemWrapW(hMenu, 0xFFFFFFFF, TRUE, &mii))
        {
            if (wResInfo & MFR_POPUP)
                DestroyMenuWrap(mii.hSubMenu);
            goto memoryerror;
        }
        wResInfo &= ~MFR_POPUP;
    } while (!(wResInfo & MFR_END));

    *phMenu = hMenu;
    return lpMenuTemplate;

memoryerror:
    if (hMenu != NULL)
        DestroyMenuWrap(hMenu);
    *phMenu = NULL;
    return NULL;
}

HMENU CreateMenuFromResource(LPBYTE lpMenuTemplate)
{
    HMENU hMenu = NULL;
    UINT menuTemplateVersion;
    UINT menuTemplateHeaderSize;

    // menu resource: First, strip version number word out of the menu
    // template.  This value should be 0 for MENU, 1 for MENUEX.
    menuTemplateVersion = *(WORD *)lpMenuTemplate;
    lpMenuTemplate += 2;
    if (menuTemplateVersion > 1)
        return NULL;

    menuTemplateHeaderSize = *(WORD *)lpMenuTemplate;
    lpMenuTemplate += 2;
    lpMenuTemplate += menuTemplateHeaderSize;
    switch (menuTemplateVersion)
    {
        case 0:
            MenuLoadMENUTemplates(lpMenuTemplate, &hMenu);
            break;

        case 1:
            MenuLoadMENUEXTemplates((PMENUITEMTEMPLATE2)lpMenuTemplate, &hMenu, 0);
            break;
    }
    return hMenu;
}

HMENU WINAPI
LoadMenuWrapW(HINSTANCE hInstance, LPCWSTR lpMenuName)
{
    VALIDATE_PROTOTYPE(LoadMenu);
    ASSERT(HIWORD64(lpMenuName) == 0);

    if (NeedMenuOwnerDraw() && MLIsMLHInstance(hInstance))
    {
        HRSRC hRes;

        if (hRes = FindResourceWrapW(hInstance, lpMenuName, RT_MENU))
        {
            LPBYTE lpMenuTemplate = (LPBYTE)LoadResource(hInstance, hRes);

            if (lpMenuTemplate)
            {
                HMENU hmenu = CreateMenuFromResource(lpMenuTemplate);

                if (hmenu)
                    return hmenu;
            }
        }
    }

    if (g_bRunningOnNT)
    {
        return LoadMenuW(hInstance, lpMenuName);
    }

    return LoadMenuA(hInstance, (LPCSTR) lpMenuName);
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

#define CX_MENUCHECK   8
#define CY_MENUCHECK   8

#define CHK_RADIO      0x006C
#define CHK_NORMAL     0x00FC

int FindCharPosition(LPCWSTR lpwStr, WCHAR wch)
{
    int iPos;
    int iLength = lstrlenW(lpwStr);

    for (iPos = 0; iPos < iLength; iPos++)
    {
        if (lpwStr[iPos] == wch)
            break;
    }

    return (iPos < iLength) ? iPos : -1;
}

int CalculateMenuTabString(HWND hWnd, HMENU hMenu)
{
    int   i;
    int   iMenuCount = GetMenuItemCount(hMenu);
    int   iLength;
    int   iTabPos = 0;
    int   iMaxTabLength = 0;
    RECT  rc;
    HDC   hdc;
    HFONT hfont, hfontSav;
    NONCLIENTMETRICSA ncm;
    MENUITEMINFOA miiA;

    ncm.cbSize = sizeof(ncm);
    if (!SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
        return 0;

    hfont = CreateFontIndirectA(&ncm.lfMenuFont);
    if (NULL == hfont)
        return 0;

    hdc = GetDC(hWnd);
    hfontSav = (HFONT)SelectObject(hdc, hfont);

    for (i = 0; i < iMenuCount; i++)
    {
        miiA.cbSize = sizeof(miiA);
        miiA.fMask = MIIM_TYPE | MIIM_ID | MIIM_SUBMENU | MIIM_DATA;
        miiA.cch = 0;

        if (GetMenuItemInfoA(hMenu, i, MF_BYPOSITION, &miiA))
        {
            if (miiA.hSubMenu)
                CalculateMenuTabString(hWnd, miiA.hSubMenu);

            if ((MIIM_TYPE & miiA.fMask) && (MFT_OWNERDRAW & miiA.fType))
            {
                LPPUIMENUITEM lpItem = (LPPUIMENUITEM)miiA.dwItemData;

                if (!IsBadReadPtr(lpItem, sizeof(lpItem->dwSig)) && PUI_OWNERDRAW_SIG == lpItem->dwSig && !(MFT_OWNERDRAW & lpItem->fType))
                {
                    if (lpItem->lpwz && lpItem->cch)
                    {
                        iTabPos = FindCharPosition(lpItem->lpwz, L'\t');

                        if (iTabPos >= 0)
                        {
                            DrawTextFLW(hdc, lpItem->lpwz + iTabPos + 1,
                                        lstrlenW(lpItem->lpwz) - iTabPos - 1, &rc, DT_SINGLELINE | DT_CALCRECT);

                            iLength = rc.right - rc.left;
                            if (iLength > iMaxTabLength)
                                iMaxTabLength = iLength;
                        }
                    }
                }
            }
        }
    }

    for (i = 0; i < iMenuCount; i++)
    {
        miiA.cbSize = sizeof(miiA);
        miiA.fMask = MIIM_TYPE | MIIM_ID | MIIM_SUBMENU | MIIM_DATA;
        miiA.cch = 0;

        if (GetMenuItemInfoA(hMenu, i, MF_BYPOSITION, &miiA))
        {
            if ((MIIM_TYPE & miiA.fMask) && (MFT_OWNERDRAW & miiA.fType))
            {
                LPPUIMENUITEM lpItem = (LPPUIMENUITEM)miiA.dwItemData;

                if (!IsBadReadPtr(lpItem, sizeof(lpItem->dwSig)) && PUI_OWNERDRAW_SIG == lpItem->dwSig && !(MFT_OWNERDRAW & lpItem->fType))
                {
                    if (lpItem->lpwz && lpItem->cch)
                    {
                        lpItem->iTabLength = iMaxTabLength;
                    }
                }
            }
        }
    }

    SelectObject(hdc, hfontSav);
    DeleteObject(hfont);
    ReleaseDC(hWnd, hdc);

    return iMaxTabLength;
}

void DrawMenuItemCheckMark(HDC hdc, LPCSTR lpChkSym, LPRECT lprc, UINT uFormat)
{
    HFONT   hFont, hFontSave;
    NONCLIENTMETRICSA ncm;

    ncm.cbSize = sizeof(ncm);
    if (SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
    {
        StrCpyNA(ncm.lfMenuFont.lfFaceName, "Wingdings", LF_FACESIZE);
        ncm.lfMenuFont.lfCharSet = SYMBOL_CHARSET;
        hFont = CreateFontIndirectA(&ncm.lfMenuFont);
        if ( hFont == NULL )
            return;

        hFontSave = (HFONT)SelectObject(hdc, hFont);

        DrawTextA(hdc, lpChkSym, 1, lprc, uFormat); 
        hFont = (HFONT)SelectObject(hdc, hFontSave);
        DeleteObject(hFont);
    }
}

void DrawMenuItemText(HDC hdc, LPCWSTR lpwMenuStr, LPRECT lprc, UINT uiRefData)
{
    UINT uFormat    = DT_VCENTER | DT_SINGLELINE | DT_LEFT  | DT_EXPANDTABS;
    int  iTabPos;

    iTabPos = FindCharPosition(lpwMenuStr, L'\t');
    if(iTabPos < 0)
    {
        // No TAB string is in the menu string
        DrawTextFLW(hdc, lpwMenuStr, lstrlenW(lpwMenuStr), lprc, uFormat);
    }
    else
    {
        RECT rc;

        // Draw Text before TAB
        DrawTextFLW(hdc, lpwMenuStr, iTabPos, lprc, uFormat);

        // Adjust RC for after TAB string.
        CopyRect(&rc, lprc);
        rc.left = rc.right - uiRefData - GetSystemMetrics(SM_CXMENUCHECK);
        DrawTextFLW(hdc, lpwMenuStr + iTabPos + 1, lstrlenW(lpwMenuStr) - iTabPos - 1, &rc, uFormat);
    }

}

void DrawMenuItem(LPDRAWITEMSTRUCT lpdis, LPRECT lprc)
{
    LPPUIMENUITEM lpItem = (LPPUIMENUITEM)lpdis->itemData;

    if (lpItem && lpItem->lpwz)
    {
        HDC   hdc = lpdis->hDC;
        UINT  uFormat = DT_VCENTER | DT_SINGLELINE | DT_LEFT | DT_EXPANDTABS;
        CHAR  ChkSym[2] = {(CHAR)CHK_NORMAL, 0x00}; 
        COLORREF clrTxt;
        int   iBkMode;
        RECT  rc;

        if (ODS_CHECKED & lpdis->itemState)
        {
            MENUITEMINFOA miiA;

            miiA.cbSize = sizeof(miiA);
            miiA.fMask = MIIM_TYPE;
            miiA.cch = 0;
            if (GetMenuItemInfoA(lpItem->hmenu, lpdis->itemID, FALSE, &miiA))
            {
                if (MFT_RADIOCHECK & miiA.fType)
                    ChkSym[0] = CHK_RADIO; 
            }
        }

        iBkMode = SetBkMode(hdc, TRANSPARENT);

        if (ODS_GRAYED & lpdis->itemState)
        {
            clrTxt = SetTextColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));

            if (ODS_CHECKED & lpdis->itemState)
            {
                CopyRect(&rc, &(lpdis->rcItem));
                OffsetRect(&rc, 1, 1);
                DrawMenuItemCheckMark(hdc, ChkSym, &rc, uFormat);
            }

            CopyRect(&rc, lprc);
            OffsetRect(&rc, 1, 1);
            DrawMenuItemText(hdc, lpItem->lpwz, &rc, lpItem->iTabLength);

            SetTextColor(hdc, GetSysColor(COLOR_BTNSHADOW));
        }

        if (ODS_CHECKED & lpdis->itemState)
            DrawMenuItemCheckMark(hdc, ChkSym, &(lpdis->rcItem), uFormat);
        DrawMenuItemText(hdc, lpItem->lpwz, lprc, lpItem->iTabLength);

        if (ODS_GRAYED & lpdis->itemState)
            SetTextColor(hdc, clrTxt);
        SetBkMode(hdc, iBkMode);
    }
}

LRESULT OwnerDrawSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    switch (uMsg)
    {
        case WM_DRAWITEM:
            if (0 == wParam)    // This is a menu
            {
                LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;
                LPPUIMENUITEM lpItem = (LPPUIMENUITEM)lpdis->itemData;

                if (lpdis->CtlType == ODT_MENU
                    && !IsBadReadPtr(lpItem, sizeof(lpItem->dwSig)) && PUI_OWNERDRAW_SIG == lpItem->dwSig
                    && !(MFT_OWNERDRAW & lpItem->fType))
                {
                    int cyTemp;
                    RECT rc;
                    HDC hdc = lpdis->hDC;
                    HFONT hfont, hfontSav;
                    TEXTMETRICA tm;
                    NONCLIENTMETRICSA ncm;

                    ncm.cbSize = sizeof(ncm);
                    if (!SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
                        break;

                    hfont = CreateFontIndirectA(&ncm.lfMenuFont);
                    if (NULL == hfont)
                        break;

                    hfontSav = (HFONT)SelectObject(hdc, hfont);

                    GetTextMetricsA(hdc, &tm);
                    CopyRect(&rc, &lpdis->rcItem);
                    rc.left += GetSystemMetrics(SM_CXMENUCHECK);
                    rc.top += tm.tmExternalLeading;

                    cyTemp = (lpdis->rcItem.bottom - lpdis->rcItem.top) - (tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER));
                    if (cyTemp > 0)
                        rc.top += (cyTemp / 2);

                    switch (lpdis->itemAction)
                    {
                        case ODA_DRAWENTIRE:
                            DrawMenuItem(lpdis, &rc);
                            break;

                        case ODA_FOCUS:
                            break;

                        case ODA_SELECT:
                        {
                            COLORREF clrTxt, clrBk, clrTxtSav, clrBkSav;

                            if (ODS_SELECTED & lpdis->itemState)
                            {
                                clrTxt = GetSysColor(COLOR_HIGHLIGHTTEXT);
                                clrBk = GetSysColor(COLOR_HIGHLIGHT);
                            }
                            else
                            {
                                clrTxt = GetSysColor(COLOR_MENUTEXT);
                                clrBk = GetSysColor(COLOR_MENU);
                            }
                            clrTxtSav = SetTextColor(hdc, clrTxt);
                            clrBkSav = SetBkColor(hdc, clrBk);
                            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lpdis->rcItem, TEXT(""), 0, NULL);
                            DrawMenuItem(lpdis, &rc);
                            SetTextColor(hdc, clrTxtSav);
                            SetBkColor(hdc, clrBkSav);
                            break;
                        }
                    }
                    SelectObject(hdc, hfontSav);
                    DeleteObject(hfont);
                    return TRUE;
                }
            }
            break;

        case WM_MEASUREITEM:
            if (0 == wParam)    // This is a menu
            {
                LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT)lParam;
                LPPUIMENUITEM lpItem = (LPPUIMENUITEM)lpmis->itemData;

                if (lpmis->CtlType == ODT_MENU
                    && !IsBadReadPtr(lpItem, sizeof(lpItem->dwSig)) && PUI_OWNERDRAW_SIG == lpItem->dwSig
                    && !(MFT_OWNERDRAW & lpItem->fType) && lpItem->lpwz)
                {
                    RECT rc;
                    HDC hdc;
                    HFONT hfont, hfontSav;
                    NONCLIENTMETRICSA ncm;
                    int    iTabPos;

                    ncm.cbSize = sizeof(ncm);
                    if (!SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
                        break;

                    hfont = CreateFontIndirectA(&ncm.lfMenuFont);
                    if (NULL == hfont)
                        break;

                    hdc = GetDC(hWnd);
                    hfontSav = (HFONT)SelectObject(hdc, hfont);

                    iTabPos = FindCharPosition(lpItem->lpwz, L'\t');
                    if (iTabPos < 0)
                        iTabPos = lstrlenW(lpItem->lpwz);

                    DrawTextFLW(hdc, lpItem->lpwz, iTabPos, &rc, DT_SINGLELINE | DT_CALCRECT | DT_EXPANDTABS);
                    SelectObject(hdc, hfontSav);
                    DeleteObject(hfont);
                    ReleaseDC(hWnd, hdc);

                    lpmis->itemWidth = rc.right - rc.left + GetSystemMetrics(SM_CXMENUCHECK) +
                                       GetSystemMetrics(SM_CXEDGE) * 2 + lpItem->iTabLength;
                    lpmis->itemHeight = rc.bottom - rc.top + GetSystemMetrics(SM_CYEDGE) * 2;
                    return TRUE;
                }
            }
            break;

        case WM_MENUCHAR:
            // FEATURE: need to be implemented
            break;
    }
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

int WINAPI
GetMenuStringWrapW(
        HMENU   hMenu,
        UINT    uIDItem,
        LPWSTR  lpString,
        int     nMaxCount,
        UINT    uFlag)
{
    VALIDATE_PROTOTYPE(GetMenuString);
    VALIDATE_OUTBUF(lpString, nMaxCount);

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();

    if (bOwnerDraw)
    {
        MENUITEMINFOA miiA;

        miiA.cbSize = sizeof(miiA);
        miiA.fMask = MIIM_TYPE | MIIM_ID | MIIM_DATA;
        miiA.cch = 0;
        if (GetMenuItemInfoA(hMenu, uIDItem, (uFlag & MF_BYPOSITION)? TRUE: FALSE, &miiA))
        {
            if ((MIIM_TYPE & miiA.fMask) && (MFT_OWNERDRAW & miiA.fType))
            {
                LPPUIMENUITEM lpItem = (LPPUIMENUITEM)miiA.dwItemData;

                if (!IsBadReadPtr(lpItem, sizeof(lpItem->dwSig)) && PUI_OWNERDRAW_SIG == lpItem->dwSig && !(MFT_OWNERDRAW & lpItem->fType))
                {
                    if (lpItem->lpwz && lpItem->cch)
                    {
                        StrCpyNW(lpString, lpItem->lpwz, nMaxCount);
                        return min((UINT)(nMaxCount - 1), lpItem->cch);
                    }
                }
            }
        }
    }

    if (g_bRunningOnNT)
    {
        return GetMenuStringW(hMenu, uIDItem, lpString, nMaxCount, uFlag);
    }

    CStrOut str(lpString, nMaxCount);

    GetMenuStringA(hMenu, uIDItem, str, str.BufSize(), uFlag);
    return str.ConvertExcludingNul();
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI
InsertMenuWrapW(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT_PTR uIDNewItem,
        LPCWSTR lpNewItem)
{
    VALIDATE_PROTOTYPE(InsertMenu);

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();

    if (bOwnerDraw)
    {
        if (!((MF_BITMAP | MF_OWNERDRAW) & uFlags)) // if MF_STRING is set. MF_STRING is 0
        {
            MENUITEMINFOW miiW;

            miiW.cbSize = sizeof(miiW);
            miiW.fMask = MIIM_TYPE | MIIM_STATE;
            miiW.fType = MFT_STRING;
            miiW.fState = uFlags & (MF_DEFAULT | MF_CHECKED | MF_UNCHECKED | MF_HILITE | MF_UNHILITE| MF_ENABLED | MF_DISABLED | MF_GRAYED);
            if (uFlags & (MF_GRAYED | MF_DISABLED))
                miiW.fState |= MFS_GRAYED;
            if (MF_POPUP & uFlags)
            {
                miiW.fMask |= MIIM_SUBMENU;
                miiW.hSubMenu = (HMENU)uIDNewItem;
            }
            else
            {
                miiW.fMask |= MIIM_ID;
                miiW.wID = (UINT)uIDNewItem;
            }
            miiW.dwTypeData = (LPWSTR)lpNewItem;
            miiW.cch = lstrlenW(lpNewItem);
            return InsertMenuItemWrapW(hMenu, uPosition, (MF_BYPOSITION & uFlags)? TRUE: FALSE, &miiW);
        }
    }

    if (g_bRunningOnNT)
    {
        return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
    }

    //
    //  You can't test for MFT_STRING because MFT_STRING is zero!
    //  So instead you have to check for everything *other* than
    //  a string.
    //
    //  The presence of any non-string menu type turns lpnewItem into
    //  an atom.
    //
    CStrIn str((uFlags & MFT_NONSTRING) ? CP_ATOM : CP_ACP, lpNewItem);

    return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, str);
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL IsWindowOnCurrentThread(HWND hWnd)
{
    DWORD foo;

    if (!IsWindow(hWnd))
        // bail if the window is dead so we dont bogusly rip
        return TRUE;

    if (GetCurrentThreadId() != GetWindowThreadProcessId(hWnd, &foo))
        return FALSE;
    else
        return TRUE;
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI
TrackPopupMenuWrap(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, CONST RECT *prcRect)
{
    VALIDATE_PROTOTYPEX(TrackPopupMenu);

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();
    BOOL        bIsWindowOnCurrentThread, bRet;

    if (bOwnerDraw && (bIsWindowOnCurrentThread = IsWindowOnCurrentThread(hWnd)))
    {
        CalculateMenuTabString(hWnd, hMenu);
        SetWindowSubclass(hWnd, OwnerDrawSubclassProc, 0, (DWORD_PTR)NULL);
    }

    bRet = TrackPopupMenu(hMenu, uFlags, x, y, nReserved, hWnd, prcRect);

    if (bOwnerDraw && bIsWindowOnCurrentThread)
        RemoveWindowSubclass(hWnd, OwnerDrawSubclassProc,  0);

    return bRet;
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI
TrackPopupMenuExWrap(HMENU hMenu, UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm)
{
    VALIDATE_PROTOTYPEX(TrackPopupMenuEx);

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();
    BOOL        bIsWindowOnCurrentThread, bRet;

    if (bOwnerDraw && (bIsWindowOnCurrentThread = IsWindowOnCurrentThread(hWnd)))
    {
        CalculateMenuTabString(hWnd, hMenu);
        SetWindowSubclass(hWnd, OwnerDrawSubclassProc, 0, (DWORD_PTR)NULL);
    }

    bRet = TrackPopupMenuEx(hMenu, uFlags, x, y, hWnd, lptpm);
    
    if (bOwnerDraw && bIsWindowOnCurrentThread)
        RemoveWindowSubclass(hWnd, OwnerDrawSubclassProc,  0);

    return bRet;
}

#ifdef NEED_USER32_WRAPPER

int WINAPI
LoadStringWrapW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    VALIDATE_PROTOTYPE(LoadString);

    if (g_bRunningOnNT)
    {
        return LoadStringW(hInstance, uID, lpBuffer, nBufferMax);
    }

    //
    //  Do it manually.  The old code used to call LoadStringA and then
    //  convert it up to unicode, which is bad, since resources are
    //  physically already Unicode!  Just copy it out directly.
    //
    //  The old code was also buggy in the case where the loaded string
    //  contains embedded NULLs.
    //

    if (nBufferMax <= 0) return 0;                  // sanity check

    PWCHAR pwch;

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    HRSRC hrsrc;
    int cwch = 0;

    hrsrc = FindResourceA(hInstance, (LPSTR)(LONG_PTR)(1 + uID / 16), (LPSTR)RT_STRING);
    if (hrsrc) {
        pwch = (PWCHAR)LoadResource(hInstance, hrsrc);
        if (pwch) {
            /*
             *  Now skip over the strings in the resource until we
             *  hit the one we want.  Each entry is a counted string,
             *  just like Pascal.
             */
            for (uID %= 16; uID; uID--) {
                pwch += *pwch + 1;
            }
            cwch = min(*pwch, nBufferMax - 1);
            memcpy(lpBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
        }
    }
    lpBuffer[cwch] = L'\0';                 /* Terminate the string */
    return cwch;
}

#endif // NEED_USER32_WRAPPER

//----------------------------------------------------------------------
//
// function:    TransformCharNoOp1( WCHAR **ppch )
//
// purpose:     Stand-in for TransformCharWidth.  Used by the function
//              CompareStringString.
//
// returns:     Character at *ppch.  The value *ppch is incremented.
//
//----------------------------------------------------------------------

static WCHAR
TransformCharNoOp1( LPCWSTR *ppch, int )
{
    WCHAR ch = **ppch;

    (*ppch)++;

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformCharWidth( WCHAR **ppch, cchRemaining )
//
// purpose:     Converts halfwidth characters to fullwidth characters.
//              Also combines voiced (dakuon) and semi-voiced (handakuon)
//              characters.  *pch is advanced by one, unless there is a
//              (semi)voiced character, in which case it is advanced by
//              two characters.
//
//              Note that unlike the full widechar version, we do not
//              combine other characters, notably the combining Hiragana
//              characters (U+3099 and U+309A.)  This is to keep the
//              tables from getting unnecessarily large.
//
//              cchRemaining is passed so as to not include the voiced
//              marks if it's passed the end of the specified buffer.
//
// returns:     Full width character. *pch is incremented.
//
//----------------------------------------------------------------------

static WCHAR
TransformCharWidth( LPCWSTR *ppch, int cchRemaining )
{
    WCHAR ch = **ppch;

    (*ppch)++;

    if (ch == 0x0020)
    {
        ch = 0x3000;
    }
    else if (ch == 0x005c)
    {
        // REVERSE SOLIDUS (aka BACKSLASH) maps to itself
    }
    else if (InRange(ch, 0x0021, 0x07e))
    {
        ch += 65248;
    }
    else if (InRange(ch, 0x00a2, 0x00af))
    {
        static const WCHAR achFull[] =
        {
            0xffe0, 0xffe1, 0x00a4, 0xffe5, 0xffe4, 0x00a7, 0x00a8, // 0xa2-0xa8
            0x00a9, 0x00aa, 0x00ab, 0xffe2, 0x00ad, 0x00ae, 0xffe3  // 0xa9-0xaf
        };

        ch = achFull[ch - 0x00a2];
    }
    else if (ch == 0x20a9) // WON SIGN
    {
        ch = 0xffe6;
    }
    else if (InRange(ch, 0xff61, 0xffdc))
    {
        WCHAR chNext = (cchRemaining > 1) ? **ppch : 0;

        if (chNext == 0xff9e && InRange(ch, 0xff73, 0xff8e))
        {
            if (cchRemaining != 1)
            {
                static const WCHAR achFull[] =
                {
/* 0xff73-0xff79 */  0xb0f4, 0x30a8, 0x30aa, 0xb0ac, 0xb0ae, 0xb0b0, 0xb0b2,
/* 0xff7a-0xff80 */  0xb0b4, 0xb0b6, 0xb0b8, 0xb0ba, 0xb0bc, 0xb0be, 0xb0c0,
/* 0xff81-0xff87 */  0xb0c2, 0xb0c5, 0xb0c7, 0xb0c9, 0x30ca, 0x30cb, 0x30cc,
/* 0xff88-0xff8e */  0x30cd, 0x30ce, 0xb0d0, 0xb0d3, 0xb0d6, 0xb0d9, 0xb0dc
                };

                // HALFWIDTH KATAKANA VOICED SOUND MARK

                WCHAR chTemp = achFull[ch - 0xff73];

                // Some in the range absorb the sound mark.
                // These are indicated by the set high-bit.

                ch = chTemp & 0x7fff;

                if (chTemp & 0x8000)
                {
                    (*ppch)++;
                }
            }
        }
        else if (chNext == 0xff9f && InRange(ch, 0xff8a, 0xff8e))
        {
            // HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK

            ch = 0x30d1 + (ch - 0xff8a) * 3;
            (*ppch)++;
        }
        else
        {
            static const WCHAR achMapFullFFxx[] =
            {
                0x3002, 0x300c, 0x300d, 0x3001, 0x30fb, 0x30f2, 0x30a1,  // 0xff61-0xff67
                0x30a3, 0x30a5, 0x30a7, 0x30a9, 0x30e3, 0x30e5, 0x30e7,  // 0xff68-0xff6e
                0x30c3, 0x30fc, 0x30a2, 0x30a4, 0x30a6, 0x30a8, 0x30aa,  // 0xff6f-0xff75
                0x30ab, 0x30ad, 0x30af, 0x30b1, 0x30b3, 0x30b5, 0x30b7,  // 0xff76-0xff7c
                0x30b9, 0x30bb, 0x30bd, 0x30bf, 0x30c1, 0x30c4, 0x30c6,  // 0xff7d-0xff83
                0x30c8, 0x30ca, 0x30cb, 0x30cc, 0x30cd, 0x30ce, 0x30cf,  // 0xff84-0xff8a
                0x30d2, 0x30d5, 0x30d8, 0x30db, 0x30de, 0x30df, 0x30e0,  // 0xff8b-0xff91
                0x30e1, 0x30e2, 0x30e4, 0x30e6, 0x30e8, 0x30e9, 0x30ea,  // 0xff92-0xff98
                0x30eb, 0x30ec, 0x30ed, 0x30ef, 0x30f3, 0x309b, 0x309c,  // 0xff99-0xff9f
                0x3164, 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136,  // 0xffa0-0xffa6
                0x3137, 0x3138, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d,  // 0xffa7-0xffad
                0x313e, 0x313f, 0x3140, 0x3141, 0x3142, 0x3143, 0x3144,  // 0xffae-0xffb4
                0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314a, 0x314b,  // 0xffb5-0xffbb
                0x314c, 0x314d, 0x314e, 0xffbf, 0xffc0, 0xffc1, 0x314f,  // 0xffbc-0xffc2
                0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0xffc8, 0xffc9,  // 0xffc3-0xffc9
                0x3155, 0x3156, 0x3157, 0x3158, 0x3159, 0x315a, 0xffd0,  // 0xffca-0xffd0
                0xffd1, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160,  // 0xffd1-0xffd7
                0xffd8, 0xffd9, 0x3161, 0x3162, 0x3163                   // 0xffd8-0xffac
            };

            ch = achMapFullFFxx[ch - 0xff61];
        }
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharNoOp2( WCHAR ch )
//
// purpose:     Stand-in for CharLowerBuffWrap.  Used by the function
//              CompareStringString.
//
// returns:     Original character
//
//----------------------------------------------------------------------

static WCHAR
TransformCharNoOp2( WCHAR ch )
{
    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharKana( WCHAR ch )
//
// purpose:     Converts Hiragana characters to Katakana characters
//
// returns:     Original character if not Hiragana,
//              Katanaka character if Hiragana
//
//----------------------------------------------------------------------

static WCHAR
TransformCharKana( WCHAR ch )
{
    if (((ch & 0xff00) == 0x3000) &&
        (InRange(ch, 0x3041, 0x3094) || InRange(ch, 0x309d, 0x309e)))
    {
        ch += 0x060;
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformCharNoOp3( LPWSTR pch, DWORD cch )
//
// purpose:     Stand-in for CharLowerBuffWrap.  Used by the function
//              CompareStringString.
//
// returns:     Character count (cch).
//
//----------------------------------------------------------------------

static DWORD
TransformCharNoOp3( LPWSTR, DWORD cch )
{
    return cch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharFinal( WCHAR ch )
//
// purpose:     Converts "final" forms to regular forms
//
// returns:     Original character if not Hiragana,
//              Katanaka character if Hiragana
//
//----------------------------------------------------------------------

// REARCHITECT (cthrash) We do not fold Presentation Forms (Alphabetic or Arabic)

static WCHAR
TransformCharFinal( WCHAR ch )
{
    WCHAR chRet = ch;

    if (ch >= 0x3c2)                    // short-circuit ASCII +
    {
        switch (ch)
        {
            case 0x03c2:                // GREEK SMALL LETTER FINAL SIGMA
            case 0x05da:                // HEBREW LETTER FINAL KAF
            case 0x05dd:                // HEBREW LETTER FINAL MEM
            case 0x05df:                // HEBREW LETTER FINAL NUN
            case 0x05e3:                // HEBREW LETTER FINAL PE
            case 0x05e5:                // HEBREW LETTER FINAL TSADI
            case 0xfb26:                // HEBREW LETTER WIDE FINAL MEM
            case 0xfb3a:                // HEBREW LETTER FINAL KAF WITH DAGESH
            case 0xfb43:                // HEBREW LETTER FINAL PE WITH DAGESH
                chRet++;
                break;
        }
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    CompareStringString( ... )
//
// purpose:     Helper for CompareStringWrap.
//
//              We handle the string comparsion for CompareStringWrap.
//              We can convert each character to (1) fullwidth,
//              (2) Katakana, and (3) lowercase, as necessary.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------

static int
CompareStringString(
    DWORD   dwFlags,
    LPCWSTR lpA,
    int     cchA,
    LPCWSTR lpB,
    int     cchB )
{
    int nRet = 0;
    WCHAR wchIgnoreNulA = cchA == -1 ? 0 : -1;
    WCHAR wchIgnoreNulB = cchB == -1 ? 0 : -1;
    WCHAR (*pfnTransformWidth)(LPCWSTR *, int);
    WCHAR (*pfnTransformKana)(WCHAR);
    DWORD (*pfnTransformLower)(LPWSTR, DWORD);
    WCHAR (*pfnTransformFinal)(WCHAR);


    pfnTransformWidth = (dwFlags & NORM_IGNOREWIDTH)
                        ? TransformCharWidth : TransformCharNoOp1;
    pfnTransformKana  = (dwFlags & NORM_IGNOREKANATYPE)
                        ? TransformCharKana : TransformCharNoOp2;
    pfnTransformLower = (dwFlags & NORM_IGNORECASE)
                        ? CharLowerBuffWrap : TransformCharNoOp3;
    pfnTransformFinal = (dwFlags & NORM_IGNORECASE)
                        ? TransformCharFinal : TransformCharNoOp2;

    while (   !nRet
           && cchA
           && cchB
           && (*lpA | wchIgnoreNulA)
           && (*lpB | wchIgnoreNulB) )
    {
        WCHAR chA, chB;
        LPCWSTR lpAOld = lpA;
        LPCWSTR lpBOld = lpB;

        chA = (*pfnTransformWidth)(&lpA, cchA);
        chA = (*pfnTransformKana)(chA);
        (*pfnTransformLower)(&chA, 1);
        chA = (*pfnTransformFinal)(chA);

        chB = (*pfnTransformWidth)(&lpB, cchB);
        chB = (*pfnTransformKana)(chB);
        (*pfnTransformLower)(&chB, 1);
        chB = (*pfnTransformFinal)(chB);

        nRet = (int)chA - (int)chB;
        cchA -= (int) (lpA - lpAOld);
        cchB -= (int) (lpB - lpBOld);
    }

    if (!nRet)
    {
        nRet = cchA - cchB;
    }

    if (nRet)
    {
        nRet = nRet > 0 ? 1 : -1;
    }

    return nRet + 2;
}

//----------------------------------------------------------------------
//
// function:    CompareStringWord( ... )
//
// purpose:     Helper for CompareStringWrap.
//
//              We handle the word comparsion for CompareStringWrap.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------

static int
CompareStringWord(
    LCID    lcid,
    DWORD   dwFlags,
    LPCWSTR lpA,
    int     cchA,
    LPCWSTR lpB,
    int     cchB )
{
    // FEATURE (cthrash) We won't properly support word compare for the
    // time being.  Do the same old CP_ACP trick, which should cover
    // enough cases.

    // fail if either string is NULL, as it causes assert on debug windows
    if (!lpA || !lpB)
        return 0;

    CStrIn strA(lpA, cchA);
    CStrIn strB(lpB, cchB);

    cchA = strA.strlen();
    cchB = strB.strlen();

    return CompareStringA(lcid, dwFlags, strA, cchA, strB, cchB);
}

//----------------------------------------------------------------------
//
// function:    CompareStringWrapW( ... )
//
// purpose:     Unicode wrapper of CompareString for Win95.
//
//              Note not all bits in dwFlags are honored; specifically,
//              since we don't do a true widechar word compare, we
//              won't properly handle NORM_IGNORENONSPACE or
//              NORM_IGNORESYMBOLS for arbitrary widechar strings.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------

LWSTDAPI_(int)
CompareStringAltW(
    LCID    lcid,
    DWORD   dwFlags,
    LPCWSTR lpA,
    int     cchA,
    LPCWSTR lpB,
    int     cchB )
{
    if (g_bRunningOnNT)
    {
        return CompareStringW(lcid, dwFlags, lpA, cchA, lpB, cchB);
    }

    int nRet;

    if (dwFlags & SORT_STRINGSORT)
    {
        nRet = CompareStringString(dwFlags, lpA, cchA, lpB, cchB);
    }
    else
    {
        nRet = CompareStringWord(lcid, dwFlags, lpA, cchA, lpB, cchB);
    }

    return nRet;
}

#ifdef NEED_KERNEL32_WRAPPER

int StrLenN(LPCWSTR psz, int cchMin)
{
    LPCWSTR pszEnd = psz;

    while (((pszEnd - psz) < cchMin) && *pszEnd)
    {
        pszEnd++;
    }
    return pszEnd - psz;
}

int WINAPI CompareStringWrapW(LCID Locale, DWORD dwFlags,
                              LPCWSTR psz1, int cch1,
                              LPCWSTR psz2, int cch2)
{
    VALIDATE_PROTOTYPE(CompareString);

    if (g_bRunningOnNT)
    {
        return CompareStringW(Locale, dwFlags, psz1, cch1, psz2, cch2);
    }
    else if (psz1 && psz2)
    {
        if (dwFlags & NORM_STOP_ON_NULL)
        {
            cch1 = StrLenN(psz1, cch1);
            cch2 = StrLenN(psz2, cch2);
            dwFlags &= ~NORM_STOP_ON_NULL;
        }

        CStrIn strString1(psz1, cch1);
        CStrIn strString2(psz2, cch2);

        cch1 = strString1.strlen();
        cch2 = strString2.strlen();

        return CompareStringA(Locale, dwFlags, strString1, cch1, strString2, cch2);
    }
    else
        return 0;   // fail if either string is NULL, as it causes assert on debug windows
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

#ifndef UNIX
BOOL WINAPI
MessageBoxIndirectWrapW(CONST MSGBOXPARAMS *pmbp)
#else
int WINAPI
MessageBoxIndirectWrapW(LPMSGBOXPARAMS pmbp)
#endif /* UNIX */
{
    VALIDATE_PROTOTYPE(MessageBoxIndirect);
    ASSERT(HIWORD64(pmbp->lpszIcon) == 0);

    if (g_bRunningOnNT)
    {
        return MessageBoxIndirectW(pmbp);
    }

    CStrIn        strText(pmbp->lpszText);
    CStrIn        strCaption(pmbp->lpszCaption);
    MSGBOXPARAMSA mbp;

    memcpy(&mbp, pmbp, sizeof(mbp));
    mbp.lpszText = strText;
    mbp.lpszCaption = strCaption;

    return MessageBoxIndirectA(&mbp);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

DWORD GetCharacterPlacementWrapW(
    HDC hdc,            // handle to device context
    LPCTSTR lpString,   // pointer to string
    int nCount,         // number of characters in string
    int nMaxExtent,     // maximum extent for displayed string
    LPGCP_RESULTS lpResults, // pointer to buffer for placement result
    DWORD dwFlags       // placement flags
   )
{
    VALIDATE_PROTOTYPE(GetCharacterPlacement);
    // Leave for someone else.
    ASSERT (lpResults->lpOutString == NULL);
    ASSERT (lpResults->lpClass == NULL);

    if (g_bRunningOnNT)
    {
        return GetCharacterPlacementW (hdc,
                                       lpString,
                                       nCount,
                                       nMaxExtent,
                                       lpResults,
                                       dwFlags);
    }

    CStrIn strText(lpString);
    DWORD dwRet;

    dwRet = GetCharacterPlacementA (hdc, strText, nCount, nMaxExtent,
                                    (LPGCP_RESULTSA)lpResults,
                                    dwFlags);
    return dwRet;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

//
// Note that we're calling get GetCharWidthA instead of GetCharWidth32A
// because the 32 version doesn't exist under Win95.
BOOL WINAPI GetCharWidth32WrapW(
     HDC hdc,
     UINT iFirstChar,
     UINT iLastChar,
     LPINT lpBuffer)
{
    VALIDATE_PROTOTYPE(GetCharWidth32);

    if (g_bRunningOnNT)
    {
         return GetCharWidth32W (hdc, iFirstChar, iLastChar, lpBuffer);
    }

    // Note that we expect to do only one character at a time for anything but
    // ISO Latin 1.
    if (iFirstChar > 255)
    {
        UINT mbChar=0;
        WCHAR ch;

        // Convert string
        ch = (WCHAR)iFirstChar;
        WideCharToMultiByte(CP_ACP, 0, &ch, 1,
                            (char *)&mbChar, 2, NULL, NULL);
    }

    return (GetCharWidthA (hdc, iFirstChar, iLastChar, lpBuffer));
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

//
//  Note:  Win95 does support ExtTextOutW.  This thunk is not for
//  ANSI/UNICODE wrapping.  It's to work around an ISV app bug.
//
//  Y'see, there's an app that patches Win95 GDI and their ExtTextOutW handler
//  is broken.  It always dereferences the lpStr parameter, even if
//  cch is zero.  Consequently, any time we are about to pass NULL as
//  the lpStr, we have to change our mind and pass a null UNICODE string
//  instead.
//
//  The name of this app:  Lotus SmartSuite ScreenCam 97.
//
LWSTDAPI_(BOOL)
ExtTextOutWrapW(HDC hdc, int x, int y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpStr, UINT cch, CONST INT *lpDx)
{
    VALIDATE_PROTOTYPE(ExtTextOut);
    if (lpStr == NULL)              // workaround
        lpStr = L"";                // for ScreenCam 97

    if (_MayNeedFontLinking(lpStr, cch))
    {
        return ExtTextOutFLW(hdc, x, y, fuOptions, lprc, lpStr, cch, lpDx);
    }

    return ExtTextOutW(hdc, x, y, fuOptions, lprc, lpStr, cch, lpDx);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
ModifyMenuWrapW(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT_PTR uIDNewItem,
        LPCWSTR lpNewItem)
{
    VALIDATE_PROTOTYPE(ModifyMenu);
    ASSERT(!(uFlags & MF_BITMAP) && !(uFlags & MF_OWNERDRAW));

    if (g_bRunningOnNT)
    {
        return ModifyMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
    }

    CStrIn  str(lpNewItem);

    return ModifyMenuA(hMenu, uPosition, uFlags, uIDNewItem, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
CopyFileWrapW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
{
    VALIDATE_PROTOTYPE(CopyFile);

    if (g_bRunningOnNT)
    {
        return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
    }

    CStrIn  strOld(lpExistingFileName);
    CStrIn  strNew(lpNewFileName);

    return CopyFileA(strOld, strNew, bFailIfExists);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
MoveFileWrapW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
{
    VALIDATE_PROTOTYPE(MoveFile);

    if (g_bRunningOnNT)
    {
        return MoveFileW(lpExistingFileName, lpNewFileName);
    }

    CStrIn  strOld(lpExistingFileName);
    CStrIn  strNew(lpNewFileName);

    return MoveFileA(strOld, strNew);
}


#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
OemToCharWrapW(LPCSTR lpszSrc, LPWSTR lpszDst)
{
    VALIDATE_PROTOTYPE(OemToChar);
    VALIDATE_OUTBUF(lpszDst, lstrlenA(lpszSrc));

    if (g_bRunningOnNT)
    {
        return OemToCharW(lpszSrc, lpszDst);
    }

    CStrOut strDst(lpszDst, lstrlenA(lpszSrc));

    return OemToCharA(lpszSrc, strDst);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI
OpenEventWrapW(
        DWORD                   fdwAccess,
        BOOL                    fInherit,
        LPCWSTR                 lpszEventName)
{
    VALIDATE_PROTOTYPE(OpenEvent);

    if (g_bRunningOnNT)
    {
        return OpenEventW(fdwAccess, fInherit, lpszEventName);
    }

    CStrIn strEventName(lpszEventName);

    return OpenEventA(fdwAccess, fInherit, strEventName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

VOID WINAPI
OutputDebugStringWrapW(LPCWSTR lpOutputString)
{
    VALIDATE_PROTOTYPE(OutputDebugString);

    if (g_bRunningOnNT)
    {
        OutputDebugStringW(lpOutputString);
        return;
    }

    CStrIn  str(lpOutputString);

    OutputDebugStringA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
PeekMessageWrapW(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax,
        UINT    wRemoveMsg)
{
    VALIDATE_PROTOTYPE(PeekMessage);

    FORWARD_AW(PeekMessage, (lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_WINMM_WRAPPER

LWSTDAPI_(BOOL)
PlaySoundWrapW(
        LPCWSTR pszSound,
        HMODULE hmod,
        DWORD fdwSound)
{
    if (g_bRunningOnNT)
    {
        return PlaySoundW(pszSound, hmod, fdwSound);
    }

    CStrIn strSound(pszSound);

    return PlaySoundA(strSound, hmod, fdwSound);
}

#endif // NEED_WINMM_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
PostMessageWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam)
{
    VALIDATE_PROTOTYPE(PostMessage);

    FORWARD_AW(PostMessage, (hWnd, Msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
PostThreadMessageWrapW(
        DWORD idThread,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam)
{
    VALIDATE_PROTOTYPE(PostThreadMessage);

    FORWARD_AW(PostThreadMessage, (idThread, Msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegCreateKeyWrapW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
{
    VALIDATE_PROTOTYPE(RegCreateKey);

    if (g_bRunningOnNT)
    {
        return RegCreateKeyW(hKey, lpSubKey, phkResult);
    }

    CStrIn  str(lpSubKey);

    return RegCreateKeyA(hKey, str, phkResult);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegCreateKeyExWrapW(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    VALIDATE_PROTOTYPE(RegCreateKeyEx);

    if (g_bRunningOnNT)
    {
        return RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes,  phkResult, lpdwDisposition);
    }

    CStrIn strSubKey(lpSubKey);
    CStrIn strClass(lpClass);

    return RegCreateKeyExA(hKey, strSubKey, Reserved, strClass, dwOptions, samDesired, lpSecurityAttributes,  phkResult, lpdwDisposition);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

//
//  Subtle difference:  RegDeleteKey on Win9x will recursively delete subkeys.
//  On NT, it fails if the key being deleted has subkeys.  If you need to
//  force NT-style behavior, use SHDeleteEmptyKey.  To force 95-style
//  behavior, use SHDeleteKey.
//
LONG APIENTRY
RegDeleteKeyWrapW(HKEY hKey, LPCWSTR pwszSubKey)
{
    VALIDATE_PROTOTYPE(RegDeleteKey);

    if (g_bRunningOnNT)
    {
        return RegDeleteKeyW(hKey, pwszSubKey);
    }

    CStrIn  str(pwszSubKey);

    return RegDeleteKeyA(hKey, str);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegDeleteValueWrapW(HKEY hKey, LPCWSTR pwszSubKey)
{
    VALIDATE_PROTOTYPE(RegDeleteValue);

    if (g_bRunningOnNT)
    {
        return RegDeleteValueW(hKey, pwszSubKey);
    }

    CStrIn  str(pwszSubKey);

    return RegDeleteValueA(hKey, str);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegEnumKeyWrapW(
        HKEY    hKey,
        DWORD   dwIndex,
        LPWSTR  lpName,
        DWORD   cbName)
{
    VALIDATE_PROTOTYPE(RegEnumKey);
    VALIDATE_OUTBUF(lpName, cbName);

    if (g_bRunningOnNT)
    {
        return RegEnumKeyW(hKey, dwIndex, lpName, cbName);
    }

    CStrOut str(lpName, cbName);

    return RegEnumKeyA(hKey, dwIndex, str, str.BufSize());
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegEnumKeyExWrapW(
        HKEY        hKey,
        DWORD       dwIndex,
        LPWSTR      lpName,
        LPDWORD     lpcbName,
        LPDWORD     lpReserved,
        LPWSTR      lpClass,
        LPDWORD     lpcbClass,
        PFILETIME   lpftLastWriteTime)
{
    VALIDATE_PROTOTYPE(RegEnumKeyEx);
    if (lpcbName) {VALIDATE_OUTBUF(lpName, *lpcbName);}
    if (lpcbClass) {VALIDATE_OUTBUF(lpClass, *lpcbClass);}

    if (g_bRunningOnNT)
    {
        return RegEnumKeyExW(
            hKey,
            dwIndex,
            lpName,
            lpcbName,
            lpReserved,
            lpClass,
            lpcbClass,
            lpftLastWriteTime);
    }

    long    ret;
    DWORD   dwClass = 0;

    if (!lpcbClass)
    {
        lpcbClass = &dwClass;
    }

    CStrOut strName(lpName, *lpcbName);
    CStrOut strClass(lpClass, *lpcbClass);

    ret = RegEnumKeyExA(
            hKey,
            dwIndex,
            strName,
            lpcbName,
            lpReserved,
            strClass,
            lpcbClass,
            lpftLastWriteTime);

    *lpcbName = strName.ConvertExcludingNul();
    *lpcbClass = strClass.ConvertExcludingNul();

    return ret;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegOpenKeyWrapW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
    VALIDATE_PROTOTYPE(RegOpenKey);

    if (g_bRunningOnNT)
    {
        return RegOpenKeyW(hKey, pwszSubKey, phkResult);
    }

    CStrIn  str(pwszSubKey);

    return RegOpenKeyA(hKey, str, phkResult);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegOpenKeyExWrapW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        DWORD   ulOptions,
        REGSAM  samDesired,
        PHKEY   phkResult)
{
    VALIDATE_PROTOTYPE(RegOpenKeyEx);

    if (g_bRunningOnNT)
    {
        return RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
    }

    CStrIn  str(lpSubKey);

    return RegOpenKeyExA(hKey, str, ulOptions, samDesired, phkResult);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegQueryInfoKeyWrapW(
        HKEY hKey,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime)
{
    VALIDATE_PROTOTYPE(RegQueryInfoKey);

    if (g_bRunningOnNT)
    {
            return RegQueryInfoKeyW(
                hKey,
                lpClass,
                lpcbClass,
                lpReserved,
                lpcSubKeys,
                lpcbMaxSubKeyLen,
                lpcbMaxClassLen,
                lpcValues,
                lpcbMaxValueNameLen,
                lpcbMaxValueLen,
                lpcbSecurityDescriptor,
                lpftLastWriteTime);

    }

    CStrIn  str(lpClass);

    return RegQueryInfoKeyA(
                hKey,
                str,
                lpcbClass,
                lpReserved,
                lpcSubKeys,
                lpcbMaxSubKeyLen,
                lpcbMaxClassLen,
                lpcValues,
                lpcbMaxValueNameLen,
                lpcbMaxValueLen,
                lpcbSecurityDescriptor,
                lpftLastWriteTime);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegQueryValueWrapW(
        HKEY    hKey,
        LPCWSTR pwszSubKey,
        LPWSTR  pwszValue,
        PLONG   lpcbValue)
{
    VALIDATE_PROTOTYPE(RegQueryValue);
    if (lpcbValue) {VALIDATE_OUTBUF(pwszValue, *lpcbValue);}

    if (g_bRunningOnNT)
    {
        return RegQueryValueW(hKey, pwszSubKey, pwszValue, lpcbValue);
    }

    long    ret;
    long    cb;
    CStrIn  strKey(pwszSubKey);
    CStrOut strValue(pwszValue, (lpcbValue ? ((*lpcbValue) / sizeof(WCHAR)) : 0));

    cb = strValue.BufSize();
    ret = RegQueryValueA(hKey, strKey, strValue, (lpcbValue ? &cb : NULL));
    if (ret != ERROR_SUCCESS)
        goto Cleanup;

    if (strValue)
    {
        cb = strValue.ConvertIncludingNul();
    }

    if (lpcbValue)
        *lpcbValue = cb * sizeof(WCHAR);

Cleanup:
    return ret;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegQueryValueExWrapW(
        HKEY    hKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData)
{
    VALIDATE_PROTOTYPE(RegQueryValueEx);
    if (lpcbData) {VALIDATE_OUTBUF(lpData, *lpcbData);}

    LONG    ret;
    DWORD   dwTempType;

    if (g_bRunningOnNT)
    {
#ifdef DEBUG
        if (lpType == NULL)
            lpType = &dwTempType;
#endif
        ret = RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

        return ret;
    }

    CStrIn  strValueName(lpValueName);
    DWORD   cb;

    //
    // Determine the type of buffer needed
    //

    ret = RegQueryValueExA(hKey, strValueName, lpReserved, &dwTempType, NULL, (lpcbData ? &cb : NULL));
    if (ret != ERROR_SUCCESS)
        goto Cleanup;

    ASSERT(dwTempType != REG_MULTI_SZ);

    switch (dwTempType)
    {
    case REG_EXPAND_SZ:
    case REG_SZ:
        {
            CStrOut strData((LPWSTR) lpData, (lpcbData ? ((*lpcbData) / sizeof(WCHAR)) : 0));

            cb = strData.BufSize();
            ret = RegQueryValueExA(hKey, strValueName, lpReserved, lpType, (LPBYTE)(LPSTR)strData, (lpcbData ? &cb : NULL));
            if (ret != ERROR_SUCCESS)
                break;

            if (strData)
            {
                cb = strData.ConvertIncludingNul();
            }

            if (lpcbData)
                *lpcbData = cb * sizeof(WCHAR);
            break;
        }

    default:
        {
            ret = RegQueryValueExA(
                    hKey,
                    strValueName,
                    lpReserved,
                    lpType,
                    lpData,
                    lpcbData);

            break;
        }
    }

Cleanup:
    return ret;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegSetValueWrapW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        DWORD   dwType,
        LPCWSTR lpData,
        DWORD   cbData)
{
    VALIDATE_PROTOTYPE(RegSetValue);

    if (g_bRunningOnNT)
    {
        return RegSetValueW(hKey, lpSubKey, dwType, lpData, cbData);
    }

    CStrIn  strKey(lpSubKey);
    CStrIn  strValue(lpData);

    return RegSetValueA(hKey, strKey, dwType, strValue, cbData);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegSetValueExWrapW(
        HKEY        hKey,
        LPCWSTR     lpValueName,
        DWORD       Reserved,
        DWORD       dwType,
        CONST BYTE* lpData,
        DWORD       cbData)
{
    VALIDATE_PROTOTYPE(RegSetValueEx);
    ASSERT(dwType != REG_MULTI_SZ);

    if (g_bRunningOnNT)
    {
        return RegSetValueExW(
            hKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData);
    }


    CStrIn      strKey(lpValueName);
    CStrIn      strSZ((dwType == REG_SZ || dwType == REG_EXPAND_SZ) ? (LPCWSTR) lpData : NULL);

    if (strSZ)
    {
        lpData = (LPBYTE) (LPSTR) strSZ;
        cbData = strSZ.strlen() + 1;
    }

    return RegSetValueExA(
            hKey,
            strKey,
            Reserved,
            dwType,
            lpData,
            cbData);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

ATOM WINAPI
RegisterClassWrapW(CONST WNDCLASSW * lpWndClass)
{
    VALIDATE_PROTOTYPE(RegisterClass);

    if (g_bRunningOnNT)
    {
        return RegisterClassW(lpWndClass);
    }

    WNDCLASSA   wc;
    CStrIn      strMenuName(lpWndClass->lpszMenuName);
    CStrIn      strClassName(lpWndClass->lpszClassName);

    ASSERT(sizeof(wc) == sizeof(*lpWndClass));
    memcpy(&wc, lpWndClass, sizeof(wc));

    wc.lpszMenuName = strMenuName;
    wc.lpszClassName = strClassName;

    return RegisterClassA(&wc);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

UINT WINAPI
RegisterClipboardFormatWrapW(LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(RegisterClipboardFormat);

    if (g_bRunningOnNT)
    {
        return RegisterClipboardFormatW(lpString);
    }

    CStrIn  str(lpString);

    return RegisterClipboardFormatA(str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

UINT WINAPI
RegisterWindowMessageWrapW(LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(RegisterWindowMessage);

    if (g_bRunningOnNT)
    {
        return RegisterWindowMessageW(lpString);
    }

    CStrIn  str(lpString);

    return RegisterWindowMessageA(str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
RemoveDirectoryWrapW(LPCWSTR lpszDir)
{
    VALIDATE_PROTOTYPE(RemoveDirectory);

    if (g_bRunningOnNT)
    {
        return RemoveDirectoryW(lpszDir);
    }

    CStrIn  strDir(lpszDir);

    return RemoveDirectoryA(strDir);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HANDLE WINAPI
RemovePropWrapW(
        HWND    hWnd,
        LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(RemoveProp);

    if (g_bRunningOnNT)
    {
        return RemovePropW(hWnd, lpString);
    }

    CStrIn  str(lpString);

    return RemovePropA(hWnd, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LRESULT WINAPI SendMessageWrapW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
//  NOTE (SumitC) Instead of calling SendDlgItemMessageA below, I'm forwarding to
//       SendMessageWrap so as not to have to re-do the special-case processing.
LRESULT WINAPI
SendDlgItemMessageWrapW(
        HWND    hDlg,
        int     nIDDlgItem,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam)
{
    VALIDATE_PROTOTYPE(SendDlgItemMessage);

    if (g_bRunningOnNT)
    {
        return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);
    }

    HWND hWnd;

    hWnd = GetDlgItem(hDlg, nIDDlgItem);

    return SendMessageWrapW(hWnd, Msg, wParam, lParam);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int CharIndexToByteIndex(LPCSTR psz, int cch)
{
    if (cch <= 0)
        return cch;

    LPCSTR pszTemp = psz;
    while (*pszTemp && cch-- > 0)
    {
        pszTemp = CharNextA(pszTemp);
    }

    return (int)(pszTemp - psz);
}

int ByteIndexToCharIndex(LPCSTR psz, int cb)
{
    if (cb <=0)
        return cb;

    LPCSTR pszTemp = psz;
    LPCSTR pszEnd = &psz[cb];
    int cch = 0;

    while (*pszTemp && pszTemp < pszEnd)
    {
        pszTemp = CharNextA(pszTemp);
        ++cch;
    }

    return cch;
}

//
// Translate between byte positions and "character" positions
//
void TranslateCharPos(HWND hwnd, BOOL fByteIndexToCharIndex, DWORD* pdwPos, int cPos)
{
    int cch = GetWindowTextLengthA(hwnd);
    if (cch > 0)
    {
        char szBuf[MAX_PATH];
        LPSTR pszBuf = szBuf;

        if (cch >= ARRAYSIZE(szBuf))
        {
            pszBuf = new char[cch + 1];
        }

        if (pszBuf)
        {
            GetWindowTextA(hwnd, (LPSTR)pszBuf, cch+1);

            // Translate Each value passed in
            while (cPos--)
            {
                if (fByteIndexToCharIndex)
                {
                    *pdwPos = (DWORD)ByteIndexToCharIndex(pszBuf, (int)*pdwPos);
                }
                else
                {
                    *pdwPos = (DWORD)CharIndexToByteIndex(pszBuf, (int)*pdwPos);
                }
                ++pdwPos;
            }

            if (pszBuf != szBuf)
            {
                delete [] pszBuf;
            }
        }
    }
}

//
//  There is no WM_GETOBJECT/OBJID_QUERYCLASSNAMEIDX code for comboex,
//  so we will just send CCM_GETUNICODEFORMAT and hope for the best.
//  We are relying on the fact that Win95's combo box returns 0 in response
//  to messages it doesn't understand (like CCM_GETUNICODEFORMAT).
//
#define IsUnicodeComboEx(hWnd) SendMessageA(hWnd, CCM_GETUNICODEFORMAT, 0, 0)

#ifdef DEBUG
int g_cSMTot, g_cSMHit;
int g_cSMMod = 100;
#endif

LRESULT WINAPI
SendMessageAThunk(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam)
{
#ifdef DEBUG
    if ((g_cSMTot % g_cSMMod) == 0)
        TraceMsg(DM_PERF, "sm: tot=%d hit=%d", g_cSMTot, g_cSMHit);
#endif
    DBEXEC(TRUE, g_cSMTot++);
    // todo: perf? seems to be pretty common case, at least for now...
    DBEXEC(Msg > WM_USER, g_cSMHit++);
#if 0
    if (Msg > WM_USER)
        goto Ldef;
#endif

    switch (Msg)
    {
        case EM_GETLINE:
        {
            LRESULT nLen;

            CStrOut str((LPWSTR) lParam, (* (SHORT *) lParam) + 1);
            * (SHORT *) (LPSTR) str = * (SHORT *) lParam;
            nLen = SendMessageA(hWnd, Msg, (WPARAM) wParam, (LPARAM) (LPSTR) str);
        
            if(nLen > 0)
                ((LPSTR) str)[nLen] = '\0';

            return nLen;
        }

        case EM_SETPASSWORDCHAR:
        {
            WPARAM  wp = 0;

            ASSERT(HIWORD64(wParam) == 0);
            SHUnicodeToAnsi((LPWSTR) &wParam, (LPSTR) &wp, sizeof(wp));
            ASSERT(HIWORD64(wp) == 0);

            return SendMessageA(hWnd, Msg, wp, lParam);
        }

        case EM_SETWORDBREAKPROC:
        {
            // There is a bug with how USER handles WH_CALLWNDPROC global hooks in Win95/98 that
            // causes us to blow up if one is installed and a wordbreakproc is set.  Thus,
            // if an app is running that has one of these hooks installed (intellipoint 1.1 etc.) then
            // if we install our wordbreakproc the app will fault when the proc is called.  There
            // does not appear to be any way for us to work around it since USER's thunking code
            // trashes the stack so this API is disabled for Win9x.
            TraceMsg(TF_WARNING, "EM_SETWORDBREAKPROC can fault on Win9x; see unicwrap.cpp for details");
            return FALSE;
        }

        case EM_GETSEL:
        {
            //
            // Convert multibyte indicies into unicode indicies 
            //
            DWORD dw[2];
            SendMessageA(hWnd, Msg, (WPARAM)&dw[0], (LPARAM)&dw[1]);
            TranslateCharPos(hWnd, TRUE, dw, ARRAYSIZE(dw));

            // Return the results
            DWORD* pdwStart = (DWORD*)wParam;
            DWORD* pdwEnd   = (DWORD*)lParam;
            if (pdwStart)
            {
                *pdwStart = dw[0];
            }
            if (pdwEnd) 
            {
                *pdwEnd = dw[1];
            }

            LRESULT lr = (LRESULT)-1;

            if (dw[0] <= 0xffff && dw[1] <= 0xffff)
            {
                lr = MAKELONG(dw[0], dw[1]);
            }
            return lr;
        }

        case EM_SETSEL:
        {
            //
            // Convert unicode char indicies into multibyte indicies
            //
            DWORD dw[2];
            dw[0] = (DWORD)wParam;  // start
            dw[1] = (DWORD)lParam;  // end

            TranslateCharPos(hWnd, FALSE, dw, ARRAYSIZE(dw));

            return SendMessageA(hWnd, Msg, (WPARAM)dw[0], (LPARAM)dw[1]);
        }

        case EM_CHARFROMPOS:
        {
            DWORD dwPos =  SendMessageA(hWnd, Msg, wParam, lParam);
            if (HIWORD(dwPos) == 0)
            {
                TranslateCharPos(hWnd, TRUE, &dwPos, 1);
            }
            return dwPos;
        }

        case WM_SETTEXT:
        case LB_ADDSTRING:
        case CB_ADDSTRING:
        case EM_REPLACESEL:
            RIPMSG(wParam == 0, "wParam should be 0 for these messages");
            // fall through
        case LB_FINDSTRING:
        case LB_FINDSTRINGEXACT:
        case LB_INSERTSTRING:
        case LB_SELECTSTRING:
        case CB_FINDSTRING:
        case CB_FINDSTRINGEXACT:
        case CB_INSERTSTRING:
        case CB_SELECTSTRING:
        {
            if (MLIsEnabled(hWnd))
            {
                UINT uiMsgTx;

                switch (Msg)
                {
                    case WM_SETTEXT:
                        uiMsgTx = g_ML_SETTEXT;
                        break;
                    case LB_ADDSTRING:
                        uiMsgTx = g_ML_LB_ADDSTRING;
                        break;
                    case CB_ADDSTRING:
                        uiMsgTx = g_ML_CB_ADDSTRING;
                        break;
                    case LB_FINDSTRING:
                        uiMsgTx = g_ML_LB_FINDSTRING;
                        break;
                    case LB_FINDSTRINGEXACT:
                        uiMsgTx = g_ML_LB_FINDSTRINGEXACT;
                        break;
                    case LB_INSERTSTRING:
                        uiMsgTx = g_ML_LB_INSERTSTRING;
                        break;
                    case LB_SELECTSTRING:
                        uiMsgTx = g_ML_LB_SELECTSTRING;
                        break;
                    case CB_FINDSTRING:
                        uiMsgTx = g_ML_CB_FINDSTRING;
                        break;
                    case CB_FINDSTRINGEXACT:
                        uiMsgTx = g_ML_CB_FINDSTRINGEXACT;
                        break;
                    case CB_INSERTSTRING:
                        uiMsgTx = g_ML_CB_INSERTSTRING;
                        break;
                    case CB_SELECTSTRING:
                        uiMsgTx = g_ML_CB_SELECTSTRING;
                        break;

                    default:
                        ASSERT(0);
                }

                return SendMessageA(hWnd, uiMsgTx, wParam, lParam);
            }
            else if (Msg == CB_FINDSTRINGEXACT && IsUnicodeComboEx(hWnd))
            {
                // ComboEx is in UNICODE mode so we can send it the
                // unicode string
                goto Ldef;
            }
            else
            {
                // WARNING: in the ADDSTRING and INSERTSTRING cases for OWNERDRAW !HASSTRING
                // then this is a pointer to a structure and not a string!!!  (Seems that only
                // code that does this is comctl32's comboex, which currently doesn't come here.)
                //
                CStrIn  str((LPWSTR) lParam);

                return SendMessageA(hWnd, Msg, wParam, (LPARAM) (LPSTR) str);
            }
        }

        case WM_GETTEXT:
        case LB_GETTEXT:
        case CB_GETLBTEXT:
        {
            if (MLIsEnabled(hWnd))
            {
                UINT uiMsgTx;

                switch (Msg)
                {
                    case WM_GETTEXT:
                        uiMsgTx = g_ML_GETTEXT;
                        break;
                    case LB_GETTEXT:
                        uiMsgTx = g_ML_LB_GETTEXT;
                        break;
                    case CB_GETLBTEXT:
                        uiMsgTx = g_ML_CB_GETLBTEXT;
                        break;

                    default:
                        ASSERT(0);
                }

                return SendMessageA(hWnd, uiMsgTx, wParam, lParam);
            }
            else if (Msg == CB_GETLBTEXT && IsUnicodeComboEx(hWnd))
            {
                // ComboEx is in UNICODE mode so we can send it the
                // unicode string
                goto Ldef;
            }
            else
            {
                int iStrLen;

                switch (Msg)
                {
                    case WM_GETTEXT:
                        iStrLen = (int)wParam;
                        break;
                    case LB_GETTEXT:
                        iStrLen = SendMessageA(hWnd, LB_GETTEXTLEN, wParam, lParam);
                        if (iStrLen == LB_ERR)
                            iStrLen = 255;
                        break;
                    case CB_GETLBTEXT:
                        iStrLen = SendMessageA(hWnd, CB_GETLBTEXTLEN, wParam, lParam);
                        if (iStrLen == CB_ERR)
                            iStrLen = 255;
                        break;

                    default:
                        ASSERT(0);
                }

                CStrOut str((LPWSTR)lParam, (iStrLen + 1));
                SendMessageA(hWnd, Msg, wParam, (LPARAM) (LPSTR) str);

                return str.ConvertExcludingNul();
            }
        }

        case WM_GETTEXTLENGTH:
        case LB_GETTEXTLEN:
        case CB_GETLBTEXTLEN:
        {
            UINT uiMsgTx;

            if (MLIsEnabled(hWnd))
            {
                switch (Msg)
                {
                    case WM_GETTEXTLENGTH:
                        uiMsgTx = g_ML_GETTEXTLENGTH;
                        break;
                    case LB_GETTEXTLEN:
                        uiMsgTx = g_ML_LB_GETTEXTLEN;
                        break;
                    case CB_GETLBTEXTLEN:
                        uiMsgTx = g_ML_CB_GETLBTEXTLEN;
                        break;

                    default:
                        ASSERT(0);
                }


                return SendMessageA(hWnd, uiMsgTx, wParam, lParam);
            }
            else
            {
                // Bug: #70280
                // we can not just return the size of ANSI character back, it breaks some localized
                // version of Win98 with localized IE/OE scenario: some apps rely on the returned size
                // in characters to show the string and may cause the garbage displayed beyond the end of
                // the actual string.
                //
                LPWSTR lpwszTemp = NULL;
                int iWCharLen = 0;
                int iAnsiCharLen = SendMessageA(hWnd, Msg, wParam, lParam);
                if ((iAnsiCharLen <= 0) || (LB_ERR == iAnsiCharLen) || (CB_ERR == iAnsiCharLen))
                {
                    iWCharLen = iAnsiCharLen;   // return error if we can not get the ANSI string length
                    goto L_Rtn;
                }

                // we always allocate the wide string buffer in the size of ANSI string length plus 1,
                // it should be big enough to hold the returned wide string.
                lpwszTemp = (LPWSTR)LocalAlloc(LPTR, ((iAnsiCharLen + 1) * sizeof(WCHAR)));
                if (!lpwszTemp)
                    goto L_Rtn;

                switch (Msg)
                {
                    case WM_GETTEXTLENGTH:
                        uiMsgTx = WM_GETTEXT;
                        break;
                    case LB_GETTEXTLEN:
                        uiMsgTx = LB_GETTEXT;
                        break;
                    case CB_GETLBTEXTLEN:
                        uiMsgTx = CB_GETLBTEXT;
                        break;

                    default:
                        ASSERT(0);
                }

                iWCharLen = SendMessageAThunk(hWnd, uiMsgTx,
                                              ((uiMsgTx == WM_GETTEXT) ? (WPARAM)(iAnsiCharLen + 1) : wParam),
                                              (LPARAM)lpwszTemp);

L_Rtn:
                if (lpwszTemp)
                    LocalFree(lpwszTemp);

                // if error occured, we'll return the error (WM_, LB_, CB_),
                // if fail to allocate memory, we'll return 0, the initial value of iWCharlen.
                return (LRESULT)iWCharLen;
            }
        }

        case WM_SETTINGCHANGE:
        {
            if (lParam)
            {
                CStrIn str((LPWSTR)lParam);
                LRESULT lRes = 0;
                SendMessageTimeoutA(hWnd, Msg, wParam, (LPARAM) (LPSTR) str,
                                    SMTO_NORMAL, 3000, (PULONG_PTR)&lRes);

                return lRes;
            }
            goto Ldef;
        }

        // The new unicode comctl32.dll handles these correctly so we don't need to thunk:
        // TTM_DELTOOL, TTM_ADDTOOL, TVM_INSERTITEM, TVM_GETITEM, TCM_INSERTITEM, TCM_SETITEM

        default:
Ldef:
            return SendMessageA(hWnd, Msg, wParam, lParam);
    }
}


LRESULT WINAPI
SendMessageTimeoutAThunk(
        HWND    hWnd,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam,
        UINT    fuFlags,
        UINT    uTimeout,
        PULONG_PTR lpdwResult)
{
    switch (uMsg)
    {
    case WM_SETTINGCHANGE:
        {
            if (lParam)
            {
                CStrIn str((LPWSTR)lParam);
                return SendMessageTimeoutA(hWnd, uMsg, wParam, (LPARAM)(LPSTR)str,
                                    fuFlags, uTimeout, lpdwResult);
            }
        }
        break;
    }
    return SendMessageTimeoutA(hWnd, uMsg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
}


LRESULT FORWARD_API WINAPI
SendMessageTimeoutWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam,
        UINT    fuFlags,
        UINT    uTimeout,
        PULONG_PTR lpdwResult)
{
    VALIDATE_PROTOTYPE(SendMessage);

    // perf: we should do _asm here (see CallWindowProcWrapW), but
    // to do that we need to 'outline' the below switch (o.w. we
    // can't be 'naked').  that in turn slows down the non-NT case...

#ifndef UNIX
    THUNK_AW(SendMessageTimeout, (hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult));
#else
    return SendMessageTimeoutW(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
#endif
}

LRESULT FORWARD_API WINAPI
SendMessageWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam)
{
    VALIDATE_PROTOTYPE(SendMessage);

    // perf: we should do _asm here (see CallWindowProcWrapW), but
    // to do that we need to 'outline' the below switch (o.w. we
    // can't be 'naked').  that in turn slows down the non-NT case...

#ifndef UNIX
    // n.b. THUNK not FORWARD
    THUNK_AW(SendMessage, (hWnd, Msg, wParam, lParam));
#else
    return SendMessageW(hWnd, Msg, wParam, lParam);
#endif
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
SetCurrentDirectoryWrapW(LPCWSTR lpszCurDir)
{
    VALIDATE_PROTOTYPE(SetCurrentDirectory);

    if (g_bRunningOnNT)
    {
        return SetCurrentDirectoryW(lpszCurDir);
    }

    CStrIn  str(lpszCurDir);

    return SetCurrentDirectoryA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SetDlgItemTextWrapW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(SetDlgItemText);

    HWND hWnd = GetDlgItem(hDlg, nIDDlgItem);

    if (hWnd)
        return SetWindowTextWrapW(hWnd, lpString);
    else
        return FALSE;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SetPropWrapW(
    HWND    hWnd,
    LPCWSTR lpString,
    HANDLE  hData)
{
    VALIDATE_PROTOTYPE(SetProp);

    if (g_bRunningOnNT)
    {
        return SetPropW(hWnd, lpString, hData);
    }

    CStrIn  str(lpString);

    return SetPropA(hWnd, str, hData);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LONG FORWARD_API WINAPI
SetWindowLongWrapW(HWND hWnd, int nIndex, LONG dwNewLong)
{
    VALIDATE_PROTOTYPE(SetWindowLong);

    FORWARD_AW(SetWindowLong, (hWnd, nIndex, dwNewLong));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HHOOK
FORWARD_API WINAPI
SetWindowsHookExWrapW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId)
{
    VALIDATE_PROTOTYPE(SetWindowsHookEx);

    FORWARD_AW(SetWindowsHookEx, (idHook, lpfn, hmod, dwThreadId));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SetWindowTextWrapW(HWND hWnd, LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(SetWindowText);

    if (MLIsEnabled(hWnd))
        return MLSetControlTextI(hWnd, lpString);

    if (g_bRunningOnNT)
    {
        return SetWindowTextW(hWnd, lpString);
    }

    CStrIn  str(lpString);

    return SetWindowTextA(hWnd, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SystemParametersInfoWrapW(
        UINT    uiAction,
        UINT    uiParam,
        PVOID   pvParam,
        UINT    fWinIni)
{
    VALIDATE_PROTOTYPE(SystemParametersInfo);

    if (g_bRunningOnNT)
    {
        return SystemParametersInfoW(
                        uiAction,
                        uiParam,
                        pvParam,
                        fWinIni);
    }

    BOOL        ret;
    char        ach[LF_FACESIZE];

    if (uiAction == SPI_SETDESKWALLPAPER)
    {
        CStrIn str((LPCWSTR) pvParam);

        ret = SystemParametersInfoA(
                        uiAction,
                        uiParam,
                        str,
                        fWinIni);
    }
    else
        ret = SystemParametersInfoA(
                        uiAction,
                        uiParam,
                        pvParam,
                        fWinIni);

    if ((uiAction == SPI_GETICONTITLELOGFONT) && ret)
    {
        strcpy(ach, ((LPLOGFONTA)pvParam)->lfFaceName);
        SHAnsiToUnicode(ach, ((LPLOGFONTW)pvParam)->lfFaceName, ARRAYSIZE(((LPLOGFONTW)pvParam)->lfFaceName));
    }

    return ret;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int FORWARD_API WINAPI
TranslateAcceleratorWrapW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
{
    VALIDATE_PROTOTYPE(TranslateAccelerator);

    FORWARD_AW(TranslateAccelerator, (hWnd, hAccTable, lpMsg));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
UnregisterClassWrapW(LPCWSTR lpClassName, HINSTANCE hInstance)
{
    VALIDATE_PROTOTYPE(UnregisterClass);

    if (g_bRunningOnNT)
    {
        return UnregisterClassW(lpClassName, hInstance);
    }

    CStrIn  str(lpClassName);

    return UnregisterClassA(str, hInstance);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

SHORT
WINAPI
VkKeyScanWrapW(WCHAR ch)
{
    VALIDATE_PROTOTYPE(VkKeyScan);

    if (g_bRunningOnNT)
    {
        return VkKeyScanW(ch);
    }

    CStrIn str(&ch, 1);

    return VkKeyScanA(*(char *)str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
WinHelpWrapW(HWND hwnd, LPCWSTR szFile, UINT uCmd, ULONG_PTR dwData)
{
    VALIDATE_PROTOTYPE(WinHelp);
  
    if (g_bRunningOnNT)
    {
        return WinHelpW(hwnd, szFile, uCmd, dwData);
    }

    CStrIn  str(szFile);

    return WinHelpA(hwnd, str, uCmd, dwData);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

//+---------------------------------------------------------------------------
//
//  Function:   wvsprintfW
//
//  Synopsis:   Nightmare string function
//
//  Arguments:  [pwszOut]    --
//              [pwszFormat] --
//              [...]        --
//
//  Returns:
//
//  History:    1-06-94   ErikGav   Created
//
//  Notes:      If you're reading this, you're probably having a problem with
//              this function.  Make sure that your "%s" in the format string
//              says "%ws" if you are passing wide strings.
//
//              %s on NT means "wide string"
//              %s on Chicago means "ANSI string"
//
//  NOTE:       This function should not be used.  Use Format instead.
//
//----------------------------------------------------------------------------

int WINAPI
wvsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, va_list arglist)
{
    VALIDATE_PROTOTYPE(wvsprintf);

    if (g_bRunningOnNT)
    {
        return wvsprintfW(pwszOut, pwszFormat, arglist);
    }

    // Old code created a 1K ansi output buffer for wvsprintfA and then
    // thunked the result.  If we're going to do that, might as
    // well create a 1K unicode output buffer and call our wvnsprintfW
    // implementation directly.  Two benefits: 1) no buffer overrun
    // and 2) native W implementation so we can handle unicode strings!
    WCHAR wszOut[1024];

    wvnsprintfW(wszOut, ARRAYSIZE(wszOut), pwszFormat, arglist);

    // Roll our own "ConvertExcludingNul" since this is W->W
    int ret = SHUnicodeToUnicode(wszOut, pwszOut, ARRAYSIZE(wszOut));
    if (ret > 0)
    {
        ret -= 1;
    }
    return ret;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_MPR_WRAPPER

//+---------------------------------------------------------------------------
//
//  Function:   WNetRestoreConnectionWrapW
//
//----------------------------------------------------------------------------

DWORD WINAPI WNetRestoreConnectionWrapW(IN HWND hwndParent, IN LPCWSTR pwzDevice)
{
    if (g_bRunningOnNT)
    {
        return WNetRestoreConnectionW(hwndParent, pwzDevice);
    }

    CStrIn  strIn(pwzDevice);
    return WNetRestoreConnectionA(hwndParent, strIn);
}

#endif // NEED_MPR_WRAPPER

#ifdef NEED_MPR_WRAPPER

//+---------------------------------------------------------------------------
//
//  Function:   WNetGetLastErrorWrapW
//
//
//----------------------------------------------------------------------------

DWORD WINAPI WNetGetLastErrorWrapW(OUT LPDWORD pdwError, OUT LPWSTR pwzErrorBuf, IN DWORD cchErrorBufSize, OUT LPWSTR pwzNameBuf, IN DWORD cchNameBufSize)
{
    VALIDATE_PROTOTYPE(WNetGetLastError);

    if (g_bRunningOnNT)
    {
        return WNetGetLastErrorW(pdwError, pwzErrorBuf, cchErrorBufSize, pwzNameBuf, cchNameBufSize);
    }

    // Consider: Out-string bufsize too large or small?
    CStrOut strErrorOut(pwzErrorBuf, cchErrorBufSize);
    CStrOut strNameOut(pwzNameBuf, cchNameBufSize);

    DWORD dwResult = WNetGetLastErrorA(pdwError, strErrorOut, strErrorOut.BufSize(), strNameOut, strNameOut.BufSize());

    strErrorOut.ConvertExcludingNul();
    strNameOut.ConvertExcludingNul();
    return dwResult;
}

#endif // NEED_MPR_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI DrawTextExWrapW(
    HDC hdc,    // handle of device context
    LPWSTR pwzText, // address of string to draw
    int cchText,    // length of string to draw
    LPRECT lprc,    // address of rectangle coordinates
    UINT dwDTFormat,    // formatting options
    LPDRAWTEXTPARAMS lpDTParams // address of structure for more options
   )
{
    VALIDATE_PROTOTYPE(DrawTextEx);
    if (_MayNeedFontLinking(pwzText, cchText))
    {
        return DrawTextExFLW(hdc, pwzText, cchText, lprc, dwDTFormat, lpDTParams);
    }
    else if (g_bRunningOnNT)
    {
        return DrawTextExW(hdc, pwzText, cchText, lprc, dwDTFormat, lpDTParams);
    }
    CStrIn strText(pwzText, cchText);
    return DrawTextExA(hdc, strText, strText.strlen(), lprc, dwDTFormat, lpDTParams);
}

#endif // NEED_USER32_WRAPPER

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

void SetThunkMenuItemInfoWToA(LPCMENUITEMINFOW pmiiW, LPMENUITEMINFOA pmiiA, LPSTR pszBuffer, DWORD cchSize)
{
    *pmiiA = *(LPMENUITEMINFOA) pmiiW;

    // MFT_STRING is Zero. So MFT_STRING & anything evaluates to False.
    // so instead you have to check for the absence of non-string items
    if ((pmiiW->dwTypeData) && (MFT_NONSTRING & pmiiW->fType) == 0)
    {
        pmiiA->dwTypeData = pszBuffer;
        pmiiA->cch = cchSize;
        SHUnicodeToAnsi(pmiiW->dwTypeData, pmiiA->dwTypeData, cchSize);
    }
}

void GetThunkMenuItemInfoWToA(LPCMENUITEMINFOW pmiiW, LPMENUITEMINFOA pmiiA, LPSTR pszBuffer, DWORD cchSize)
{
    *pmiiA = *(LPMENUITEMINFOA) pmiiW;

    if ((pmiiW->dwTypeData) && (MFT_STRING & pmiiW->fType))
    {
        pszBuffer[0] = 0;
        pmiiA->dwTypeData = pszBuffer;
        pmiiA->cch = cchSize;
    }
}

void GetThunkMenuItemInfoAToW(LPCMENUITEMINFOA pmiiA, LPMENUITEMINFOW pmiiW)
{
    LPWSTR pwzText = pmiiW->dwTypeData;
    UINT cch = pmiiW->cch;

    *pmiiW = *(LPMENUITEMINFOW) pmiiA;
    pmiiW->dwTypeData = pwzText;
    pmiiW->cch = cch;

    if ((pmiiA->cch > 0) && (pmiiA->dwTypeData) && (pwzText) && !((MFT_SEPARATOR | MFT_BITMAP) & pmiiA->fType))
        SHAnsiToUnicode(pmiiA->dwTypeData, pmiiW->dwTypeData, pmiiW->cch);
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI GetMenuItemInfoWrapW(
    HMENU  hMenu,
    UINT  uItem,
    BOOL  fByPosition,
    LPMENUITEMINFOW  pmiiW)
{
    BOOL fResult;
    VALIDATE_PROTOTYPE(GetMenuItemInfo);
    ASSERT(pmiiW->cbSize == MENUITEMINFOSIZE_WIN95); // Ensure Win95 compatibility

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();
    BOOL fItemData;
    DWORD_PTR dwItemData;
    LPWSTR pwz;
    UINT cch;

    if (bOwnerDraw)
    {
        if (MIIM_DATA & pmiiW->fMask)
            fItemData = TRUE;
        else
        {
            fItemData = FALSE;
            pmiiW->fMask |= MIIM_DATA;
        }
        pwz = pmiiW->dwTypeData;        // save original buffer pointer
        cch = pmiiW->cch;               // save original buffer size
        dwItemData = pmiiW->dwItemData; // save original dwItemData size
    }

#ifndef UNIX
    // Widechar API's are messed up in MAINWIN. For now assume not ruuning on
    // NT for this.
    if (g_bRunningOnNT)
        fResult = GetMenuItemInfoW(hMenu, uItem, fByPosition, pmiiW);
    else
#endif
    {
        if (pmiiW->fMask & MIIM_TYPE)
        {
            MENUITEMINFOA miiA = *(LPMENUITEMINFOA)pmiiW;
            LPSTR pszText = NULL;

            if (pmiiW->cch > 0)
                pszText = new char[pmiiW->cch * 2];  // for DBCS, we multifly by 2

            miiA.dwTypeData = pszText;
            miiA.cch = (pszText)? pmiiW->cch * 2: 0; // set correct buffer size
            fResult = GetMenuItemInfoA(hMenu, uItem, fByPosition, &miiA);
            GetThunkMenuItemInfoAToW(&miiA, pmiiW);

            if (pszText)
                delete pszText;
        }
        else
            fResult = GetMenuItemInfoA(hMenu, uItem, fByPosition, (LPMENUITEMINFOA) pmiiW); // It doesn't contain a string so W and A are the same.
    }

    if (bOwnerDraw)
    {
        if ((MIIM_TYPE & pmiiW->fMask) && (MFT_OWNERDRAW & pmiiW->fType))
        {
            LPPUIMENUITEM lpItem = (LPPUIMENUITEM)pmiiW->dwItemData;

            if (!IsBadReadPtr(lpItem, sizeof(lpItem->dwSig)) && PUI_OWNERDRAW_SIG == lpItem->dwSig && !(MFT_OWNERDRAW & lpItem->fType))
            {
                if ((cch > 0) && pwz && !((MFT_SEPARATOR | MFT_BITMAP) & pmiiW->fType))
                {
                    StrCpyNW(pwz, lpItem->lpwz, cch);
                    pmiiW->dwTypeData = pwz;
                    pmiiW->cch = lpItem->cch;
                    pmiiW->fType &= ~MFT_OWNERDRAW;
                    if (fItemData)
                        pmiiW->dwItemData = lpItem->dwItemData;
                    else
                        pmiiW->dwItemData = dwItemData;
                }
            }
        }
    }

    return fResult;
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI InsertMenuItemWrapW(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFOW pmiiW)
{
    VALIDATE_PROTOTYPE(InsertMenuItem);
    ASSERT(pmiiW->cbSize == MENUITEMINFOSIZE_WIN95); // Ensure Win95 compatibility

    BOOL fResult;

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();
    MENUITEMINFOW miiW;

    if (bOwnerDraw)
    {
        MungeMenuItem(hMenu, pmiiW, &miiW);
        pmiiW = &miiW;
    }

    if (g_bRunningOnNT)
        return InsertMenuItemW(hMenu, uItem, fByPosition, pmiiW);

    MENUITEMINFOA miiA;
    CHAR szText[INTERNET_MAX_URL_LENGTH];

    SetThunkMenuItemInfoWToA(pmiiW, &miiA, szText, ARRAYSIZE(szText));
    fResult = InsertMenuItemA(hMenu, uItem, fByPosition, &miiA);

    return fResult;
}

// This is required for ML, so do not put inside #ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SetMenuItemInfoWrapW(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFOW lpmiiW)
{
    VALIDATE_PROTOTYPE(SetMenuItemInfo);
    ASSERT(lpmiiW->cbSize == MENUITEMINFOSIZE_WIN95); // Ensure Win95 compatibility

    static BOOL bOwnerDraw = NeedMenuOwnerDraw();
    MENUITEMINFOW miiW;

    if (bOwnerDraw)
    {
        if ( (MIIM_TYPE & lpmiiW->fMask) &&
             0 == (lpmiiW->fType & (MFT_BITMAP | MFT_SEPARATOR)))
        {
            DeleteOwnerDrawMenuItem(hMenu, uItem, fByPosition);
            MungeMenuItem(hMenu, lpmiiW, &miiW);
            lpmiiW = &miiW;
        }
    }

    if (g_bRunningOnNT)
    {
        return SetMenuItemInfoW( hMenu, uItem, fByPosition, lpmiiW);
    }

    BOOL fRet;

    ASSERT( sizeof(MENUITEMINFOW) == sizeof(MENUITEMINFOA) &&
            FIELD_OFFSET(MENUITEMINFOW, dwTypeData) ==
            FIELD_OFFSET(MENUITEMINFOA, dwTypeData) );

    if ( (MIIM_TYPE & lpmiiW->fMask) &&
         0 == (lpmiiW->fType & (MFT_BITMAP | MFT_SEPARATOR)))
    {
        MENUITEMINFOA miiA;
        // the cch is ignored on SetMenuItemInfo
        CStrIn str((LPWSTR)lpmiiW->dwTypeData, -1);

        memcpy( &miiA, lpmiiW, sizeof(MENUITEMINFOA) );
        miiA.dwTypeData = (LPSTR)str;
        miiA.cch = str.strlen();

        fRet = SetMenuItemInfoA( hMenu, uItem, fByPosition, &miiA );
    }
    else
    {
        fRet = SetMenuItemInfoA( hMenu, uItem, fByPosition,
                                 (LPCMENUITEMINFOA)lpmiiW );
    }

    return fRet;
}

#ifdef NEED_GDI32_WRAPPER

HFONT WINAPI
CreateFontWrapW(int  nHeight,   // logical height of font
                int  nWidth,    // logical average character width
                int  nEscapement,   // angle of escapement
                int  nOrientation,  // base-line orientation angle
                int  fnWeight,  // font weight
                DWORD  fdwItalic,   // italic attribute flag
                DWORD  fdwUnderline,    // underline attribute flag
                DWORD  fdwStrikeOut,    // strikeout attribute flag
                DWORD  fdwCharSet,  // character set identifier
                DWORD  fdwOutputPrecision,  // output precision
                DWORD  fdwClipPrecision,    // clipping precision
                DWORD  fdwQuality,  // output quality
                DWORD  fdwPitchAndFamily,   // pitch and family
                LPCWSTR  pwzFace)   // address of typeface name string )
{
    VALIDATE_PROTOTYPE(CreateFont);

    if (g_bRunningOnNT)
    {
        return CreateFontW(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic,
                        fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision,
                        fdwClipPrecision, fdwQuality, fdwPitchAndFamily, pwzFace);
    }

    CStrIn  str(pwzFace);
    return CreateFontA(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic,
                        fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision,
                        fdwClipPrecision, fdwQuality, fdwPitchAndFamily, str);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI CreateMutexWrapW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR pwzName)
{
    VALIDATE_PROTOTYPE(CreateMutex);

    if (g_bRunningOnNT)
        return CreateMutexW(lpMutexAttributes, bInitialOwner, pwzName);

    CStrIn strText(pwzName);
    return CreateMutexA(lpMutexAttributes, bInitialOwner, strText);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

HDC WINAPI CreateMetaFileWrapW(LPCWSTR pwzFile)
{
    VALIDATE_PROTOTYPE(CreateMetaFile);

    if (g_bRunningOnNT)
        return CreateMetaFileW(pwzFile);

    CStrIn strText(pwzFile);
    return CreateMetaFileA(strText);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

// ExpandEnvironmentStrings returns the size of the needed string
DWORD WINAPI ExpandEnvironmentStringsWrapW(LPCWSTR pwzSrc, LPWSTR pwzDst, DWORD cchSize)
{
    DWORD dwRet;

    if (pwzDst)
    {
        VALIDATE_OUTBUF(pwzDst, cchSize);
    }

    if (g_bRunningOnNT)
    {
        dwRet = ExpandEnvironmentStringsW(pwzSrc, pwzDst, cchSize);
    }
    else
    {
        CStrIn strTextIn(pwzSrc);
        CStrOut strTextOut(pwzDst, cchSize);
        DWORD dwResult = ExpandEnvironmentStringsA(strTextIn, strTextOut, strTextOut.BufSize());
        DWORD dwResultUnicode = strTextOut.ConvertIncludingNul();

        // NT4 returned the number of bytes in the UNICODE string, not the number
        // of bytes in the ANSI string.  NT5 returns the number of bytes in the UNICODE
        // string divided by 2, so it has even less bearing on the ansi string.  Hopefully
        // the Win9x implementations did the right thing...
        //
        if (dwResult <= cchSize)
        {
            ASSERT(dwResultUnicode <= dwResult);
            dwRet = dwResultUnicode; // we fit in the out buffer, give accurate count
        }
        else
        {
            dwRet = dwResult; // buffer was too small, let caller know (NOTE: this may be bigger than needed)
        }
    }

    return dwRet;
}

#endif // NEED_KERNEL32_WRAPPER

// SHExpandEnvironmentStrings
//
// In all cases, this returns a valid output buffer.  The buffer may
// be empty, or it may be truncated, but you can always use the string.
//
// RETURN VALUE:
//   0  implies failure, either a truncated expansion or no expansion whatsoever
//   >0 implies complete expansion, value is count of characters written (excluding NULL)
//
DWORD WINAPI SHExpandEnvironmentStringsForUserW(HANDLE hToken, LPCWSTR pwzSrc, LPWSTR pwzDst, DWORD cchSize)
{
    DWORD   dwRet;

    // 99/05/28 vtan: Handle specified users here. It's a Windows NT
    // thing only. Check for both conditions then load the function
    // dynamically out of userenv.dll. If the function cannot be
    // located or returns a problem default to the current user as
    // NULL hToken.

    if (g_bRunningOnNT5OrHigher && (hToken != NULL))
    {
        VALIDATE_OUTBUF(pwzDst, cchSize);
        if (NT5_ExpandEnvironmentStringsForUserW(hToken, pwzSrc, pwzDst, cchSize) != FALSE)
        {

            // userenv!ExpandEnvironmentStringsForUser returns
            // a BOOL result. Convert this to a DWORD result
            // that matches what kernel32!ExpandEnvironmentStrings
            // returns.

            dwRet = lstrlenW(pwzDst) + sizeof('\0');
        }
        else
        {
            dwRet = 0;
        }
    }
    else
    {
        dwRet = ExpandEnvironmentStringsWrapW(pwzSrc, pwzDst, cchSize);
    }

    // The implementations of this function don't seem to gurantee gurantee certain
    // things about the output buffer in failure conditions that callers rely on.
    // So clean things up here.
    //
    // And I found code occasionally that handled semi-failure (success w/ dwRet>cchSize)
    // that assumed the string wasn't properly NULL terminated in this case.  Fix that here
    // in the wrapper so our callers don't have to wig-out about errors.
    //
    // NOTE: we map all failures to 0 too.
    //
    if (dwRet > cchSize)
    {
        // Buffer too small, some code assumed there was still a string there and
        // tried to NULL terminate, do it for them.
        SHTruncateString(pwzDst, cchSize);
        dwRet = 0;
    }
    else if (dwRet == 0)
    {
        // Failure, assume no expansions...
        StrCpyNW(pwzDst, pwzSrc, cchSize);
    }

    return dwRet;
}

DWORD WINAPI SHExpandEnvironmentStringsW(LPCWSTR pwzSrc, LPWSTR pwzDst, DWORD cchSize)
{
    return(SHExpandEnvironmentStringsForUserW(NULL, pwzSrc, pwzDst, cchSize));
}

DWORD WINAPI SHExpandEnvironmentStringsForUserA(HANDLE hToken, LPCSTR pszSrc, LPSTR pszDst, DWORD cchSize)
{
    DWORD dwRet;

    // 99/05/28 vtan: The ANSI version of SHExpandEnvironmentStringsForUser
    // exists in case somebody calls the ANSI implementation in WindowsNT.
    // This is meaningless on Win9x. This just thunks parameters and invokes
    // the Unicode implementation. If a problem occurs when thunking just
    // use the current user.

    if (g_bRunningOnNT5OrHigher && (hToken != NULL))
    {
        DWORD       dwResultAnsi;
        CStrInW     strInW(pszSrc);
        CStrOutW    strOutW(pszDst, cchSize);

        dwRet = SHExpandEnvironmentStringsForUserW(hToken, strInW, strOutW, strOutW.BufSize());
        dwResultAnsi = strOutW.ConvertIncludingNul();
        if (dwResultAnsi <= cchSize)
            dwRet = dwResultAnsi;
    }
    else
    {
        // NT4 returns the number of bytes in the UNICODE string.
        //
        // NT5 (as of June 99) returns the number of bytes in the UNICODE string / 2, so it
        // really has no accurate bearing on the number of ansi characters.  Plus we're not
        // guranteed buffer truncation in failure case.
        //
        // Not much we can do about it here, eh?  Hopefully our callers ignore the return result...
        //
        dwRet = ExpandEnvironmentStringsA(pszSrc, pszDst, cchSize);
    }

    // The implementations of this function don't seem to gurantee gurantee certain
    // things about the output buffer in failure conditions that callers rely on.
    // So clean things up here.
    //
    // And I found code occasionally that handled semi-failure (success w/ dwRet>cchSize)
    // that assumed the string wasn't properly NULL terminated in this case.  Fix that here
    // in the wrapper so our callers don't have to wig-out about errors.
    //
    // NOTE: we map all failures to 0 too.
    //
    if (dwRet > cchSize)
    {
        // Buffer too small, make sure it's NULL terminated.
        SHTruncateString(pszDst, cchSize);
        dwRet = 0;
    }
    else if (dwRet == 0)
    {
        // Failure, assume no expansions...
        StrCpyNA(pszDst, pszSrc, cchSize);
    }

    return dwRet;
}

DWORD WINAPI SHExpandEnvironmentStringsA(LPCSTR pszSrc, LPSTR pszDst, DWORD cchSize)
{
    return(SHExpandEnvironmentStringsForUserA(NULL, pszSrc, pszDst, cchSize));
}

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI CreateSemaphoreWrapW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR pwzName)
{
    VALIDATE_PROTOTYPE(CreateSemaphore);
    if (g_bRunningOnNT)
        return CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, pwzName);

    CStrIn strText(pwzName);
    return CreateSemaphoreA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, strText);
}

#endif // NEED_KERNEL32_WRAPPER

// FEATURE: Todo - GetStartupInfoWrapW

#ifdef NEED_KERNEL32_WRAPPER

#define ISGOOD 0
#define ISBAD 1

BOOL WINAPI IsBadStringPtrWrapW(LPCWSTR pwzString, UINT_PTR ucchMax)
{
    VALIDATE_PROTOTYPE(IsBadStringPtr);
    if (g_bRunningOnNT)
        return IsBadStringPtrW(pwzString, ucchMax);

    if (!ucchMax)
        return ISGOOD;

    if (!pwzString)
        return ISBAD;

    LPCWSTR pwzStartAddress = pwzString;
    // ucchMax maybe -1 but that's ok because the loop down below will just
    // look for the terminator.
    LPCWSTR pwzEndAddress = &pwzStartAddress[ucchMax - 1];
    TCHAR chTest;

    _try
    {
        chTest = *(volatile WCHAR *)pwzStartAddress;
        while (chTest && (pwzStartAddress != pwzEndAddress))
        {
            pwzStartAddress++;
            chTest = *(volatile WCHAR *)pwzStartAddress;
        }
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
        return ISBAD;
    }
    __endexcept

    return ISGOOD;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HINSTANCE WINAPI LoadLibraryWrapW(LPCWSTR pwzLibFileName)
{
    VALIDATE_PROTOTYPE(LoadLibrary);

    if (g_bRunningOnNT)
        return LoadLibraryW(pwzLibFileName);

    CStrIn  strFileName(pwzLibFileName);
    return LoadLibraryA(strFileName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI GetTimeFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpTime, LPCWSTR pwzFormat, LPWSTR pwzTimeStr, int cchTime)
{
    VALIDATE_PROTOTYPE(GetTimeFormat);
    if (g_bRunningOnNT)
        return GetTimeFormatW(Locale, dwFlags, lpTime, pwzFormat, pwzTimeStr, cchTime);

    CStrIn strTextIn(pwzFormat);

    // Cross codepage text will be trashed if it is rendered in ANSI, 
    // Use system codepage for conversion to make sure we don't trash native ANSI text.
    CStrOut strTextOut(pwzTimeStr, cchTime);
    int nResult = GetTimeFormatA(Locale, dwFlags, lpTime, strTextIn, strTextOut, strTextOut.BufSize());
    if (cchTime != 0)
        nResult = strTextOut.ConvertIncludingNul();

    return nResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI GetDateFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpDate, LPCWSTR pwzFormat, LPWSTR pwzDateStr, int cchDate)
{
    VALIDATE_PROTOTYPE(GetDateFormat);
    if (g_bRunningOnNT)
        return GetDateFormatW(Locale, dwFlags, lpDate, pwzFormat, pwzDateStr, cchDate);

    CStrIn strTextIn(pwzFormat);
    CStrOut strTextOut(pwzDateStr, cchDate);
    int nResult = GetDateFormatA(Locale, dwFlags, lpDate, strTextIn, strTextOut, strTextOut.BufSize());
    if (cchDate != 0)
        nResult = strTextOut.ConvertIncludingNul();

    return nResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI WritePrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzString, LPCWSTR pwzFileName)
{
    VALIDATE_PROTOTYPE(WritePrivateProfileString);
    if (g_bRunningOnNT)
        return WritePrivateProfileStringW(pwzAppName, pwzKeyName, pwzString, pwzFileName);

    CStrIn strTextAppName(pwzAppName);
    CStrIn strTextKeyName(pwzKeyName);
    CStrIn strTextString(pwzString);
    CPPFIn strTextFileName(pwzFileName); // PrivateProfile filename needs special class

    return WritePrivateProfileStringA(strTextAppName, strTextKeyName, strTextString, strTextFileName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI GetPrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzDefault, LPWSTR pwzReturnedString, DWORD cchSize, LPCWSTR pwzFileName)
{
    VALIDATE_PROTOTYPE(GetPrivateProfileString);
    if (g_bRunningOnNT)
        return GetPrivateProfileStringW(pwzAppName, pwzKeyName, pwzDefault, pwzReturnedString, cchSize, pwzFileName);

    CStrIn strTextAppName(pwzAppName);
    CStrIn strTextKeyName(pwzKeyName);
    CStrIn strTextDefault(pwzDefault);
    CPPFIn strTextFileName(pwzFileName); // PrivateProfile filename needs special class

    CStrOut strTextOut(pwzReturnedString, cchSize);
    DWORD dwResult = GetPrivateProfileStringA(strTextAppName, strTextKeyName, strTextDefault, strTextOut, cchSize, strTextFileName);
    strTextOut.ConvertIncludingNul();

    return dwResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

STDAPI_(DWORD_PTR) SHGetFileInfoWrapW(LPCWSTR pwzPath, DWORD dwFileAttributes, SHFILEINFOW FAR  *psfi, UINT cbFileInfo, UINT uFlags)
{
    if (g_bRunningOnNT)
    {
        return SHGetFileInfoW(pwzPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
    }

    SHFILEINFOA shFileInfo;
    DWORD_PTR dwResult;

    shFileInfo.szDisplayName[0] = 0;        // Terminate so we can always thunk afterward.
    shFileInfo.szTypeName[0] = 0;           // Terminate so we can always thunk afterward.

    // Do we need to thunk the Path?
    if (SHGFI_PIDL & uFlags)
    {
        // No, because it's really a pidl pointer.
        dwResult = SHGetFileInfoA((LPCSTR)pwzPath, dwFileAttributes, &shFileInfo, sizeof(shFileInfo), uFlags);
    }
    else
    {
        // Yes
        CStrIn strPath(pwzPath);
        dwResult = SHGetFileInfoA(strPath, dwFileAttributes, &shFileInfo, sizeof(shFileInfo), uFlags);
    }

    psfi->hIcon = shFileInfo.hIcon;
    psfi->iIcon = shFileInfo.iIcon;
    psfi->dwAttributes = shFileInfo.dwAttributes;
    SHAnsiToUnicode(shFileInfo.szDisplayName, psfi->szDisplayName, ARRAYSIZE(shFileInfo.szDisplayName));
    SHAnsiToUnicode(shFileInfo.szTypeName, psfi->szTypeName, ARRAYSIZE(shFileInfo.szTypeName));

    return dwResult;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

STDAPI_(ATOM) RegisterClassExWrapW(CONST WNDCLASSEXW FAR * pwcx)
{
    VALIDATE_PROTOTYPE(RegisterClassEx);
    if (g_bRunningOnNT)
        return RegisterClassExW(pwcx);

    CStrIn strMenuName(pwcx->lpszMenuName);
    CStrIn strClassName(pwcx->lpszClassName);
    WNDCLASSEXA wcx = *(CONST WNDCLASSEXA FAR *) pwcx;
    wcx.cbSize = sizeof(wcx);
    wcx.lpszMenuName = strMenuName;
    wcx.lpszClassName = strClassName;

    return RegisterClassExA(&wcx);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

STDAPI_(BOOL) GetClassInfoExWrapW(HINSTANCE hinst, LPCWSTR pwzClass, LPWNDCLASSEXW lpwcx)
{
    VALIDATE_PROTOTYPE(GetClassInfoEx);
    if (g_bRunningOnNT)
        return GetClassInfoExW(hinst, pwzClass, lpwcx);

    BOOL fResult;
    CStrIn strClassName(pwzClass);
    WNDCLASSEXA wcx;
    wcx.cbSize = sizeof(wcx);

    fResult = GetClassInfoExA(hinst, strClassName, &wcx);
    *(WNDCLASSEXA FAR *) lpwcx = wcx;
    lpwcx->lpszMenuName = NULL;        // GetClassInfoExA makes this point off to private data that they own.
    lpwcx->lpszClassName = pwzClass;

    return fResult;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

//+---------------------------------------------------------------------------
//      StartDoc
//----------------------------------------------------------------------------

int
StartDocWrapW( HDC hDC, const DOCINFO * lpdi )
{
    VALIDATE_PROTOTYPE(StartDoc);

    if (g_bRunningOnNT)
    {
        return StartDocW( hDC, lpdi );
    }

    CStrIn  strDocName( lpdi->lpszDocName );
    CStrIn  strOutput( lpdi->lpszOutput );
    CStrIn  strDatatype( lpdi->lpszDatatype );
    DOCINFOA dia;

    dia.cbSize = sizeof(DOCINFO);
    dia.lpszDocName = strDocName;
    dia.lpszOutput = strOutput;
    dia.lpszDatatype = strDatatype;
    dia.fwType = lpdi->fwType;

    return StartDocA( hDC, &dia );
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

STDAPI_(HCOLORSPACE)
CreateColorSpaceWrapW(LOGCOLORSPACEW * lpLogColorSpaceW)
{
    VALIDATE_PROTOTYPE(CreateColorSpace);

    if (g_bRunningOnNT)
    {
        return CreateColorSpaceW(lpLogColorSpaceW);
    }

    HCOLORSPACE     hColorSpace;
    LOGCOLORSPACEA  logColorSpaceA;

    memcpy(&logColorSpaceA, lpLogColorSpaceW, 
           FIELD_OFFSET(LOGCOLORSPACEA, lcsFilename));

    SHUnicodeToAnsi(lpLogColorSpaceW->lcsFilename, 
                    logColorSpaceA.lcsFilename, 
                    ARRAYSIZE(logColorSpaceA.lcsFilename));

    hColorSpace = CreateColorSpaceA(&logColorSpaceA);

    return hColorSpace;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

STDAPI_(UINT) DragQueryFileWrapW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
{
    VALIDATE_OUTBUF(lpszFile, cch);

    //
    //  We are lazy and do not support lpszFile == NULL to query the length
    //  of an individual string.
    //
    ASSERT(iFile == 0xFFFFFFFF || lpszFile);

    if (g_bRunningOnNT)
    {
        return DragQueryFileW(hDrop, iFile, lpszFile, cch);
    }

    //
    //  If iFile is 0xFFFFFFFF, then lpszFile and cch are ignored.
    //
    if (iFile == 0xFFFFFFFF)
    {
        return DragQueryFileA(hDrop, iFile, NULL, 0);
    }

    CStrOut str(lpszFile, cch);

    DragQueryFileA(hDrop, iFile, str, str.BufSize());
    return str.ConvertExcludingNul();
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_VERSION_WRAPPER

//
//  the version APIs are not conducive to using
//  wrap versions of the APIs, but we are going to
//  do something reasonable....
//
#define VERSIONINFO_BUFF   (MAX_PATH * SIZEOF(WCHAR))

STDAPI_(DWORD)
GetFileVersionInfoSizeWrapW(LPWSTR pwzFilename,  LPDWORD lpdwHandle)
{
    if (g_bRunningOnNT)
    {
        return GetFileVersionInfoSizeW(pwzFilename, lpdwHandle);
    }
    else
    {
        char szFilename[MAX_PATH];
        DWORD dwRet;

        ASSERT(pwzFilename);
        SHUnicodeToAnsi(pwzFilename, szFilename, ARRAYSIZE(szFilename));
        dwRet = GetFileVersionInfoSizeA(szFilename, lpdwHandle);
        if (dwRet > 0)
        {
            // Add a scratch buffer to front for converting to UNICODE
            dwRet += VERSIONINFO_BUFF;
        }
        return dwRet;
    }
}

#endif // NEED_VERSION_WRAPPER

#ifdef NEED_VERSION_WRAPPER

STDAPI_(BOOL)
GetFileVersionInfoWrapW(LPWSTR pwzFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
    if (g_bRunningOnNT)
    {
        return GetFileVersionInfoW(pwzFilename, dwHandle, dwLen, lpData);
    }
    else
    {
        char szFilename[MAX_PATH];
        BYTE* pb;

        if (dwLen <= VERSIONINFO_BUFF)
        {
            return FALSE;
        }

        ASSERT(pwzFilename);
        SHUnicodeToAnsi(pwzFilename, szFilename, ARRAYSIZE(szFilename));
        //Skip over our scratch buffer at the beginning
        pb = (BYTE*)lpData + VERSIONINFO_BUFF;

        return GetFileVersionInfoA(szFilename, dwHandle, dwLen - VERSIONINFO_BUFF, (void*)pb);
    }
}

#endif // NEED_VERSION_WRAPPER

#ifdef NEED_VERSION_WRAPPER

STDAPI_(BOOL)
VerQueryValueWrapW(const LPVOID pBlock, LPWSTR pwzSubBlock, LPVOID *ppBuffer, PUINT puLen)
{
    if (g_bRunningOnNT)
    {
        return VerQueryValueW(pBlock, pwzSubBlock, ppBuffer, puLen);
    }
    else
    {
        const WCHAR pwzStringFileInfo[] = L"\\StringFileInfo";

        //
        // WARNING: This function wipes out any string previously returned
        // for this pBlock because a common buffer at the beginning of the
        // block is used for ansi/unicode translation!
        //
        char szSubBlock[MAX_PATH];
        BOOL fRet;
        BYTE* pb;

        ASSERT(pwzSubBlock);
        SHUnicodeToAnsi(pwzSubBlock, szSubBlock, ARRAYSIZE(szSubBlock));

        // The first chunk is our scratch buffer for converting to UNICODE
        pb = (BYTE*)pBlock + VERSIONINFO_BUFF;
        fRet = VerQueryValueA((void*)pb, szSubBlock, ppBuffer, puLen);

        // Convert to unicode if ansi string returned
        if (fRet && StrCmpNIW(pwzSubBlock, pwzStringFileInfo, ARRAYSIZE(pwzStringFileInfo) - 1) == 0)
        {
            // Convert returned string to UNICODE.  We use the scratch buffer
            // at the beginning of pBlock
            LPWSTR pwzBuff = (LPWSTR)pBlock;
            if (*puLen == 0)
            {
                pwzBuff[0] = L'\0';
            }
            else
            {
                SHAnsiToUnicode((LPCSTR)*ppBuffer, pwzBuff, VERSIONINFO_BUFF/sizeof(WCHAR));
            }
            *ppBuffer = pwzBuff;
        }
        return fRet;
    }
}

#endif // NEED_VERSION_WRAPPER


#ifdef NEED_SHELL32_WRAPPER

HRESULT WINAPI SHDefExtractIconWrapW(LPCWSTR pszFile, int nIconIndex,
                                     UINT uFlags, HICON *phiconLarge,
                                     HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr;

    if (UseUnicodeShell32())
    {
        hr = SHDefExtractIconW(pszFile, nIconIndex, uFlags, phiconLarge, phiconSmall, nIconSize);
    }
    else
    {
        CStrIn striFile(pszFile);

        hr = SHDefExtractIconA(striFile, nIconIndex, uFlags, phiconLarge, phiconSmall, nIconSize);
    }

    return hr;
}

#endif // NEED_SHELL32_WRAPPER


BOOL WINAPI SHGetNewLinkInfoWrapW(LPCWSTR pszpdlLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
{
    BOOL fRet;

    if (g_bRunningOnNT5OrHigher)
    {
        fRet =  SHGetNewLinkInfoW(pszpdlLinkTo, pszDir, pszName, pfMustCopy, uFlags);
    }
    else
    {
        CStrIn  striDir(pszDir);
        CStrOut stroName(pszName, MAX_PATH);

        if (SHGNLI_PIDL & uFlags)
        {
            fRet = SHGetNewLinkInfoA((LPCSTR)pszpdlLinkTo, striDir, stroName, pfMustCopy, uFlags);
        }
        else
        {
            CStrIn striLinkTo(pszpdlLinkTo);

            fRet = SHGetNewLinkInfoA(striLinkTo, striDir, stroName, pfMustCopy, uFlags);
        }

        if (fRet)
        {
            stroName.ConvertIncludingNul();
        }
    }
    
    return fRet;
}


#ifdef NEED_ADVAPI32_WRAPPER

LONG WINAPI RegEnumValueWrapW(HKEY hkey, DWORD dwIndex, LPWSTR lpValueName,
                              LPDWORD lpcbValueName, LPDWORD lpReserved,
                              LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    VALIDATE_PROTOTYPE(RegEnumValue);

    LONG lRet;

    if (UseUnicodeShell32())
    {
        lRet = RegEnumValueW(hkey, dwIndex, lpValueName, lpcbValueName,
                             lpReserved, lpType, lpData, lpcbData);
    }
    else
    {
        CStrOut stroValueName(lpValueName, *lpcbValueName);
        DWORD   dwTypeTemp;

        if (lpData)
        {
            ASSERT(lpcbData);

            CStrOut stroData((LPWSTR)lpData, (*lpcbData) / sizeof(WCHAR));

            lRet = RegEnumValueA(hkey, dwIndex, stroValueName, lpcbValueName,
                                 lpReserved, &dwTypeTemp,
                                 (LPBYTE)(LPSTR)stroData, lpcbData);

            if (ERROR_SUCCESS == lRet && REG_SZ == dwTypeTemp)
            {
                *lpcbData = sizeof(WCHAR) * stroData.ConvertIncludingNul();
            }
        }
        else
        {
            lRet = RegEnumValueA(hkey, dwIndex, stroValueName, lpcbValueName,
                                 lpReserved, &dwTypeTemp, lpData, lpcbData);
        }

        if (ERROR_SUCCESS == lRet)
            *lpcbValueName = stroValueName.ConvertExcludingNul();

        if (lpType)
            *lpType = dwTypeTemp;
    }

    return lRet;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI WritePrivateProfileStructWrapW(LPCWSTR lpszSection, LPCWSTR lpszKey,
                                           LPVOID lpStruct, UINT uSizeStruct,
                                           LPCWSTR szFile)
{
    VALIDATE_PROTOTYPE(WritePrivateProfileStruct);

    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = WritePrivateProfileStructW(lpszSection, lpszKey, lpStruct,
                                          uSizeStruct, szFile);
    }
    else
    {
        CStrIn striSection(lpszSection);
        CStrIn striKey(lpszKey);
        CPPFIn striFile(szFile); // PrivateProfile filename needs special class

        fRet = WritePrivateProfileStructA(striSection, striKey, lpStruct,
                                          uSizeStruct, striFile);
    }

    return fRet;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI GetPrivateProfileStructWrapW(LPCWSTR lpszSection, LPCWSTR lpszKey,
                                         LPVOID lpStruct, UINT uSizeStruct,
                                         LPCWSTR szFile)
{
    VALIDATE_PROTOTYPE(GetPrivateProfileStruct);

    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = GetPrivateProfileStructW(lpszSection, lpszKey, lpStruct,
                                        uSizeStruct, szFile);
    }
    else
    {
        CStrIn striSection(lpszSection);
        CStrIn striKey(lpszKey);
        CPPFIn striFile(szFile); // PrivateProfile filename needs special class

        fRet = GetPrivateProfileStructA(striSection, striKey, lpStruct,
                                        uSizeStruct, striFile);
    }

    return fRet;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI CreateProcessWrapW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine,
                               LPSECURITY_ATTRIBUTES lpProcessAttributes,
                               LPSECURITY_ATTRIBUTES lpThreadAttributes,
                               BOOL bInheritHandles,
                               DWORD dwCreationFlags,
                               LPVOID lpEnvironment,
                               LPCWSTR lpCurrentDirectory,
                               LPSTARTUPINFOW lpStartupInfo,
                               LPPROCESS_INFORMATION lpProcessInformation)
{
    BOOL fRet;
    VALIDATE_PROTOTYPE(CreateProcess);

    if (UseUnicodeShell32())
    {
        fRet = CreateProcessW(lpApplicationName, lpCommandLine,
                              lpProcessAttributes, lpThreadAttributes,
                              bInheritHandles, dwCreationFlags, lpEnvironment,
                              lpCurrentDirectory, lpStartupInfo,
                              lpProcessInformation);
    }
    else
    {
        CStrIn striApplicationName(lpApplicationName);
        CStrIn striCommandLine(lpCommandLine);
        CStrIn striCurrentDirectory(lpCurrentDirectory);

        if (NULL == lpStartupInfo)
        {
            fRet = CreateProcessA(striApplicationName, striCommandLine,
                                  lpProcessAttributes, lpThreadAttributes,
                                  bInheritHandles, dwCreationFlags,
                                  lpEnvironment, striCurrentDirectory,
                                  NULL, lpProcessInformation);
        }
        else
        {
            STARTUPINFOA si = *(STARTUPINFOA*)lpStartupInfo;

            CStrIn striReserved(lpStartupInfo->lpReserved);
            CStrIn striDesktop(lpStartupInfo->lpDesktop);
            CStrIn striTitle(lpStartupInfo->lpTitle);

            si.lpReserved = striReserved;
            si.lpDesktop  = striDesktop;
            si.lpTitle   = striTitle;

            fRet = CreateProcessA(striApplicationName, striCommandLine,
                                  lpProcessAttributes, lpThreadAttributes,
                                  bInheritHandles, dwCreationFlags,
                                  lpEnvironment, striCurrentDirectory,
                                  &si, lpProcessInformation);
        }

    }

    return fRet;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

HICON WINAPI ExtractIconWrapW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
    HICON hicon;

    if (UseUnicodeShell32())
    {
        hicon = ExtractIconW(hInst, lpszExeFileName, nIconIndex);
    }
    else
    {
        CStrIn striExeFileName(lpszExeFileName);

        hicon = ExtractIconA(hInst, striExeFileName, nIconIndex);
    }

    return hicon;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

UINT WINAPI DdeInitializeWrapW(LPDWORD pidInst, PFNCALLBACK pfnCallback,
                               DWORD afCmd, DWORD ulRes)
{
    UINT uRet;

    if (UseUnicodeShell32())
    {
        uRet = DdeInitializeW(pidInst, pfnCallback, afCmd, ulRes);
    }
    else
    {
        //
        // This assumes the callback function will used the wrapped dde
        // string functions (DdeCreateStringHandle and DdeQueryString)
        // to access strings.
        //

        uRet = DdeInitializeA(pidInst, pfnCallback, afCmd, ulRes);
    }

    return uRet;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HSZ WINAPI DdeCreateStringHandleWrapW(DWORD idInst, LPCWSTR psz, int iCodePage)
{
    HSZ hszRet;

    if (UseUnicodeShell32())
    {
        hszRet = DdeCreateStringHandleW(idInst, psz, iCodePage);
    }
    else
    {
        CStrIn stripsz(psz);

        hszRet = DdeCreateStringHandleA(idInst, stripsz, CP_WINANSI);
    }

    return hszRet;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

DWORD WINAPI DdeQueryStringWrapW(DWORD idInst, HSZ hsz, LPWSTR psz,
                                 DWORD cchMax, int iCodePage)
{
    DWORD dwRet;

    if (UseUnicodeShell32())
    {
        dwRet = DdeQueryStringW(idInst, hsz, psz, cchMax, iCodePage);
    }
    else
    {
        CStrOut stropsz(psz, cchMax);

        dwRet = DdeQueryStringA(idInst, hsz, stropsz, stropsz.BufSize(),
                                CP_WINANSI);

        if (dwRet && psz)
            dwRet = stropsz.ConvertExcludingNul();        
    }

    return dwRet;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

ATOM WINAPI
GlobalAddAtomWrapW(LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(GlobalAddAtom);

    if (g_bRunningOnNT)
    {
        return GlobalAddAtomW(lpString);
    }

    CStrIn  str(lpString);

    return GlobalAddAtomA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

ATOM WINAPI
GlobalFindAtomWrapW(LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(GlobalFindAtom);

    if (g_bRunningOnNT)
    {
        return GlobalFindAtomW(lpString);
    }

    CStrIn  str(lpString);

    return GlobalFindAtomA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

BOOL WINAPI GetSaveFileNameWrapW(LPOPENFILENAMEW lpofn)
{
    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = GetSaveFileNameW(lpofn);
    }
    else
    {
        ASSERT(lpofn);
        ASSERT(sizeof(OPENFILENAMEA) == sizeof(OPENFILENAMEW));

        OPENFILENAMEA ofnA = *(LPOPENFILENAMEA)lpofn;

        // In parameters
        CStrInMulti strimFilter(lpofn->lpstrFilter);
        CStrIn      striInitialDir(lpofn->lpstrInitialDir);
        CStrIn      striTitle(lpofn->lpstrTitle);
        CStrIn      striDefExt(lpofn->lpstrDefExt);
        CStrIn      striTemplateName(lpofn->lpTemplateName);

        ASSERT(NULL == lpofn->lpstrCustomFilter); // add support if you need it.

        // Out parameters
        CStrOut     stroFile(lpofn->lpstrFile, lpofn->nMaxFile);
        CStrOut     stroFileTitle(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle);

        //In Out parameters
        SHUnicodeToAnsi(lpofn->lpstrFile, stroFile, stroFile.BufSize());

        // Set up the parameters
        ofnA.lpstrFilter        = strimFilter;
        ofnA.lpstrInitialDir    = striInitialDir;
        ofnA.lpstrTitle         = striTitle;
        ofnA.lpstrDefExt        = striDefExt;
        ofnA.lpTemplateName     = striTemplateName;
        ofnA.lpstrFile          = stroFile;
        ofnA.lpstrFileTitle     = stroFileTitle;

        fRet = GetSaveFileNameA(&ofnA);

        if (fRet)
        {
            // Copy the out parameters
            lpofn->nFilterIndex = ofnA.nFilterIndex;
            lpofn->Flags        = ofnA.Flags;

            // Get the offset to the filename
            stroFile.ConvertIncludingNul();
            LPWSTR psz = PathFindFileNameW(lpofn->lpstrFile);

            if (psz)
            {
                lpofn->nFileOffset = (int) (psz-lpofn->lpstrFile);

                // Get the offset of the extension
                psz = PathFindExtensionW(psz);

                lpofn->nFileExtension = psz ? (int)(psz-lpofn->lpstrFile) : 0; 
            }
            else
            {
                lpofn->nFileOffset    = 0;
                lpofn->nFileExtension = 0;
            }

        }
    }

    return fRet;
}

#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

BOOL WINAPI GetOpenFileNameWrapW(LPOPENFILENAMEW lpofn)
{
    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = GetOpenFileNameW(lpofn);
    }
    else
    {
        ASSERT(lpofn);
        ASSERT(sizeof(OPENFILENAMEA) == sizeof(OPENFILENAMEW));

        OPENFILENAMEA ofnA = *(LPOPENFILENAMEA)lpofn;

        // In parameters
        CStrInMulti strimFilter(lpofn->lpstrFilter);
        CStrIn      striInitialDir(lpofn->lpstrInitialDir);
        CStrIn      striTitle(lpofn->lpstrTitle);
        CStrIn      striDefExt(lpofn->lpstrDefExt);
        CStrIn      striTemplateName(lpofn->lpTemplateName);

        ASSERT(NULL == lpofn->lpstrCustomFilter); // add support if you need it.

        // Out parameters
        CStrOut     stroFile(lpofn->lpstrFile, lpofn->nMaxFile);
        CStrOut     stroFileTitle(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle);

        //In Out parameters
        SHUnicodeToAnsi(lpofn->lpstrFile, stroFile, stroFile.BufSize());

        // Set up the parameters
        ofnA.lpstrFilter        = strimFilter;
        ofnA.lpstrInitialDir    = striInitialDir;
        ofnA.lpstrTitle         = striTitle;
        ofnA.lpstrDefExt        = striDefExt;
        ofnA.lpTemplateName     = striTemplateName;
        ofnA.lpstrFile          = stroFile;
        ofnA.lpstrFileTitle     = stroFileTitle;

        fRet = GetOpenFileNameA(&ofnA);

        if (fRet)
        {
            // Copy the out parameters
            lpofn->nFilterIndex = ofnA.nFilterIndex;
            lpofn->Flags        = ofnA.Flags;

            // Get the offset to the filename
            stroFile.ConvertIncludingNul();
            LPWSTR psz = PathFindFileNameW(lpofn->lpstrFile);

            if (psz)
            {
                lpofn->nFileOffset = (int) (psz-lpofn->lpstrFile);

                // Get the offset of the extension
                psz = PathFindExtensionW(psz);

                lpofn->nFileExtension = psz ? (int)(psz-lpofn->lpstrFile) : 0; 
            }
            else
            {
                lpofn->nFileOffset    = 0;
                lpofn->nFileExtension = 0;
            }

        }
    }

    return fRet;
}

#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

#define SHCNF_HAS_WSTR_PARAMS(f)   ((f & SHCNF_TYPE) == SHCNF_PATHW     ||    \
                                    (f & SHCNF_TYPE) == SHCNF_PRINTERW  ||    \
                                    (f & SHCNF_TYPE) == SHCNF_PRINTJOBW    )

void SHChangeNotifyWrap(LONG wEventId, UINT uFlags, LPCVOID dwItem1,
                        LPCVOID dwItem2)
{
    if (UseUnicodeShell32() || !SHCNF_HAS_WSTR_PARAMS(uFlags))
    {
        SHChangeNotify(wEventId, uFlags, dwItem1, dwItem2);
    }
    else
    {
        CStrIn striItem1((LPWSTR)dwItem1);
        CStrIn striItem2((LPWSTR)dwItem2);
        
        if ((uFlags & SHCNF_TYPE) == SHCNF_PATHW)
        {
            uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PATHA;
        }
        else if ((uFlags & SHCNF_TYPE) == SHCNF_PRINTERW)
        {
            uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PRINTERA;
        }
        else
        {
            uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PRINTJOBA;
        }

        SHChangeNotify(wEventId, uFlags, (void*)(LPSTR)striItem1, (void*)(LPSTR)striItem2);
    }

    return;
}

LWSTDAPI_(void) SHFlushSFCacheWrap(void)
{
    // if shell32 is not in process, then there's nothing to flush
    HMODULE hShell32 = GetModuleHandleWrap(TEXT("SHELL32"));
    if (hShell32) 
    {
        // NOTE: GetProcAddress always takes ANSI strings!
        DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hShell32, "DllGetVersion");

        if (pfnGetVersion)
        {
            DLLVERSIONINFO dllinfo;

            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if (pfnGetVersion(&dllinfo) == NOERROR)
            {
                // first, we need a version of shell32 that supports the function
                if (dllinfo.dwMajorVersion >= 4)
                {
                    if (dllinfo.dwMajorVersion == 4)
                    {
                        // to work around the "missing critical section" bug in v4 shell32.dll,
                        // we simply bail the call.
                        return;
                    }

                    SHFlushSFCache();
                }
            }
        }
    }
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

//+---------------------------------------------------------------------------
// PrintDlgWrap, PageSetupDlgWrap - wrappers
// DevNamesAFromDevNamesW, DevNamesWFromDevNamesA - helper functions
//
//        Copied from mshtml\src\core\wrappers\unicwrap.cpp with some
//        cosmetic changes (peterlee)
//        
//+---------------------------------------------------------------------------

HGLOBAL
DevNamesAFromDevNamesW( HGLOBAL hdnw )
{
    HGLOBAL         hdna = NULL;

    if (hdnw)
    {
        LPDEVNAMES lpdnw = (LPDEVNAMES) GlobalLock( hdnw );
        if (lpdnw)
        {
            CStrIn      strDriver( (LPCWSTR) lpdnw + lpdnw->wDriverOffset );
            CStrIn      strDevice( (LPCWSTR) lpdnw + lpdnw->wDeviceOffset );
            CStrIn      strOutput( (LPCWSTR) lpdnw + lpdnw->wOutputOffset );
            int         cchDriver = strDriver.strlen() + 1;
            int         cchDevice = strDevice.strlen() + 1;
            int         cchOutput = strOutput.strlen() + 1;

            hdna = GlobalAlloc( GHND, sizeof(DEVNAMES) +
                                cchDriver + cchDevice + cchOutput );
            if (hdna)
            {
                LPDEVNAMES lpdna = (LPDEVNAMES) GlobalLock( hdna );
                if (!lpdna)
                {
                    GlobalFree( hdna );
                    hdna = NULL;
                }
                else
                {
                    lpdna->wDriverOffset = sizeof(DEVNAMES);
                    lpdna->wDeviceOffset = lpdna->wDriverOffset + cchDriver;
                    lpdna->wOutputOffset = lpdna->wDeviceOffset + cchDevice;
                    lpdna->wDefault = lpdnw->wDefault;

                    lstrcpyA( (LPSTR) lpdna + lpdna->wDriverOffset, strDriver );
                    lstrcpyA( (LPSTR) lpdna + lpdna->wDeviceOffset, strDevice );
                    lstrcpyA( (LPSTR) lpdna + lpdna->wOutputOffset, strOutput );

                    GlobalUnlock( hdna );
                }
            }

            GlobalUnlock( hdnw );
            GlobalFree( hdnw );
        }
    }

   return hdna;
}

HGLOBAL
DevNamesWFromDevNamesA( HGLOBAL hdna )
{
    HGLOBAL         hdnw = NULL;

    if (hdna)
    {
        LPDEVNAMES lpdna = (LPDEVNAMES) GlobalLock( hdna );
        if (lpdna)
        {
            LPCSTR      lpszDriver = (LPCSTR) lpdna + lpdna->wDriverOffset;
            LPCSTR      lpszDevice = (LPCSTR) lpdna + lpdna->wDeviceOffset;
            LPCSTR      lpszOutput = (LPCSTR) lpdna + lpdna->wOutputOffset;
            int         cchDriver = lstrlenA( lpszDriver ) + 1;
            int         cchDevice = lstrlenA( lpszDevice ) + 1;
            int         cchOutput = lstrlenA( lpszOutput ) + 1;

            // assume the wide charcount won't exceed the multibyte charcount

            hdnw = GlobalAlloc( GHND, sizeof(DEVNAMES) +
                                sizeof(WCHAR) * (cchDriver + cchDevice + cchOutput)  );
            if (hdnw)
            {
                LPDEVNAMES lpdnw = (LPDEVNAMES) GlobalLock( hdnw );
                if (!lpdnw)
                {
                    GlobalFree( hdnw );
                    hdnw = NULL;
                }
                else
                {
                    lpdnw->wDriverOffset = sizeof(DEVNAMES) / sizeof(WCHAR);
                    lpdnw->wDeviceOffset = lpdnw->wDriverOffset + cchDriver;
                    lpdnw->wOutputOffset = lpdnw->wDeviceOffset + cchDevice;
                    lpdnw->wDefault = lpdna->wDefault;

                    SHAnsiToUnicode( (LPSTR) lpszDriver, (LPWSTR) lpdnw + lpdnw->wDriverOffset,
                                     cchDriver );
                    SHAnsiToUnicode( lpszDevice, (LPWSTR) lpdnw + lpdnw->wDeviceOffset,
                                     cchDevice);
                    SHAnsiToUnicode( lpszOutput, (LPWSTR) lpdnw + lpdnw->wOutputOffset,
                                     cchOutput);

                    GlobalUnlock( hdnw );
                }
            }

            GlobalUnlock( hdna );
            GlobalFree( hdna );
        }
    }

   return hdnw;
}

#ifdef UNIX
HGLOBAL
DevModeAFromDevModeW( HGLOBAL hdmw )
{
    HGLOBAL         hdma = NULL;

    if (hdmw)
    {
        LPDEVMODEW lpdmw = (LPDEVMODEW)GlobalLock( hdmw );
    if (lpdmw)
    {
        hdma = GlobalAlloc( GHND, sizeof(DEVMODEA) );
        if (hdma)
        {
            LPDEVMODEA lpdma = (LPDEVMODEA) GlobalLock( hdma );
        if (lpdma)
        {
            CStrIn          strDeviceName( lpdmw->dmDeviceName );
            CStrIn          strFormName( lpdmw->dmFormName );

            // assume memory layout is identical

            memcpy( lpdma->dmDeviceName, strDeviceName, CCHDEVICENAME );

            memcpy( &lpdma->dmSpecVersion,
                &lpdmw->dmSpecVersion,
                offsetof(DEVMODEW, dmFormName) -
                offsetof(DEVMODEW, dmSpecVersion) );

            memcpy( lpdma->dmFormName, strFormName, CCHFORMNAME );

            memcpy( &lpdma->dmLogPixels,
                &lpdmw->dmLogPixels,
                sizeof(DEVMODEW) -
                offsetof(DEVMODEW, dmLogPixels) );

            GlobalUnlock( hdma );
        }
        else
        {
            GlobalFree( hdma );
            hdma = NULL;
        }
        }

        GlobalUnlock( hdmw );
        GlobalFree( hdmw );
    }
    }

    return hdma;
}

//--------------------------------------------------------------
//      DEVMODEW from DEVMODEA
//--------------------------------------------------------------
HGLOBAL
DevModeWFromDevModeA( HGLOBAL hdma )
{
    HGLOBAL         hdmw = NULL;

    if (hdma)
    {
        LPDEVMODEA lpdma = (LPDEVMODEA)GlobalLock( hdma );
    if (lpdma)
    {
        hdmw = GlobalAlloc( GHND, sizeof(DEVMODEW) );
        if (hdmw)
        {
            LPDEVMODEW lpdmw = (LPDEVMODEW) GlobalLock( hdmw );
        if (lpdmw)
        {
            CStrOut     strDeviceName( lpdmw->dmDeviceName, CCHDEVICENAME );
            CStrOut     strFormName( lpdmw->dmFormName, CCHFORMNAME );

            // assume memory layout is identical

            lstrcpyA( strDeviceName, (LPCSTR)lpdma->dmDeviceName );
            strDeviceName.ConvertIncludingNul();

            memcpy( &lpdmw->dmSpecVersion,
                &lpdma->dmSpecVersion,
                offsetof(DEVMODEA, dmFormName) -
                offsetof(DEVMODEA, dmSpecVersion) );

            lstrcpyA( strFormName, (LPCSTR)lpdmw->dmFormName );
            strFormName.ConvertIncludingNul();

            memcpy( &lpdmw->dmLogPixels,
                &lpdma->dmLogPixels,
                sizeof(DEVMODEA) -
                offsetof(DEVMODEA, dmLogPixels) );

            GlobalUnlock( hdmw );
        }
        else
        {
            GlobalFree( hdmw );
            hdmw = NULL;
        }
        }

        GlobalUnlock( hdma );
        GlobalFree( hdma );
    }
    }

    return hdmw;
}
#endif //UNIX
#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

//--------------------------------------------------------------
//      PrintDlgW wrapper
//--------------------------------------------------------------

BOOL WINAPI
PrintDlgWrapW(LPPRINTDLGW lppd)
{
    BOOL        fRet;
    
    if (UseUnicodeShell32())
    {
         fRet = PrintDlgW(lppd);
    }
    else
    {    
        PRINTDLGA   pda;
        LPCWSTR     lpPrintTemplateName = lppd->lpPrintTemplateName;
        LPCWSTR     lpSetupTemplateName = lppd->lpSetupTemplateName;
        CStrIn      strPrintTemplateName( lpPrintTemplateName );
        CStrIn      strSetupTemplateName( lpSetupTemplateName );

        ASSERT( sizeof(pda) == sizeof( *lppd ));

        memcpy( &pda, lppd, sizeof(pda) );

        // IMPORTANT: We are not converting the DEVMODE structure back and forth
        // from ASCII to Unicode on Win95 anymore because we are not touching the
        // two strings or any other member.  Converting the DEVMODE structure can
        // be tricky because of potential and common discrepancies between the
        // value of the dmSize member and sizeof(DEVMODE).  (25155)
    
        // So instead of: pda.hDevMode = DevModeAFromDevModeW( lppd->hDevMode );
        // we just forward the DEVMODE handle:
        pda.hDevMode = lppd->hDevMode;
        pda.hDevNames = DevNamesAFromDevNamesW( lppd->hDevNames );
        pda.lpPrintTemplateName = strPrintTemplateName;
        pda.lpSetupTemplateName = strSetupTemplateName;
    
        fRet = PrintDlgA( &pda );
    
        // copy back wholesale, then restore strings.
    
        memcpy( lppd, &pda, sizeof(pda) );
    
        lppd->lpSetupTemplateName = lpSetupTemplateName;
        lppd->lpPrintTemplateName = lpPrintTemplateName;
        lppd->hDevNames = DevNamesWFromDevNamesA( pda.hDevNames );
    
        // And instead of: lppd->hDevMode = DevModeWFromDevModeA( pda.hDevMode );
        // we just forward the DEVMODE handle:
        lppd->hDevMode = pda.hDevMode;
    }

    return fRet;
}

#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

//--------------------------------------------------------------
//      PageSetupDlgW wrapper
//--------------------------------------------------------------

BOOL WINAPI
PageSetupDlgWrapW(LPPAGESETUPDLGW lppsd)
{
    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = PageSetupDlgW(lppsd);
    }
    else
    {   
        PAGESETUPDLGA   psda;
        LPCWSTR         lpPageSetupTemplateName = lppsd->lpPageSetupTemplateName;
        CStrIn          strPageSetupTemplateName( lpPageSetupTemplateName );
    
        ASSERT( sizeof(psda) == sizeof( *lppsd ) );
    
        memcpy( &psda, lppsd, sizeof(psda));
    
        // IMPORTANT: We are not converting the DEVMODE structure back and forth
        // from ASCII to Unicode on Win95 anymore because we are not touching the
        // two strings or any other member.  Converting the DEVMODE structure can
        // be tricky because of potential and common discrepancies between the
        // value of the dmSize member and sizeof(DEVMODE).  (25155)
    
        // So instead of: psda.hDevMode = DevModeAFromDevModeW( lppsd->hDevMode );
        // we just forward the DEVMODE handle:
        psda.hDevMode = lppsd->hDevMode;
        psda.hDevNames = DevNamesAFromDevNamesW( lppsd->hDevNames );
        psda.lpPageSetupTemplateName = strPageSetupTemplateName;
    
        fRet = PageSetupDlgA((LPPAGESETUPDLGA)&psda);
    
        // copy back wholesale, then restore string.
    
        memcpy( lppsd, &psda, sizeof(psda) );
    
        lppsd->lpPageSetupTemplateName = lpPageSetupTemplateName;
        lppsd->hDevNames = DevNamesWFromDevNamesA( psda.hDevNames );
    
        // And instead of: lppsd->hDevMode = DevModeWFromDevModeA( psda.hDevMode );
        // we just forward the DEVMODE handle:
        lppsd->hDevMode = psda.hDevMode;            
    }

    return fRet;
}

#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_OLE32_WRAPPER

//  CLSIDFromXXX puke when input is >= 248
#define SAFE_OLE_BUF_LEN    247

HRESULT WINAPI CLSIDFromStringWrap(LPOLESTR lpsz, LPCLSID pclsid)
{
    return GUIDFromStringW(lpsz, pclsid) ? S_OK : E_INVALIDARG;
}

HRESULT WINAPI CLSIDFromProgIDWrap(LPCOLESTR lpszProgID, LPCLSID lpclsid)
{
    HRESULT hr;
    
    if (lstrlenW(lpszProgID) < SAFE_OLE_BUF_LEN)
    {
        hr = CLSIDFromProgID(lpszProgID, lpclsid);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

#endif // NEED_OLE32_WRAPPER

//************************************************************************
// function GETLONGPATHNAME :
//
// These wrappers are needed on all platforms (x86 and Alpha) because they
// implement the functionality for the Kernel32 function GetLongPathName that 
// exists only on Win2K (Unicode/Ansi) and Win98 (Ansi only). Hence these
// wrappers provide this functionality for lower level platforms (NT4 & Win95)
//

#define achGETLONGPATHNAMEA     "GetLongPathNameA"
typedef DWORD (*PROC_GETLONGPATHNAMEA) (LPCSTR, LPSTR, DWORD);

LWSTDAPI_(DWORD)
GetLongPathNameWrapA(
        LPCSTR lpszShortPath,
        LPSTR lpszLongPath, 
        DWORD cchBuffer)
{
    VALIDATE_PROTOTYPE(GetLongPathName);

    // If NT5 or Win98, use the system API for ANSI
    if (g_bRunningOnNT5OrHigher || g_bRunningOnMemphis)
    {
        static PROC_GETLONGPATHNAMEA s_fpGLPNA = NULL;

        if (!s_fpGLPNA)
        {
            // This codepath is used for Memphis also, hence need to use the
            // wrapper for GetModuleHandle.
            s_fpGLPNA = (PROC_GETLONGPATHNAMEA)GetProcAddress(GetModuleHandleWrap(L"kernel32"),achGETLONGPATHNAMEA);
        }

        ASSERT(s_fpGLPNA);
        
        if (s_fpGLPNA)
        {
            return s_fpGLPNA(lpszShortPath, lpszLongPath, cchBuffer);
        }
    }

    // Otherwise use our own logic to do the conversion....
    BOOL    bCountMode = FALSE;
    CHAR    cTmp;
    HANDLE  hFind;
    LPSTR   pTmp = NULL;
    DWORD   dwReturnLen = 0;    
    WIN32_FIND_DATAA Find_Data;  
    UINT    PrevErrorMode;

    // Since we are going to be touchin the media, turn off file error
    // pop-ups. Remember the current mode and set it back in the end.
    PrevErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    if (lpszLongPath == NULL)
    {    // No OUT buffer provided ==> counting mode.
        bCountMode = TRUE;
    }
    else
    {    // Initialize OUT buffer.
        *lpszLongPath = '\0';
    }

    // Validate the input parameters...
    if ((lpszShortPath == NULL) 
        || (0xFFFFFFFF == GetFileAttributesA(lpszShortPath)) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        dwReturnLen = 0;
        goto Done;
    }         
                                                                    
    if (PathIsUNCA(lpszShortPath))
    {
        // This is a UNC Path, don't know how to handle
        SetLastError(ERROR_INVALID_PARAMETER);
        dwReturnLen = 0;
        goto Done;
    }

    // Input must be a full path.
    // Since Drive letter cannot be multi-byte, just check 2nd and 3rd chars.
    if ( lpszShortPath[1] != ':' || 
         lpszShortPath[2] != '\\')
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        dwReturnLen = 0;
        goto Done;
    }

    // Create the drive root for the LFN.
    if ( !bCountMode && cchBuffer >= 3)
    {   // Copy the drive letter.
        StrCpyNA(lpszLongPath, lpszShortPath, 3);
    }
    else
    {   // Supplied buffer is so small, can't even copy the drive letter!!
        bCountMode = TRUE;
    }
    dwReturnLen += 2;


    // Create a local copy of the input Short name to party on.
    // Also, as per the documentation, OUT buffer can be the same as the IN.
    // Hence need to save the IN buffer before we start filling the OUT.
    CHAR lpLocalCopy[MAX_PATH];
    StrCpyNA(lpLocalCopy, lpszShortPath, MAX_PATH);

    // Now starts the main processing....
    // Skip past the root backslash in lpszShortPath.
    pTmp = lpLocalCopy+3;
 
    while (*pTmp)
    {
        // Get the next Backslash
        pTmp = StrChrA(pTmp, L'\\');
        if ( pTmp == NULL)
        {
            // Fell off the end of the str. So point pTmp to the terminating \0
            pTmp = lpLocalCopy + lstrlenA(lpLocalCopy);
        }

        cTmp = *pTmp;
        *pTmp = '\0';

        hFind = FindFirstFileA(lpLocalCopy, &Find_Data);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

            dwReturnLen += lstrlenA(Find_Data.cFileName);
            dwReturnLen += 1;  // Plus for the '\' introduced by PathCombine.
            if (!bCountMode && dwReturnLen < cchBuffer)
            {   // Add the LFN to the path
                PathCombineA(lpszLongPath, lpszLongPath, Find_Data.cFileName);
            }
            else
            {   // We are out of buffer space. Continue loop to find space reqd.
                bCountMode = TRUE;
                *lpszLongPath = '\0';
            }
        }
        else
        {
            //Error: Input path does not exist. The earlier check should catch
            //this
            SetLastError(ERROR_INVALID_PARAMETER);
            if (!bCountMode)
                *lpszLongPath = '\0';
            *pTmp = cTmp;
            dwReturnLen = 0;
            goto Done;
        }

        *pTmp = cTmp;
      
        if (*pTmp)
            pTmp = CharNextA(pTmp);
    }

Done:
    // restore error mode.
    SetErrorMode(PrevErrorMode);

    if ( dwReturnLen && bCountMode)
    {   // If everything OK (dwReturnLen!=0) and Counting Mode, add one.
        return (dwReturnLen+1);  
    }
    else
    {   // Return error (dwReturnLen==0) Or 
        // No. of chars (dwReturnLen != 0 && bCountMode == FALSE)
        return (dwReturnLen);   
    }
}

#define achGETLONGPATHNAMEW     "GetLongPathNameW"
typedef DWORD (*PROC_GETLONGPATHNAMEW) (LPCWSTR, LPWSTR, DWORD);

LWSTDAPI_(DWORD)
GetLongPathNameWrapW(
        LPCWSTR lpszShortPath,
        LPWSTR lpszLongPath,
        DWORD cchBuffer)
{
    VALIDATE_PROTOTYPE(GetLongPathName);

    // If we are running on NT5, use the system API for Unicode
    if (g_bRunningOnNT5OrHigher)
    {
        static PROC_GETLONGPATHNAMEW s_fpGLPNW = NULL;

        if (!s_fpGLPNW)
        {
            s_fpGLPNW = (PROC_GETLONGPATHNAMEW)GetProcAddress(GetModuleHandle(TEXT("kernel32")),achGETLONGPATHNAMEW);
        }

        ASSERT(s_fpGLPNW);
        
        if (s_fpGLPNW)
        {
            return s_fpGLPNW(lpszShortPath, lpszLongPath, cchBuffer);
        }
    }

    // All other platforms, convert UNICODE inputs to ANSI and use the
    // ANSI wrapper.
    CStrIn  strShortPath(lpszShortPath);
    CStrOut strLongPath(lpszLongPath, cchBuffer);

    // DWORD dwRet = GetLongPathNameWrapA(strShortPath, strLongPath, strLongPath.BufSize());
    DWORD dwRet = GetLongPathNameWrapA(strShortPath, strLongPath, cchBuffer);
    if (dwRet != 0)
    {   // If the call succeeded, thunk back the size.
        if (dwRet < (DWORD)cchBuffer)
        {   // Succeeded in getting LFN value in the OUT buffer. Thunk it back
            // to Unicode.
            dwRet = strLongPath.ConvertIncludingNul() - 1;
        }
        // else ==> buffer small, need dwRet character space.
    }

    return dwRet;
}

// End of GETLONGPATHNAME wrapper implementation.
// NOTE: This wrapper is to be built on all platforms.
//************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\srca\makefile.inc ===
$(O)\patha.c: ..\path.c
    echo #undef UNICODE > $@
    echo #undef _UNICODE >> $@
    type $** >> $@

$(O)\nativea.cpp: ..\native.cpp
    echo #undef UNICODE > $@
    echo #undef _UNICODE >> $@
    type $** >> $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\srcw\makefile.inc ===
$(O)\pathw.c: ..\path.c
    echo // This file expects to be compiled UNICODE > $@
    type $** >> $@

$(O)\nativew.cpp: ..\native.cpp
    echo // This file expects to be compiled UNICODE > $@
    type $** >> $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\resdll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\wsprintf.c ===
#include "priv.h"

#define DBCS_CHARSIZE   (2)

//  N versions of wsprintf and wvsprintf which take an output buffer size to prevent overflow
//  bugs.  Taken from the NT wsprintf source code.

//  _MBToWCS and _WCSToMB are actually macros which call ntrtl functions in the NT version.
int _MBToWCS(LPSTR pszIn, int cchIn, LPWSTR *ppwszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppwszOut))
    {
        cchIn++;
        cbAlloc = cchIn * sizeof(WCHAR);

        *ppwszOut = (LPWSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppwszOut)
        {
            cch = MultiByteToWideChar(CP_ACP, 0, pszIn, cchIn, *ppwszOut, cchIn);

            if (!cch)
            {
                LocalFree(*ppwszOut);
                *ppwszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

int _WCSToMB(LPCWSTR pwszIn, int cchIn, LPSTR *ppszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppszOut))
    {
        cchIn++;
        cbAlloc = cchIn * DBCS_CHARSIZE;

        *ppszOut = (LPSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppszOut)
        {
            cch = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchIn,
                                      *ppszOut, cbAlloc, NULL, NULL);

            if (!cch)
            {
                LocalFree(*ppszOut);
                *ppszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

/* Max number of characters. Doesn't include termination character */

#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout

/***************************************************************************\
* SP_PutNumber
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
\***************************************************************************/

int SP_PutNumber(
    LPSTR lpstr,
    ULONG64 n,
    int   limit,
    DWORD radix,
    int   uppercase,
    int   *pcch)
{
    DWORD mod;
    *pcch = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
                mod += uppercase;
            *lpstr++ = (char)mod;
            (*pcch)++;
        } while((*pcch < limit) && n);
    }

    return (n == 0) && (*pcch > 0);
}

/***************************************************************************\
* SP_Reverse
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
\***************************************************************************/

void SP_Reverse(
    LPSTR lpFirst,
    LPSTR lpLast)
{
    char ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}

/***************************************************************************\
* SP_GetFmtValue
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

LPCSTR SP_GetFmtValue(
    LPCSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= '0' && *lpch <= '9') {
        ii *= 10;
        ii += (int)(*lpch - '0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from SP_GetFmtValue)
\***************************************************************************/

LPCWSTR SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* wvsprintfA (API)
*
* Windows version of vsprintf().  Does not support floating point or
* pointer types, and all strings are assumed to be FAR.  Supports only
* the left alignment flag.
*
* Takes pointers to an output buffer, where the string is built, a
* pointer to an input buffer, and a pointer to a list of parameters.
*
* The cdecl function wnsprintf() calls this function.
*
* History:
* 11-12-90 MikeHar      Ported from windows 3
* 12-11-90 GregoryW     after %d format is parsed lpParms needs to be aligned
*                       to a dword boundary.
* 09-Aug-1991 mikeke    no it doesn't
* 11-19-91 DarrinM      Now wvsprintf and wsprintf treat parameters the same
*                       (as if they originated from a DWORD-aligned stack).
* 1-22-97 tnoonan       Converted to wvnsprintfA
\***************************************************************************/

LWSTDAPI_(int) wvnsprintfA(
    LPSTR lpOut,
    int cchLimitIn,
    LPCSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem = FALSE;
    char prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = --cchLimitIn, cch, cchAvailable;
    LPSTR lpT, lpTMB = NULL;
    LPWSTR pwsz;
    va_list varglist = arglist;
    union {
        LONG64 l;
        ULONG64 ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    if (cchLimit < 0)
        return 0;

    while (*lpFmt != 0) {
        if (*lpFmt == '%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == '-')
                    left++;
                else if (*lpFmt == '#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == '0') {
                fillch = '0';
                lpFmt++;
            } else
                fillch = ' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValue((LPCSTR)lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == '.') {
                lpFmt = SP_GetFmtValue((LPCSTR)++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * 64bit number: size == 3
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if (*lpFmt == 'w') {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == 'l') {
                size = 1;
                lpFmt++;
            } else if (*lpFmt == 't') {
                size = 0;
                lpFmt++;
            } else if (*lpFmt == 'I') {
                if (*(lpFmt+1) == '3' && *(lpFmt+2) == '2') {
                    size = 1;
                    lpFmt += 3;
                } else if (*(lpFmt+1) == '6' && *(lpFmt+2) == '4') {
                    size = 3;
                    lpFmt += 3;
                } else {
                    size = (sizeof(INT_PTR) == sizeof(LONG)) ? 1 : 3;
                    lpFmt++;
                }
            } else {
                size = 0;
                if (*lpFmt == 'h') {
                    lpFmt++;
                    hprefix = 1;
                } else if ((*lpFmt == 'i') || (*lpFmt == 'd')) {
                    // %i or %d specified (no modifiers) - use long
                    // %u seems to have always been short - leave alone
                    size = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case 'i':
            case 'd':
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case 'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = ' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 * if size == 3, "%p" was specified
                 */
                if (size == 3) {
                    val.l = va_arg(varglist, LONG64);
                } else if (size) {
                    val.l = va_arg(varglist, long);
                } else if (sign) {
                    val.l = (long)va_arg(varglist, short);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                /*
                 * Unless printing a full 64-bit value, ensure values
                 * here are not in canonical longword format to prevent
                 * the sign extended upper 32-bits from being printed.
                 */
                if (size != 3) {
                    val.l &= MAXDWORD;
                }

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 * SP_PutNumber returns false if it runs out of space
                 */
                if (!SP_PutNumber(lpOut, val.l, cchLimit, radix, upper, &cch))
                {
                    break;
                }

                //  Now we have the number backwards, calculate how much
                //  more buffer space we'll need for this number to
                //  format correctly.
                cchAvailable = cchLimit - cch;

                width -= cch;
                prec -= cch;
                if (prec > 0)
                {
                    width -= prec;
                    cchAvailable -= prec;
                }

                if (width > 0)
                {
                    cchAvailable -= width - (sign ? 1 : 0);
                }

                if (sign)
                {
                    cchAvailable--;
                }

                if (cchAvailable < 0)
                {
                    break;
                }

                //  We have enough space to format the buffer as requested
                //  without overflowing.

                lpOut += cch;
                cchLimit -= cch;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out('0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != '0') {
                        if (sign) {
                            sign = 0;
                            out('-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out('0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out('-');

                    if (prefix) {
                        out(prefix);
                        out('0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_Reverse(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out('-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out('0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_Reverse(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case 'p':
                size = (sizeof(PVOID) == sizeof(LONG)) ? 1 : 3;
                if (prec == -1) {
                    prec = 2 * sizeof(PVOID);
                }

                /*** FALL THROUGH to case 'X' ***/

            case 'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case 'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = 'X';
                    else
                        prefix = 'x';
                goto donumeric;

            case 'C':
                /*
                 * explicit size specifier overrides case
                 */
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'c' ***/

            case 'c':
                /*
                 * if size == 0, "%c" or "%hc" or "%tc" was specified (CHAR)
                 * if size == 1, "%C" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0x0000;
                    pwsz = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    lpT = val.sz;
                    goto putstring;
                }

            case 'S':
                /*
                 * explicit size specifier overrides case
                 */
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 's' ***/

            case 's':
                /*
                 * if size == 0, "%s" or "%hs" or "%ts" was specified (LPSTR);
                 * if size == 1, "%S" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" was specified (LPWSTR)
                 */
                if (size) {
                    pwsz = va_arg(varglist, LPWSTR);
                    if (pwsz == NULL) {
                        cch = 0;
                    } else {
                        cch = wcslen(pwsz);
                    }
putwstring:
                    cch = _WCSToMB(pwsz, cch, &lpTMB);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTMB;
                } else {
                    lpT = va_arg(varglist, LPSTR);
                    if (lpT == NULL) {
                        cch = 0;
                    } else {
                        cch = strlen(lpT);
                    }
                }
putstring:
                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     LocalFree(lpTMB);
                     fAllocateMem = FALSE;
                }
                break;

            default:
normalch:
                if (IsDBCSLeadByte(*lpFmt)) {
                    out(*lpFmt++);
                    if (!*lpFmt)
                        break;      // lead byte with no trail byte
                }
                out(*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    if (fAllocateMem)
    {
        LocalFree(lpTMB);
    }

    return cchLimitIn - cchLimit;
}

/***************************************************************************\
* StringPrintfA (API)
*
* Windows version of sprintf
*
* History:
* 11-12-90 MikeHar      Ported from windows 3
* 02-05-90 DarrinM      Cleaned up with STDARG.h vararg stuff.
* 1-22-97 tnoonan       Converted to wnsprintfA
\***************************************************************************/

LWSTDAPIV_(int) wnsprintfA(
    LPSTR lpOut,
    int cchLimitIn,
    LPCSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvnsprintfA(lpOut, cchLimitIn, lpFmt, arglist);
    va_end(arglist);
    return ret;
}

/***************************************************************************\
* SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int SP_PutNumberW(
    LPWSTR lpstr,
    ULONG64 n,
    int   limit,
    DWORD radix,
    int   uppercase,
    int   *pcch)
{
    DWORD mod;
    *pcch = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            (*pcch)++;
        } while((*pcch < limit) && n);
    }

    return (n == 0) && (*pcch > 0);
}

/***************************************************************************\
* SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
* 1-22-97 tnoonan       Converted to wvnsprintfW
\***************************************************************************/

LWSTDAPI_(int) wvnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem = FALSE;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = --cchLimitIn, cch, cchAvailable;
    LPWSTR lpT, lpTWC = NULL;
    LPBYTE psz;
    va_list varglist = arglist;
    union {
        LONG64 l;
        ULONG64 ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    if (cchLimit < 0)
        return 0;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * 64bit number: size == 3
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else if (*lpFmt == L'I') {
                if (*(lpFmt+1) == L'3' && *(lpFmt+2) == L'2') {
                    size = 1;
                    lpFmt += 3;
                } else if (*(lpFmt+1) == L'6' && *(lpFmt+2) == L'4') {
                    size = 3;
                    lpFmt += 3;
                } else {
                    size = (sizeof(INT_PTR) == sizeof(LONG)) ? 1 : 3;
                    lpFmt++;
                }
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                } else if ((*lpFmt == L'i') || (*lpFmt == L'd')) {
                    // %i or %d specified (no modifiers) - use long
                    // %u seems to have always been short - leave alone
                    size = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 * if size == 3, "%p" was specified
                 */
                if (size == 3) {
                    val.l = va_arg(varglist, LONG64);
                } else if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                /*
                 * Unless printing a full 64-bit value, ensure values
                 * here are not in canonical longword format to prevent
                 * the sign extended upper 32-bits from being printed.
                 */
                if (size != 3) {
                    val.l &= MAXDWORD;
                }

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 * SP_PutNumberW returns FALSE if it runs out of space
                 */
                if (!SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper, &cch))
                {
                    break;
                }

                //  Now we have the number backwards, calculate how much
                //  more buffer space we'll need for this number to
                //  format correctly.
                cchAvailable = cchLimit - cch;

                width -= cch;
                prec -= cch;
                if (prec > 0)
                {
                    width -= prec;
                    cchAvailable -= prec;
                }

                if (width > 0)
                {
                    cchAvailable -= width - (sign ? 1 : 0);
                }

                if (sign)
                {
                    cchAvailable--;
                }

                if (cchAvailable < 0)
                {
                    break;
                }

                //  We have enough space to format the buffer as requested
                //  without overflowing.

                lpOut += cch;
                cchLimit -= cch;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'p':
                size = (sizeof(PVOID) == sizeof(LONG)) ? 1 : 3;
                if (prec == -1) {
                    prec = 2 * sizeof(PVOID);
                }

                /*** FALL THROUGH to case 'X' ***/

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = val.sz;
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    if (lpT == NULL) {
                        cch = 0;
                    } else {
                        cch = wcslen(lpT);
                    }
                } else {
                    psz = va_arg(varglist, LPBYTE);
                    if (psz == NULL) {
                        cch = 0;
                    } else {
                        cch = strlen(psz);
                    }
putstring:
                    cch = _MBToWCS(psz, cch, &lpTWC);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }
putwstring:
                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     LocalFree(lpTWC);
                     fAllocateMem = FALSE;
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    if (fAllocateMem)
    {
        LocalFree(lpTWC);
    }

    return cchLimitIn - cchLimit;
}

LWSTDAPIV_(int) wnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvnsprintfW(lpOut, cchLimitIn, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themebld.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-1998
#   All Rights Reserved.
#
##########################################################################


!if !defined(CCSHELL_DIR)
!error  CCSHELL_DIR must be defined in sources file
!endif

!INCLUDE $(CCSHELL_DIR)\COMMON.INC
THEME_DIR = $(CCSHELL_DIR)\themes

#
# Set private paths
#

INCLUDES = $(THEME_DIR)\inc;$(THEME_DIR)\themedir;$(INCLUDES)
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE -DWIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\util.cpp ===
#include "priv.h"
#include <shlobj.h>
#include <shellp.h>
#include <ieguidp.h>
#include "ids.h"
#include <objbase.h>
#include <trayp.h>
#include <shdocvw.h>
#include <mshtmhst.h>
#include <shsemip.h>
#include <winnetp.h>
#include <inetreg.h>
#include <shguidp.h>
#include <shlguid.h>            // Defines: CLSID_ACLMRU
#include <htmlhelp.h>
#include <mluisupp.h>
#include "apithk.h"
#include <initguid.h>
#include <shimgdata.h>
#include <varutil.h>

#define REGSTR_PATH_MESSAGEBOXCHECKA "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DontShowMeThisDialogAgain"
#define REGSTR_PATH_MESSAGEBOXCHECKW L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DontShowMeThisDialogAgain"


//  Raw accelerator table
typedef struct
{
    int     cEntries;
    ACCEL   rgacc[0];
} CA_ACCEL;


STDAPI_(HANDLE) SHLoadRawAccelerators(HINSTANCE hInst, LPCTSTR lpTableName)
{
    CA_ACCEL *pca = NULL;
    HACCEL hAcc = LoadAccelerators(hInst, lpTableName);    //  Load the accelerator resource
    if (hAcc)
    {
        //  Retrieve the number of entries
        int cEntries = CopyAcceleratorTable(hAcc, NULL, 0);
        if (cEntries > 0)
        {
            //  Allocate a counted array and copy the elements
            pca = (CA_ACCEL*)LocalAlloc(LPTR, sizeof(CA_ACCEL) + cEntries * sizeof(ACCEL));
            if (pca)
            {
                pca->cEntries = cEntries;
                if (cEntries != CopyAcceleratorTable(hAcc, pca->rgacc, cEntries))
                {
                    LocalFree(pca);
                    pca = NULL;
                }
            }
        }
        DestroyAcceleratorTable(hAcc);
    }
    
    return pca;
}

STDAPI_(BOOL) SHQueryRawAccelerator(HANDLE hcaAcc, IN BYTE fVirtMask, IN BYTE fVirt, IN WPARAM wKey, OUT OPTIONAL UINT* puCmdID)
{
    ASSERT(hcaAcc);
    CA_ACCEL* pca = (CA_ACCEL*)hcaAcc;
    
    if (puCmdID)
        *puCmdID = 0;

    for(int i = 0; i < pca->cEntries; i++)
    {
        if (fVirt == (pca->rgacc[i].fVirt & fVirtMask) && wKey == pca->rgacc[i].key)
        {
            if (puCmdID)
                *puCmdID = pca->rgacc[i].cmd;
            return TRUE;
        }
    }
    return FALSE;
}

STDAPI_(BOOL) SHQueryRawAcceleratorMsg(HANDLE hcaAcc, MSG* pmsg, OUT OPTIONAL UINT* puCmdID)
{
    if (WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message)
    {
        #define TESTKEYSTATE(vk)   ((GetKeyState(vk) & 0x8000)!=0)

        BYTE fVirt = FVIRTKEY;
    
        if (TESTKEYSTATE(VK_CONTROL))
            fVirt |= FCONTROL;
        else if (TESTKEYSTATE(VK_SHIFT))
            fVirt |= FSHIFT;
        else if (TESTKEYSTATE(VK_MENU))
            fVirt |= FALT;

        return SHQueryRawAccelerator(hcaAcc, fVirt, fVirt, pmsg->wParam, puCmdID);
    }
    return FALSE;
}

STDAPI SHSetThreadRef(IUnknown *punk)
{
#ifdef DEBUG
    IUnknown* tmp;
    tmp = (IUnknown*)TlsGetValue(g_tlsThreadRef);
    ASSERT(NULL==tmp || NULL==punk);
#endif

    return TlsSetValue(g_tlsThreadRef, punk) ? S_OK : E_FAIL;
}

STDAPI SHGetThreadRef(IUnknown **ppunk)
{
    *ppunk = (IUnknown *)TlsGetValue(g_tlsThreadRef);
    if (*ppunk)
    {
        (*ppunk)->AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDAPI SHSetOtherThreadsRef(IUnknown *punk)
{
#ifdef DEBUG
    IUnknown* tmp;
    tmp = (IUnknown*)TlsGetValue(g_tlsOtherThreadsRef);
    ASSERT(NULL==tmp || NULL==punk);
#endif

    return TlsSetValue(g_tlsOtherThreadsRef, punk) ? S_OK : E_FAIL;
}

// release a CTF_THREAD_REF reference earlier than the return of pfnThreadProc
STDAPI SHReleaseThreadRef()
{
    IUnknown* punk;
    punk = (IUnknown *)TlsGetValue(g_tlsOtherThreadsRef);
    if (punk)
    {
        TlsSetValue(g_tlsOtherThreadsRef, NULL);
        punk->Release();
        return S_OK;
    }

    RIPMSG(FALSE, "Why is caller SHRealeaseThreadRef()ing when they don't have a thread ref?");
    return S_FALSE;
}

// thread reference count object, this uses SHSetThreadRef()to let other code
// in this process hold a reference to this main thread, and thus the main thread in this process

class CRefThread : public IUnknown
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    CRefThread(LONG *pcRef);

private:
    ~CRefThread();

    LONG *_pcRef;
    UINT _idThread;
};


CRefThread::CRefThread(LONG *pcRef) 
{
    _idThread = GetCurrentThreadId();
    _pcRef = pcRef;
    *_pcRef = 1;

}

//
//  Note that this code tightens but does not close a race window.
//  Although we nuke the process reference, the class factory for
//  the web browser has yet to be deregistered, so if somebody decides
//  to create one, our class factory will wake up and create a
//  shell folder, which will flake out because it can't get a
//  process reference.
//
CRefThread::~CRefThread() 
{
    *_pcRef = 0;

    // get the other thread out of WaitMessage() or GetMessage()
    PostThreadMessage(_idThread, WM_NULL, 0, 0);
}


HRESULT CRefThread::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { { 0 }, };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CRefThread::AddRef()
{
    return InterlockedIncrement(_pcRef);
}

ULONG CRefThread::Release()
{
    if (InterlockedDecrement(_pcRef))
        return *_pcRef;

    delete this;
    return 0;
}

STDAPI _CreateThreadRef(LONG *pcRef, IUnknown **ppunk)
{
    *ppunk = new CRefThread(pcRef);
    if (*ppunk)
        return S_OK;

    *pcRef = 0;
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

// call if you want to kick off an independant thread.. you don't want handles back, or ids
// and if the create fails, call synchronously

typedef struct
{
    LPTHREAD_START_ROUTINE pfnMain;
    LPTHREAD_START_ROUTINE pfnSync;
    HANDLE hSync;
    void *pvData;
    DWORD dwFlags;
    IUnknown *punkThreadRef;
    IUnknown *punkProcessRef;
    HMODULE hmodFree;
    HRESULT hrThreadStart;
} PRIVCREATETHREADDATA;

DWORD CALLBACK WrapperThreadProc(void *pv)
{
    // make a copy of the input buffer, this is sitting on the calling threads stack
    // once we signal him his copy will be invalid
    PRIVCREATETHREADDATA rgCreate = *((PRIVCREATETHREADDATA *)pv);
    HRESULT hrInit;
    LONG cThreadRef;
    IUnknown *punkThreadRef;
    DWORD dwRes = 0;
    
    if (rgCreate.dwFlags & CTF_REF_COUNTED)
    {
        rgCreate.hrThreadStart = _CreateThreadRef(&cThreadRef, &punkThreadRef);
        if (SUCCEEDED(rgCreate.hrThreadStart))
            rgCreate.hrThreadStart = SHSetThreadRef(punkThreadRef);
    }

    if (SUCCEEDED(rgCreate.hrThreadStart) && rgCreate.punkThreadRef)
    {
        rgCreate.hrThreadStart = SHSetOtherThreadsRef(rgCreate.punkThreadRef); // hand punkThreadRef off to our tls value
    }

    if (SUCCEEDED(rgCreate.hrThreadStart))
    {
        if (rgCreate.dwFlags & CTF_COINIT)
            hrInit = SHCoInitialize();

        // call the synchronous ThreadProc while the other thread is waiting on hSync
        if (rgCreate.pfnSync)
            rgCreate.pfnSync(rgCreate.pvData);
    }

    // poke our return value back before releasing the main thread
    ((PRIVCREATETHREADDATA *)pv)->hrThreadStart = rgCreate.hrThreadStart;

    SetEvent(rgCreate.hSync);   // release the main thread..

    if (SUCCEEDED(rgCreate.hrThreadStart))
    {
        // call the main thread proc
        dwRes = rgCreate.pfnMain(rgCreate.pvData);

        if ((rgCreate.dwFlags & CTF_REF_COUNTED) && punkThreadRef)
        {
            MSG msg;
            //  release our ref on ourselves.
            //  then pump until everyone else 
            //  has finished using our thread.
            //  this is important for COM objects
            //  that were created on this thread 
            //  but are being used by another thread
            punkThreadRef->Release();
            while (cThreadRef)
            {
                if (GetMessage(&msg, NULL, 0, 0))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        if (rgCreate.punkThreadRef)
        {
            // If pfnMain hasn't released the thread reference yet, do it ourselves
            IUnknown* tmp;
            tmp = (IUnknown*)TlsGetValue(g_tlsOtherThreadsRef);
            if (tmp)
                SHReleaseThreadRef();
        }

        if (rgCreate.punkProcessRef)
            rgCreate.punkProcessRef->Release();

        if (rgCreate.dwFlags & CTF_COINIT)
            SHCoUninitialize(hrInit);

        if (rgCreate.hmodFree)
            FreeLibraryAndExitThread(rgCreate.hmodFree, dwRes);
    }
    
    return dwRes;
}


// Call if you want to kick off an independent thread and
// you don't care about the handle or thread ID.
//
// If the create fails, call synchronously.
//
// optionally call a secondary callback when the thread
// is created.
// returns: 
//      TRUE if pfnThreadProc was executed

STDAPI_(BOOL) SHCreateThread(
    LPTHREAD_START_ROUTINE pfnThreadProc,
    void *pvData,
    DWORD dwFlags,                          // CTF_*
    LPTHREAD_START_ROUTINE pfnCallback)     OPTIONAL
{
    BOOL bRet = FALSE;
    PRIVCREATETHREADDATA rgCreate = {0};  // can be on the stack since we sync the thread

    if ((dwFlags & CTF_INSIST) && pfnCallback)
    {
        ASSERTMSG(FALSE, "SHCreateThread: cannot specify CTF_INSIST and pfnCallback at the same time");
        return FALSE;
    }

    if (CTF_THREAD_REF & dwFlags)
    {
        if (FAILED(SHGetThreadRef(&rgCreate.punkThreadRef)))
        {
            TraceMsg(TF_WARNING, "SHCreateThread is failing since caller requested CTF_THREAD_REF but does not support thread references.");

            // The calling code is requesting a thread-ref, but the thread doesn't support it.
            // Whatever requires this thread-ref will break, so we must return FALSE here (and
            // let the caller work around it).
            return FALSE;
        }
    }

    if (CTF_PROCESS_REF & dwFlags)
    {
        SHGetInstanceExplorer(&rgCreate.punkProcessRef);
    }

    if (CTF_FREELIBANDEXIT & dwFlags)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery(pfnThreadProc, &mbi, sizeof(mbi)))
        {
            TCHAR szModule[MAX_PATH];
            if (GetModuleFileName((HMODULE)mbi.AllocationBase, szModule, ARRAYSIZE(szModule)))
            {
                rgCreate.hmodFree = LoadLibrary(szModule);
            }
        }
    }

    rgCreate.pfnMain = pfnThreadProc;
    rgCreate.pfnSync = pfnCallback;
    rgCreate.pvData = pvData;
    rgCreate.dwFlags = dwFlags;
    rgCreate.hSync = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (rgCreate.hSync)
    {
        DWORD idThread;
        HANDLE hThread = CreateThread(NULL, 0, WrapperThreadProc, &rgCreate, 0, &idThread);
        if (hThread)
        {
            // Some pfnCallback procs need to do SendMessage to the calling thread, others
            // want to do COM.  This COM thing is new, so reduce the risk of breaking things
            // by making it by-request only
            if (CTF_WAIT_ALLOWCOM & dwFlags)
                SHWaitForCOMSendMessageThread(rgCreate.hSync, INFINITE);
            else
                SHWaitForSendMessageThread(rgCreate.hSync, INFINITE);
            CloseHandle(hThread);

            // If the WrapperThreadProc failed to initialize itself, pretend we failed to create the thread
            bRet = SUCCEEDED(rgCreate.hrThreadStart);
        }
        CloseHandle(rgCreate.hSync);
    }

    if (!bRet)
    {
        if (rgCreate.punkThreadRef)
        {
            rgCreate.punkThreadRef->Release();
        }

        if (rgCreate.punkProcessRef)
        {
            rgCreate.punkProcessRef->Release();
        }

        if (rgCreate.hmodFree)
            FreeLibrary(rgCreate.hmodFree);

        if (dwFlags & CTF_INSIST)
        {
            // failed to create another thread... call synchronously
            pfnThreadProc(pvData);
            bRet = TRUE;
        }
    }

    return bRet;
}



STDAPI_(BOOL) SHIsLowMemoryMachine(DWORD dwType)
// Are we an 8 meg Win95 machine or 16 meg NT machine.
// Back in the old days...
{
#ifdef UNIX
    return 0; //due to GlobalMemoryStatus() always return 0 physical mem size.
#else
    static int fLowMem = -1;

    if (ILMM_IE4 == dwType && fLowMem == -1)
    {
        MEMORYSTATUS ms;
        GlobalMemoryStatus(&ms);

        if (g_bRunningOnNT)
            fLowMem = (ms.dwTotalPhys <= 16*1024*1024);
        else
            fLowMem = (ms.dwTotalPhys <= 8*1024*1024);
    }

    return fLowMem;
#endif
}

#if 0

// MultiByteToWideChar doesn't truncate if the buffer is too small.
// these utils do.
// returns:
//      # of chars converted (WIDE chars) into out buffer (pwstr)

int _AnsiToUnicode(UINT uiCP, LPCSTR pstr, LPWSTR pwstr, int cch)
{
    int cchDst = 0;

    ASSERT(IS_VALID_STRING_PTRA(pstr, -1));
    ASSERT(NULL == pwstr || IS_VALID_WRITE_BUFFER(pwstr, WCHAR, cch));

    if (cch && pwstr)
        pwstr[0] = 0;

#if 0
    switch (uiCP)
    {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // fall through;
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
        {
            INT cchSrc, cchSrcOriginal;

            cchSrc = cchSrcOriginal = lstrlenA(pstr) + 1;
            cchDst = cch;

            if (SUCCEEDED(ConvertINetMultiByteToUnicode(NULL, uiCP, pstr,
                &cchSrc, pwstr, &cchDst)) &&
                cchSrc < cchSrcOriginal)
            {
                LPWSTR pwsz = (LPWSTR)LocalAlloc(LPTR, cchDst * sizeof(WCHAR));
                if (pwsz)
                {
                    if (SUCCEEDED(ConvertINetMultiByteToUnicode(NULL, uiCP, pstr,
                        &cchSrcOriginal, pwsz, &cchDst)))
                    {
                        StrCpyNW(pwstr, pwsz, cch);
                        cchDst = cch;
                    }
                    LocalFree(pwsz);
                }
            }
            break;
        }

        default:
#endif
            cchDst = MultiByteToWideChar(uiCP, 0, pstr, -1, pwstr, cch);
            if (!cchDst) 
            {
                // failed.

                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
                {
                    int cchNeeded = MultiByteToWideChar(uiCP, 0, pstr, -1, NULL, 0);

                    if (cchNeeded) 
                    {
                        LPWSTR pwsz = (LPWSTR)LocalAlloc(LPTR, cchNeeded * sizeof(WCHAR));
                        if (pwsz) 
                        {
                            cchDst = MultiByteToWideChar(uiCP, 0, pstr, -1, pwsz, cchNeeded);
                            if (cchDst) 
                            {
                                StrCpyNW(pwstr, pwsz, cch);
                                cchDst = cch;
                            }
                            LocalFree(pwsz);
                        }
                    }
                }
            }
#if 0
            break;
    }
#endif
    return cchDst;
}

// returns:
//      # of BYTES written to output buffer (pstr)

int _UnicodeToAnsi(UINT uiCP, LPCWSTR pwstr, LPSTR pstr, int cch)
{
    int cchDst = 0;

    ASSERT(IS_VALID_STRING_PTRW(pwstr, -1));
    ASSERT(NULL == pstr || IS_VALID_WRITE_BUFFER(pstr, char, cch));

    if (pstr && cch)
        pstr[0] = 0;

#if 0
    switch (uiCP)
    {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // fall through
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
        {
            INT cchSrc, cchSrcOriginal;

            cchSrc = cchSrcOriginal = lstrlenW(pwstr) + 1;
            cchDst = cch;

            if (SUCCEEDED(ConvertINetUnicodeToMultiByte(NULL, uiCP, pwstr,
                &cchSrc, pstr, &cchDst)) &&
                cchSrc < cchSrcOriginal)
            {
                LPSTR psz = (LPSTR)LocalAlloc(LPTR, cchDst * sizeof(CHAR));
                if (psz)
                {
                    if (SUCCEEDED(ConvertINetUnicodeToMultiByte(NULL, uiCP, pwstr,
                        &cchSrcOriginal, psz, &cchDst)))
                    {
                        // lstrcpyn puts NULL at pstr[cch-1]
                        // without considering if it'd cut in dbcs
                        TruncateString(psz, cch);
                        lstrcpynA(pstr, psz, cch);
                        cchDst = cch;
                    }
                    LocalFree(psz);
                }
            }
            break;
        }
        default:
#endif
            cchDst = WideCharToMultiByte(uiCP, 0, pwstr, -1, pstr, cch, NULL, NULL);
            if (!cchDst) 
            {
                // failed.
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
                {
                    int cchNeeded = WideCharToMultiByte(uiCP, 0, pwstr, -1, NULL, 0, NULL, NULL);

                    if (cchNeeded > 0) 
                    {
                        LPSTR psz = (LPSTR)LocalAlloc(LPTR, cchNeeded * sizeof(CHAR));
                        if (psz) 
                        {
                            cchDst = WideCharToMultiByte(uiCP, 0, pwstr, -1, psz, cchNeeded, NULL, NULL);
                            if (cchDst) 
                            {
                                // lstrcpyn puts NULL at pstr[cch-1]
                                // without considering if it'd cut in dbcs
                                SHTruncateString(psz, cch);
                                lstrcpynA(pstr, psz, cch);
                                cchDst = cch;
                            }
                            LocalFree(psz);
                        }
                    }
                }
            }
#if 0
            break;
    }
#endif
    return cchDst;
}

#endif

// SHTruncateString
//
// purpose: cut a string at the given length in dbcs safe manner.
//          the string may be truncated at cch-2 if the sz[cch] points
//          to a lead byte that would result in cutting in the middle
//          of double byte character.
//
// The character at sz[cchBufferSize-1] is not consulted, so you
// can call this after lstrcpyn (which forces sz[cchBufferSize-1]=0).
//
// If the source string is shorter than cchBufferSize-1 characters,
// we fiddle some bytes that have no effect, in which case the return
// value is random.
//
// update: made it faster for sbcs environment (5/26/97)
//         now returns adjusted cch            (6/20/97)
//
STDAPI_(int) SHTruncateString(CHAR *sz, int cchBufferSize)
{
    if (!sz || cchBufferSize <= 0) return 0;

    int cch = cchBufferSize - 1; // get index position to NULL out

    LPSTR psz = &sz[cch];

    while (psz >sz)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // Found non-leadbyte for the first time.
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or &sz[cch]
            psz++;
            break;
        }
    }
    if (((&sz[cch] - psz) & 1) && cch > 0)
    {
        // we're truncating the string in the middle of dbcs
        cch--;
    }
    sz[cch] = '\0';
    return cch;
}


//
//  Why do we use the unsafe version?
//
//  -   Unsafe is much faster.
//
//  -   The safe version isn't safe after all and serves only to mask
//      existing bugs.  The situation the safe version "saves" is if
//      two threads both try to atomicrelease the same object.  This
//      means that at the same moment, both threads think the object
//      is alive.  Change the timing slightly, and now one thread
//      atomicreleases the object before the other one, so the other
//      thread is now using an object after the first thread already
//      atomicreleased it.  Bug.
//
STDAPI_(void) IUnknown_AtomicRelease(void **ppunk)
{
#if 1 // Unsafe
    if (ppunk && *ppunk) 
    {
        IUnknown* punk = *(IUnknown**)ppunk;
        *ppunk = NULL;
        punk->Release();
    }
#else // Safe
    if (ppunk) 
    {
        IUnknown* punk = (IUnknown *)InterlockedExchangePointer(ppunk, NULL);
        if (punk) 
        {
            punk->Release();
        }
    }
#endif
}


STDAPI ConnectToConnectionPoint(IUnknown* punk, REFIID riidEvent, BOOL fConnect, IUnknown* punkTarget, DWORD* pdwCookie, IConnectionPoint** ppcpOut)
{
    // We always need punkTarget, we only need punk on connect
    if (!punkTarget || (fConnect && !punk))
        return E_FAIL;

    if (ppcpOut)
        *ppcpOut = NULL;

    IConnectionPointContainer *pcpc;
    HRESULT hr = punkTarget->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcpc));
    if (SUCCEEDED(hr))
    {
        IConnectionPoint *pcp;
        hr = pcpc->FindConnectionPoint(riidEvent, &pcp);
        if (SUCCEEDED(hr))
        {
            if (fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punk, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
        }
        pcpc->Release();
    }
    return hr;
}

STDAPI IUnknown_QueryStatus(IUnknown *punk, const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = E_FAIL;
    if (punk) 
    {
        IOleCommandTarget* pct;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct));
        if (pct) 
        {
            hr = pct->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
            pct->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_Exec(IUnknown* punk, const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = E_FAIL;
    if (punk) 
    {
        IOleCommandTarget* pct;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct));
        if (SUCCEEDED(hr)) 
        {
            hr = pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            pct->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_TranslateAcceleratorIO(IUnknown* punk, LPMSG lpMsg)
{
    HRESULT hr = E_FAIL;

    if (punk != NULL)
    {
        IInputObject *pio;

        hr = punk->QueryInterface(IID_PPV_ARG(IInputObject, &pio));
        if (SUCCEEDED(hr))
        {
            hr = pio->TranslateAcceleratorIO(lpMsg);
            pio->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_UIActivateIO(IUnknown *punk, BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hr = E_FAIL;

    if (punk != NULL)
    {
        IInputObject *pio;

        hr = punk->QueryInterface(IID_PPV_ARG(IInputObject, &pio));
        if (SUCCEEDED(hr))
        {
            hr = pio->UIActivateIO(fActivate, lpMsg);
            pio->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_OnFocusChangeIS(IUnknown *punk, IUnknown *punkSrc, BOOL fSetFocus)
{
    HRESULT hr = E_FAIL;

    if (punk != NULL)
    {
        IInputObjectSite *pis;

        hr = punk->QueryInterface(IID_PPV_ARG(IInputObjectSite, &pis));
        if (SUCCEEDED(hr))
        {
            hr = pis->OnFocusChangeIS(punkSrc, fSetFocus);
            pis->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_HasFocusIO(IUnknown *punk)
{
    HRESULT hr = E_FAIL;

    if (punk != NULL)
    {
        IInputObject *pio;

        hr = punk->QueryInterface(IID_PPV_ARG(IInputObject, &pio));
        if (SUCCEEDED(hr))
        {
            hr = pio->HasFocusIO();
            pio->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_DoContextMenuPopup(IUnknown *punkSite, IContextMenu* pcm, UINT fFlags, POINT pt)
{
    IContextMenuSite* pcms;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SContextMenuSite, IID_PPV_ARG(IContextMenuSite, &pcms));
    if (SUCCEEDED(hr))
    {
        hr = pcms->DoContextMenuPopup(pcm, fFlags, pt);
        pcms->Release();
    }
    else
    {
#if 0 // REVIEW: do we want fall-back code?
        HWND hwnd;
        hr = IUnknown_GetWindow(punkSite, &hwnd);
        if (SUCCEEDED(hr))
        {
            HMENU hmenu = CreatePopupMenu();
            if (hmenu)
            {
                IShellBrowser* psb;
                if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
                {
                    HWND hwnd;
                    if (SUCCEEDED(psb->GetControlWindow(FCW_TREE, &hwnd)) && hwnd)
                    {
                        fFlags |= CMF_EXPLORE;
                    }
                    psb->Release();
                }

                if (GetKeyState(VK_SHIFT) < 0)
                {
                    fFlags |= CMF_EXTENDEDVERBS;
                }

                hr = pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, fFlags);
                if (SUCCEEDED(hr))
                {
                    int idCmd = TrackPopupMenuEx(hmenu,
                                                 TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                                 pt.x,
                                                 pt.y,
                                                 hwnd,
                                                 NULL);

                    if (0 != idCmd)
                    {
                        idCmd -= CONTEXTMENU_IDCMD_FIRST;

                        CMINVOKECOMMANDINFOEX ici = {0};
                        ici.cbSize = sizeof(ici);
                        ici.fMask  = CMIC_MASK_ASYNCOK | CMIC_MASK_PTINVOKE;
                        ici.hwnd = hwnd;
                        ici.lpVerb = (LPCSTR)IntToPtr(idCmd);
                        ici.nShow = SW_SHOWDEFAULT;
                        ici.lpVerbW = (LPCWSTR)IntToPtr(idCmd);
                        ici.pt.x = pt.x;
                        ici.pt.y = pt.y;

                        if (GetKeyState(VK_SHIFT) < 0)
                            ici.fMask |= CMIC_MASK_SHIFT_DOWN;

                        if (GetKeyState(VK_CONTROL) < 0)
                            ici.fMask |= CMIC_MASK_CONTROL_DOWN;

                        hr = pcm->InvokeCommand(reinterpret_cast<LPCMINVOKECOMMANDINFO>(&ici));
                    }
                    else
                    {
                        hr = ERROR_CANCELLED;
                    }
                }
                DestroyMenu(hmenu);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
#endif
    }
    return hr;
}


STDAPI_(DWORD) SHSetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    DWORD dwStyle = GetWindowLong(hWnd, iWhich);
    DWORD dwNewStyle = (dwStyle & ~dwBits) | (dwValue & dwBits);
    if (dwStyle != dwNewStyle) 
    {
        SetWindowLong(hWnd, iWhich, dwNewStyle);
    }
    return dwStyle;
}


// OpenRegStream API in SHELL32 returns an emtpy
// stream if we ask for read-only, if the entry does not exist.
// we need to detect that case.
//
const LARGE_INTEGER c_li0 = { 0, 0 };

STDAPI_(BOOL) SHIsEmptyStream(IStream* pstm)
{
#ifdef DEBUG
    // We always call this function when we open a new stream,
    // so we should always be at the beginning of the stream.
    //
    // We need this assert for the <NT5 shell case.
    //
    ULARGE_INTEGER liStart;
    pstm->Seek(c_li0, STREAM_SEEK_CUR, &liStart);
    ASSERT(0==liStart.HighPart && 0==liStart.LowPart);
#endif

    STATSTG st;
    if (SUCCEEDED(pstm->Stat(&st, STATFLAG_NONAME)))
    {
        if (st.cbSize.LowPart || st.cbSize.HighPart)
            return FALSE;
    }
    else
    {
        // Win95 IStream code did not implement stat, so check
        // emptiness by trying to read.
        //
        int iTmp;
        if (SUCCEEDED(IStream_Read(pstm, &iTmp, sizeof(iTmp))))
        {
            // The stream is indeed present, seek back to start
            //
            pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);

            return FALSE; // not empty
        }
    }

    return TRUE;
}


STDAPI_(void) SHSetParentHwnd(HWND hwnd, HWND hwndParent)
{
    HWND hwndOldParent = GetParent(hwnd);

    if (hwndParent != hwndOldParent)
    {
        //
        // Get the child flag correct!  If we don't do this and
        // somebody calls DialogBox on us while we are parented to NULL
        // and WS_CHILD, the desktop will be disabled, thereby causing
        // all mouse hit-testing to fail systemwide.
        // we also want to do this in the right order so the window
        // manager does the correct attachthreadinput if required...
        //

        if (hwndParent)
            SHSetWindowBits(hwnd, GWL_STYLE, WS_CHILD | WS_POPUP, WS_CHILD);

        SetParent(hwnd, hwndParent);

        if (!hwndParent)
            SHSetWindowBits(hwnd, GWL_STYLE, WS_CHILD | WS_POPUP, WS_POPUP);

        //
        // (jbeda) USER32 doesn't mirror the UIS bits correctly when windows
        //         are reparented.  They (mcostea) say that it would cause
        //         compat problems.  So to work around this, when
        //         we reparent, we grab the bits on the parent window
        //         and mirror them to the child.
        //
        if (g_bRunningOnNT5OrHigher)
        {
            LRESULT lUIState;

            lUIState = SendMessage(hwndParent, WM_QUERYUISTATE, 0, 0);

            if (lUIState & (UISF_HIDEFOCUS | UISF_HIDEACCEL))
            {
                SendMessage(hwnd, WM_UPDATEUISTATE,
                             MAKEWPARAM(UIS_SET, 
                               lUIState & (UISF_HIDEFOCUS | UISF_HIDEACCEL)), 0);
            }

            if (~lUIState & (UISF_HIDEFOCUS | UISF_HIDEACCEL))
            {
                SendMessage(hwnd, WM_UPDATEUISTATE,
                             MAKEWPARAM(UIS_CLEAR, 
                               ~lUIState & (UISF_HIDEFOCUS | UISF_HIDEACCEL)), 0);
            }
        }

    }
}


// IsSameObject checks for OLE object identity.
//
STDAPI_(BOOL) SHIsSameObject(IUnknown* punk1, IUnknown* punk2)
{
    if (!punk1 || !punk2)
    {
        return FALSE;
    }
    else if (punk1 == punk2)
    {
        // Quick shortcut -- if they're the same pointer
        // already then they must be the same object
        //
        return TRUE;
    }
    else
    {
        IUnknown* punkI1;
        IUnknown* punkI2;

        // Some apps don't implement QueryInterface! (SecureFile)
        HRESULT hr = punk1->QueryInterface(IID_PPV_ARG(IUnknown, &punkI1));
        if (SUCCEEDED(hr))
        {
            punkI1->Release();
            hr = punk2->QueryInterface(IID_PPV_ARG(IUnknown, &punkI2));
            if (SUCCEEDED(hr))
                punkI2->Release();
        }
        return SUCCEEDED(hr) && (punkI1 == punkI2);
    }
}

// pass the CLSID of the object you are about to bind to. this queries 
// the bind context to see if that guy should be avoided 
// this would be a good shlwapi service. 

STDAPI_(BOOL) SHSkipJunction(IBindCtx *pbc, const CLSID *pclsid) 
{ 
    IUnknown *punk; 
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_SKIP_BINDING_CLSID, &punk))) 
    { 
        CLSID clsid; 
        BOOL bSkip = SUCCEEDED(IUnknown_GetClassID(punk, &clsid)) && IsEqualCLSID(clsid, *pclsid); 
        punk->Release(); 
        return bSkip; 
    } 
    return FALSE; 
} 

STDAPI IUnknown_GetWindow(IUnknown* punk, HWND* phwnd)
{
    HRESULT hr = E_FAIL;
    *phwnd = NULL;

    if (punk) 
    {
        IOleWindow* pow;
        IInternetSecurityMgrSite* pisms;
        IShellView* psv;

        // How many ways are there to get a window?  Let me count the ways...
        hr = punk->QueryInterface(IID_PPV_ARG(IOleWindow, &pow));
        if (SUCCEEDED(hr))
        {
            hr = pow->GetWindow(phwnd);
            pow->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IInternetSecurityMgrSite, &pisms))))
        {
            hr = pisms->GetWindow(phwnd);
            pisms->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
        {
            hr = psv->GetWindow(phwnd);
            psv->Release();
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION:   IUnknown_EnableModless

    DESCRIPTION:
        Several interfaces implement the ::EnableModeless() or equivalent methods.
    This requires us to use a utility function to query the punk until one is
    implemented and then use it.
\*****************************************************************************/
HRESULT IUnknown_EnableModeless(IUnknown * punk, BOOL fEnabled)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IOleInPlaceActiveObject * poipao;
        IInternetSecurityMgrSite * pisms;
        IOleInPlaceFrame * poipf;
        IShellBrowser * psb;
        IDocHostUIHandler * pdhuh;

        // How many ways are there to enable modless?  Let me count the ways...
        hr = punk->QueryInterface(IID_PPV_ARG(IOleInPlaceActiveObject, &poipao));
        if (SUCCEEDED(hr))
        {
            hr = poipao->EnableModeless(fEnabled);
            poipao->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IInternetSecurityMgrSite, &pisms))))
        {
            hr = pisms->EnableModeless(fEnabled);
            pisms->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IOleInPlaceFrame, &poipf))))
        {
            hr = poipf->EnableModeless(fEnabled);
            poipf->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IShellBrowser, &psb))))
        {
            hr = psb->EnableModelessSB(fEnabled);
            psb->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IDocHostUIHandler, &pdhuh))))
        {
            hr = pdhuh->EnableModeless(fEnabled);
            pdhuh->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_SetOwner(IUnknown* punk, IUnknown* punkOwner)
{
    HRESULT hr = E_FAIL;
    if (punk) 
    {
        IShellService* pss;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellService, &pss));
        if (SUCCEEDED(hr)) 
        {
            pss->SetOwner(punkOwner);
            pss->Release();
        }
    }
    return hr;
}

STDAPI IUnknown_SetSite(IUnknown *punk, IUnknown *punkSite)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IObjectWithSite *pows;

        hr = punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));
        if (SUCCEEDED(hr))
        {
            hr = pows->SetSite(punkSite);
            ASSERT(SUCCEEDED(hr));
            pows->Release();
        }
        else
        {
            IInternetSecurityManager * pism;

            // The security guys should have used IObjectWithSite, but no....
            hr = punk->QueryInterface(IID_PPV_ARG(IInternetSecurityManager, &pism));
            if (SUCCEEDED(hr))
            {
                hr = pism->SetSecuritySite((IInternetSecurityMgrSite *) punkSite);
                ASSERT(SUCCEEDED(hr));
                pism->Release();
            }
        }
    }
    return hr;
}

STDAPI IUnknown_GetSite(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    *ppv = NULL;
    if (punk) 
    {
        IObjectWithSite *pows;
        hr = punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));
        ASSERT(SUCCEEDED(hr) || pows == NULL);  // paranoia
        if (SUCCEEDED(hr)) 
        {
            hr = pows->GetSite(riid, ppv);
            // Note: The GetSite can legitimately fail if there is no site
            // or the site doesn't support the requested interface.
            ASSERT(SUCCEEDED(hr) || *ppv == NULL);
            pows->Release();
        }
    }
    return hr;
}

//
//      GetUIVersion()
//
//  returns the version of shell32
//  3 == win95 gold / NT4
//  4 == IE4 Integ / win98
//  5 == win2k
//  6 == Whistler
//
STDAPI_(UINT) GetUIVersion()
{
    static UINT s_uiShell32 = 0;
    if (s_uiShell32 == 0)
    {
        HINSTANCE hinst = GetModuleHandle(TEXT("SHELL32.DLL"));
        if (hinst)
        {
            DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");
            DLLVERSIONINFO dllinfo;

            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if (pfnGetVersion && pfnGetVersion(&dllinfo) == NOERROR)
                s_uiShell32 = dllinfo.dwMajorVersion;
            else
                s_uiShell32 = 3;
        }
    }
    return s_uiShell32;
}



//***   IUnknown_GetClassID -- do punk->IPS::GetClassID
STDAPI IUnknown_GetClassID(IUnknown *punk, CLSID *pclsid)
{
    HRESULT hr = E_FAIL;

    ASSERT(punk);   // currently nobody does
    if (punk)
    {
        IPersist *p;
        hr = punk->QueryInterface(IID_PPV_ARG(IPersist, &p));

        //  sometimes we can do this since they dont answer the
        //  the QI for IPersist.  but we cant do it on NT4 plain
        //  since the net hood faults if the psf is just a \\server
        if (FAILED(hr) && (GetUIVersion() > 3))
        {
            //
            //  APPCOMPAT - we have some issues here on downlevel implementations of IPersistFolder
            //  so in order to protect ourselves from bad implementations we will wrap this in a simple
            //  exception handler.
            //
            __try
            {
                IPersistFolder *pf;
                hr = punk->QueryInterface(IID_PPV_ARG(IPersistFolder, &pf));
                p = pf;
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                hr = E_NOTIMPL;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = p->GetClassID(pclsid);
            p->Release();
        }

    }
    
    return hr;
}


STDAPI IUnknown_QueryService(IUnknown* punk, REFGUID guidService, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IServiceProvider *psp;
        hr = punk->QueryInterface(IID_PPV_ARG(IServiceProvider, &psp));
        ASSERT(SUCCEEDED(hr) ? psp != NULL : psp == NULL);  // COM rules
        if (SUCCEEDED(hr))
        {
            hr = psp->QueryService(guidService, riid, ppvOut);
            psp->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_QueryServiceForWebBrowserApp(IUnknown* punk, REFIID riid, void **ppvOut)
{
    IServiceProvider* psp;
    HRESULT hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_IServiceProvider, (LPVOID*)&psp);
    if (SUCCEEDED(hr))
    {
        hr = psp->QueryService(SID_SWebBrowserApp, riid, ppvOut);
        psp->Release();
    }
    else
        *ppvOut = NULL;

    return hr;
}

STDAPI IUnknown_ShowBrowserBar(IUnknown* punk, REFCLSID clsidBrowserBar, BOOL fShow)
{
    IWebBrowser2* pwb2;
    HRESULT hr = IUnknown_QueryServiceForWebBrowserApp(punk, IID_PPV_ARG(IWebBrowser2, &pwb2));
    if (SUCCEEDED(hr))
    {
        SA_BSTRGUID strClsid;
        InitFakeBSTR(&strClsid, clsidBrowserBar);

        VARIANT varClsid;
        V_VT(&varClsid)   = VT_BSTR;
        V_BSTR(&varClsid) = strClsid.wsz;

        VARIANT varShow;
        V_VT(&varShow)    = VT_BOOL;
        V_BOOL(&varShow)  = (fShow) ? VARIANT_TRUE : VARIANT_FALSE;

        VARIANT varEmpty = {0};

        hr = pwb2->ShowBrowserBar(&varClsid, &varShow, &varEmpty);

        pwb2->Release();
    }

    return hr;
}



#if defined(DEBUG) && 0 // defined(NOTYET)
//
// IUnknown_IsCanonical checks if the interface is the canonical IUnknown
// for the object.
//
//  S_OK    = yes it is
//  S_FALSE = no it isn't
//  error   = IUnknown implementation is buggy.
//
//  If you get an error back, it means that the IUnknown is incorrectly
//  implemented, and you probably should avoid doing anything with it.
//
STDAPI_(HRESULT) IUnknown_IsCanonical(IUnknown *punk)
{
    IUnknown *punkT;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IUnknown, &punkT));
    if (EVAL(SUCCEEDED(hr))) 
    {
        punkT->Release();
        if (punk == punkT) 
        {
            hr = S_OK;
        }
        else 
        {
            hr = S_FALSE;
        }
    }
    return hr;
}
#endif

//
//  QueryInterface that doesn't affect the refcount.  Use this when doing
//  funny aggregation games.
//
//  In order for this QI/Release trick to work, the punkOuter must be the
//  canonical IUnknown for the outer object.  It is the caller's
//  responsibility to ensure this.
//
//  punkOuter  - The controlling unknown (must be canonical)
//  punkTarget - The thing that receives the QI (must be controlled
//               by punkOuter)
//  riid       - The interface to get
//  ppvOut     - Where to put the result
//
//  On success, the interface is obtained from the punkTarget, and the
//  refcount generated by the QI is removed from the punkOuter.
//
//  If either punkOuter or punkTarget is NULL, we vacuously fail with
//  E_NOINTERFACE.
//
//  When querying from an outer to an inner, punkOuter is the outer, and
//  punkTarget is the inner.
//
//  When querying from an inner to an outer, punkOuter and punkTarget are
//  both the outer.
//
STDAPI SHWeakQueryInterface(IUnknown *punkOuter, IUnknown *punkTarget, REFIID riid, void **ppvOut)
{
    HRESULT hres;

    if (punkOuter && punkTarget) 
    {
#if defined(DEBUG) && 0 // defined(NOTYET)
        // RaymondC hasn't yet fixed all our aggregatable classes, so this
        // assertion fires too often
        ASSERT(IUnknown_IsCanonical(punkOuter));
#endif
        hres = punkTarget->QueryInterface(riid, ppvOut);
        if (SUCCEEDED(hres)) 
        {
            punkOuter->Release();
            hres = S_OK;
        }
        else 
        {
            // Double-check that QI isn't buggy.
            ASSERT(*ppvOut == NULL);
        }

    }
    else 
    {
        hres = E_NOINTERFACE;
    }

    if (FAILED(hres)) 
    {
        *ppvOut = NULL;
    }

    return hres;
}

//
//  Release an interface that was obtained via SHWeakQueryInterface.
//
//  punkOuter - The controlling unknown
//  ppunk     - The IUnknown to release
//
STDAPI_(void) SHWeakReleaseInterface(IUnknown *punkOuter, IUnknown **ppunk)
{
    if (*ppunk) 
    {
        ASSERT(IS_VALID_CODE_PTR(punkOuter, IUnknown));
        punkOuter->AddRef();
        IUnknown_AtomicRelease((void **)ppunk);
    }
}

HRESULT IUnknown_SetOptions(IUnknown * punk, DWORD dwACLOptions)
{
    IACList2 * pal2;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IACList2, &pal2));
    if (SUCCEEDED(hr))
    {
        hr = pal2->SetOptions(dwACLOptions);
        pal2->Release();
    }

    return hr;
}

#define SZ_REGKEY_TYPEDCMDMRU       L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"
#define SZ_REGKEY_TYPEDURLMRU       L"Software\\Microsoft\\Internet Explorer\\TypedURLs"

HRESULT InitializeAndAddACLMRU(IObjMgr *pmulti, LPCWSTR pszRegKey)
{
    IUnknown *punk;

    HRESULT hr = CoCreateInstance(CLSID_ACLCustomMRU, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        IACLCustomMRU *pmru;
        
        hr = punk->QueryInterface(IID_PPV_ARG(IACLCustomMRU, &pmru));
        if (SUCCEEDED(hr))
        {
            hr = pmru->Initialize(pszRegKey, 26);
            if (SUCCEEDED(hr))
            {
                pmulti->Append(punk);
            }
            pmru->Release();
        }
        punk->Release();
    }

    return hr;
}

IUnknown * ACGetLists(DWORD dwFlags, DWORD dwACLOptions)
{
    IUnknown * punkACLMulti = NULL;
    HRESULT hr = CoCreateInstance(CLSID_ACLMulti, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punkACLMulti));

    AssertMsg((CO_E_NOTINITIALIZED != hr), TEXT("SHAutoComplete() can not use AutoComplete because OleInitialize() was never called."));
    if (SUCCEEDED(hr))
    {
        IObjMgr * pomMulti;

        hr = punkACLMulti->QueryInterface(IID_PPV_ARG(IObjMgr, &pomMulti));
        if (SUCCEEDED(hr))
        {
            if (dwFlags & SHACF_URLMRU)
            {
                // ADD The MRU List-- add both URL and run dialog MRU
                hr = InitializeAndAddACLMRU(pomMulti, SZ_REGKEY_TYPEDCMDMRU);
                if (SUCCEEDED(hr))
                    hr = InitializeAndAddACLMRU(pomMulti, SZ_REGKEY_TYPEDURLMRU);
            }

            if (dwFlags & SHACF_URLHISTORY)
            {
                // ADD The History List
                IUnknown * punkACLHist;
                hr = CoCreateInstance(CLSID_ACLHistory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punkACLHist));
                if (SUCCEEDED(hr))
                {
                    pomMulti->Append(punkACLHist);
                    IUnknown_SetOptions(punkACLHist, dwACLOptions);
                    punkACLHist->Release();
                }
            }

            if ((dwFlags & SHACF_FILESYSTEM) ||
                (dwFlags & SHACF_FILESYS_DIRS) ||
                (dwFlags & SHACF_FILESYS_ONLY))
            {
                // ADD The ISF List
                IUnknown * punkACLISF;
                hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punkACLISF));
                if (SUCCEEDED(hr))
                {
                    pomMulti->Append(punkACLISF);
                    IUnknown_SetOptions(punkACLISF, dwACLOptions);
                    punkACLISF->Release();
                }
            }

            pomMulti->Release();
        }
    }

    return punkACLMulti;
}


#define SZ_REGKEY_AUTOCOMPLETE_TAB          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_AUTOCOMPLETE_TAB        TEXT("Always Use Tab")
#define BOOL_NOT_SET                        0x00000005
DWORD _UpdateAutoCompleteFlags(DWORD dwFlags, DWORD * pdwACLOptions)
{
    DWORD dwACOptions = 0;

    *pdwACLOptions = 0;
    if (!(SHACF_AUTOAPPEND_FORCE_OFF & dwFlags) &&
        ((SHACF_AUTOAPPEND_FORCE_ON & dwFlags) ||
        SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE)))
    {
        dwACOptions |= ACO_AUTOAPPEND;
    }

    if (!(SHACF_AUTOSUGGEST_FORCE_OFF & dwFlags) &&
        ((SHACF_AUTOSUGGEST_FORCE_ON & dwFlags) ||
        SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE)))
    {
        dwACOptions |= ACO_AUTOSUGGEST;
    }

    if (SHACF_USETAB & dwFlags)
    {
        dwACOptions |= ACO_USETAB;
    }

    if (SHACF_FILESYS_DIRS & dwFlags)
    {
        *pdwACLOptions |= ACLO_FILESYSDIRS;
    }
    else if (SHACF_FILESYS_ONLY & dwFlags)
    {
        *pdwACLOptions |= ACLO_FILESYSONLY;
    }

    // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
    // operating systems that use AutoComplete have traditionally used the TAB key to
    // iterate thru the AutoComplete possibilities.  We need to default to disable the
    // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
    // turn it on 
    static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
    if (BOOL_NOT_SET == s_fAlwaysUseTab)
        s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_AUTOCOMPLETE_TAB, SZ_REGVALUE_AUTOCOMPLETE_TAB, FALSE, FALSE);
        
    if (s_fAlwaysUseTab)
        dwACOptions |= ACO_USETAB;

    return dwACOptions;
}


/****************************************************\
    FUNCTION: SHAutoComplete

    DESCRIPTION:
        This function will have AutoComplete take over
    an editbox to help autocomplete DOS paths.

    Caller needs to have called CoInitialize() or OleInitialize()
    and cannot call CoUninit/OleUninit until after
    WM_DESTROY on hwndEdit.
\****************************************************/
STDAPI SHAutoComplete(HWND hwndEdit, DWORD dwFlags)
{
    IUnknown * punkACL;
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwACLOptions = 0;
    DWORD dwACOptions = _UpdateAutoCompleteFlags(dwFlags, &dwACLOptions);

    if (SHACF_DEFAULT == dwFlags)
        dwFlags = (SHACF_FILESYSTEM | SHACF_URLALL);

    punkACL = ACGetLists(dwFlags, dwACLOptions);
    if (punkACL)    // May fail on low memory.
    {
        IAutoComplete2 * pac;

        // Create the AutoComplete Object
        hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAutoComplete2, &pac));
        if (SUCCEEDED(hr))
        {
            if (SHPinDllOfCLSID(&CLSID_ACListISF) &&
                SHPinDllOfCLSID(&CLSID_AutoComplete))
            {
                hr = pac->Init(hwndEdit, punkACL, NULL, NULL);
                pac->SetOptions(dwACOptions);
            }
            else
            {
                hr = E_FAIL;
            }
            pac->Release();
        }

        punkACL->Release();
    }

    return hr;
}



//***   IOleCommandTarget helpers {

#define ISPOW2(i)   (((i) & ~((i) - 1)) == (i))

//***   IsQSForward -- (how) should i forward an IOleCT::Exec/QS command?
// ENTRY/EXIT
//  nCmdID  the usual; plus special value -1 means just check pguidCmdGroup
//  hr      S_OK|n if recognized (see below); o.w. OLECMDERR_E_NOTSUPPORTED
//      S_OK|+1  down
//      S_OK|+2  broadcast down
//      S_OK|-1  up
//      S_OK|-2  broadcast up (unused?)
// NOTES
//  WARNING: we never touch anything but the 1st field of rgCmds, so
//  IsExecForward can (and does!) lie and pass us '(OLECMD *) &nCmdID'.
//
STDAPI IsQSForward(const GUID *pguidCmdGroup, int cCmds, OLECMD *pCmds)
{
    int octd = 0;

    ASSERT(OCTD_DOWN > 0 && OCTD_DOWNBROADCAST > OCTD_DOWN);
    ASSERT(ISPOW2(OCTD_DOWN) && ISPOW2(OCTD_DOWNBROADCAST));
    ASSERT(OCTD_UP < 0);
    if (pguidCmdGroup == NULL) 
    {
        for (; cCmds > 0; pCmds++, cCmds--) 
        {
            switch (pCmds->cmdID) 
            {
            case OLECMDID_STOP:
            case OLECMDID_REFRESH:
            case OLECMDID_ENABLE_INTERACTION:
                // down (broadcast)
                octd |= OCTD_DOWNBROADCAST;
                break;

            case OLECMDID_CUT:
            case OLECMDID_COPY:
            case OLECMDID_PASTE:
            case OLECMDID_SELECTALL:
                // down (singleton)
                octd |= OCTD_DOWN;
                break;

            default:
                octd |= +4;
                break;
            }
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        for (; cCmds > 0; pCmds++, cCmds--)
        {
            switch (pCmds->cmdID)
            {
                case  SBCMDID_FILEDELETE:
                case  SBCMDID_FILEPROPERTIES:
                case  SBCMDID_FILERENAME:
                case  SBCMDID_CREATESHORTCUT:
                    octd |= OCTD_DOWN;
                    break;
            }
        }
    }

#ifdef DEBUG
    // make sure only one bit set

    if (!ISPOW2(octd)) 
    {
        // e.g. if we have both down and broadcast guys, the caller
        // will have to be careful to have his IOleCT::QS forward them
        // separately and then merge them together.
        ASSERT(0);  // probably best for caller to do 2 separate calls
        TraceMsg(DM_WARNING, "ief: singleton/broadcast mixture");
    }
#endif
    if (octd == 0 || (octd & 4)) 
    {
        // octd&4: if anyone is bogus, make them all be, to flesh out
        // bugs where the caller is passing us a mixture we can't handle
        return OLECMDERR_E_NOTSUPPORTED;
    }

    // aka (S_OK|octd)
    return MAKE_HRESULT(ERROR_SUCCESS, FACILITY_NULL, octd);
}


//***   MayQSForward -- forward IOleCT::QS if appropriate
//
STDAPI MayQSForward(IUnknown *punk, int iUpDown, const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hrTmp;

    hrTmp = IsQSForward(pguidCmdGroup, cCmds, rgCmds);
    if (SUCCEEDED(hrTmp)) 
    {
        // we know how to forward
        if (HRESULT_CODE(hrTmp) > 0 && iUpDown > 0
          || HRESULT_CODE(hrTmp) < 0 && iUpDown < 0) 
        {
            // punk pts in the right direction for nCmdID
#if 0
            // it's caller's bug if they have more than 1 kid
            // can't ASSERT though because broadcast to only child is o.k.
            if (HRESULT_CODE(hrTmp) > 1)
                TraceMsg(DM_WARNING, "med: Exec broadcast to singleton");
#endif
            return IUnknown_QueryStatus(punk, pguidCmdGroup, cCmds, rgCmds,
                pcmdtext);
        }
    }
    return OLECMDERR_E_NOTSUPPORTED;
}


//***   MayExecForward -- forward IOleCT::Exec if appropriate
// NOTES
//  should iUpDown be an int or an HRESULT?
STDAPI MayExecForward(IUnknown *punk, int iUpDown, const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hrTmp;

    hrTmp = IsExecForward(pguidCmdGroup, nCmdID);
    if (SUCCEEDED(hrTmp)) 
    {
        // we know how to forward
        if (HRESULT_CODE(hrTmp) > 0 && iUpDown > 0
          || HRESULT_CODE(hrTmp) < 0 && iUpDown < 0) 
        {
            // punk pts in the right direction for nCmdID
#if 0
            // it's caller's bug if they have more than 1 kid
            // can't ASSERT though because broadcast to only child is o.k.
            if (HRESULT_CODE(hrTmp) > 1)
                TraceMsg(DM_WARNING, "md: Exec broadcast to singleton));
#endif
            return IUnknown_Exec(punk, pguidCmdGroup, nCmdID, nCmdexecopt,
                pvarargIn, pvarargOut);
        }
    }
    return OLECMDERR_E_NOTSUPPORTED;
}


STDAPI_(HMENU) SHLoadMenuPopup(HINSTANCE hinst, UINT id)
{
    HMENU hMenuSub = NULL;
    HMENU hMenu = LoadMenuWrapW(hinst, MAKEINTRESOURCEW(id));
    if (hMenu) 
    {
        hMenuSub = GetSubMenu(hMenu, 0);
        if (hMenuSub) 
        {
            RemoveMenu(hMenu, 0, MF_BYPOSITION);
        }
        DestroyMenuWrap(hMenu);
    }

    return hMenuSub;
}


//-----------------------------------------------------------------------------

typedef LRESULT (WINAPI *POSTORSENDMESSAGEPROC)(HWND, UINT, WPARAM, LPARAM);
struct propagatemsg
{
    HWND   hwndParent;
    int    iFlags;  // "int" for back compatibility; used to be "BOOL"
    UINT   uMsg;
    WPARAM wParam;
    LPARAM lParam;
    POSTORSENDMESSAGEPROC PostOrSendMessage;
};

BOOL CALLBACK PropagateCallback(HWND hwndChild, LPARAM lParam)
{
    struct propagatemsg *pmsg = (struct propagatemsg *)lParam;

    if ((pmsg->iFlags & SPM_ONELEVEL) && GetParent(hwndChild) != pmsg->hwndParent)
    {
        // Wrong parent; skip it
        return TRUE;
    }
    pmsg->PostOrSendMessage(hwndChild, pmsg->uMsg, pmsg->wParam, pmsg->lParam);

    return TRUE;
}

STDAPI_(void) SHPropagateMessage(HWND hwndParent, UINT uMsg, WPARAM wParam, LPARAM lParam, int iFlags)
{
    if (!hwndParent)
        return;

    struct propagatemsg msg;
    msg.hwndParent = hwndParent;
    msg.iFlags = iFlags;
    msg.uMsg = uMsg;
    msg.wParam = wParam;
    msg.lParam = lParam;
    if (iFlags & SPM_SEND)
    {
        msg.PostOrSendMessage = IsWindowUnicode(hwndParent) ?
                                    SendMessageW : SendMessageA;
    }
    else
    {
        msg.PostOrSendMessage = (POSTORSENDMESSAGEPROC)
                                (IsWindowUnicode(hwndParent) ?
                                    PostMessageW : PostMessageA);
    }

    EnumChildWindows(hwndParent, /*(WNDENUMPROC)*/PropagateCallback, (LPARAM)&msg);
}

LRESULT SHDefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (IsWindowUnicode(hwnd)) 
    {
        return DefWindowProcW(hwnd, uMsg, wParam, lParam);
    }
    else 
    {
        return DefWindowProcA(hwnd, uMsg, wParam, lParam);
    }
}

// Returns the submenu of the given menu and ID.  Returns NULL if there
// is no submenu
STDAPI_(HMENU) SHGetMenuFromID(HMENU hmMain, UINT uID)
{
    HMENU hmenuRet = NULL;
    if (!hmMain)
        return NULL;

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    if (GetMenuItemInfo(hmMain, uID, FALSE, &mii))
        hmenuRet = mii.hSubMenu;
    return hmenuRet;
}


STDAPI_(int) SHMenuIndexFromID(HMENU hm, UINT id)
{
    for (int index = GetMenuItemCount(hm)-1; index>=0; index--)
    {
        // We have to use GetMenuItemInfo and not the simpler GetMenuItemID
        // because GetMenuItemID does not support submenus (grr).
        MENUITEMINFO mii;
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID;
        mii.cch = 0;        // just in case

        if (GetMenuItemInfo(hm, (UINT)index, TRUE, &mii)
            && (mii.wID == id))
        {
           break;
        }
    }

    return(index);
}


STDAPI_(void) SHRemoveAllSubMenus(HMENU hmenu)
{
    int cItems = GetMenuItemCount(hmenu);
    int i;

    for (i=cItems-1; i>=0; i--)
    {
        if (GetSubMenu(hmenu, i))
            RemoveMenu(hmenu, i, MF_BYPOSITION);
    }
}


STDAPI_(void) SHEnableMenuItem(HMENU hmenu, UINT id, BOOL fEnable)
{
    EnableMenuItem(hmenu, id, fEnable ?
        (MF_BYCOMMAND | MF_ENABLED) : (MF_BYCOMMAND| MF_GRAYED));
}


STDAPI_(void) SHCheckMenuItem(HMENU hmenu, UINT id, BOOL fChecked)
{
    CheckMenuItem(hmenu, id,
                  fChecked ? (MF_BYCOMMAND | MF_CHECKED) : (MF_BYCOMMAND | MF_UNCHECKED));
}


//
//  IStream 'saner/simpler' Wrappers that dont use exactly the same params, and have simpler
//  output.  closer mirroring the way we use them.
//
// NOTES
//  'saner' means that it only returns SUCCEEDED when it reads everything
//  you asked for.  'simpler' means no 'pcbRead' param.
STDAPI IStream_Read(IStream *pstm, void *pv, ULONG cb)
{
    ASSERT(pstm);
    ULONG cbRead;
    HRESULT hr = pstm->Read(pv, cb, &cbRead);
    if (SUCCEEDED(hr) && cbRead != cb) 
    {
        hr = E_FAIL;
    }
    return hr;
}


STDAPI IStream_Write(IStream *pstm, LPCVOID pvIn, ULONG cbIn)
{
    ASSERT(pstm);
    DWORD cb;
    HRESULT hr = pstm->Write(pvIn, cbIn, &cb);
    if (SUCCEEDED(hr) && cbIn != cb)
        hr = E_FAIL;

    return hr;
}


STDAPI IStream_Reset(IStream *pstm)
{
    return pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
}

STDAPI IStream_Size(IStream *pstm, ULARGE_INTEGER *pui)
{
    ASSERT(pstm);
    ASSERT(pui);

    STATSTG st = {0};

    // WARNING: What if IStream::Stat is not implemented?
    // Win95/NT4/IE4's IStream had this problem.  Fixed
    // for NT5...
    //
    HRESULT hr = pstm->Stat(&st, STATFLAG_NONAME);
    if (SUCCEEDED(hr))
    {
        *pui = st.cbSize;
    }

    return hr;
}


STDAPI IStream_ReadPidl(IStream *pstm, LPITEMIDLIST *ppidlOut)
{
    *ppidlOut = NULL;

    DWORD cbPidl;
    HRESULT hr = IStream_Read(pstm, &cbPidl, sizeof(cbPidl));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)CoTaskMemAlloc(cbPidl);
        if (pidl)
        {
            if (SUCCEEDED(hr = IStream_Read(pstm, pidl, cbPidl)))
            {
                // Validate that what we have is a well-formed pidl
                LPITEMIDLIST pidlEnd = _ILSkip(pidl, cbPidl - sizeof(USHORT));
                LPITEMIDLIST pidlT = pidl;
                while (pidlT <= pidlEnd && pidlT->mkid.cb)
                {
                    pidlT = _ILNext(pidlT);
                }

                if (pidlT == pidlEnd && pidlT->mkid.cb == 0)
                {
                    *ppidlOut = pidl;
                    hr = S_OK;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
            }
            if (FAILED(hr))
            {
                // Cannot use ILFree because it might not be a valid pidl
                CoTaskMemFree(pidl);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

STDAPI IStream_WritePidl(IStream *pstm, LPCITEMIDLIST pidlWrite)
{
    HRESULT hr;
    
    ASSERT(pidlWrite);
    DWORD cbPidl = ILGetSize(pidlWrite);

    if (SUCCEEDED(hr = IStream_Write(pstm, &cbPidl, sizeof(cbPidl))) &&
        SUCCEEDED(hr = IStream_Write(pstm, pidlWrite, cbPidl)))
    {
        // woo-hoo, all written successfully
    }
    return hr;
}

STDAPI_(BOOL) SHRegisterClassA(const WNDCLASSA* pwc)
{
    WNDCLASSA wc;
    if (!GetClassInfoA(pwc->hInstance, pwc->lpszClassName, &wc)) 
    {
        return RegisterClassA(pwc);
    }
    return TRUE;
}

//
//  Warning!  This uses RegisterClassWrap, which means that if we
//  are an ANSI-only platform, your window class will be registered
//  as **ANSI**, not as UNICODE.  You window procedure needs to call
//  IsWindowUnicode() to determine how to interpret incoming string
//  parameters.
//
STDAPI_(BOOL) SHRegisterClassW(const WNDCLASSW* pwc)
{
    WNDCLASSW wc;
    if (!GetClassInfoWrapW(pwc->hInstance, pwc->lpszClassName, &wc)) 
    {
        return RegisterClassWrapW(pwc);
    }
    return TRUE;
}

//
//  SHUnregisterClasses unregisters an array of class names.
//
STDAPI_(void) SHUnregisterClassesA(HINSTANCE hinst, const LPCSTR *rgpszClasses, UINT cpsz)
{
    for (UINT i = 0; i < cpsz; i++) 
    {
        WNDCLASSA wc;
        if (GetClassInfoA(hinst, rgpszClasses[i], &wc)) 
        {
            UnregisterClassA(rgpszClasses[i], hinst);
        }
    }
}

STDAPI_(void) SHUnregisterClassesW(HINSTANCE hinst, const LPCWSTR *rgpszClasses, UINT cpsz)
{
    for (UINT i = 0; i < cpsz; i++) 
    {
        WNDCLASSW wc;
        if (GetClassInfoWrapW(hinst, rgpszClasses[i], &wc)) 
        {
            UnregisterClassWrapW(rgpszClasses[i], hinst);
        }
    }
}


//
// This structure is used by the UNICODE version of this function. So, the pointers point to
// wide characters strings.
typedef struct tagMBCINFOW {  // Used only between the routine and its DlgProc
    UINT    uType;
    LPCWSTR pwszText;
    LPCWSTR pwszTitle;
    LPCWSTR pwszRegPath;
    LPCWSTR pwszRegVal;
    
    DLGPROC pUserDlgProc;
    void * pUserData;
} MBCINFOW, *LPMBCINFOW;


void _MoveDlgItem(HDWP hdwp, HWND hDlg, int nItem, int x, int y)
{
    RECT rc;
    HWND hwnd = GetDlgItem(hDlg, nItem);

    GetClientRect(hwnd, &rc);
    MapWindowPoints(hwnd, hDlg, (LPPOINT) &rc, 2);

    DeferWindowPos(hdwp, hwnd, 0, rc.left + x, rc.top + y, 0, 0,
        SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);
}


void _AddIcon(HWND hDlg, LPRECT prcNextChild, UINT uType)
{
    HICON hic;

    switch (uType & MB_ICONMASK)
    {
    case MB_ICONHAND:
        hic = LoadIcon(NULL, IDI_ERROR);        // == IDI_HAND
        break;
    case MB_ICONQUESTION:
        hic = LoadIcon(NULL, IDI_QUESTION);
        break;
    case MB_ICONEXCLAMATION:
        hic = LoadIcon(NULL, IDI_WARNING);      // == IDI_EXCLAMATION
        break;
    case MB_ICONINFORMATION:
        hic = LoadIcon(NULL, IDI_INFORMATION);  // == IDI_ASTERISK
        break;
    default:
        hic = NULL;
        break;
    }
    if (hic)
    {
        prcNextChild->left += GetSystemMetrics(SM_CXICON) + 10;
        SendDlgItemMessage(hDlg, IDC_MBC_ICON, STM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) hic);
    }
}

void _RecalcWindowHeight(HWND hWnd, LPMBCINFOW lpmbci)
{
    HDC  hdc = GetDC(hWnd);
    RECT rc;
    HWND hwndText = GetDlgItem(hWnd,IDC_MBC_TEXT);
    HDWP hdwp;
    int  iHeightDelta, cx, cxIcon;
    HFONT hFontSave;

    hFontSave = (HFONT)SelectObject(hdc, GetWindowFont(hwndText));

    // Get the starting rect of the text area (for the width)
    GetClientRect(hwndText, &rc);
    MapWindowPoints(hwndText, hWnd, (LPPOINT) &rc, 2);

    // See if we need to add an icon, slide rc over if we do
    cxIcon = RECTWIDTH(rc);
    _AddIcon(hWnd, &rc, lpmbci->uType);
    cxIcon = RECTWIDTH(rc) - cxIcon;

    // Calc how high the static text area needs to be, given the above width
    iHeightDelta = RECTHEIGHT(rc);
    cx = RECTWIDTH(rc);
    //Note: We need to call the Wide version of DrawText here!
    DrawTextWrapW(hdc, lpmbci->pwszText, -1, &rc, DT_CALCRECT | DT_LEFT | DT_WORDBREAK);
    iHeightDelta = RECTHEIGHT(rc) - iHeightDelta;

    cx = RECTWIDTH(rc) - cx; // Should only change for really long words w/o spaces
    if (cx < 0)
        cx = 0;

    if (hFontSave)
        SelectObject(hdc, hFontSave);
    ReleaseDC(hWnd, hdc);

    hdwp = BeginDeferWindowPos(6);
    if (hdwp)
    {
        DeferWindowPos(hdwp, hwndText, 0, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_NOACTIVATE);

        _MoveDlgItem(hdwp, hWnd, IDC_MBC_CHECK, -cxIcon, iHeightDelta);
        _MoveDlgItem(hdwp, hWnd, IDCANCEL, cx, iHeightDelta);
        _MoveDlgItem(hdwp, hWnd, IDOK, cx, iHeightDelta);
        _MoveDlgItem(hdwp, hWnd, IDYES, cx, iHeightDelta);
        _MoveDlgItem(hdwp, hWnd, IDNO, cx, iHeightDelta);

        EndDeferWindowPos(hdwp);

        GetWindowRect(hWnd, &rc);
        SetWindowPos(hWnd, 0, rc.left - (cx/2), rc.top - (iHeightDelta/2), RECTWIDTH(rc)+cx, RECTHEIGHT(rc)+iHeightDelta, SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return;
}


void HideAndDisableWindow(HWND hwnd)
{
    ShowWindow(hwnd, SW_HIDE);
    EnableWindow(hwnd, FALSE);
}


//
// NOTE: This dialog proc is always UNICODE since both SHMessageBoxCheckA/W thunk to UNICODE and
//       use this procedure.
//
BOOL_PTR CALLBACK MessageBoxCheckDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        // we only handle the WM_INITDIALOG so that we can resize the dialog
        // approprately
        case WM_INITDIALOG:
        {
            LPMBCINFOW lpmbci = (LPMBCINFOW)lParam;
            HWND hwndYES = GetDlgItem(hDlg, IDYES);
            HWND hwndNO = GetDlgItem(hDlg, IDNO);
            HWND hwndCANCEL = GetDlgItem(hDlg, IDCANCEL);
            HWND hwndOK = GetDlgItem(hDlg, IDOK);

            _RecalcWindowHeight(hDlg, lpmbci);

            //Note: We need to call the Wide version of SetDlgItemText() here.
            SetDlgItemTextWrapW(hDlg,IDC_MBC_TEXT,lpmbci->pwszText);
            if (lpmbci->pwszTitle)
                SetWindowTextWrapW(hDlg,lpmbci->pwszTitle);
            if ((lpmbci->uType & MB_TYPEMASK) == MB_OKCANCEL)
            {
                SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
                HideAndDisableWindow(hwndYES);
                HideAndDisableWindow(hwndNO);
                SetFocus(hwndOK);
            }
            else if ((lpmbci->uType & MB_TYPEMASK) == MB_OK)
            {
                RECT rc;

                SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
                HideAndDisableWindow(hwndYES);
                HideAndDisableWindow(hwndNO);
                HideAndDisableWindow(hwndCANCEL);

                if (EVAL(GetClientRect(hwndCANCEL, &rc)))
                {
                    MapWindowPoints(hwndCANCEL, hDlg, (LPPOINT) &rc, 2);
                    EVAL(SetWindowPos(hwndOK, hDlg, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_SHOWWINDOW));
                }

                SetFocus(hwndOK);
            }
            else // MB_YESNO
            {
                SendMessage(hDlg, DM_SETDEFID, IDYES, 0);
                HideAndDisableWindow(hwndOK);
                HideAndDisableWindow(hwndCANCEL);
                SetFocus(hwndYES);
            }
            return (FALSE); // we set the focus, so return false
        }
    }
    
    // didnt handle this message
    return FALSE;
}


//
// NOTE: The MessageBoxCheckExDlgProc is both UNICODE and ANSI since it dosent really do any string
//       stuff. Our UNICODE/ANSI-ness is determined by our caller.
//
BOOL_PTR CALLBACK MessageBoxCheckExDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MBCINFOW* pmbci = NULL;
    HWND hwndCheckBox = GetDlgItem(hDlg, IDC_MESSAGEBOXCHECKEX);

    if (uMsg == WM_INITDIALOG)
    {
        pmbci = (MBCINFOW*)lParam;

        // we have to have this control or we're hopeless
        if (!hwndCheckBox)
        {
            AssertMsg(FALSE, "MessageBoxCheckEx dialog templates must have a control whos ID is IDC_MESSAGEBOXCHECKEX!!");
            EndDialog(hDlg, 0);
        }
        
        // we use the checkbox to hang our data off of, since the caller
        // might want to use hDlg to hang its data off of.
        SetWindowPtr(hwndCheckBox, GWLP_USERDATA, pmbci);
    }
    else
    {
        pmbci = (MBCINFOW*)GetWindowPtr(hwndCheckBox, GWLP_USERDATA);
    }

    // we get a few messages before we get the WM_INITDIALOG (such as WM_SETFONT)
    // and until we get the WM_INITDIALOG we dont have our pmbci pointer, we just
    // return false
    if (!pmbci)
        return FALSE;


    // now check to see if we have a user specified dlg proc
    if (pmbci->pUserDlgProc)
    {
        // for the messages below, we simply return what the "real" dialog proc
        // said since they do NOT return TRUE/FALSE (eg handled or not handled).
        if (uMsg == WM_CTLCOLORMSGBOX      ||
            uMsg == WM_CTLCOLOREDIT        ||
            uMsg == WM_CTLCOLORLISTBOX     ||
            uMsg == WM_CTLCOLORBTN         ||
            uMsg == WM_CTLCOLORDLG         ||
            uMsg == WM_CTLCOLORSCROLLBAR   ||
            uMsg == WM_CTLCOLORSTATIC      ||
            uMsg == WM_COMPAREITEM         ||
            uMsg == WM_VKEYTOITEM          ||
            uMsg == WM_CHARTOITEM          ||
            uMsg == WM_QUERYDRAGICON       ||
            uMsg == WM_INITDIALOG)
        {
            return pmbci->pUserDlgProc(hDlg, uMsg, wParam, (uMsg == WM_INITDIALOG) ? (LPARAM)(pmbci->pUserData) : lParam);
        }

        if ((pmbci->pUserDlgProc(hDlg, uMsg, wParam, lParam) != FALSE) &&
            (uMsg != WM_DESTROY))
        {
            // the "real" dialog proc handled it so we are done, except we always
            // need to handle the WM_DESTROY message so we can check the state of
            // the checkbox in order to set the registry key accordingly.
            return TRUE;
        }
    }

    switch (uMsg)
    {
        case WM_CLOSE:
            wParam = IDCANCEL;
            // fall through
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDYES:
                case IDCANCEL:
                case IDNO:
                    EndDialog(hDlg, (int) LOWORD(wParam));
                    break;
            }
            break;
        }

        case WM_DESTROY:
            if (IsDlgButtonChecked(hDlg, IDC_MESSAGEBOXCHECKEX) == BST_CHECKED)
            {
                // Note: we need to call the Wide version of this function,
                // since our pmbci is always UNICODE
                SHRegSetUSValueW(pmbci->pwszRegPath, pmbci->pwszRegVal, REG_SZ,
                                 L"no", sizeof(L"no"), SHREGSET_HKCU);
            }
            break;
    }
    return FALSE;
}


// MessageBoxCheckW puts up a simple dialog box, with a checkbox to control if the
// dialog is to be shown again (eg gives you "dont show me this dlg again" functionality).
//
// Call as you would MessageBox, but with three additional parameters:
// The value to return if they checked "never again", and the reg path and value
// to store whether it gets shown again.


// MessageBoxCheckEx allows the user to specify a template that will be used along with
// a dialog proc that will be called. The only must for the dialog template is that it has
// to have a checkbox control with ID IDC_MESSAGEBOXCHECKEX (this is the "dont show me this
// again" checkbox).
// 
// The default template looks something like the following:
//
//        DLG_MESSAGEBOXCHECK DIALOG DISCARDABLE  0, 0, 210, 55
//        STYLE DS_MODALFRAME | DS_NOIDLEMSG | DS_CENTER | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE
//        CAPTION "Error!"
//        FONT 8, "MS Shell Dlg"
//        BEGIN
//            ICON            0, IDC_MBC_ICON,5,5,18,20
//            LTEXT           "",IDC_MBC_TEXT,5,5,200,8
//            CONTROL         "&In the future, do not show me this dialog box",
//                             IDC_MESSAGEBOXCHECKEX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,5,20,155,10
//            PUSHBUTTON      "OK",IDOK,95,35,50,14
//            PUSHBUTTON      "Cancel",IDCANCEL,150,35,50,14
//        END

//
// This function is fully implemented in UNICODE and the ANSI version of this function is thunked
// to this UNICODE version.
//
STDAPI_(int) SHMessageBoxCheckW(HWND hwnd, LPCWSTR pwszText, LPCWSTR pwszTitle, UINT uType, int iDefault, LPCWSTR pwszRegVal)
{
    // -- browseui(unicode) uses this
    MBCINFOW mbci;

    // check first to see if the "dont show me this again" is set
    if (!SHRegGetBoolUSValueW(REGSTR_PATH_MESSAGEBOXCHECKW, pwszRegVal, FALSE, /*default:*/TRUE))
        return iDefault;

    ASSERT(((uType & MB_TYPEMASK) == MB_OKCANCEL) || 
           ((uType & MB_TYPEMASK) == MB_YESNO) ||
           ((uType & MB_TYPEMASK) == MB_OK));
    ASSERT(pwszText != NULL);

    mbci.pwszText = pwszText;
    mbci.pwszTitle = pwszTitle;
    mbci.pwszRegPath = REGSTR_PATH_MESSAGEBOXCHECKW;
    mbci.pwszRegVal = pwszRegVal;
    mbci.uType = uType;
    mbci.pUserData = (LPVOID) &mbci;
    mbci.pUserDlgProc = MessageBoxCheckDlgProc;

    // we use the MessageBoxCheckExDlgProc as the main dlg proc, and allow the MessageBoxCheckDlgProc
    // to be the "user" dlg proc

    ULONG_PTR ul;
    HANDLE h = XP_CreateAndActivateContext(&ul);


    int i = (int)DialogBoxParamWrapW(HINST_THISDLL, MAKEINTRESOURCEW(DLG_MESSAGEBOXCHECK),
                                    hwnd, MessageBoxCheckExDlgProc, (LPARAM)&mbci);

    XP_DeactivateAndDestroyContext(h, ul);

    return i;
}

//
//  This function simply thunks to the UNICODE version.
//
//
STDAPI_(int) SHMessageBoxCheckA(HWND hwnd, LPCSTR pszText, LPCSTR pszTitle, UINT uType, int iDefault, LPCSTR pszRegVal)
{
    LPWSTR  lpwszText = NULL, lpwszTitle = NULL;
    int     iTextBuffSize = 0, iTitleBuffSize = 0;
    WCHAR   wszRegVal[REGSTR_MAX_VALUE_LENGTH];

    // check first to see if the "dont show me this again" is set
    if (!SHRegGetBoolUSValueA(REGSTR_PATH_MESSAGEBOXCHECKA, pszRegVal, FALSE, /*default:*/TRUE))
        return iDefault;

    // Since there is no MAX possible size for these strings, we dynamically allocate them.
    // Convert the input params into UNICODE.
    if (!(lpwszText = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(iTextBuffSize = lstrlen(pszText)+1))))
        goto End_MsgBoxCheck;
    if (!(lpwszTitle = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(iTitleBuffSize = lstrlen(pszTitle)+1))))
        goto End_MsgBoxCheck;

    // Conver the Ansi strings into Unicode strings.
    SHAnsiToUnicode(pszText, lpwszText, iTextBuffSize);
    SHAnsiToUnicode(pszTitle, lpwszTitle, iTitleBuffSize);
    SHAnsiToUnicode(pszRegVal, wszRegVal, ARRAYSIZE(wszRegVal));

    // Call the UNICODE version of this function.
    iDefault = SHMessageBoxCheckW(hwnd, lpwszText, lpwszTitle, uType, iDefault, wszRegVal);

    // Clean up and return.
End_MsgBoxCheck:
    if (lpwszText)
        LocalFree((HANDLE)lpwszText);
    if (lpwszTitle)
        LocalFree((HANDLE)lpwszTitle);

    return iDefault;
}


//
// This function calls directly to the helper function
//
STDAPI_(int) SHMessageBoxCheckExW(HWND hwnd, HINSTANCE hinst, LPCWSTR pwszTemplateName, DLGPROC pDlgProc, void *pData,
                                  int iDefault, LPCWSTR pwszRegVal)
{
    MBCINFOW mbci = {0};

    // check first to see if the "dont show me this again" is set
    if (!SHRegGetBoolUSValueW(REGSTR_PATH_MESSAGEBOXCHECKW, pwszRegVal, FALSE, /*default:*/TRUE))
        return iDefault;

    mbci.pwszRegPath = REGSTR_PATH_MESSAGEBOXCHECKW;
    mbci.pwszRegVal = pwszRegVal;
    mbci.pUserDlgProc = pDlgProc;
    mbci.pUserData = pData;

    ULONG_PTR ul;
    HANDLE h = XP_CreateAndActivateContext(&ul);


    // call the UNICODE function, since the users dlg proc (if it exists) is UNICODE
    int i = (int)DialogBoxParamWrapW(hinst, pwszTemplateName, hwnd, MessageBoxCheckExDlgProc, (LPARAM)&mbci);

    XP_DeactivateAndDestroyContext(h, ul);


    return i;
}


//
// This function thunks the strings and calls the helper function
//
STDAPI_(int) SHMessageBoxCheckExA(HWND hwnd, HINSTANCE hinst, LPCSTR pszTemplateName, DLGPROC pDlgProc, void *pData, 
                                  int iDefault, LPCSTR pszRegVal)
{
    WCHAR   wszRegVal[REGSTR_MAX_VALUE_LENGTH];
    MBCINFOW mbci = {0};

    // check first to see if the "dont show me this again" is set
    if (!SHRegGetBoolUSValueA(REGSTR_PATH_MESSAGEBOXCHECKA, pszRegVal, FALSE, /*default:*/TRUE))
        return iDefault;

    // Conver the Ansi strings into Unicode strings.
    SHAnsiToUnicode(pszRegVal, wszRegVal, ARRAYSIZE(wszRegVal));

    mbci.pwszRegPath = REGSTR_PATH_MESSAGEBOXCHECKW; // the MBCINFOW is always UNICODE
    mbci.pwszRegVal = wszRegVal;
    mbci.pUserDlgProc = pDlgProc;
    mbci.pUserData = pData;

    ULONG_PTR ul;
    HANDLE h = XP_CreateAndActivateContext(&ul);


    // call the ANSI function since the users dlg proc (if it exists) is ANSI
    iDefault = (int)DialogBoxParamA(hinst, pszTemplateName, hwnd, MessageBoxCheckExDlgProc, (LPARAM)&mbci);

    XP_DeactivateAndDestroyContext(h, ul);

    return iDefault;
}

// "I'm sorry, Dave, I can't let you do that."

LWSTDAPI_(void) SHRestrictedMessageBox(HWND hwnd)
{
    ShellMessageBoxWrapW(MLGetHinst(),
                         hwnd, 
                         MAKEINTRESOURCEW(IDS_RESTRICTIONS), 
                         MAKEINTRESOURCEW(IDS_RESTRICTIONSTITLE), 
                         MB_OK | MB_ICONSTOP);
}

// in:
//      pdrop       thing to drop on
//      pdataobj    thing we are dropping
//      grfKeyState to force certain operations
//      ppt         [optional] point where the drop happens (screen coords)
//
// in/out
//      pdwEffect   [optional] effects allowed and returns what was performed.

STDAPI SHSimulateDrop(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                      const POINTL *ppt, DWORD *pdwEffect)
{
    POINTL pt;
    DWORD dwEffect;

    if (!ppt)
    {
        ppt = &pt;
        pt.x = 0;
        pt.y = 0;
    }

    if (!pdwEffect)
    {
        pdwEffect = &dwEffect;
        dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY;
    }

    DWORD dwEffectSave = *pdwEffect;    // drag enter returns the default effect

    HRESULT hr = pdrop->DragEnter(pdtobj, grfKeyState, *ppt, pdwEffect);
    if (*pdwEffect)
    {
        *pdwEffect = dwEffectSave;      // do Drop with the full set of bits
        hr = pdrop->Drop(pdtobj, grfKeyState, *ppt, pdwEffect);
    }
    else
    {
        pdrop->DragLeave();
        hr = S_FALSE;     // HACK? S_FALSE DragEnter said no
    }

    return hr;
}


STDAPI SHLoadFromPropertyBag(IUnknown* punk, IPropertyBag* ppg)
{
    IPersistPropertyBag* pppg;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IPersistPropertyBag, &pppg));
    if (SUCCEEDED(hr))
    {
        hr = pppg->Load(ppg, NULL);
        pppg->Release();
    }

    return hr;
}


//***   IUnknown_TranslateAcceleratorOCS -- do punk->IOCS::TranslateAccelerator
STDAPI IUnknown_TranslateAcceleratorOCS(IUnknown *punk, LPMSG lpMsg, DWORD grfMods)
{
    HRESULT hr = E_FAIL;

    if (punk) 
    {
        IOleControlSite *pocs;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs));
        if (SUCCEEDED(hr)) 
        {
            hr = pocs->TranslateAccelerator(lpMsg, grfMods);
            pocs->Release();
        }
    }

    return hr;
}


STDAPI IUnknown_OnFocusOCS(IUnknown *punk, BOOL fGotFocus)
{
    HRESULT hr = E_FAIL;

    if (punk) 
    {
        IOleControlSite *pocs;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs));
        if (SUCCEEDED(hr)) 
        {
            hr = pocs->OnFocus(fGotFocus);
            pocs->Release();
        }
    }

    return hr;
}


STDAPI IUnknown_HandleIRestrict(IUnknown * punk, const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult)
{
    *pdwRestrictionResult = RR_NOCHANGE;    // init to something reasonable in case of failure

    IRestrict * pr;
    HRESULT hr = IUnknown_QueryService(punk, SID_SRestrictionHandler, IID_PPV_ARG(IRestrict, &pr));
    if (SUCCEEDED(hr))
    {
        hr = pr->IsRestricted(pguidID, dwRestrictAction, pvarArgs, pdwRestrictionResult);
        pr->Release();
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: Get color resolution of the current display

*/
STDAPI_(UINT) SHGetCurColorRes(void)
{
    HDC hdc;
    UINT uColorRes;

    hdc = GetDC(NULL);
    uColorRes = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL, hdc);

    return uColorRes;
}

//
// If a folder returns QIF_DONTEXPANDFODLER from QueryInfo, the folder should
// not get expanded.  This is used by menu code to not expand channel folders.
//
STDAPI_(BOOL) SHIsExpandableFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    ASSERT(psf);
    ASSERT(pidl);

    BOOL fRet = TRUE;

    IQueryInfo* pqi;

    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_PPV_ARG_NULL(IQueryInfo, &pqi))))
    {
        ASSERT(pqi);

        DWORD dwFlags;

        if (SUCCEEDED(pqi->GetInfoFlags(&dwFlags)))
        {
            fRet = !(dwFlags & QIF_DONTEXPANDFOLDER);
        }

        pqi->Release();
    }

    return fRet;
}


STDAPI_(DWORD) SHWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwRet;
    DWORD dwEnd = GetTickCount() + dwTimeout;

    // We will attempt to wait up to dwTimeout for the thread to
    // terminate
    do 
    {
        dwRet = MsgWaitForMultipleObjects(1, &hThread, FALSE,
                dwTimeout, QS_SENDMESSAGE);

        if (dwRet == (WAIT_OBJECT_0 + 1))
        {
            // There must be a pending SendMessage from either the
            // thread we are killing or some other thread/process besides
            // this one.  Do a PeekMessage to process the pending
            // SendMessage and try waiting again
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            // Calculate if we have any more time left in the timeout to
            // wait on.
            if (dwTimeout != INFINITE)
            {
                dwTimeout = dwEnd - GetTickCount();
                if ((long)dwTimeout <= 0)
                {
                    // No more time left, fail with WAIT_TIMEOUT
                    dwRet = WAIT_TIMEOUT;
                }
            }
        }

        // dwRet == WAIT_OBJECT_0 || dwRet == WAIT_FAILED
        // The thread must have exited, so we are happy
        //
        // dwRet == WAIT_TIMEOUT
        // The thread is taking too long to finish, so just
        // return and let the caller kill it

    } while (dwRet == (WAIT_OBJECT_0 + 1));

    return(dwRet);
}

STDAPI SHWaitForCOMSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
    DWORD dwIndex;
    return CoWaitForMultipleHandles(0, dwTimeout, 1, &hThread, &dwIndex); // COWAIT_ALERTABLE?
}


STDAPI_(BOOL) SHVerbExistsNA(LPCSTR szExtension, LPCSTR pszVerb, LPSTR pszCommand, DWORD cchCommand)
{
/*
    This Private API was being exported only for usage in shdocvw\dochost.cpp. We 
    don't use this function any more. 
    I searched in srch in index1, and there was no users execpt us. Just to make sure that
    this assert is added so as to .to find out if there are any other users of this api which
    I might have missed.
        -KishoreP 5/4/2000
*/
    ASSERT(!"This Private API has been Removed");
    return FALSE;
}


STDAPI_(void) SHFillRectClr(HDC hdc, LPRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
    SetBkColor(hdc, clrSave);
}


//***   SearchMapInt -- map int->int
//
STDAPI_(int) SHSearchMapInt(const int *src, const int *dst, int cnt, int val)
{
    for (; cnt > 0; cnt--, src++, dst++) 
    {
        if (*src == val)
            return *dst;
    }
    return -1;
}


STDAPI_(void) IUnknown_Set(IUnknown ** ppunk, IUnknown * punk)
{
    ASSERT(ppunk);

    if (*ppunk != punk)
    {
        IUnknown_AtomicRelease((void **)ppunk);

        if (punk)
        {
            punk->AddRef();
            *ppunk = punk;
        }
    }
}



/*----------------------------------------------------------
  Purpose: Removes '&'s from a string, returning the character after
           the last '&'.  Double-ampersands are collapsed into a single
           ampersand.  (This is important so "&Help && Support" works.)

           If a string has multiple mnemonics ("&t&wo") USER is inconsistent.
           DrawText uses the last one, but the dialog manager uses the first
           one.  So we use whichever one is most convenient.
*/
STDAPI_(CHAR) SHStripMneumonicA(LPSTR pszMenu)
{
    ASSERT(pszMenu);
    CHAR cMneumonic = pszMenu[0]; // Default is first char

    // Early-out:  Many strings don't have ampersands at all
    LPSTR pszAmp = StrChrA(pszMenu, '&');
    if (pszAmp)
    {
        LPSTR pszCopy = pszAmp;
        while (*pszAmp)
        {
            // Protect against string that ends in '&' - don't read past the end!
            if (*pszAmp == L'&' && pszAmp[1])
            {
                // ++ is safe here because & is never a DBCS lead byte
                pszAmp++;                   // Don't copy the ampersand itself
                if (*pszAmp != L'&')        // && is not a mnemonic
                {
                    cMneumonic = *pszAmp;
                }
            }
            *pszCopy++ = *pszAmp++;

            // If I just copied a lead byte and there is a trail byte,
            // then copy the trail byte, too.
            if (IsDBCSLeadByte(pszCopy[-1]) && *pszAmp)
            {
                *pszCopy++ = *pszAmp++;
            }
        }
        *pszCopy = 0;
    }


    return cMneumonic;
}


/*----------------------------------------------------------
  Purpose: Removes '&'s from a string, returning the character after
           the last '&'.  Double-ampersands are collapsed into a single
           ampersand.  (This is important so "&Help && Support" works.)

           If a string has multiple mnemonics ("&t&wo") USER is inconsistent.
           DrawText uses the last one, but the dialog manager uses the first
           one.  So we use whichever one is most convenient.
*/
STDAPI_(WCHAR) SHStripMneumonicW(LPWSTR pszMenu)
{
    ASSERT(pszMenu);
    WCHAR cMneumonic = pszMenu[0]; // Default is first char

    // Early-out:  Many strings don't have ampersands at all
    LPWSTR pszAmp = StrChrW(pszMenu, L'&');
    if (pszAmp)
    {
        LPWSTR pszCopy = pszAmp - 1;

        //  FAREAST some localized builds have an mnemonic that looks like
        //    "Localized Text (&L)"  we should remove that, too
        if (pszAmp > pszMenu && *pszCopy == L'(')
        {
            if (pszAmp[2]  == L')')
            {
                cMneumonic = *pszAmp;
                // move amp so that we arent past the potential terminator
                pszAmp += 3;
                pszAmp = pszCopy;
            }
        }
        else
        {
            //  move it up so that we copy on top of amp
            pszCopy++;
        }
            
        while (*pszAmp)
        {
            // Protect against string that ends in '&' - don't read past the end!
            if (*pszAmp == L'&' && pszAmp[1])
            {
                pszAmp++;                   // Don't copy the ampersand itself
                if (*pszAmp != L'&')        // && is not a mnemonic
                {
                    cMneumonic = *pszAmp;
                }
            }
            *pszCopy++ = *pszAmp++;
        }
        *pszCopy = 0;
    }

    return cMneumonic;
}


// don't use IsChild.  that walks down all children.
// faster to walk up the parent chain

//***   IsChildOrSelf -- is hwnd either a child of or equal to hwndParent?
// NOTES
//  HasFocus      is IsChildOrSelf(hwnd, GetFocus())
//  IsWindowOwner is IsChildOrSelf(hwnd, hwndOwner)
//  n.b. hwnd==0 is special and yields FALSE.  this is presumbably what
//  one wants for both HasFocus and IsWindowOwner.
//
// NOTE: S_OK means TRUE, S_FALSE meanse FALSE
//
STDAPI SHIsChildOrSelf(HWND hwndParent, HWND hwnd)
{
    // SHDOCVW likes to pass hwndParent == NULL.  Oops.
    // SHDOCVW even likes to pass hwndParent == hwnd == NULL.  Double oops.
    if (hwndParent == NULL || hwnd == NULL) 
    {
        return S_FALSE;
    }

    // Old code here used to walk the GetParent chain which is bogus
    // because GetParent will return the Window Owner when there is
    // no parent window. Bug 63233 got bit by this -- a dialog box
    // has no parent but it's owned by the window at the top of
    // the hwndParent chain. Since GetParent returns the window owner
    // if there is no parent, we'd incorrectly think we should translate
    // this message. I switched this to calling IsChild directly. Note:
    // in asking around it appears that this function was written
    // because of the mistaken assumption that IsChild was implemented
    // in a perf-unfriendly way. [mikesh 15 Oct 97]
    //
    return ((hwndParent == hwnd) || IsChild(hwndParent, hwnd)) ? S_OK : S_FALSE;
}


STDAPI IContextMenu_Invoke(IContextMenu* pcm, HWND hwndOwner, LPCSTR pVerb, UINT fFlags)
{
    HRESULT hres = S_OK;

    if (pcm)
    {
        UINT idCmd = 0;
        DECLAREWAITCURSOR;
        SetWaitCursor();

        HMENU hmenu = NULL;
        CMINVOKECOMMANDINFO ici = {
            sizeof(CMINVOKECOMMANDINFO),
            0,
            hwndOwner,
            NULL,
            NULL, NULL,
            SW_NORMAL,
        };

        if (!IS_INTRESOURCE(pVerb)) 
        {
#ifdef UNICODE
            ici.lpVerbW = pVerb;
            ici.lpVerb = makeansi(pVerb);
            ici.fMask |= CMIC_MASK_UNICODE;
#else
            ici.lpVerb = pVerb;
#endif
        }
        else 
        {
            hmenu = CreatePopupMenu();
            if (hmenu)
            {
                fFlags |= CMF_DEFAULTONLY;

                pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, fFlags);

                idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
                if (-1 != idCmd)
                {
                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                }
            }
        }

        // need to reset it so that user won't blow off the app starting  cursor
        // also so that if we won't leave the wait cursor up when we're not waiting
        // (like in a prop sheet or something that has a message loop
        ResetWaitCursor();

        // can't just check verb because it could be 0 if idCmd == CMD_ID_FIRST
        if ((-1 != idCmd) || ici.lpVerb) 
        {
            if (!hwndOwner)
                ici.fMask |= CMIC_MASK_FLAG_NO_UI;

            pcm->InvokeCommand(&ici);
            hres = (HRESULT)1;
        }

        if (hmenu)
            DestroyMenu(hmenu);
    }

    return hres;
}


//
// SetDefaultDialogFont
//
// purpose: set font to the given control of the dialog
//          with platform's default character set so that
//          user can see whatever string in the native
//          language on the platform.
//
// in:      hDlg - the parent window handle of the given control
//          idCtl - ID of the control
//
// note:    this will store created font with window property
//          so that we can destroy it later.
//
const TCHAR c_szPropDlgFont[]       = TEXT("PropDlgFont");

STDAPI_(void) SHSetDefaultDialogFont(HWND hDlg, int idCtl)
{
    HFONT hfont;
    HFONT hfontDefault;
    LOGFONT lf;
    LOGFONT lfDefault;

    hfont = GetWindowFont(hDlg);
    GetObject(hfont, sizeof(LOGFONT), &lf);

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lfDefault, 0);
    
    if (lfDefault.lfCharSet == lf.lfCharSet)
    {
        // if the dialog already has correct character set
        // don't do anything.
        return;
    }

    // If we already have hfont created, use it.
    if (!(hfontDefault = (HFONT)GetProp(hDlg, c_szPropDlgFont)))
    {
        // assign the same height of the dialog font
        lfDefault.lfHeight = lf.lfHeight;
        if (!(hfontDefault=CreateFontIndirect(&lfDefault)))
        {
            // restore back in failure
            hfontDefault = hfont;
        }
        if (hfontDefault != hfont)
            SetProp(hDlg, c_szPropDlgFont, hfontDefault);
    }
    

    SetWindowFont(GetDlgItem(hDlg, idCtl), hfontDefault, FALSE);
}


//
// RemoveDefaultDialogFont
//
// purpose: Destroy the font we used to set gui default font
//          Also removes the window property used to store the font.
//
// in:      hDlg - the parent window handle of the given control
//
// note:
STDAPI_(void) SHRemoveDefaultDialogFont(HWND hDlg)
{
    HFONT hfont;
    if (hfont = (HFONT)GetProp(hDlg, c_szPropDlgFont))
    {
        DeleteObject(hfont);
        RemoveProp(hDlg, c_szPropDlgFont);
    }
}

// NOTE: since this is a worker window it probably doesn't care about
// system messages that are ansi/unicode, so only support an ansi version.
// If the pfnWndProc cares, it can thunk the messages. (Do this because
// Win95 doesn't support RegisterClassW.)
HWND SHCreateWorkerWindowA(WNDPROC pfnWndProc, HWND hwndParent, DWORD dwExStyle, DWORD dwFlags, HMENU hmenu, void * p)
{
    WNDCLASSA wc = {0};

    wc.lpfnWndProc      = DefWindowProcA;
    wc.cbWndExtra       = sizeof(void *);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_BTNFACE + 1);
    wc.lpszClassName    = "WorkerA";
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    SHRegisterClassA(&wc);

    HWND hwnd = CreateWindowExA(dwExStyle, "WorkerA", NULL, dwFlags,
                                  0, 0, 0, 0, hwndParent,
                                  (HMENU)hmenu, HINST_THISDLL, NULL);
    if (hwnd) 
    {
        SetWindowPtr(hwnd, 0, p);

        if (pfnWndProc)
            SetWindowPtr(hwnd, GWLP_WNDPROC, pfnWndProc);
    }

    return hwnd;
}

// WARNING: since this is a worker window it probably doesn't care about
// system messages that are ansi/unicode, default to an ansi version on Win95.
//
// this forces callers to be aware of the fact that they are getting into
// a mess if they want compatibility with Win95.
//
// If the pfnWndProc cares, it can thunk the messages. (Do this because
// Win95 doesn't support RegisterClassW.)
//

HWND SHCreateWorkerWindowW(WNDPROC pfnWndProc, HWND hwndParent, DWORD dwExStyle, DWORD dwFlags, HMENU hmenu, void * p)
{
    //  must default to ANSI on win95
    if (!g_bRunningOnNT)
    {
        return SHCreateWorkerWindowA(pfnWndProc, hwndParent, dwExStyle, dwFlags, hmenu, p);
    }

    WNDCLASSW wc = {0};

    wc.lpfnWndProc      = DefWindowProcW;
    wc.cbWndExtra       = sizeof(void *);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_BTNFACE + 1);
    wc.lpszClassName    = L"WorkerW";
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    SHRegisterClassW(&wc);

    HWND hwnd = CreateWindowExW(dwExStyle, L"WorkerW", NULL, dwFlags,
                                  0, 0, 0, 0, hwndParent,
                                  (HMENU)hmenu, HINST_THISDLL, NULL);
    if (hwnd) 
    {
        SetWindowPtr(hwnd, 0, p);

        // Note: Must explicitly use W version to avoid charset thunks
        if (pfnWndProc)
            SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR)pfnWndProc);

    }

    return hwnd;
}

#pragma warning(disable:4035)   // no return value

#undef SHInterlockedCompareExchange
STDAPI_(void *) SHInterlockedCompareExchange(void **ppDest, void *pExch, void *pComp)
{
#if defined(_X86_)
    _asm {
        mov     ecx,ppDest
        mov     edx,pExch
        mov     eax,pComp
        lock    cmpxchg [ecx],edx
    }
#else
    return InterlockedCompareExchangePointer(ppDest, pExch, pComp);
#endif
}

#pragma warning(default:4035)

#define REGSTR_PATH_POLICIESW    L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies"

STDAPI_(DWORD) SHRestrictionLookup(INT rest, LPCWSTR pszBaseKey, const SHRESTRICTIONITEMS *pRestrictions,
                                   DWORD* pdwRestrictionItemValues)
{
    int i;
    DWORD dw = 0;

    //
    // Loop through the restrictions
    //
    for (i=0; pRestrictions[i].pszKey; i++)
    {
        if (rest == pRestrictions[i].iFlag)
        {
            dw = pdwRestrictionItemValues[i];

            // Has this restriction been initialized yet?
            //
            if (dw == -1)
            {
                dw = SHGetRestriction(pszBaseKey, pRestrictions[i].pszKey, pRestrictions[i].pszValue);
                pdwRestrictionItemValues[i] = dw;
            }

            // Got the restriction we needed. Get out of here.
            break;
        }
    }

    return dw;

}

STDAPI_(DWORD) SHGetRestriction(LPCWSTR pszBaseKey, LPCWSTR pszGroup, LPCWSTR pszRestriction)
{
    // Make sure the string is long enough to hold longest one...
    COMPILETIME_ASSERT(MAX_PATH > ARRAYSIZE(REGSTR_PATH_POLICIESW) + 40); // PathCombine *assumes* MAX_PATH
    WCHAR szSubKey[MAX_PATH];
    DWORD dwSize;

    // A sensible default
    DWORD dw = 0;

    //
    // This restriction hasn't been read yet.
    //
    if (!pszBaseKey) 
    {
        pszBaseKey = REGSTR_PATH_POLICIESW;
    }
#ifndef UNIX
    PathCombineW(szSubKey, pszBaseKey, pszGroup);
#else
    wsprintfW(szSubKey, L"%s\\%s", pszBaseKey, pszGroup);
#endif

    // Check local machine first and let it override what the
    // HKCU policy has done.
    dwSize = sizeof(dw);
    if (ERROR_SUCCESS != SHGetValueW(HKEY_LOCAL_MACHINE,
                                     szSubKey, pszRestriction,
                                     NULL, &dw, &dwSize))
    {
        // Check current user if we didn't find anything for the local machine.
        dwSize = sizeof(dw);
        SHGetValueW(HKEY_CURRENT_USER,
                    szSubKey, pszRestriction,
                    NULL, &dw, &dwSize);
    }

    return dw;
}


//  WhichPlatform
//      Determine if we're running on integrated shell or browser-only.

STDAPI_(UINT) WhichPlatform(void)
{
    HINSTANCE hinst;

    // Cache this info
    static UINT uInstall = PLATFORM_UNKNOWN;

    if (uInstall != PLATFORM_UNKNOWN)
        return uInstall;

    // Not all callers are linked to SHELL32.DLL, so we must use LoadLibrary.
    hinst = LoadLibraryA("SHELL32.DLL");
    if (hinst)
    {
        DWORD fValue;
        DWORD cbSize = sizeof(fValue);
        HKEY hKey;
        LONG lRes;

        // NOTE: GetProcAddress always takes ANSI strings!
        DLLGETVERSIONPROC pfnGetVersion =
            (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");

        uInstall = (NULL != pfnGetVersion) ? PLATFORM_INTEGRATED : PLATFORM_BROWSERONLY;

        // check that the registry reflects the right value... (this is so iexplore can check efficiently)
        lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer"),
                            0, KEY_READ | KEY_WRITE, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
            lRes = RegQueryValueEx(hKey, REGVAL_INTEGRATEDBROWSER,
                                    NULL, NULL,
                                    (LPBYTE) &fValue, &cbSize);

            if (lRes == ERROR_SUCCESS && uInstall == PLATFORM_BROWSERONLY)
            {
                // remove the value, we are now Browser only release
                RegDeleteValue(hKey, REGVAL_INTEGRATEDBROWSER);
            }
            else if (lRes != ERROR_SUCCESS && uInstall == PLATFORM_INTEGRATED)
            {
                // install the RegValue, we are integrated browser mode...
                fValue = TRUE;
                cbSize = sizeof(fValue);
                RegSetValueEx(hKey, REGVAL_INTEGRATEDBROWSER,
                               (DWORD) NULL, REG_DWORD,
                               (LPBYTE) &fValue, cbSize);
                // ignore the failure, if the key is not present, shdocvw will be loaded and this
                // function called anyway....
            }
            RegCloseKey(hKey);
        }
        else
        {
            // a machine without our regKey,
            TraceMsg(TF_WARNING, "WhichPlatform: failed to open 'HKLM\\Software\\Microsoft\\Internet Explorer'");
        }

        FreeLibrary(hinst);
    }

    return uInstall;
}


// Tray notification window class

CHAR const c_szTrayNotificationClass[] = WNDCLASS_TRAYNOTIFY;

BOOL DoRegisterGlobalHotkey(WORD wOldHotkey, WORD wNewHotkey,
                            LPCSTR pcszPath, LPCWSTR pcwszPath)
{
    BOOL bResult;
    HWND hwndTray;
    CHAR szPath[MAX_PATH];

    ASSERT((NULL != pcszPath) || (NULL != pcwszPath));

    hwndTray = FindWindowA(c_szTrayNotificationClass, 0);

    if (hwndTray)
    {
        if (wOldHotkey)
        {
            SendMessage(hwndTray, WMTRAY_SCUNREGISTERHOTKEY, wOldHotkey, 0);

            TraceMsg(TF_FUNC, "RegisterGlobalHotkey(): Unregistered old hotkey %#04x.", wOldHotkey);
        }

        if (wNewHotkey)
        {
            //  If not running on NT and we have a widestr, need to convert to ansi
            if ((!g_bRunningOnNT) && (NULL == pcszPath))
            {
                SHUnicodeToAnsi(pcwszPath, szPath, ARRAYSIZE(szPath));
                pcszPath = szPath;
            }

            // Aargh: The W95/browser only mode sends a string, other platforms sends
            // Atom...
            if (!g_bRunningOnNT && (WhichPlatform() == PLATFORM_IE3))
            {
                SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wNewHotkey, (LPARAM)pcszPath);
            }
            else
            {
                ATOM atom = (NULL != pcszPath) ?
                                GlobalAddAtomA(pcszPath) :
                                GlobalAddAtomW(pcwszPath);
                ASSERT(atom);
                if (atom)
                {
                    SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wNewHotkey, (LPARAM)atom);
                    GlobalDeleteAtom(atom);
                }
            }

            TraceMsg(TF_FUNC, "RegisterGlobalHotkey(): Registered new hotkey %#04x.",wNewHotkey);
        }

        bResult = TRUE;
    }
    else
    {
        bResult = FALSE;

        TraceMsgA(TF_WARNING, "RegisterGlobalHotkey(): Unable to find Tray window of class %s to notify.",
                  c_szTrayNotificationClass);
    }

    return(bResult);
}


BOOL
RegisterGlobalHotkeyW(
    WORD wOldHotkey,
    WORD wNewHotkey,
    LPCWSTR pcwszPath)
{
    ASSERT(IsValidPathW(pcwszPath));

    return DoRegisterGlobalHotkey(wOldHotkey, wNewHotkey, NULL, pcwszPath);
}


BOOL
RegisterGlobalHotkeyA(
    WORD wOldHotkey,
    WORD wNewHotkey,
    LPCSTR pcszPath)
{
    ASSERT(IsValidPathA(pcszPath));

    return DoRegisterGlobalHotkey(wOldHotkey, wNewHotkey, pcszPath, NULL);
}

typedef UINT (__stdcall * PFNGETSYSTEMWINDOWSDIRECTORYW)(LPWSTR pwszBuffer, UINT cchBuff);

UINT WINAPI
SHGetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
{
    if (g_bRunningOnNT)
    {
        static PFNGETSYSTEMWINDOWSDIRECTORYW s_pfn = (PFNGETSYSTEMWINDOWSDIRECTORYW)-1;

        if (((PFNGETSYSTEMWINDOWSDIRECTORYW)-1) == s_pfn)
        {
            HINSTANCE hinst = GetModuleHandle(TEXT("KERNEL32.DLL"));

            ASSERT(NULL != hinst);  //  YIKES!

            if (hinst)
                s_pfn = (PFNGETSYSTEMWINDOWSDIRECTORYW)GetProcAddress(hinst, "GetSystemWindowsDirectoryW");
            else
                s_pfn = NULL;
        }

        if (s_pfn)
        {
            // we use the new API so we dont get lied to by hydra
            return s_pfn(lpBuffer, uSize);
        }
        else
        {
            GetSystemDirectoryW(lpBuffer, uSize);
            PathRemoveFileSpecW(lpBuffer);
            return lstrlenW(lpBuffer);
        }
    }
    else
    {
        return GetWindowsDirectoryWrapW(lpBuffer, uSize);
    }
}

UINT WINAPI
SHGetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
{
    if (g_bRunningOnNT)
    {
        WCHAR wszPath[MAX_PATH];

        SHGetSystemWindowsDirectoryW(wszPath, ARRAYSIZE(wszPath));
        return SHUnicodeToAnsi(wszPath, lpBuffer, uSize);
    }
    else
    {
        if (lpBuffer && uSize)
            *lpBuffer = '\0';

        return GetWindowsDirectoryA(lpBuffer, uSize);
    }
}



typedef struct {
    SHDLGPROC pfnDlgProc;
    VOID* pData;
} SHDIALOGDATA;
BOOL_PTR DialogBoxProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SHDIALOGDATA* pdd = (SHDIALOGDATA*)GetWindowPtr(hwnd, DWLP_USER);

    if (uMsg == WM_INITDIALOG) 
    {
        pdd = (SHDIALOGDATA*)lParam;
        SetWindowPtr(hwnd, DWLP_USER, pdd);
        lParam = (LPARAM)pdd->pData;
    }

    if (pdd && pdd->pfnDlgProc) 
    {
        // Must return bResult instead of unconditional TRUE because it
        // might be a WM_CTLCOLOR message.
        BOOL_PTR bResult = pdd->pfnDlgProc(pdd->pData, hwnd, uMsg, wParam, lParam);
        if (bResult)
            return bResult;
    }

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
    {
        int id = GET_WM_COMMAND_ID(wParam, lParam);
        HWND hwndCtrl = GetDlgItem(hwnd, id);
        if ((id != IDHELP) && SendMessage(hwndCtrl, WM_GETDLGCODE, 0, 0) & (DLGC_DEFPUSHBUTTON | DLGC_UNDEFPUSHBUTTON)) 
        {
            EndDialog(hwnd, id);
            return TRUE;
        }
        break;
    }
    }

    return FALSE;
}

STDAPI_(INT_PTR) SHDialogBox(HINSTANCE hInstance, LPCWSTR lpTemplateName,
    HWND hwndParent, SHDLGPROC lpDlgFunc, VOID* lpData)
{
    SHDIALOGDATA dd;
    dd.pfnDlgProc = lpDlgFunc;
    dd.pData = lpData;

    // we currently only support resource id #'s
    ASSERT(IS_INTRESOURCE(lpTemplateName));

    return DialogBoxParam(hInstance, (LPCTSTR)lpTemplateName, hwndParent, DialogBoxProc, (LPARAM)&dd);
}


//---------------------------------------------------------------------------

// NOTE!  SHInvokeDefaultCommand logs the action as user-initiated!

STDAPI SHInvokeDefaultCommand(HWND hwnd, IShellFolder* psf, LPCITEMIDLIST pidlItem)
{
    return SHInvokeCommand(hwnd, psf, pidlItem, NULL);
}

// NOTE!  SHInvokeDefaultCommand logs the action as user-initiated!

STDAPI SHInvokeCommand(HWND hwnd, IShellFolder* psf, LPCITEMIDLIST pidlItem, LPCSTR lpVerb)
{
    HRESULT hr = E_FAIL;
    if (psf)
    {
        IContextMenu *pcm;
        if (SUCCEEDED(psf->GetUIObjectOf(hwnd, 1, &pidlItem, IID_X_PPV_ARG(IContextMenu, 0, &pcm))))
        {
            DWORD dwFlags = IsOS(OS_WHISTLERORGREATER) ? CMIC_MASK_FLAG_LOG_USAGE : 0;
            hr = SHInvokeCommandsOnContextMenu(hwnd, NULL, pcm, dwFlags, lpVerb ? &lpVerb : NULL, lpVerb ? 1 : 0);
            pcm->Release();
        }
    }
    return hr;
}

HRESULT SHInvokeCommandOnContextMenu(HWND hwnd, IUnknown* punk, IContextMenu *pcm, DWORD fMask, LPCSTR lpVerb)
{
    return SHInvokeCommandsOnContextMenu(hwnd, punk, pcm, fMask, lpVerb ? &lpVerb : NULL, lpVerb ? 1 : 0);
}

STDAPI SHInvokeCommandsOnContextMenu(HWND hwnd, IUnknown* punk, IContextMenu *pcm, DWORD fMask, const LPCSTR rgszVerbs[], UINT cVerbs)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (pcm)
    {
        HMENU hmenu = CreatePopupMenu();
        if (hmenu)
        {
            if (punk)
                IUnknown_SetSite(pcm, punk);

            hr = pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, cVerbs ? 0 : CMF_DEFAULTONLY);
            if (SUCCEEDED(hr)) 
            {
                LPCSTR lpVerb = NULL;

                // set up the default verb case outside the loop
                UINT idCmd = -1;
                if (0 == cVerbs)
                {
                    idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
                    if ((UINT)-1 != idCmd)
                        lpVerb = MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                }
                
                UINT i = 0;
                do {
                    if (cVerbs)
                        lpVerb = rgszVerbs[i];

                    // if idCmd == 0, then lpVerb would be Zero. So we need to check to
                    // see if idCmd is not -1.
                    if (lpVerb || idCmd != (UINT)-1)
                    {
                        CMINVOKECOMMANDINFOEX ici = { 0 };

                        ici.cbSize = sizeof(ici);
                        ici.fMask = fMask;
                        ici.hwnd = hwnd;
                        ici.lpVerb = lpVerb;
                        ici.nShow = SW_NORMAL;

                        // shell32 converted ASCII canonical name to Unicode, we do it faster in-line
                        // NOTE: should create an SHAsciiToUnicode function for this...
                        WCHAR szVerbW[128];
                        if (idCmd == (UINT)-1)
                        {
                            WCHAR wch = L'\0';
                            LPCSTR pSrc = lpVerb;
                            LPWSTR pDst = szVerbW;
                            UINT cch = ARRAYSIZE(szVerbW);
                            do {
                                *(LPSTR)&wch = *pSrc++;
                                *pDst++ = wch;
                            } while (wch && (wch <= (WCHAR)127));

                            // all of our calls are ASCII
                            RIPMSG(!wch, "Caller of SHInvokeCommandXXX passed in bogus canonical name");
                            if (!wch)
                            {
                                ici.lpVerbW = szVerbW;
                                ici.fMask |= CMIC_MASK_UNICODE;
                            }
                        }

                        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);

                        if (SUCCEEDED(hr))
                            break;

                        if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED) )
                            break;  // user aborted
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                } while (++i < cVerbs);
            }

            if (punk)
                IUnknown_SetSite(pcm, NULL);

            DestroyMenu(hmenu);
        }
    }

    return hr;
}

HRESULT SHForwardContextMenuMsg(IContextMenu* pcm, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL fAllowICM2)
{
    HRESULT hr = E_FAIL;
    if (pcm)
    {
        IContextMenu3 *pcm3;
        if (SUCCEEDED(pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &pcm3))))
        {
            hr = pcm3->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
            pcm3->Release();
        }
        else if (fAllowICM2)
        {
            IContextMenu2 *pcm2;
            if (SUCCEEDED(pcm->QueryInterface(IID_PPV_ARG(IContextMenu2, &pcm2))))
            {
                hr = pcm2->HandleMenuMsg(uMsg, wParam, lParam);
                pcm2->Release();

                if (plResult)
                    *plResult = 0;

                if (SUCCEEDED(hr))
                    hr = S_FALSE; // so caller knows the return result is bogus
            }
        }
    }
    return hr;
}


int MessageBoxHelper(HINSTANCE hInst, HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzMessage, UINT idTitle, UINT nFlags)
{
    WCHAR wzTitle[MAX_PATH];
    UINT uiResult;

    ULONG_PTR ul;
    HANDLE h = XP_CreateAndActivateContext(&ul);

    EVAL(LoadStringWrapW(hInst, idTitle, wzTitle, ARRAYSIZE(wzTitle)));

    if (hwnd)
        IUnknown_EnableModless(punkEnableModless, TRUE);

    uiResult = MessageBoxWrapW(hwnd, pwzMessage, wzTitle, nFlags);

    if (hwnd)
        IUnknown_EnableModless(punkEnableModless, TRUE);

    XP_DeactivateAndDestroyContext(h, ul);

    return uiResult;
}


int MessageBoxDiskHelper(HINSTANCE hInst, HWND hwnd, IUnknown *punkEnableModless, UINT idMessage, UINT idTitle, UINT nFlags, BOOL fDrive, DWORD dwDrive)
{
    WCHAR wzMessage[MAX_PATH];

    EVAL(LoadStringWrapW(hInst, idMessage, wzMessage, ARRAYSIZE(wzMessage)));

    if (fDrive)
    {
        WCHAR wzTemp[MAX_PATH];

        wnsprintfW(wzTemp, ARRAYSIZE(wzTemp), wzMessage, dwDrive);
        StrCpyNW(wzMessage, wzTemp, ARRAYSIZE(wzMessage));
    }

    return MessageBoxHelper(hInst, hwnd, punkEnableModless, wzMessage, idTitle, nFlags);
}

BOOL DoMediaPrompt(HWND hwnd, IUnknown *punkEnableModless, int nDrive, LPCWSTR pwzDrive, BOOL fOfferToFormat, DWORD dwError, UINT wFunc, BOOL * pfRetry)
{
    BOOL fDiskHasMedia = TRUE;  // Assume yes
    *pfRetry = FALSE;

    TraceMsg(TF_FUNC, "DOS Extended error %X", dwError);

    // FEATURE, flash (ROM?) drives return a different error code here
    // that we need to map to not formatted, talk to robwi...

    // Is it true that it's not ready or we can't format it?
    if ((dwError == ERROR_NOT_READY) || !fOfferToFormat)
    {
        // Yes, so do the disk insert w/o offering to format.
        fDiskHasMedia = FALSE;

        // drive not ready (no disk in the drive)
        if (hwnd &&
            (IDRETRY == MessageBoxDiskHelper(HINST_THISDLL,
                                             hwnd,
                                             punkEnableModless,
                                             IDS_DRIVENOTREADY,
                                             (IDS_FILEERROR + wFunc),
                                             (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_RETRYCANCEL),
                                             TRUE,
                                             (DWORD)(nDrive + TEXT('A')))))
        {
            *pfRetry = TRUE;    // The user wants to try again, bless their heart.
        }
        else
        {
            // The user was informed that media isn't present and they basically
            // informed us to cancel the operation.
            *pfRetry = FALSE;
        }
    }
    else if ((dwError == ERROR_GEN_FAILURE)         ||
             (dwError == ERROR_UNRECOGNIZED_MEDIA)  ||
             (dwError == ERROR_UNRECOGNIZED_VOLUME))
    {
        // general failue (disk not formatted)

        if (hwnd &&
            (MessageBoxDiskHelper(HINST_THISDLL,
                                  hwnd,
                                  punkEnableModless,
                                  IDS_UNFORMATTED,
                                  (IDS_FILEERROR + wFunc),
                                  (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_YESNO),
                                  TRUE,
                                  (DWORD)(nDrive + TEXT('A'))) == IDYES))
        {
            if (hwnd)
            {
                IUnknown_EnableModless(punkEnableModless, FALSE);
            }

            UINT uiFormat = SHFormatDrive(hwnd, nDrive, SHFMT_ID_DEFAULT, 0);
            if (hwnd)
            {
                IUnknown_EnableModless(punkEnableModless, TRUE);
            }

            switch (uiFormat)
            {
            case SHFMT_CANCEL:
                *pfRetry = FALSE;
                fDiskHasMedia = FALSE;
                break;

            case SHFMT_ERROR:
            case SHFMT_NOFORMAT:
                fDiskHasMedia = FALSE;  // We still don't have a formatted drive
                if (hwnd)
                {
                    MessageBoxDiskHelper(HINST_THISDLL,
                                         hwnd,
                                         punkEnableModless,
                                         IDS_NOFMT,
                                         (IDS_FILEERROR + wFunc), 
                                         (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK),
                                         TRUE,
                                         (DWORD)(nDrive + TEXT('A')));
                    *pfRetry = TRUE;
                }
                else
                {
                    // If we can't display UI, no need to try again.
                    *pfRetry = FALSE;
                }
                break;

            default:
                // Disk should now be formatted, verify
                *pfRetry = TRUE;
                fDiskHasMedia = TRUE;
                break;
            }
        }
        else
        {
            *pfRetry = FALSE;   // If we can't display UI, or no need to try again.
            fDiskHasMedia = FALSE;  // The user either wasn't given the option of formatting or decided not to format.
        }
    }
    else
    {
        if (hwnd)
        {
            MessageBoxDiskHelper(HINST_THISDLL, hwnd, punkEnableModless, IDS_NOSUCHDRIVE, (IDS_FILEERROR + wFunc),
                        (MB_SETFOREGROUND | MB_ICONHAND), TRUE, (DWORD)(nDrive + TEXT('A')));
            *pfRetry = FALSE;
            fDiskHasMedia = FALSE;
        }
        else
        {
            *pfRetry = FALSE;
            fDiskHasMedia = FALSE;
        }
    }

    return fDiskHasMedia;
}


BOOL CheckDiskForMedia(HWND hwnd, IUnknown *punkEnableModless, int nDrive, LPCWSTR pwzDrive, UINT wFunc, BOOL * pfRetry)
{
    BOOL fDiskHasMedia = TRUE;  // Assume yes because of the fall thru case. (Path Exists)

    *pfRetry = FALSE;   // If we fall thru and the destination path exists, don't retry.

    // REARCHITECT, we need to do the find first here instead of GetCurrentDirectory()
    // because redirected devices (network, cdrom) do not actually hit the disk
    // on the GetCurrentDirectory() call (dos busted)

    // Is it a CD-ROM Drive?
    if (RealDriveType(nDrive, FALSE) == DRIVE_CDROM)
    {
        // Is the CD not in and the caller wants UI?
        if (!PathFileExistsW(pwzDrive) && hwnd)
            fDiskHasMedia = DoMediaPrompt(hwnd, punkEnableModless, nDrive, pwzDrive, wFunc, FALSE, GetLastError(), pfRetry);
    }
    else
    {
        int iIsNet;

        // Is this some kind of net drive?
        if ((DriveType(nDrive) != DRIVE_FIXED) && (FALSE != (iIsNet = IsNetDrive(nDrive))))
        {
            // Yes, so see if the connection still exists.
            if (iIsNet == 1)
            {
                // Yes, it exists so we are done.
                *pfRetry = FALSE;
                fDiskHasMedia = TRUE;
            }
            else
            {
                // No, so try to restore the connection.
                DWORD dwError = WNetRestoreConnectionWrapW(hwnd, pwzDrive);

                if (dwError != WN_SUCCESS)
                {
                    // Restoring the connection failed, so prepare to tell the 
                    // caller the bad news and then display UI to the user if appropriate.
                    *pfRetry = FALSE;
                    fDiskHasMedia = TRUE;

                    if (!(dwError == WN_CANCEL || dwError == ERROR_CONTINUE) && hwnd)
                    {
                        WCHAR wzMessage[128];

                        WNetGetLastErrorWrapW(&dwError, wzMessage, ARRAYSIZE(wzMessage), NULL, 0);
                        IUnknown_EnableModless(punkEnableModless, FALSE);   // Cover me, I'm going to do UI
                        MessageBoxHelper(HINST_THISDLL, hwnd, punkEnableModless, wzMessage, (IDS_FILEERROR + wFunc),
                                        (MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND));
                        IUnknown_EnableModless(punkEnableModless, TRUE);
                    }
                }
                else
                {
                    // Restoring the connection worked.
                    *pfRetry = FALSE;
                    fDiskHasMedia = TRUE;
                }
            }
        }
        else
        {
            // No, so see if it's a floppy or unformatted drive.

            // Is the destination reachable?
            if (!PathFileExistsW(pwzDrive))
            {
                // No so ask the user about formatting or inserting the media.
                fDiskHasMedia = DoMediaPrompt(hwnd, punkEnableModless, nDrive, pwzDrive, TRUE, GetLastError(), wFunc, pfRetry);
            }
            else
            {
                ASSERT(FALSE == *pfRetry);      // Make sure the defaults are still true.
                ASSERT(TRUE == fDiskHasMedia);
            }
        }
    }

    return fDiskHasMedia;
}


// FUNCTION: SHCheckDiskForMedia
//
// DESCRIPTION:
// note: this has the side effect of setting the
// current drive to the new disk if it is successful
//
// The default impl being ansi isn't very good, but we need to 
// see if the unicode versions of the WNet APIs are impl on Win95.
//
// PARAMETERS:
// hwnd - NULL means no UI will be displayed.  Non-NULL means
// punkEnableModless - Make caller modal during UI. (OPTIONAL)
// pszPath - Path that needs verification.
// wFunc - Type of operation (FO_MOVE, FO_COPY, FO_DELETE, FO_RENAME - shellapi.h)
//
// Keep the return value a strict TRUE/FALSE because some callers rely on it.
BOOL SHCheckDiskForMediaW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, UINT wFunc)
{
    BOOL fDiskHasMedia = FALSE;  // Assume yes
    int nDrive = PathGetDriveNumberW(pwzPath);

    ASSERT(nDrive != -1);       // should not get a UNC here

    if (nDrive != -1)   // not supported on UNCs
    {
        WCHAR wzDrive[10];
        PathBuildRootW(wzDrive, nDrive);
        BOOL fKeepRetrying;

        do
        {
            fDiskHasMedia = CheckDiskForMedia(hwnd, punkEnableModless, nDrive, wzDrive, wFunc, &fKeepRetrying);          
        }
        while (fKeepRetrying);
    }
    return fDiskHasMedia;
}

BOOL SHCheckDiskForMediaA(HWND hwnd, IUnknown *punkEnableModless, LPCSTR pszPath, UINT wFunc)
{
    WCHAR wzPath[MAX_PATH];

    SHAnsiToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
    return SHCheckDiskForMediaW(hwnd, punkEnableModless, wzPath, wFunc);
}

HRESULT _FaultInIEFeature(HWND hwnd, uCLSSPEC *pclsspec, QUERYCONTEXT *pQ, DWORD dwFlags);

struct HELPCONT_FILE 
{
    const   CHAR *pszFile;
    int     nLength;
} g_helpConts[] =
{
{ "iexplore.chm", ARRAYSIZE("iexplore.chm") - 1 },
{ "iexplore.hlp", ARRAYSIZE("iexplore.hlp") - 1 },
{ "update.chm", ARRAYSIZE("update.chm") - 1 },
{ "update.cnt", ARRAYSIZE("update.cnt") - 1 },
{ "users.chm", ARRAYSIZE("users.chm") - 1 },
{ "users.hlp", ARRAYSIZE("users.hlp") - 1 },
{ "accessib.chm", ARRAYSIZE("accessib.chm") - 1 },
{ "ieeula.chm", ARRAYSIZE("ieeula.chm") - 1 },
{ "iesupp.chm", ARRAYSIZE("iesupp.chm") - 1 },
{ "msnauth.hlp", ARRAYSIZE("msnauth.hlp") - 1 },
{ "ratings.chm", ARRAYSIZE("ratings.chm") - 1 },
{ "ratings.hlp", ARRAYSIZE("ratings.hlp") - 1 }
};

HRESULT _JITHelpFileA(HWND hwnd, LPCSTR pszPath)
{
    if (!pszPath)
        return S_OK;

    HRESULT hr = S_OK;
    BOOL bMustJIT = FALSE;
    CHAR *pszFile = PathFindFileName(pszPath);
  
    for (int i = 0; i < ARRAYSIZE(g_helpConts); i++)
    {
        if (StrCmpNIA(g_helpConts[i].pszFile, pszFile, g_helpConts[i].nLength) == 0)
        {
            bMustJIT = TRUE;
            break;
        }
    }

    if (bMustJIT)
    {
        uCLSSPEC ucs;
        QUERYCONTEXT qc = { 0 };
        
        ucs.tyspec = TYSPEC_CLSID;
        ucs.tagged_union.clsid = CLSID_IEHelp;

        hr = _FaultInIEFeature(hwnd, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);
    }

    return hr;
}

HRESULT _JITHelpFileW(HWND hwnd, LPCWSTR pwszFile)
{
    if (!pwszFile)
        return S_OK;

    CHAR szFile[MAX_PATH];

    SHUnicodeToAnsi(pwszFile, szFile, ARRAYSIZE(szFile));

    return _JITHelpFileA(hwnd, szFile);
}

BOOL _JITSetLastError(HRESULT hr)
{
    DWORD err;
    
    if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
    {
        err = HRESULT_CODE(hr);
    }
    else if (hr == E_ACCESSDENIED)
    {
        err = ERROR_ACCESS_DENIED;
    }
    else
    {
        err = ERROR_FILE_NOT_FOUND;
    }

    SetLastError(err);

    return FALSE;
}

HWND SHHtmlHelpOnDemandW(HWND hwnd, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage, BOOL bUseML)
{
    return SUCCEEDED(_JITHelpFileW(hwnd, pszFile)) ?
                (bUseML ? MLHtmlHelpW(hwnd, pszFile, uCommand, dwData, dwCrossCodePage) : 
                          HtmlHelpW(hwnd, pszFile, uCommand, dwData)) :
                NULL;
}

HWND SHHtmlHelpOnDemandA(HWND hwnd, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage, BOOL bUseML)
{
    return SUCCEEDED(_JITHelpFileA(hwnd, pszFile)) ?
                (bUseML ? MLHtmlHelpA(hwnd, pszFile, uCommand, dwData, dwCrossCodePage) : 
                          HtmlHelpA(hwnd, pszFile, uCommand, dwData)) :
                NULL;
}

BOOL SHWinHelpOnDemandW(HWND hwnd, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, BOOL bUseML)
{
    HRESULT hr;
    return SUCCEEDED(hr = _JITHelpFileW(hwnd, pszFile)) ?
                (bUseML ? MLWinHelpW(hwnd, pszFile, uCommand, dwData) : 
                          WinHelpWrapW(hwnd,pszFile, uCommand, dwData)) :
                _JITSetLastError(hr);
}

BOOL SHWinHelpOnDemandA(HWND hwnd, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, BOOL bUseML)
{
    HRESULT hr;
    return SUCCEEDED(hr = _JITHelpFileA(hwnd, pszFile)) ?
                (bUseML ? MLWinHelpA(hwnd, pszFile, uCommand, dwData) : 
                          WinHelpA(hwnd,pszFile, uCommand, dwData)) :
                _JITSetLastError(hr);
}



/*****************************************************************************\
    FUNCTION: SHPersistDataObject

    DESCRIPTION:
        This funciton exists for IDataObjects that don't want OLE to use the
    default IDataObject implementation if OleFlushClipboard is called.
    How to use:
    1. This function should be called when the IDataObject::GetData() method
       is called with (FORMATETC.cfFormat ==
       RegisterClipboardFormat(CFSTR_PERSISTEDDATAOBJECT)).
    2. OleFlushClipboard copies pMedium to it's own implementation of IDataObject
       which doesn't work with the lindex parameter of FORMATETC or for private interfaces.
    3. OLE or the IDropTarget calls SHLoadPersistedDataObject().  The first
       param will be OLE's IDataObject impl, and the second param (out param)
       will be the original IDataObject.  The new IDataObject will contains
       the original state as long as it correctly implemented IPersistStream.

    PARAMETERS:
        pdoToPersist - This is the original IDataObject that implements IPersistStream.
        pMedium - This is contain the persisted state of this object.
                  CFSTR_PERSISTEDDATAOBJECT can be used to read the data.
\*****************************************************************************/
#define SIZE_PERSISTDATAOBJECT  (10 * 1024)

STDAPI SHPersistDataObject(/*IN*/ IDataObject * pdoToPersist, /*OUT*/ STGMEDIUM * pMedium)
{
    HRESULT hr = E_NOTIMPL;

    // We shipped IE 5.0 RTM with this and SHLoadPersistedDataObject().  We removed
    // the code after the OLE32.DLL guys moved the functionality into ole32.dll.
    // See the "OleClipboardPersistOnFlush" clipboard format.
    return hr;
}


/*****************************************************************************\
    FUNCTION: SHLoadPersistedDataObject

    DESCRIPTION:
        This funciton exists for IDataObjects that don't want OLE to use the
    default IDataObject implementation if OleFlushClipboard is called.
    How to use:
    1. SHPersistDataObject() was called when the IDataObject::GetData() method
       is called with (FORMATETC.cfFormat == RegisterClipboardFormat(CFSTR_PERSISTEDDATAOBJECT)).
    2. OleFlushClipboard copies pMedium to it's own implementation of IDataObject
       which doesn't work with the lindex parameter of FORMATETC or for private interfaces.
    3. OLE or the IDropTarget calls SHLoadPersistedDataObject().  The first
       param will be OLE's IDataObject impl, and the second param (out param)
       will be the original IDataObject.  The new IDataObject will contains
       the original state as long as it correctly implemented IPersistStream.

    PARAMETERS:
        pdo - This is OLE's IDataObject.
        ppdoToPersist - This is the original IDataObject or equal to pdo if
                        un-serializing the object didn't work.  It always has
                        it's own ref.
\*****************************************************************************/
STDAPI SHLoadPersistedDataObject(/*IN*/ IDataObject * pdo, /*OUT*/ IDataObject ** ppdoToPersist)
{
    // See SHPersistDataObject() for details
    return pdo->QueryInterface(IID_PPV_ARG(IDataObject, ppdoToPersist));
}

#ifndef SMTO_NOTIMEOUTIFNOTHUNG
#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008
#endif

LWSTDAPI_(LRESULT) SHSendMessageBroadcastA(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ULONG_PTR lres = 0;
    DWORD dwFlags = SMTO_ABORTIFHUNG;

    if (g_bRunningOnNT5OrHigher)
        dwFlags |= SMTO_NOTIMEOUTIFNOTHUNG;

    SendMessageTimeoutA(HWND_BROADCAST, uMsg, wParam, lParam, dwFlags, 30 * 1000, &lres);

    return (LRESULT) lres;
}

LWSTDAPI_(LRESULT) SHSendMessageBroadcastW(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ULONG_PTR lres = 0;
    DWORD dwFlags = SMTO_ABORTIFHUNG;

    if (g_bRunningOnNT5OrHigher)
        dwFlags |= SMTO_NOTIMEOUTIFNOTHUNG;

    SendMessageTimeoutWrapW(HWND_BROADCAST, uMsg, wParam, lParam, dwFlags, 30 * 1000, &lres);

    return (LRESULT) lres;
}

#ifdef UNIX
/*****************************************************************************\
    IEUNIX : Wrapper to get rid of undefined symbol on UNIX.
\*****************************************************************************/
STDAPI_(BOOL) SHCreateThreadPriv(
    LPTHREAD_START_ROUTINE pfnThreadProc,
    void *pvData,
    DWORD dwFlags,                          // CTF_*
    LPTHREAD_START_ROUTINE pfnCallback)     OPTIONAL
{
    return SHCreateThread(pfnThreadProc, pvData, dwFlags, pfnCallback);
}
#endif

#define MODULE_NAME_SIZE    128
#define MODULE_VERSION_SIZE  15

//
//  If version is NULL, then we do it for all versions of the app.
//
//  If version begins with MAJORVERSION, then we check only the major version.
//  (CH_MAJORVERSION is the char version of same.)
//
#define MAJORVERSION TEXT("\1")
#define CH_MAJORVERSION TEXT('\1')

typedef struct tagAPPCOMPAT
{
    LPCTSTR pszModule;
    LPCTSTR pszVersion;
    DWORD  dwFlags;
} APPCOMPAT, *LPAPPCOMPAT;

typedef struct tagAPPCLASS
{
    LPCTSTR pstzWndClass;
    DWORD   dwFlags;
} APPCLASS, *LPAPPCLASS;

typedef struct tagWNDDAT
{
    const APPCLASS *rgAppClass;
    DWORD      cAppClass;
    DWORD      dwPid;
    int        irgFound;
} WNDDAT, *LPWNDDAT;


BOOL CALLBACK EnumWnd (HWND hwnd, LPARAM lParam)
{
    TCHAR sz[256];
    DWORD dwPid;
    int cch;
    LPWNDDAT pwd = (LPWNDDAT) lParam;

    if (GetClassName (hwnd, sz, ARRAYSIZE(sz)))
    {
        cch = lstrlen (sz);
        for (DWORD irg = 0; irg < pwd->cAppClass; irg++)
        {
            ASSERT(lstrlen(&(pwd->rgAppClass[irg].pstzWndClass[1])) == (int) pwd->rgAppClass[irg].pstzWndClass[0]);
            if (lstrncmp (sz, &(pwd->rgAppClass[irg].pstzWndClass[1]),
                 min(cch, (int) pwd->rgAppClass[irg].pstzWndClass[0])) == 0)
            {
                GetWindowThreadProcessId(hwnd, &dwPid);
                if (dwPid == pwd->dwPid)
                {
                    pwd->irgFound = irg;
                    return FALSE;
                }
            }
        }
    }
    return TRUE;
}

BOOL _IsAppCompatVersion(LPTSTR szModulePath, LPCTSTR pszVersionMatch)
{
    if (pszVersionMatch == NULL)            // Wildcard - match all versions
    {
        return TRUE;
    }
    else
    {
        CHAR  chBuffer[4096]; // hopefully this is enough... Star Office 5 requires 3172
        TCHAR* pszVersion = NULL;
        UINT  cb;
        DWORD  dwHandle;

        // get module version here!
        //
        //  Some apps use codepage 0x04E4 (1252 = CP_USASCII) and some use
        //  codepage 0x04B0 (1200 = CP_UNICODE).
        //
        // ...and then Star Office 5.00 uses 0407 instead of 0409.
        // ...and then recycle.exe uses 041D Swedish

        cb = GetFileVersionInfoSize(szModulePath, &dwHandle);
        if (cb <= ARRAYSIZE(chBuffer) &&
            GetFileVersionInfo(szModulePath, dwHandle, ARRAYSIZE(chBuffer), (void *)chBuffer) &&
            (VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\040904E4\\ProductVersion"), (void **) &pszVersion, &cb) ||
             VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\040704E4\\ProductVersion"), (void **) &pszVersion, &cb) ||
             VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\040904B0\\ProductVersion"), (void **) &pszVersion, &cb) ||
             //The following 040900000 was added for SnapShot.exe
             VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\04090000\\ProductVersion"), (void **) &pszVersion, &cb) ||
             VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\041D04B0\\ProductVersion"), (void **) &pszVersion, &cb)))
        {
            DWORD_PTR cchCmp = 0;
            if (pszVersionMatch[0] == CH_MAJORVERSION)
            {
                // Truncate at the first comma or period
                LPTSTR pszTemp = StrChr(pszVersion, TEXT(','));
                if (pszTemp)
                    *pszTemp = 0;

                pszTemp = StrChr(pszVersion, TEXT('.'));
                if (pszTemp)
                    *pszTemp = 0;

                pszVersionMatch++;
            }
            else
            {
                TCHAR *pch = StrChr(pszVersionMatch, TEXT('*'));
                if (pch)
                {
                    cchCmp = pch - pszVersionMatch;
                }
            }

            if ((cchCmp && StrCmpNI(pszVersion, pszVersionMatch, (int)cchCmp) == 0)
            || lstrcmpi(pszVersion, pszVersionMatch) == 0)
            {
                DebugMsg(TF_ALWAYS, TEXT("%s ver %s - compatibility hacks enabled"), PathFindFileName(szModulePath), pszVersion);
                return TRUE;
            }
        }
    }
    return FALSE;
}

typedef struct {
    DWORD flag;
    LPCTSTR psz;
} FLAGMAP;

DWORD _GetMappedFlags(HKEY hk, const FLAGMAP *pmaps, DWORD cmaps)
{
    DWORD dwRet = 0;
    for (DWORD i = 0; i < cmaps; i++)
    {
        if (NOERROR == SHGetValue(hk, NULL, pmaps[i].psz, NULL, NULL, NULL))
            dwRet |= pmaps[i].flag;
    }

    return dwRet;
}

#define ACFMAPPING(acf)     {ACF_##acf, TEXT(#acf)}

DWORD _GetRegistryCompatFlags(LPTSTR pszModulePath)
{
    DWORD dwRet = 0;
    LPCTSTR pszModule = PathFindFileName(pszModulePath);
    TCHAR sz[MAX_PATH];
    HKEY hkApp;

    wnsprintf(sz, ARRAYSIZE(sz), TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Applications\\%s"), pszModule);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkApp))
    {
        // Convert the module path into a directory so we can PathCombine it
        TCHAR szDir[MAX_PATH];
        lstrcpyn(szDir, pszModulePath, ARRAYSIZE(szDir));
        PathRemoveFileSpec(szDir);


        //
        //  HEADSUP!  Strange loop ahead!
        //
        //  We want the first RegOpenKeyEx to pass sz = NULL (so we look
        //  inside hkApp directly), and subsequent RegOpenKeyEx calls to
        //  pass the name of a subkey (so we look inside the subkeys).
        //
        //  So the first time through the loop, we set sz = NULL.
        //  At the bottom of the loop, we set sz = Next Enumerated Key.

        sz[0] = TEXT('\0');     /* Preinitialize for first iteration */
        DWORD dwIndex = 0;

        do {
            HKEY hkSub;
            if (ERROR_SUCCESS == RegOpenKeyEx(hkApp, sz, 0, KEY_QUERY_VALUE, &hkSub))
            {
                LPCTSTR pszValue;
                DWORD dw = sizeof(sz);

                if (NOERROR == SHGetValue(hkSub, NULL, TEXT("RequiredFile"), NULL, sz, &dw))
                {
                    pszValue = PathCombine(sz, szDir, sz);
                }
                else
                    pszValue = NULL;

                // If no RequiredFile or RequiredFile exists...
                if (pszValue == NULL || GetFileAttributes(pszValue) != 0xFFFFFFFF)
                {
                    if (NOERROR == SHGetValue(hkSub, NULL, TEXT("Version"), NULL, sz, &dw))
                        pszValue = sz;
                    else
                        pszValue = NULL;

                    if (_IsAppCompatVersion(pszModulePath, pszValue))
                    {
                        static const FLAGMAP rgAcfMaps[] = {
                            ACFMAPPING(CONTEXTMENU),
                            ACFMAPPING(CORELINTERNETENUM),
                            ACFMAPPING(OLDCREATEVIEWWND),
                            ACFMAPPING(WIN95DEFVIEW),
                            ACFMAPPING(DOCOBJECT),
                            ACFMAPPING(FLUSHNOWAITALWAYS),
                            ACFMAPPING(MYCOMPUTERFIRST),
                            ACFMAPPING(OLDREGITEMGDN),
                            ACFMAPPING(LOADCOLUMNHANDLER),
                            ACFMAPPING(ANSI),
                            ACFMAPPING(STAROFFICE5PRINTER),
                            ACFMAPPING(NOVALIDATEFSIDS),
                            ACFMAPPING(WIN95SHLEXEC),
                            ACFMAPPING(FILEOPENNEEDSEXT),
                            ACFMAPPING(WIN95BINDTOOBJECT),
                            ACFMAPPING(IGNOREENUMRESET),
                            ACFMAPPING(ANSIDISPLAYNAMES),
                            ACFMAPPING(FILEOPENBOGUSCTRLID),
                            ACFMAPPING(FORCELFNIDLIST),
                        };

                        dwRet |= _GetMappedFlags(hkSub, rgAcfMaps, ARRAYSIZE(rgAcfMaps));
                    }
                }

                RegCloseKey(hkSub);
            }
        } while (ERROR_SUCCESS == RegEnumKey(hkApp, dwIndex++, sz, ARRAYSIZE(sz)));

        RegCloseKey(hkApp);
    }

    return dwRet;
}
        
DWORD SHGetAppCompatFlags (DWORD dwFlagsNeeded)
{
    static BOOL  bInitialized = FALSE;
    static DWORD dwCachedProcessFlags = 0;
    static const APPCOMPAT aAppCompat[] = 
    {
        {TEXT("WPWIN7.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM},
        {TEXT("PRWIN70.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM},
        {TEXT("PS80.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("QPW.EXE"), MAJORVERSION TEXT("7"), ACF_CONTEXTMENU},
        {TEXT("QFINDER.EXE"), NULL, ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("PFIM80.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("UA80.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("PDXWIN32.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("SITEBUILDER.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("HOTDOG4.EXE"), NULL, ACF_DOCOBJECT},
        {TEXT("RNAAPP.EXE"), NULL, ACF_FLUSHNOWAITALWAYS},

        //
        //  PDEXPLO.EXE version "2, 0, 2, 0" requires ACF_CONTEXTMENU | ACF_MYCOMPUTERFIRST
        //  PDEXPLO.EXE version "1, 0, 0, 0" requires ACF_CONTEXTMENU | ACF_MYCOMPUTERFIRST
        //  PDEXPLO.EXE version "3, 0, 0, 1" requires                   ACF_MYCOMPUTERFIRST
        //  PDEXPLO.EXE version "3, 0, 3, 0" requires                   ACF_MYCOMPUTERFIRST
        //
        //  So I'm just going to key off the major versions.
        //
        {TEXT("PDEXPLO.EXE"), MAJORVERSION TEXT("2"), ACF_CONTEXTMENU | ACF_MYCOMPUTERFIRST},
        {TEXT("PDEXPLO.EXE"), MAJORVERSION TEXT("1"), ACF_CONTEXTMENU | ACF_MYCOMPUTERFIRST},
        {TEXT("PDEXPLO.EXE"), MAJORVERSION TEXT("3"), ACF_MYCOMPUTERFIRST | ACF_OLDREGITEMGDN},

        // SIZEMGR.EXE is part of the PowerDesk 98 suite, so we also key off
        // only the major version
        {TEXT("SIZEMGR.EXE"), MAJORVERSION TEXT("3"), ACF_OLDCREATEVIEWWND | ACF_OLDREGITEMGDN},

        {TEXT("SMARTCTR.EXE"), TEXT("96.0"), ACF_CONTEXTMENU},
        // new programs, old bugs
        {TEXT("WPWIN8.EXE"), NULL, ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("PRWIN8.EXE"), NULL, ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},

        {TEXT("UE32.EXE"), TEXT("2.00.0.0"), ACF_OLDREGITEMGDN},
        {TEXT("PP70.EXE"),NULL, ACF_LOADCOLUMNHANDLER},
        {TEXT("PP80.EXE"),NULL, ACF_LOADCOLUMNHANDLER},
        {TEXT("PS80.EXE"),NULL, ACF_OLDREGITEMGDN},
        {TEXT("ABCMM.EXE"),NULL,ACF_LOADCOLUMNHANDLER},

        // We've found versions 8.0.0.153 and 8.0.0.227, so just use 8.*
        {TEXT("QPW.EXE"), MAJORVERSION TEXT("8"), ACF_CORELINTERNETENUM | ACF_OLDCREATEVIEWWND | ACF_OLDREGITEMGDN | ACF_ANSIDISPLAYNAMES },

        {TEXT("CORELDRW.EXE"), MAJORVERSION TEXT("7"), ACF_OLDREGITEMGDN},
        {TEXT("FILLER51.EXE"), NULL, ACF_OLDREGITEMGDN},
        
        //For Win95 and Win98
        {TEXT("AUTORUN.EXE"), TEXT("4.10.1998"),ACF_ANSI},
        {TEXT("AUTORUN.EXE"), TEXT("4.00.950"),ACF_ANSI},

        //Powerpoint
        {TEXT("POWERPNT.EXE"), MAJORVERSION TEXT("8"), ACF_WIN95SHLEXEC},

        //  msmoney
        {TEXT("MSMONEY.EXE"), TEXT("7.05.1107"), ACF_WIN95SHLEXEC},
        
        //Star Office 5.0
        {TEXT("soffice.EXE"), MAJORVERSION TEXT("5"), ACF_STAROFFICE5PRINTER},

        // All of the "Corel WordPerfect Office 2000" suite apps need ACF_WIN95DEFVIEW. Since the shipping
        // version (9.0.0.528) as well as their SR1 release (9.0.0.588) are both broken, we key off 
        // of the major version
        {TEXT("WPWIN9.EXE"), MAJORVERSION TEXT("9"), ACF_WIN95DEFVIEW},
        {TEXT("QPW.EXE"), MAJORVERSION TEXT("9"), ACF_WIN95DEFVIEW},
        {TEXT("PRWIN9.EXE"), MAJORVERSION TEXT("9"), ACF_WIN95DEFVIEW},
        {TEXT("DAD9.EXE"), MAJORVERSION TEXT("9"), ACF_WIN95DEFVIEW},

        //
        //  WARNING DONT ADD NEW COMPATIBILITY HERE - ZekeL - 18-OCT-99
        //  Add new entries to the registry.  each component 
        //  that needs compatibility flags should register 
        //  during selfregistration.  (see the RegExternal
        //  section of selfreg.inx in shell32 for an example.)  
        //  all new flags should be added to the FLAGMAP array.
        //
        //  the register under:
        //  HKLM\SW\MS\Win\CV\ShellCompatibility\Applications
        //      \App.exe
        //          RequiredFile="OtherFile.dat" // optional
        //          Version = "1.0.0.1"  or "1.*" // version of App.exe
        //          //  NOTE version supports basic pattern matching,
        //          //  but doesnt currently support multiple versions
        //          //  for multiple versions, see below
        //          FLAGNAME    //  requires no value
        //
        //  If a RequiredFile is present, then it is PathCombine'd with
        //  the directory that App.exe is in and checked for existence.
        //  The file must exist for the app compat flag to be used.
        //  RequiredFile is strongly recommended to avoid false positives.
        //
        //  If the app name is generic (like "setup.exe" or "install.exe")
        //  then you must use the RequiredFile method to ensure
        //  that the app compat flag fires only for the app you care about.
        //
        //  To accomodate multiple entries for one EXE name (e.g., the
        //  multiple versions problem described above), we will
        //  also look inside all subdirectories of Applications\App.exe
        //  for a matching app compat flag.
        //
        //  For example, Starcraft 1.03 INSTALL.EXE uses this key layout:
        //
        //  HKLM\SW\MS\Win\CV\ShellCompatibility\Applications
        //      \install.exe            (name of exe)
        //          \Starcraft 1.03     (arbitrary unique string)
        //              RequiredFile="HELP\STAR.HTM" (unique file on CD)
        //              Version = "1.0.0.1" or "1.*" (same as above)
        //              FLAGNAME (same as above)
        //
    };

    static const APPCLASS aAppClass[] =
    {
            // note that the strings here are stz's....
        {TEXT("\x9""bosa_sdm_"),                           ACF_APPISOFFICE | ACF_STRIPFOLDERBIT},
        {TEXT("\x18""File Open Message Window"),           ACF_APPISOFFICE | ACF_STRIPFOLDERBIT},
    };

    if (dwFlagsNeeded & (ACF_PERPROCESSFLAGS))
    {
        if (!bInitialized)
        {    
          //
          //  Do this only for old apps.
          //
          //  Once an app marks itself as NT5-compatible, we stop doing
          //  NT4/Win5 app hacks for it.
          //
            if (GetProcessVersion(0) < MAKELONG(0, 5))
            {
                TCHAR  szModulePath[MODULE_NAME_SIZE];
                TCHAR* pszModuleName = NULL;
        
                if (GetModuleFileName(GetModuleHandle(NULL), szModulePath, ARRAYSIZE(szModulePath)))
                    pszModuleName = PathFindFileName(szModulePath);
        
                if (pszModuleName)
                {
                    for (int i=0; i < ARRAYSIZE(aAppCompat); i++)
                    {
                        if (lstrcmpi(aAppCompat[i].pszModule, pszModuleName) == 0)
                        {
                            if (_IsAppCompatVersion(szModulePath, aAppCompat[i].pszVersion))
                            {
                                dwCachedProcessFlags = aAppCompat[i].dwFlags;
                                break;
                            }
                        }
                    }

                    dwCachedProcessFlags |= _GetRegistryCompatFlags(szModulePath);
                }
            }
            bInitialized = TRUE;
        }
    }

    if ((dwFlagsNeeded & ACF_PERCALLFLAGS) &&
        !(dwCachedProcessFlags & ACF_KNOWPERPROCESS))
    {
        WNDDAT wd;
        wd.dwPid = GetCurrentProcessId();
        wd.irgFound = -1;
        wd.rgAppClass = aAppClass;
        wd.cAppClass = ARRAYSIZE(aAppClass);
        EnumWindows (EnumWnd, (LPARAM) &wd);

        if (wd.irgFound > -1)
        {
            dwCachedProcessFlags |= (aAppClass[wd.irgFound].dwFlags);
        }
        dwCachedProcessFlags |= ACF_KNOWPERPROCESS;
    }
    
    return dwCachedProcessFlags; 
}

// {9EAC43C0-53EC-11CE-8230-CA8A32CF5494}
//static const GUID GUID_WINAMP = 
//{ 0x9eac43c0, 0x53ec, 0x11ce, { 0x82, 0x30, 0xca, 0x8a, 0x32, 0xcf, 0x54, 0x94} };

// {E9779583-939D-11CE-8A77-444553540000}
static const GUID GUID_AECOZIPARCHIVE = 
{ 0xE9779583, 0x939D, 0x11ce, { 0x8a, 0x77, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };
// {49707377-6974-6368-2E4A-756E6F644A01}
static const GUID CLSID_WS_FTP_PRO_EXPLORER =
{ 0x49707377, 0x6974, 0x6368, {0x2E, 0x4A,0x75, 0x6E, 0x6F, 0x64, 0x4A, 0x01} };
// {49707377-6974-6368-2E4A-756E6F644A0A}
static const GUID CLSID_WS_FTP_PRO =
{ 0x49707377, 0x6974, 0x6368, {0x2E, 0x4A,0x75, 0x6E, 0x6F, 0x64, 0x4A, 0x0A} };
// {2bbbb600-3f0a-11d1-8aeb-00c04fd28d85}
static const GUID CLSID_KODAK_DC260_ZOOM_CAMERA =
{ 0x2bbbb600, 0x3f0a, 0x11d1, {0x8a, 0xeb, 0x00, 0xc0, 0x4f, 0xd2, 0x8d, 0x85} };
// {00F43EE0-EB46-11D1-8443-444553540000}
static const GUID GUID_MACINDOS =
{ 0x00F43EE0, 0xEB46, 0x11D1, { 0x84, 0x43, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };
static const GUID CLSID_EasyZIP = 
{ 0xD1069700, 0x932E, 0x11cf, { 0xAB, 0x59, 0x00, 0x60, 0x8C, 0xBF, 0x2C, 0xE0} };

static const GUID CLSID_PAGISPRO_FOLDER =
{ 0x7877C8E0, 0x8B13, 0x11D0, { 0x92, 0xC2, 0x00, 0xAA, 0x00, 0x4B, 0x25, 0x6F} };
// {61E285C0-DCF4-11cf-9FF4-444553540000}
static const GUID CLSID_FILENET_IDMDS_NEIGHBORHOOD =
{ 0x61e285c0, 0xdcf4, 0x11cf, { 0x9f, 0xf4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };

// These guys call CoFreeUnusedLibraries inside their Release() handler, so
// if you are releasing the last object, they end up FreeLibrary()ing
// themselves!

// {b8777200-d640-11ce-b9aa-444553540000}
static const GUID CLSID_NOVELLX =
{ 0xb8777200, 0xd640, 0x11ce, { 0xb9, 0xaa, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };

static const GUID CLSID_PGP50_CONTEXTMENU =  //{969223C0-26AA-11D0-90EE-444553540000}
{ 0x969223C0, 0x26AA, 0x11D0, { 0x90, 0xEE, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };

static const GUID CLSID_QUICKFINDER_CONTEXTMENU = //  {CD949A20-BDC8-11CE-8919-00608C39D066}
{ 0xCD949A20, 0xBDC8, 0x11CE, { 0x89, 0x19, 0x00, 0x60, 0x8C, 0x39, 0xD0, 0x66} };

static const GUID CLSID_HERCULES_HCTNT_V1001 = // {921BD320-8CB5-11CF-84CF-885835D9DC01}
{ 0x921BD320, 0x8CB5, 0x11CF, { 0x84, 0xCF, 0x88, 0x58, 0x35, 0xD9, 0xDC, 0x01} };

//
// NOTICE - DONT ADD ANYMORE HARDCODED CLSIDS
// add them to the ShellCompatibility key.  register in the client DLL
//

#define OCFMAPPING(ocf)     {OBJCOMPATF_##ocf, TEXT(#ocf)}

DWORD _GetRegistryObjectCompatFlags(REFGUID clsid)
{
    DWORD dwRet = 0;
    TCHAR szGuid[GUIDSTR_MAX];
    TCHAR sz[MAX_PATH];
    HKEY hk;

    SHStringFromGUID(clsid, szGuid, ARRAYSIZE(szGuid));
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Objects\\%s"), szGuid);
    
    if (NOERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE, &hk))
    {   
        static const FLAGMAP rgOcfMaps[] = {
            OCFMAPPING(OTNEEDSSFCACHE),
            OCFMAPPING(NO_WEBVIEW),
            OCFMAPPING(UNBINDABLE),
            OCFMAPPING(PINDLL),
            OCFMAPPING(NEEDSFILESYSANCESTOR),
            OCFMAPPING(NOTAFILESYSTEM),
            OCFMAPPING(CTXMENU_NOVERBS),
            OCFMAPPING(CTXMENU_LIMITEDQI),
            OCFMAPPING(COCREATESHELLFOLDERONLY),
            OCFMAPPING(NEEDSSTORAGEANCESTOR),
            OCFMAPPING(NOLEGACYWEBVIEW),
            };

        dwRet = _GetMappedFlags(hk, rgOcfMaps, ARRAYSIZE(rgOcfMaps));
        RegCloseKey(hk);
    }

    return dwRet;
}

typedef struct _CLSIDCOMPAT
{
    const GUID *pclsid;
    OBJCOMPATFLAGS flags;
}CLSIDCOMPAT, *PCLSIDCOMPAT;

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlags(IUnknown *punk, const CLSID *pclsid)
{
    HRESULT hr = E_INVALIDARG;
    OBJCOMPATFLAGS ocf = 0;
    CLSID clsid;
    if (punk)
        hr = IUnknown_GetClassID(punk, &clsid);
    else if (pclsid)
    {
        clsid = *pclsid;
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        static const CLSIDCOMPAT s_rgCompat[] =
        {
            {&CLSID_WS_FTP_PRO_EXPLORER,
                OBJCOMPATF_OTNEEDSSFCACHE | OBJCOMPATF_PINDLL },
            {&CLSID_WS_FTP_PRO,
                OBJCOMPATF_UNBINDABLE},
            {&GUID_AECOZIPARCHIVE,
                OBJCOMPATF_OTNEEDSSFCACHE | OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_KODAK_DC260_ZOOM_CAMERA,
                OBJCOMPATF_OTNEEDSSFCACHE | OBJCOMPATF_PINDLL},
            {&GUID_MACINDOS,
                OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_EasyZIP,            
                OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_PAGISPRO_FOLDER,
                OBJCOMPATF_NEEDSFILESYSANCESTOR},
            {&CLSID_FILENET_IDMDS_NEIGHBORHOOD,
                OBJCOMPATF_NOTAFILESYSTEM},
            {&CLSID_NOVELLX,
                OBJCOMPATF_PINDLL},
            {&CLSID_PGP50_CONTEXTMENU,
                OBJCOMPATF_CTXMENU_LIMITEDQI},
            {&CLSID_QUICKFINDER_CONTEXTMENU,
                OBJCOMPATF_CTXMENU_NOVERBS},
            {&CLSID_HERCULES_HCTNT_V1001,
                OBJCOMPATF_PINDLL},
            //
            //  WARNING DONT ADD NEW COMPATIBILITY HERE - ZekeL - 18-OCT-99
            //  Add new entries to the registry.  each component 
            //  that needs compatibility flags should register 
            //  during selfregistration.  (see the RegExternal
            //  section of selfreg.inx in shell32 for an example.)  
            //  all new flags should be added to the FLAGMAP array.
            //
            //  the register under:
            //  HKLM\SW\MS\Win\CV\ShellCompatibility\Objects
            //      \{CLSID}
            //          FLAGNAME    //  requires no value
            //
            //  NOTE: there is no version checking
            //  but we could add it as the data attached to 
            //  the flags, and compare with the version 
            //  of the LocalServer32 dll.
            //  
            {NULL, 0}
        };

        for (int i = 0; s_rgCompat[i].pclsid; i++)
        {
            if (IsEqualGUID(clsid, *(s_rgCompat[i].pclsid)))
            {
                //  we could check version based
                //  on what is in under HKCR\CLSID\{clsid}
                ocf = s_rgCompat[i].flags;
                break;
            }
        }

        ocf |= _GetRegistryObjectCompatFlags(clsid);

    }

    return ocf;
}

STDAPI IUnknown_ProfferServiceOld(IUnknown *punkSite, REFGUID sidWhere, 
                               REFGUID sidWhat, IServiceProvider *pService, 
                               DWORD *pdwCookie)
{
    IProfferService *pps;
    HRESULT hr = IUnknown_QueryService(punkSite, sidWhere, IID_PPV_ARG(IProfferService, &pps));
    if (SUCCEEDED(hr))
    {
        if (pService)
            hr = pps->ProfferService(sidWhat, pService, pdwCookie);
        else
            hr = pps->RevokeService(*pdwCookie);
        pps->Release();
    }
    return hr;
}


// helper to get up to service provider and to do register/unregister
// two forms:
//      pService != NULL, register, pdwCookie is [out] returns cookie
//      pService == NULL, unregister, *pdwCookie is [in] de-registers the service

STDAPI IUnknown_ProfferService(IUnknown *punkSite,
                               REFGUID sidWhat, IServiceProvider *pService, 
                               DWORD *pdwCookie)
{
    IProfferService *pps;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SProfferService, IID_PPV_ARG(IProfferService, &pps));
    if (SUCCEEDED(hr))
    {
        if (pService)
            hr = pps->ProfferService(sidWhat, pService, pdwCookie);
        else
        {
            hr = pps->RevokeService(*pdwCookie);
            *pdwCookie = 0;
        }
        pps->Release();
    }
    return hr;
}

HRESULT IUnknown_QueryServiceExec(IUnknown* punk, REFGUID guidService, const GUID *guid,
                                 DWORD cmdID, DWORD cmdParam, VARIANT* pvarargIn, VARIANT* pvarargOut)
{
    IOleCommandTarget* poct;
    HRESULT hres = IUnknown_QueryService(punk, guidService, IID_PPV_ARG(IOleCommandTarget, &poct));
    if (SUCCEEDED(hres))
    {
        hres = poct->Exec(guid, cmdID, cmdParam, pvarargIn, pvarargOut);
        poct->Release();
    }

    return hres;
}

HRESULT IUnknown_QueryServicePropertyBag(IUnknown* punk, DWORD dwFlags, REFIID riid, void** ppv)
{
    IShellBrowserService* psbs;
    HRESULT hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowserService, &psbs));
    if (SUCCEEDED(hr))
    {
        hr = psbs->GetPropertyBag(dwFlags, riid, ppv);

        psbs->Release();
    }

    return hr;
}


HRESULT SHConvertGraphicsFile(IN LPCWSTR pszSourceFile, IN LPCWSTR pszDestFile, IN DWORD dwFlags)
{
    HRESULT hr = S_OK;

    HRESULT hrInit = SHCoInitialize();

    if ((dwFlags & SHCGF_REPLACEFILE) && PathFileExistsW(pszDestFile))
    {
        if (!DeleteFileW(pszDestFile))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (SUCCEEDED(hr))
    {
        if (PathFileExistsW(pszDestFile))
        {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }
        else
        {
            IShellImageDataFactory * pImgFact;

            hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &pImgFact));
            if (SUCCEEDED(hr))
            {
                GUID guidDontCare;
                hr = pImgFact->GetDataFormatFromPath(pszDestFile, &guidDontCare);
                if (SUCCEEDED(hr))
                {
                    // Open image file
                    IShellImageData * pImage;
                    hr = pImgFact->CreateImageFromFile(pszSourceFile, &pImage);
                    if (SUCCEEDED(hr))
                    {
                        hr = pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            // load the file
                            IPersistFile *ppfImg;
                            hr = pImage->QueryInterface(IID_PPV_ARG(IPersistFile, &ppfImg));
                            if (SUCCEEDED(hr))
                            {
                                // saving to a different extention automatically changes the file type
                                hr = ppfImg->Save(pszDestFile, TRUE);
                                ppfImg->Release();
                            }

                        }
                        pImage->Release();
                    }
                }
                pImgFact->Release();
            }
        }
    }
    
    SHCoUninitialize(hrInit);

    return hr;
}

void _ValidateShellNoRoam(HKEY hk)
{
    WCHAR szOld[MAX_COMPUTERNAME_LENGTH + 1] = L"";
    WCHAR szNew[MAX_COMPUTERNAME_LENGTH + 1] = L"";
    DWORD cb = sizeof(szOld);
    SHGetValueW(hk, NULL, NULL, NULL, szOld, &cb);
    cb = ARRAYSIZE(szNew);
    GetComputerNameW(szNew, &cb);
    if (StrCmpICW(szNew, szOld))
    {
        //  need to delete this key's kids
        SHDeleteKey(hk, NULL);
        SHSetValueW(hk, NULL, NULL, REG_SZ, szNew, CbFromCchW(lstrlenW(szNew)+1));
    }
}

void _ValidateMUICache(HKEY hk)
{
    LANGID lidOld = 0;
    //  if we are running on legacy platforms, we aggressively invalidate
    LANGID lidNew = g_bRunningOnNT5OrHigher ? MLGetUILanguage() : -1;
    DWORD cb = sizeof(lidOld);
    SHGetValueW(hk, NULL, L"LangID", NULL, &lidOld, &cb);

    if (lidOld != lidNew)
    {
        SHDeleteKey(hk, NULL);
        SHSetValueW(hk, NULL, L"LangID", REG_BINARY, &lidNew, sizeof(lidNew));
    }
}

typedef void (*PFNVALIDATE)(HKEY);

typedef struct 
{
    LPCWSTR psz;
    DWORD dwOption;
    PFNVALIDATE pfnValidate;
    HKEY hkCU;
    HKEY hkLM;
} SKCACHE;

#define SKENTRY(s)  {s, REG_OPTION_NON_VOLATILE, NULL, NULL, NULL}
#define SKENTRYOPT(s, o)  {s, o, NULL, NULL, NULL}
#define SKENTRYVAL(s, pfnV) {s, REG_OPTION_NON_VOLATILE, pfnV, NULL, NULL}

static SKCACHE s_skPath[] =
{
    SKENTRY(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), 
    SKENTRY(L"Software\\Microsoft\\Windows\\Shell"), 
    SKENTRYVAL(L"Software\\Microsoft\\Windows\\ShellNoRoam", _ValidateShellNoRoam), 
    SKENTRY(L"Software\\Classes"),
};

static SKCACHE s_skSub[] =
{
    SKENTRY(L"LocalizedResourceName"),
    SKENTRY(L"Handlers"),
    SKENTRY(L"Associations"),
    SKENTRYOPT(L"Volatile", REG_OPTION_VOLATILE),
    SKENTRYVAL(L"MUICache", _ValidateMUICache), 
    SKENTRY(L"FileExts"),
};

HKEY _OpenKey(HKEY hk, LPCWSTR psz, BOOL fCreate, DWORD dwOption)
{
    HKEY hkRet = NULL;
    DWORD err;
    if (fCreate && psz)
    {
        DWORD dwDisp;
        err = RegCreateKeyExWrapW(hk, psz, 0, NULL, dwOption, MAXIMUM_ALLOWED, NULL, &hkRet, &dwDisp);
    }
    else
    {
        err = RegOpenKeyExWrapW(hk, psz, 0, MAXIMUM_ALLOWED, &hkRet);
    }

    if (!hkRet)
    {
        //  if ERROR_KEY_DELETED
        //  should we invalidate our cache??
        //  cause we will fail forever...
        SetLastError(err);
    }
        
    return hkRet;
}

HKEY _OpenSKCache(HKEY hk, BOOL fHKLM, BOOL fNoCaching, BOOL fCreateSub, SKCACHE *psk, DWORD *pdwOption)
{
    HKEY hkSub = fHKLM ? psk->hkLM : psk->hkCU;
    *pdwOption = psk->dwOption;

    if (!hkSub || fNoCaching)
    {
        hkSub = _OpenKey(hk, psk->psz, fCreateSub, psk->dwOption);
        if (hkSub)
        {
            if (psk->pfnValidate)
                psk->pfnValidate(hkSub);

            if (!fNoCaching)
            {
                ENTERCRITICAL;
                HKEY *phk = fHKLM ? &psk->hkLM : &psk->hkCU;
                if (!*phk)
                {
                    *phk = hkSub;
                }
                else
                {
                    RegCloseKey(hkSub);
                    hkSub = *phk;
                }
                LEAVECRITICAL;
            }
        }
    }
    return hkSub;
}
    
#define HKEY_FROM_SKROOT(sk)    ((sk & SKROOT_MASK) == SKROOT_HKLM ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER)

HKEY _OpenShellKey(SHELLKEY sk, HKEY hkRoot, BOOL fNoCaching, BOOL fCreateSub, DWORD *pdwOption)
{
    BOOL fHKLM = (sk & SKROOT_MASK) == SKROOT_HKLM;
    ULONG uPath = (sk & SKPATH_MASK) >> 4;
    ULONG uSub = (sk & SKSUB_MASK) >> 12;

    ASSERT(uPath < ARRAYSIZE(s_skPath));
    HKEY hkPath = NULL;
    if (uPath < ARRAYSIZE(s_skPath))
    {
        hkPath = _OpenSKCache(hkRoot, fHKLM, fNoCaching, fCreateSub, &s_skPath[uPath], pdwOption);
    }
    else
        SetLastError(E_INVALIDARG);

    //  see if there is a sub value to add
    if (hkPath && uSub != SKSUB_NONE && --uSub < ARRAYSIZE(s_skSub))
    {
        HKEY hkSub = _OpenSKCache(hkPath, fHKLM, fNoCaching, fCreateSub, &s_skSub[uSub], pdwOption);
        if (fNoCaching)
            RegCloseKey(hkPath);
        hkPath = hkSub;
    }
    
    return hkPath;
}

HKEY _GetRootKey(SHELLKEY sk, BOOL *pfNoCaching)
{
    HKEY hkRoot = HKEY_FROM_SKROOT(sk);
    HANDLE hToken;
    if (hkRoot == HKEY_CURRENT_USER && OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
    {
        //  we dont support ARBITRARY tokens
        //  but RegOpenCurrentUser() opens the current thread token
        NT5_RegOpenCurrentUser(MAXIMUM_ALLOWED, &hkRoot);
        //  if we wanted to we would have to do something
        //  like shell32!GetUserProfileKey(hToken, &hkRoot);

        CloseHandle(hToken);
    }

    *pfNoCaching = HKEY_FROM_SKROOT(sk) != hkRoot;
    return hkRoot;
}

STDAPI_(HKEY) SHGetShellKey(SHELLKEY sk, LPCWSTR pszSubKey, BOOL fCreateSub)
{
    BOOL fNoCaching;
    HKEY hkRoot = _GetRootKey(sk, &fNoCaching);
    HKEY hkRet = NULL;
    if (hkRoot)
    {
        DWORD dwOption;
        HKEY hkPath = _OpenShellKey(sk, hkRoot, fNoCaching, fCreateSub, &dwOption); 

        //  this duplicates when there is no subkey
        if (hkPath)
        {
            hkRet = _OpenKey(hkPath, pszSubKey, fCreateSub, dwOption);

            if (fNoCaching)
                RegCloseKey(hkPath);
        }

        if (fNoCaching)
            RegCloseKey(hkRoot);
    }
    else
        SetLastError(ERROR_ACCESS_DENIED);

    return hkRet;
}

STDAPI_(void) InitShellKeys(BOOL fInit)
{
    if (!fInit)
    {
        int i;

        //  walk each array and close the cached keys
        for (i = 0; i < ARRAYSIZE(s_skPath); i++)
        {
            if (s_skPath[i].hkCU)
            {
                RegCloseKey(s_skPath[i].hkCU);
                s_skPath[i].hkCU = NULL;
            }

            if (s_skPath[i].hkLM)
            {
                RegCloseKey(s_skPath[i].hkLM);
                s_skPath[i].hkLM = NULL;
            }
        }

        for (i = 0; i < ARRAYSIZE(s_skSub); i++)
        {
            if (s_skSub[i].hkCU)
            {
                RegCloseKey(s_skSub[i].hkCU);
                s_skSub[i].hkCU = NULL;
            }

            if (s_skSub[i].hkLM)
            {
                RegCloseKey(s_skSub[i].hkLM);
                s_skSub[i].hkLM = NULL;
            }
        }
    }
}

STDAPI SKGetValueW(
    IN  SHELLKEY sk,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,          OPTIONAL
    OUT DWORD * pdwType,            OPTIONAL
    OUT void *  pvData,             OPTIONAL
    OUT DWORD * pcbData)            OPTIONAL
{
    HKEY hk = SHGetShellKey(sk, pwszSubKey, FALSE);
    if (hk)
    {
        DWORD err = SHQueryValueExW(hk, pwszValue, NULL, pdwType, pvData, pcbData);
        RegCloseKey(hk);
        return HRESULT_FROM_WIN32(err);
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

STDAPI SKSetValueW(
    IN  SHELLKEY sk,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,
    IN  DWORD   dwType,
    IN  LPCVOID pvData,
    IN  DWORD   cbData)
{
    HKEY hk = SHGetShellKey(sk, pwszSubKey, TRUE);
    if (hk)
    {
        // RegSetValueExW is not supported on Win95 but we have a thunking function.
        DWORD err = RegSetValueExWrapW(hk, pwszValue, 0, dwType, (BYTE *)pvData, cbData);
        RegCloseKey(hk);
        return HRESULT_FROM_WIN32(err);
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

STDAPI SKDeleteValueW(
    IN  SHELLKEY sk,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue)
{
    HKEY hk = SHGetShellKey(sk, pwszSubKey, TRUE);
    if (hk)
    {
        // RegSetValueExW is not supported on Win95 but we have a thunking function.
        DWORD err = RegDeleteValueWrapW(hk, pwszValue);
        RegCloseKey(hk);
        return HRESULT_FROM_WIN32(err);
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

STDAPI SKAllocValueW(
    IN  SHELLKEY sk,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,          OPTIONAL
    OUT DWORD * pdwType,            OPTIONAL
    OUT void ** ppvData,
    OUT DWORD * pcbData)            OPTIONAL
{
    HKEY hk = SHGetShellKey(sk, pwszSubKey, FALSE);
    if (hk)
    {
        DWORD cbData;
        DWORD err = SHQueryValueExW(hk, pwszValue, NULL, NULL, NULL, &cbData);
        if (err == ERROR_SUCCESS)
        {
            //  we add an extra char incase we need a NULL terminator
            *ppvData = LocalAlloc(LPTR, cbData + sizeof(WCHAR));
            if (*ppvData)
            {
                err = SHQueryValueExW(hk, pwszValue, NULL, pdwType, *ppvData, &cbData);
                if (err == ERROR_SUCCESS)
                {
                    if (pcbData)
                        *pcbData = cbData;
                }
                else
                {
                    LocalFree(*ppvData);
                    *ppvData = NULL;
                }
            }
            else
                err = ERROR_NOT_ENOUGH_MEMORY;
        }
        
        RegCloseKey(hk);
        return HRESULT_FROM_WIN32(err);
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

//
// SHBoolSystemParametersInfo
//
// Wrapper around SystemParametersInfo to deal with various
// parameter semantics of boolean SPI's.
//
// The return value is just the result of the call to SPI.
// If you're querying for a value, you need to look at the
// value returned in pdwParam.
//
// Feel free to add more cases to the switch statement below
// if you need them.
//
STDAPI_(BOOL) SHBoolSystemParametersInfo(UINT uiAction, DWORD *pdwParam)
{
    //
    // Figure out the SPI parameters depending on uiAction.
    //

    UINT uiParam = 0;
    PVOID pvParam = NULL;

    ANIMATIONINFO aii;

    if (uiAction & (SPIF_BOOL | SPIF_DWORD))
    {
        if (uiAction & SPIF_SET)
        {
            pvParam = IntToPtr(*pdwParam);
        }
        else
        {
            pvParam = pdwParam;
        }
    }
    else
    {
        switch (uiAction)
        {
        case SPI_GETANIMATION:
        case SPI_SETANIMATION:
            aii.cbSize = uiParam = sizeof(ANIMATIONINFO);
            aii.iMinAnimate = *pdwParam;
            pvParam = &aii;
            break;

        case SPI_GETDRAGFULLWINDOWS:
        case SPI_GETFONTSMOOTHING:
            pvParam = pdwParam;
            break;

        case SPI_SETDRAGFULLWINDOWS:
        case SPI_SETFONTSMOOTHING:
            uiParam = *pdwParam;
            break;

        default:
            RIPMSG(0, "SHBoolSystemParametersInfo: unknown SPI_ %x, need to add code for this case", uiAction);
            return ERROR_INVALID_PARAMETER;
        }
    }
    

    //
    // do the SPI call
    //
    BOOL fRet = SystemParametersInfo(uiAction, uiParam, pvParam, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

    //
    // copy return value if necessary
    //
    if (uiAction == SPI_GETANIMATION)
    {
        *pdwParam = aii.iMinAnimate;
    }

    return fRet;
}


// 
// Determine if the images represented by the two icons are the same
// (NOTE: this does not compare ICON masks, but this should never be a distinguishing factor)
//
STDAPI_(BOOL) SHAreIconsEqual(HICON hIcon1, HICON hIcon2)
{
    BOOL bRet = FALSE;

    ICONINFO ii1;
    if (hIcon1 && hIcon2 && GetIconInfo(hIcon1, &ii1))
    {
        ICONINFO ii2;
        if (GetIconInfo(hIcon2, &ii2))
        {
            BITMAP bm1 = {0};
            if (GetObject(ii1.hbmColor, sizeof(bm1), &bm1))
            {
                BITMAP bm2 = {0};
                if (GetObject(ii2.hbmColor, sizeof(bm2), &bm2))
                {
                    if ((bm1.bmWidth == bm2.bmWidth) && (bm1.bmHeight == bm2.bmHeight))
                    {
                        BITMAPINFO bmi = {0};
                        bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
                        bmi.bmiHeader.biWidth = bm1.bmWidth;
                        bmi.bmiHeader.biHeight = bm1.bmHeight;
                        bmi.bmiHeader.biPlanes = 1;
                        bmi.bmiHeader.biBitCount = 32;
                        bmi.bmiHeader.biCompression = BI_RGB;

                        HDC hdc = GetDC(NULL);
                        if (hdc)
                        {
                            ULONG* pulIcon1 = new ULONG[bm1.bmWidth * bm1.bmHeight];
                            if (pulIcon1)
                            {
                                if (GetDIBits(hdc, ii1.hbmColor, 0, bm1.bmHeight, (LPVOID)pulIcon1, &bmi, DIB_RGB_COLORS))
                                {
                                    ULONG* pulIcon2 = new ULONG[bm1.bmWidth * bm1.bmHeight];
                                    if (pulIcon2)
                                    {
                                        if (GetDIBits(hdc, ii2.hbmColor, 0, bm1.bmHeight, (LPVOID)pulIcon2, &bmi, DIB_RGB_COLORS))
                                        {
                                            bRet = (0 == memcmp(pulIcon1, pulIcon2, bm1.bmWidth * bm1.bmHeight * sizeof(ULONG)));
                                        }
                                        delete[] pulIcon2;
                                    }
                                }
                                delete[] pulIcon1;
                            }
                            ReleaseDC(NULL, hdc);
                        }
                    }
                }
            }
            DeleteObject(ii2.hbmColor);
            DeleteObject(ii2.hbmMask);
        }
        DeleteObject(ii1.hbmColor);
        DeleteObject(ii1.hbmMask);
    }

    return bRet;
}

//
//  CoCreateInstance that queries the app compat layer first, giving
//  it a chance to load any necessary shims in anticipation of the
//  bad DLL being loaded.
//

EXTERN_C DECLSPEC_IMPORT BOOL STDAPICALLTYPE
ApphelpCheckShellObject(
    IN  REFCLSID    ObjectCLSID,
    IN  BOOL        bShimIfNecessary,
    OUT ULONGLONG*  pullFlags
);

STDAPI SHCoCreateInstanceAC(REFCLSID rclsid, IUnknown *punkOuter,
                            DWORD dwClsCtx, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;
    ULONGLONG ullFlags;

    // Note that on downlevel, our delayload stub will save us
    if (!ApphelpCheckShellObject(rclsid, TRUE, &ullFlags))
    {
        // App compat says "Do not load under any circumstances!"
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    return CoCreateInstance(rclsid, punkOuter, dwClsCtx, riid, ppvOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\clipper\clipper.cpp ===
//--------------------------------------------------------------------------
// Clipper.cpp : test out theme drawing and fast clipping
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "resource.h"

#define ASSERT(x)

#include "uxthemep.h"
#include "tmschema.h"
#include "borderfill.h"
#include "imagefile.h"
#include "textdraw.h"
#include "stdlib.h"
#include "stdio.h"
#include "autos.h"
//--------------------------------------------------------------------------
#define RECTWIDTH(rc) (rc.right - rc.left)
#define RECTHEIGHT(rc) (rc.bottom - rc.top)

#define CLIPPER_FONTHEIGHT  55
//--------------------------------------------------------------------------
HINSTANCE hInst;        

HWND hwndMain;
HWND hwndTab;
HWND hwndDisplay;

TCHAR *pszMainWindowClass = L"Clipper";
TCHAR *pszDisplayWindowClass = L"ClipperDisplay";
//-----------------------------------------------------------------------------------
enum IMAGEFILEDRAW
{
    IF_REG,
    IF_TRANS,
    IF_ALPHA
};
//-----------------------------------------------------------------------------------
LPCWSTR szPageNames[] = 
{
    L"BorderFill",
    L"BorderFill-R",
    L"ImageFile",
    L"ImageFile-R",
    L"Glyph",
    L"Glyph-R",
    L"MultiImage",
    L"MultiImage-R",
    L"Text",
    L"Text-R",
    L"Borders",
    L"Borders-R",
    L"SourceSizing",
    L"SourceSizing-R",
};
//-----------------------------------------------------------------------------------
enum GROUPID
{
    GID_BORDERFILL,
    GID_IMAGEFILE,
    GID_GLYPH,
    GID_MULTIIMAGE,
    GID_TEXT,
    GID_BORDERS,
    GID_SRCSIZING,
};
//-----------------------------------------------------------------------------------
#define MAXGROUPS  ((ARRAYSIZE(szPageNames))/2)
#define MAXTESTITEMS 50
//-----------------------------------------------------------------------------------
// Foward declarations of functions included in this code module:
BOOL                            InitInstance(HINSTANCE, int);
LRESULT CALLBACK        MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK        DisplayWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK        About(HWND, UINT, WPARAM, LPARAM);

void CreateDrawObjects();
BOOL CreateAllWindows();
void RegisterWindowClasses();
//-----------------------------------------------------------------------------------
HRESULT MakeErrorLast() {return E_FAIL;}
//-----------------------------------------------------------------------------------
BOOL CaptureBitmaps();
BOOL WriteBitmapToFile(BITMAPINFOHEADER *pHdr, BYTE *pBits, LPCWSTR pszBaseName);
BOOL WriteBitmapHeader(HANDLE hOutFile, BYTE *pMemoryHdr, DWORD dwTotalPixelBytes);

void OnDisplayResize();
void PaintObjects(HDC hdc, RECT *prc, int iGroupId);
//-----------------------------------------------------------------------------------
SIZE szCell = {100, 60};
RECT rcDraw = {10, 10, 50, 45};        // where to draw within cell
//-----------------------------------------------------------------------------------
struct TESTITEM
{
    HTHEME hTheme;
    DWORD dwDtbFlags;

    WCHAR szName[MAX_PATH];
};
//-----------------------------------------------------------------------------------
//---- scrolling support ----
int iVertOffset = 0;
int iMaxVertOffset = 0;     // set by WM_SIZE
int iVertLineSize = 10;     // # of pixels
int iVertPageSize = 0;      // set by WM_SIZE
//-----------------------------------------------------------------------------------
int iItemCount[MAXGROUPS] = {0};
TESTITEM TestItems[MAXGROUPS][MAXTESTITEMS];

BOOL fCapturing = FALSE;
//-----------------------------------------------------------------------------------
int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE, LPWSTR lpCmdLine, int nCmdShow)
{
    MSG msg;
    HACCEL hAccelTable;

    hInst = hInstance;
    RegisterWindowClasses();

    InitCommonControlsEx(NULL);

    if (!InitInstance (hInstance, nCmdShow)) 
    {
            return FALSE;
    }

    //---- parse cmdline params ----
    USES_CONVERSION;

    LPCSTR p = W2A(lpCmdLine);
    while (*p)
    {
        while (isspace(*p))
            p++;

        //---- parse switches ----
        if ((*p == '/') || (*p == '-'))
        {
            p++;

            if ((*p == 'c') || (*p == 'C'))
            {
                p++;
                fCapturing = TRUE;
            }
        }
    }

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_CLIPPER);

    if (fCapturing)
    {
        CaptureBitmaps();
        return 0;
    }

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
        {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
        }
    }

    return static_cast<int>(msg.wParam);
}
//--------------------------------------------------------------------------
BOOL CaptureBitmaps()
{
    //---- paint each tab page to a memory dc & convert to a bitmap file ----
    HDC hdcClient = GetDC(NULL);

    RECT rt = {0, 0, 800, 600};     // currently captures all good info
    BITMAPINFOHEADER BitMapHdr = {sizeof(BITMAPINFOHEADER), WIDTH(rt), HEIGHT(rt), 1, 24, BI_RGB};

    //---- create a DIB to paint into ----
    BYTE *pBits;
    HBITMAP hBitmap = CreateDIBSection(hdcClient, (BITMAPINFO *)&BitMapHdr, DIB_RGB_COLORS,
       (void **)&pBits, NULL, 0);

    HDC hdcMemory = CreateCompatibleDC(hdcClient);
    HBITMAP hOldBitmap = (HBITMAP)SelectObject(hdcMemory, hBitmap);

    //---- for each tab that we can draw ----
    for (int iTabNum=0; iTabNum < ARRAYSIZE(szPageNames); iTabNum++)
    {
        iVertOffset = 0;
        iVertPageSize = RECTHEIGHT(rt);
        int iGroupId = iTabNum/2;

        //---- keep tester interested by sync. visuals ----
        TabCtrl_SetCurSel(hwndTab, iTabNum);
        OnDisplayResize();
        iVertPageSize = RECTHEIGHT(rt);
        InvalidateRect(hwndDisplay, NULL, TRUE);

        if (iTabNum % 2)       // if its a mirrored page
            SetLayout(hdcMemory, LAYOUT_RTL);
        else
            SetLayout(hdcMemory, 0);
    
        //---- clear the background first ----
        HBRUSH hbr = CreateSolidBrush(RGB(255, 255, 255));
        FillRect(hdcMemory, &rt, hbr);

        //---- draw the objects/labels for this tab ----
        PaintObjects(hdcMemory, &rt, iGroupId);

        //---- now copy DIB bits to a bitmap file ----
        WriteBitmapToFile(&BitMapHdr, pBits, szPageNames[iTabNum]);
    }

    //---- clean up ----
    SelectObject(hdcMemory, hOldBitmap);
    DeleteDC(hdcMemory);
    DeleteObject(hBitmap);

    ReleaseDC(NULL, hdcClient);

    return TRUE;
}
//--------------------------------------------------------------------------
BOOL WriteBitmapToFile(BITMAPINFOHEADER *pHdr, BYTE *pBits, LPCWSTR pszBaseName)
{
    BOOL fWroteFile = FALSE;

    //---- get size of bitmap ----
    int iDibWidth = pHdr->biWidth;
    int iDibHeight = pHdr->biHeight;

    int iRawBytes = iDibWidth * 3;
    int iBytesPerRow = 4*((iRawBytes+3)/4);
    int iPixelBytesTotal = iBytesPerRow * iDibHeight;

    //---- create the bitmap file ----
    WCHAR szName[MAX_PATH];
    wsprintf(szName, L"%s.bmp", pszBaseName);

    HANDLE hFileOutput = CreateFile(szName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    if (hFileOutput == INVALID_HANDLE_VALUE)
    {
        printf("\nError - could not open bitmap file for output: %s\n", szName);
        goto exit;
    }

    //---- write the bitmap FILE header ----
    if (! WriteBitmapHeader(hFileOutput, (BYTE *)pHdr, iPixelBytesTotal))
        goto exit;

    //---- write the bitmap MEMORY header ----
    DWORD dw;
    if (! WriteFile(hFileOutput, pHdr, sizeof(*pHdr), &dw, NULL))
        goto exit;

    //---- write the bitmap bits ----
    if (! WriteFile(hFileOutput, pBits, iPixelBytesTotal, &dw, NULL))
        goto exit;

    //---- close the file ----
    CloseHandle(hFileOutput);

    fWroteFile = TRUE;

exit:
    return fWroteFile;
}
//---------------------------------------------------------------------------
BOOL WriteBitmapHeader(HANDLE hOutFile, BYTE *pMemoryHdr, DWORD dwTotalPixelBytes)
{
    BOOL fOK = FALSE;
    BYTE pbHdr1[] = {0x42, 0x4d};
    BYTE pbHdr2[] = {0x0, 0x0, 0x0, 0x0};
    int iFileLen;

    DWORD dw;

    //---- add bitmap hdr at front ----
    HRESULT hr = WriteFile(hOutFile, pbHdr1, sizeof(pbHdr1), &dw, NULL);
    if (FAILED(hr))
        goto exit;

    //---- add length of data ----
    iFileLen = dwTotalPixelBytes + sizeof(BITMAPFILEHEADER);
    hr = WriteFile(hOutFile, &iFileLen, sizeof(int), &dw, NULL);
    if (FAILED(hr))
        goto exit;

    hr = WriteFile(hOutFile, pbHdr2, sizeof(pbHdr2), &dw, NULL);
    if (FAILED(hr))
        goto exit;

    //---- offset to bits (who's idea was *this* field?) ----
    int iOffset, iColorTableSize;
    DWORD dwSize;

    iOffset = sizeof(BITMAPFILEHEADER);
    dwSize = *(DWORD *)pMemoryHdr;
    iOffset += dwSize; 
    iColorTableSize = 0;

    switch (dwSize)
    {
        case sizeof(BITMAPCOREHEADER):
            BITMAPCOREHEADER *hdr1;
            hdr1 = (BITMAPCOREHEADER *)pMemoryHdr;
            if (hdr1->bcBitCount == 1)
                iColorTableSize = 2*sizeof(RGBTRIPLE);
            else if (hdr1->bcBitCount == 4)
                iColorTableSize = 16*sizeof(RGBTRIPLE);
            else if (hdr1->bcBitCount == 8)
                iColorTableSize = 256*sizeof(RGBTRIPLE);
            break;

        case sizeof(BITMAPINFOHEADER):
        case sizeof(BITMAPV4HEADER):
        case sizeof(BITMAPV5HEADER):
            BITMAPINFOHEADER *hdr2;
            hdr2 = (BITMAPINFOHEADER *)pMemoryHdr;
            if (hdr2->biClrUsed)
                iColorTableSize = hdr2->biClrUsed*sizeof(RGBQUAD);
            else
            {
                if (hdr2->biBitCount == 1)
                    iColorTableSize = 2*sizeof(RGBQUAD);
                else if (hdr2->biBitCount == 4)
                    iColorTableSize = 16*sizeof(RGBQUAD);
                else if (hdr2->biBitCount == 8)
                    iColorTableSize = 256*sizeof(RGBQUAD);
            }
            break;
    }

    iOffset += iColorTableSize;
    hr = WriteFile(hOutFile, &iOffset, sizeof(int), &dw, NULL);
    if (FAILED(hr))
        goto exit;

    fOK = TRUE;

exit:
    return fOK;
}
//--------------------------------------------------------------------------
void DrawTargetRect(HDC hdc, RECT *prc, COLORREF cr)
{
    //---- draw purple target dashed rect ----

    //---- prepare drawing objects ----
    HPEN hPen = CreatePen(PS_DOT, 1, cr);
    HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
    HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

    //---- draw that thing ----
    Rectangle(hdc, prc->left-1, prc->top-1, prc->right+1, prc->bottom+1);

    //---- restore DC ----
    SelectObject(hdc, hOldPen);
    SelectObject(hdc, hOldBrush);
    DeleteObject(hPen);
}
//--------------------------------------------------------------------------
void DrawClip(HTHEME hTheme, HDC hdc, RECT *prc, int iRowIndex, int iColIndex,
     DWORD dwDtbFlags)
{
    RECT rect, rcClip;
    int left = prc->left + (iColIndex+1)*szCell.cx;
    int top = prc->top + (iRowIndex+1)*szCell.cy;

    HRESULT hr = S_OK;

    SetRect(&rect, left + rcDraw.left, top + rcDraw.top, 
        left + rcDraw.right, top + rcDraw.bottom);

    //---- draw purple target dashed rect ----
    DrawTargetRect(hdc, &rect, RGB(128, 128, 255));

    switch (iColIndex)      // clipping type
    {
    case 0:         // no clipping
        break;

    case 1:         // over clipping
        rcClip = rect;
        rcClip.left -= 4;
        rcClip.right += 4;
        rcClip.top -= 4;
        rcClip.bottom += 4;
        break;

    case 2:         // exact clipping
        rcClip = rect;
        break;

    case 3:         // partial overlap 
        rcClip = rect;
        rcClip.left += 8;
        rcClip.right -= 8;
        rcClip.top += 8;
        rcClip.bottom -= 8;
        break;

    case 4:         // InOut1
        rcClip = rect;
        rcClip.left -= 3;
        rcClip.right = rcClip.left + 20;
        rcClip.top -= 3;
        rcClip.bottom = rcClip.top + 20;
        break;

    case 5:         // InOut2
        rcClip = rect;
        rcClip.left += 20;
        rcClip.right += 5;
        rcClip.top += 15;;
        rcClip.bottom += 5;
        break;

    case 6:         // out clip
        rcClip.left = rect.right + 6;
        rcClip.right = rcClip.left + 9;
        rcClip.top = rect.top - 2;
        rcClip.bottom = rect.bottom + 2;
        break;
    }

    //---- draw red clipping rect ----
    if (iColIndex)
    {
        HPEN hPen = CreatePen(PS_DOT, 1, RGB(255, 0, 0));
        HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
        HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

        Rectangle(hdc, rcClip.left-1, rcClip.top-1, rcClip.right+1, rcClip.bottom+1);

        SelectObject(hdc, hOldPen);
        SelectObject(hdc, hOldBrush);
        DeleteObject(hPen);
    }

    DTBGOPTS DtbOpts = {sizeof(DtbOpts)};
    DtbOpts.dwFlags = dwDtbFlags;

    if (iColIndex)        // pass clipping rect
    {
        DtbOpts.dwFlags |= DTBG_CLIPRECT;
        DtbOpts.rcClip = rcClip;
    }

    hr = DrawThemeBackgroundEx(hTheme, hdc, 1, 2, &rect, &DtbOpts);
    if (FAILED(hr))
    {
        WCHAR buff[100];
        wsprintf(buff, L"DrawThemeBackgroundEx err: hr=0x%x, irow=%d, icol=%d", 
            hr, iRowIndex, iColIndex);

        //MessageBox(NULL, buff, L"Error", MB_OK);
    }
}
//--------------------------------------------------------------------------
void DrawTextObjects(HTHEME hTheme, HDC hdc, RECT *prc, int iRowIndex, LPCWSTR pszName)
{
    int left = prc->left + 4;        // some padding away from edge
    int top = prc->top + iRowIndex*szCell.cy + 18;  // try to center

    //---- draw label in left cell ----
    TextOut(hdc, left, top, pszName, wcslen(pszName));

    left += szCell.cx;
    RECT rc = {left, top, left+szCell.cx*5, top+szCell.cy};

    //---- draw actual test text ----
    HRESULT hr = DrawThemeText(hTheme, hdc, 1, 2, L"Testing Text Drawing", -1, 0, 0, &rc);

    if (FAILED(hr))
    {
        WCHAR buff[100];
        wsprintf(buff, L"DrawThemeText err: hr=0x%x, irow=%d", 
            hr, iRowIndex);

        MessageBox(NULL, buff, L"Error", MB_OK);
    }
}
//--------------------------------------------------------------------------
void DrawClips(HTHEME hTheme, HDC hdc, RECT *prc, int iRowIndex, LPCWSTR pszName,
    DWORD dwDtbFlags)
{
    //---- label object on left ----
    int left = prc->left + 4;        // some padding away from edge
    int top = prc->top + (iRowIndex+1)*szCell.cy + 18;  // try to center

    //---- manual page clipping ----
    if ((top + szCell.cy) < 0)
        return;
    if (top > iVertPageSize)
        return;

    TextOut(hdc, left, top, pszName, wcslen(pszName));

    //---- draw clipping variations ----
    for (int i=0; i <= 6; i++)
    {
        DrawClip(hTheme, hdc, prc, iRowIndex, i, dwDtbFlags);
    }
}
//--------------------------------------------------------------------------
void AddItem(CDrawBase *pObject, CTextDraw *pTextObj, LPCWSTR pszName, int iGroupId,
     DWORD dwOtdFlags=0, DWORD dwDtbFlags=0)
{
    HTHEME hTheme = NULL;
    
    if (iItemCount[iGroupId] >= MAXTESTITEMS)
        return;

    if (pObject)
    {
        if (pObject->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pTo = new CBorderFill;

            if (pTo)
            {
                memcpy(pTo, pObject, sizeof(CBorderFill));
                hTheme = CreateThemeDataFromObjects(pTo, NULL, dwOtdFlags);
            }
        }
        else            // imagefile
        {
            CMaxImageFile *pFrom = (CMaxImageFile *)pObject;
            CMaxImageFile *pTo = new CMaxImageFile;
            
            if (pTo)
            {
                //---- transfer CImageFile object & variable number of DIBINFO's ----
                DWORD dwLen = sizeof(CImageFile) + sizeof(DIBINFO)*pFrom->_iMultiImageCount;

                memcpy(pTo, pFrom, dwLen);

                hTheme = CreateThemeDataFromObjects(pTo, NULL, dwOtdFlags);
            }
        }
    }
    else            // text object
    {
        CTextDraw *pTo = new CTextDraw;

        if (pTo)
        {
            memcpy(pTo, pTextObj, sizeof(CTextDraw));
            hTheme = CreateThemeDataFromObjects(NULL, pTo, dwOtdFlags);
        }
    }

    if (hTheme)
    {
        int iIndex = iItemCount[iGroupId];
        TestItems[iGroupId][iIndex].hTheme = hTheme;
        TestItems[iGroupId][iIndex].dwDtbFlags = dwDtbFlags;

        lstrcpy(TestItems[iGroupId][iIndex].szName, pszName);

        iItemCount[iGroupId]++;
    }
    else
    {
        MessageBox(NULL, L"Error creating hTheme from obj", L"Error", MB_OK);
    }
}
//--------------------------------------------------------------------------
void CreateBorderFillNoDraw()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._fNoDraw = TRUE;

    AddItem(&bfill, NULL, L"NoDraw", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillSquare()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_RECT;
    bfill._iBorderSize = 0;

    bfill._eFillType = FT_SOLID;
    bfill._crFill = RGB(128, 255, 255);

    AddItem(&bfill, NULL, L"Square", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillBorder()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_RECT;
    bfill._crBorder = RGB(255, 128, 128);
    bfill._iBorderSize = 3;

    bfill._eFillType = FT_SOLID;
    bfill._crFill = RGB(128, 255, 255);

    AddItem(&bfill, NULL, L"Border", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillCircle()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_ROUNDRECT;
    bfill._crBorder = RGB(255, 128, 128);
    bfill._iBorderSize = 3;
    bfill._iRoundCornerWidth = 80;
    bfill._iRoundCornerHeight = 80;

    bfill._eFillType = FT_SOLID;
    bfill._crFill = RGB(128, 255, 255);

    AddItem(&bfill, NULL, L"Circle", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillGradient()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_RECT;
    bfill._crBorder = RGB(255, 128, 128);
    bfill._iBorderSize = 3;

    bfill._eFillType = FT_HORZGRADIENT;

    //---- gradients ----
    bfill._iGradientPartCount = 2;
    bfill._crGradientColors[0] = RGB(0, 0, 0);
    bfill._crGradientColors[1] = RGB(255, 255, 255);
    bfill._iGradientRatios[0] = 0;
    bfill._iGradientRatios[1] = 255;

    AddItem(&bfill, NULL, L"Gradient", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillCircleGradient()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_ROUNDRECT;
    bfill._crBorder = RGB(255, 128, 128);
    bfill._iBorderSize = 3;
    bfill._iRoundCornerWidth = 80;
    bfill._iRoundCornerHeight = 80;

    bfill._eFillType = FT_HORZGRADIENT;

    //---- gradients ----
    bfill._iGradientPartCount = 2;
    bfill._crGradientColors[0] = RGB(0, 0, 0);
    bfill._crGradientColors[1] = RGB(255, 255, 255);
    bfill._iGradientRatios[0] = 0;
    bfill._iGradientRatios[1] = 255;

    AddItem(&bfill, NULL, L"CircleGradient", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateImageFileBorder(SIZINGTYPE eSizeType, BOOL fSizeBorders, BOOL fForceSizeRect)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_BORDERTEST)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object that sizes with STRETCH ----
    cif._eBgType = BT_IMAGEFILE;  
    
    if (fSizeBorders)
    {
        cif._fSourceGrow = TRUE;
        cif._fIntegralSizing = TRUE;
    }

    cif._fMirrorImage = TRUE;
    cif._iImageCount = 1;
    cif._eImageLayout = IL_VERTICAL;
    cif._ImageInfo.iSingleWidth = 18;
    cif._ImageInfo.iSingleHeight = 17;
    cif._ImageInfo.eSizingType = eSizeType;
    cif._ImageInfo.iMinDpi = 96;
    cif._szNormalSize.cx = 50;
    cif._szNormalSize.cy = 50;

    SetRect((RECT *)&cif._SizingMargins, 3, 3, 3, 3);

    DWORD dwOtdFlags = 0;
    
    if (fForceSizeRect) 
    {
        dwOtdFlags |= OTD_FORCE_RECT_SIZING; 
    }

    AddItem(&cif, NULL, L"BorderTest", GID_BORDERS, dwOtdFlags);
}
//--------------------------------------------------------------------------
void CreateImage(int iBgImageId, int iStateCount, SIZINGTYPE eSizeType, BOOL fSrcSizing, int iGroupId,
     LPCWSTR pszName, int lw, int rw, int th, int bh)
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    if (iBgImageId)
    {
        mif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(iBgImageId)), 
            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    }

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    
    mif._fMirrorImage = TRUE;
    mif._iImageCount = iStateCount;
    mif._eImageLayout = IL_VERTICAL;
    mif._ImageInfo.eSizingType = eSizeType;
    mif._ImageInfo.iMinDpi = 96;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;
    mif._eGlyphType = GT_IMAGEGLYPH;

    //---- set Width/Height ----
    BITMAP bm;
    GetObject(mif._ImageInfo.hProcessBitmap, sizeof bm, &bm);

    mif._ImageInfo.iSingleWidth = bm.bmWidth;
    mif._ImageInfo.iSingleHeight = bm.bmHeight/iStateCount;

    mif._ImageInfo.szMinSize.cx = bm.bmWidth;
    mif._ImageInfo.szMinSize.cy = bm.bmHeight/iStateCount;

    SetRect((RECT *)&mif._SizingMargins, lw, rw, th, bh);
    SetRect((RECT *)&mif._ContentMargins, lw, rw, th, bh);

    DWORD dwOtdFlags = 0;
    
    if (fSrcSizing) 
    {
        dwOtdFlags |= OTD_FORCE_RECT_SIZING; 
    }

    AddItem(&mif, NULL, pszName, iGroupId, dwOtdFlags);
}
//--------------------------------------------------------------------------
void CreateProgressTrack()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    mif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_PROGRESS_TRACK)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    
    mif._fMirrorImage = TRUE;
    mif._iImageCount = 1;
    mif._eImageLayout = IL_VERTICAL;
    mif._ImageInfo.eSizingType = ST_TILE;
    mif._ImageInfo.iMinDpi = 96;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;

    //---- set Width/Height ----
    BITMAP bm;
    GetObject(mif._ImageInfo.hProcessBitmap, sizeof bm, &bm);

    mif._ImageInfo.iSingleWidth = bm.bmWidth;
    mif._ImageInfo.iSingleHeight = bm.bmHeight/1;

    mif._ImageInfo.szMinSize.cx = 10;
    mif._ImageInfo.szMinSize.cy = 10;

    mif._szNormalSize.cx = 100;
    mif._szNormalSize.cy = 18;

    mif._fSourceShrink = TRUE;

    SetRect((RECT *)&mif._SizingMargins, 4, 4, 3, 3);
    SetRect((RECT *)&mif._ContentMargins, 4, 4, 3, 3);

    AddItem(&mif, NULL, L"Progress", GID_SRCSIZING, 0);
}
//--------------------------------------------------------------------------
void CreateProgressChunk()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  

    mif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_PROGRESS_CHUNK)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    mif._fMirrorImage = TRUE;
    mif._iImageCount = 1;
    mif._eImageLayout = IL_VERTICAL;
    mif._ImageInfo.eSizingType = ST_TILE;
    mif._ImageInfo.iMinDpi = 96;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;
    mif._eGlyphType = GT_IMAGEGLYPH;

    //---- set Width/Height ----
    BITMAP bm;
    GetObject(mif._ImageInfo.hProcessBitmap, sizeof bm, &bm);

    mif._ImageInfo.iSingleWidth = bm.bmWidth;
    mif._ImageInfo.iSingleHeight = bm.bmHeight/1;

    mif._ImageInfo.szMinSize.cx = 10;
    mif._ImageInfo.szMinSize.cy = 10;

    mif._szNormalSize.cx = 100;
    mif._szNormalSize.cy = 18;

    SetRect((RECT *)&mif._SizingMargins, 0, 0, 6, 5);
    SetRect((RECT *)&mif._ContentMargins, 0, 0, 6, 5);

    AddItem(&mif, NULL, L"Progress", GID_SRCSIZING, 0);
}
//--------------------------------------------------------------------------
void CreateRadioImage()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    
    mif._fMirrorImage = TRUE;
    mif._iImageCount = 8;
    mif._eImageLayout = IL_VERTICAL;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;
    mif._eImageSelectType = IST_DPI;
    mif._iMultiImageCount = 3;
    mif._eTrueSizeScalingType = TSST_DPI;
    mif._fUniformSizing = TRUE;
    mif._eHAlign = HA_CENTER;
    mif._eVAlign = VA_CENTER;

    int iMinDpis[] = {96, 118, 185};

    //---- process multiple images ----
    for (int i=0; i < 3; i++)
    {
        DIBINFO *pdi = &mif.MultiDibs[i];

        int idnum = IDB_RADIO13 + i;

        pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        pdi->iMinDpi = iMinDpis[i];

        //---- get bitmap width/height ----
        BITMAP bm;
        GetObject(pdi->hProcessBitmap, sizeof bm, &bm);

        pdi->iSingleWidth = bm.bmWidth;
        pdi->iSingleHeight = bm.bmHeight/8;

        pdi->szMinSize.cx = pdi->iSingleWidth;
        pdi->szMinSize.cy = pdi->iSingleHeight;
        
        pdi->eSizingType = ST_TRUESIZE;
        
        pdi->crTransparent = RGB(255, 0, 255);
        pdi->fTransparent = TRUE;
    }

    //---- set primary image ----
    mif._ImageInfo = mif.MultiDibs[0];

    AddItem(&mif, NULL, L"RadioButton", GID_SRCSIZING, OTD_FORCE_RECT_SIZING);
}
//--------------------------------------------------------------------------
void CreateCheckImage()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    
    mif._fMirrorImage = TRUE;
    mif._iImageCount = 12;
    mif._eImageLayout = IL_VERTICAL;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;
    mif._eImageSelectType = IST_DPI;
    mif._iMultiImageCount = 3;
    mif._eTrueSizeScalingType = TSST_DPI;
    mif._fUniformSizing = TRUE;
    mif._eHAlign = HA_CENTER;
    mif._eVAlign = VA_CENTER;

    int iMinDpis[] = {96, 118, 185};

    //---- process multiple images ----
    for (int i=0; i < 3; i++)
    {
        DIBINFO *pdi = &mif.MultiDibs[i];

        int idnum = IDB_CHECK13 + i;

        pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        pdi->iMinDpi = iMinDpis[i];

        //---- get bitmap width/height ----
        BITMAP bm;
        GetObject(pdi->hProcessBitmap, sizeof bm, &bm);

        pdi->iSingleWidth = bm.bmWidth;
        pdi->iSingleHeight = bm.bmHeight/12;

        pdi->szMinSize.cx = pdi->iSingleWidth;
        pdi->szMinSize.cy = pdi->iSingleHeight;
        
        pdi->eSizingType = ST_TRUESIZE;
        
        pdi->fAlphaChannel =  TRUE;
    }

    //---- set primary image ----
    mif._ImageInfo = mif.MultiDibs[0];

    AddItem(&mif, NULL, L"CheckBox", GID_SRCSIZING, OTD_FORCE_RECT_SIZING);
}
//--------------------------------------------------------------------------
void CreateScrollGlyph()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    mif._eGlyphType = GT_IMAGEGLYPH;
    mif._fMirrorImage = TRUE;
    mif._iImageCount = 16;
    mif._eImageLayout = IL_VERTICAL;
    mif._szNormalSize.cx = 30;
    mif._szNormalSize.cy = 10;
    mif._eImageSelectType = IST_NONE;
    mif._fUniformSizing = TRUE;
    mif._eHAlign = HA_CENTER;
    mif._eVAlign = VA_CENTER;

    SetRect((RECT *)&mif._SizingMargins, 5, 5, 5, 5);
    SetRect((RECT *)&mif._ContentMargins, 0, 0, 3, 3);

    //---- background image ----
    DIBINFO *pdi = &mif._ImageInfo;
    pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_SCROLL_ARROWS)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- get bitmap width/height ----
    BITMAP bm;
    GetObject(pdi->hProcessBitmap, sizeof bm, &bm);

    pdi->iSingleWidth = bm.bmWidth;
    pdi->iSingleHeight = bm.bmHeight/16;

    pdi->szMinSize.cx = pdi->iSingleWidth;
    pdi->szMinSize.cy = pdi->iSingleHeight;

    pdi->iMinDpi = 96;
    
    pdi->eSizingType = ST_STRETCH;

    //---- glyph image ----
    pdi = &mif._GlyphInfo;
    mif._GlyphInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_SCROLL_GLPYHS)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    pdi->fTransparent =  TRUE;
    pdi->crTransparent = RGB(255, 0, 255);

    GetObject(pdi->hProcessBitmap, sizeof bm, &bm);
    pdi->iSingleWidth = bm.bmWidth;
    pdi->iSingleHeight = bm.bmHeight/16;

    pdi->szMinSize.cx = pdi->iSingleWidth;
    pdi->szMinSize.cy = pdi->iSingleHeight;
   
    pdi->iMinDpi = 96;
    pdi->eSizingType = ST_TRUESIZE;
    
    mif._fSourceShrink = TRUE;
    mif._fSourceGrow = TRUE;

    mif._eTrueSizeScalingType = TSST_SIZE;
    mif._iTrueSizeStretchMark = 100;

    //---- add it (without OTD_FORCE_RECT_SIZING) ----
    AddItem(&mif, NULL, L"ScrollBox", GID_SRCSIZING, 0);
}
//--------------------------------------------------------------------------
void CreateImageFileStretch(IMAGEFILEDRAW eDraw, int iGroupId)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_STRETCH;
    if (eDraw == IF_TRANS)
        idnum = IDB_STRETCH_TRANS;

    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object that sizes with STRETCH ----
    cif._eBgType = BT_IMAGEFILE;    
    cif._fMirrorImage = TRUE;
    cif._iImageCount = 5;
    cif._eImageLayout = IL_VERTICAL;
    cif._ImageInfo.iSingleWidth = 20;
    cif._ImageInfo.iSingleHeight = 19;
    cif._ImageInfo.eSizingType = ST_STRETCH;

    if (eDraw == IF_TRANS)
    {
        cif._ImageInfo.fTransparent = TRUE;
        cif._ImageInfo.crTransparent = RGB(255, 0, 255);
    }

    SetRect((RECT *)&cif._SizingMargins, 4, 4, 4, 4);

    LPCWSTR p = L"Stretch";

    if (eDraw == IF_TRANS)
        p = L"Stretch+Trans";

    AddItem(&cif, NULL, p, iGroupId);
}
//--------------------------------------------------------------------------
void CreateImageFileTile(IMAGEFILEDRAW eDraw, int iGroupId)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_TILE;
    if (eDraw == IF_TRANS)
        idnum = IDB_TILE_TRANS;

    DIBINFO *pdi = &cif._ImageInfo;

    pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object that sizes with TILE ----
    pdi->eSizingType = ST_TILE;
    cif._eBgType = BT_IMAGEFILE;    
    cif._fMirrorImage = TRUE;
    cif._iImageCount = 5;
    cif._eImageLayout = IL_VERTICAL;
    cif._ImageInfo.iSingleWidth = 20;
    cif._ImageInfo.iSingleHeight = 19;

    if (eDraw == IF_TRANS)
    {
        cif._ImageInfo.fTransparent = TRUE;
        cif._ImageInfo.crTransparent = RGB(255, 0, 255);
    }

    SetRect((RECT *)&cif._SizingMargins, 4, 4, 9, 9);

    LPCWSTR p = L"Tile";

    if (eDraw == IF_TRANS)
        p = L"Tile+Trans";

    AddItem(&cif, NULL, p, iGroupId);
}
//--------------------------------------------------------------------------
void CreateImageFileTrueSize(IMAGEFILEDRAW eDraw, int iGroupId)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_TRUE;
    if (eDraw == IF_TRANS)
        idnum = IDB_TRUE_TRANS;
    else if (eDraw == IF_ALPHA)
        idnum = IDB_TRUE_ALPHA;

    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object that sizes with STRETCH ----
    cif._eBgType = BT_IMAGEFILE;    
    cif._iImageCount = 8;
    cif._fMirrorImage = TRUE;
    cif._eImageLayout = IL_HORIZONTAL;
    cif._ImageInfo.iSingleWidth = 16;
    cif._ImageInfo.iSingleHeight = 16;
    cif._ImageInfo.eSizingType = ST_TRUESIZE;

    if (eDraw == IF_TRANS)
    {
        cif._ImageInfo.fTransparent = TRUE;
        cif._ImageInfo.crTransparent = RGB(255, 0, 255);
    }
    else if (eDraw == IF_ALPHA)
    {
        cif._ImageInfo.fAlphaChannel = TRUE;
    }

    LPCWSTR p = L"TrueSize";
    if (eDraw == IF_TRANS)
        p = L"True+Trans";
    else if (eDraw == IF_ALPHA)
        p = L"True+Alpha";

    AddItem(&cif, NULL, p, iGroupId);
}
//--------------------------------------------------------------------------
void CreateImageFileCharGlyph()
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_GLYPHBG;
    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- specify bg info ----
    cif._eBgType = BT_IMAGEFILE;    
    cif._fMirrorImage = TRUE;
    cif._iImageCount = 3;
    cif._eImageLayout = IL_HORIZONTAL;
    cif._ImageInfo.iSingleWidth = 16;
    cif._ImageInfo.iSingleHeight = 22;
    cif._ImageInfo.eSizingType = ST_STRETCH;

    SetRect((RECT *)&cif._SizingMargins, 1, 1, 1, 1);

    //---- specify the char/font info ----
    cif._eGlyphType = GT_FONTGLYPH;
    cif._crGlyphTextColor = RGB(0, 0, 255);
    cif._iGlyphIndex = 62;
    cif._lfGlyphFont.lfWeight = FW_NORMAL;
    cif._lfGlyphFont.lfHeight = CLIPPER_FONTHEIGHT;
    lstrcpy(cif._lfGlyphFont.lfFaceName, L"marlett");

    //---- specify alignment ----
    cif._eHAlign = HA_CENTER;
    cif._eVAlign = VA_CENTER;

    LPCWSTR p = L"FontGlyph";
    AddItem(&cif, NULL, p, GID_GLYPH);
}
//--------------------------------------------------------------------------
void CreateImageFileImageGlyph(IMAGEFILEDRAW eDraw, BOOL fForceMirror)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_GLYPHBG;
    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- specify bg info ----
    cif._eBgType = BT_IMAGEFILE;  
    cif._fMirrorImage = TRUE;
    cif._eGlyphType = GT_IMAGEGLYPH;
    cif._iImageCount = 3;
    cif._eImageLayout = IL_HORIZONTAL;
    cif._ImageInfo.iSingleWidth = 16;
    cif._ImageInfo.iSingleHeight = 22;
    cif._ImageInfo.eSizingType = ST_STRETCH;

    SetRect((RECT *)&cif._SizingMargins, 1, 1, 1, 1);

    //---- specify glyph info ----
    WCHAR szName[MAX_PATH];
    
    if (eDraw == IF_REG)
    {
        idnum = IDB_GLYPH;
        lstrcpy(szName, L"ImageGlyph");

        cif._GlyphInfo.iSingleWidth = 10;
        cif._GlyphInfo.iSingleHeight = 7;
    }
    else if (eDraw == IF_TRANS)
    {
        idnum = IDB_GLYPH_TRANS;
        lstrcpy(szName, L"ImageTrans");

        cif._GlyphInfo.fTransparent = TRUE;
        cif._GlyphInfo.crTransparent = RGB(255, 0, 255);

        cif._GlyphInfo.iSingleWidth = 10;
        cif._GlyphInfo.iSingleHeight = 7;
    }
    else
    {
        idnum = IDB_GLYPH_ALPHA;
        lstrcpy(szName, L"ImageAlpha");

        cif._GlyphInfo.fAlphaChannel = TRUE;

        cif._GlyphInfo.iSingleWidth = 16;
        cif._GlyphInfo.iSingleHeight = 16;
    }

    cif._GlyphInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)),
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- specify alignment ----
    cif._eHAlign = HA_CENTER;
    cif._eVAlign = VA_CENTER;

    DWORD dwDtbFlags = 0;

    if (fForceMirror)
    {
        dwDtbFlags |= DTBG_MIRRORDC;
        lstrcat(szName, L"+M");
    }

    AddItem(&cif, NULL, szName, GID_GLYPH, 0, dwDtbFlags);
}
//--------------------------------------------------------------------------
void CreateMultiImage()
{
    CMaxImageFile MaxIf;

    memset(&MaxIf, 0, sizeof(MaxIf));

    //---- specify general info ----
    MaxIf._eBgType = BT_IMAGEFILE;  
    MaxIf._fMirrorImage = TRUE;
    MaxIf._iImageCount = 8;
    MaxIf._eImageLayout = IL_VERTICAL;
    MaxIf._eImageSelectType = IST_SIZE;
    MaxIf._iMultiImageCount = 3;
    MaxIf._iTrueSizeStretchMark = 50;
    MaxIf._eTrueSizeScalingType = TSST_SIZE;
    MaxIf._fUniformSizing = TRUE;
    MaxIf._eHAlign = HA_CENTER;
    MaxIf._eVAlign = VA_CENTER;
    
    int iUsageSizes[] = {20, 24, 32};

    //---- specify alignment ----
    MaxIf._eHAlign = HA_CENTER;
    MaxIf._eVAlign = VA_CENTER;

    for (int i=0; i < MaxIf._iMultiImageCount; i++)
    {
        int idnum = IDB_MULTI1 + i;

        DIBINFO *pdi = &MaxIf.MultiDibs[i];

        pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        pdi->szMinSize.cx = iUsageSizes[i];
        pdi->szMinSize.cy = iUsageSizes[i];

        //---- get bitmap width/height ----
        BITMAP bm;
        GetObject(pdi->hProcessBitmap, sizeof bm, &bm);

        pdi->iSingleWidth = bm.bmWidth;
        pdi->iSingleHeight = bm.bmHeight/8;
        pdi->eSizingType = ST_TRUESIZE;
        pdi->fAlphaChannel = TRUE;
    }

    //---- set primary image ----
    MaxIf._ImageInfo = MaxIf.MultiDibs[0];

    AddItem(&MaxIf, NULL, L"MultiImage", GID_MULTIIMAGE);
}
//--------------------------------------------------------------------------
void CreateTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 128, 128);        // red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    lstrcpy(td._lfFont.lfFaceName, L"arial");

    AddItem(NULL, &td, L"TextObj", GID_TEXT);
}
//--------------------------------------------------------------------------
void CreateShadowTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 139, 139);        // light red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    lstrcpy(td._lfFont.lfFaceName, L"arial");

    //---- shadow ----
    td._ptShadowOffset.x = 2;
    td._ptShadowOffset.y = 2;
    td._crShadow = RGB(149, 0, 0);          // dark red
    td._eShadowType = TST_SINGLE;

    AddItem(NULL, &td, L"ShadowText", GID_TEXT);
}
//--------------------------------------------------------------------------
void CreateBorderTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 139, 139);        // light red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    lstrcpy(td._lfFont.lfFaceName, L"arial");

    //---- border ----
    td._iBorderSize = 1;
    td._crBorder = RGB(128, 128, 255);      // light blue

    AddItem(NULL, &td, L"BorderText", GID_TEXT);
}
//--------------------------------------------------------------------------
void CreateBorderShadowTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 139, 139);        // light red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    lstrcpy(td._lfFont.lfFaceName, L"arial");

    //---- shadow ----
    td._ptShadowOffset.x = 2;
    td._ptShadowOffset.y = 2;
    td._crShadow = RGB(149, 0, 0);          // dark red
    td._eShadowType = TST_SINGLE;

    //---- border ----
    td._iBorderSize = 1;
    td._crBorder = RGB(0, 0, 0);      // black

    AddItem(NULL, &td, L"BorderShadow", GID_TEXT);
}
//--------------------------------------------------------------------------
void CreateBlurShadowTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 139, 139);        // light red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    lstrcpy(td._lfFont.lfFaceName, L"arial");

    //---- shadow ----
    td._ptShadowOffset.x = 2;
    td._ptShadowOffset.y = 2;
    td._crShadow = RGB(149, 0, 0);          // dark red
    td._eShadowType = TST_CONTINUOUS;

    AddItem(NULL, &td, L"BlurShadow", GID_TEXT);
}
//--------------------------------------------------------------------------
void LabelClip(HDC hdc, RECT *prc, int iColIndex, LPCWSTR pszName)
{
    int left = prc->left + (iColIndex+1)*szCell.cx;
    int top = prc->top + 6;    // some padding from very top of window

    //---- manual page clipping ----
    if ((top + szCell.cy) < 0)
        return;
    if (top > iVertPageSize)
        return;

    TextOut(hdc, left, top, pszName, wcslen(pszName));
}
//--------------------------------------------------------------------------
void CreateDrawObjects()
{
    //---- borderfill group ----
    CreateBorderFillNoDraw();
    CreateBorderFillSquare();
    CreateBorderFillBorder();
    CreateBorderFillCircle();
    CreateBorderFillGradient();
    CreateBorderFillCircleGradient();

    //---- imagefile group ----
    CreateImageFileStretch(IF_REG, GID_IMAGEFILE);
    CreateImageFileStretch(IF_TRANS, GID_IMAGEFILE);
    CreateImageFileTile(IF_REG, GID_IMAGEFILE);
    CreateImageFileTile(IF_TRANS, GID_IMAGEFILE);

    CreateImageFileTrueSize(IF_REG, GID_IMAGEFILE);
    CreateImageFileTrueSize(IF_TRANS, GID_IMAGEFILE);
    CreateImageFileTrueSize(IF_ALPHA, GID_IMAGEFILE);

    //---- glyph group ----
    //CreateImageFileCharGlyph();
    CreateImageFileImageGlyph(IF_REG, FALSE);
    CreateImageFileImageGlyph(IF_TRANS, FALSE);
    CreateImageFileImageGlyph(IF_TRANS, TRUE);
    CreateImageFileImageGlyph(IF_ALPHA, FALSE);

    //---- MultiImage group ----
    CreateMultiImage();

    //---- text group ----
    CreateTextObj();
    CreateShadowTextObj();
    CreateBorderTextObj();
    CreateBorderShadowTextObj();
    CreateBlurShadowTextObj();

    //---- borders group ----
    CreateImageFileBorder(ST_TRUESIZE, FALSE, FALSE);
    CreateImageFileBorder(ST_STRETCH, FALSE, FALSE);
    CreateImageFileBorder(ST_STRETCH, TRUE, TRUE);
    CreateImageFileBorder(ST_TILE, TRUE, TRUE);

    //---- SrcSizing group ----
    CreateImage(IDB_PUSHBUTTON, 5, ST_STRETCH, TRUE, GID_SRCSIZING, L"PushButton",
        8, 8, 9, 9);

    CreateRadioImage();

    CreateCheckImage();

    CreateScrollGlyph();

    CreateProgressTrack();

    CreateProgressChunk();
}
//--------------------------------------------------------------------------
void CenterRect(POINT &ptCenter, int iSize, RECT *prc)
{
    int iSizeA = iSize/2;
    int iSizeB = iSize - iSizeA;

    prc->left = ptCenter.x - iSizeA;
    prc->right = ptCenter.x + iSizeB;
    
    prc->top = ptCenter.y - iSizeA;
    prc->bottom = ptCenter.y + iSizeB;
}
//--------------------------------------------------------------------------
void DrawMultiImages(HDC hdc, RECT *prc, HTHEME hTheme)
{
    SIZE szMyCell = {80, 80};

    int iRowIndex = 0;
    int iSizes[] = {12, 16, 20, 24, 32, 48, 64};

    //---- draw various sizes of image ----
    for (int iIndex=0; iIndex < ARRAYSIZE(iSizes); iIndex++)
    {
        int iSize = iSizes[iIndex];

        //---- label object on left ----
        int left = prc->left + 4;        // some padding away from edge
        int top = prc->top + (iRowIndex)*szMyCell.cy + 18;  // try to center

        //---- manual page clipping ----
        if ((top + szMyCell.cy) < 0)
            return;
        if (top > iVertPageSize)
            return;

        WCHAR szName[MAX_PATH];
        wsprintf(szName, L"Size: %d", iSize);

        TextOut(hdc, left, top+15, szName, wcslen(szName));

        //---- draw image in all of its states ----
        int iPartId = BP_RADIOBUTTON;

        for (int iStateId=RBS_UNCHECKEDNORMAL; iStateId <= RBS_CHECKEDDISABLED; iStateId++)
        {
            left += szMyCell.cx;

            RECT rc = {left, top, left+szMyCell.cx, top+szMyCell.cy};

            //---- draw purple target dashed rect ----
            DrawTargetRect(hdc, &rc, RGB(128, 128, 255));

            //---- calc center pt ----
            POINT ptCenter = {left + szMyCell.cx/2, top + szMyCell.cy/2};

            //---- rect to draw into ----
            CenterRect(ptCenter, iSize, &rc);

            //---- draw red rect for "draw into" rect ----
            DrawTargetRect(hdc, &rc, RGB(255, 0, 0));

            HRESULT hr = DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rc, NULL);

            if (FAILED(hr))
            {
                WCHAR buff[100];
                wsprintf(buff, L"DrawThemeBackground err: hr=0x%x, irow=%d, iPartId=%d", 
                    hr, iRowIndex, iPartId);

                //MessageBox(NULL, buff, L"Error", MB_OK);
            }
        }

        iRowIndex++;
    }
}
//--------------------------------------------------------------------------
void DrawBorders(HDC hdc, RECT *prc, TESTITEM *pTestItem)
{
    int top = prc->top + 4;
    int left = prc->left + 6;
    
    //---- message on top line ----
    WCHAR szBuff[100];
    lstrcpy(szBuff, L"Image: BorderTest.bmp, 18x17, 24 bit, Sizing Margins: 3, 3, 3, 3");
    TextOut(hdc, left, top+15, szBuff, wcslen(szBuff));
    top += 44;

    //---- FIRST row: draw border test obj in 6 different sizes ----
    SIZE szMyCell = {120, 120};

    //---- manual page clipping ----
    if (((top + szMyCell.cy) >= 0) && (top <= iVertPageSize))
    {
        LPCWSTR pszLabels [] = { L"TrueSize", L"Stretch", L"Stretch", L"Stretch",
            L"Stretch", L"Stretch", L"Stretch"};
        SIZE szSizes[] = { {60, 40}, {60, 40}, {6, 40}, {3, 40}, {60, 6}, {60, 2}, {2, 3} };

        //---- draw various sizes of image ----
        for (int iIndex=0; iIndex < ARRAYSIZE(szSizes); iIndex++)
        {
            SIZE sz = szSizes[iIndex];

            //---- label object on top ----
            left = prc->left + iIndex*szMyCell.cx + 6;        // some padding away from edge

            wsprintf(szBuff, L"%s (%dx%d)", pszLabels[iIndex], sz.cx, sz.cy);

            TextOut(hdc, left, top+15, szBuff, wcslen(szBuff));

            //---- draw image ----
            RECT rc = {left, top+50, left+sz.cx, top+50+sz.cy};

            int i = (iIndex==0) ? 0 : 1;

            HRESULT hr = DrawThemeBackground(pTestItem[i].hTheme, hdc, 0, 0, &rc, NULL);

            if (FAILED(hr))
            {
                WCHAR buff[100];
                wsprintf(buff, L"DrawThemeBackground err in DrawBorders: hr=0x%x, iIndex=%d", 
                    hr, iIndex);

                //MessageBox(NULL, buff, L"Error", MB_OK);
            }
        }
    }

    //---- SECOND row: draw 2 other border objects real big (test border scaling) ----
    top += szMyCell.cy;

    szMyCell.cx = 380;
    szMyCell.cy = 300;

    SIZE sz = {szMyCell.cx - 30, szMyCell.cy - (50 + 10)};

    //---- manual page clipping: first row ----
    if (((top + szMyCell.cy) >= 0) && (top <= iVertPageSize))
    {
        LPCWSTR pszLabels [] = { L"Border Scaling (stretch)", L"Border Scaling (tile)"};

        //---- draw various sizes of image ----
        for (int iIndex=0; iIndex < ARRAYSIZE(pszLabels); iIndex++)
        {
            //---- label object on top ----
            int left = prc->left + iIndex*szMyCell.cx + 6;        // some padding away from edge

            TextOut(hdc, left, top+15, pszLabels[iIndex], wcslen(pszLabels[iIndex]));

            //---- draw image ----
            RECT rc = {left, top+50, left+sz.cx, top+50+sz.cy};

            HRESULT hr = DrawThemeBackground(pTestItem[2+iIndex].hTheme, hdc, 0, 0, &rc, NULL);

            if (FAILED(hr))
            {
                WCHAR buff[100];
                wsprintf(buff, L"DrawThemeBackground err in DrawBorders: hr=0x%x, iIndex=%d", 
                    hr, iIndex);

                //MessageBox(NULL, buff, L"Error", MB_OK);
            }
        }
    }
}
//--------------------------------------------------------------------------
void DrawSrcSizing(HDC hdc, RECT *prc, TESTITEM *pTestItem)
{
    SIZE szMyCell = {120, 110};

    int top = prc->top + 4;
    int left = prc->left + szMyCell.cx + 6;
    
    //---- labels on top line ----
    LPCWSTR TopLabels[] = {L"Small", L"Regular", L"Large", L"High DPI"};

    SIZE szStretchSizes[] = { {50, 6}, {75, 23}, {90, 65}, {340, 100} };
    SIZE szTrueSizes[] = { {10, 6}, {13, 13}, {30, 30}, {340, 100} };

    int iStates[] = {5, 6, 6, 0, 0};

    for (int i=0; i < ARRAYSIZE(TopLabels); i++)
    {
        TextOut(hdc, left, top, TopLabels[i], wcslen(TopLabels[i]));
        left += szMyCell.cx;
    }

    top += 30;

    //---- draw rows ----
    for (int iRow=0; iRow < 5; iRow++)
    {
        //---- draw name on left ----
        left = prc->left + 6;
        
        WCHAR *pszName = pTestItem[iRow].szName;

        TextOut(hdc, left, top-5, pszName, wcslen(pszName));

        for (int iSize=0; iSize < ARRAYSIZE(szStretchSizes); iSize++)
        {
            left += szMyCell.cx;
            SIZE *psz;

            if ((iRow > 0) && (iRow < 4))
            {
                psz = &szTrueSizes[iSize];
            }
            else
            {
                psz = &szStretchSizes[iSize];
            }

            RECT rc = {left, top, left + psz->cx, top + psz->cy};
            
            HTHEME hTheme = pTestItem[iRow].hTheme;

            if (hTheme)
            {
                DrawThemeBackground(hTheme, hdc, 0, iStates[iRow], &rc, NULL);
                if (iRow == 4)      // progress control
                {
                    RECT rcContent;

                    GetThemeBackgroundContentRect(hTheme, hdc, 
                        0, 0, &rc, &rcContent);
                    
                    DrawThemeBackground(pTestItem[5].hTheme, hdc, 0, iStates[iRow], &rcContent, NULL);
                }
            }

        }

        top += szMyCell.cy;
    }
}
//--------------------------------------------------------------------------
void PaintObjects(HDC hdc, RECT *prc, int iGroupId)
{
    //---- select in a fixed size font for resolution-independent bits ----
    HFONT hfFixedSize = CreateFont(18, 6, 0, 0, FW_NORMAL, 0, 0, 0, ANSI_CHARSET, 
        0, 0, 0, 0, L"MS Sans Serif");
    HFONT hOldFont = (HFONT)SelectObject(hdc, hfFixedSize);

    RECT rc = *prc;

    rc.top -= iVertOffset;
    rc.bottom -= iVertOffset;

    if (iGroupId == GID_TEXT)      // text object
    {
        for (int i=0; i < iItemCount[iGroupId]; i++)
        {
            DrawTextObjects(TestItems[iGroupId][i].hTheme, hdc, &rc, i, 
                TestItems[iGroupId][i].szName);
        }
    }
    else if (iGroupId == GID_MULTIIMAGE)
    {
        DrawMultiImages(hdc, prc, TestItems[iGroupId][0].hTheme);
    }
    else if (iGroupId == GID_BORDERS)
    {
        DrawBorders(hdc, prc, TestItems[iGroupId]);
    }
    else if (iGroupId == GID_SRCSIZING)
    {
        DrawSrcSizing(hdc, prc, TestItems[iGroupId]);
    }
    else
    {
        LabelClip(hdc, &rc, 0, L"NoClip");   
        LabelClip(hdc, &rc, 1, L"OverClip");
        LabelClip(hdc, &rc, 2, L"ExactClip");
        LabelClip(hdc, &rc, 3, L"PartialClip");
        LabelClip(hdc, &rc, 4, L"InOut1");
        LabelClip(hdc, &rc, 5, L"InOut2");
        LabelClip(hdc, &rc, 6, L"OutClip");

        for (int i=0; i < iItemCount[iGroupId]; i++)
        {
            DrawClips(TestItems[iGroupId][i].hTheme, hdc, &rc, i, 
                TestItems[iGroupId][i].szName, TestItems[iGroupId][i].dwDtbFlags);
        }
    }

    //---- restore the font ----
    SelectObject(hdc, hOldFont);

    DeleteObject(hfFixedSize);
}
//--------------------------------------------------------------------------
void RegisterWindowClasses()
{
        WNDCLASSEX wcex;
        wcex.cbSize = sizeof(WNDCLASSEX); 

    //---- register MAIN window class ----
        wcex.style                      = 0;
        wcex.lpfnWndProc        = (WNDPROC)MainWndProc;
        wcex.cbClsExtra         = 0;
        wcex.cbWndExtra         = 0;
        wcex.hInstance          = hInst;
        wcex.hIcon                      = LoadIcon(hInst, (LPCTSTR)IDI_CLIPPER);
        wcex.hCursor            = LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground      = (HBRUSH)(COLOR_WINDOW+1);
        wcex.lpszMenuName       = (LPCWSTR)IDC_CLIPPER;
        wcex.lpszClassName      = pszMainWindowClass;
        wcex.hIconSm            = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

        RegisterClassEx(&wcex);

    //---- register DISPLAY window class ----
        wcex.style                      = CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc        = (WNDPROC)DisplayWndProc;
        wcex.cbClsExtra         = 0;
        wcex.cbWndExtra         = 0;
        wcex.hInstance          = hInst;
        wcex.hIcon                      = LoadIcon(hInst, (LPCTSTR)IDI_CLIPPER);
        wcex.hCursor            = LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground      = (HBRUSH)(COLOR_WINDOW+1);
        wcex.lpszMenuName       = (LPCWSTR)IDC_CLIPPER;
        wcex.lpszClassName      = pszDisplayWindowClass;
        wcex.hIconSm            = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

        RegisterClassEx(&wcex);
}
//--------------------------------------------------------------------------
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

   CreateDrawObjects();

   if (! CreateAllWindows())
       return FALSE;

   ShowWindow(hwndMain, nCmdShow);
   UpdateWindow(hwndMain);

   return TRUE;
}
//--------------------------------------------------------------------------
void HandleVScroll(int message, WPARAM wParam, LPARAM lParam)
{
    int iOldVertOffset = iVertOffset;

    if (message == WM_VSCROLL)
    {
        switch (LOWORD(wParam))
        {
            case SB_LINEUP:
                iVertOffset -= iVertLineSize;
                break;

            case SB_LINEDOWN:
                iVertOffset += iVertLineSize;
                break;

            case SB_PAGEUP:
                iVertOffset -= iVertPageSize;
                break;

            case SB_PAGEDOWN:
                iVertOffset += iVertPageSize;
                break;

            case SB_THUMBPOSITION:
                iVertOffset = HIWORD(wParam);
                break;
        }
    }
    else        // mouse wheel
    {
        iVertOffset -= (GET_WHEEL_DELTA_WPARAM(wParam)/10);
    }

    //---- keep in valid range ----
    if (iVertOffset < 0)
    {
        iVertOffset = 0;
    }
    else if (iVertOffset > iMaxVertOffset)
    {
        iVertOffset = iMaxVertOffset;
    }

    //---- scroll or repaint, as needed ----
    if (iVertOffset != iOldVertOffset)
    {
        SetScrollPos(hwndDisplay, SB_VERT, iVertOffset, TRUE);

        int iDiff = (iVertOffset - iOldVertOffset);

        if (abs(iDiff) >= iVertPageSize)
        {
            InvalidateRect(hwndDisplay, NULL, TRUE);
        }
        else
        {
            ScrollWindowEx(hwndDisplay, 0, -iDiff, NULL, NULL, NULL, 
                NULL, SW_INVALIDATE | SW_ERASE);
        }
    }
}
//--------------------------------------------------------------------------
void OnDisplayResize()
{
    int iTabNum = TabCtrl_GetCurSel(hwndTab);
    if (iTabNum < 0)
        iTabNum = 0;

    int iGroupId = iTabNum/2;

    RECT rc;
    GetClientRect(hwndDisplay, &rc);
    iVertPageSize = RECTHEIGHT(rc);

    iMaxVertOffset = ((iItemCount[iGroupId]+1)*szCell.cy) - iVertPageSize;
    if (iMaxVertOffset < 0)
        iMaxVertOffset = 0;

    if (iVertOffset > iMaxVertOffset)
        iVertOffset = iMaxVertOffset;

    //---- set scrolling info ----
    SetScrollRange(hwndDisplay, SB_VERT, 0, iMaxVertOffset, FALSE);
    SetScrollPos(hwndDisplay, SB_VERT, iVertOffset, TRUE);
}
//--------------------------------------------------------------------------
LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        int wmId, wmEvent;
    int iWidth, iHeight;

        switch (message) 
        {
                case WM_COMMAND:
                        wmId    = LOWORD(wParam); 
                        wmEvent = HIWORD(wParam); 
                        // Parse the menu selections:
                        switch (wmId)
                        {
                                case IDM_ABOUT:
                                   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
                                   break;
                                case IDM_EXIT:
                                   DestroyWindow(hWnd);
                                   break;
                                default:
                                   return DefWindowProc(hWnd, message, wParam, lParam);
                        }
                        break;

       case WM_NOTIFY: 
            NMHDR *phdr;
            phdr = (NMHDR *)lParam;
            if (phdr->code == TCN_SELCHANGE)    // tab selection
            {
                iVertOffset = 0;
                OnDisplayResize();
                InvalidateRect(hwndDisplay, NULL, TRUE);
            }
            break; 

        case WM_SIZE:
            iWidth = LOWORD(lParam);
            iHeight = HIWORD(lParam);

            MoveWindow(hwndTab, 0, 0, iWidth, iHeight, TRUE);

            RECT rc;
            SetRect(&rc, 0, 0, iWidth, iHeight);
            TabCtrl_AdjustRect(hwndTab, FALSE, &rc);

            MoveWindow(hwndDisplay, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), TRUE);
            break;

        case WM_MOUSEWHEEL:
            HandleVScroll(message, wParam, lParam);
            return 0;

                case WM_DESTROY:
                        PostQuitMessage(0);
                        break;

                default:
                        return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
//--------------------------------------------------------------------------
LRESULT CALLBACK DisplayWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        int wmId, wmEvent;
        PAINTSTRUCT ps;
        HDC hdc;

    int iTabNum = TabCtrl_GetCurSel(hwndTab);
    if (iTabNum < 0)
        iTabNum = 0;

    int iGroupId = iTabNum/2;

        switch (message) 
        {
            case WM_COMMAND:
                    wmId    = LOWORD(wParam); 
                    wmEvent = HIWORD(wParam); 
                    // Parse the menu selections:
                    switch (wmId)
                    {
                            case IDM_ABOUT:
                               DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
                               break;
                            case IDM_EXIT:
                               DestroyWindow(hWnd);
                               break;
                            default:
                               return DefWindowProc(hWnd, message, wParam, lParam);
                    }
                    break;

            case WM_PAINT:
                RECT rt;

                hdc = BeginPaint(hWnd, &ps);

                if (iTabNum % 2)       // if its a mirrored page
                    SetLayout(hdc, LAYOUT_RTL);
                else
                    SetLayout(hdc, 0);

                GetClientRect(hWnd, &rt);
                    
                PaintObjects(hdc, &rt, iGroupId);

                EndPaint(hWnd, &ps);
                break;

            case WM_VSCROLL:
                HandleVScroll(message, wParam, lParam);
                return 0;

            case WM_SIZE:
                OnDisplayResize();
                break;

            case WM_DESTROY:
                PostQuitMessage(0);
                break;

            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
//--------------------------------------------------------------------------
BOOL CreateAllWindows()
{
    TCITEM tci = {0};
    BOOL fOk = FALSE;
    int i;

    //---- create main window ----
    hwndMain = CreateWindow(pszMainWindowClass, L"Clipper", WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInst, NULL);
    if (! hwndMain)
        goto exit;

    //---- create tab control covering main client area ----
    RECT rc;
    GetClientRect(hwndMain, &rc);
                        
    hwndTab = CreateWindowEx(0, WC_TABCONTROL, L"", 
        WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|TCS_MULTILINE|TCS_HOTTRACK|WS_VISIBLE,
        rc.left, rc.top, (int)RECTWIDTH(&rc), (int)RECTHEIGHT(&rc), hwndMain, NULL, hInst, NULL);
    if (! hwndTab)
        goto exit;

    //---- create the display window in the tab control "display area" ----
    hwndDisplay = CreateWindow(pszDisplayWindowClass, L"", WS_CHILD|WS_VSCROLL|WS_VISIBLE,
        rc.left, rc.top, (int)RECTWIDTH(&rc), (int)RECTHEIGHT(&rc), hwndTab, NULL, hInst, NULL);
    if (! hwndDisplay)
        goto exit;

    //---- add tab pages ----
    tci.mask = TCIF_TEXT;

    TabCtrl_SetPadding(hwndTab, 7, 3);

    for (i=0; i < ARRAYSIZE(szPageNames); i++)
    {
        tci.pszText = (LPWSTR)szPageNames[i];
        SendMessage(hwndTab, TCM_INSERTITEM, i, (LPARAM)&tci);
    }

    fOk = TRUE;

exit:
    return fOk;
}
//--------------------------------------------------------------------------
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
        switch (message)
        {
                case WM_INITDIALOG:
                                return TRUE;

                case WM_COMMAND:
                        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
                        {
                                EndDialog(hDlg, LOWORD(wParam));
                                return TRUE;
                        }
                        break;
        }

    return FALSE;
}
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\clipper\clipper.h ===
#if !defined(AFX_CLIPPER_H__C0921B21_C177_4FD2_A049_D548235D340A__INCLUDED_)
#define AFX_CLIPPER_H__C0921B21_C177_4FD2_A049_D548235D340A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_CLIPPER_H__C0921B21_C177_4FD2_A049_D548235D340A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\clipper\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Clipper.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\clipper\stdafx.h ===
//---------------------------------------------------------------------------
// stdafx.h : include file for standard system include files
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <atlbase.h>

#include <uxthemep.h>
#include <tmschema.h>
//---------------------------------------------------------------------------
#define WIDTH(rc) ((rc).right - (rc).left)
#define HEIGHT(rc) ((rc).bottom - (rc).top)

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\clipper\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by CLIPPER.RC
//
#define IDR_MAINFRAME				128
#define IDD_CLIPPER_DIALOG		    102
#define IDD_ABOUTBOX				103
#define IDS_APP_TITLE				103
#define IDM_ABOUT					104
#define IDM_EXIT					105
#define IDS_HELLO					106
#define IDI_CLIPPER	                107
#define IDI_SMALL					108
#define IDC_CLIPPER	                109
#define IDC_MYICON					2
#define IDC_STATIC	                -1

#define IDB_STRETCH                 110
#define IDB_STRETCH_TRANS           111

#define IDB_TILE                    112
#define IDB_TILE_TRANS              113

#define IDB_TRUE                    114
#define IDB_TRUE_TRANS              115
#define IDB_TRUE_ALPHA              116

#define IDB_GLYPHBG                 117

#define IDB_GLYPH                   118
#define IDB_GLYPH_TRANS             119
#define IDB_GLYPH_ALPHA             120

#define IDB_MULTI1                  121
#define IDB_MULTI2                  122
#define IDB_MULTI3                  123
#define IDB_MULTI4                  124

#define IDB_BORDERTEST              125

#define IDB_PUSHBUTTON              130
#define IDB_CHECKBOX                131

#define IDB_RADIO13                 140
#define IDB_RADIO16                 141
#define IDB_RADIO25                 142

#define IDB_CHECK13                 150
#define IDB_CHECK16                 151
#define IDB_CHECK25                 152

#define IDB_PROGRESS_TRACK          160
#define IDB_PROGRESS_CHUNK          161

#define IDB_SCROLL_ARROWS           170
#define IDB_SCROLL_GLPYHS           171


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        180
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           150
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\imagecon\imagecon.cpp ===
//---------------------------------------------------------------------------
//  ImageCon.cpp - converts from one file format to another
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <uxthemep.h>
#include <utils.h>
#include "SimpStr.h"
#include "Scanner.h"
#include "shlwapip.h"
#include "themeldr.h"
//---------------------------------------------------------------------------
void PrintUsage()
{
    wprintf(L"\nUsage: imagecon <input name> <output name> \n");
    wprintf(L"\n");
}
//---------------------------------------------------------------------------
extern "C" WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE previnst, 
    LPTSTR pszCmdLine, int nShowCmd)
{
    //---- initialize globals from themeldr.lib ----
    ThemeLibStartUp(FALSE);

    WCHAR szOutput[_MAX_PATH+1] = {0};
    WCHAR szInput[_MAX_PATH+1] = {0};
    BOOL fQuietRun = FALSE;

    if (! fQuietRun)
    {
        wprintf(L"Microsoft (R) Image Converter (Version .1)\n");
        wprintf(L"Copyright (C) Microsoft Corp 2000. All rights reserved.\n");
    }

    CScanner scan(pszCmdLine);

    BOOL gotem = scan.GetFileName(szInput, ARRAYSIZE(szInput));
    if (gotem)
        gotem = scan.GetFileName(szOutput, ARRAYSIZE(szOutput));

    if (! gotem)
    {
        PrintUsage(); 
        return 1;
    }

    HRESULT hr = S_OK;

    if (! FileExists(szInput))
        hr = MakeError32(STG_E_FILENOTFOUND);       
    else
    {
        //---- protect ourselves from crashes ----
        try
        {
            hr = SHConvertGraphicsFile(szInput, szOutput, SHCGF_REPLACEFILE);
        }
        catch (...)
        {
            hr = MakeError32(E_FAIL);
        }
    }

    if ((SUCCEEDED(hr)) && (! FileExists(szOutput)))
        hr = MakeError32(E_FAIL);

    if (FAILED(hr))
    {
        LPWSTR pszMsgBuff;

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM 
            | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr, 
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&pszMsgBuff, 0, NULL);

        printf("Error in converting: %S", pszMsgBuff);
        return 1;
    }

    printf("Converted image file to: %S\n", szOutput);
    return 0;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\imagecon\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set 
//---------------------------------------------------------------------------
#ifndef _STDAFX_H_
#define _STDAFX_H_
//---------------------------------------------------------------------------
#define _iswupper(_c)    ( iswctype(_c,_UPPER) )
#define _iswlower(_c)    ( iswctype(_c,_LOWER) )
#define _iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define _iswxdigit(_c)   ( iswctype(_c,_HEX) )
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define STRICT
#define _ATL_NO_ATTRIBUTES
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
//---------------------------------------------------------------------------
#include "log.h"
#include "errors.h"
#include "utils.h"
//---------------------------------------------------------------------------
#include <atlbase.h> 
//---------------------------------------------------------------------------
#endif //_STDAFX_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\imagecon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PackThem.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\imagecon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ImageCon.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\autos.h ===
//-------------------------------------------------------------------------
//	Autos.h - resource holder classes that automatically return their resource
//            resources in the destructors.  These can be declared on the stack
//            to free resources whenever the enclosing block is exited or 
//            as class member variables that free the associated resources
//            when the containing object is destroyed.
//-------------------------------------------------------------------------
#ifndef _AUTOS_H_
#define _AUTOS_H_
//-------------------------------------------------------------------------
#include "errors.h"
//-------------------------------------------------------------------------
class COptionalDC
{
public:
    COptionalDC(HDC hdcOpt)
    {
        _hdc = hdcOpt;
        _fReleaseDC = FALSE;

        if (! _hdc)
        {
            _hdc = GetWindowDC(NULL);
            if (_hdc)
            {
                _fReleaseDC = TRUE;
            }
        }
    }

    operator HDC()
    {
        return _hdc;
    }

    ~COptionalDC()
    {
        if (_fReleaseDC)
        {
            ReleaseDC(NULL, _hdc);
        }
    }

private:
    HDC _hdc;
    BOOL _fReleaseDC;
};
//-------------------------------------------------------------------------
template <class T>
class CAutoGDI 
{
public:
    CAutoGDI(T Value=NULL)
    {
        _Handle = Value;
    }

    ~CAutoGDI()
    {
        if (_Handle)
            DeleteObject(_Handle);
    }

    T & operator = (T Value) 
    {
        if (_Handle)
            DeleteObject(_Handle);

        _Handle = Value;

        return _Handle;
    }

    operator T() const
    {
        return _Handle;
    }


protected:
    T _Handle;
};
//------------------------------------------------------------------------------------
class CAutoDC
{
public:
    CAutoDC(HDC Value=NULL)
    {
        _hdc = Value;

        _fOldPen = FALSE;
        _fOldBrush = FALSE;
        _fOldBitmap = FALSE;
        _fOldFont = FALSE;
        _fOldRegion = FALSE;
    }

    ~CAutoDC()
    {
        RestoreObjects();
    }

    HDC & operator = (HDC &Value) 
    {
        if (_hdc)
            RestoreObjects();

        _hdc = Value;

        return _hdc;
    }

    operator HDC() const
    {
        return _hdc;
    }

    void RestoreObjects()
    {
        if (_fOldBitmap)
        {
            SelectObject(_hdc, _hOldBitmap);
            _fOldBitmap = FALSE;
        }

        if (_fOldFont)
        {
            SelectObject(_hdc, _hOldFont);
            _fOldFont = FALSE;
        }

        if (_fOldPen)
        {
            SelectObject(_hdc, _hOldPen);
            _fOldPen = FALSE;
        }

        if (_fOldBrush)
        {
            SelectObject(_hdc, _hOldBrush);
            _fOldBrush = FALSE;
        }

        if (_fOldRegion)
        {
            SelectObject(_hdc, _hOldRegion);
            _fOldRegion = FALSE;
        }
    }

    inline HBITMAP SelectBitmap(HBITMAP hValue)
    {
        if (! _fOldBitmap)
        {
            _fOldBitmap = TRUE;
            _hOldBitmap = (HBITMAP)SelectObject(_hdc, hValue);
            return _hOldBitmap;
        }
        return (HBITMAP)SelectObject(_hdc, hValue);
    }

    inline HFONT SelectFont(HFONT hValue)
    {
        if (! _fOldFont)
        {
            _fOldFont = TRUE;
            _hOldFont = (HFONT)SelectObject(_hdc, hValue);
            return _hOldFont;
        }
        return (HFONT)SelectObject(_hdc, hValue);
    }

    inline HBRUSH SelectBrush(HBRUSH hValue)
    {
        if (! _fOldBrush)
        {
            _fOldBrush = TRUE;
            _hOldBrush = (HBRUSH)SelectObject(_hdc, hValue);
            return _hOldBrush;
        }

        return (HBRUSH) SelectObject(_hdc, hValue);
    }

    inline HPEN SelectPen(HPEN hValue)
    {
        if (! _fOldPen)
        {
            _fOldPen = TRUE;
            _hOldPen = (HPEN)SelectObject(_hdc, hValue);
            return _hOldPen;
        }
        return (HPEN)SelectObject(_hdc, hValue);
    }

    inline HRGN SelectRegion(HRGN hValue)
    {
        if (! _fOldRegion)
        {
            _fOldRegion = TRUE;
            _hOldRegion = (HRGN)SelectObject(_hdc, hValue);
            return _hOldRegion;
        }
        return (HRGN)SelectObject(_hdc, hValue);
    }


protected:
    HDC _hdc;

    BOOL _fOldBitmap;
    BOOL _fOldFont;
    BOOL _fOldBrush;
    BOOL _fOldPen;
    BOOL _fOldRegion;

    HBITMAP _hOldBitmap;
    HFONT _hOldFont;
    HBRUSH _hOldBrush;
    HPEN _hOldPen;
    HRGN _hOldRegion;
};
//------------------------------------------------------------------------------------
class CAutoCS
{
public:
    CAutoCS(CRITICAL_SECTION *pcs)
    {
        _pcs = pcs;
        EnterCriticalSection(_pcs);
    }

    ~CAutoCS()
    {
        LeaveCriticalSection(_pcs);
    }

protected:
    CRITICAL_SECTION *_pcs;
};
//------------------------------------------------------------------------------------
class CSaveClipRegion
{
public:
    CSaveClipRegion()
    {
        _hRegion = NULL;
        _fSaved = FALSE;
    }

    HRESULT Save(HDC hdc)
    {
        HRESULT hr;
        int iRetVal;

        if (! _hRegion)
        {
            _hRegion = CreateRectRgn(0, 0, 1, 1);      
            if (! _hRegion)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }

        iRetVal = GetClipRgn(hdc, _hRegion);
        if (iRetVal == -1)
        {
            hr = MakeErrorLast();
            goto exit;
        }

        if (iRetVal == 0)       // no previous region
        {
            DeleteObject(_hRegion);
            _hRegion = NULL;
        }

        _fSaved = TRUE;
        hr = S_OK;

exit:
        return hr;

    }

    HRESULT Restore(HDC hdc)
    {
        if (_fSaved)
        {
            //---- works for both NULL and valid _hRegion ----
            SelectClipRgn(hdc, _hRegion);
        }

        return S_OK;
    }


    ~CSaveClipRegion()
    {
        if (_hRegion)
        {
            DeleteObject(_hRegion);
            _hRegion = NULL;
        }
    }

protected:
    HRGN _hRegion;
    BOOL _fSaved;
};
//------------------------------------------------------------------------------------
template <class T>
class CAutoArrayPtr
{
public:
    CAutoArrayPtr(T *pValue=NULL)
    {
        _pMem = pValue;
    }

    ~CAutoArrayPtr()
    {
        if (_pMem)
            delete [] _pMem;
    }

    T * operator = (T *pValue) 
    {
        if (_pMem)
            delete [] _pMem;

        _pMem = pValue;
        return _pMem;
    }

    T & operator [] (int iIndex) const
    {
        return _pMem[iIndex];
    }

    operator T*() const
    {
        return _pMem;
    }

    bool operator!() const
	{
		return (_pMem == NULL);
	}

	T** operator&()
	{
		return &_pMem;
	}

protected:
    T *_pMem;
};
//------------------------------------------------------------------------------------
#endif      // _AUTOS_H_
//------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\errors.h ===
//---------------------------------------------------------------------------
//    errors.h - support for creating and reporting errors
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#ifndef ERRORS_H
#define ERRORS_H
//---------------------------------------------------------------------------
typedef struct            // records theme api's last error return code
{
    DWORD dwParseErrCode;  
    WCHAR szMsgParam1[MAX_PATH];
    WCHAR szMsgParam2[MAX_PATH];
    WCHAR szFileName[MAX_PATH];
    WCHAR szSourceLine[MAX_PATH];
    int iLineNum;
} TMERRINFO;
//---------------------------------------------------------------------------
extern DWORD _tls_ErrorInfoIndex;
//---------------------------------------------------------------------------
TMERRINFO *GetParseErrorInfo(BOOL fOkToCreate);

HRESULT MakeParseError(DWORD dwParseErrCode, OPTIONAL LPCWSTR pszMsgParam1=NULL, OPTIONAL LPCWSTR pszMsgParam2=NULL,
    OPTIONAL LPCWSTR pszSourceName=NULL, OPTIONAL LPCWSTR pszSourceLine=NULL, int iLineNum=0);
//---------------------------------------------------------------------------
#define WIN32_EXIT(code)        if (code) {hr=HRESULT_FROM_WIN32(code); goto exit;} else
#define SET_LAST_ERROR(hr)      SetLastError((DWORD) hr)
//---------------------------------------------------------------------------
HRESULT MakeError32(HRESULT hr);
HRESULT MakeErrorLast();
HRESULT MakeErrorParserLast();
//---------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\loader.h ===
//---------------------------------------------------------------------------
//  Loader.h - loads the theme data into shared memory
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Parser.h"
#include "TmSchema.h"
#include "ThemeFile.h"
//---------------------------------------------------------------------------
#define THEMEDATA_VERSION   0x00010006
//---------------------------------------------------------------------------
#define TM_FONTCOUNT    (TMT_LASTFONT - TMT_FIRSTFONT + 1)
#define TM_SIZECOUNT    (TMT_LASTSIZE - TMT_FIRSTSIZE + 1)
#define TM_BOOLCOUNT    (TMT_LASTBOOL - TMT_FIRSTBOOL + 1)
#define TM_STRINGCOUNT  (TMT_LASTSTRING - TMT_FIRSTSTRING + 1)
#define TM_INTCOUNT     (TMT_LASTINT - TMT_FIRSTINT + 1)
//---------------------------------------------------------------------------
class CRenderObj;       // forward
class CImageFile;       // forward
struct DIBINFO;   // forward
//---------------------------------------------------------------------------
struct THEMEMETRICS
{
    //---- subset of system metrics ----
    LOGFONT lfFonts[TM_FONTCOUNT];
    COLORREF crColors[TM_COLORCOUNT];
    int iSizes[TM_SIZECOUNT];
    BOOL fBools[TM_BOOLCOUNT];

    //---- special theme metrics ----
    int iStringOffsets[TM_STRINGCOUNT];
    int iInts[TM_INTCOUNT];
};
//---------------------------------------------------------------------------
struct LOADTHEMEMETRICS : THEMEMETRICS
{
    CWideString wsStrings[TM_STRINGCOUNT];
};

//---------------------------------------------------------------------------
// Signatures for quick cache file validation
const CHAR kszBeginCacheFileSignature[] = "BEGINTHM";
const CHAR kszEndCacheFileSignature[] = "ENDTHEME";
const UINT kcbBeginSignature = sizeof kszBeginCacheFileSignature - 1;
const UINT kcbEndSignature = sizeof kszEndCacheFileSignature - 1;

//---------------------------------------------------------------------------
// Theme section flags
#define SECTION_READY           1
#define SECTION_GLOBAL          2
#define SECTION_HASSTOCKOBJECTS 4

//---------------------------------------------------------------------------
struct THEMEHDR
{
    //---- theme validity ----
    CHAR szSignature[kcbBeginSignature];        // "BEGINTHM"
    DWORD dwVersion;            // THEMEDATA_VERSION
    DWORD dwFlags;              // must have SECTION_READY to be usable
    DWORD dwCheckSum;           // byte-additive total of all bytes following THEMEHDR
    FILETIME ftModifTimeStamp;  // Last modification time of the .msstyles file

    DWORD dwTotalLength;        // total number of bytes of all data (incl. header & begin/end sigs)

    //---- theme id ----
    int iDllNameOffset;         // dll filename of this theme
    int iColorParamOffset;      // color param theme was loaded with
    int iSizeParamOffset;       // size param theme was loaded with
    DWORD dwLangID;             // User lang ID theme was loaded with
    int iLoadId;                // sequential number for each loaded file (workstation local)

    //---- main sections ----
    DWORD iStringsOffset;       // offset to strings
    DWORD iStringsLength;       // total bytes in string section
    DWORD iSectionIndexOffset;  // offset to Section Index
    DWORD iSectionIndexLength;  // length of section indexes
    
    DWORD iGlobalsOffset;           // offset to [globals] section (for globals parts)
    DWORD iGlobalsTextObjOffset;    // offset to text obj for [globals] section
    DWORD iGlobalsDrawObjOffset;    // offset to draw obj for [globals] section

    DWORD iSysMetricsOffset;    // offset to [SysMetrics] section (for theme metrics API support)
};

//---------------------------------------------------------------------------
struct DRAWOBJHDR       // preceeds each draw obj
{
    int iPartNum;
    int iStateNum;
};
//---------------------------------------------------------------------------
struct RGNDATAHDR       // preceeds each draw obj
{
    int iPartNum;
    int iStateNum;
    int iFileIndex;   // for multiple image selection (HDC scaling)
};
//---------------------------------------------------------------------------
//   Shared Theme Data layout:
//
//      // ----- header ----
//      THEMEHDR ThemeHdr;
//
//      // ----- string section ----
//      DWORD dwStringsLength;  // length of string section
//      WCHAR [];               // strings
//
//      // ----- index section ----
//      DWORD dwIndexLengh;     // length of index section
//      DWORD dwIndexCount;     // count of APPCLASSLIVE entries
//      APPCLASSLIVE [];
//
//      // ----- theme data section ----
//      DWORD dwDataLength;     // length of theme data section
//      BYTE [];                // actual theme data
//
//      // ----- end signature
//      CHAR[8];                // ENDTHEME signature
//---------------------------------------------------------------------------
//   A class section within the "theme data section" consists of the
//   following ENTRYs:
//
//      <part jump table>
//
//      <optional state jump table>
//      <property/value entries>
//
//      for each packed drawobject:
//
//          <TMT_RGNLIST entries>      (associated with each DIB)
//          <TMT_STOCKBRUSH entries>   (associated with each DIB)
//          <TMT_DRAWOBJ entry>
//
//      <TMT_TEXTOBJ entries>
//      
//      <end of class marker>
//---------------------------------------------------------------------------
// an ENTRY consists of (all 1-byte aligned):
//
//      WORD usTypeNum;             // declared type id
//      BYTE ePrimVal;              // equiv. primitive type
//      BYTE bFiller;               // # of bytes added after data to align it
//      DWORD dwDataLen;            // includes filler bytes
//      //---- entry data follows ----
//
//---------------------------------------------------------------------------
//  The data for a part jump table ENTRY (TMT_PARTJUMPTABLE) consists of:
//
//      <offset of first drawobj: long>
//      <PartCount (1 + MaxPart): BYTE>
//      <offset to each part's entries: long[]>
//---------------------------------------------------------------------------
//  The data for a state jump table ENTRY (TMT_STATEJUMPTABLE) consists of:
//
//      <StateCount (1 + MaxState): BYTE>
//      <offset to each state's entries: long[]>
//---------------------------------------------------------------------------
//  The data for a rgn list ENTRY (TMT_RGNLIST) consists of:
//
//      <StateCount (1 + MaxState): BYTE>
//      <offset to each state's custom rgn data: long[]>
//---------------------------------------------------------------------------
//  The custom rgn data ENTRY (TMT_RGNDATA) consists of:    
//
//      RGNDATAHDR RgnDataHdr;
//      BYTE Data[];
//---------------------------------------------------------------------------
//  The TMT_STOCKBRUSHES ENTRY consists of:    
//
//    int iBrushCount;                    // number of brush slots (5*ImageCount)
//    HBRUSHES hBrushes[iBrushCount];
//---------------------------------------------------------------------------
#define MAX_SHAREDMEM_SIZE (3000*1000)            // 1.5 meg (yikes!)
//---------------------------------------------------------------------------
#ifdef _WIN64
#define ALIGN_FACTOR   8
#else
#define ALIGN_FACTOR   4   
#endif
//---------------------------------------------------------------------------
#define MAX_ENTRY_NESTING  5      // max # of nested entry levels
//---------------------------------------------------------------------------
#define ENTRYHDR_SIZE     (sizeof(SHORT) + sizeof(BYTE) + sizeof(BYTE) + sizeof(int))
//---------------------------------------------------------------------------
struct UNPACKED_ENTRYHDR      // (hdr's in theme are PACKED)
{
    WORD usTypeNum;             // declared type id
    BYTE ePrimVal;              // equiv. primitive type
    BYTE bFiller;               // # of bytes added after data to align it
    DWORD dwDataLen;            // includes filler bytes
};
//---------------------------------------------------------------------------
inline void FillAndSkipHdr(MIXEDPTRS &u, UNPACKED_ENTRYHDR *pHdr)
{
    pHdr->usTypeNum = *u.ps++;
    pHdr->ePrimVal = *u.pb++;
    pHdr->bFiller = *u.pb++;
    pHdr->dwDataLen = *u.pi++;
}
//---------------------------------------------------------------------------
struct PART_STATE_INDEX
{
    int iPartNum;          // 0=parent part
    int iStateNum;
    int iIndex;
    int iLen;
};
//---------------------------------------------------------------------------
struct APPCLASSLIVE        
{
    //---- note: cannot use ptrs since image shared by diff addr-mapping processes ----
    DWORD dwAppNameIndex;
    DWORD dwClassNameIndex;
    int iIndex;
    int iLen;
};
//---------------------------------------------------------------------------
struct APPCLASSLOCAL
{
    CWideString csAppName;
    CWideString csClassName;
    int iMaxPartNum;
    CSimpleArray<PART_STATE_INDEX> PartStateIndexes;
    int iPackedSize;        // total size of section (incl strings) if packed

    APPCLASSLIVE LiveIndex;     // updated during copy to live
}; 
//---------------------------------------------------------------------------
HRESULT InitThemeMetrics(LOADTHEMEMETRICS *tm);
void SetSystemMetrics(THEMEMETRICS *tm, BOOL fSyncLoad);
HRESULT PersistSystemColors(THEMEMETRICS *tm);
//---------------------------------------------------------------------------
class CThemeLoader : IParserCallBack
{
public:
    CThemeLoader();
    ~CThemeLoader();

    HRESULT LoadTheme(LPCWSTR pszThemeName, LPCWSTR pszColorParam,
        LPCWSTR pszSizeParam, OUT HANDLE *pHandle, BOOL fGlobalTheme);

    BOOL GetThemeName(LPTSTR NameBuff, int BuffSize);

    HRESULT SetWindowThemeInfo(HWND hwnd, LPCWSTR pszThemeIdList); 
    
    HRESULT LoadClassDataIni(HINSTANCE hInst, LPCWSTR pszColorName,
        LPCWSTR pszSizeName, LPWSTR pszFoundIniName, DWORD dwMaxIniNameChars, LPWSTR *ppIniData);

    //---- IParserCallBack ----
    HRESULT AddIndex(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum, int iIndex, int iLen);

    HRESULT AddData(SHORT sTypeNum, PRIMVAL ePrimVal, const void *pData, DWORD dwLen);
    int GetNextDataIndex();

protected:
    //---- helpers ----
    HRESULT PackAndLoadTheme(LPCWSTR pszThemeName, LPCWSTR pszColorParam,
        LPCWSTR pszSizeParam, HINSTANCE hInst);
    HRESULT CopyLocalThemeToLive(int iTotalLength, LPCWSTR pszThemeName, 
        LPCWSTR pszColorParam, LPCWSTR pszSizeParam);
    void FreeLocalTheme();
    HRESULT PackMetrics();
    HRESULT PackThemeStructs();

    BOOL KeyDrawPropertyFound(int iStateDataOffset);
    BOOL KeyTextPropertyFound(int iStateDataOffset);

    HRESULT PackDrawObject(MIXEDPTRS &u, CRenderObj *pRender, int iPartId, int iStateId);
    HRESULT PackTextObject(MIXEDPTRS &u, CRenderObj *pRender, int iPartId, int iStateId);

    HRESULT PackDrawObjects(MIXEDPTRS &u, CRenderObj *pRender, int iMaxPart, BOOL fGlobals);
    HRESULT PackTextObjects(MIXEDPTRS &u, CRenderObj *pRender, int iMaxPart, BOOL fGlobals);

    HRESULT CopyPartGroup(APPCLASSLOCAL *ac, MIXEDPTRS &u, int iPartNum, 
        int *piPartJumpTable, int iPartZeroIndex, int iGlobalsIndex, BOOL fGlobalsGroup);

    int GetPartOffset(CRenderObj *pRender, int iPartNum);

    HRESULT CopyClassGroup(APPCLASSLOCAL *ac, MIXEDPTRS &u, int iGlobalsIndex, int iClassNameOffset);
    int GetMaxState(APPCLASSLOCAL *ac, int iPartNum);

    HRESULT AddIndexInternal(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum, int iIndex, int iLen);

    BOOL IndexExists(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum);

    HRESULT AddMissingParent(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum);

    HRESULT EmitEntryHdr(MIXEDPTRS &u, SHORT propnum, BYTE privnum);
    int EndEntry(MIXEDPTRS &u);

    HRESULT PackImageFileInfo(DIBINFO *pdi, CImageFile *pImageObj, MIXEDPTRS &u, 
        CRenderObj *pRender, int iPartId, int iStateId);
    
    HRESULT AllocateThemeFileBytes(BYTE *upb, DWORD dwAdditionalLen);

    // Helper functions to alloc and emit sized data
    HRESULT EmitAndCopyBlock(MIXEDPTRS &u, void *pSrc, DWORD dwLen);
    HRESULT EmitString(MIXEDPTRS &u, LPCWSTR pSrc, DWORD dwLen, int *piOffSet);
    HRESULT EmitObject(MIXEDPTRS &u, SHORT propnum, BYTE privnum, void *pHdr, DWORD dwHdrLen, void *pObj, DWORD dwObjLen);

    //---- private data ----
    CWideString _wsThemeFileName;
    int _iGlobalsOffset;
    int _iSysMetricsOffset;
    
    //---- ptrs to packed objs for [globals] section ----
    int _iGlobalsTextObj;       // we always create this obj
    int _iGlobalsDrawObj;       // we always create this obj

    //---- local copy of theme data while being built ----
    BYTE *_pbLocalData;
    int _iLocalLen;
    CSimpleArray<APPCLASSLOCAL> _LocalIndexes;

    //---- used for updating entry hdrs ----
    BYTE *_pbEntryHdrs[MAX_ENTRY_NESTING];          // points to current hdr
    int _iEntryHdrLevel;

    //---- shared memory copy of theme data ----
    CUxThemeFile _LoadingThemeFile;

    //---- theme metrics ----
    LOADTHEMEMETRICS _LoadThemeMetrics;

    //---- Global creation flag
    BOOL _fGlobalTheme;

    //---- Machine page size for VirtualAlloc optimization
    DWORD _dwPageSize;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\cfile.h ===
//---------------------------------------------------------------------------
//    cfile.h - file read/write (ansi/unicode) helper class
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#ifndef CFILE_H
#define CFILE_H
//---------------------------------------------------------------------------
class CSimpleFile
{
public:
    HANDLE _hFile;
    BOOL _fAnsi;

    CSimpleFile()
    {
        _hFile = INVALID_HANDLE_VALUE;
        _fAnsi = FALSE;
    }

    BOOL IsOpen()
    {
        return _hFile != INVALID_HANDLE_VALUE;
    }

    HRESULT Create(LPCWSTR lpsz, BOOL fAnsi=FALSE)
    {
        _fAnsi = fAnsi;

        _hFile = CreateFile(lpsz, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
        if (_hFile == INVALID_HANDLE_VALUE)
            return MakeErrorLast();
        
        return S_OK;
    }

    HRESULT Open(LPCWSTR lpsz, BOOL fAnsi=FALSE, BOOL fExclusive=FALSE)
    {
        _fAnsi = fAnsi;

        DWORD dwShare = 0;
        if (! fExclusive)
            dwShare = FILE_SHARE_READ;

        _hFile = CreateFile(lpsz, GENERIC_READ, dwShare, NULL, OPEN_EXISTING, 0, NULL);
        if (_hFile == INVALID_HANDLE_VALUE)
            return MakeErrorLast();
        
        return S_OK;
    }

    HRESULT Append(LPCWSTR lpsz, BOOL fAnsi=FALSE)
    {
        _fAnsi = fAnsi;

        _hFile = CreateFile(lpsz, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
        if (_hFile == INVALID_HANDLE_VALUE)
            return MakeErrorLast();

        // cannot rely on retval from SetFilePointer() so must use GetLastError()
        SetLastError(0);  
        SetFilePointer(_hFile, 0, NULL, FILE_END);
        if (GetLastError() != NO_ERROR)
            return MakeErrorLast();

        return S_OK;
    }

    DWORD GetFileSize(DWORD* pdw = NULL)
    {
        return ::GetFileSize(_hFile, pdw);
    }

    HRESULT Printf(LPCWSTR fmtstr, ...)
    {
        va_list args;
        va_start(args, fmtstr);

        WCHAR msgbuff[2048];

        //---- format caller's string ----
        wvsprintfW(msgbuff, fmtstr, args);
        va_end(args);

        return Write((void*)msgbuff, lstrlen(msgbuff)*sizeof(WCHAR));
    }

    HRESULT OutLine(LPCWSTR fmtstr, ...)
    {
        va_list args;
        va_start(args, fmtstr);

        WCHAR msgbuff[2048];

        //---- format caller's string ----
        wvsprintfW(msgbuff, fmtstr, args);
        va_end(args);

        //---- add a CR/LF at end ----
        lstrcat(msgbuff, L"\r\n");

        return Write((void*)msgbuff, lstrlen(msgbuff)*sizeof(WCHAR));
    }

    ~CSimpleFile()
    {
        Close();
    }

    void Close()
    {
        if (_hFile != INVALID_HANDLE_VALUE)
            CloseHandle(_hFile);

        _hFile = INVALID_HANDLE_VALUE;
    }

    HRESULT Write(void* pv, DWORD dwBytes)
    {
        HRESULT hr = S_OK;

        DWORD dw;
        if (_fAnsi)
        {
            USES_CONVERSION;
            LPSTR p = W2A((LPCWSTR)pv);
            if (! WriteFile(_hFile, p, dwBytes/sizeof(WCHAR), &dw, NULL))
                hr = MakeErrorLast();
        }
        else
        {
            if (! WriteFile(_hFile, pv, dwBytes, &dw, NULL))
                hr = MakeErrorLast();
        }

        return hr;
    }

    HRESULT Read(void* lpBuffer, DWORD n, DWORD* lpcb)
    {
        HRESULT hr = S_OK;

        if (_fAnsi)
        {
            LPSTR szAnsiBuff = (LPSTR)alloca(n+1);
            if (! szAnsiBuff)
                return MakeError32(E_OUTOFMEMORY);

            if (! ReadFile(_hFile, szAnsiBuff, n, lpcb, NULL))
                hr = MakeErrorLast();
            else
            {
                USES_CONVERSION;
                szAnsiBuff[*lpcb] = 0;      // zero terminate
                LPCWSTR pw = A2W(szAnsiBuff);
                memcpy(lpBuffer, pw, lstrlen(pw));      // no room for NULL
            }
        }
        else
        {
            if (! ReadFile(_hFile, lpBuffer, n, lpcb, NULL))
                hr = MakeErrorLast();
        }

        return hr;
    }
};
//---------------------------------------------------------------------------
#endif      // CFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\logopts.h ===
//-----------------------------------------------------------------
//   LogOpts.h - logging options
//-----------------------------------------------------------------
#ifdef MAKE_LOG_STRINGS          // this file in #include-ed twice

#define BEGIN_LOG_OPTIONS()         static const LOGNAMEINFO LogNames[] = {
#define LOGOPT(val, key, desc)      {key, desc},
#define END_LOG_OPTIONS()           };

#else

#define BEGIN_LOG_OPTIONS()         enum LogOptions {
#define LOGOPT(val, key, desc)      val,
#define END_LOG_OPTIONS()           };

#endif
//-----------------------------------------------------------------
BEGIN_LOG_OPTIONS()

    //---- log options ----
    LOGOPT(LO_BREAK,      "Break",      "Controls whether DebugBreak()'s are enabled")
    LOGOPT(LO_CONSOLE,    "Console",    "log msgs to the debugger console")
    LOGOPT(LO_LOGFILE,    "LogFile",    "log msgs to c:\themes.log")
    LOGOPT(LO_TIMERID,    "TimerId",    "msgs contain a relative timer")
    LOGOPT(LO_CLOCKID,    "ClockId",    "msgs contain the clock time")
    LOGOPT(LO_SRCID,      "SrcId",      "msgs contain their source file name & line number")
    LOGOPT(LO_APPID,      "AppId",      "msgs contain their app name")
    LOGOPT(LO_THREADID,   "ThreadId",   "msgs contain their thread id")
    LOGOPT(LO_USERCOUNT,  "UserCount",  "msgs contain open USER handle count")
    LOGOPT(LO_GDICOUNT,   "GdiCount",   "msgs contain open GDI handle count")
    LOGOPT(LO_MEMUSAGE,   "MemUsage",   "msgs contain memory usage")
    LOGOPT(LO_HEAPCHECK,  "HeapCheck",  "heap is validated as each msg is displayed")
    LOGOPT(LO_SHUTDOWN,   "ShutDown",   "Force early uxtheme ShutDown() code on top win close")

    //---- msg filter presets ----
    LOGOPT(LO_ALL,      "All",          "turn on/off all msg filters")

    //---- msg filters (*** MUST ADD TO LOG_XXX DEFINES BELOW ***) ----
    LOGOPT(LO_ASSERT,   "Assert",       "log assert msg & DebugBreak()")
    LOGOPT(LO_ERROR,    "Error",        "log error msg & DebugBreak()")
    LOGOPT(LO_ALWAYS,   "Always",       "always log but don't break")
    LOGOPT(LO_PERF,     "Perf",         "perf related msgs")
    LOGOPT(LO_PARAMS,   "Params",       "log bad API params")

    LOGOPT(LO_TMAPI,    "TMAPI",        "monitor all uxthem API entry/exit")
    LOGOPT(LO_TMLOAD,   "TMLoad",       "track theme file load/unloads")
    LOGOPT(LO_TMCHANGE, "TMChange",     "monitor events during theme load/unloads")
    LOGOPT(LO_TMCHANGEMSG, "TMChangeMsg",     "monitor msgs sent/received during theme changes")
    LOGOPT(LO_TMSTARTUP,"TMStartUp",    "log thread/process startup/shutdown calls")
    LOGOPT(LO_TMOPEN,   "TMOPEN",       "_OpenThemeData() & CloseThemeData() calls")
    LOGOPT(LO_TMHANDLE, "TMHANDLE",     "track calls to open/close theme file handles")
    LOGOPT(LO_TMBITMAP, "TMBITMAP",     "track calls to bitmap creation and use")
    LOGOPT(LO_TMBRUSHES,"TMBRUSHES",    "track calls to brushes creation and use")
    LOGOPT(LO_TM,       "TM",           "general theme manager events")
    LOGOPT(LO_CACHE,    "Cache",        "trace Caching API's")
    LOGOPT(LO_RFBUG,    "RfBug",        "trace info relating to roland's current bug")
    LOGOPT(LO_TILECNT,  "TileCnt",      "count # of tiling bitblt calls needed")
    LOGOPT(LO_BADHTHEME,"BadHTheme",    "log any illegal HTHEME handles in public api's")

    LOGOPT(LO_WINDUMP,  "WinDump",      "dump of windows by process")
    LOGOPT(LO_COMPOSITE,"Composite",    "WS_EX_COMPOSITED related processing")
    LOGOPT(LO_CAPTION,  "Caption",      "Experimental caption drawing")

    LOGOPT(LO_NCATTACH, "NCAttach",     "monitor events during NC window attach/detach")
    LOGOPT(LO_NCMSGS,   "NCMsgs",       "monitor all nc theme msgs that we process")
    LOGOPT(LO_NCMETRICS, "NCMetrics",   "info about NC metrics calcs")
    LOGOPT(LO_NCTRACE,  "NCTrace",      "entry/exit tracing in key NC functions")

END_LOG_OPTIONS()
//---------------------------------------------------------------------------
#undef BEGIN_LOG_OPTIONS
#undef LOGOPT
#undef END_LOG_OPTIONS
//---------------------------------------------------------------------------
#define LOGPARAMS            __FILE__, __LINE__

//---- use these msg filters for calls to Log() ----

#define LOG_ASSERT           LO_ASSERT, LOGPARAMS, 0
#define LOG_ERROR            LO_ERROR, LOGPARAMS, 0
#define LOG_ALWAYS           LO_ALWAYS, LOGPARAMS, 0
#define LOG_PERF             LO_PERF, LOGPARAMS, 0
#define LOG_PARAMS           LO_PARAMS, LOGPARAMS, 0

#define LOG_TMAPI            LO_TMAPI, LOGPARAMS, 0
#define LOG_TMLOAD           LO_TMLOAD, LOGPARAMS, 0
#define LOG_TMSTARTUP        LO_TMSTARTUP, LOGPARAMS, 0
#define LOG_TMCHANGE         LO_TMCHANGE, LOGPARAMS, 0
#define LOG_TMCHANGEMSG      LO_TMCHANGEMSG, LOGPARAMS, 0
#define LOG_TMOPEN           LO_TMOPEN, LOGPARAMS, 0
#define LOG_TMHANDLE         LO_TMHANDLE, LOGPARAMS, 0
#define LOG_TMBITMAP         LO_TMBITMAP, LOGPARAMS, 0
#define LOG_TMBRUSHES        LO_TMBRUSHES, LOGPARAMS, 0
#define LOG_TM               LO_TM, LOGPARAMS, 0
#define LOG_CACHE            LO_CACHE, LOGPARAMS, 0
#define LOG_RFBUG            LO_RFBUG, LOGPARAMS, 0
#define LOG_TILECNT          LO_TILECNT, LOGPARAMS, 0
#define LOG_BADHTHEME        LO_BADHTHEME, LOGPARAMS, 0

#define LOG_WINDUMP          LO_WINDUMP, LOGPARAMS, 0
#define LOG_COMPOSITE        LO_COMPOSITE, LOGPARAMS, 0
#define LOG_CAPTION          LO_CAPTION, LOGPARAMS, 0

#define LOG_NCATTACH         LO_NCATTACH, LOGPARAMS, 0
#define LOG_NCMSGS           LO_NCMSGS, LOGPARAMS, 0
#define LOG_NCMETRICS        LO_NCMETRICS, LOGPARAMS, 0
#define LOG_NCTRACE          LO_NCTRACE, LOGPARAMS, 0
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\log.h ===
//---------------------------------------------------------------------------
//    log.h - theme logging routines
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#ifndef LOG_H
#define LOG_H
//---------------------------------------------------------------------------
#include "logopts.h"        // log options as enums
//---------------------------------------------------------------------------
#ifdef DEBUG
#define LOGGING 1
#endif
//-----------------------------------------------------------------
//---- set this to "GetMemUsage", "GetUserCount", or "GetGdiCount" ----
//---- it controls which resource is tracked across entry/exit calls ----
#define ENTRY_EXIT_FUNC        GetGdiCount()
#define ENTRY_EXIT_NAME        L"GdiCount()"
//-----------------------------------------------------------------
//   Note: 
//      For builds without DEBUG defined (FRE builds), calling
//      code will reference an underscore version of all public 
//      logging routines (_xxx()).  These functions are defined
//      as inline with little or no code (no code means no caller 
//      code is generated).
//
//      For DEBUG defined (CHK) builds, the calling code connects
//      with the normally named logging routines.
//
//      This is done to keep calling code to a minimum for FRE
//      builds, to avoid LOG2(), LOG3() type defines that vary
//      with param count, and to keep build system happy when
//      mixing FRE and CHK callers and libraries.
//-----------------------------------------------------------------
//---- these are used for CHK builds only but must be defined for both ----
void Log(UCHAR uLogOption, LPCSTR pszSrcFile, int iLineNum, int iEntryCode, LPCWSTR pszFormat, ...);
BOOL LogStartUp();
BOOL LogShutDown();
void LogControl(LPCSTR pszOptions, BOOL fEcho);
void TimeToStr(UINT uRaw, WCHAR *pszBuff);
DWORD StartTimer();
DWORD StopTimer(DWORD dwStartTime);
HRESULT OpenLogFile(LPCWSTR pszLogFileName);
void CloseLogFile();
int GetMemUsage();
int GetUserCount();
int GetGdiCount();
BOOL LogOptionOn(int iLogOption);
//-----------------------------------------------------------------
#ifdef LOGGING

#define LogEntry(pszFunc)              \
    LOGENTRYCODE;  Log(LO_TMAPI, LOGPARAMS, 1, L"%s ENTRY (%s=%d)", pszFunc, \
    ENTRY_EXIT_NAME, _iEntryValue);
 
#define LogEntryC(pszFunc, pszClass)    \
    LOGENTRYCODE;  Log(LO_TMAPI, LOGPARAMS, 1, L"%s ENTRY, class=%s (%s=%d)", \
    pszFunc, pszClass, ENTRY_EXIT_NAME, _iEntryValue); 

#define LogEntryW(pszFunc)              \
    LOGENTRYCODEW;   Log(LO_TMAPI, LOGPARAMS, 1, L"%s ENTRY (%s=%d)", pszFunc, \
    ENTRY_EXIT_NAME, _iEntryValue);

#define LogEntryCW(pszFunc, pszClass)    \
    LOGENTRYCODEW; Log(LO_TMAPI, LOGPARAMS, 1, L"%s ENTRY, class=%s (%s=%d)", \
    pszFunc, pszClass, ENTRY_EXIT_NAME, _iEntryValue); 

#define LogEntryNC(pszFunc)            \
    LOGENTRYCODE;  Log(LO_NCTRACE, LOGPARAMS, 1, L"%s ENTRY (%s=%d)", \
    pszFunc, ENTRY_EXIT_NAME, _iEntryValue); 

#define LogEntryMsg(pszFunc, hwnd, umsg)            \
    LOGENTRYCODE;  Log(LO_NCMSGS, LOGPARAMS, 1, L"%s ENTRY (hwnd=0x%x, umsg=0x%x, %s=%d)", \
    pszFunc, hwnd, umsg, ENTRY_EXIT_NAME, _iEntryValue); 

#define LogExit(pszFunc)                    LOGEXIT(pszFunc, LO_TMAPI)
#define LogExitC(pszFunc, cls)              LOGEXITCLS(pszFunc, LO_TMAPI, cls)
#define LogExitNC(pszFunc)                  LOGEXIT(pszFunc, LO_NCTRACE)
#define LogExitMsg(pszFunc)                 LOGEXIT(pszFunc, LO_NCMSGS)

#define LOGEXIT(pszFunc, filter)  \
{    \
    LOGEXITCODE;   \
    if (_iEntryValue != _ExitValue) \
        Log(filter, LOGPARAMS, -1, L"%s EXIT [%s delta: %d]", pszFunc, ENTRY_EXIT_NAME, _ExitValue-_iEntryValue);  \
    else   \
        Log(filter, LOGPARAMS, -1, L"%s EXIT", pszFunc);  \
}

#define LOGEXITCLS(pszFunc, filter, cls)  \
{    \
    LOGEXITCODE;   \
    if (_iEntryValue != _ExitValue) \
        Log(filter, LOGPARAMS, -1, L"%s EXIT, class=%s [%s delta: %d]", pszFunc, cls, ENTRY_EXIT_NAME, _ExitValue-_iEntryValue);  \
    else   \
        Log(filter, LOGPARAMS, -1, L"%s EXIT, class=%s", pszFunc, cls);  \
}

#ifndef _X86_
#define DEBUG_BREAK        if (LogOptionOn(LO_BREAK)) DebugBreak(); else
#else
#define DEBUG_BREAK        if (LogOptionOn(LO_BREAK)) __asm {int 3} else
#endif

//---- change this when you want to track something different for entry/exit ----
#define LOGENTRYCODE        int _iEntryValue = ENTRY_EXIT_FUNC
#define LOGENTRYCODEW       _iEntryValue = ENTRY_EXIT_FUNC
#define LOGEXITCODE         int _ExitValue = ENTRY_EXIT_FUNC

#else

//---- for FRE builds, connect to the inline routines ----
#define Log             _Log
#define LogStartUp      _LogStartUp
#define LogShutDown     _LogShutDown
#define LogControl      _LogControl
#define TimeToStr       _TimeToStr
#define StartTimer      _StartTimer
#define StopTimer       _StopTimer
#define OpenLogFile     _OpenLogFile
#define CloseLogFile    _CloseLogFile
#define LogOptionOn     _LogOptionOn
#define GetMemUsage     _GetMemUsage
#define GetUserCount    _GetUserCount
#define GetGdiCount     _GetGdiCount

#define LogEntry(pszFunc)   
#define LogEntryC(pszFunc, pszClass) 
#define LogEntryW(pszFunc)   
#define LogEntryCW(pszFunc, pszClass)   
#define LogExit(pszFunc)    
#define LogExitC(pszFunc, pszClass)    
#define LogExitW(pszFunc, pszClass)    
#define LogEntryNC(pszFunc) 
#define LogExitNC(pszFunc)  
#define LogEntryMsg(pszFunc, hwnd, umsg)   
#define LogExitMsg(x)

#define DEBUG_BREAK     (0)

//---- for FRE builds, make these guys gen no or minimum code ----
inline void _Log(UCHAR uLogOption, LPCSTR pszSrcFile, int iLineNum, int iEntryExitCode, LPCWSTR pszFormat, ...) {}
inline BOOL _LogStartUp() {return TRUE;}
inline BOOL _LogShutDown() {return TRUE;}
inline void _LogControl(LPCSTR pszOptions, BOOL fEcho) {}
inline void _TimeToStr(UINT uRaw, WCHAR *pszBuff) {}
inline DWORD _StartTimer() {return 0;}
inline DWORD _StopTimer(DWORD dwStartTime) {return 0;}
inline HRESULT _OpenLogFile(LPCWSTR pszLogFileName) {return E_NOTIMPL;}
inline void _CloseLogFile() {}
inline BOOL _LogOptionOn(int iIndex) {return FALSE;}
inline BOOL _pszClassName(int iIndex) {return FALSE;}
inline int GetMemUsage() {return 0;}
inline int GetUserCount() {return 0;}
inline int GetGdiCount() {return 0;}

#endif
//---------------------------------------------------------------------------
#undef ASSERT
#define ATLASSERT(exp) _ASSERTE(exp)
#define ASSERT(exp)    _ASSERTE(exp)
#define _ATL_NO_DEBUG_CRT
//---------------------------------------------------------------------------
#ifdef LOGGING

#define _ASSERTE(exp)   if (! (exp)) { Log(LOG_ASSERT, L#exp); DEBUG_BREAK; } else
#define CLASSPTR(x)     ((x) ? ((CRenderObj *)x)->_pszClassName : L"")  
#define SHARECLASS(x)   (LPCWSTR)x->_pszClassName
#else
#define _ASSERTE(exp)    (0)
#define CLASSPTR(x) NULL
#define SHARECLASS(x) NULL
#endif
//---------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\ntl.h ===
//-------------------------------------------------------------------------
//	ntl.h - common declarations for ntl modules
//-------------------------------------------------------------------------
#ifndef _NTL_H_
#define _NTL_H_
//-------------------------------------------------------------------------
enum NTL_OPCODE         // packed as BYTE's 
{
    //---- support for IF/ELSE/ENDIF properties ----
    NTL_STATEJUMPTABLE, // the state jump table at the beginning of the code
                        // BYTE bStateCount, int iOffsets[bStateCount]

    NTL_JMPON,          // jump to location if bit is ON
                        // BYTE bBitNum, int iLocation

    NTL_JMPOFF,         // jump to location if bit is OFF
                        // BYTE bBitNum, int iLocaton

    NTL_JMP,            // jump to location
                        // int iLocation

    NTL_RETURN,         // return to caller (no params)

    //---- support for primitive vector drawing ----
    NTL_LOGRECT,        // specifies logical drawing rect
                        // RECT rcLogRect

    NTL_LINEBRUSH,      // defines the current brush for drawing lines
                        // <paramColor> crLine, 
                        // <paramInt> iLineWidth, BOOL fLogWidth

    NTL_FILLBRUSH,      // defines the current brush to be used for shape fill
                        // <paramFillBrush>

    NTL_MOVETO,         // moves current position to specified point
                        // POINT ptLog

    NTL_LINETO,         // draws a line to specified point
                        // POINT ptLog

    NTL_CURVETO,        // draws a bezier curve to specified point
                        // POINT ptCP1, POINT ptCP2, POINT pt
                        
    NTL_SHAPE,          // marks the start of a shape
                        // POINT ptDrawOrigin

    NTL_ENDSHAPE,       // marks the end of a shape
                        // POINT ptDrawOrigin
    
    //---- support for cascading rectangle operations ----
    NTL_DRAWRECT,       // draw rect border & adjust rect
                        // <paramInt> iLineWidth, <paramInt> iLineHeight,
                        // <paramColor> crColor, <paramColor> crBottomRight


    NTL_FILLRECT,       // fill current rect with specified color
                        // <paramFillBrush> Fill

    NTL_SETOPTION,      // set specified option
                        // BYTE bBitNum

    NTL_CLROPTION,      // clear specified option
                        // BYTE bBitNum
};
//-------------------------------------------------------------------------
//  <paramInt> must be PT_INT or PT_SYSMETRICINDEX
//
//  <paramColor> must be PT_COLORREF or PT_COLORNULL or PT_SYSCOLORINDEX
//
//  <paramFillBrush> must be <paramColor> or PT_FILENAME or PT_FILENAMEOFFSET
//-------------------------------------------------------------------------
enum NTL_PARAMTYPES         // packed as BYTE's
{
    PT_INT = 128,           // followed by: 4 byte int
    PT_SYSMETRICINDEX,      // followed by: 2 byte SHORT - evaluates to: GetSystemMetrics(index)
    PT_COLORREF,            // followed by: 4 byte COLORREF
    PT_COLORNULL,           // 
    PT_SYSCOLORINDEX,       // followed by: 2 byte SHORT - evaluates to: GetSysColor(index)
    PT_IMAGEFILE,           // followed by: 1 byte image index 
};
//-------------------------------------------------------------------------
#endif  //  _NTL_H_
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\ntlparse.h ===
//---------------------------------------------------------------------------
//  NtlParse.h - parses a ".ntl" file (Native Theme Language)
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Scanner.h"
#include "Utils.h"
#include "CFile.h"
#include "SimpStr.h"
#include "parser.h"
#include "ntl.h"
//---------------------------------------------------------------------------
#define MAX_IF_NESTING  99
#define MAX_STATES      99
//---------------------------------------------------------------------------
struct OPTIONBITENTRY
{
    CWideString csName;
    int iValue; 
};
//---------------------------------------------------------------------------
struct IFRECORD
{
    BYTE iBitNum;
    BOOL fIfOn;
    int iIfOffset;
    int iElseOffset;
};
//---------------------------------------------------------------------------
class CNtlParser
{
public:
    CNtlParser();
    HRESULT ParseBuffer(LPCWSTR pszSource, LPCWSTR pszSourceFileName, INtlParserCallBack *pCallBack,
        OUT BYTE **ppPCode, OUT int *piLen);

protected:
    HRESULT SourceError(int iMsgResId, ...);
    HRESULT ParseOptionBitsSection();
    HRESULT AddOptionBitName(LPCWSTR szOptionName, int iOptionValue);
    HRESULT ParseDrawingSection();
    HRESULT GetBitnumVal(LPCWSTR szName, BYTE *piValue);
    HRESULT GetStateNum(LPCWSTR pszStateName, BYTE *piNum);

    //---- drawing cmd parsing ----
    HRESULT ParseAddBorder();
    HRESULT ParseFillBorder();
    HRESULT ParseLogicalRect();
    HRESULT ParseFillBrush();
    HRESULT ParseLineBrush();
    HRESULT ParseMoveTo();
    HRESULT ParseLineTo();
    HRESULT ParseCurveTo();
    HRESULT ParseShape();
    HRESULT ParseEndShape();
    HRESULT ParseIf();
    HRESULT ParseElse();
    HRESULT ParseEndIf();
    HRESULT ParseSetOption();
    HRESULT ParseGotoState();

    //---- emitting ----
    HRESULT EmitCheck(int iLen);
    HRESULT EmitByte(BYTE eOpCode);
    HRESULT EmitShort(SHORT sValue);
    HRESULT EmitInt(int iValue);
    HRESULT EmitString(LPCWSTR szValue);

    //---- parse parameters ----
    HRESULT ParseEmitPoint();
    HRESULT ParseEmitRect();
    HRESULT ParseEmitSize();
    HRESULT ParseEmitSize2();
    HRESULT ParseEmitSize4();
    HRESULT ParseEmitColor();
    HRESULT ParseEmitColor4();
    HRESULT ParseEmitImagefile();
    HRESULT ParseEmitNone();

    //---- private data ----
    CScanner _scan;
    CSimpleArray<OPTIONBITENTRY> _OptionBits;
    int _iStateOffsets[MAX_STATES+1];
    INtlParserCallBack *_pCallBack;

    //---- pcode ----
    BYTE *_pPCode;
    int _iPCodeAllocSize;       // currently allocated size
    MIXEDPTRS _u;               // ptr to next pcode byte

    //---- IfStack ----
    IFRECORD _IfStack[MAX_IF_NESTING];
    int _iIfLevel;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\parser.h ===
//---------------------------------------------------------------------------
//  Parser.h - parses a "themes.ini" file and builds the ThemeInfo entries
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Scanner.h"
#include "Utils.h"
#include "CFile.h"
#include "SimpStr.h"
//#include "NtlParse.h"
//---------------------------------------------------------------------------
//  TMT_XXX ranges:
//      1 - 49   SpecialPropVals (see below)
//      50 - 60  Primitive Properties
//      61 - xx  enum definitions & regular Properties 
//---------------------------------------------------------------------------
enum SpecialPropVals        // strings not needed for these
{
    TMT_THEMEMETRICS = 1,   // THEMEMETRICS struct in shared data
    TMT_DIBDATA,            // bitmap file converted to DIB data 
    TMT_DIBDATA1,           // bitmap file converted to DIB data 
    TMT_DIBDATA2,           // bitmap file converted to DIB data 
    TMT_DIBDATA3,           // bitmap file converted to DIB data 
    TMT_DIBDATA4,           // bitmap file converted to DIB data 
    TMT_DIBDATA5,           // bitmap file converted to DIB data 
    TMT_GLYPHDIBDATA,       // NTL pcode generated from NTL source file
    TMT_NTLDATA,            // NTL pcode generated from NTL source file
    TMT_PARTJUMPTABLE,      // seen if more than 1 part defined for class
    TMT_STATEJUMPTABLE,     // seen if more than 1 state defined for part
    TMT_JUMPTOPARENT,       // seen at end of every section (index=-1 means stop)
    TMT_ENUMDEF,            // enum definition (not yet a property)
    TMT_ENUMVAL,            // enum value definition
    TMT_ENUM,               // enum property
    TMT_DRAWOBJ,            // packed struct (CBorderFill and CImageFile objs)
    TMT_TEXTOBJ,            // packed struct (CTextObj)
    TMT_RGNLIST,            // state jump table to access custom region data entries
    TMT_RGNDATA,            // custom region data for an imagefile/state
    TMT_STOCKBRUSHES,       // stock brush values for bitmap(s)
    TMT_ENDOFCLASS,         // end of data for a class section
    TMT_STOCKDIBDATA,
    TMT_UNKNOWN, 
};
//---------------------------------------------------------------------------
#define HUE_SUBCNT 5
#define COLOR_SUBCNT 5
//---------------------------------------------------------------------------
#define MAX_PROPERTY_VALUE      1024
//---------------------------------------------------------------------------
#define ENUM_SECTION_NAME   L"enums"
#define TYPE_SECTION_NAME   L"types"

#define INI_MACRO_SYMBOL    L'#'
#define SUBST_TABLE_INCLUDE L"Include"

#define GLOBALS_SECTION_NAME   L"globals"
#define SYSMETRICS_SECTION_NAME   L"SysMetrics"

#define MYAPP_NAME          L"ThemeSel"
#define OUTFILE_NAME        L"tmdefs.h"
#define PREDEFINES_NAME     L"themes.inc"
//---------------------------------------------------------------------------
typedef BYTE PRIMVAL;        // first 10 TMT_XXX defines
//---------------------------------------------------------------------------
class IParserCallBack           // Parser Caller must implement
{
public:
    virtual HRESULT AddIndex(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum, int iIndex, int iLen) = 0;
    virtual HRESULT AddData(SHORT sTypeNum, PRIMVAL ePrimVal, const void *pData, 
        DWORD dwLen) = 0;
    virtual int GetNextDataIndex() = 0;
};
//---------------------------------------------------------------------------
struct ENUMVAL
{
    CWideString csName;
    int iValue;
    int iSymbolIndex;
};
//---------------------------------------------------------------------------
struct SYMBOL
{
    CWideString csName;
    SHORT sTypeNum;             // the property number of this property
    PRIMVAL ePrimVal;           // all enums = ENUM_PRIMNUM
};
//---------------------------------------------------------------------------
// Stock objects data
//---------------------------------------------------------------------------
struct TMBITMAPHEADER       // Stock bitmap info, can be followed with a BITMAPINFOHEADER struct
{
    DWORD dwSize;           // Size of the structure
    BOOL fFlipped;          // TRUE if the bitmap is flipped (stock or not)
    HBITMAP hBitmap;        // Stock bitmap handle, if NULL then a BITMAPINFOHEADER follows
    DWORD dwColorDepth;     // Bitmap color depth
    BOOL fTrueAlpha;        // TRUE if the bitmap has a non-empty alpha chanel
    DWORD iBrushesOffset;   // Offset to the stock brushes array for this bitmap
    UINT nBrushes;          // Number of brushes in the array
};
// Pointer to the BITMAPINFOHEADER following the structure
#define BITMAPDATA(p) (reinterpret_cast<BITMAPINFOHEADER*>((BYTE*) p + p->dwSize))
// Size in bytes preceding the BITMAPINFOHEADER data
#define TMBITMAPSIZE (sizeof(TMBITMAPHEADER))
//---------------------------------------------------------------------------
class INtlParserCallBack           // Parser Caller must implement
{
public:
    virtual HRESULT GetStateNum(LPCWSTR pszStateName, BYTE *piNum) = 0;
};
//---------------------------------------------------------------------------
class CThemeParser : public INtlParserCallBack
{
public:
    CThemeParser(BOOL fGlobalTheme = FALSE);

    HRESULT ParseThemeFile(LPCWSTR pszFileName, LPCWSTR pszColorParam, 
        IParserCallBack *pCallBack, THEMEENUMPROC pNameCallBack=NULL, 
        LPARAM lFnParam=NULL, DWORD dwParseFlags=0);

    HRESULT ParseThemeBuffer(LPCWSTR pszBuffer, LPCWSTR pszFileName,
        LPCWSTR pszColorParam, HINSTANCE hInstThemeDll, IParserCallBack *pCallBack, 
        THEMEENUMPROC pNameCallBack=NULL, LPARAM lFnParam=NULL, 
        DWORD dwParseFlags=0, LPCWSTR pszDocProperty=NULL, OUT LPWSTR pszResult=NULL,
        DWORD dwMaxResultChars=0);

    HRESULT GetEnumValue(LPCWSTR pszEnumName, LPCWSTR pszEnumValName,
        int *piValue);

    HRESULT GetPropertyNum(LPCWSTR pszName, int *piPropNum);

    HRESULT GetStateNum(LPCWSTR pszStateName, BYTE *piNum);

    void CleanupStockBitmaps();

protected:
    //---- helpers ----
    HRESULT SourceError(int iMsgResId, LPCWSTR pszParam1=NULL, LPCWSTR pszParam2=NULL);
    HRESULT ParseDocSection();
    HRESULT ParseClassSection(LPCWSTR pszFirstName);
    HRESULT InitializeSymbols();
    PRIMVAL GetPrimVal(LPCWSTR pszName);
    HRESULT AddSymbol(LPCWSTR pszName, SHORT sTypeNum, PRIMVAL ePrimVal);
    HRESULT ParseClassSectionName(LPCWSTR pszFirstName, LPWSTR appsym);
    HRESULT ValidateEnumSymbol(LPCWSTR pszName, int iSymType, int *pIndex=NULL);
    HRESULT ParseClassLine(int *piSymType=NULL, int *piValue=NULL, LPWSTR pszBuff=NULL, DWORD dwMaxBuffChars=0);
    int GetSymbolIndex(LPCWSTR pszName);
    HRESULT ParseThemeScanner(IParserCallBack *pCallBack, THEMEENUMPROC pNameCallBack, 
        LPARAM lFnParam, DWORD dwParseFlags);
    HRESULT ParseColorSchemeSection();
    COLORREF ApplyColorSubstitution(COLORREF crOld);
    HRESULT ParseSizeSection();
    HRESULT ParseFileSection();
    HRESULT ParseSubstSection();
    HRESULT BitmapColorReplacement(DWORD *pPixelBuff, UINT iWidth, UINT iHeight);
    HRESULT PackageImageData(LPCWSTR szFileNameR, LPCWSTR szFileNameG, LPCWSTR szFileNameB, int iDibPropNum);
    HRESULT PackageNtlCode(LPCWSTR szFileName);
    HRESULT LoadResourceProperties();
    void EmptyResourceProperties();
    HRESULT GetResourceProperty(LPCWSTR pszPropName, LPWSTR pszValueBuff,
        int cchMaxValueChars);

    //---- primitive value parsers ----
    HRESULT ParseEnumValue(int iSymType);
    HRESULT ParseStringValue(int iSymType, LPWSTR pszBuff=NULL, DWORD dwMaxBuffChars=0);
    HRESULT ParseIntValue(int iSymType, int *piValue=NULL);
    HRESULT ParseBoolValue(int iSymType, LPCWSTR pszPropertyName);
    HRESULT ParseColorValue(int iSymType, COLORREF *pcrValue=NULL, COLORREF *pcrValue2=NULL);
    HRESULT ParseMarginsValue(int iSymType);
    HRESULT ParseIntListValue(int iSymType);
    HRESULT ParseFileNameValue(int iSymType, LPWSTR pszBuff=NULL, DWORD dwMaxBuffChars=0);
    HRESULT ParseSizeValue(int iSymType);
    HRESULT ParsePositionValue(int iSymType);
    HRESULT ParseRectValue(int iSymType, LPCWSTR pszPropertyName);
    HRESULT ParseFontValue(int iSymType, LPCWSTR pszPropertyName);
    HRESULT AddThemeData(int iTypeNum, PRIMVAL ePrimVal, const void *pData, DWORD dwLen);
    HRESULT ParseSizeInfoUnits(int iVal, LPCWSTR pszDefaultUnits, int *piPixels);
    HRESULT GetIntList(int *pInts, LPCWSTR *pParts, int iCount, 
        int iMin, int iMax);
    HRESULT ParseSysFont(LOGFONT *pFont);
    HRESULT ParseSysColor(LPCWSTR szId, COLORREF *pcrValue);
    HRESULT GenerateEmptySection(LPCWSTR pszSectionName, int iPartId, int iStateId);

    //---- private data ----
    CScanner _scan;
    CSimpleFile _outfile;
    int _iEnumCount;
    int _iTypeCount;
    int _iFontNumber;           // for using resource-based strings as font values
    BOOL _fGlobalTheme;
    BOOL _fGlobalsDefined;
    BOOL _fClassSectionDefined;
    BOOL _fDefiningColorScheme;
    BOOL _fUsingResourceProperties;
    UCHAR _uCharSet;

    //---- current section info ----
    int _iPartId;
    int _iStateId;
    WCHAR _szClassName[MAX_PATH];
    WCHAR _szBaseSectionName[MAX_PATH];          // of current section
    WCHAR _szFullSectionName[MAX_PATH];          // of current section

    CSimpleArray<ENUMVAL> _EnumVals;
    CSimpleArray<SYMBOL> _Symbols;
    CSimpleArray<HBITMAP> _StockBitmapCleanupList;
    IParserCallBack *_pCallBackObj;
    THEMEENUMPROC _pNameCallBack;
    LPARAM _lNameParam;
    DWORD _dwParseFlags;
    WCHAR _ColorParam[MAX_PATH+1];
    HINSTANCE _hinstThemeDll;
    LPCWSTR _pszDocProperty;
    LPWSTR _pszResult;      // for querying doc property
    DWORD _dwMaxResultChars;

    //---- color substitution table ----
    int _iColorCount;
    COLORREF _crFromColors[5];
    COLORREF _crToColors[5];
    COLORREF _crBlend;

    //---- hue substitution table ----
    int _iHueCount;
    BYTE _bFromHues[5];
    BYTE _bToHues[5];

    //---- theme metrics table ----
    BOOL _fDefiningMetrics;
    BOOL _fMetricsDefined;

    //---- resource properties ----
    CSimpleArray<CWideString> _PropertyNames;
    CSimpleArray<CWideString> _PropertyValues;
    CSimpleArray<int> _iPropertyIds;

    WCHAR _szResPropValue[2*MAX_PATH];
    int _iResPropId;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\ntleng.h ===
//-------------------------------------------------------------------------
//	NtlEng.h - support for Native Theme Language runtime graphics engine
//-------------------------------------------------------------------------
#ifndef _NTLENG_H_
#define _NTLENG_H_
//-------------------------------------------------------------------------
#include "ntl.h"
//-------------------------------------------------------------------------
class INtlEngCallBack           // Caller must implement
{
public:
    virtual HRESULT CreateImageBrush(HDC hdc, int iPartId, int IStateId,
        int iImageIndex, HBRUSH *phbr) = 0;
};
//---------------------------------------------------------------------------
HRESULT RunNtl(HDC hdc, RECT &rcCaller, HBRUSH hbrBkDefault, DWORD dwOptions, 
     int iPartId, int iStateId, BYTE *pbCode, int iCodeLen, INtlEngCallBack *pCallBack);
//-------------------------------------------------------------------------
#endif  //  _NTLENG_H_
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\stringtable.h ===
//--------------------------------------------------------------------
//   StringTable.h - shared error strings for theme modules
//--------------------------------------------------------------------
#define IDC_MYICON                      2
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_SMALL                       108
#define IDC_UXTHEME                     109
#define IDS_UXTHEME                     109

#define IDR_MAINFRAME                   128
#define IDB_TOPLEFT                     134
#define IDB_BOTTOMLEFT                  135
#define IDB_TOPRIGHT                    136
#define IDB_BOTTOMRIGHT                 137
#define IDB_LEFT                        138
#define IDB_RIGHT                       139
#define IDB_TOP                         140
#define IDB_BOTTOM                      141
#define IDB_SAMPLE                      151

//---- do NOT renumber these (bad for localization teams) ----

//---- only PARSER Errors are allowed as custom error codes ----

#define PARSER_IDS_TYPE_DEFINED_TWICE          115
#define PARSER_IDS_MISSING_SECTION_LBRACKET    122
#define PARSER_IDS_NOT_ENUM_VALNAME            123
#define PARSER_IDS_EXPECTED_TRUE_OR_FALSE      124
#define PARSER_IDS_CS_MUST_BE_BEFORE_GLOBLS    125
#define PARSER_IDS_CS_MUST_BE_BEFORE_CLASSES   126

#define PARSER_IDS_UNKNOWN_SECTION_NAME        129
#define PARSER_IDS_EXPECTED_DOUBLE_COLON       130
#define PARSER_IDS_MISSING_SECT_HDR_NAME       131
#define PARSER_IDS_ENUM_NOT_DEFINED            132
#define PARSER_IDS_MISSING_SECT_HDR_PART       133
#define PARSER_IDS_MISSING_SECT_HDR_STATE      134
#define PARSER_IDS_EXPECTED_RPAREN             135
#define PARSER_IDS_EXPECTED_END_OF_SECTION     136
#define PARSER_IDS_ENUM_VALNAME_EXPECTED       137
#define PARSER_IDS_INT_EXPECTED                138
#define PARSER_IDS_BOOL_EXPECTED               139
#define PARSER_IDS_BAD_COLOR_VALUE             140
#define PARSER_IDS_BAD_MARGINS_VALUE           141
#define PARSER_IDS_ILLEGAL_SIZE_VALUE          146
#define PARSER_IDS_ILLEGAL_RECT_VALUE          147
#define PARSER_IDS_UNKNOWN_SIZE_UNITS          148
#define PARSER_IDS_LBRACKET_EXPECTED           149
#define PARSER_IDS_SYS_COLOR_EXPECTED          150
#define PARSER_IDS_RBRACKET_EXPECTED           151
#define PARSER_IDS_END_OF_LINE_EXPECTED        152
#define PARSER_IDS_UNKNOWN_SYS_COLOR           153
#define PARSER_IDS_INVALID_SYSFONT             154
#define PARSER_IDS_EXPECTED_SYSFONT_ID         155
#define PARSER_IDS_UNKNOWN_SYSFONT_ID          156
#define PARSER_IDS_UNKNOWN_FONT_FLAG           157
#define PARSER_IDS_EXPECTED_PROP_NAME          158
#define PARSER_IDS_EXPECTED_EQUALS_SIGN        159
#define PARSER_IDS_UNKNOWN_PROP                160
#define PARSER_IDS_EXTRA_PROP_TEXT             161
#define PARSER_IDS_CS_NAME_EXPECTED            162
#define PARSER_IDS_ILLEGAL_CS_PROPERTY         163
#define PARSER_IDS_GLOBALS_MUST_BE_FIRST       164
#define PARSER_IDS_EXPECTED_DOT_SN             165
#define PARSER_IDS_CHARSETFIRST                166
#define PARSER_IDS_CHARSET_GLOBALS_ONLY        167
#define PARSER_IDS_BADSECT_THEMES_INI          168
#define PARSER_IDS_BADSECT_CLASSDATA           169
#define PARSER_IDS_ILLEGAL_SS_PROPERTY         170
#define PARSER_IDS_SS_NAME_EXPECTED            171
#define PARSER_IDS_NOOPEN_IMAGE                173
#define PARSER_IDS_FS_NAME_EXPECTED            172
#define PARSER_IDS_THEME_TOO_BIG               174
#define PARSER_IDS_METRICS_MUST_COME_BEFORE_CLASSES 176
#define PARSER_IDS_PARTS_NOT_DEFINED           177
#define PARSER_IDS_STATES_NOT_DEFINED          178

#if 0       // NTL parsing
#define PARSER_IDS_OPTIONNAME_EXPECTED         179
#define PARSER_IDS_ALREADY_DEFINED             180
#define PARSER_IDS_LEFTPAREN_EXPECTED          181
#define PARSER_IDS_STATENAME_EXPECTED          183
#define PARSER_IDS_DRAWINGPROP_EXPECTED        184
#define PARSER_IDS_RECT_EXPECTED               186
#define PARSER_IDS_COMMA_EXPECTED              187
#define PARSER_IDS_SIZE_EXPECTED               188
#define PARSER_IDS_COLORVALUE_EXPECTED         189
#define PARSER_IDS_POINT_EXPECTED              190
#define PARSER_IDS_ONOFF_EXPECTED              191
#define PARSER_IDS_MAX_IFNESTING               192
#define PARSER_IDS_NOMATCHINGIF                193
#define PARSER_IDS_WRONG_IF_BITNAME            194
#define PARSER_IDS_WRONG_ELSE_PARAM            195
#define PARSER_IDS_STATEID_EXPECTED            196
#endif

#define PARSER_IDS_NOT_ALLOWED_SYSMETRICS      197
#define PARSER_IDS_PARTSTATE_ALREADY_DEFINED   205
#define PARSER_IDS_INTERNAL_TM_ERROR           207
#define PARSER_IDS_UNKNOWN_BITNAME             208
#define PARSER_IDS_VALUE_NAME_EXPECTED         209
#define PARSER_IDS_UNKNOWN_VALUE_NAME          210
#define PARSER_IDS_VALUE_PART_SPECIFIED_TWICE  211
#define PARSER_IDS_NUMBER_EXPECTED             213
#define PARSER_IDS_NUMBER_OUT_OF_RANGE         214
#define PARSER_IDS_UNKNOWN_STATE               215
#define PARSER_IDS_STATE_MUST_BE_DEFINED       222
#define PARSER_IDS_COLOR_EXPECTED              223
#define PARSER_IDS_BAD_RES_PROPERTY            233
#define PARSER_IDS_BAD_SUBST_SYMBOL            234
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\scanner.h ===
//---------------------------------------------------------------------------
//  Scanner.h - supports parsing lines & text files
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#define ISNUMSTART(p)   ((isdigit(*p)) || (*p == '-') || (*p == '+'))
#define IS_NAME_CHAR(p) ((isalnum(*p)) || (*p == '_') || (*p == '-'))
//---------------------------------------------------------------------------
#define MAX_ID_LEN      _MAX_PATH
#define MAX_INPUT_LINE  255
//---------------------------------------------------------------------------
class CScanner
{
public:
    CScanner(LPCWSTR pszTextToScan=NULL);
    ~CScanner();
    HRESULT AttachFile(LPCWSTR pszFileName);
    BOOL AttachLine(LPCWSTR pszLine);
    BOOL AttachMultiLineBuffer(LPCWSTR pszBuffer, LPCWSTR pszFileName);
    BOOL GetId(LPWSTR pszIdBuff, DWORD dwMaxLen=MAX_ID_LEN);
    BOOL GetIdPair(LPWSTR pszIdBuff, LPWSTR pszValueBuff, DWORD dwMaxLen=MAX_ID_LEN);
    BOOL GetKeyword(LPCWSTR pszKeyword);
    BOOL GetFileName(LPWSTR pszBuff, DWORD dwMaxLen);
    BOOL GetNumber(int *piVal);
    BOOL IsNameChar(BOOL fOkToSkip=TRUE);
    BOOL IsFileNameChar(BOOL fOkToSkip);
    BOOL IsNumStart();
    BOOL GetChar(const WCHAR val);
    BOOL EndOfLine();
    BOOL EndOfFile();
    BOOL ForceNextLine();
    BOOL SkipSpaces();              // called by CScanner before all checking routines
    BOOL ReadNextLine();
    void UseSymbol(LPCWSTR pszSymbol);

protected:
    void ResetAll(BOOL fPossiblyAllocated);

public:
    //---- data ----
    const WCHAR *_p;              // accessible for special comparisons
    const WCHAR *_pSymbol;        // if not null, use this instead of _p
    WCHAR _szLineBuff[MAX_INPUT_LINE+1];
    WCHAR _szFileName[_MAX_PATH+1];
    LPCWSTR _pszMultiLineBuffer;
    LPWSTR _pszFileText;
    int _iLineNum;
    BOOL _fEndOfFile;
    BOOL _fBlankSoFar;
    BOOL _fUnicodeInput;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\syscolors.h ===
//---------------------------------------------------------------------------
//   syscolors.h
//---------------------------------------------------------------------------
extern WCHAR *pszSysColorNames[];
extern const int iSysColorSize;

#ifdef SYSCOLOR_STRINGS

WCHAR *pszSysColorNames[] = 
{
   L"Scrollbar",        // 0
   L"Background",       // 1
   L"ActiveTitle",      // 2
   L"InactiveTitle",    // 3
   L"Menu",             // 4
   L"Window",           // 5
   L"WindowFrame",      // 6
   L"MenuText",         // 7
   L"WindowText",       // 8
   L"TitleText",        // 9
   L"ActiveBorder",     // 10
   L"InactiveBorder",   // 11
   L"AppWorkspace",     // 12
   L"Hilight",          // 13
   L"HilightText",      // 14
   L"ButtonFace",       // 15
   L"ButtonShadow",     // 16
   L"GrayText",         // 17
   L"ButtonText",       // 18
   L"InactiveTitleText",     // 19
   L"ButtonHilight",         // 20
   L"ButtonDkShadow",        // 21
   L"ButtonLight",           // 22
   L"InfoText",              // 23
   L"InfoWindow",            // 24
   L"ButtonAlternateFace",   // 25
   L"HotTrackingColor",      // 26
   L"GradientActiveTitle",   // 27
   L"GradientInactiveTitle", // 28
   L"MenuHilight",           // 29
   L"MenuBar",               // 30
};

const int iSysColorSize = ARRAYSIZE(pszSysColorNames);
#endif
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\signing.h ===
//  --------------------------------------------------------------------------
//  Module Name: Signing.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  A class to handle signing on themes.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

#ifndef     _ThemeSignature_
#define     _ThemeSignature_

#include <wincrypt.h>

int GetIndexFromDate(void);
BOOL StrToInt64ExInternalW(LPCWSTR pszString, DWORD dwFlags, LONGLONG *pllRet);


//  --------------------------------------------------------------------------
//  CThemeSignature
//
//  Purpose:    This class knows about signing and verification of themes. It
//              has the public and private keys encapsulated within it. This
//              is information that nobody needs to know. It provides three
//              public functions to do the work.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------

class   CThemeSignature
{
private:
    typedef enum
    {
        KEY_NONE        =   0,
        KEY_PUBLIC,
        KEY_PRIVATE
    } KEY_TYPES;

public:
    CThemeSignature(void);
    CThemeSignature(OPTIONAL const BYTE * pvPrivateKey, OPTIONAL DWORD cbPrivateKeySize);
    ~CThemeSignature (void);
public:
    HRESULT         Verify (const WCHAR *pszFilename, bool fNoSFCCheck);
    HRESULT         Sign (const WCHAR *pszFilename);
    HRESULT         Generate (void);
private:
    bool            HasProviderAndHash (void)   const;
    bool            IsProtected (const WCHAR *pszFilename)  const;
    HRESULT         CreateKey (KEY_TYPES keyType);
    HRESULT         CalculateHash (HANDLE hFile, KEY_TYPES keyType);
    HRESULT         SignHash (void);
    HRESULT         ReadSignature (HANDLE hFile, void *pvSignature);
    HRESULT         WriteSignature (const WCHAR *pszFilename, const void *pvSignature, DWORD dwSignatureSize);
    HRESULT         CreateExportKey (DWORD dwBlobType, void*& pvKey, DWORD& dwKeySize);
    void            PrintKey (const void *pvKey, DWORD dwKeySize);
    bool            SafeStringConcatenate (WCHAR *pszString1, const WCHAR *pszString2, DWORD cchString1)    const;
    void            _Init(OPTIONAL const BYTE * pvPrivateKey, OPTIONAL DWORD cbPrivateKeySize);

private:
    HCRYPTPROV      _hCryptProvider;
    HCRYPTHASH      _hCryptHash;
    HCRYPTKEY       _hCryptKey;
    void*           _pvSignature;
    DWORD           _dwSignatureSize;

    const BYTE *    _pvPrivateKey;              // May be NULL
    DWORD           _cbPrivateKeySize;

    static  const WCHAR     s_szDescription[];
    static  const WCHAR     s_szThemeDirectory[];
    static  const WCHAR*    s_szKnownThemes[];
    static  const BYTE      s_keyPublic2[];

    const BYTE * _GetPublicKey(void);
    HRESULT _CheckLocalKey(void);
};

HRESULT CheckThemeFileSignature(LPCWSTR pszName);

#endif  /*  _ThemeSignature_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\themefile.h ===
//---------------------------------------------------------------------------
//  ThemeFile.h - manages loaded theme files
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
class CUxThemeFile      // changed from "CThemeFile" to avoid conflict with
{                       // class of same name in themeui
    //---- methods ----
public:
    CUxThemeFile();
    ~CUxThemeFile();

    HRESULT CreateFile(int iLength, BOOL fReserve = FALSE);
    HRESULT CreateFromSection(HANDLE hSection);
    HRESULT OpenFromHandle(HANDLE handle, BOOL fCleanupOnFailure = FALSE);
    HRESULT ValidateThemeData(BOOL fFullCheck);
    bool IsReady();
    bool IsGlobal();
    bool HasStockObjects();
    
    HANDLE Handle()
    {
        if (this)
            return _hMemoryMap;

        return NULL;
    }

    DWORD DataCheckSum();
    void CloseFile();
    void Reset();
    HANDLE Unload();
    BOOL ValidateObj();

    //---- data ----
    char _szHead[8];
    BYTE *_pbThemeData;         // ptr to shared memory block
    HANDLE _hMemoryMap;         // handle to memory mapped file
    char _szTail[4];
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\themeldr.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation 1991-2000
//
// File   : ThemeLdr.h - defines private library routines for loading themes
//                       (used by msgina.dll)
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _THEMELDR_H_                   
#define _THEMELDR_H_                   
//---------------------------------------------------------------------------
#include "uxthemep.h"       // for various DWORD flags (not functions)
//---------------------------------------------------------------------------
// Define API decoration 
#if (! defined(_THEMELDR_))
#define TLAPI          EXTERN_C HRESULT STDAPICALLTYPE
#define TLAPI_(type)   EXTERN_C type STDAPICALLTYPE
#else
#define TLAPI          STDAPI
#define TLAPI_(type)   STDAPI_(type)
#endif
//---------------------------------------------------------------------------
//---- functions used by packthem (from themeldr.lib) ----

BOOL ThemeLibStartUp(BOOL fThreadAttach);
BOOL ThemeLibShutDown(BOOL fThreadDetach);

HRESULT _GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo);

HRESULT _ParseThemeIniFile(LPCWSTR pszFileName,  
    DWORD dwParseFlags, OPTIONAL THEMEENUMPROC pfnCallBack, OPTIONAL LPARAM lparam);

//---------------------------------------------------------------------------
#endif // _THEMELDR_H_                               
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\sysmetrics.h ===
//---------------------------------------------------------------------------
//   sysmetrics.h
//---------------------------------------------------------------------------
WCHAR *pszSysMetricIntNames[] = 
{
   L"BorderWidth",       
   L"ScrollBarWidth",    
   L"ScrollBarHeight",   
   L"CaptionBarWidth",   
   L"CaptionBarHeight",  
   L"SmCaptionBarWidth", 
   L"SmCaptionBarHeight", 
   L"MenuBarWidth",       
   L"MenuBarHeight",      
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\simpstr.h ===
//---------------------------------------------------------------------------
//   SimpStr.h - defines simple string classes
//---------------------------------------------------------------------------
#ifndef _SIMPSTR_H_
#define _SIMPSTR_H_
//---------------------------------------------------------------------------
class CWideString           // simplified version of CString
{
public:
    //--------------------------------------------------------------
    CWideString(LPCWSTR pszString=NULL)
    {
        _pWideString = NULL;

        if (pszString)
        {
            int len = lstrlen(pszString);
            _pWideString = new WCHAR[1+len];

            if (_pWideString)
            {
                lstrcpy(_pWideString, pszString);
            }
        }
    }

    //--------------------------------------------------------------
    CWideString(CWideString &wsCopy)
    {
        _pWideString = NULL;

        if (wsCopy._pWideString)
        {
            int len = lstrlen(wsCopy._pWideString);
            _pWideString = new WCHAR[1+len];

            if (_pWideString)
            {
                lstrcpy(_pWideString, wsCopy._pWideString);
            }
        }
    }

    //--------------------------------------------------------------
    ~CWideString()
    {
        if (_pWideString)
            delete [] _pWideString;
    }

    //--------------------------------------------------------------
    CWideString & operator = (CWideString &wsNew)
    {
        //---- delete our old string ----
        if (_pWideString)
        {
            delete [] _pWideString;
            _pWideString = NULL;
        }

        //---- copy new string, if not NULL ----
        if (wsNew._pWideString)
        {
            int len = lstrlen(wsNew._pWideString);
            _pWideString = new WCHAR[1+len];

            if (_pWideString)
            {
                lstrcpy(_pWideString, wsNew._pWideString);
            }
        }

        return *this;
    }

    //--------------------------------------------------------------
    CWideString & operator = (LPCWSTR pNewString)
    {
        //---- delete our old string ----
        if (_pWideString)
        {
            delete [] _pWideString;
            _pWideString = NULL;
        }

        //---- copy new string, if not NULL ----
        if (pNewString)
        {
            int len = lstrlen(pNewString);
            _pWideString = new WCHAR[1+len];

            if (_pWideString)
            {
                lstrcpy(_pWideString, pNewString);
            }
        }

        return *this;
    }
    //--------------------------------------------------------------
    operator LPCWSTR() const
    {
        return _pWideString;
    }

    //--------------------------------------------------------------
    int GetLength()
    {
        int iLen = 0;

        if (_pWideString)
        {
            iLen = lstrlen(_pWideString);
        }
        
        return iLen;
    }
    //--------------------------------------------------------------

protected:
    LPWSTR _pWideString;
};
//---------------------------------------------------------------------------
template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
        //---- always call the dtr ----
#if _MSC_VER >= 1200
		m_aT[nIndex].~T();
#else
        T* MyT;
        MyT = &m_aT[nIndex];
        MyT->~T();
#endif

        if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		}

		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
				m_aT[i].~T();
#else
                T* MyT;
                MyT = &m_aT[i];
                MyT->~T();
#endif
            }
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		T t;
	};
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(m_aT + nIndex) Wrapper(t);
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;  // not found
	}
};
#endif      // _SIMPSTR_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\packthem\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PackThem.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\tmutils.h ===
//-------------------------------------------------------------------------
//	TmUtils.h - theme manager shared utilities
//-------------------------------------------------------------------------
#ifndef _TMUTILS_H_
#define _TMUTILS_H_
//-------------------------------------------------------------------------
#include "themefile.h"
//-------------------------------------------------------------------------
#define DIBDATA(infohdr) (((BYTE *)(infohdr)) + infohdr->biSize + \
	infohdr->biClrUsed*sizeof(RGBQUAD))

#define THEME_OFFSET(x)         int(x - _LoadingThemeFile._pbThemeData)
#define THEMEFILE_OFFSET(x)     int(x - pThemeFile->_pbThemeData)
//------------------------------------------------------------------------------------
class CMemoryDC
{
public:
    CMemoryDC();
    ~CMemoryDC();
    HRESULT OpenDC(HDC hdcSource, int iWidth, int iHeight);
    void CloseDC();
    operator HDC() {return _hdc;}

    HBITMAP _hBitmap;

protected:
    //---- private data ----
    HDC _hdc;
    HBITMAP _hOldBitmap;
};
//------------------------------------------------------------------------------------
class CBitmapPixels
{
public:
    CBitmapPixels();
    ~CBitmapPixels();

    //---- "OpenBitmap()" returns a ptr to pixel values in bitmap. ----
    //---- Rows go from bottom to top; Colums go from left to right. ----
    //---- IMPORTANT: pixel DWORDS have RGB bytes reversed from COLORREF ----
    HRESULT OpenBitmap(HDC hdc, HBITMAP bitmap, BOOL fForceRGB32, 
        DWORD OUT **pPixels, OPTIONAL OUT int *piWidth=NULL, OPTIONAL OUT int *piHeight=NULL, 
        OPTIONAL OUT int *piBytesPerPixel=NULL, OPTIONAL OUT int *piBytesPerRow=NULL, 
        OPTIONAL OUT int *piPreviousBytesPerPixel = NULL, OPTIONAL UINT cbBytesBefore = 0);

    void CloseBitmap(HDC hdc, HBITMAP hBitmap);

    //---- Pointer to the total buffer (including cbBytesBefore)
    BYTE *Buffer();

    //---- public data ----
    BITMAPINFOHEADER *_hdrBitmap;

protected:
    //---- private data ----
    int _iWidth;
    int _iHeight;
    BYTE* _buffer;
};
//------------------------------------------------------------------------------------
HRESULT LoadThemeLibrary(LPCWSTR pszThemeName, HINSTANCE *phInst);

LPCWSTR ThemeString(CUxThemeFile *pThemeFile, int iOffset);

HRESULT GetThemeNameId(CUxThemeFile *pThemeFile, LPWSTR pszFileNameBuff, UINT cchFileNameBuff,
    LPWSTR pszColorParam, UINT cchColorParam, LPWSTR pszSizeParam, UINT cchSizeParam, int *piSysMetricsIndex, LANGID *pwLangID);
BOOL ThemeMatch (CUxThemeFile *pThemeFile, LPCWSTR pszThemeName, LPCWSTR pszColorName, LPCWSTR pszSizeName, LANGID wLangID);

HRESULT _EnumThemeSizes(HINSTANCE hInst, LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, OUT THEMENAMEINFO *ptn, BOOL fCheckColorDepth);
HRESULT _EnumThemeColors(HINSTANCE hInst, LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, OUT THEMENAMEINFO *ptn, BOOL fCheckColorDepth);

HRESULT GetSizeIndex(HINSTANCE hInst, LPCWSTR pszSize, int *piIndex);
HRESULT GetColorSchemeIndex(HINSTANCE hInst, LPCWSTR pszSize, int *piIndex);
HRESULT FindComboData(HINSTANCE hDll, COLORSIZECOMBOS **ppCombos);
HRESULT GetThemeSizeId(int iSysSizeId, int *piThemeSizeId);
int GetLoadIdFromTheme(CUxThemeFile *pThemeFile);
//---------------------------------------------------------------------------
#endif  //  _TMUTILS_H_
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\tmreg.h ===
//---------------------------------------------------------------------------
//  TmReg.h - theme manager registry access routines
//---------------------------------------------------------------------------
#pragma once
//  --------------------------------------------------------------------------
//  CCurrentUser
//
//  Purpose:    Manages obtaining HKEY_CURRENT_USER even when impersonation
//              is in effect to ensure that the correct user hive is
//              referenced.
//
//  History:    2000-08-11  vtan        created
//  --------------------------------------------------------------------------

class   CCurrentUser
{
    private:
                CCurrentUser (void);
    public:
                CCurrentUser (REGSAM samDesired);
                ~CCurrentUser (void);

                operator HKEY (void)    const;
    private:
        HKEY    _hKeyCurrentUser;
};

//---------------------------------------------------------------------------
//  Theme registry keys (exposed ones in uxthemep.h)
//---------------------------------------------------------------------------
//---- key root ----
#define THEMEMGR_REGKEY              L"Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"
#define THEMES_REGKEY                L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes"

//---- theme active/loaded before ----
#define THEMEPROP_THEMEACTIVE        L"ThemeActive"
#define THEMEPROP_LOADEDBEFORE       L"LoadedBefore"

//---- local machine -to- current user propogation keys ----
#define THEMEPROP_LMVERSION          L"LMVersion"
#define THEMEPROP_LMOVERRIDE         L"LMOverRide"

//---- theme identification ----
#define THEMEPROP_DLLNAME            L"DllName"
#define THEMEPROP_COLORNAME          L"ColorName"
#define THEMEPROP_SIZENAME           L"SizeName"
#define THEMEPROP_LANGID             L"LastUserLangID"

//---- theme loading options ----
#define THEMEPROP_COMPOSITING        L"Compositing"
#define THEMEPROP_DISABLECACHING     L"DisableCaching"

//---- obsolete loading options ----
#define THEMEPROP_TARGETAPP          L"TargetApp"
#define THEMEPROP_EXCLUDETARGETAPP   L"ExcludeTarget"
#define THEMEPROP_DISABLEFRAMES      L"DisableFrames"
#define THEMEPROP_DISABLEDIALOGS     L"DisableDialogs"

//---- debug logging ----
#define THEMEPROP_LOGCMD             L"LogCmd"
#define THEMEPROP_BREAKCMD           L"BreakCmd"
#define THEMEPROP_LOGAPPNAME         L"LogAppName"

//---- custom app theming ----
#define THEMEPROP_CUSTOMAPPS         L"Apps"

#ifdef  __TRAP_360180__
#define THEMEPROP_TRAP360180         L"ShrinkTrap"
#endif  __TRAP_360180__


//---- themeui values ----
#define CONTROLPANEL_APPEARANCE_REGKEY  L"Control Panel\\Appearance"

#define REGVALUE_THEMESSETUPVER      L"SetupVersion"
#define THEMEPROP_WHISTLERBUILD      L"WCreatedUser"
#define THEMEPROP_CURRSCHEME         L"Current"                 // This key is stored under CU,"Control Panel\Appearance"
#define THEMEPROP_NEWCURRSCHEME      L"NewCurrent"              // This key is stored under CU,"Control Panel\Appearance" and will be set to the Whistler selected Appearance scheme.

#define SZ_INSTALL_VS                L"/InstallVS:'"
#define SZ_USER_INSTALL              L"/UserInstall"
#define SZ_DEFAULTVS_OFF             L"DefaultVisualStyleOff"
#define SZ_INSTALLVISUALSTYLE        L"InstallVisualStyle"
#define SZ_INSTALLVISUALSTYLECOLOR   L"InstallVisualStyleColor"
#define SZ_INSTALLVISUALSTYLESIZE    L"InstallVisualStyleSize"

//---- policy values ----
#define SZ_POLICY_SETVISUALSTYLE     L"SetVisualStyle"
#define SZ_THEME_POLICY_KEY          L"System"

//---------------------------------------------------------------------------
HRESULT GetCurrentUserThemeInt(LPCWSTR pszValueName, int iDefaultValue, int *piValue);
HRESULT SetCurrentUserThemeInt(LPCWSTR pszValueName, int iValue);

HRESULT GetCurrentUserString(LPCWSTR pszKeyName, LPCWSTR pszValueName, LPCWSTR pszDefaultValue,
    LPWSTR pszBuff, DWORD dwMaxBuffChars);
HRESULT SetCurrentUserString(LPCWSTR pszKeyName, LPCWSTR pszValueName, LPCWSTR pszValue);

HRESULT GetCurrentUserThemeString(LPCWSTR pszValueName, LPCWSTR pszDefaultValue,
    LPWSTR pszBuff, DWORD dwMaxBuffChars);
HRESULT SetCurrentUserThemeString(LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT SetCurrentUserThemeStringExpand(LPCWSTR pszValueName, LPCWSTR pszValue);

HRESULT DeleteCurrentUserThemeValue(LPCWSTR pszKeyName);
BOOL IsRemoteThemeDisabled();
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\inc\utils.h ===
//---------------------------------------------------------------------------
//    utils.h - theme code utilities
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include <uxthemep.h>
#include <commctrl.h>

#include <math.h>
//---------------------------------------------------------------------------
#define THEMEDLL_EXT        L".msstyles"
#define DEFAULT_THEME       L".\\luna\\luna.msstyles"

#define CONTAINER_NAME      L"themes.ini"
#define CONTAINER_RESNAME   L"themes_ini"

#define USUAL_CLASSDATA_NAME   L"default.ini"

//---------------------------------------------------------------------------
#define RESOURCE         // marks vars as being needed to be freed at block exit
//---------------------------------------------------------------------------
#ifdef DEBUG
#define _DEBUG
#endif
//---------------------------------------------------------------------------
#define COMBOENTRY(combo, color, size) \
    (combo->sFileNums[size*combo->cColorSchemes + color])
//---------------------------------------------------------------------------
#define SAFE_ATOM_DELETE(x) if (1) {GlobalDeleteAtom(x); x = 0;} else
#define SAFE_DELETE_GDIOBJ(hgdiobj) if((hgdiobj)) {DeleteObject(hgdiobj); (hgdiobj)=NULL;}
//---------------------------------------------------------------------------
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif  ARRAYSIZE

#define WIDTH(r) ((r).right - (r).left)
#define HEIGHT(r) ((r).bottom - (r).top)

#ifndef RECTWIDTH
#define RECTWIDTH(prc)  ((prc)->right - (prc)->left)
#endif  RECTWIDTH

#ifndef RECTHEIGHT
#define RECTHEIGHT(prc)  ((prc)->bottom - (prc)->top)
#endif  RECTHEIGHT

#ifndef BOOLIFY
#define BOOLIFY(val)     ((val) ? TRUE : FALSE)
#endif  BOOLIFY

#ifndef TESTFLAG
#define TESTFLAG(field,bits)  (((field)&(bits)) ? TRUE : FALSE)
#endif  TESTFLAG

//---------------------------------------------------------------------------
#ifdef __cplusplus
#define SAFE_DELETE(p)          { delete (p); (p)=NULL; }
#define SAFE_DELETE_ARRAY(prg)  { delete [] (prg); (prg)=NULL; }
#endif //__cplusplus
//---------------------------------------------------------------------------
#define RED(c)      GetRValue(c)
#define GREEN(c)    GetGValue(c)
#define BLUE(c)     GetBValue(c)
#define ALPHACHANNEL(c) BYTE((c) >> 24)
//---------------------------------------------------------------------------
#define REVERSE3(c) ((RED(c) << 16) | (GREEN(c) << 8) | BLUE(c))
//---------------------------------------------------------------------------
#define LAST_SYSCOLOR   (COLOR_MENUBAR)     // last color defined in winuser.h

#define TM_COLORCOUNT   (LAST_SYSCOLOR+1)   // # of colors we care about
//---------------------------------------------------------------------------
#define ULONGAT(p) (*((LONG *)(p)))
//---------------------------------------------------------------------------
#define THEME_DPI    96

#define DPISCALE(val, DcDpi)  MulDiv(val, DcDpi, THEME_DPI)

#define ROUND(flNum) (int(floor((flNum)+.5)))
//---------------------------------------------------------------------------
inline BOOL DpiDiff(HDC hdc, OUT int *piDcDpiH, OUT int *piDcDpiV = NULL)
{
    BOOL fDiff = FALSE;
    BOOL fGotDc = (hdc != NULL);

    if (! fGotDc)
        hdc = GetWindowDC(NULL);

    if (hdc)
    {
        *piDcDpiH = GetDeviceCaps(hdc, LOGPIXELSX);

        if (piDcDpiV)
        {
            *piDcDpiV = GetDeviceCaps(hdc, LOGPIXELSY);
        }

        if (! fGotDc)
            ReleaseDC(NULL, hdc);

        fDiff = (*piDcDpiH != THEME_DPI);
    }

    return fDiff;
}
//---------------------------------------------------------------------------
typedef BOOL (WINAPI *IMAGE_DRAWPROC) (IMAGELISTDRAWPARAMS* pimldp);
typedef int  (WINAPI *PFNDRAWSHADOWTEXT)(HDC hdc, LPCTSTR pszText, UINT cch, RECT* prc, 
    DWORD dwFlags, COLORREF crText, COLORREF crShadow, int ixOffset, int iyOffset);
//---------------------------------------------------------------------------
#if 1       // testing DrawThemeIcon()
typedef HIMAGELIST (WINAPI *IMAGE_LOADPROC) (HINSTANCE hi, LPCTSTR lpbmp,
   int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);

typedef BOOL (WINAPI *IMAGE_DESTROYPROC) (HIMAGELIST himl);

#endif
//---------------------------------------------------------------------------
struct COLORSIZECOMBOS         // binary resource in package
{
    WORD cColorSchemes;     // number of color schemes defined
    WORD cSizes;            // number of sizes defined
    SHORT sFileNums[1];     // 2 dim array (colors x sizes)
};
//---------------------------------------------------------------------------
union MIXEDPTRS
{
    BYTE *pb;
    char *pc;
    WORD *pw;
    SHORT *ps;
    WCHAR *px;
    int *pi;
    DWORD *pdw;
    POINT *ppt;
    SIZE *psz;
    RECT *prc;
};
//---------------------------------------------------------------------------
enum GRIDNUM
{
    GN_LEFTTOP = 0,
    GN_MIDDLETOP = 1,
    GN_RIGHTTOP = 2,
    GN_LEFTMIDDLE = 3,
    GN_MIDDLEMIDDLE = 4,
    GN_RIGHTMIDDLE = 5,
    GN_LEFTBOTTOM = 6,
    GN_MIDDLEBOTTOM = 7,
    GN_RIGHTBOTTOM = 8
};
//---------------------------------------------------------------------------
extern IMAGE_DRAWPROC ImageList_DrawProc;
extern HINSTANCE g_hInst;
extern PFNDRAWSHADOWTEXT CCDrawShadowText;

extern int g_iScreenDpi;
//---------------------------------------------------------------------------
inline bool IsSpace(WCHAR wch)
{
    WORD w = 0;
    GetStringTypeW(CT_CTYPE1, &wch, 1, &w);
    return (w & C1_SPACE) ? true : false;
}
//---------------------------------------------------------------------------
inline bool IsHexDigit(WCHAR wch)
{
    WORD w = 0;
    GetStringTypeW(CT_CTYPE1, &wch, 1, &w);
    return (w & C1_XDIGIT) ? true : false;
}
//---------------------------------------------------------------------------
inline bool IsDigit(WCHAR wch)
{
    WORD w = 0;
    GetStringTypeW(CT_CTYPE1, &wch, 1, &w);
    return (w & C1_DIGIT) ? true : false;
}

// A string compare that explicitely only works on english characters
int AsciiStrCmpI(const WCHAR *dst, const WCHAR *src);

//---------------------------------------------------------------------------
void ErrorBox(LPCSTR pszFormat, ...);
void lstrcpy_truncate(LPWSTR pszDest, LPCWSTR pszSrc, DWORD dwMaxDestChars);
void ForceDesktopRepaint();
void ReplChar(LPWSTR pszBuff, WCHAR wOldVal, WCHAR wNewVal);
void ApplyStringProp(HWND hwnd, LPCWSTR psz, ATOM atom);
//---------------------------------------------------------------------------
BOOL UtilsStartUp();
BOOL UtilsShutDown();

BOOL IsUnicode(LPCSTR pszBuff, int *piUnicodeStartOffset);
BOOL FileExists(LPCTSTR pszFullNameAndPath);
BOOL GetMyExePath(LPWSTR pszNameBuff);
BOOL lstrtoken(LPWSTR psz, WCHAR wch);
//---------------------------------------------------------------------------
HANDLE CmdLineRun(LPCTSTR pszExeName, LPCTSTR pszCmdLine=NULL, BOOL fHide=TRUE);
//---------------------------------------------------------------------------
HRESULT SyncCmdLineRun(LPCTSTR pszExeName, LPCTSTR pszParams=NULL);
HRESULT TextToFile(LPCWSTR szFileName, LPCWSTR szText);

HRESULT GetPtrToResource(HINSTANCE hInst, LPCWSTR pszResType, LPCWSTR pszResName,
    OUT void **ppBytes, OPTIONAL OUT DWORD *pdwBytes=NULL);

HRESULT GetResString(HINSTANCE hInst, LPCWSTR pszResType, int id, LPWSTR pszBuff,
    DWORD dwMaxBuffChars);

HRESULT AllocateTextResource(HINSTANCE hInst, LPCWSTR pszResName, LPWSTR *ppszText);

//---- uses LocalAlloc() to put text file into a string; use LocalFree() to release ----

HRESULT AllocateTextFile(LPCWSTR szFileName, OUT LPWSTR *ppszFileText,
    OUT OPTIONAL BOOL *pfWasAnsi);

HRESULT AddPathIfNeeded(LPCWSTR pszFileName, LPCWSTR pszPath, LPWSTR pszFullName,
    DWORD dwFullChars);
HRESULT hr_lstrcpy(LPWSTR pszDest, LPCWSTR pszSrc, DWORD dwMaxDestChars);
HRESULT GetDirBaseName(LPCWSTR pszDirName, LPWSTR pszBaseBuff, DWORD dwMaxBaseChars);
HRESULT AnsiToUnicode(LPSTR pszSource, LPWSTR pszDest, DWORD dwMaxDestChars);
HRESULT SetFileExt(LPCWSTR pszOrigName, LPCWSTR pszNewExt, OUT LPWSTR pszNewNameBuff);
BOOL UnExpandEnvironmentString(LPCWSTR pszPath, LPCWSTR pszEnvVar, LPWSTR pszResult, UINT cbResult);

HRESULT EnsureUxCtrlLoaded();
HRESULT RegistryIntWrite(HKEY hKey, LPCWSTR pszValueName, int iValue);
HRESULT RegistryStrWrite(HKEY hKey, LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT RegistryStrWriteExpand(HKEY hKey, LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT RegistryIntRead(HKEY hKey, LPCWSTR pszValueName, int *piValue);
HRESULT RegistryStrRead(HKEY hKey, LPCWSTR pszValueName, LPWSTR pszBuff, DWORD dwMaxChars);
BOOL PreMultiplyAlpha(DWORD *pPixelBuff, UINT iWidth, UINT iHeight);
HRESULT MakeFlippedBitmap(HBITMAP hSrcBitmap, HBITMAP *phFlipped);
HRESULT FlipDIB32(DWORD *pBits, UINT iWidth, UINT iHeight);
BOOL IsBiDiLocalizedSystem(void);
DWORD MinimumDisplayColorDepth (void);
bool CheckMinColorDepth(HINSTANCE hInst, DWORD dwCurMinDepth, int iIndex = -1);

void SafeSendMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
//---------------------------------------------------------------------------
WCHAR  *StringDup(LPCWSTR pszOrig);
BOOL    AsciiScanStringList( LPCWSTR pwszString, LPCWSTR* rgpwszList, int cStrings,
                        BOOL fIgnoreCase );
HICON  _GetWindowIcon(HWND hwnd, BOOL fPerferLargeIcon);

BOOL GetWindowDesktopName(HWND hwnd, LPWSTR pszName, DWORD dwMaxChars);

int FontPointSize(int iFontHeight);
//---------------------------------------------------------------------------
inline BOOL IsWindowProcess( HWND hwnd, DWORD dwProcessId )
{
    DWORD dwPid = 0;
    GetWindowThreadProcessId(hwnd, &dwPid);
    return dwProcessId == dwPid;
}
//---------------------------------------------------------------------------
void RGBtoHLS(COLORREF crColor, WORD *pfHue, WORD *pfSat, WORD *pfLum);
COLORREF HLStoRGB(WORD bHue, WORD bLum, WORD bSat);
int string2number(LPCWSTR psz);
//---------------------------------------------------------------------------
inline void MIRROR_POINT( IN const RECT& rcWindow, IN OUT POINT& pt )
{
    pt.x = rcWindow.right + rcWindow.left - pt.x;
}

//-------------------------------------------------------------------------//
inline void MIRROR_RECT( IN const RECT& rcWindow, IN OUT RECT& rc )
{
    DWORD dwWidth = RECTWIDTH(&rc);
    rc.right = rcWindow.right + rcWindow.left - rc.left;
    rc.left  = rc.right - dwWidth;
}
//-------------------------------------------------------------------------//
inline BOOL IsMirrored(HDC hdc)
{
    BOOL fMirrored = FALSE;

    DWORD dwVal = GetLayout(hdc);
    if ((dwVal != GDI_ERROR) && (dwVal & LAYOUT_RTL))
        fMirrored = TRUE;

    return fMirrored;
}
//-------------------------------------------------------------------------//
inline BOOL IsFlippingBitmaps(HDC hdc)
{
    BOOL fFlipping = FALSE;

    DWORD dwVal = GetLayout(hdc);
    if ((dwVal != GDI_ERROR) && (dwVal & LAYOUT_RTL))
    {
        if (! (dwVal & LAYOUT_BITMAPORIENTATIONPRESERVED))
            fFlipping = TRUE;
    }

    return fFlipping;
}
//---------------------------------------------------------------------------
inline void ScaleFontForScreenDpi(LOGFONT *plf)
{
    //---- scale from 96 dpi to current logical screen dpi ----
    if (plf->lfHeight < 0)          // specified in points
    {
        plf->lfHeight = MulDiv(plf->lfHeight, g_iScreenDpi, THEME_DPI);
    }
}
//---------------------------------------------------------------------------
inline int ScaleSizeForScreenDpi(int iValue)
{
    //---- scale from 96 dpi to current logical screen dpi ----
    return MulDiv(iValue, g_iScreenDpi, THEME_DPI);
}
//---------------------------------------------------------------------------
void ScaleFontForHdcDpi(HDC hdc, LOGFONT *plf);
int ScaleSizeForHdcDpi(HDC hdc, int iValue);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\preview\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PackThem.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\packthem\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PackThem.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\packthem\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set 
//---------------------------------------------------------------------------
#ifndef _STDAFX_H_
#define _STDAFX_H_
//---------------------------------------------------------------------------
#define _iswupper(_c)    ( iswctype(_c,_UPPER) )
#define _iswlower(_c)    ( iswctype(_c,_LOWER) )
#define _iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define _iswxdigit(_c)   ( iswctype(_c,_HEX) )
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define STRICT
#define _ATL_NO_ATTRIBUTES
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
//---------------------------------------------------------------------------
#include "autos.h"
#include "log.h"
#include "errors.h"
#include "utils.h"
//---------------------------------------------------------------------------
#include <atlbase.h> 
//---------------------------------------------------------------------------
#endif //_STDAFX_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\packthem\localsign.cpp ===
/*****************************************************************************\
    FILE: localsign.cpp

    DESCRIPTION:
        This code will sign and verify the signature of a Visual Style file.

    BryanSt 8/1/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"
#include <signing.h>
#include <stdio.h>
#include <windows.h>
#include "signing.h"
#include "localsign.h"
#include <shlwapip.h>




const BYTE * _GetPrivateKey(void)
{
    const BYTE * pKeyToReturn = NULL;

    pKeyToReturn = s_keyPrivate1;

    return pKeyToReturn;
}


/*****************************************************************************\
    Public Fuctions
\*****************************************************************************/
HRESULT GenerateKeys(IN LPCWSTR pszFileName)
{
    UNREFERENCED_PARAMETER(pszFileName);

    DWORD               dwErrorCode;
    CThemeSignature     themeSignature;

    dwErrorCode = themeSignature.Generate();
    return(HRESULT_FROM_WIN32(dwErrorCode));
}

HRESULT SignTheme(IN LPCWSTR pszFileName, int nWeek)
{
    DWORD               dwErrorCode;
    const BYTE * pPrivateKey = _GetPrivateKey();

    CThemeSignature     themeSignature(s_keyPrivate1, SIZE_PRIVATE_KEY);

    dwErrorCode = themeSignature.Sign(pszFileName);
    return(HRESULT_FROM_WIN32(dwErrorCode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\packthem\packthem.cpp ===
//---------------------------------------------------------------------------
//  PackThem.cpp - packs up theme files into a theme DLL 
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <uxthemep.h>
#include <utils.h>
#include "SimpStr.h"
#include "Scanner.h"
#include "shlwapip.h"
#include "parser.h"
#include "TmSchema.h"
#include "signing.h"
#include "localsign.h"
#include "ThemeLdr.h"
#include "TmUtils.h"
#include "StringTable.h"

HRESULT ParseTheme(LPCWSTR pszThemeName);

//---------------------------------------------------------------------------
struct FILEINFO
{
    CWideString wsName;
    BOOL fIniFile;
};
//---------------------------------------------------------------------------
#define MAX_COLORS   50
#define MAX_SIZES    20
#define TEMP_FILENAME_BASE    L"$temp$"
#define kRESFILECHAR L'$'
//---------------------------------------------------------------------------
enum PACKFILETYPE
{
    PACK_INIFILE,
    PACK_IMAGEFILE,
    PACK_NTLFILE,
    PACK_OTHER
};
//---------------------------------------------------------------------------
CSimpleArray<FILEINFO> FileInfo;

CSimpleArray<CWideString> ColorSchemes;
CSimpleArray<CWideString> ColorDisplays;
CSimpleArray<CWideString> ColorToolTips;

CSimpleArray<int> MinDepths;

CSimpleArray<CWideString> SizeNames;
CSimpleArray<CWideString> SizeDisplays;
CSimpleArray<CWideString> SizeToolTips;

typedef struct
{
    CWideString sName;
    int iFirstIndex;
    UINT cItems;
} sSubstTable;
CSimpleArray<sSubstTable> SubstNames;
CSimpleArray<CWideString> SubstIds;
CSimpleArray<CWideString> SubstValues;

CSimpleArray<CWideString> BaseResFileNames;
CSimpleArray<CWideString> ResFileNames;
CSimpleArray<CWideString> OrigFileNames;

CSimpleArray<CWideString> PropValuePairs;
//---------------------------------------------------------------------------
SHORT Combos[MAX_SIZES][MAX_COLORS];

int g_iMaxColor;
int g_iMaxSize;
int g_LineCount = 0;
int iTempBitmapNum = 1;

BOOL g_fQuietRun = FALSE;             // don't show needless output
BOOL g_fKeepTempFiles = FALSE;
FILE *ConsoleFile = NULL;

WCHAR g_szInputDir[_MAX_PATH+1];
WCHAR g_szTempPath[_MAX_PATH+1];
WCHAR g_szBaseIniName[_MAX_PATH+1];
WCHAR g_szCurrentClass[_MAX_PATH+1];

//---------------------------------------------------------------------------
#define DOCPROPCNT (1+TMT_LAST_RCSTRING_NAME - TMT_FIRST_RCSTRING_NAME)

CWideString DocProperties[DOCPROPCNT];
//---------------------------------------------------------------------------
HRESULT ReportError(HRESULT hr, LPWSTR pszDefaultMsg) 
{
    WCHAR szErrorMsg[2*_MAX_PATH+1];
    PARSE_ERROR_INFO Info = {sizeof(Info)};
    
    BOOL fGotMsg = FALSE;

    if (THEME_PARSING_ERROR(hr))
    {
        if (SUCCEEDED(_GetThemeParseErrorInfo(&Info)))
        {
            lstrcpy(szErrorMsg, Info.szMsg);
            fGotMsg = TRUE;
        }
    }

    if (! fGotMsg)
    {
        lstrcpy(szErrorMsg, pszDefaultMsg);
    }

    if (*Info.szFileName)        // input file error
    {
        fwprintf(ConsoleFile, L"%s(%d): error - %s\n", 
            Info.szFileName, Info.iLineNum, szErrorMsg);
        fwprintf(ConsoleFile, L"%s\n", Info.szSourceLine);
    }
    else                    // general error 
    {
        fwprintf(ConsoleFile, L"%s(): error - %s\n", 
            g_szInputDir, szErrorMsg);
    }

    SET_LAST_ERROR(hr);
    return hr;
}
//---------------------------------------------------------------------------
void MakeResName(LPCWSTR pszName, LPWSTR pszResName, bool bUseClassName = false)
{
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];

    //---- isolate base name (no path) ----
    _wsplitpath(pszName, szDrive, szDir, szBaseName, szExt);

    if (szBaseName[0] == kRESFILECHAR) // Don't put $ in resource names
    {
        wcscpy(szBaseName, szBaseName + 1);
    }

    //---- replace the "." with a '_' ----
    //---- if a file section name without .ini, append _INI so that the extracted files has .ini extension
    if (*szExt)
    {
        wsprintf(pszResName, L"%s%s_%s", bUseClassName ? g_szCurrentClass : L"", szBaseName, szExt+1);
    } else
    {
        wsprintf(pszResName, L"%s%s_INI", bUseClassName ? g_szCurrentClass : L"", szBaseName);
    }

    //---- all uppercase ----
    CharUpperBuff(pszResName, lstrlen(pszResName));

    //---- replace any spaces with underscores ----
    WCHAR *q = pszResName;       
    while (*q)
    {
        if (*q == ' ')
            *q = '_';
        q++;
    }
}
//---------------------------------------------------------------------------
HRESULT BuildThemeDll(LPCWSTR pszRcName, LPCWSTR pszResName, LPCWSTR pszDllName)
{
    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"compiling resources\n");

    HRESULT hr = SyncCmdLineRun(L"rc.exe", pszRcName);
    if (FAILED(hr))
        return ReportError(hr, L"Error during resource compiliation");

    //---- run LINK to create the DLL ----
    WCHAR params[2*_MAX_PATH+1];

    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"linking theme dll\n");

    wsprintf(params, L"/out:%s /machine:ix86 /dll /noentry %s", pszDllName, pszResName);
    hr = SyncCmdLineRun(L"link.exe", params);
    if (FAILED(hr))
        return ReportError(hr, L"Error during DLL linking");

    return S_OK;
}
//---------------------------------------------------------------------------
void OutputDashLine(FILE *outfile)
{
    fwprintf(outfile, L"//----------------------------------------------------------------------\n");
}
//---------------------------------------------------------------------------
inline void ValueLine(FILE *outfile, LPCWSTR pszName, LPCWSTR pszValue)
{
    fwprintf(outfile, L"            VALUE \"%s\", \"%s\\0\"\n", pszName, pszValue);
}
//---------------------------------------------------------------------------
HRESULT OutputVersionInfo(FILE *outfile, LPCWSTR pszFileName, LPCWSTR pszBaseName)
{
    fwprintf(outfile, L"1 PACKTHEM_VERSION\n");
    fwprintf(outfile, L"BEGIN\n");
    fwprintf(outfile, L"    %d\n", PACKTHEM_VERSION);
    fwprintf(outfile, L"END\n");
    OutputDashLine(outfile);

    WCHAR *Company = L"Microsoft";
    WCHAR *Copyright = L"Copyright  2000";
    WCHAR szDescription[2*_MAX_PATH+1];
    
    wsprintf(szDescription, L"%s Theme for Windows", pszBaseName);

    fwprintf(outfile, L"1 VERSIONINFO\n");
    fwprintf(outfile, L"    FILEVERSION 1,0,0,1\n");
    fwprintf(outfile, L"    PRODUCTVERSION 1,0,0,1\n");
    fwprintf(outfile, L"    FILEFLAGSMASK 0x3fL\n");
    fwprintf(outfile, L"    FILEFLAGS 0x0L\n");
    fwprintf(outfile, L"    FILEOS 0x40004L\n");
    fwprintf(outfile, L"    FILETYPE 0x1L\n");
    fwprintf(outfile, L"    FILESUBTYPE 0x0L\n");

    fwprintf(outfile, L"BEGIN\n");
    fwprintf(outfile, L"    BLOCK \"StringFileInfo\"\n");
    fwprintf(outfile, L"    BEGIN\n");
    fwprintf(outfile, L"        BLOCK \"040904b0\"\n");

    fwprintf(outfile, L"        BEGIN\n");
    
    ValueLine(outfile, L"Comments", L"");
    ValueLine(outfile, L"CompanyName", Company);
    ValueLine(outfile, L"FileDescription", szDescription);
    ValueLine(outfile, L"FileVersion", L"1, 0, 0, 1");
    ValueLine(outfile, L"InternalName", pszFileName);
    ValueLine(outfile, L"LegalCopyright", Copyright);
    ValueLine(outfile, L"LegalTrademarks", L"");
    ValueLine(outfile, L"OriginalFilename", pszFileName);
    ValueLine(outfile, L"PrivateBuild", L"");
    ValueLine(outfile, L"ProductName", szDescription);
    ValueLine(outfile, L"ProductVersion", L"1, 0, 0, 1");
    ValueLine(outfile, L"SpecialBuild", L"");

    fwprintf(outfile, L"        END\n");
    fwprintf(outfile, L"    END\n");
    fwprintf(outfile, L"    BLOCK \"VarFileInfo\"\n");
    fwprintf(outfile, L"    BEGIN\n");
    fwprintf(outfile, L"        VALUE \"Translation\", 0x409, 1200\n");
    fwprintf(outfile, L"    END\n");
    fwprintf(outfile, L"END\n");

    OutputDashLine(outfile);
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT RemoveTempFiles(LPCWSTR szRcName, LPCWSTR szResName)
{
    DeleteFile(szRcName);
    DeleteFile(szResName);

    //---- find & delete all temp files in temp directory ----
    HANDLE hFile = NULL;
    BOOL   bFile = TRUE;
    WIN32_FIND_DATA wfd;
    WCHAR szPattern[_MAX_PATH+1];
    WCHAR szTempName[_MAX_PATH+1];

    wsprintf(szPattern, L"%s\\%s*.*", g_szTempPath, TEMP_FILENAME_BASE); 

    for( hFile = FindFirstFile( szPattern, &wfd ); hFile != INVALID_HANDLE_VALUE && bFile;
         bFile = FindNextFile( hFile, &wfd ) )
    {
        wsprintf(szTempName, L"%s\\%s", g_szTempPath, wfd.cFileName);
    
        DeleteFile(szTempName);
    }

    if (hFile)      
    {
        FindClose( hFile );
    }

    // Remove files generated by the substitution tables
    for (int i = 0; i < SubstNames.GetSize(); i++)
    {
        wsprintf(szTempName, L"%s\\$%s.ini", g_szTempPath, SubstNames[i].sName);
        DeleteFile(szTempName);
    }

    return S_OK;
}
//---------------------------------------------------------------------------
int GetSubstTableIndex(LPCWSTR pszTableName)
{
    // Search for an existing subst table
    for (int i = 0; i < SubstNames.GetSize(); i++)
    {
        if (0 == AsciiStrCmpI(SubstNames[i].sName, pszTableName))
            return i;
    }
    return -1;
}
//---------------------------------------------------------------------------
HRESULT GetSubstValue(LPCWSTR pszIniFileName, LPCWSTR pszName, LPWSTR pszResult)
{
    UINT cTablesCount = SubstNames.GetSize();

    if (pszIniFileName && pszIniFileName[0] == kRESFILECHAR)
    {
        pszIniFileName++;
    }

    for (UINT i = 0; i < cTablesCount; i++)      
    {
        if (0 == AsciiStrCmpI(SubstNames[i].sName, pszIniFileName))
        {
            for (UINT j = SubstNames[i].iFirstIndex; j < SubstNames[i].iFirstIndex + SubstNames[i].cItems; j++) 
            {
                if (0 == AsciiStrCmpI(SubstIds[j], pszName))
                {
                    lstrcpy(pszResult, SubstValues[j]);
                    return S_OK;
                }
            }
        }
    }

    return MakeError32(E_FAIL);      // unknown sizename
}
//---------------------------------------------------------------------------
LPWSTR FindSymbolToken(LPWSTR pSrc, int nLen)
{
    LPWSTR p = wcschr(pSrc, INI_MACRO_SYMBOL);

    // Skip single #s
    while (p != NULL && (p - pSrc < nLen - 1) && *(p + 1) != INI_MACRO_SYMBOL)
    {
        p = wcschr(p + 1, INI_MACRO_SYMBOL);
    }
    return p;
}

LPWSTR ReallocTextBuffer(LPWSTR pSrc, UINT *pnLen)
{
    *pnLen *= 2; // Double the size each time

    LPWSTR pszNew = (LPWSTR) LocalReAlloc(pSrc, *pnLen * sizeof(WCHAR), 0);
    if (!pszNew)
    {
        LocalFree(pSrc);
        return NULL;
    }
    return pszNew;
}

LPWSTR SubstituteSymbols(LPWSTR szTableName, LPWSTR pszText)
{
    UINT nLen = wcslen(pszText);
    UINT nNewLen = nLen * 2; // Reserve some additional space
    UINT iSymbol;
    UINT nBlockSize;
    LPWSTR pszNew = (LPWSTR) LocalAlloc(0, nNewLen * sizeof(WCHAR));
    LPWSTR pSrc = FindSymbolToken(pszText, nLen);
    LPWSTR pOldSrc = pszText;
    LPWSTR pDest = pszNew;
    WCHAR szSymbol[MAX_INPUT_LINE+1];
    HRESULT hr;

    if (!pszNew)
        return NULL;

    while (pSrc != NULL)
    {
        nBlockSize = UINT(pSrc - pOldSrc); 
        // Check for enough space after substitution
        if (pDest + nBlockSize >= pszNew + nNewLen &&
            NULL == (pszNew = ReallocTextBuffer(pszNew, &nNewLen)))
        {
            return NULL;
        }

        // Copy from the last # to the new one
        wcsncpy(pDest, pOldSrc, nBlockSize);
        pDest += nBlockSize;
        pSrc += 2; // Skip the ##

        // Copy the symbol name
        iSymbol = 0;
        while (IsCharAlphaNumericW(*pSrc) || (*pSrc == '_') || (*pSrc == '-'))
        {
            szSymbol[iSymbol++] = *pSrc++;
        }
        szSymbol[iSymbol] = 0;

        // Get the symbol value
        hr = GetSubstValue(szTableName, szSymbol, szSymbol);
        if (FAILED(hr))
        {
            // There's a problem, abort and return the buffer untouched
            LocalFree(pszNew);

            WCHAR szErrorText[MAX_INPUT_LINE + 1];
            wsprintf(szErrorText, L"Substitution symbol not found: %s", szSymbol);

            ReportError(hr, szErrorText);
            return NULL;
        }

        // Make sure we have enough room for one symbol
        if (pDest + MAX_INPUT_LINE + 1 >= pszNew + nNewLen &&
            NULL == (pszNew = ReallocTextBuffer(pszNew, &nNewLen)))
        {
            return NULL;
        }

        // Copy the symbol value to the new text
        iSymbol = 0;
        while (szSymbol[iSymbol] != 0)
        {
            *pDest++ = szSymbol[iSymbol++];
        }

        // Advance to the next iteration
        pOldSrc = pSrc;
        pSrc = FindSymbolToken(pSrc, nLen - UINT(pSrc - pszText));
    }

    if (pDest == pszNew)
    {
        // We did nothing, return NULL
        LocalFree(pszNew);
        return NULL;
    }

    // Copy the remainder text (after the last #)
    if (pDest + wcslen(pOldSrc) >= pszNew + nNewLen &&
        NULL == (pszNew = ReallocTextBuffer(pszNew, &nNewLen)))
    {
        return NULL;
    }
    wcscpy(pDest, pOldSrc);

    return pszNew;
}

//---------------------------------------------------------------------------
HRESULT OutputResourceLine(LPCWSTR pszFilename, FILE *outfile, PACKFILETYPE ePackFileType)
{
    HRESULT hr;

    //---- did we already process this filename? ----
    UINT cNames = FileInfo.GetSize();
    for (UINT c=0; c < cNames; c++)
    {
        if (lstrcmpi(FileInfo[c].wsName, pszFilename)==0)
            return S_OK;
    }

    WCHAR szTempName[_MAX_PATH+1];
    WCHAR szResName[_MAX_PATH];
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];
    WCHAR *filetype;
    LPWSTR pszText;
    BOOL fWasAnsi;
    BOOL fFileChecked = FALSE;
    
    WCHAR szOrigName[_MAX_PATH];
    lstrcpy(szOrigName, pszFilename);

    _wsplitpath(pszFilename, szDrive, szDir, szBaseName, szExt);

    if (ePackFileType == PACK_INIFILE)
    {
        //---- translate to UNICODE, if needed ----
        hr = AllocateTextFile(pszFilename, &pszText, &fWasAnsi);
        if (FAILED(hr))
            return hr;
    
        if (szBaseName[0] == kRESFILECHAR)
        {
            wcscpy(szBaseName, szBaseName + 1);
        }

        // If this an INI file with a subst table, process the substitution
        for (int i = 0; i < SubstNames.GetSize(); i++)
        {
            if (0 == AsciiStrCmpI(SubstNames[i].sName, szBaseName))
            {
                SetLastError(0);
                LPWSTR pszNewText = SubstituteSymbols(szBaseName, pszText);
                if (pszNewText != NULL)
                {
                    LPWSTR pszTemp = pszText;

                    pszText = pszNewText;
                    LocalFree(pszTemp);
                }
                hr = GetLastError();
                if (SUCCEEDED(hr))
                {
                    HRESULT hr = TextToFile(pszFilename, pszText); // Local hr, ignore failure later

                    if (SUCCEEDED(hr))
                    {
                        fWasAnsi = FALSE; // We don't need another temp file
                    }
                }
                break;
            }
        }

        if (SUCCEEDED(hr) && fWasAnsi)       // write out as temp file
        {
            DWORD len = lstrlen(g_szTempPath);
            
            if ((len) && (g_szTempPath[len-1] == '\\'))
                wsprintf(szTempName, L"%s%s%d%s", g_szTempPath, TEMP_FILENAME_BASE, iTempBitmapNum++, L".uni");
            else
                wsprintf(szTempName, L"%s\\%s%d%s", g_szTempPath, TEMP_FILENAME_BASE, iTempBitmapNum++, L".uni");

            hr = TextToFile(szTempName, pszText);
            pszFilename = szTempName;       // use this name in .rc file
        }

        LocalFree(pszText);

        if (FAILED(hr)) 
            return hr;

        fFileChecked = TRUE;
    }
    
    if (! fFileChecked)
    {
        //---- ensure the file is accessible ----
        if (_waccess(pszFilename, 0) != 0)
        {
            fwprintf(ConsoleFile, L"Error - cannot access file: %s\n", pszFilename);

            return MakeError32(E_FAIL);          // cannot access (open) file
        }
    }

    bool bUseClassName = false;

    if (ePackFileType == PACK_IMAGEFILE)
    {
        filetype = L"BITMAP";
        bUseClassName = true;
    }
    else if (ePackFileType == PACK_NTLFILE)
    {
        filetype = L"NTL";
    }
    else if (AsciiStrCmpI(szExt, L".ini")==0)
    {
        filetype = L"TEXTFILE";
    }
    else if (AsciiStrCmpI(szExt, L".wav")==0)
    {
        filetype = L"WAVE";
        bUseClassName = true;
    }
    else
    {
        filetype = L"CUSTOM";
        bUseClassName = true;
    }
     
    MakeResName(szOrigName, szResName, bUseClassName);
    
    //---- replace all single backslashes with double ones ----
    WCHAR DblName[_MAX_PATH+1];
    WCHAR *d = DblName;
    LPCWSTR p = pszFilename;
    while (*p)
    {
        if (*p == '\\')
            *d++ = '\\';

        *d++ = *p++;
    }
    *d = 0;

    //---- output the line to the .rc file ----
    fwprintf(outfile, L"%-30s \t %s DISCARDABLE \"%s\"\n", szResName, filetype, DblName);

    FILEINFO fileinfo;
    fileinfo.wsName = pszFilename;
    fileinfo.fIniFile = (ePackFileType == PACK_INIFILE);

    FileInfo.Add(fileinfo);

    g_LineCount++;

    return S_OK;
}
//---------------------------------------------------------------------------
void ClearCombos()
{
    for (int s=0; s < MAX_SIZES; s++)
    {
        for (int c=0; c < MAX_COLORS; c++)
        {
            Combos[s][c] = -1;          // -1 means no file supports this combo
        }
    }

    g_iMaxColor = -1;
    g_iMaxSize = -1;
}
//---------------------------------------------------------------------------
HRESULT OutputCombos(FILE *outfile)
{
    if ((g_iMaxColor < 0) || (g_iMaxSize < 0))      // no combos found
        return ReportError(E_FAIL, L"No size/color combinations found");

    fwprintf(outfile, L"COMBO COMBODATA\n");
    fwprintf(outfile, L"BEGIN\n");
    fwprintf(outfile, L"    %d, %d    // cColors, cSizes\n", g_iMaxColor+1, g_iMaxSize+1);

    for (int s=0; s <= g_iMaxSize; s++)
    {
        for (int c=0; c <= g_iMaxColor; c++)
        {
            fwprintf(outfile, L"    %d, ", Combos[s][c]);
        }

        fwprintf(outfile, L"   // size=%d row\n", s);
    }

    fwprintf(outfile, L"END\n");
    OutputDashLine(outfile);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT GetFileIndex(LPCWSTR pszName, int *piIndex)
{
    int cCount = ResFileNames.GetSize();

    for (int i=0; i < cCount; i++)      
    {
        if (lstrcmpi(ResFileNames[i], pszName)==0)
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(E_FAIL);      // unknown filename
}
//---------------------------------------------------------------------------
HRESULT GetColorIndex(LPCWSTR pszName, int *piIndex)
{
    int cCount = ColorSchemes.GetSize();

    for (int i=0; i < cCount; i++)      
    {
        if (lstrcmpi(ColorSchemes[i], pszName)==0)
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(E_FAIL);      // unknown colorname
}
//---------------------------------------------------------------------------
HRESULT GetSizeIndex(LPCWSTR pszName, int *piIndex)
{
    int cCount = SizeNames.GetSize();

    for (int i=0; i < cCount; i++)      
    {
        if (lstrcmpi(SizeNames[i], pszName)==0)
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(E_FAIL);      // unknown sizename
}
//---------------------------------------------------------------------------
HRESULT ApplyCombos(LPCWSTR pszResFileName, LPCWSTR pszColors, LPCWSTR pszSizes)
{
    //---- get index of pszResFileName ----
    int iFileNum;
    HRESULT hr = GetFileIndex(pszResFileName, &iFileNum);
    if (FAILED(hr))
        return hr;
    
    //---- parse colors in pszColors ----
    CScanner scan(pszColors);
    WCHAR szName[_MAX_PATH+1];
    int iColors[MAX_COLORS];
    int cColors = 0;

    while (1)
    {
        if (! scan.GetId(szName))
            return MakeError32(E_FAIL);      // bad color list

        //---- get index of szName ----
        int index;
        HRESULT hr = GetColorIndex(szName, &index);
        if (FAILED(hr))
            return hr;

        if (cColors == MAX_COLORS)
            return MakeError32(E_FAIL);      // too many colors specified

        iColors[cColors++] = index;

        if (scan.EndOfLine())
            break;

        if (! scan.GetChar(L','))
            return MakeError32(E_FAIL);      // names must be comma separated
    }


    //---- parse sizes in pszSizes ----
    scan.AttachLine(pszSizes);
    int iSizes[MAX_SIZES];
    int cSizes = 0;

    while (1)
    {
        if (! scan.GetId(szName))
            return MakeError32(E_FAIL);      // bad color list

        //---- get index of szName ----
        int index;
        HRESULT hr = GetSizeIndex(szName, &index);
        if (FAILED(hr))
            return hr;

        if (cSizes == MAX_SIZES)
            return MakeError32(E_FAIL);      // too many sizes specified

        iSizes[cSizes++] = index;

        if (scan.EndOfLine())
            break;

        if (! scan.GetChar(L','))
            return MakeError32(E_FAIL);      // names must be comma separated
    }

    //---- now form all combos of specified colors & sizes ----
    for (int c=0; c < cColors; c++)     // for each color
    {
        int color = iColors[c];

        for (int s=0; s < cSizes; s++)      // for each size
        {
            int size = iSizes[s];

            Combos[size][color] = (SHORT)iFileNum;

            //---- update our max's ----
            if (size > g_iMaxSize)
                g_iMaxSize = size;

            if (color > g_iMaxColor)
                g_iMaxColor = color;
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
void WriteProperty(CSimpleArray<CWideString> &csa, LPCWSTR pszSection, LPCWSTR pszPropName,
    LPCWSTR pszValue)
{
    WCHAR buff[MAX_PATH*2];

    wsprintf(buff, L"%s@[%s]%s=%s", g_szBaseIniName, pszSection, pszPropName, pszValue);

    csa.Add(CWideString(buff));
}
//---------------------------------------------------------------------------
BOOL FnCallBack(enum THEMECALLBACK tcbType, LPCWSTR pszName, LPCWSTR pszName2, 
     LPCWSTR pszName3, int iIndex, LPARAM lParam)
{
    HRESULT hr = S_OK;
    int nDefaultDepth = 15;

    switch (tcbType)
    {
        case TCB_FILENAME:
            WCHAR szFullName[_MAX_PATH+1];

            hr = AddPathIfNeeded(pszName, g_szInputDir, szFullName, ARRAYSIZE(szFullName));
            if (FAILED(hr))
            {
                SET_LAST_ERROR(hr);
                return FALSE;
            }

            if ((iIndex == TMT_IMAGEFILE) || (iIndex == TMT_GLYPHIMAGEFILE) || (iIndex == TMT_STOCKIMAGEFILE))
                hr = OutputResourceLine(szFullName, (FILE *)lParam, PACK_IMAGEFILE);
            else if ((iIndex >= TMT_IMAGEFILE1) && (iIndex <= TMT_IMAGEFILE5))
                hr = OutputResourceLine(szFullName, (FILE *)lParam, PACK_IMAGEFILE);
#if 0           // not yet implemented
            else if (iIndex == TMT_NTLFILE)
                hr = OutputResourceLine(szFullName, (FILE *)lParam, PACK_NTLFILE);
#endif
            else
                hr = MakeError32(E_FAIL);        // unexpected type

            if (FAILED(hr))
            {
                SET_LAST_ERROR(hr);
                return FALSE;
            }
            break;

        case TCB_FONT:
            WriteProperty(PropValuePairs, pszName2, pszName3, pszName);
            break;

        case TCB_MIRRORIMAGE:
            {
                LPCWSTR p;
            
                if (lParam)
                    p = L"1";
                else
                    p = L"0";
    
                WriteProperty(PropValuePairs, pszName2, pszName3, p);
            }
            break;

        case TCB_LOCALIZABLE_RECT:
            {
                WCHAR szBuff[100];
                RECT *prc = (RECT *)lParam;

                wsprintf(szBuff, L"%d, %d, %d, %d", prc->left, prc->top, prc->right, prc->bottom);

                WriteProperty(PropValuePairs, pszName2, pszName3, szBuff);
            }
            break;

        case TCB_COLORSCHEME:
            ColorSchemes.Add(CWideString(pszName));
            ColorDisplays.Add(CWideString(pszName2));
            ColorToolTips.Add(CWideString(pszName3));
            break;

        case TCB_SIZENAME:
            SizeNames.Add(CWideString(pszName));
            SizeDisplays.Add(CWideString(pszName2));
            SizeToolTips.Add(CWideString(pszName3));
            break;

        case TCB_SUBSTTABLE:
        {
            int iTableIndex = GetSubstTableIndex(pszName);

            if (iTableIndex == -1) // Not found, add one
            {
                sSubstTable s;
                s.sName = pszName;
                s.iFirstIndex = -1;
                s.cItems = 0;

                SubstNames.Add(s);
                iTableIndex = SubstNames.GetSize() - 1;
            }
            if (0 == AsciiStrCmpI(pszName2, SUBST_TABLE_INCLUDE))
            {
                int iSecondTableIndex = GetSubstTableIndex(pszName3);

                if (iSecondTableIndex == -1)
                {
                    SET_LAST_ERROR(MakeError32(ERROR_NOT_FOUND));
                    return FALSE;
                }
                else
                {
                    // Copy the symbols in the new table
                    for (UINT iSymbol = SubstNames[iSecondTableIndex].iFirstIndex; 
                        iSymbol < SubstNames[iSecondTableIndex].iFirstIndex + SubstNames[iSecondTableIndex].cItems;
                        iSymbol++)
                    {
                        if (SubstNames[iTableIndex].iFirstIndex == -1)
                        {
                            SubstNames[iTableIndex].iFirstIndex = SubstValues.GetSize();
                        }
                        SubstNames[iTableIndex].cItems++;
                        SubstIds.Add(CWideString(SubstIds[iSymbol]));
                        SubstValues.Add(CWideString(SubstValues[iSymbol]));
                    }
                }
            } 
            else if (pszName2 != NULL && pszName3 != NULL)
            {
                // If the table was pre-created, update it
                if (SubstNames[iTableIndex].iFirstIndex == -1)
                {
                    SubstNames[iTableIndex].iFirstIndex = SubstValues.GetSize();
                }
                SubstNames[iTableIndex].cItems++;
                SubstIds.Add(CWideString(pszName2));
                SubstValues.Add(CWideString(pszName3));
            }
            break;
        }

        case TCB_NEEDSUBST:
            GetSubstValue(pszName, pszName2, (LPWSTR) pszName3);
            break;

        case TCB_CDFILENAME:
            WCHAR szResName[_MAX_PATH+1];
            MakeResName(pszName, szResName);

            ResFileNames.Add(CWideString(szResName));
            MinDepths.Add(nDefaultDepth);
            BaseResFileNames.Add(CWideString(pszName));
            OrigFileNames.Add(CWideString(pszName2));
            break;

        case TCB_CDFILECOMBO:
            MakeResName(pszName, szResName);

            hr = ApplyCombos(szResName, pszName2, pszName3);
            if (FAILED(hr))
            {
                SET_LAST_ERROR(hr);
                return FALSE;
            }
            break;
 
        case TCB_DOCPROPERTY:
            if ((iIndex < 0) || (iIndex >= ARRAYSIZE(DocProperties)))
                return FALSE;
            DocProperties[iIndex] = pszName;
            break;

        case TCB_MINCOLORDEPTH:
            MakeResName(pszName, szResName);

            int iRes;
            
            if (SUCCEEDED(GetFileIndex(szResName, &iRes)))
            {
                MinDepths[iRes] = iIndex;
            }
            break;
    }

    SET_LAST_ERROR(hr);
    return TRUE;
}
//---------------------------------------------------------------------------
HRESULT OpenOutFile(FILE *&outfile, LPCWSTR pszRcName, LPCWSTR pszBaseName)
{
    if (! outfile)          // first time thru
    {
        //---- open out file ----
        outfile = _wfopen(pszRcName, L"wt");
        if (! outfile)
        {
            fwprintf(ConsoleFile, L"Error - cannot open file: %s\n", pszRcName);

            return MakeError32(E_FAIL);
        }

        OutputDashLine(outfile);
        fwprintf(outfile, L"// %s.rc - used to build the %s theme DLL\n", pszBaseName, pszBaseName);
        OutputDashLine(outfile);
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT ProcessContainerFile(LPCWSTR pszDir, LPCWSTR pszInputName, FILE *&outfile)
{
    HRESULT hr;
    
    //---- output .ini filename as a resource ----
    WCHAR fullname[_MAX_PATH+1];
    wsprintf(fullname, L"%s\\%s", pszDir, pszInputName);

    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"processing container file: %s\n", fullname);

    hr = OutputResourceLine(fullname, outfile, PACK_INIFILE);
    if (FAILED(hr))
    {
        ReportError(hr, L"Error reading themes.ini file");
        goto exit;
    }

    OutputDashLine(outfile);
    int oldcnt = g_LineCount;

    //---- scan the themes.ini files for color, size, & file sections; write 'em to the .rc file ----
    DWORD flags = PTF_CONTAINER_PARSE | PTF_CALLBACK_COLORSECTION | PTF_CALLBACK_SIZESECTION
        | PTF_CALLBACK_FILESECTION | PTF_CALLBACK_DOCPROPERTIES | PTF_CALLBACK_SUBSTTABLE;


    WCHAR szErrMsg[4096];

    hr = _ParseThemeIniFile(fullname, flags, FnCallBack, (LPARAM)outfile);
    if (FAILED(hr))
    {
        ReportError(hr, L"Error parsing themes.ini file");
        goto exit;
    }

    if (g_LineCount > oldcnt)
        OutputDashLine(outfile);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT ProcessClassDataFile(LPCWSTR pszFileName, FILE *&outfile, LPCWSTR pszResFileName, LPCWSTR pszInputDir)
{
    HRESULT hr;
    WCHAR szFullName[MAX_PATH];
    WCHAR szTempName[MAX_PATH];
    LPWSTR pBS = NULL;

    hr = hr_lstrcpy(g_szCurrentClass, pszFileName, ARRAYSIZE(g_szCurrentClass));        // make avail to everybody
    if (SUCCEEDED(hr))
    {
        pBS = wcschr(g_szCurrentClass, L'\\');

        if (pBS)
        {
            *pBS = L'_';
            *(pBS + 1) = L'\0';
        }
    }
    if (pBS == NULL) // If there's no '\', don't use the class name
    {
        g_szCurrentClass[0] = 0;
    }

    hr = hr_lstrcpy(g_szInputDir, pszInputDir, ARRAYSIZE(g_szInputDir));        // make avail to everybody
    if (FAILED(hr))
        goto exit;

    hr = AddPathIfNeeded(pszFileName, pszInputDir, szFullName, ARRAYSIZE(szFullName));
    if (FAILED(hr))
        goto exit;

    //---- extract base ini name ----
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szExt[_MAX_EXT];
    _wsplitpath(szFullName, szDrive, szDir, g_szBaseIniName, szExt);
    
    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"processing classdata file: %s\n", pszFileName);

    //---- Create a temporary INI file with the substituted values
    UINT cTablesCount = SubstNames.GetSize();
    for (UINT i = 0; i < cTablesCount; i++)
    {
        if (0 == AsciiStrCmpI(SubstNames[i].sName, pszResFileName))
        {
            // Section used in the string table
            wcscpy(g_szBaseIniName, SubstNames[i].sName);
            // Create the temp file
            DWORD len = lstrlen(g_szTempPath);
            
            if ((len) && (g_szTempPath[len-1] == '\\'))
                wsprintf(szTempName, L"%s$%s%s", g_szTempPath, pszResFileName, szExt);
            else
                wsprintf(szTempName, L"%s\\$%s%s", g_szTempPath, pszResFileName, szExt);
         
            if (lstrcmpi(szFullName, szTempName))
            {
                CopyFile(szFullName, szTempName, FALSE);
                SetFileAttributes(szTempName, FILE_ATTRIBUTE_NORMAL);
                wcscpy(szFullName, szTempName);
            }
            break;
        }
    }

    //---- output .ini filename as a resource ----
    hr = OutputResourceLine(szFullName, outfile, PACK_INIFILE);
    if (FAILED(hr))
        goto exit;

    OutputDashLine(outfile);
    int oldcnt;
    oldcnt = g_LineCount;

    //---- scan the classdata .ini file for valid filenames & fonts; write 'em to the .rc file ----
    WCHAR szErrMsg[4096];
    DWORD flags;
    flags = PTF_CLASSDATA_PARSE | PTF_CALLBACK_FILENAMES | PTF_CALLBACK_LOCALIZATIONS 
        | PTF_CALLBACK_MINCOLORDEPTH;

    hr = _ParseThemeIniFile(szFullName, flags, FnCallBack, (LPARAM)outfile);
    if (FAILED(hr))
    {
        ReportError(hr, L"Error parsing classdata .ini file");
        goto exit;
    }

    if (g_LineCount > oldcnt)
        OutputDashLine(outfile);

    hr = S_OK;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT ProcessClassDataFiles(FILE *&outfile, LPCWSTR pszInputDir)
{
    int cNames = OrigFileNames.GetSize();

    for (int i=0; i < cNames; i++)
    {
        HRESULT hr = ProcessClassDataFile(OrigFileNames[i], outfile, BaseResFileNames[i], pszInputDir);
        if (FAILED(hr))
            return hr;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT OutputStringTable(FILE *outfile, CWideString *ppszStrings, UINT cStrings, int iBaseNum,
    LPCWSTR pszTitle, BOOL fLocalizable=TRUE, BOOL fMinDepths=FALSE)
{
    if (! cStrings)
        return S_OK;

    if (fLocalizable)
    {
        fwprintf(outfile, L"STRINGTABLE DISCARDABLE       // %s\n", pszTitle);
    }
    else            // custom resource type
    {
        fwprintf(outfile, L"1 %s DISCARDABLE\n", pszTitle);
    }

    fwprintf(outfile, L"BEGIN\n");

    for (UINT c=0; c < cStrings; c++)
    {
        LPCWSTR p = ppszStrings[c];
        if (! p)
            p = L"";

        if (fLocalizable)
            fwprintf(outfile, L"    %d \t\"%s\"\n", iBaseNum, p);
        else
        {
            if (fMinDepths)
            {
                fwprintf(outfile, L"    %d,\n", MinDepths[c]);
            }
            else
            {
                fwprintf(outfile, L"    L\"%s\\0\",\n", p);
            }

            if (c == cStrings-1)        // last entry
            {
                if (fMinDepths)
                {
                    fwprintf(outfile, L"    0\n");
                }
                else
                {
                    fwprintf(outfile, L"    L\"\\0\",\n");
                }
            }
        }

        iBaseNum++;
    }

    fwprintf(outfile, L"END\n");
    OutputDashLine(outfile);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT OutputAllStringTables(FILE *outfile)
{
    //---- output all non-localizable strings ----
    if (ColorSchemes.GetSize())
    {
        OutputStringTable(outfile, &ColorSchemes[0], ColorSchemes.GetSize(), 
            0, L"COLORNAMES", FALSE);
    }

    if (SizeNames.GetSize())
    {
        OutputStringTable(outfile, &SizeNames[0], SizeNames.GetSize(), 
            0, L"SIZENAMES", FALSE);
    }

    if (ResFileNames.GetSize())
    {
        OutputStringTable(outfile, &ResFileNames[0], ResFileNames.GetSize(), 
            0, L"FILERESNAMES", FALSE);
    }

    if (MinDepths.GetSize())
    {
        OutputStringTable(outfile, &ResFileNames[0], ResFileNames.GetSize(), 
            0, L"MINDEPTH", FALSE, TRUE);
    }

    if (OrigFileNames.GetSize())
    {
        OutputStringTable(outfile, &OrigFileNames[0], OrigFileNames.GetSize(), 
            0, L"ORIGFILENAMES", FALSE);
    }

    //---- output all localizable strings ----
    if (ColorDisplays.GetSize())
    {
        OutputStringTable(outfile, &ColorDisplays[0], ColorDisplays.GetSize(), 
            RES_BASENUM_COLORDISPLAYS, L"Color Display Names");
    }

    if (ColorToolTips.GetSize())
    {
        OutputStringTable(outfile, &ColorToolTips[0], ColorToolTips.GetSize(), 
            RES_BASENUM_COLORTOOLTIPS, L"Color ToolTips");
    }

    if (SizeDisplays.GetSize())
    {
        OutputStringTable(outfile, &SizeDisplays[0], SizeDisplays.GetSize(), 
            RES_BASENUM_SIZEDISPLAYS, L"Size Display Names");
    }

    if (SizeToolTips.GetSize())
    {
        OutputStringTable(outfile, &SizeToolTips[0], SizeToolTips.GetSize(), 
            RES_BASENUM_SIZETOOLTIPS, L"Size ToolTips");
    }

    OutputStringTable(outfile, &DocProperties[0], ARRAYSIZE(DocProperties), 
        RES_BASENUM_DOCPROPERTIES, L"Doc PropValuePairs");

    OutputStringTable(outfile, &PropValuePairs[0], PropValuePairs.GetSize(), 
        RES_BASENUM_PROPVALUEPAIRS, L"PropValuePairs");

    return S_OK;
}
//---------------------------------------------------------------------------
BOOL WriteBitmapHeader(CSimpleFile &cfOut, BYTE *pBytes, DWORD dwBytes)
{
    BOOL fOK = FALSE;
    BYTE pbHdr1[] = {0x42, 0x4d};
    BYTE pbHdr2[] = {0x0, 0x0, 0x0, 0x0};
    int iFileLen;

    //---- add bitmap hdr at front ----
    HRESULT hr = cfOut.Write(pbHdr1, sizeof(pbHdr1));
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }

    //---- add length of data ----
    iFileLen = dwBytes + sizeof(BITMAPFILEHEADER);
    hr = cfOut.Write(&iFileLen, sizeof(int));
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }

    hr = cfOut.Write(pbHdr2, sizeof(pbHdr2));
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }

    //---- offset to bits (who's idea was *this* field?) ----
    int iOffset, iColorTableSize;
    DWORD dwSize;

    iOffset = sizeof(BITMAPFILEHEADER);
    dwSize = *(DWORD *)pBytes;
    iOffset += dwSize; 
    iColorTableSize = 0;

    switch (dwSize)
    {
        case sizeof(BITMAPCOREHEADER):
            BITMAPCOREHEADER *hdr1;
            hdr1 = (BITMAPCOREHEADER *)pBytes;
            if (hdr1->bcBitCount == 1)
                iColorTableSize = 2*sizeof(RGBTRIPLE);
            else if (hdr1->bcBitCount == 4)
                iColorTableSize = 16*sizeof(RGBTRIPLE);
            else if (hdr1->bcBitCount == 8)
                iColorTableSize = 256*sizeof(RGBTRIPLE);
            break;

        case sizeof(BITMAPINFOHEADER):
        case sizeof(BITMAPV4HEADER):
        case sizeof(BITMAPV5HEADER):
            BITMAPINFOHEADER *hdr2;
            hdr2 = (BITMAPINFOHEADER *)pBytes;
            if (hdr2->biClrUsed)
                iColorTableSize = hdr2->biClrUsed*sizeof(RGBQUAD);
            else
            {
                if (hdr2->biBitCount == 1)
                    iColorTableSize = 2*sizeof(RGBQUAD);
                else if (hdr2->biBitCount == 4)
                    iColorTableSize = 16*sizeof(RGBQUAD);
                else if (hdr2->biBitCount == 8)
                    iColorTableSize = 256*sizeof(RGBQUAD);
            }
            break;
    }

    iOffset += iColorTableSize;
    hr = cfOut.Write(&iOffset, sizeof(int));
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }

    fOK = TRUE;

exit:
    return fOK;
}
//---------------------------------------------------------------------------
BOOL CALLBACK ResEnumerator(HMODULE hModule, LPCWSTR pszType, LPWSTR pszResName, LONG_PTR lParam)
{
    HRESULT hr;
    BOOL fAnsi = (BOOL)lParam;
    BOOL fText = FALSE;
    RESOURCE BYTE *pBytes = NULL;
    CSimpleFile cfOut;
    DWORD dwBytes;

    if (pszType != RT_BITMAP)
        fText = TRUE;

    hr = GetPtrToResource(hModule, pszType, pszResName, (void **)&pBytes, &dwBytes);
    if (FAILED(hr))
    {
        ReportError(hr, L"error reading file resources");
        goto exit;
    }

    //---- convert name to filename ----
    WCHAR szFileName[_MAX_PATH+1];
    lstrcpy(szFileName, pszResName);
    WCHAR *q;
    q = wcsrchr(szFileName, '_');
    if (q)
        *q = '.';
        
    if (! fText)
        fAnsi = FALSE;          // don't translate if binary data

    hr = cfOut.Create(szFileName, fAnsi);
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot create output file");
        goto exit;
    }

    if (! fText)
    {
        if (! WriteBitmapHeader(cfOut, pBytes, dwBytes))
            goto exit;
    }

    hr = cfOut.Write(pBytes, dwBytes);
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }
    
exit:
    return (SUCCEEDED(hr));
}
//---------------------------------------------------------------------------
void WriteBitmap(LPWSTR pszFileName, BITMAPINFOHEADER* pbmi, DWORD* pdwData)
{
    DWORD dwLen = pbmi->biWidth * pbmi->biHeight;

    CSimpleFile cfOut;
    cfOut.Create(pszFileName, FALSE);

    BITMAPFILEHEADER bmfh = {0};
    bmfh.bfType = 'MB';
    bmfh.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + (dwLen * sizeof(DWORD));
    bmfh.bfOffBits = sizeof(BITMAPINFOHEADER) + sizeof(BITMAPFILEHEADER);
    cfOut.Write(&bmfh, sizeof(BITMAPFILEHEADER));
    cfOut.Write(pbmi, sizeof(BITMAPINFOHEADER));
    cfOut.Write(pdwData, dwLen * sizeof(DWORD));
}

HRESULT ColorShift(LPWSTR pszFileName, int cchFileName)
{
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HBITMAP hbm = (HBITMAP)LoadImage(0, pszFileName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_DEFAULTSIZE | LR_LOADFROMFILE);
        if (hbm)
        {
            BITMAP bm;
            GetObject(hbm, sizeof(bm), &bm);

            DWORD dwLen = bm.bmWidth * bm.bmHeight;
            DWORD* pPixelQuads = new DWORD[dwLen];
            if (pPixelQuads)
            {
                BITMAPINFO bi = {0};
                bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                bi.bmiHeader.biWidth = bm.bmWidth;
                bi.bmiHeader.biHeight = bm.bmHeight;
                bi.bmiHeader.biPlanes = 1;
                bi.bmiHeader.biBitCount = 32;
                bi.bmiHeader.biCompression = BI_RGB;

                if (GetDIBits(hdc, hbm, 0, bm.bmHeight, pPixelQuads, &bi, DIB_RGB_COLORS))
                {
                    pszFileName[lstrlen(pszFileName) - 4] = 0;

                    WCHAR szFileNameR[MAX_PATH];
                    wsprintf(szFileNameR, L"%sR.bmp", pszFileName);
                    WCHAR szFileNameG[MAX_PATH];
                    wsprintf(szFileNameG, L"%sG.bmp", pszFileName);
                    WCHAR szFileNameB[MAX_PATH];
                    wsprintf(szFileNameB, L"%sB.bmp", pszFileName);
                    
                    WriteBitmap(szFileNameB, &bi.bmiHeader, pPixelQuads);

                    DWORD *pdw = pPixelQuads;
                    for (DWORD i = 0; i < dwLen; i++)
                    {
                        COLORREF crTemp = *pdw;
                        if (crTemp != RGB(255, 0, 255))
                        {
                            crTemp = (crTemp & 0xff000000) | RGB(GetGValue(crTemp), GetBValue(crTemp), GetRValue(crTemp));
                        }
                        *pdw = crTemp;
                        pdw++;
                    }

                    WriteBitmap(szFileNameR, &bi.bmiHeader, pPixelQuads);

                    pdw = pPixelQuads;
                    for (DWORD i = 0; i < dwLen; i++)
                    {
                        COLORREF crTemp = *pdw;
                        if (crTemp != RGB(255, 0, 255))
                        {
                            crTemp = (crTemp & 0xff000000) | RGB(GetGValue(crTemp), GetBValue(crTemp), GetRValue(crTemp));
                        }
                        *pdw = crTemp;
                        pdw++;
                    }

                    WriteBitmap(szFileNameG, &bi.bmiHeader, pPixelQuads);
                }

                delete[] pPixelQuads;
            }
            DeleteObject(hbm);
        }
        ReleaseDC(NULL, hdc);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
HRESULT UnpackTheme(LPCWSTR pszFileName, BOOL fAnsi)
{
    HRESULT hr = S_OK;

    //---- load the file as a resource only DLL ----
    RESOURCE HINSTANCE hInst = LoadLibraryEx(pszFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hInst)
    {
        //---- enum all bitmaps & write as files ----
        if (! EnumResourceNames(hInst, RT_BITMAP, ResEnumerator, LPARAM(fAnsi)))
            hr = GetLastError();

        //---- enum all .ini files & write as files ----
        if (! EnumResourceNames(hInst, L"TEXTFILE", ResEnumerator, LPARAM(fAnsi)))
            hr = GetLastError();

        //---- close the file ----
        if (hInst)
            FreeLibrary(hInst);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT PackTheme(LPCWSTR pszInputDir, LPWSTR pszOutputName, DWORD cchSize)
{
    //---- is it a valid dir ----
    DWORD dwMask = GetFileAttributes(pszInputDir);
    if ((dwMask == 0xffffffff) || (! (dwMask & FILE_ATTRIBUTE_DIRECTORY)))
    {
        fwprintf(ConsoleFile, L"\nError - not a valid directory name: %s\n", pszInputDir);
        return MakeError32(E_FAIL);
    }

    //---- build: szDllName ----
    WCHAR szDllName[_MAX_PATH+1];
    BOOL fOutputDir = FALSE;

    if (! *pszOutputName)                     // not specified - build from pszInputDir
    {
        WCHAR szFullDir[_MAX_PATH+1];
        WCHAR *pszBaseName;

        DWORD val = GetFullPathName(pszInputDir, ARRAYSIZE(szFullDir), szFullDir, &pszBaseName);
        if (! val)
            return MakeErrorLast();

        //---- make output dir same as input dir ----
        wsprintf(szDllName, L"%s\\%s%s", pszInputDir, pszBaseName, THEMEDLL_EXT);
    }
    else        // get full name of output file
    {
        DWORD val = GetFullPathName(pszOutputName, ARRAYSIZE(szDllName), szDllName, NULL);
        if (! val)
            return MakeErrorLast();

        fOutputDir = TRUE;            // don't remove temp files
    }

    // Give the caller the path so the file can be signed.
    lstrcpyn(pszOutputName, szDllName, cchSize);

    //--- delete the old target in case we have errors ----
    DeleteFile(pszOutputName);

    //---- build: g_szTempPath, szDllRoot, szRcName, and szResName ----
    WCHAR szDllRoot[_MAX_PATH+1];
    WCHAR szResName[_MAX_PATH+1];
    WCHAR szRcName[_MAX_PATH+1];
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];

    _wsplitpath(szDllName, szDrive, szDir, szBaseName, szExt);

    _wmakepath(szDllRoot, L"", L"", szBaseName, szExt);
    _wmakepath(szRcName, szDrive, szDir, szBaseName, L".rc");
    _wmakepath(szResName, szDrive, szDir, szBaseName, L".res");

    if (fOutputDir)
        _wmakepath(g_szTempPath, szDrive, szDir, L"", L"");
    else
        lstrcpy(g_szTempPath, L".");

    FILE *outfile = NULL;
    OpenOutFile(outfile, szRcName, szBaseName);

    ClearCombos();

    //---- process the main container file ----
    HRESULT hr = ProcessContainerFile(pszInputDir, CONTAINER_NAME, outfile);
    if (FAILED(hr))
        goto exit;

    //---- process all classdata files that were defined in container file ----
    hr = ProcessClassDataFiles(outfile, pszInputDir);
    if (FAILED(hr))
        goto exit;

    //---- output all string tables ----
    hr = OutputAllStringTables(outfile);
    if (FAILED(hr))
        goto exit;

    hr = OutputCombos(outfile);
    if (FAILED(hr))
        goto exit;

    hr = OutputVersionInfo(outfile, szDllRoot, szBaseName);
    if (FAILED(hr))
        goto exit;

    fclose(outfile);
    outfile = NULL;

    hr = BuildThemeDll(szRcName, szResName, szDllName);

exit:
    if (outfile)
        fclose(outfile);

    if (ConsoleFile != stdout)
        fclose(ConsoleFile);

    if (! g_fKeepTempFiles)
        RemoveTempFiles(szRcName, szResName);

    if (SUCCEEDED(hr))
    {
        if (! g_fQuietRun)
            fwprintf(ConsoleFile, L"Created %s\n", szDllName);
        return S_OK;
    }

    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"Error occured - theme DLL not created\n");
    return hr; 
}
//---------------------------------------------------------------------------
void PrintUsage()
{
    fwprintf(ConsoleFile, L"\nUsage: \n\n");
    fwprintf(ConsoleFile, L"    packthem [-o <output name> ] [-k] [-q] <dirname>\n");
    fwprintf(ConsoleFile, L"      -m    specifies the (full path) name of the image file you want to color shift\n");
    fwprintf(ConsoleFile, L"      -o    specifies the (full path) name of the output file\n");
    fwprintf(ConsoleFile, L"      -k    specifies that temp. files should be kept (not deleted)\n");
    fwprintf(ConsoleFile, L"      -d    do not sign the file when building it\n");
    fwprintf(ConsoleFile, L"      -q    quite mode (don't print header and progress msgs)\n\n");

    fwprintf(ConsoleFile, L"    packthem -u [-a] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -u    unpacks the packed file into its separate files in current dir\n");
    fwprintf(ConsoleFile, L"      -a    writes .ini files as ANSI (defaults to UNICODE)\n\n");

    fwprintf(ConsoleFile, L"    packthem -p [-q] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -p    Parses the localized packed file and reports errors\n\n");

    fwprintf(ConsoleFile, L"    packthem [-c] [-q] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -c    check the signature of the already created file\n\n");

    fwprintf(ConsoleFile, L"    packthem [-s] [-q] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -s    sign the already created file\n\n");

    fwprintf(ConsoleFile, L"    packthem [-g] [-q] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -g    generate public and private keys\n\n");
}
//---------------------------------------------------------------------------
enum eOperation
{
    opPack = 1,
    opUnPack,
    opSign,
    opCheckSignature,
    opGenerateKeys,
    opParse,
    opColorShift
};
//---------------------------------------------------------------------------
extern "C" WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE previnst, 
    LPTSTR pszCmdLine, int nShowCmd)
{
    //---- initialize globals from themeldr.lib ----
    ThemeLibStartUp(FALSE);

    //---- initialize our globals ----
    HRESULT hr = S_OK;
    int nWeek = -1;

    UtilsStartUp();        
    LogStartUp();

    WCHAR szOutputName[_MAX_PATH+1] = {0};
    int retval = 1;             // error, until prove otherwise

    BOOL fAnsi = FALSE; 
    BOOL fSkipSigning = FALSE;
    eOperation Operation = opPack;

    LPCWSTR p = pszCmdLine;
    szOutputName[0] = 0;    // Much faster than ={0};

    //---- default to console until something else is specified ----
    if (! ConsoleFile)
    {
        ConsoleFile = stdout;
    }

    while ((*p == '-') || (*p == '/'))
    {
        p++;
        WCHAR sw = *p;

        if (isupper(sw))
            sw = (WCHAR)tolower(sw);

        if (sw == 'e')
        {
            ConsoleFile = _wfopen(L"packthem.err", L"wt");
            g_fQuietRun = TRUE;
            p++;
        }
        else if (sw == 'o')
        {
            WCHAR *q = szOutputName;
            p++;        // skip over switch
            while (iswspace(*p))
                p++;
            while ((*p) && (! iswspace(*p)))
                *q++ = *p++;

            *q = 0;     // terminate the output name
        }
        else if (sw == 'k')
        {
            g_fKeepTempFiles = TRUE;
            p++;
        }
        else if (sw == 'q')
        {
            g_fQuietRun = TRUE;
            p++;
        }
        else if (sw == 'm')
        {
            Operation = opColorShift;

            WCHAR *q = szOutputName;
            p++;        // skip over switch
            while (iswspace(*p))
                p++;
            while ((*p) && (! iswspace(*p)))
                *q++ = *p++;

            *q = 0;     // terminate the output name
        }
        else if (sw == 'u')
        {
            Operation = opUnPack;
            p++;
        }
        else if (sw == 'd')
        {
            fSkipSigning = TRUE;
            p++;
        }
        else if (sw == 'c')
        {
            Operation = opCheckSignature;
            p++;
        }
        else if (sw == 'g')
        {
            Operation = opGenerateKeys;
            p++;
        }
        else if (sw == 's')
        {
            Operation = opSign;
            p++;
        }
        else if (sw == 'a')
        {
            fAnsi = TRUE;
            p++;
        }
        else if (sw == 'w')
        {
            fAnsi = TRUE;
            p++;

            LARGE_INTEGER uli;
            WCHAR szWeek[3];

            szWeek[0] = p[0];
            szWeek[1] = p[1];
            szWeek[2] = 0;
            if (StrToInt64ExInternalW(szWeek, 0, &(uli.QuadPart)) &&
                (uli.QuadPart > 0))
            {
                nWeek = (int)uli.LowPart;
            }

            while ((L' ' != p[0]) && (0 != p[0]))
            {
                p++;
            }
        }
        else if (sw == 'p')
        {
            Operation = opParse;
            p++;
        }
        else if (sw == '?')
        {
            PrintUsage();
            retval = 0;
            goto exit;
        }
        else
        {
            fwprintf(ConsoleFile, L"Error - unrecognized switch: %s\n", p);
            goto exit;
        }

        while (iswspace(*p))
            p++;
    }

    LPCWSTR pszInputDir;
    pszInputDir = p;

    if (! g_fQuietRun)
    {
        fwprintf(ConsoleFile, L"Microsoft (R) Theme Packager (Version %d)\n", PACKTHEM_VERSION);
        fwprintf(ConsoleFile, L"Copyright (C) Microsoft Corp 2000. All rights reserved.\n");
    }

    //---- any cmdline arg specified? ----
    if (Operation != opColorShift)
    {
        if ((! pszInputDir) || (! *pszInputDir))
        {
            PrintUsage(); 
            goto exit;
        }
    }

    switch (Operation)
    {
    case opPack:
        hr = PackTheme(pszInputDir, szOutputName, ARRAYSIZE(szOutputName));
        if (SUCCEEDED(hr) && !fSkipSigning)
        {
            hr = SignTheme(szOutputName, nWeek);
            if (!g_fQuietRun)
            {
                if (SUCCEEDED(hr))
                {
                    wprintf(L"Creating the signature succeeded\n");
                }
                else
                {
                    wprintf(L"The signature failed to be created.  hr=%#08lx\n", hr);
                }
            }
        }
        break;
    case opUnPack:
        hr = UnpackTheme(pszInputDir, fAnsi);
        break;
    case opSign:
        // We don't sign it again if the signature is already valid.
        if (FAILED(CheckThemeFileSignature(pszInputDir)))
        {
            // Needs signing.
            hr = SignTheme(pszInputDir, nWeek);
            if (!g_fQuietRun)
            {
                if (SUCCEEDED(hr))
                {
                    wprintf(L"Creating the signature succeeded\n");
                }
                else
                {
                    wprintf(L"The signature failed to be created.  hr=%#08lx\n", hr);
                }
            }
        }
        else
        {
            if (!g_fQuietRun)
            {
                wprintf(L"The file was already signed and the signature is still valid.");
            }
        }
        break;
    case opCheckSignature:
        hr = CheckThemeFileSignature(pszInputDir);
        if (!g_fQuietRun)
        {
            if (SUCCEEDED(hr))
            {
                wprintf(L"The signature is valid\n");
            }
            else
            {
                wprintf(L"The signature is not valid.  hr=%#08lx\n", hr);
            }
        }
        break;
    case opGenerateKeys:
        hr = GenerateKeys(pszInputDir);
        break;
    case opParse:
        hr = ParseTheme(pszInputDir);
        if (FAILED(hr))
        {
            ReportError(hr, L"Error during parsing");
            goto exit;
        } else
        {
            wprintf(L"No errors parsing theme file\n");
        }
        break;
    case opColorShift:
        hr = ColorShift(szOutputName, ARRAYSIZE(szOutputName));
        break;

    default:
        if (FAILED(hr))
        {
            hr = E_FAIL;
            goto exit;
        }
        break;
    };

    retval = 0;     // all OK

exit:
    UtilsShutDown();
    LogShutDown();

    return retval;
}
//---------------------------------------------------------------------------
HRESULT LoadClassDataIni(HINSTANCE hInst, LPCWSTR pszColorName,
    LPCWSTR pszSizeName, LPWSTR pszFoundIniName, DWORD dwMaxIniNameChars, LPWSTR *ppIniData)
{
    COLORSIZECOMBOS *combos;
    HRESULT hr = FindComboData(hInst, &combos);
    if (FAILED(hr))
        return hr;

    int iSizeIndex = 0;
    int iColorIndex = 0;

    if ((pszColorName) && (* pszColorName))
    {
        hr = GetColorSchemeIndex(hInst, pszColorName, &iColorIndex);
        if (FAILED(hr))
            return hr;
    }

    if ((pszSizeName) && (* pszSizeName))
    {
        hr = GetSizeIndex(hInst, pszSizeName, &iSizeIndex);
        if (FAILED(hr))
            return hr;
    }

    int filenum = COMBOENTRY(combos, iColorIndex, iSizeIndex);
    if (filenum == -1)
        return MakeError32(ERROR_NOT_FOUND);

    //---- locate resname for classdata file "filenum" ----
    hr = GetResString(hInst, L"FILERESNAMES", filenum, pszFoundIniName, dwMaxIniNameChars);
    if (SUCCEEDED(hr))
    {
        hr = AllocateTextResource(hInst, pszFoundIniName, ppIniData);
    }

    return hr;
}
//---------------------------------------------------------------------------
// Parse the theme to detect localization errors
HRESULT ParseTheme(LPCWSTR pszThemeName)
{
    // Dummy callback class needed by the parser
    class CParserCallBack: public IParserCallBack
    {
        HRESULT AddIndex(LPCWSTR pszAppName, LPCWSTR pszClassName, 
            int iPartNum, int iStateNum, int iIndex, int iLen) { return S_OK; };
        HRESULT AddData(SHORT sTypeNum, PRIMVAL ePrimVal, const void *pData, DWORD dwLen) { return S_OK; };
        int GetNextDataIndex() { return 0; };
    };

    CParserCallBack *pParserCallBack = NULL;
    CThemeParser *pParser = NULL;

    HRESULT hr;
    HINSTANCE hInst = NULL;
    WCHAR *pDataIni = NULL;
    WCHAR szClassDataName[_MAX_PATH+1];

    //---- load the Color Scheme from "themes.ini" ----
    hr = LoadThemeLibrary(pszThemeName, &hInst);
    if (FAILED(hr))
        goto exit;
    
    pParser = new CThemeParser(FALSE);
    if (! pParser)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    pParserCallBack = new CParserCallBack;
    if (!pParserCallBack)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    THEMENAMEINFO tniColors;
    THEMENAMEINFO tniSizes;

    for (DWORD c = 0; ; c++)
    {
        if (FAILED(_EnumThemeColors(hInst, pszThemeName, NULL, c, &tniColors, FALSE)))
            break;

        for (DWORD s = 0 ; ; s++)
        {
            if (FAILED(_EnumThemeSizes(hInst, pszThemeName, tniColors.szName, s, &tniSizes, FALSE)))
                break;

            //---- load the classdata file resource into memory ----
            hr = LoadClassDataIni(hInst, tniColors.szName, tniSizes.szName, szClassDataName, ARRAYSIZE(szClassDataName), &pDataIni);
            if (FAILED(hr))
                goto exit;

            //---- parse & build binary theme ----
            hr = pParser->ParseThemeBuffer(pDataIni, szClassDataName, NULL, hInst, 
                pParserCallBack, FnCallBack, NULL, PTF_CLASSDATA_PARSE);
            if (FAILED(hr))
                goto exit;

            if (pDataIni)
            {
                delete [] pDataIni;
                pDataIni = NULL;
            }
        }
    }

exit:

    if (hInst)
        FreeLibrary(hInst);
    
    if (pDataIni)
        delete [] pDataIni;

    if (pParser)
        delete pParser;

    if (pParserCallBack)
        delete pParserCallBack;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\preview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Preview.rc
//
#define IDC_MYICON                      2
#define IDB_PINKGRAY                    4
#define IDB_BLUEGRAY                    5
#define IDB_WHITE                       6
#define IDB_GRAY                        7
#define IDD_PREVIEW_DIALOG              102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_PREVIEW                     107
#define IDI_SMALL                       108
#define IDC_PREVIEW                     109
#define IDR_MAINFRAME                   128
#define ID_BACKGROUND_GRAYPINK          32771
#define ID_BACKGROUND_GRAY              32772
#define ID_BACKGROUND_WHITE             32773
#define ID_BACKGROUND_BLUEGRAY          32774
#define ID_FILE_OPEN                    32775
#define ID_ZOOM_50                      32776
#define ID_ZOOM_100                     32777
#define ID_ZOOM_200                     32778
#define ID_ZOOM_400                     32779
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32780
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\preview\preview.cpp ===
//----------------------------------------------------------------------------
//  Preview.cpp - image preview app for theme authoring
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "resource.h"
#include "shlwapip.h"
#include "themeldr.h"
//----------------------------------------------------------------------------
#define MAX_LOADSTRING 100
//----------------------------------------------------------------------------
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
HRESULT InitDib(HINSTANCE hInstance, LPCWSTR pszFileName);
void SetBackground(HWND hWnd, HINSTANCE hinst, int id, int iMenuId);
LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM);
void OnFileOpen(HINSTANCE hInst, HWND hWnd);
void SetZoom(HWND hWnd, HINSTANCE hInstance, int iZoomPercent, int iMenuId);
//----------------------------------------------------------------------------
HINSTANCE hInst;	
HBITMAP hCenterDIB = NULL;
HBITMAP hbrBackground = NULL;
int iDibWidth;
int iDibHeight;
int iCurrentBgMenu = 0;
int iCurrentZoomMenu = 0;
int iZoomFactor = 100;
BOOL fAlpha;
//----------------------------------------------------------------------------
int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE, LPWSTR lpCmdLine, int nCmdShow)
{
	MSG msg;
	HACCEL hAccelTable;
    TCHAR szWindowClass[MAX_LOADSTRING];	
    TCHAR szTitle[MAX_LOADSTRING];				

    //---- initialize globals from themeldr.lib ----
    ThemeLibStartUp(FALSE);
    
	//---- Initialize global strings ----
    LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_PREVIEW, szWindowClass, MAX_LOADSTRING);

    //---- register window class ----
    WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

    wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_PREVIEW);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= NULL;
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_PREVIEW);
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	RegisterClassEx(&wcex);
    
    if (*lpCmdLine)
        InitDib(hInstance, lpCmdLine);

    //---- create the main window ----
    HWND hWnd;
    hInst = hInstance; // Store instance handle in our global variable

    hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
    if (!hWnd)
        return 1;

    SetBackground(hWnd, hInstance, IDB_PINKGRAY, ID_BACKGROUND_GRAYPINK);
    SetZoom(hWnd, hInstance, 100, ID_ZOOM_100);

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);
	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_PREVIEW);

    //---- initialize us as a drag target ----
    DragAcceptFiles(hWnd, TRUE);

    //---- main message loop ----
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return (int)msg.wParam;
}
//----------------------------------------------------------------------------
void SetBackground(HWND hWnd, HINSTANCE hInstance, int id, int iMenuId)
{
    if (hbrBackground)
        DeleteObject(hbrBackground);
    
    hbrBackground = LoadBitmap(hInstance, MAKEINTRESOURCE(id));

    InvalidateRect(hWnd, NULL, TRUE);

    //---- update menu items ----
    HMENU hMenu = GetMenu(hWnd);
    hMenu = GetSubMenu(hMenu, 1);

    if (iCurrentBgMenu)
        CheckMenuItem(hMenu, iCurrentBgMenu, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hMenu, iMenuId, MF_BYCOMMAND | MF_CHECKED);

    iCurrentBgMenu = iMenuId;
}
//----------------------------------------------------------------------------
HRESULT InitDib(HINSTANCE hInstance, LPCWSTR pszFileName)
{
    if (hCenterDIB)
    {
        DeleteObject(hCenterDIB);
        hCenterDIB = NULL;
    }

    int iRetVal = 0;
    fAlpha = FALSE;
    WCHAR *pszOutputName = L"$temp$.bmp";
    HRESULT hr = S_OK;
    HDC hdc = NULL;
    DWORD *pBits = NULL;

    //---- ensure file exists ----
    if (! FileExists(pszFileName))
    {
        hr = MakeError32(STG_E_FILENOTFOUND);       
        goto exit;
    }

    //---- convert file, if needed ----
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];
    _wsplitpath(pszFileName, szDrive, szDir, szBaseName, szExt);
    if (lstrcmpi(szExt, L".bmp") != 0)           // not a .bmp file
    {
        //---- protect ourselves from crashes ----
        try
        {
            hr = SHConvertGraphicsFile(pszFileName, pszOutputName, SHCGF_REPLACEFILE);
        }
        catch (...)
        {
            hr = MakeError32(E_FAIL);
        }

        if ((SUCCEEDED(hr)) && (! FileExists(pszOutputName)))
            hr = MakeError32(E_FAIL);

        if (FAILED(hr))
            goto exit;

        pszFileName = pszOutputName;
    }

    //---- load the specified center bitmap as a DIB ----
    hCenterDIB = (HBITMAP) LoadImage(hInstance, pszFileName, IMAGE_BITMAP,
        0, 0, LR_CREATEDIBSECTION | LR_LOADFROMFILE);
    if (! hCenterDIB)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    BITMAP bminfo;
    GetObject(hCenterDIB, sizeof(bminfo), &bminfo);

    iDibWidth = bminfo.bmWidth;
    iDibHeight = bminfo.bmHeight;

    if (bminfo.bmBitsPixel < 32)
        iRetVal = 1;
    else
    {
        pBits = new DWORD[(iDibWidth+20)*iDibHeight];
        if (! pBits)
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        BITMAPINFOHEADER BitMapHdr = {sizeof(BITMAPINFOHEADER), iDibWidth, iDibHeight, 1, 32, BI_RGB};
        hdc = GetWindowDC(NULL);
        if (! hdc)
        {
            hr = MakeErrorLast();
            goto exit;
        }

        iRetVal = GetDIBits(hdc, hCenterDIB, 0, iDibHeight, pBits, (BITMAPINFO *)&BitMapHdr, DIB_RGB_COLORS);
        if (! iRetVal)
        {
            hr = MakeErrorLast();
            goto exit;
        }

        DWORD *pdw = pBits;

        //---- pre-multiply bits - required by AlphaBlend() API ----
        for (int r=0; r < iDibHeight; r++)
        {
            for (int c=0; c < iDibWidth; c++)
            {
                COLORREF cr = *pdw;
                int iAlpha = ALPHACHANNEL(cr);
                if (iAlpha)
                {
                    int iRed = (RED(cr)*iAlpha)/255;
                    int iGreen = (GREEN(cr)*iAlpha)/255;
                    int iBlue = (BLUE(cr)*iAlpha)/255;

                    *pdw++ = (RGB(iRed, iGreen, iBlue) | (iAlpha << 24));
                    fAlpha = TRUE;
                }
                else
                    *pdw++ = 0;
            } 
        }

        if (fAlpha)
        {
            iRetVal = SetDIBits(NULL, hCenterDIB, 0, iDibHeight, pBits, (BITMAPINFO *)&BitMapHdr, DIB_RGB_COLORS);
            if (! iRetVal)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }
        else
            MessageBox(NULL, L"Alpha Channel of bitmap is all zero's", L"Warning", MB_OK);
    }

exit:
    if (hdc)
        ReleaseDC(NULL, hdc);
    
    if (pBits)
        delete [] pBits;

    if (FAILED(hr))
        MessageBox(NULL, L"Error loading bitmap", L"Error", MB_OK);

    return hr;
}
//----------------------------------------------------------------------------
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;

	switch (message) 
	{
        case WM_DROPFILES:
        {
            HDROP hDrop = (HDROP)wParam;
            WCHAR szFileName[_MAX_PATH+1];
            int iGot = DragQueryFile(hDrop, 0, szFileName, ARRAYSIZE(szFileName));
            DragFinish(hDrop);

            if (iGot)               // got a valid filename
            {
                HRESULT hr = InitDib(hInst, szFileName);
                if (SUCCEEDED(hr))
                    InvalidateRect(hWnd, NULL, TRUE);
            }
        }
        break;

		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
                case ID_FILE_OPEN:
                   OnFileOpen(hInst, hWnd);
                   break;

				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;

				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;

                case ID_BACKGROUND_GRAYPINK:
                   SetBackground(hWnd, hInst, IDB_PINKGRAY, wmId);
                   break;

                case ID_BACKGROUND_BLUEGRAY:
                   SetBackground(hWnd, hInst, IDB_BLUEGRAY, wmId);
                   break;

                case ID_BACKGROUND_WHITE:
                   SetBackground(hWnd, hInst, IDB_WHITE, wmId);
                   break;
                   
                case ID_BACKGROUND_GRAY:
                   SetBackground(hWnd, hInst, IDB_GRAY, wmId);
                   break;
                   
                case ID_ZOOM_50:
                   SetZoom(hWnd, hInst, 50, wmId);
                   break;
                   
                case ID_ZOOM_100:
                   SetZoom(hWnd, hInst, 100, wmId);
                   break;
                   
                case ID_ZOOM_200:
                   SetZoom(hWnd, hInst, 200, wmId);
                   break;
                   
                case ID_ZOOM_400:
                   SetZoom(hWnd, hInst, 400, wmId);
                   break;
                                   
                default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;

		case WM_ERASEBKGND:
            HBRUSH hbr;
            hbr = CreatePatternBrush(hbrBackground);
            hdc = (HDC)wParam;
            if ((hbr) && (hdc))
            {
                RECT rect;
                GetClientRect(hWnd, &rect);
                FillRect(hdc, &rect, hbr);
                DeleteObject(hbr);
            }
            return 1;

		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);

            XFORM xForm;

            xForm.eM11 = (FLOAT)(iZoomFactor/100.); 
            xForm.eM12 = (FLOAT) 0.0; 
            xForm.eM21 = (FLOAT) 0.0; 
            xForm.eM22 = (FLOAT)(iZoomFactor/100.); 
            xForm.eDx  = (FLOAT) 0.0; 
            xForm.eDy  = (FLOAT) 0.0; 

            SetGraphicsMode(hdc, GM_ADVANCED);
            SetWorldTransform(hdc, &xForm);

            //---- get scaled rect ----
			RECT rc;
			GetClientRect(hWnd, &rc);
            rc.right = (rc.right*100)/iZoomFactor;
            rc.bottom = (rc.bottom*100)/iZoomFactor;

            //---- paint the center bitmap ----
            HDC dc2;
            dc2 = CreateCompatibleDC(hdc);
            if ((dc2) && (hCenterDIB))
            {
                HBITMAP hOldBitmap2;
                hOldBitmap2 = (HBITMAP) SelectObject(dc2, hCenterDIB);

                int x = ((rc.right - rc.left) - iDibWidth)/2;
                int y = ((rc.bottom - rc.top) - iDibHeight)/2;
                BLENDFUNCTION bf = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};

                if (fAlpha)
                {
                    AlphaBlend(hdc, x, y, iDibWidth, iDibHeight, 
                        dc2, 0, 0, iDibWidth, iDibHeight, bf);
                }
                else
                {
                    BitBlt(hdc, x, y, iDibWidth, iDibHeight, 
                        dc2, 0, 0, SRCCOPY);
                }

                SelectObject(dc2, hOldBitmap2);
                DeleteDC(dc2);
            }

			EndPaint(hWnd, &ps);
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			break;

		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
//----------------------------------------------------------------------------
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
//----------------------------------------------------------------------------
void OnFileOpen(HINSTANCE hInst, HWND hWnd)
{
	const WCHAR *filter = 
		L"Bitmap Files (*.bmp)\0*.bmp\0"
		L"PNG Files (*.png)\0*.png\0"
		L"All Files (*.*)\0*.*\0\0";

    OPENFILENAME ofn = {sizeof(ofn)};  
    WCHAR szFile[_MAX_PATH+1] = {0};       

    //---- init ofn ----
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hInst;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = ARRAYSIZE(szFile);
    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = L"Select an Image File to preview";
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    // Display the Open dialog box. 

    if (GetOpenFileName(&ofn)) 
    {
        HRESULT hr = InitDib(hInst, szFile);
        if (SUCCEEDED(hr))
            InvalidateRect(hWnd, NULL, TRUE);
    }
}
//----------------------------------------------------------------------------
void SetZoom(HWND hWnd, HINSTANCE hInstance, int iZoomPercent, int iMenuId)
{
    iZoomFactor = iZoomPercent;

    InvalidateRect(hWnd, NULL, TRUE);

    //---- update menu items ----
    HMENU hMenu = GetMenu(hWnd);
    hMenu = GetSubMenu(hMenu, 2);

    if (iCurrentZoomMenu)
        CheckMenuItem(hMenu, iCurrentZoomMenu, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hMenu, iMenuId, MF_BYCOMMAND | MF_CHECKED);

    iCurrentZoomMenu = iMenuId;
}
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\packthem\localsign.h ===
/*****************************************************************************\
    FILE: localsign.h

    DESCRIPTION:
        This code will sign and verify the signature of a Visual Style file.

    BryanSt 8/1/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef PACKTHEM_SIGNING_H
#define PACKTHEM_SIGNING_H

#include <utils.h>
#include <shlwapip.h>
#include "localsign.h"
#include "..\inc\signing.h"



HRESULT SignTheme(IN LPCWSTR pszFileName, int nWeek);
HRESULT CheckSignatureThemeInternal(IN LPCWSTR pszFileName);
HRESULT GenerateKeys(IN LPCWSTR pszFileName);

/*****************************************************************************\
    WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING

    Do NOT let this private key be included in anything except packthem.exe

    WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING

    You can create new key pairs by running "packthem.exe -g gofaster"
\*****************************************************************************/

const BYTE s_keyPrivate1[]    =   //  Private Key: #1
{
    0x07, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x32, 0x00,
    0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x73, 0xAA, 0xFD, 0xFE, 0x2E, 0x34,
    0x75, 0x3B, 0xC2, 0x20, 0x72, 0xFC, 0x50, 0xCC, 0xD4, 0xE0, 0xDE, 0xC7, 0xA6,
    0x46, 0xC6, 0xDC, 0xE6, 0x6B, 0xF0, 0x58, 0x11, 0x88, 0x66, 0x54, 0x5F, 0x3D,
    0x81, 0x8C, 0xEF, 0x5F, 0x89, 0x51, 0xE4, 0x9C, 0x3F, 0x57, 0xA6, 0x22, 0xA9,
    0xE7, 0x0F, 0x4B, 0x56, 0x81, 0xD1, 0xA6, 0xBA, 0x24, 0xFF, 0x93, 0x17, 0xFE,
    0x64, 0xEF, 0xE5, 0x11, 0x90, 0x00, 0xDC, 0x37, 0xC2, 0x84, 0xEE, 0x7B, 0x12,
    0x43, 0xA4, 0xAF, 0xC3, 0x69, 0x57, 0xD1, 0x92, 0x96, 0x8E, 0x55, 0x0F, 0xE1,
    0xCD, 0x0F, 0xAE, 0xEA, 0xE8, 0x01, 0x83, 0x65, 0x32, 0xF1, 0x80, 0xDB, 0x08,
    0xD6, 0x01, 0x84, 0xB1, 0x09, 0x80, 0x3C, 0x27, 0x83, 0x9F, 0x16, 0x92, 0x86,
    0x4C, 0x8E, 0x15, 0xC7, 0x94, 0xE4, 0x27, 0xFF, 0x2B, 0xA4, 0x28, 0xDE, 0x9C,
    0x43, 0x5B, 0x5E, 0x14, 0xB6, 0x5D, 0x33, 0x83, 0x8F, 0x62, 0x33, 0xAE, 0x99,
    0x1F, 0xA3, 0xE3, 0x41, 0xC9, 0x46, 0x76, 0xAA, 0x93, 0x74, 0x5A, 0xCA, 0x0D,
    0xEE, 0xCA, 0x84, 0xF5, 0xF6, 0xA4, 0x70, 0xD8, 0x5D, 0x58, 0x7B, 0xA2, 0xD3,
    0x74, 0x57, 0xF0, 0x04, 0x05, 0xBE, 0xF0, 0x3C, 0xBB, 0xAB, 0x8E, 0x2C, 0x70,
    0xDC, 0x5B, 0x0C, 0x6E, 0x10, 0xC7, 0x75, 0xA4, 0x8F, 0x87, 0xDF, 0x20, 0x62,
    0x26, 0xAF, 0xC8, 0xE5, 0x0F, 0xC8, 0x11, 0x91, 0xAC, 0xC3, 0x00, 0x1D, 0x05,
    0x07, 0xB6, 0x1D, 0xB7, 0x9E, 0x7B, 0xB8, 0xE1, 0x20, 0x1B, 0x9D, 0xCB, 0x68,
    0xA5, 0x4C, 0x8F, 0x4E, 0x70, 0xCC, 0x2E, 0xF0, 0x71, 0xE8, 0x13, 0xF4, 0x58,
    0xA8, 0x60, 0x2E, 0x23, 0x13, 0x13, 0x60, 0x4C, 0xC5, 0xBC, 0x80, 0xC3, 0xA5,
    0x84, 0xA1, 0x25, 0xD4, 0x69, 0x31, 0x28, 0xEE, 0x38, 0xD1, 0x04, 0x5A, 0x36,
    0x61, 0xDA, 0xCA, 0xC5, 0x18, 0xB7, 0xAF, 0xE9, 0x69, 0xD3, 0xC1, 0x9C, 0x8B,
    0xB2, 0x53, 0xB1, 0x85, 0xDA, 0x2C, 0xBF, 0xDA, 0xB9, 0xBD, 0x8B, 0xCE, 0x1D,
    0x62, 0x8D, 0x49, 0x61, 0x70, 0xC3, 0x9D, 0x68, 0xBB, 0xA9, 0xBF, 0x66, 0x3B,
    0x87, 0x49, 0x8F, 0x98, 0xF4, 0x32, 0x68, 0xCB, 0xE4, 0xB7, 0x5B, 0xFF, 0xB4,
    0xA2, 0x77, 0xF4, 0x4F, 0xA7, 0xCA, 0x6C, 0xDD, 0x34, 0x69, 0xE8, 0xA1, 0x1C,
    0x37, 0x8C, 0x67, 0x7B, 0x87, 0xEC, 0x96, 0x48, 0x6C, 0x95, 0xA9, 0xDF, 0x8E,
    0xDE, 0xFB, 0x7D, 0x43, 0xEE, 0x6B, 0x29, 0x4B, 0x1D, 0x47, 0x9B, 0x2B, 0xA7,
    0x0C, 0x3E, 0xC9, 0xA4, 0x8C, 0xFB, 0x34, 0xF1, 0x70, 0x86, 0xF7, 0x71, 0xDE,
    0xE8, 0x80, 0x7D, 0x84, 0x36, 0x76, 0xA5, 0xB6, 0xD7, 0xFE, 0x0D, 0xE9, 0xB1,
    0x72, 0xC6, 0x7E, 0xCF, 0x1C, 0xEC, 0xCA, 0x89, 0x0E, 0x4F, 0xF8, 0x94, 0x13,
    0x1E, 0x7A, 0x43, 0xA6, 0x76, 0x97, 0x12, 0x41, 0x3E, 0x8A, 0x63, 0xD1, 0x09,
    0x6B, 0x3A, 0x45, 0x68, 0xA9, 0xC2, 0x8A, 0x5E, 0xA2, 0x00, 0x54, 0x59, 0x7D,
    0x8E, 0xAF, 0x15, 0xE1, 0x6C, 0x1B, 0x3F, 0x4E, 0x17, 0x92, 0xC2, 0xBC, 0x3A,
    0x78, 0x9B, 0x7B, 0xBB, 0x69, 0x9D, 0x65, 0x73, 0x43, 0xF9, 0xE0, 0xE6, 0x9D,
    0x11, 0xC4, 0xC9, 0x8A, 0xB0, 0x38, 0x5D, 0x59, 0x84, 0x6A, 0x78, 0x79, 0xAD,
    0x39, 0x65, 0x6D, 0x8B, 0xFD, 0xFA, 0x77, 0x42, 0x23, 0x96, 0x89, 0xF3, 0x56,
    0x98, 0x47, 0x43, 0x81, 0x7D, 0x89, 0x88, 0x7C, 0xE9, 0x49, 0x02, 0xCE, 0xBE,
    0x7D, 0x4C, 0x81, 0xBC, 0x23, 0xE4, 0x5E, 0x0B, 0xBD, 0x26, 0x33, 0xAE, 0x3E,
    0x89, 0x02, 0xBF, 0x45, 0xFC, 0x3A, 0x73, 0x11, 0xB2, 0xEF, 0xCF, 0x4E, 0xFC,
    0x03, 0xEE, 0x8A, 0xEC, 0x83, 0x4F, 0x1C, 0x05, 0xDF, 0x25, 0x17, 0xE8, 0xEC,
    0x8C, 0x0E, 0x1F, 0x41, 0x1A, 0x67, 0x09, 0xED, 0x2C, 0x1A, 0x32, 0x56, 0xDB,
    0x60, 0x07, 0xB0, 0xE0, 0xDF, 0x91, 0xFE, 0xD9, 0xDB, 0xBB, 0x64, 0x93, 0xE8,
    0x5E, 0x4D, 0xE9, 0x44, 0xF1, 0x29, 0x91, 0x15, 0x37, 0x94, 0xEC, 0x1C, 0x81,
    0x19, 0xA4, 0x86, 0xDA, 0xEA, 0x20, 0x1F, 0xA3, 0xD9, 0x12, 0x5E, 0x32, 0x36,
    0xC2, 0x73, 0xD4, 0x82, 0x33, 0xAA, 0x55, 0x83, 0x88, 0x4E, 0x74
};

#define SIZE_PRIVATE_KEY         sizeof(s_keyPrivate1)


#endif // PACKTHEM_SIGNING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\apicompare\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DumpIcon.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\apicompare\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__CED75F4A_7D64_4EF9_B869_5655DFADAEA4__INCLUDED_)
#define AFX_STDAFX_H__CED75F4A_7D64_4EF9_B869_5655DFADAEA4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <wingdi.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CED75F4A_7D64_4EF9_B869_5655DFADAEA4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\preview\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set 
//---------------------------------------------------------------------------
#ifndef _STDAFX_H_
#define _STDAFX_H_
//---------------------------------------------------------------------------
#define _iswupper(_c)    ( iswctype(_c,_UPPER) )
#define _iswlower(_c)    ( iswctype(_c,_LOWER) )
#define _iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define _iswxdigit(_c)   ( iswctype(_c,_HEX) )
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define STRICT
#define _ATL_NO_ATTRIBUTES
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
//---------------------------------------------------------------------------
#include "autos.h"
#include "log.h"
#include "errors.h"
#include "utils.h"
//---------------------------------------------------------------------------
#include <atlbase.h> 
//---------------------------------------------------------------------------
#endif //_STDAFX_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\aboutdlg.h ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\aboutdlg.h
//
//  Contents:  Interface of the CAboutDlg class.
//             Generated by the WTL app wizard.
//
//  Classes:   CAboutDlg
//
//------------------------------------------------------------------------
#pragma once

class CAboutDlg : public CDialogImpl<CAboutDlg>
{
public:
    enum { IDD = IDD_ABOUTBOX };

    BEGIN_MSG_MAP(CAboutDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
        COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
    END_MSG_MAP()

    LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
    {
        CenterWindow(GetParent());
        return TRUE;
    }

    LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        EndDialog(wID);
        return 0;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\apicompare\apicompare.cpp ===
// DumpIcon.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "stdio.h"
#include "commctrl.h"
#include "uxtheme.h"
#include <tmschema.h>


int __cdecl main(int cch, char* ppv[])
{

    __int64 liStart;
    __int64 liEnd;
    __int64 liFreq;
    QueryPerformanceFrequency((LARGE_INTEGER*)&liFreq);

    InitCommonControls();
    CreateWindow(TEXT("Static"), TEXT(""), WS_POPUP, 0,0,0,0,0,0,0,0);
    HTHEME g_hTheme9Grid = OpenThemeData(NULL, L"Button");
    HTHEME g_hThemeSolid = OpenThemeData(NULL, L"Progress");

    HDC hdc = CreateCompatibleDC(NULL);
    HBITMAP hbmp = CreateBitmap(100, 100, 1, 32, NULL);
    SelectObject(hdc, hbmp);

    RECT rc = {0,0,76,24};		// default size of a button on 12x10 96dpi system

    //---- time button face vs. 9-grid ----
    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);
    for (int i = 0; i < 100; i++)
    {
        DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONPUSH);
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);
    double fTimeForBaseline = (float)(liEnd - liStart) / liFreq;

    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);

    for (int i = 0; i < 100; i++)
    {
        DrawThemeBackground(g_hTheme9Grid, hdc, 1, 1, &rc, 0);
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);
    double fTimeFor9Grid = (float)(liEnd - liStart) / liFreq;

    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);

    //---- time solid rect, direct vs. uxtheme ----
    for (int i = 0; i < 500; i++)
    {
        //---- part=3 is the "chunk" part ----
        DrawThemeBackground(g_hThemeSolid, hdc, 3, 1, &rc, 0);
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);
    double fTimeForSolid = (float)(liEnd - liStart) / liFreq;

    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);

    for (int i = 0; i < 500; i++)
    {
	COLORREF crOld = SetBkColor(hdc, RGB(0,0,0xff));
        ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
	
	//--- restore the color as normal API service would have to ----
        SetBkColor(hdc, crOld);
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);
    double fTimeForGDI = (float)(liEnd - liStart) / liFreq;

    for (int i = 0; i < 500; i++)
    {
        HBRUSH hbr = CreateSolidBrush(RGB(0,0,0xff));
        HBRUSH hold = (HBRUSH)SelectObject(hdc, hbr);
        FillRect(hdc, &rc, hbr);
        SelectObject(hdc, hold);
        DeleteObject(hbr);
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);
    double fTimeForGDI2 = (float)(liEnd - liStart) / liFreq;

    TCHAR sz[256];
    sprintf(sz, TEXT("The total time to render a 9 Grid, 100 times is %f,\n"
        "which is %fx slower than baseline of %f. To render a solid color takes %f,\n"
        "which is %fx Slower than using ExtTextOut with a time of %f or \n"
        "%fx slower than PatBlt which with a time of %f"), 
        fTimeFor9Grid, fTimeFor9Grid / fTimeForBaseline, fTimeForBaseline, 
        fTimeForSolid, fTimeForSolid / fTimeForGDI, fTimeForGDI, 
        fTimeForSolid / fTimeForGDI2, fTimeForGDI2);

    MessageBox(NULL, sz, TEXT("UxTheme times vs Raw GDI calls"), 0);


    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\ctlperfview.cpp ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\CtlPerfView.cpp
//
//  Contents:  Implementation of the CCtlPerfView class.
//
//  Classes:   CCtlPerfView
//
//------------------------------------------------------------------------
#include "stdafx.h"
#include "resource.h"
#include "CtlPerfView.h"
#include "Samples.h"
#include <atlmisc.h>
#include <shellapi.h>

//** Local constants
    // Default log file name
    const TCHAR kszLogFileName[] = _T("CtlPerf.log");
    // Default number of loops
    const UINT kcLoops = 100;
    // Default numbers of controls in X
    const UINT kcxCtrl = 10;
    // Default numbers of controls in Y
    const UINT kcyCtrl = 10;
    // Default name for pass 1
    const TCHAR kszPass1[] = _T("Pass1");
    // Default name for pass 2
    const TCHAR kszPass2[] = _T("Pass2");
    // Default value for NumberOnly
    const TCHAR kszNumberOnly[] = _T("false");

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::CCtlPerfView
//
//  Synopsis:  Constructor
//
//------------------------------------------------------------------------
CCtlPerfView::CCtlPerfView()
{    
    m_hWndStatusBar = NULL;
    m_rgWnds = NULL;
    m_rgzClasses = NULL;
    m_cClasses = 0;
    m_cxCtrl = kcxCtrl;
    m_cyCtrl = kcyCtrl;
    m_cX = 0;
    m_cY = 0;
    m_cLoops = kcLoops;
    m_bTwoPasses = false;
    m_bBatch = false;
    m_bSilent = false;
    _tcscpy(m_szLogFileName, kszLogFileName);
    _tcscpy(m_szPass1, kszPass1);
    _tcscpy(m_szPass2, kszPass2);
    _tcscpy(m_szNumberOnly, kszNumberOnly);
    ParseIniFile();
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::~CCtlPerfView
//
//  Synopsis:  Destructor
//
//------------------------------------------------------------------------
CCtlPerfView::~CCtlPerfView()
{
    if (m_rgWnds)
    {
        free(m_rgWnds);
    }

    if (m_rgzClasses)
    {
        for(UINT i = 0; i < m_cClasses; i++)
        {
            if (m_rgzClasses[i])
            {
                free(m_rgzClasses[i]);
            }
        }
        free(m_rgzClasses);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::SetStatusBar
//
//  Synopsis:  Receive status bar from parent
//
//  Arguments: hWndStatusBar      Status bar window handle
//
//------------------------------------------------------------------------
void CCtlPerfView::SetStatusBar(HWND hWndStatusBar)
{
    m_hWndStatusBar = hWndStatusBar;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::ParseIniFile
//
//  Synopsis:  Process INI file
//
//------------------------------------------------------------------------
void CCtlPerfView::ParseIniFile()
{
    FILE* flIniFile;

    flIniFile = ::_wfopen(_T("CtlPerf.ini"), _T("r"));

    if (flIniFile)
    {
        TCHAR szLine[1024];

        szLine[0] = _T('\0');

#define STRIP_TRAILING_RETURN(s) \
		{ \
			LPTSTR p = _tcschr(s, _T('\n')); \
				\
			if(p) \
            { \
				*p = _T('\0'); \
            } \
		}

        while (!feof(flIniFile))
        {
            // Read the [Classes] section
            ::fgetws(szLine, _countof(szLine), flIniFile);
			STRIP_TRAILING_RETURN(szLine);

            if (!_tcsicmp(szLine, _T("[Classes]")))
            {
                szLine[0] = _T('\0');
                ::fgetws(szLine, _countof(szLine), flIniFile);
				STRIP_TRAILING_RETURN(szLine);

                // Read each class
                while (szLine[0] != _T('\0') && szLine[0] != _T('['))
                {
                    if (szLine[0] != _T(';'))
                    {
                        m_cClasses++;
                        m_rgzClasses = (LPTSTR*) realloc(m_rgzClasses, m_cClasses * sizeof(LPTSTR));
                        if (m_rgzClasses)
                        {
                            m_rgzClasses[m_cClasses - 1] = _tcsdup(szLine);
                        }
                    }

                    szLine[0] = _T('\0');
                    ::fgetws(szLine, _countof(szLine), flIniFile);
					STRIP_TRAILING_RETURN(szLine);
                }
            }

            // Read the Options section
            if (!_tcsicmp(szLine, _T("[Options]"))) 
            {
                UINT n;
                UINT n1;
                UINT n2;

                szLine[0] = _T('\0');
                ::fgetws(szLine, _countof(szLine), flIniFile);
				STRIP_TRAILING_RETURN(szLine);

                // Try each token, to time to do better
                while (szLine[0] != _T('\0') && szLine[0] != _T('['))
                {
                    n = 0;
                    swscanf(szLine, _T("XControls=%d"), &n);
                    if (n)
                    {
                        m_cxCtrl = n;
                    }
                    else
                    {
                        swscanf(szLine, _T("YControls=%d"), &n);
                        if (n)
                        {
                            m_cyCtrl = n;
                        }
                        else
                        {
                            swscanf(szLine, _T("NumLoops=%d"), &n);
                            if (n)
                            {
                                m_cLoops = n;
                            }
                            else
                            {
                                n1 = n2 = 0;

                                swscanf(szLine, _T("Resolution=%dx%d"), &n1, &n2);
                                if (n1 && n2)
                                {
                                    m_cX = n1;
                                    m_cY = n2;
                                }
                                else
                                {
                                    LPTSTR p = _tcschr(szLine, _T('='));

                                    if(p && !_tcsnicmp(szLine, _T("Pass1"), _countof(_T("Pass1")) - 1))
                                    {
                                        _tcscpy(m_szPass1, p + 1);
                                    }
                                    else if(p && !_tcsnicmp(szLine, _T("Pass2"), _countof(_T("Pass2")) - 1))
                                    {
                                        _tcscpy(m_szPass2, p + 1);
                                    }
                                    else if(p && !_tcsnicmp(szLine, _T("LogFile"), _countof(_T("LogFile")) - 1))
                                    {
                                        _tcscpy(m_szLogFileName, p + 1);
                                    }
                                    else if(p && !_tcsnicmp(szLine, _T("Viewer"), _countof(_T("Viewer")) - 1))
                                    {
                                        _tcscpy(m_szViewer, p + 1);
                                    }
                                    else if(p && !_tcsnicmp(szLine, _T("NumberOnly"), _countof(_T("NumberOnly")) - 1))
                                    {
                                        _tcscpy(m_szNumberOnly, p + 1);
                                    }
                                }
                            }
                        }
                    }
                    
                    szLine[0] = _T('\0');
                    ::fgetws(szLine, _countof(szLine), flIniFile);
				STRIP_TRAILING_RETURN(szLine);
                }
            }
        }
        fclose(flIniFile);
    }
    m_rgWnds = (HWND*) calloc(m_cxCtrl * m_cyCtrl, sizeof(HWND));
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::TestControl
//
//  Synopsis:  Test a single control class
//
//  Arguments: szClassName      Name of window class to create
//
//------------------------------------------------------------------------
void CCtlPerfView::TestControl(LPTSTR szClassName)
{
    UINT nWidth;
    UINT nHeight;
    DWORD dwStyle = WS_BORDER;
    CRect rcWindow;

    ClearChildren();

    GetWindowRect(rcWindow);
    nWidth = rcWindow.Width() / (m_cxCtrl + 1);
    nHeight = rcWindow.Height() / (m_cyCtrl + 1);

    // Some controls need specials styles
    if (!_tcsicmp(szClassName, _T("ToolbarWindow32"))
        || !_tcsicmp(szClassName, _T("ReBarWindow32"))
        || !_tcsicmp(szClassName, _T("msctls_statusbar32")))
    {
        dwStyle |= CCS_NOPARENTALIGN | CCS_NORESIZE;
    }

    if (!_tcsicmp(szClassName, _T("SysTreeView32")))
    {
        dwStyle |= TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_EDITLABELS | TVS_CHECKBOXES;
    }

    // Some controls need an initialization routine to create data
    // See samples.*

    PFNINIT pf = NULL;    // Routine to call after creation

    if (!_tcsicmp(szClassName, _T("SysTabControl32")))
    {
        pf = Pickers_Init;
    }
    if (!_tcsicmp(szClassName, _T("msctls_progress32")))
    {
        pf = Movers_Init;
    }
    if (!_tcsicmp(szClassName, _T("ListBox")))
    {
        pf = Lists_Init;
    }
    if (!_tcsicmp(szClassName, _T("ComboBox")))
    {
        pf = Combo_Init;
    }
    if (!_tcsicmp(szClassName, _T("ComboBoxEx32")))
    {
        pf = ComboEx_Init;
    }
    if (!_tcsicmp(szClassName, _T("SysListView32")))
    {
        pf = ListView_Init;
    }
    if (!_tcsicmp(szClassName, _T("SysTreeView32")))
    {
        pf = TreeView_Init;
    }
    if (!_tcsicmp(szClassName, _T("msctls_statusbar32")))
    {
        pf = Status_Init;
    }
    if (!_tcsicmp(szClassName, _T("SysTabControl32")))
    {
        pf = Pickers_Init;
    }
    if (!_tcsicmp(szClassName, _T("ToolbarWindow32")))
    {
        pf = Toolbar_Init;
    }
    if (!_tcsicmp(szClassName, _T("ReBarWindow32")))
    {
        pf = Rebar_Init;
    }

    m_perfLog.OpenLoggingClass(szClassName);
    m_perfLog.StartCreate(m_cxCtrl * m_cyCtrl);

    // Create m_cLoops instances
    // They're initially visible for better perf realism, but set to non-visible while adding data (if any)
    for (UINT i = 0; i < m_cxCtrl; i++)
    {
        for (UINT j = 0; j < m_cyCtrl; j++)
        {
            m_rgWnds[i + m_cxCtrl * j] = ::CreateWindow(szClassName, 
                szClassName, 
                WS_CHILD | WS_VISIBLE | dwStyle,
                i * nWidth * (m_cxCtrl + 1) / m_cxCtrl, 
                j * nHeight * (m_cyCtrl + 1) / m_cyCtrl, 
                nWidth, 
                nHeight, 
                m_hWnd, 
                NULL, 
                _Module.GetModuleInstance(), 
                NULL);
            ATLASSERT(m_rgWnds[i + m_cxCtrl * j]);

            if (!m_rgWnds[i + m_cxCtrl * j])
            {
                if (!m_bBatch)
                {
                    TCHAR szMessage[1024];

                    wsprintf(szMessage, _T("Failed to create class %s, test aborted."), szClassName);
                    MessageBox(szMessage, _T("CtlPerf"), MB_OK | MB_ICONERROR);
                }
                return;
            }

            if(pf != NULL)
            {
                DWORD dwOldStyle = ::GetWindowLong(m_rgWnds[i + m_cxCtrl * j], GWL_STYLE);

                ::SetWindowLong(m_rgWnds[i + m_cxCtrl * j], GWL_STYLE, dwOldStyle & ~WS_VISIBLE);
                pf(m_rgWnds[i + m_cxCtrl * j]);
                ::SetWindowLong(m_rgWnds[i + m_cxCtrl * j], GWL_STYLE, dwOldStyle);
            }

            // Handle escape key to abort
            if(::GetAsyncKeyState(VK_ESCAPE))
            {
                m_perfLog.StopLogging();
                return;
            }
        }
    }
    m_perfLog.StopCreate();

    m_perfLog.StartPaint(m_cLoops);
    for (i = 0; i < m_cLoops; i++)
    {
        RedrawWindow(NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_INTERNALPAINT | RDW_UPDATENOW | RDW_ALLCHILDREN);

        // Handle escape key to abort
        if(::GetAsyncKeyState(VK_ESCAPE))
        {
            m_perfLog.StopLogging();
            return;
        }
    }

    m_perfLog.StopPaint();
    
    TimeResize();

    m_perfLog.CloseLoggingClass();
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnFinalMessage
//
//  Synopsis:  Called after window destruction, do window cleanup
//
//------------------------------------------------------------------------
void CCtlPerfView::OnFinalMessage(HWND /*hWnd*/)
{
    m_perfLog.StopLogging();
    ClearChildren();
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::ClearChildren
//
//  Synopsis:  Destroy all child windows
//
//------------------------------------------------------------------------
void CCtlPerfView::ClearChildren()
{
    for (UINT i = 0; i < m_cxCtrl; i++)
    {
        for (UINT j = 0; j < m_cyCtrl; j++)
        {
            if (::IsWindow(m_rgWnds[i + m_cxCtrl * j]))
            {
                ::DestroyWindow(m_rgWnds[i + m_cxCtrl * j]);
            }
            m_rgWnds[i + m_cxCtrl * j] = NULL;
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::ResizeChildren
//
//  Synopsis:  Resize the controls inside the client area
//
//------------------------------------------------------------------------
void CCtlPerfView::ResizeChildren()
{
    CRect rcWindow;
    GetWindowRect(rcWindow);
    UINT nWidth = rcWindow.Width() / (m_cxCtrl + 1);
    UINT nHeight = rcWindow.Height() / (m_cyCtrl + 1);

    for (UINT i = 0; i < m_cxCtrl; i++)
    {
        for (UINT j = 0; j < m_cyCtrl; j++)
        {
            if (!::IsWindow(m_rgWnds[i + m_cxCtrl * j]))
            {
                continue;
            }

            ::SetWindowPos(m_rgWnds[i + m_cxCtrl * j], 
                NULL,
                i * nWidth * (m_cxCtrl + 1) / m_cxCtrl, 
                j * nHeight * (m_cyCtrl + 1) / m_cyCtrl, 
                nWidth, 
                nHeight,
                SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::TimeResize
//
//  Synopsis:  Does the whole resizing timing
//
//------------------------------------------------------------------------
void CCtlPerfView::TimeResize()
{
    m_perfLog.StartResize(m_cLoops);
    
    CRect rcWindow;
    CWindow wnd(GetTopLevelParent());
    wnd.GetWindowRect(rcWindow);

    UINT nWidth = rcWindow.Width();
    UINT nHeight = rcWindow.Height();
    MSG msg;

    // First resize without repainting
    for (UINT i = 0; i < m_cLoops; i++)
    {
        nWidth -= 4;
        nHeight -= 3;
        wnd.SetWindowPos(NULL,
            0, 
            0, 
            nWidth,
            nHeight,
            SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);

        // Leave the message loop breathe a little (else it locks)
        while (!::PeekMessage(&msg, wnd, NULL, NULL, PM_NOREMOVE));

        // Handle escape key to abort
        if(::GetAsyncKeyState(VK_ESCAPE))
        {
            m_perfLog.StopLogging();
            return;
        }
    }
    m_perfLog.StopResize();
    // Repaint once (not timed)
    wnd.SetWindowPos(NULL,
        0, 
        0, 
        rcWindow.Width(),
        rcWindow.Height(),
        SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);

    m_perfLog.StartResizeAndPaint(m_cLoops);

    nWidth = rcWindow.Width();
    nHeight = rcWindow.Height();

    for (i = 0; i < m_cLoops; i++)
    {
        nWidth -= 4;
        nHeight -= 3;
        wnd.SetWindowPos(NULL,
            0, 
            0, 
            nWidth,
            nHeight,
            SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);
        // This time we update each time
        UpdateWindow();

        // Leave the message loop breathe a little
        while (!::PeekMessage(&msg, wnd, NULL, NULL, PM_NOREMOVE));

        // Handle escape key to abort
        if(::GetAsyncKeyState(VK_ESCAPE))
        {
            m_perfLog.StopLogging();
            return;
        }
    }
    m_perfLog.StopResizeAndPaint();
    // Repaint once
    wnd.SetWindowPos(NULL,
        0, 
        0, 
        rcWindow.Width(),
        rcWindow.Height(),
        SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnCreate
//
//  Synopsis:  WM_CREATE handler
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
{
    // Create a menu with all the classes
    if (m_cClasses > 0)
    {
        CMenu menu(::GetMenu(GetParent()));

        if(menu != NULL)
        {
            CMenuItemInfo mii;

            mii.fMask = MIIM_SUBMENU;
            menu.GetSubMenu(0).GetMenuItemInfo(2, TRUE, &mii); // Hard-coded position!!

            for (UINT i = 0; i < m_cClasses; i++)
                ::AppendMenu(mii.hSubMenu, MF_STRING, IDM_CONTROL + i, m_rgzClasses[i]);
        }
    }
    bHandled = FALSE;
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnSize
//
//  Synopsis:  WM_SIZE handler
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
{
    bHandled = FALSE;

    ResizeChildren();
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnGetMinMaxInfo
//
//  Synopsis:  WM_GETMINMAXINFO handler, forwarded by the parent
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnGetMinMaxInfo(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
{
    if(m_cX == 0 || m_cY == 0)
    {
        bHandled = FALSE;
        return 1;
    }

    LPMINMAXINFO pMMI = (LPMINMAXINFO) lParam;

    if(pMMI)
    {
        pMMI->ptMaxSize = CPoint(m_cX, m_cY);
    }
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnControl
//
//  Synopsis:  IDM_CONTROL handler
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnControl(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& bHandled)
{
    if (wID < IDM_CONTROL || wID > IDM_CONTROL + 99)
    {
        bHandled = 0;
        return 0;
    }

    LPTSTR pszClassName = m_rgzClasses[wID - IDM_CONTROL];

    // Time a single control class
    m_perfLog.StartLoggingOnePass(m_szLogFileName, m_hWndStatusBar, m_szPass1);
    TestControl(pszClassName);
    m_perfLog.CloseLoggingClass();
    m_perfLog.StopLogging();
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnFrame
//
//  Synopsis:  IDM_FRAME handler
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnFrame(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
    ClearChildren();

    m_perfLog.StartLoggingOnePass(m_szLogFileName, m_hWndStatusBar, m_szPass1);
    // Time the frame window
    m_perfLog.OpenLoggingClass(kszFrameWnd);

    m_perfLog.StartPaint(m_cLoops);
    for (UINT i = 0; i < m_cLoops; i++)
        RedrawWindow(NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_INTERNALPAINT | RDW_UPDATENOW | RDW_ALLCHILDREN);

    m_perfLog.StopPaint();

    TimeResize();

    m_perfLog.CloseLoggingClass();
    m_perfLog.StopLogging();
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::RunSuite
//
//  Synopsis:  Call TestControl() for every control class
//
//------------------------------------------------------------------------
void CCtlPerfView::RunSuite()
{
    // determine output type and set value in perflog
    m_perfLog.SetOutputType(m_szNumberOnly);
    // First do the frame
    m_perfLog.OpenLoggingClass(kszFrameWnd);

    m_perfLog.StartPaint(m_cLoops);
    for (UINT i = 0; i < m_cLoops; i++)
        RedrawWindow(NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_INTERNALPAINT | RDW_UPDATENOW | RDW_ALLCHILDREN);

    m_perfLog.StopPaint();

    TimeResize();

    m_perfLog.CloseLoggingClass();

    // Then each control
    for (i = 0; i < m_cClasses; i++)
    {
        if (m_rgzClasses[i])
        {
            TestControl(m_rgzClasses[i]);

            // Handle escape key to abort
            if(::GetAsyncKeyState(VK_ESCAPE))
            {
                m_perfLog.StopLogging();
                break;
            }
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnSuite1
//
//  Synopsis:  IDM_SUITE1 handler: create and run one pass
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnSuite1(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
    m_bTwoPasses = false;

    if (!m_bBatch)
    {
        COptionsDialog dlg(this);

        INT_PTR nRes = dlg.DoModal();

        if (nRes == IDCANCEL)
            return 0;

        // Reset the WS_MAXIMIZE style to set the parent to the new size, via WM_GETMINMAXINFO
        ::SetWindowLong(GetParent(), GWL_STYLE, ::GetWindowLong(GetParent(), GWL_STYLE) & ~WS_MAXIMIZE);
        ::ShowWindow(GetParent(), SW_MAXIMIZE);
    }

    m_perfLog.StartLoggingOnePass(m_szLogFileName, m_hWndStatusBar, m_szPass1);

    RunSuite();

    m_perfLog.StopLogging();

    // Run the viewer app with the results
    TCHAR szCurDir[_MAX_PATH + 1];

    ::GetCurrentDirectory(_countof(szCurDir), szCurDir);
    ::ShellExecute(GetDesktopWindow(), NULL, m_szViewer, m_szLogFileName, szCurDir, SW_SHOWMAXIMIZED);
    ClearChildren();

    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnSuite2
//
//  Synopsis:  IDM_SUITE2 handler: create and run two passes
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnSuite2(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
    m_bTwoPasses = true;

    if (!m_bBatch)
    {
        COptionsDialog dlg(this);

        INT_PTR nRes = dlg.DoModal();

        if (nRes == IDCANCEL)
            return 0;

        // Reset the WS_MAXIMIZE style to set the parent to the new size, via WM_GETMINMAXINFO
        ::SetWindowLong(GetParent(), GWL_STYLE, ::GetWindowLong(GetParent(), GWL_STYLE) & ~WS_MAXIMIZE);
        ::ShowWindow(GetParent(), SW_MAXIMIZE);
    }

    m_perfLog.StartLoggingTwoPasses(m_szLogFileName, m_hWndStatusBar, m_szPass1, m_szPass2);

    RunSuite();

    m_perfLog.StopLoggingPass1();
    
    ClearChildren();

    if (m_bSilent
        || (IDOK == ::MessageBox(GetParent(), 
                                _T("Ready to run pass 2, press OK after changing Theme settings."), 
                                _T("CtlPerf"), 
                                MB_OKCANCEL)))
    {
        m_perfLog.StartLoggingPass2();
        RunSuite();
        m_perfLog.StopLoggingPass2();

        if (m_bSilent)
        {
            ::PostMessage(GetParent(), WM_CLOSE, 0, 0);
        }
    }

    m_perfLog.StopLogging();

    // Run the viewer app with the results
    TCHAR szCurDir[_MAX_PATH + 1];

    ::GetCurrentDirectory(_countof(szCurDir), szCurDir);
    ::ShellExecute(GetDesktopWindow(), NULL, m_szViewer, m_szLogFileName, szCurDir, SW_SHOWMAXIMIZED);
    ClearChildren();

    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnBatch1
//
//  Synopsis:  IDM_BATCH1 handler: create and run one pass in non-interactive mode
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnBatch1(WORD /*wNotifyCode*/, WORD wID, HWND hWndCtl, BOOL& /*bHandled*/)
{
    m_bBatch = true;

    // Override the log file name
    if((LPTSTR) hWndCtl)
        _tcscpy(m_szLogFileName, (LPTSTR) hWndCtl);

    // Simulate a menu selection, but with m_bBatch to true, and exit
    PostMessage(WM_COMMAND, IDM_SUITE1, 0);
    ::PostMessage(GetParent(), WM_CLOSE, 0, 0);

    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnBatch2
//
//  Synopsis:  IDM_BATCH2 handler: create and run two passes in non-interactive mode
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnBatch2(WORD /*wNotifyCode*/, WORD wID, HWND hWndCtl, BOOL& /*bHandled*/)
{
    m_bBatch = true;
    m_bSilent = false;

    // Override the log file name
    if((LPTSTR) hWndCtl)
        _tcscpy(m_szLogFileName, (LPTSTR) hWndCtl);

    PostMessage(WM_COMMAND, IDM_SUITE2, 0);
    // We'll let the pause message box post the WM_CLOSE
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::OnBatch3
//
//  Synopsis:  IDM_BATCH3 handler: create and run two passes in non-interactive mode, 
//             without pause
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::OnBatch3(WORD /*wNotifyCode*/, WORD wID, HWND hWndCtl, BOOL& /*bHandled*/)
{
    m_bBatch = true;
    m_bSilent = true;

    // Override the log file name
    if((LPTSTR) hWndCtl)
        _tcscpy(m_szLogFileName, (LPTSTR) hWndCtl);

    PostMessage(WM_COMMAND, IDM_SUITE2, 0);
    ::PostMessage(GetParent(), WM_CLOSE, 0, 0);

    return 0;
}

////////////////////////////////////////////////////////////////////////////
// CCtlPerfView::COptionsDialog

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::COptionsDialog::COptionsDialog
//
//  Synopsis:  Constructor
//
//------------------------------------------------------------------------
CCtlPerfView::COptionsDialog::COptionsDialog(CCtlPerfView *pView)
{
    m_pView = pView;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::COptionsDialog::OnInitDialog
//
//  Synopsis:  Pre-dialog
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::COptionsDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DoDataExchange();

    // Call the base class to center
    thisClass::OnInitDialog(uMsg, wParam, lParam, bHandled);

    if(!m_pView->m_bTwoPasses)
        ::EnableWindow(GetDlgItem(IDC_EDIT_PASS2), FALSE);
    else
        ::EnableWindow(GetDlgItem(IDC_EDIT_PASS2), TRUE);
    ::SetFocus(GetDlgItem(IDC_EDIT_PASS1));
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CCtlPerfView::COptionsDialog::OnInitDialog
//
//  Synopsis:  Post-dialog
//
//------------------------------------------------------------------------
LRESULT CCtlPerfView::COptionsDialog::OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& bHandled)
{
    if(wID == IDOK)
        DoDataExchange(DDX_SAVE);

    bHandled = FALSE;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\mainfrm.h ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\Mainfrm.h
//
//  Contents:  Main frame window.
//             This file was generated by the WTL wizard. 
//
//  Classes:   CMainFrame
//
//------------------------------------------------------------------------
#pragma once

//-----------------------------------------------------------
//
// Class:       CMainFrame
//
// Synopsis:    Main application frame window.
//
//-----------------------------------------------------------
class CMainFrame 
    : public CFrameWindowImpl<CMainFrame>    // Main base class
    , public CUpdateUI<CMainFrame>            // For enabling/disabling menus
{
public:
    DECLARE_FRAME_WND_CLASS(NULL, IDR_MAINFRAME)

    BEGIN_MSG_MAP(CMainFrame)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMaxInfo)
        COMMAND_ID_HANDLER(ID_APP_EXIT, OnFileExit)
        COMMAND_ID_HANDLER(ID_VIEW_STATUS_BAR, OnViewStatusBar)
        COMMAND_ID_HANDLER(ID_APP_ABOUT, OnAppAbout)
        CHAIN_CLIENT_COMMANDS()                // We're chaining WM_COMMAND to the view (in m_hWndClient)
        CHAIN_MSG_MAP(CUpdateUI<CMainFrame>)
        CHAIN_MSG_MAP(CFrameWindowImpl<CMainFrame>)
    END_MSG_MAP()

    BEGIN_UPDATE_UI_MAP(CMainFrame)
        UPDATE_ELEMENT(ID_VIEW_STATUS_BAR, UPDUI_MENUPOPUP)
    END_UPDATE_UI_MAP()

    LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
    {
        CreateSimpleStatusBar();

        m_hWndClient = m_view.Create(m_hWnd, rcDefault, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, WS_EX_CLIENTEDGE);

        if (m_view.IsWindow())
        {
            m_view.SetStatusBar(m_hWndStatusBar);    // Communicate the status bar to the view
        }

        UISetCheck(ID_VIEW_STATUS_BAR, 1);

        return 0;
    }

    LRESULT OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        if (m_view.IsWindow())
        {
            return m_view.SendMessage(uMsg, wParam, lParam); // Forward to the view
        }

        bHandled = FALSE;
        return 1;
    }

    LRESULT OnFileExit(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        PostMessage(WM_CLOSE);
        return 0;
    }

    LRESULT OnViewStatusBar(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        BOOL bVisible = !::IsWindowVisible(m_hWndStatusBar);

        ::ShowWindow(m_hWndStatusBar, bVisible ? SW_SHOWNOACTIVATE : SW_HIDE);
        UISetCheck(ID_VIEW_STATUS_BAR, bVisible);
        UpdateLayout();
        return 0;
    }

    LRESULT OnAppAbout(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        CAboutDlg dlg;

        dlg.DoModal();
        return 0;
    }

private:
    CCtlPerfView m_view;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\ctlperfview.h ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\CtlPerfView.h
//
//  Contents:  View window, manages the client area. All the work is done there
//
//  Classes:   CCtlPerfView
//
//------------------------------------------------------------------------
#pragma once

#include "PerfLog.h"    // We have a member of this class
#include <atlddx.h>     // For Options dialog DDX

//-----------------------------------------------------------
//
// Class:       CCtlPerfView
//
// Synopsis:    View window, manages the client area.
//
//-----------------------------------------------------------
class CCtlPerfView 
    : public CWindowImpl<CCtlPerfView>
{
public:
    DECLARE_WND_CLASS(NULL)

    BEGIN_MSG_MAP(CCtlPerfView)
        MESSAGE_HANDLER(WM_SIZE, OnSize)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMaxInfo)
        COMMAND_ID_HANDLER(IDM_SUITE1, OnSuite1)
        COMMAND_ID_HANDLER(IDM_SUITE2, OnSuite2)
        COMMAND_ID_HANDLER(IDM_BATCH1, OnBatch1)
        COMMAND_ID_HANDLER(IDM_BATCH2, OnBatch2)
        COMMAND_ID_HANDLER(IDM_BATCH3, OnBatch3)
        COMMAND_ID_HANDLER(IDM_FRAME, OnFrame)
        COMMAND_RANGE_HANDLER(IDM_CONTROL, IDM_CONTROL + 99, OnControl)
    END_MSG_MAP()

//** Construction/destruction
    CCtlPerfView();
    ~CCtlPerfView();
    // Called after window destruction
    virtual void OnFinalMessage(HWND /*hWnd*/);

//** Public methods
    // Receive status bar from parent
    void SetStatusBar(HWND hWndStatusBar);
    // Test a single control class
    void TestControl(LPTSTR szClassName);
    // Destroy all child windows
    void ClearChildren();
    // Resize the controls inside the client area
    void ResizeChildren();
    // Process INI file
    void ParseIniFile();
    // Does the whole resizing timing
    void TimeResize();
    // Processes all the control classes
    void RunSuite();

//** Message handlers    
    LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
    LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
    LRESULT OnGetMinMaxInfo(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
    LRESULT OnRunBatch(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);

//** Command handlers    
    LRESULT OnControl(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
    LRESULT OnFrame(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
    LRESULT OnSuite1(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
    LRESULT OnSuite2(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
    LRESULT OnBatch1(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
    LRESULT OnBatch2(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
    LRESULT OnBatch3(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);

private:
//** Private members
    // The status bar window, in the parent frame
    HWND        m_hWndStatusBar;
    // Array of handles to the children
    HWND*       m_rgWnds;
    // Array of control class names
    LPTSTR*     m_rgzClasses;
    // Number of elements in m_rgzClasses
    UINT        m_cClasses;
    // Number of controls to create horizontally
    UINT        m_cxCtrl;
    // Number of controls to create vertically
    UINT        m_cyCtrl;
    // Number of iterations to do for each test
    UINT        m_cLoops;
    // Maximum frame window width
    UINT        m_cX;
    // Maximum frame window height
    UINT        m_cY;
    // Are we doing two passes?
    bool        m_bTwoPasses;
    // Are we in batch mode (command line)?
    bool        m_bBatch;
    // Do we have to be silent (command line)?
    bool        m_bSilent;
    // Name of pass 1
    TCHAR       m_szPass1[256];
    // Name of pass 2
    TCHAR       m_szPass2[256];
    // Name of viewer app
    TCHAR       m_szViewer[_MAX_PATH + 1];
    // Name of log file
    TCHAR       m_szLogFileName[_MAX_PATH + 1];
    // specify type of output
    TCHAR       m_szNumberOnly[10 * sizeof(TCHAR) + 1];
    // The logging object
    CPerfLog    m_perfLog;

//** Private classes
    //-----------------------------------------------------------
    //
    // Class:       COptionsDialog
    //
    // Synopsis:    Options dialog, to display/override the INI file settings.
    //
    //-----------------------------------------------------------
    class COptionsDialog
        : public CSimpleDialog<IDD_OPTIONS>            // Centers automatically
        , public CWinDataExchange<COptionsDialog>    // For DDX
    {
    public:
        explicit COptionsDialog(CCtlPerfView *pView);

        BEGIN_MSG_MAP(COptionsDialog)
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            COMMAND_RANGE_HANDLER(IDOK, IDNO, OnCloseCmd)
            CHAIN_MSG_MAP(thisClass)
        END_MSG_MAP()

        BEGIN_DDX_MAP(COptionsDialog)
            DDX_INT(IDC_EDIT_CTLX, m_pView->m_cxCtrl);
            DDX_INT(IDC_EDIT_CTLY, m_pView->m_cyCtrl);
            DDX_INT(IDC_EDIT_CX, m_pView->m_cX);
            DDX_INT(IDC_EDIT_CY, m_pView->m_cY);
            DDX_INT(IDC_EDIT_NUMLOOPS, m_pView->m_cLoops);
            DDX_TEXT(IDC_EDIT_PASS1, m_pView->m_szPass1);
            DDX_TEXT(IDC_EDIT_PASS2, m_pView->m_szPass2);
            DDX_TEXT(IDC_EDIT_LOGFILE, m_pView->m_szLogFileName);
        END_DDX_MAP()

        LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
        LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);

    private:
        CCtlPerfView* m_pView;
    };

    // Let this dialog operate directly on our memebers
    friend class COptionsDialog;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\ctlperf.cpp ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\CtlPerf.cpp
//
//  Contents:  Main source file for CtlPerf.exe
//             This file was generated by the WTL app wizard.
//
//  Classes:   None
//
//------------------------------------------------------------------------
#include "stdafx.h"

#include <atlframe.h>

#include "resource.h"

#include "CtlPerfView.h"
#include "aboutdlg.h"
#include "MainFrm.h"

CAppModule _Module;

//------------------------------------------------------------------------
//
//  Function:  Run
//
//  Synopsis:  Create main window and start message loop
//
//------------------------------------------------------------------------
int Run(LPTSTR lpstrCmdLine = NULL, int /*nCmdShow*/ = SW_SHOWDEFAULT)
{
    CMessageLoop theLoop;
    _Module.AddMessageLoop(&theLoop);

    CMainFrame wndMain;

    if(wndMain.CreateEx() == NULL)
    {
        ATLTRACE(_T("Main window creation failed!\n"));
        return 0;
    }

    wndMain.ShowWindow(SW_MAXIMIZE);

    //** Parse command line
    if (lpstrCmdLine)
    {
        ::CharLower(lpstrCmdLine);

        LPTSTR p = _tcsstr(lpstrCmdLine, _T("/l"));
        TCHAR pszLogFileName[_MAX_PATH + 1];

        if(p)   // Copy the log file name
        {
            _tcscpy(pszLogFileName, p + 2);
            p  = pszLogFileName;
            while (*p && *p != _T(' '))
            {
                p++;
            }
            if (*p)
            {
                *p = _T('\0');
            }
        }

        // We communicate by messages with the main frame (the only thing we know from here)
        //   that will forward to the view
        if (_tcsstr(lpstrCmdLine, _T("1pass")))
        {
            wndMain.PostMessage(WM_COMMAND, IDM_BATCH1, p ? (LPARAM) pszLogFileName : 0);
        }
        else if (_tcsstr(lpstrCmdLine, _T("2pass")))
        {
            if(_tcsstr(lpstrCmdLine, _T("/s")))
            {
                wndMain.PostMessage(WM_COMMAND, IDM_BATCH3, p ? (LPARAM) pszLogFileName : 0);
            }
            else
            {
                wndMain.PostMessage(WM_COMMAND, IDM_BATCH2, p ? (LPARAM) pszLogFileName : 0);
            }
        }
    }

    int nRet = theLoop.Run();

    _Module.RemoveMessageLoop();
    return nRet;
}

//------------------------------------------------------------------------
//
//  Function:  _tWinMain
//
//  Synopsis:  Main entry point
//
//------------------------------------------------------------------------
int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpstrCmdLine, int nCmdShow)
{
    HRESULT hRes = ::CoInitialize(NULL);
// If you are running on NT 4.0 or higher you can use the following call instead to 
// make the EXE free threaded. This means that calls come in on a random RPC thread.
//    HRESULT hRes = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
    ATLASSERT(SUCCEEDED(hRes));

#if (_WIN32_IE >= 0x0300)
    INITCOMMONCONTROLSEX iccx;
    iccx.dwSize = sizeof(iccx);
    //iccx.dwICC = ICC_COOL_CLASSES | ICC_BAR_CLASSES;
    iccx.dwICC = 0x3FFF;
    BOOL bRet = ::InitCommonControlsEx(&iccx);
    bRet;
    ATLASSERT(bRet);
#else
    ::InitCommonControls();
#endif

    hRes = _Module.Init(NULL, hInstance);
    ATLASSERT(SUCCEEDED(hRes));

    int nRet = Run(lpstrCmdLine, nCmdShow);

    _Module.Term();
    ::CoUninitialize();

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\perflog.h ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\PerfLog.h
//
//  Contents:  Declaration of the timing and logging class, CPerfLog
//
//  Classes:   CPerfLog
//
//------------------------------------------------------------------------
#pragma once

// Class name used as a base for the timing (its timings are removed from the others)
const TCHAR kszFrameWnd[] = _T("FrameWindow");

//-----------------------------------------------------------
//
// Class:       CPerfLog
//
// Synopsis:    Encapsulates timing and logging
//
//-----------------------------------------------------------
class CPerfLog
{
public:
//** Construction/destruction
     CPerfLog();
     ~CPerfLog();

//** Public methods
    // Initialization method when loggin one pass
    void StartLoggingOnePass(LPCTSTR szFileName, HWND hWndStatusBar, LPCTSTR szPass);
    // Initialization method when loggin two passes
    void StartLoggingTwoPasses(LPCTSTR szFileName, HWND hWndStatusBar, LPCTSTR szPass1, LPCTSTR szPass2);
    // Close and cleanup
    void StopLogging();
    // For parity, does nothing
    void StopLoggingPass1();
    // Log pass 2
    void StartLoggingPass2();
    // Close pass 2, output log and cleanup
    void StopLoggingPass2();
    // Start timing a new control class name for the following timing
    void OpenLoggingClass(LPCTSTR szClassName);
    // Finished with this class
    void CloseLoggingClass();
    // Beginning timing creation test
    void StartCreate(UINT cCtl);
    // Finished timing creation test
    void StopCreate();
    // Beginning timing painting test
    void StartPaint(UINT nTimes);
    // Finished timing painting test
    void StopPaint();
    // Beginning timing resizing  test
    void StartResize(UINT nTimes);
    // Finished timing resizing test
    void StopResize();
    // Beginning timing resizing with painting test
    void StartResizeAndPaint(UINT nTimes);
    // Finished timing resizing with painting test
    void StopResizeAndPaint();
    //  Setup the output type
    void SetOutputType(LPTSTR szNumberOnly);

private:
//** Private methods
    // Stores the data in one of the buffers
    void OutputData();
    // Stores the string in memory
    void LogString(LPCTSTR sz);

//** Private members
    // Perf counter frequency
    __int64 m_liFreq;
    // Start measurement in m_liFreq units
    __int64 m_liStart;
    // End measurement in m_liFreq units
    __int64 m_liEnd;
    // File name used for output
    TCHAR   m_szFileName[_MAX_PATH + 1];
    // Status bar to display current info
    HWND    m_hWndStatusBar;
    // Are we ready to log?
    bool    m_bLogging;
    // Handle to the log file
    FILE*   m_flLogFile;
    // Stored reference value for kszFrameWnd
    UINT    m_nFramePaintTime;
    // Stored reference value for kszFrameWnd
    UINT    m_nFrameResizeTime;
    // Stored reference value for kszFrameWnd
    UINT    m_nFrameResizeAndPaintTime;
    // Are we timing the reference frame class?
    bool    m_bFrame;
    // Are we logging two passes?
    bool    m_bTwoPasses;
    // Are we logging the first pass?
    bool    m_bFirstPass;
    // Specify type of output
    bool   m_bNumberOnly;
    // Name of first pass
    TCHAR   m_szPass1[256];
    // Name of second pass
    TCHAR   m_szPass2[256];
    // Numeric results of pass 1
    UINT*   m_rgnResults1;
    // Numeric results of pass 2
    UINT*   m_rgnResults2;
    // Strings to log
    LPTSTR* m_rgszResults;
    // Number of elements in m_rgnResults1
    UINT    m_cnResults1;
    // Number of elements in m_rgnResults2
    UINT    m_cnResults2;
    // Number of elements in m_rgszResults
    UINT    m_cszResults;
    // Buffer for composing strings before logging
    TCHAR   m_szBuf[256];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CtlPerf.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDD_OPTIONS                     202
#define IDC_EDIT_PASS1                  1000
#define IDC_EDIT_PASS2                  1001
#define IDC_EDIT_LOGFILE                1002
#define IDC_EDIT_CTLX                   1003
#define IDC_EDIT_CTLY                   1004
#define IDC_EDIT_CX                     1005
#define IDC_EDIT_CY                     1006
#define IDC_EDIT_NUMLOOPS               1007
#define IDM_SUITE1                      32772
#define IDM_CONTROL                     32773
#define IDM_FRAME                       32874
#define IDM_SUITE2                      32875
#define IDM_BATCH1                      32876
#define IDM_BATCH2                      32877
#define IDM_BATCH3                      32878

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32879
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\perflog.cpp ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\Perflog.cpp
//
//  Contents:  Implementation of the Timing and logging class.
//
//  Classes:   CPerfLog
//
//------------------------------------------------------------------------
#include "stdafx.h"
#include "PerfLog.h"

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::CPerfLog
//
//  Synopsis:  Constructor
//
//------------------------------------------------------------------------
CPerfLog::CPerfLog()
{
    ::QueryPerformanceFrequency( (LARGE_INTEGER*) &m_liFreq);
    m_szPass1[0] = _T('\0');
    m_szPass2[0] = _T('\0');
    m_bLogging = false;
    m_nFramePaintTime = 0;
    m_nFrameResizeTime = 0;
    m_nFrameResizeAndPaintTime = 0;
    m_bFrame = false;
    m_bTwoPasses = false;
    m_rgnResults1 = NULL;
    m_rgnResults2 = NULL;
    m_rgszResults = NULL;
    m_cnResults1 = 0;
    m_cnResults2 = 0;
    m_cszResults = 0;
    m_bFirstPass = true;
    m_flLogFile = NULL;
    m_bNumberOnly = false;
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::~CPerfLog
//
//  Synopsis:  Destructor
//
//------------------------------------------------------------------------
CPerfLog::~CPerfLog()
{
    StopLogging();  // Just in case the caller didn't call it
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StartLoggingOnePass
//
//  Synopsis:  Initialization method when loggin one pass
//
//  Arguments: szFileName      Name of the log file
//             hWndStatusBar   Handle to a status bar window to receive info 
//             szPass          Name of the test
//
//------------------------------------------------------------------------
void CPerfLog::StartLoggingOnePass(LPCTSTR szFileName, HWND hWndStatusBar, LPCTSTR szPass)
{
    if (m_bLogging)
    {
        StopLogging();
    }

    if (m_liFreq == 0)  // We can't do anything without it
    {
        m_bLogging = false;
        return;
    }

    if (szFileName)
    {
        _tcscpy(m_szFileName, szFileName);
    }

    if(szPass)
    {
        _tcscpy(m_szPass1, szPass);
    }

    m_flLogFile = ::_wfopen(szFileName, _T("w"));
    ATLASSERT(m_flLogFile);

    if(m_flLogFile != NULL)
    {
        m_hWndStatusBar = hWndStatusBar;
        m_nFramePaintTime = 0;
        m_nFrameResizeTime = 0;
        m_nFrameResizeAndPaintTime = 0;

        m_bLogging = true;
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StopLogging
//
//  Synopsis:  Close and cleanup
//
//------------------------------------------------------------------------
void CPerfLog::StopLogging()
{
    if (m_flLogFile && ::ftell(m_flLogFile) != -1)
    {
        ::fflush(m_flLogFile);
        ::fclose(m_flLogFile);
        m_flLogFile = NULL;
    }
    if (m_rgnResults1)
    {
        free(m_rgnResults1);
        m_rgnResults1 = NULL;
        m_cnResults1 = 0;
    }
    if (m_rgnResults2)
    {
        free(m_rgnResults2);
        m_rgnResults2 = NULL;
        m_cnResults2 = 0;
    }
    if (m_cszResults)
    {
        for (UINT i = 0; i < m_cszResults; i++)
            free(m_rgszResults[i]);
        free(m_rgszResults);
        m_rgszResults = NULL;
        m_cszResults = 0;
    }

    m_bLogging = false;
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StartLoggingTwoPasses
//
//  Synopsis:  Initialization method when loggin two passes
//
//  Arguments: szFileName      Name of the log file
//             hWndStatusBar   Handle to a status bar window to receive info 
//             szPass1         Name of the first test
//             szPass2         Name of the second test
//
//------------------------------------------------------------------------
void CPerfLog::StartLoggingTwoPasses(LPCTSTR szFileName, HWND hWndStatusBar, LPCTSTR szPass1, LPCTSTR szPass2)
{
    m_bTwoPasses = true;

    StartLoggingOnePass(szFileName, hWndStatusBar, NULL);   // Reuse main initialization (dirty)

    if (szPass1)
    {
        _tcscpy(m_szPass1, szPass1);
    }
    if (szPass2)
    {
        _tcscpy(m_szPass2, szPass2);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StopLoggingPass1
//
//  Synopsis:  For parity, does nothing
//
//------------------------------------------------------------------------
void CPerfLog::StopLoggingPass1()
{
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StartLoggingPass2
//
//  Synopsis:  Log pass 2
//
//------------------------------------------------------------------------
void CPerfLog::StartLoggingPass2()
{
    // Reset variables from pass 1
    m_nFramePaintTime = 0;
    m_nFrameResizeTime = 0;
    m_nFrameResizeAndPaintTime = 0;
    m_bFirstPass = false;
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StopLoggingPass2
//
//  Synopsis:  Close pass 2, output log and cleanup
//
//------------------------------------------------------------------------
void CPerfLog::StopLoggingPass2()
{
    UINT iResults2 = 0;
    UINT iszResults1 = 0;

    for (UINT iResults1 = 0; iResults1 < m_cnResults1; iResults1++)
    {
        if (m_rgnResults1[iResults1] == -1) // This is a string
        {
            fputws(m_rgszResults[iszResults1++], m_flLogFile);
        }
        else    // Two results to display on the same line
        {
            if (m_rgnResults1[iResults1])
            {
                // just remvoed one \t so that slow colum would line up.
                swprintf(m_szBuf, 
                    _T("%u\t\t%u\t%.2f\n"), 
                    m_rgnResults1[iResults1], 
                    m_rgnResults2[iResults2], 
                    (100.0f * float(m_rgnResults2[iResults2]) / float(m_rgnResults1[iResults1])) - 100.0f);
            }
            else
            {
                swprintf(m_szBuf, _T("%u\t\t%u\t\t0\n"), m_rgnResults1[iResults1], m_rgnResults2[iResults2]);
            }
            iResults2++;
            fputws(m_szBuf, m_flLogFile);
        }
    }
    StopLogging();
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::LogString
//
//  Synopsis:  Stores the string in memory
//
//  Arguments: sz      String to log
//
//------------------------------------------------------------------------
void CPerfLog::LogString(LPCTSTR sz)
{
    if (!m_bTwoPasses)
    {
        fputws(sz, m_flLogFile);
    }
    else if (m_bFirstPass)
    {
        m_cszResults++;
        m_rgszResults = (LPTSTR*) realloc(m_rgszResults, m_cszResults * sizeof(LPTSTR));
        m_rgszResults[m_cszResults - 1] = _wcsdup(sz);
        m_cnResults1++;
        m_rgnResults1 = (UINT*) realloc(m_rgnResults1, m_cnResults1 * sizeof(UINT));
        // Since -1 is an illegal value for the results, we use it to mark a string
        m_rgnResults1[m_cnResults1 - 1] = -1;
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::OpenLoggingClass
//
//  Synopsis:  Start timing a new control class name for the following timing
//
//  Arguments: szClassName      Name of class (for logging only)
//
//------------------------------------------------------------------------
void CPerfLog::OpenLoggingClass(LPCTSTR szClassName)
{
    if (!m_bLogging)
    {
        return;
    }

    ::SendMessage(m_hWndStatusBar, SB_SIMPLE, TRUE, 0L);
    ::SendMessage(m_hWndStatusBar, SB_SETTEXT, (255 | SBT_NOBORDERS), (LPARAM) szClassName);

    // Class header in the file
    if (m_bTwoPasses)
    {
        // added number only check
        if(m_bNumberOnly)
        {
            swprintf(m_szBuf, _T("%.12s\t%s\t%% Slower\n"), m_szPass1, m_szPass2);
        }
        else
        {
            swprintf(m_szBuf, _T("%-23s\t%.12s\t%s\t%% Slower\n"), szClassName, m_szPass1, m_szPass2);
        }
    }
    else
    {
        // added number only check
        if(m_bNumberOnly)
        {
            swprintf(m_szBuf, _T("%-23s\n"), szClassName);
        }
        else
        {
            swprintf(m_szBuf, _T("%-23s\t%s\n"), szClassName, m_szPass1);
        }
    }
    LogString(m_szBuf);

    if (!m_bFrame && !_tcsicmp(szClassName, kszFrameWnd))
    {
        m_bFrame = true;
    }
    else
    {
        m_bFrame = false;
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::CloseLoggingClass
//
//  Synopsis:  Finished with this class
//
//------------------------------------------------------------------------
void CPerfLog::CloseLoggingClass()
{
    if (!m_bLogging)
    {
        return;
    }

    LogString(_T("\n"));
    ::SendMessage(m_hWndStatusBar, SB_SETTEXT, (255 | SBT_NOBORDERS), (LPARAM) _T(""));
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StartCreate
//
//  Synopsis:  Beginning timing creation test
//
//  Arguments: cCtl      Number of controls being created (for logging)
//
//------------------------------------------------------------------------
void CPerfLog::StartCreate(UINT cCtl)
{
    if (!m_bLogging)
    {
        return;
    }
    // added number only check
    if(!m_bNumberOnly)
    {
        swprintf(m_szBuf, _T("Creation(x%d)\t\t"), cCtl);
        LogString(m_szBuf);
    }
    ::QueryPerformanceCounter( (LARGE_INTEGER*) &m_liStart);
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StopCreate
//
//  Synopsis:  Finished timing creation test
//
//------------------------------------------------------------------------
void CPerfLog::StopCreate()
{
    if (!m_bLogging)
    {
        return;
    }

    ::QueryPerformanceCounter( (LARGE_INTEGER*) &m_liEnd);
    OutputData();
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StartPaint
//
//  Synopsis:  Beginning timing painting test
//
//  Arguments: nTimes      Number of loops executed (for logging)
//
//------------------------------------------------------------------------
void CPerfLog::StartPaint(UINT nTimes)
{
    if (!m_bLogging)
    {
        return;
    }
    // added number only check
    if(!m_bNumberOnly)
    {
        swprintf(m_szBuf, _T("Paint(x%d)\t\t"), nTimes);
        LogString(m_szBuf);
    }
    ::QueryPerformanceCounter( (LARGE_INTEGER*) &m_liStart);
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StopPaint
//
//  Synopsis:  Finished timing painting test
//
//------------------------------------------------------------------------
void CPerfLog::StopPaint()
{
    if (!m_bLogging)
    {
        return;
    }

    ::QueryPerformanceCounter( (LARGE_INTEGER*) &m_liEnd);
    if (m_nFramePaintTime > 0)
    {
        m_liEnd -= m_nFramePaintTime;
    }

    OutputData();

    if (m_bFrame)
    {
        ATLASSERT(m_nFramePaintTime == 0);
        m_nFramePaintTime = UINT(m_liEnd - m_liStart);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StartResize
//
//  Synopsis:  Beginning timing resizing test
//
//  Arguments: nTimes      Number of loops executed (for logging)
//
//------------------------------------------------------------------------
void CPerfLog::StartResize(UINT nTimes)
{
    if (!m_bLogging)
    {
        return;
    }
    // added number only check
    if(!m_bNumberOnly)
    {
        swprintf(m_szBuf, _T("Resize(x%d)\t\t"), nTimes);
        LogString(m_szBuf);
    }
    ::QueryPerformanceCounter( (LARGE_INTEGER*) &m_liStart);
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StopResize
//
//  Synopsis:  Finished timing resizing test
//
//------------------------------------------------------------------------
void CPerfLog::StopResize()
{
    if (!m_bLogging)
    {
        return;
    }

    ::QueryPerformanceCounter( (LARGE_INTEGER*) &m_liEnd);
    if (m_nFrameResizeTime > 0)
    {
        m_liEnd -= m_nFrameResizeTime;
    }

    OutputData();

    if (m_bFrame)
    {
        ATLASSERT(m_nFrameResizeTime == 0);
        m_nFrameResizeTime = UINT(m_liEnd - m_liStart);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StartResizeAndPaint
//
//  Synopsis:  Beginning timing resizing with painting test
//
//  Arguments: nTimes      Number of loops executed (for logging)
//
//------------------------------------------------------------------------
void CPerfLog::StartResizeAndPaint(UINT nTimes)
{
    if (!m_bLogging)
    {
        return;
    }
    // added number only check
    if(!m_bNumberOnly)
    {
        swprintf(m_szBuf, _T("Resize and paint(x%d)\t"), nTimes);
        LogString(m_szBuf);
    }
    ::QueryPerformanceCounter( (LARGE_INTEGER*) &m_liStart);
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::StopResizeAndPaint
//
//  Synopsis:  Finished timing resizing with painting test
//
//------------------------------------------------------------------------
void CPerfLog::StopResizeAndPaint()
{
    if (!m_bLogging)
    {
        return;
    }

    ::QueryPerformanceCounter( (LARGE_INTEGER*) &m_liEnd);
    if (m_nFrameResizeAndPaintTime > 0)
    {
        m_liEnd -= m_nFrameResizeAndPaintTime;
    }

    OutputData();

    if (m_bFrame)
    {
        ATLASSERT(m_nFrameResizeAndPaintTime == 0);
        m_nFrameResizeAndPaintTime = UINT(m_liEnd - m_liStart);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::OutputData
//
//  Synopsis:  Stores the data in one of the buffers
//
//------------------------------------------------------------------------
void CPerfLog::OutputData()
{
    if (m_liEnd < m_liStart) // In case nLoops is low, it can happen
    {
        m_liEnd = m_liStart;
    }

    UINT nData = UINT((1000.0 * double(m_liEnd - m_liStart)) / double(m_liFreq));

    if (!m_bTwoPasses)
    {
        fwprintf(m_flLogFile, _T("%u\n"), nData);
    }
    else
    {
        if (m_bFirstPass)
        {
            m_cnResults1++;
            m_rgnResults1 = (UINT*) realloc(m_rgnResults1, m_cnResults1 * sizeof(UINT));
            m_rgnResults1[m_cnResults1 - 1] = nData;
        }
        else
        {
            m_cnResults2++;
            m_rgnResults2 = (UINT*) realloc(m_rgnResults2, m_cnResults2 * sizeof(UINT));
            m_rgnResults2[m_cnResults2 - 1] = nData;
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CPerfLog::SetOutputType
//
//  Synopsis:  Stores the output type (numbers only) for use later
//
//------------------------------------------------------------------------
void CPerfLog::SetOutputType(LPTSTR szNumberOnly)
{
    if(!_tcsicmp(szNumberOnly, _T("true")))
    {
        m_bNumberOnly = true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\samples.cpp ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\samples.cpp
//
//  Contents:  Sample control initialization routines, taken from ThemeSel by RFernand.
//             Add new control initialization data here.
//
//  Classes:   None
//
//------------------------------------------------------------------------
#include "stdafx.h"
#include "samples.h"

//** shared sample data

static WCHAR *Names[] = {L"One", L"Two", L"Three", L"Four", L"Five", L"Six",
    L"Seven", L"Eight", L"Nine", L"Ten", L"Eleven", L"Twelve", 
    L"Thirteen", L"Fourteen", L"Fifteen", L"Sixteen"};

static WCHAR *Buttons[] = {L"New", L"Open", L"Save", L"Cut",  L"Copy", L"Delete", 
    L"Undo", L"Redo", L"Print", L"Help\0"};

static int ButtonIndexes[] = {STD_FILENEW, STD_FILEOPEN, STD_FILESAVE, 
    STD_CUT, STD_COPY, STD_DELETE, STD_UNDO, STD_REDOW, STD_PRINT, STD_HELP};

static WCHAR *Columns[] = {L"Name", L"Phone", L"City", L"State"};

static WCHAR *Col1Items[] = {L"Chris", L"Lou", L"Richard", L"Mark", L"Roland", L"Paul",
    L"Scott", L"Aaron", L"Greg", L"Ken"};

static WCHAR *Col2Items[] = {L"555-1212", L"567-3434", L"656-4432", L"343-7788", L"706-0225", L"828-3043",
    L"706-4433", L"882-8080", L"334-3434", L"333-5430"};

static WCHAR *Col3Items[] = {L"Seattle", L"Redmond", L"Bellevue", L"Seattle", L"Woodinville", L"Kirkland",
    L"Kirkland", L"Woodinville", L"Redmond", L"Redmond"};

//-------------------------------------------------------------------------//
// Tab control
//-------------------------------------------------------------------------//
void Pickers_Init(HWND hWndCtl)
{
    TCITEM item;
    item.mask = TCIF_TEXT;

    for (int i=0; i < 4; i++)
    {
        item.pszText = Names[i];
        SendMessage(hWndCtl, TCM_INSERTITEM, i, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
// Progress bar
//-------------------------------------------------------------------------//
void Movers_Init(HWND hWndCtl)
{
    SendMessage(hWndCtl, PBM_SETRANGE, 0, MAKELPARAM(0, 100));

    SendMessage(hWndCtl, PBM_SETPOS, 50, 0);
}

//-------------------------------------------------------------------------//
// Listbox
//-------------------------------------------------------------------------//
void Lists_Init(HWND hWndCtl)
{
    SendMessage(hWndCtl, LB_RESETCONTENT, 0, 0);
    for (int j=0; j < _countof(Names); j++)
        SendMessage(hWndCtl, LB_ADDSTRING, 0, (LPARAM)Names[j]);
    SendMessage(hWndCtl, LB_SETCURSEL, 0, 0);
}

//-------------------------------------------------------------------------//
// Combo box
//-------------------------------------------------------------------------//
void Combo_Init(HWND hWndCtl)
{
    SendMessage(hWndCtl, CB_RESETCONTENT, 0, 0);

    for (int j=0; j < _countof(Names); j++)
        SendMessage(hWndCtl, CB_ADDSTRING, 0, (LPARAM)Names[j]);

    SendMessage(hWndCtl, CB_SETCURSEL, 0, 0);
}

//-------------------------------------------------------------------------//
// ComboBoxEx
//-------------------------------------------------------------------------//
void ComboEx_Init(HWND hWndCtl)
{
    COMBOBOXEXITEM exitem;
    exitem.mask = CBEIF_TEXT ;

    SendMessage(hWndCtl, CB_RESETCONTENT, 0, 0);

    for (int j=0; j < _countof(Names); j++)
    {
        exitem.iItem = j;
        exitem.pszText = Names[j];
        SendMessage(hWndCtl, CBEM_INSERTITEM, 0, (LPARAM)&exitem);
    }

    SendMessage(hWndCtl, CB_SETCURSEL, 0, 0);
}

//-------------------------------------------------------------------------//
// ListView
//-------------------------------------------------------------------------//
void ListView_Init(HWND hWndCtl)
{
    //---- initialize the colums ----
    LVCOLUMN lvc; 
    memset(&lvc, 0, sizeof(lvc));
 
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH; 
    lvc.fmt = LVCFMT_LEFT; 
    lvc.cx = 100; 
 
    // Add the columns. 
    for (int c=0; c < _countof(Columns); c++)
    {
        lvc.iSubItem = c;
        lvc.pszText = Columns[c];
        SendMessage(hWndCtl, LVM_INSERTCOLUMN, c, (LPARAM)&lvc);
    } 

    //---- initialize the items ----
    LVITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = LVIF_TEXT;

    //---- add the items ----
    for (int i=0; i < _countof(Col1Items); i++)  
    {
        item.pszText = Col1Items[i];
        item.iItem = i;
        item.iSubItem = 0;
        SendMessage(hWndCtl, LVM_INSERTITEM, 0, (LPARAM)&item);

        item.iSubItem = 1;
        item.pszText = Col2Items[i];
        SendMessage(hWndCtl, LVM_SETITEM, 0, (LPARAM)&item);

        item.iSubItem = 2;
        item.pszText = Col3Items[i];
        SendMessage(hWndCtl, LVM_SETITEM, 0, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
// Treeview
//-------------------------------------------------------------------------//
void TreeView_Init(HWND hWndCtl)
{
    //---- initialize the item ----
    TVINSERTSTRUCT tvs;
    memset(&tvs, 0, sizeof(tvs));
    tvs.itemex.mask = TVIF_TEXT;
    tvs.hInsertAfter = TVI_LAST;    

    tvs.itemex.pszText = L"Root";
    HTREEITEM hRoot = (HTREEITEM) SendMessage(hWndCtl, TVM_INSERTITEM, 0, (LPARAM)&tvs);

    //---- add the items ----
    for (int i=0; i < _countof(Col1Items); i++)  
    {
        tvs.itemex.pszText = Col1Items[i];
        tvs.hParent = hRoot;
        HTREEITEM hItem = (HTREEITEM) SendMessage(hWndCtl, TVM_INSERTITEM, 0, (LPARAM)&tvs);

        if (hItem)
        {
            TVINSERTSTRUCT tvchild;
            memset(&tvchild, 0, sizeof(tvchild));
            tvchild.itemex.mask = TVIF_TEXT;
            tvchild.hInsertAfter = TVI_LAST;    
            tvchild.hParent = hItem;

            tvchild.itemex.pszText = Col2Items[i];
            SendMessage(hWndCtl, TVM_INSERTITEM, 0, (LPARAM)&tvchild);

            tvchild.itemex.pszText = Col3Items[i];
            SendMessage(hWndCtl, TVM_INSERTITEM, 0, (LPARAM)&tvchild);
        }
    }
}

//-------------------------------------------------------------------------//
// Header
//-------------------------------------------------------------------------//
void Header_Init(HWND hWndCtl)
{
    //---- initialize the item ----
    HDITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = HDI_WIDTH | HDI_TEXT;
    item.cxy = 60;

    //---- add the items ----
    for (int i=0; i < _countof(Columns); i++)  
    {
        item.pszText = Columns[i];
        HTREEITEM hItem = (HTREEITEM) SendMessage(hWndCtl, HDM_INSERTITEM, i, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
// Status bar
//-------------------------------------------------------------------------//
void Status_Init(HWND hWndCtl)
{
    //---- setup the different sections ----
    int Widths[] = {200, 400, 600};
    SendMessage(hWndCtl, SB_SETPARTS, _countof(Widths), (LPARAM)Widths);

    //---- write some text ----
    SendMessage(hWndCtl, SB_SETTEXT, 0, (LPARAM)L"First Section");
    SendMessage(hWndCtl, SB_SETTEXT, 1, (LPARAM)L"Second Section");
    SendMessage(hWndCtl, SB_SETTEXT, 2, (LPARAM)L"Third Section");
}

//-------------------------------------------------------------------------//
// Toolbar
//-------------------------------------------------------------------------//
void Toolbar_Init(HWND hWndCtl)
{
    //---- send require toolbar init msg ----
    SendMessage(hWndCtl, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0); 

    //---- setup the bitmap images for buttons ----
    TBADDBITMAP abm = {HINST_COMMCTRL, IDB_STD_LARGE_COLOR};
    SendMessage(hWndCtl, TB_ADDBITMAP, 15, (LPARAM)&abm);

    TBBUTTON button;
    memset(&button, 0, sizeof(button));
    button.fsState = TBSTATE_ENABLED; 
    
    //int index = (int)SendMessage(hwnd, TB_ADDSTRING, NULL, (LPARAM)Buttons);

    int cnt = min(10, _countof(Buttons));

    for (int i=0; i < cnt; i++)
    {
        button.fsStyle = TBSTYLE_BUTTON; 
        button.iBitmap = ButtonIndexes[i];
        button.idCommand = i;
        button.iString = 0; // index + i;
        SendMessage(hWndCtl, TB_ADDBUTTONS, 1, LPARAM(&button));

        if ((i == 2) || (i == 5) || (i == 7) || (i == 9))
        {
            button.fsStyle = BTNS_SEP;
            SendMessage(hWndCtl, TB_ADDBUTTONS, 1, LPARAM(&button));
        }
    }

    SendMessage(hWndCtl, TB_AUTOSIZE, 0, 0); 
    ShowWindow(hWndCtl, SW_SHOW); 
}

//-------------------------------------------------------------------------//
// Rebar
//-------------------------------------------------------------------------//
void Rebar_Init(HWND hWndCtl)
{
   //---- initialize the rebar ----
   REBARINFO rbi;
   rbi.cbSize = sizeof(rbi); 
   rbi.fMask  = 0;
   rbi.himl   = (HIMAGELIST)NULL;
   SendMessage(hWndCtl, RB_SETBARINFO, 0, (LPARAM)&rbi);
   
   //---- initialize the band ----
   REBARBANDINFO rbBand;   
   rbBand.cbSize = sizeof(REBARBANDINFO);  
   rbBand.fMask  = RBBIM_TEXT | RBBIM_STYLE | RBBIM_CHILD  | RBBIM_CHILDSIZE | RBBIM_SIZE;
   rbBand.fStyle = RBBS_GRIPPERALWAYS | RBBS_BREAK;
   // rbBand.hbmBack= LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BACKGROUND));   
   
   RECT rc;
   HWND hwndCB, hwndTB;

   // Create the combo box control to be added.
   hwndCB = CreateWindowEx(0, L"Combobox", L"Combo Text", WS_VISIBLE | WS_CHILD | WS_BORDER,
       0, 0, 100, 30, hWndCtl, (HMENU)51, _Module.GetModuleInstance(), 0);
   
   // Set values unique to the band with the combo box.
   GetWindowRect(hwndCB, &rc);
   rbBand.lpText     = L"Combo Box";
   rbBand.hwndChild  = hwndCB;
   rbBand.cxMinChild = 20;
   rbBand.cyMinChild = rc.bottom - rc.top;
   rbBand.cx         = 120; // WIDTH(rc) + 20;

   // Add the band that has the combo box.
   LRESULT val = SendMessage(hWndCtl, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);

#if 1
   // Create the toolbar control to be added.
   hwndTB = CreateWindowEx(0, L"SysToolBar32", L"", WS_VISIBLE | WS_CHILD | WS_BORDER,
       0, 0, 500, 30, hWndCtl, (HMENU)52, _Module.GetModuleInstance(), 0);
   Toolbar_Init(hwndTB);

   // Set values unique to the band with the toolbar.
   rbBand.lpText     = L"Tool Bar";
   rbBand.hwndChild  = hwndTB;
   rbBand.cxMinChild = 20;

   DWORD dwBtnSize = (DWORD) SendMessage(hwndTB, TB_GETBUTTONSIZE, 0,0);
   rbBand.cyMinChild = HIWORD(dwBtnSize);
   
   GetWindowRect(hwndTB, &rc);
   rbBand.cx         = 450;     // WIDTH(rc) + 20;

   // Add the band that has the toolbar.
   val = SendMessage(hWndCtl, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\samples.h ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\samples.h
//
//  Contents:  Declaration of sample control initialization routines, 
//             taken from ThemeSel by RFernand.
//
//  Classes:   none
//
//------------------------------------------------------------------------
#pragma once

// Type for variable declarations
typedef void (*PFNINIT)(HWND);

// Tab control
extern void Pickers_Init(HWND hWndCtl);
// Progress bar
extern void Movers_Init(HWND hWndCtl);
// Listbox
extern void Lists_Init(HWND hWndCtl);
// Combo box
extern void Combo_Init(HWND hWndCtl);
// ComboBoxEx
extern void ComboEx_Init(HWND hWndCtl);
// ListView
extern void ListView_Init(HWND hWndCtl);
// Treeview
extern void TreeView_Init(HWND hWndCtl);
// Header
extern void Header_Init(HWND hWndCtl);
// Status bar
extern void Status_Init(HWND hWndCtl);
// Toolbar
extern void Toolbar_Init(HWND hWndCtl);
// Rebar
extern void Rebar_Init(HWND hWndCtl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\stdafx.h ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\stdafx.h
//
//  Contents:  include file for standard system include files,
//             or project specific include files that are used frequently, 
//             but are changed infrequently
//
//  Classes:   none
//
//------------------------------------------------------------------------
#pragma once

// Change these values to use different versions
/*#ifndef WINVER
#define WINVER        0x0500
#endif*/
#ifndef _WIN32_IE
#define _WIN32_IE    0x0500
#endif
#define _RICHEDIT_VER    0x0300

#include <w4warn.h>

#if defined(_IA64_)
    // Cheating to avoid having to change WTL
    #pragma warning(disable:4311) // 'type cast' : pointer truncation from 'HMENU' to 'UINT'
#endif

#include <atlbase.h>
#include <atlapp.h>

extern CAppModule _Module;

#include <atlwin.h>
#include <stdio.h>

//** Macros
#ifndef _countof
    #define _countof(array)    (sizeof(array)/sizeof(array[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\framemetrics\framemetrics.h ===
#if !defined(AFX_FRAMEMETRICS_H__6D34743C_A484_4A6D_81C2_51C1C34333BF__INCLUDED_)
#define AFX_FRAMEMETRICS_H__6D34743C_A484_4A6D_81C2_51C1C34333BF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_FRAMEMETRICS_H__6D34743C_A484_4A6D_81C2_51C1C34333BF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ctlperf\stdafx.cpp ===
//------------------------------------------------------------------------
//
//  File:      shell\themes\test\ctlperf\stdafx.cpp
//
//  Contents:  Source file that includes just the standard includes
//               CtlPerf.pch will be the pre-compiled header
//             stdafx.obj will contain the pre-compiled type information
//
//  Classes:   None
//
//------------------------------------------------------------------------
#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\framemetrics\framemetrics.cpp ===
// FrameMetrics.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text

enum {
    NCCAPTION,
    NCBORDERS,
    NCMENUBAR,
    NCSCROLLBARS,
    NCCLOSEBUTTON,
    NCMAXBUTTON,
    NCMINBUTTON,
    NCHELPBUTTON,
    NCSYSICON,
    _cNCXXX,
};

BOOL       _rgf[_cNCXXX] = {FALSE};
HBRUSH    _rghbr[_cNCXXX] = {0};
COLORREF  _rgrgb[_cNCXXX] = { 
    RGB(255,0,255),
    RGB(0,255,255),
    RGB(255,255,0),
    RGB(0,0,255),
    RGB(0,255,255),
    RGB(0,255,255),
    RGB(0,255,255),
    RGB(0,255,255),
    RGB(0,255,255),
};

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_FRAMEMETRICS, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

    for( int i=0; i<ARRAYSIZE(_rghbr); i++ )
    {
        _rghbr[i] = CreateSolidBrush(_rgrgb[i]);
    }

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_FRAMEMETRICS);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

    for( i=0; i<ARRAYSIZE(_rghbr); i++ )
    {
        DeleteObject(_rghbr[i]);
    }

	return msg.wParam;
}



//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_FRAMEMETRICS);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCTSTR)IDC_FRAMEMETRICS;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hwnd;

   hInst = hInstance; // Store instance handle in our global variable

   hwnd = CreateWindowEx( WS_EX_CONTEXTHELP, szWindowClass, szTitle, WS_OVERLAPPEDWINDOW|WS_HSCROLL|WS_VSCROLL,
                        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

   if (!hwnd)
   {
      return FALSE;
   }

   ShowWindow(hwnd, nCmdShow);
   UpdateWindow(hwnd);

   return TRUE;
}

//-------------------------------------------------------------------------//
//
//  GetWindowBorders()  - port from win32k, rtl\winmgr.c
//
//  Computes window border dimensions based on style bits.
//
int _GetWindowBorders(LONG lStyle, DWORD dwExStyle )
{
    int cBorders = 0;

    //
    // Is there a 3D border around the window?
    //
    if( TESTFLAG(dwExStyle, WS_EX_WINDOWEDGE) )
        cBorders += 2;
    else if ( TESTFLAG(dwExStyle, WS_EX_STATICEDGE) )
        ++cBorders;

    //
    // Is there a single flat border around the window?  This is true for
    // WS_BORDER, WS_DLGFRAME, and WS_EX_DLGMODALFRAME windows.
    //
    if( TESTFLAG(lStyle, WS_CAPTION) || TESTFLAG(dwExStyle, WS_EX_DLGMODALFRAME) )
        ++cBorders;

    //
    // Is there a sizing flat border around the window?
    //
    if( TESTFLAG(lStyle, WS_THICKFRAME) )
	{
		NONCLIENTMETRICS ncm;  ncm.cbSize = sizeof(ncm);
		if( SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE ) )
			cBorders += ncm.iBorderWidth;
		else
			cBorders += GetSystemMetrics( SM_CXBORDER );
	}

    return(cBorders);
}

BOOL NcPaint(HWND hwnd, HRGN hrgnUpdate)
{
    BOOL fRet = FALSE;
    int  cPaint = 0;

    for( int i = 0; i < ARRAYSIZE(_rgf); i++ )
    {
        if( _rgf[i] )
            cPaint++;
    }
    if( 0 == cPaint )
        return FALSE;

    // private GetDCEx #defines from user
    #define DCX_USESTYLE         0x00010000L
    #define DCX_NODELETERGN      0x00040000L

    HDC hdc = (hrgnUpdate != NULL) ? 
                GetDCEx( hwnd, hrgnUpdate, DCX_USESTYLE|DCX_WINDOW|DCX_LOCKWINDOWUPDATE|
                                        DCX_INTERSECTRGN|DCX_NODELETERGN ) :
                GetDCEx( hwnd, NULL, DCX_USESTYLE|DCX_WINDOW|DCX_LOCKWINDOWUPDATE );

    if( hdc )
    {
        WINDOWINFO wi;
        wi.cbSize = sizeof(wi);
        const RECT rcNil = {0};
        if( GetWindowInfo(hwnd, &wi) )
        {
            NONCLIENTMETRICS ncm;
            ncm.cbSize = sizeof(ncm);
            SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE );
            
            int cxEdge    = GetSystemMetrics( SM_CXEDGE );
            int cyEdge    = GetSystemMetrics( SM_CYEDGE );
            int cxBtn     = GetSystemMetrics( SM_CXSIZE );
            int cyBtn     = GetSystemMetrics( SM_CYSIZE );
            int cyCaption = GetSystemMetrics( SM_CYCAPTION );
            int cyMenu    = GetSystemMetrics( SM_CYMENU );
            int cnBorders = _GetWindowBorders( wi.dwStyle, wi.dwExStyle );

            RECT rcWnd, rcCaption, rcMenuBar, rcHscroll, rcVscroll, rcSys;
        
            rcWnd = wi.rcWindow;
            OffsetRect( &rcWnd, -wi.rcWindow.left, -wi.rcWindow.top );
            rcCaption = rcMenuBar = rcWnd;
            rcHscroll = rcVscroll = rcNil;

            rcCaption.bottom = rcCaption.top + ncm.iCaptionHeight ;
            rcMenuBar.bottom = rcMenuBar.top + cyMenu;

            OffsetRect( &rcCaption, 0, cnBorders );
            OffsetRect( &rcMenuBar, 0, rcCaption.top + cyCaption );

            rcCaption.left += cnBorders;
            rcMenuBar.left += cnBorders;

            rcCaption.right -= cnBorders;
            rcMenuBar.right -= cnBorders;

            if( TESTFLAG(wi.dwStyle, WS_HSCROLL) )
            {
                rcHscroll = rcWnd;
                rcHscroll.top = rcHscroll.bottom - GetSystemMetrics(SM_CYHSCROLL);
                OffsetRect( &rcHscroll, 0, -cnBorders );
                rcHscroll.left  += cnBorders;
                rcHscroll.right -= (cnBorders + (TESTFLAG(wi.dwStyle, WS_VSCROLL) ? GetSystemMetrics(SM_CXVSCROLL) : 0));
            }

            if( TESTFLAG(wi.dwStyle, WS_VSCROLL) )
            {
                rcVscroll = rcWnd;
                rcVscroll.left = rcVscroll.right - GetSystemMetrics(SM_CXVSCROLL);
                OffsetRect( &rcVscroll, -cnBorders, 0 );
                rcVscroll.top = rcMenuBar.bottom;
                rcVscroll.bottom -= (cnBorders + (TESTFLAG(wi.dwStyle, WS_HSCROLL) ? GetSystemMetrics(SM_CYHSCROLL) : 0));
            }

            //  buttons
            RECT rcClose, rcMin, rcMax, rcHelp;

            rcClose.top = rcMin.top = rcMax.top = rcHelp.top = rcCaption.top;
            rcClose.bottom = rcMin.bottom = rcMax.bottom = rcHelp.bottom = rcCaption.top + (cyBtn - (cyEdge * 2));

            rcSys.top = rcCaption.top;
            rcSys.bottom = rcSys.top + GetSystemMetrics(SM_CYSMICON);
            rcSys.left = rcCaption.left + cxEdge; rcSys.right = rcSys.left + GetSystemMetrics(SM_CXSMICON);

            rcClose.right = rcCaption.right - cxEdge; rcClose.left = rcClose.right - (cxBtn - cxEdge);
            rcMax.right = rcClose.left  - cxEdge; rcMax.left =  rcMax.right - (cxBtn - cxEdge);
            rcMin.right = rcMax.left; rcMin.left =  rcMin.right - (cxBtn - cxEdge);
            
            rcHelp = rcMax;

            // vertically center
            OffsetRect( &rcSys, 0,   (ncm.iCaptionHeight - RECTHEIGHT(&rcSys))/2 );
            OffsetRect( &rcClose, 0, (ncm.iCaptionHeight - RECTHEIGHT(&rcClose))/2 );
            OffsetRect( &rcMax, 0,   (ncm.iCaptionHeight - RECTHEIGHT(&rcMax))/2 );
            OffsetRect( &rcMin, 0,   (ncm.iCaptionHeight - RECTHEIGHT(&rcMin))/2 );
            OffsetRect( &rcHelp, 0,  (ncm.iCaptionHeight - RECTHEIGHT(&rcHelp))/2 );

            DefWindowProc( hwnd, WM_NCPAINT, (WPARAM)hrgnUpdate, 0L );

GdiSetBatchLimit(1);
            if( _rgf[NCCAPTION] )
            {
                FillRect( hdc, &rcCaption, _rghbr[NCCAPTION] );
            }

            if( _rgf[NCMENUBAR] )
            {
                FillRect( hdc, &rcMenuBar, _rghbr[NCMENUBAR] );
            }

            if( _rgf[NCSCROLLBARS] )
            {
                FillRect( hdc, &rcHscroll, _rghbr[NCSCROLLBARS] );
                FillRect( hdc, &rcVscroll, _rghbr[NCSCROLLBARS] );
            }

            if( _rgf[NCBORDERS] )
            {
                RECT rcBorders = rcWnd;
                for( int i=0; i<cnBorders; i++ )
                {
                    FrameRect( hdc, &rcBorders, _rghbr[NCBORDERS] );
                    GetLastError();
                    InflateRect( &rcBorders, -1, -1 );
                }
            }

            if( _rgf[NCCLOSEBUTTON] )
                FillRect( hdc, &rcClose, _rghbr[NCCLOSEBUTTON] );

            if( _rgf[NCMAXBUTTON] && TESTFLAG(wi.dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX) )
                FillRect( hdc, &rcMax,   _rghbr[NCMAXBUTTON] );

            if( _rgf[NCMINBUTTON] && TESTFLAG(wi.dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX) )
                FillRect( hdc, &rcMin,   _rghbr[NCMINBUTTON] );

            if( _rgf[NCHELPBUTTON] && !TESTFLAG(wi.dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX) )
                FillRect( hdc, &rcHelp,  _rghbr[NCHELPBUTTON] );

            if( _rgf[NCSYSICON] && TESTFLAG(wi.dwStyle, WS_SYSMENU) )
                FillRect( hdc, &rcSys,  _rghbr[NCSYSICON] );

GdiSetBatchLimit(0) ;          
            ReleaseDC( hwnd, hdc );

            fRet = TRUE;
        }
    }

    return fRet;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lRet = 0;
    int wmId, wmEvent;

	switch (message) 
	{
		case WM_COMMAND:
        {
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
            BOOL fSwp = FALSE;
			// Parse the menu selections:
			switch (wmId)
			{
                #define IMPLEMENT_NCCOMMANDID(cmd) \
                    case ID_##cmd: _rgf[NC##cmd] = !_rgf[NC##cmd]; fSwp = TRUE; break;

                IMPLEMENT_NCCOMMANDID(CAPTION)
                IMPLEMENT_NCCOMMANDID(MENUBAR)
                IMPLEMENT_NCCOMMANDID(BORDERS)
                IMPLEMENT_NCCOMMANDID(SCROLLBARS)
                IMPLEMENT_NCCOMMANDID(CLOSEBUTTON)
                IMPLEMENT_NCCOMMANDID(MAXBUTTON)
                IMPLEMENT_NCCOMMANDID(MINBUTTON)
                IMPLEMENT_NCCOMMANDID(HELPBUTTON)
                IMPLEMENT_NCCOMMANDID(SYSICON)

                case ID_NONE:
                case ID_ALL:
                    for( int i = 0; i<ARRAYSIZE(_rgf); i++ )
                    {
                        _rgf[i] = wmId == ID_ALL;
                    }
                    fSwp = TRUE;
                    break;

                case ID_THICKFRAME:
                {
                    DWORD dwStyle = GetWindowLong( hwnd, GWL_STYLE );
                    if( TESTFLAG( dwStyle, WS_THICKFRAME ) )
                        dwStyle &= ~WS_THICKFRAME;
                    else
                        dwStyle |= WS_THICKFRAME;

                    SetWindowLong( hwnd, GWL_STYLE, dwStyle );
                    fSwp = TRUE;
                    break;
                }

                case ID_MINMAX:
                {
                    DWORD dwStyle = GetWindowLong( hwnd, GWL_STYLE );
                    if( TESTFLAG( dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX ) )
                        dwStyle &= ~(WS_MINIMIZEBOX|WS_MAXIMIZEBOX);
                    else
                        dwStyle |= (WS_MINIMIZEBOX|WS_MAXIMIZEBOX);

                    SetWindowLong( hwnd, GWL_STYLE, dwStyle );
                    fSwp = TRUE;
                    break;
                }

				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hwnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hwnd);
				   break;
				default:
				   return DefWindowProc(hwnd, message, wParam, lParam);
			}
            if( fSwp )
                SetWindowPos( hwnd, NULL, 0,0,0,0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER|SWP_DRAWFRAME );
			break;
        }
        
        case WM_NCPAINT:
            if( !NcPaint(hwnd, (HRGN)wParam) )
                lRet = DefWindowProc( hwnd, message, wParam, lParam );
            break;

        case WM_NCACTIVATE:
            lRet = DefWindowProc( hwnd, message, wParam, lParam );
            NcPaint(hwnd, NULL);
            break;

        case WM_INITMENUPOPUP:
        {
            CheckMenuItem( (HMENU)wParam, ID_CAPTION, MF_BYCOMMAND | (_rgf[NCCAPTION] ? MF_CHECKED : MF_UNCHECKED) );
            CheckMenuItem( (HMENU)wParam, ID_MENUBAR, MF_BYCOMMAND | (_rgf[NCMENUBAR] ? MF_CHECKED : MF_UNCHECKED) );
            CheckMenuItem( (HMENU)wParam, ID_BORDERS, MF_BYCOMMAND | (_rgf[NCBORDERS] ? MF_CHECKED : MF_UNCHECKED) );
            CheckMenuItem( (HMENU)wParam, ID_SCROLLBARS, MF_BYCOMMAND | (_rgf[NCSCROLLBARS] ? MF_CHECKED : MF_UNCHECKED) );

            CheckMenuItem( (HMENU)wParam, ID_CLOSEBUTTON, MF_BYCOMMAND | (_rgf[NCCLOSEBUTTON] ? MF_CHECKED : MF_UNCHECKED) );
            CheckMenuItem( (HMENU)wParam, ID_MAXBUTTON,   MF_BYCOMMAND | (_rgf[NCMAXBUTTON] ? MF_CHECKED : MF_UNCHECKED) );
            CheckMenuItem( (HMENU)wParam, ID_MINBUTTON,   MF_BYCOMMAND | (_rgf[NCMINBUTTON] ? MF_CHECKED : MF_UNCHECKED) );
            CheckMenuItem( (HMENU)wParam, ID_HELPBUTTON,  MF_BYCOMMAND | (_rgf[NCHELPBUTTON] ? MF_CHECKED : MF_UNCHECKED) );
            CheckMenuItem( (HMENU)wParam, ID_SYSICON,     MF_BYCOMMAND | (_rgf[NCSYSICON] ? MF_CHECKED : MF_UNCHECKED) );

            ULONG dwStyle = GetWindowLong(hwnd, GWL_STYLE);
            CheckMenuItem( (HMENU)wParam, ID_THICKFRAME, MF_BYCOMMAND | (TESTFLAG(dwStyle, WS_THICKFRAME) ? MF_CHECKED : MF_UNCHECKED) );
            CheckMenuItem( (HMENU)wParam, ID_MINMAX, MF_BYCOMMAND | (TESTFLAG(dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX) ? MF_CHECKED : MF_UNCHECKED) );
            break;
        }
            

		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hwnd, message, wParam, lParam);
   }
   return lRet;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\drawedge\drawedge.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************************************************************

        PROGRAM: Generic.c

        PURPOSE: Generic template for Windows applications

        FUNCTIONS:

        WinMain() - calls initialization function, processes message loop
        InitApplication() - initializes window data and registers window
        InitInstance() - saves instance handle and creates main window
        WndProc() - processes messages
        CenterWindow() - used to center the "About" box over application window
        About() - processes messages for "About" dialog box

        COMMENTS:

                The Windows SDK Generic Application Example is a sample application
                that you can use to get an idea of how to perform some of the simple
                functionality that all Applications written for Microsoft Windows
                should implement. You can use this application as either a starting
                point from which to build your own applications, or for quickly
                testing out functionality of an interesting Windows API.

                This application is source compatible for with Windows 3.1 and
                Windows NT.

****************************************************************************/

#include <windows.h>   // required for all Windows applications
#include "UxTheme.h"
#include "tmschema.h"
#include "resource.h"   // specific to this program

#define countof(x) (sizeof(x) / sizeof(x[0]))

HINSTANCE hInst;          // current instance
HWND ghWnd;
HTHEME ghTheme;
HTHEME ghThemeTB;

/****************************************************************************/

BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);  
LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM);

/****************************************************************************/
                                                   
DWORD GetLastErrorBox(HWND hWnd, LPTSTR lpTitle)
{
   LPVOID lpv;
   DWORD  dwRv;

   if (GetLastError() == 0) return 0;
   dwRv = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        GetLastError(),
                        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                        (LPVOID)&lpv,
                        0,
                        NULL);
   MessageBox(hWnd, lpv, lpTitle, MB_OK);
   if(dwRv)
      LocalFree(lpv);
   return dwRv;
}

/****************************************************************************

        FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPTSTR, int)

        PURPOSE: calls initialization function, processes message loop

        COMMENTS:

                Windows recognizes this function by name as the initial entry point
                for the program.  This function calls the application initialization
                routine, if no other instance of the program is running, and always
                calls the instance initialization routine.  It then executes a message
                retrieval and dispatch loop that is the top-level control structure
                for the remainder of execution.  The loop is terminated when a WM_QUIT
                message is received, at which time this function exits the application
                instance by returning the value passed by PostQuitMessage().

                If this function must abort before entering the message loop, it
                returns the conventional value NULL.

****************************************************************************/
int APIENTRY WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
{

        MSG msg;
        HANDLE hAccelTable;
		
        if (!hPrevInstance)       // Other instances of app running?
          if (!InitApplication(hInstance)) // Initialize shared things
             return (FALSE);     // Exits if unable to initialize

        /* Perform initializations that apply to a specific instance */

        if (!InitInstance(hInstance, nCmdShow)) 
          return (FALSE);

        hAccelTable = LoadAccelerators (hInstance, L"DEACCEL");
										
        /* Acquire and dispatch messages until a WM_QUIT message is received. */
        while (GetMessage(&msg, // message structure
           NULL,   // handle of window receiving the message
           0,      // lowest message to examine
           0))     // highest message to examine
        {
            if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg)) {
                TranslateMessage(&msg);// Translates virtual key codes
                DispatchMessage(&msg); // Dispatches message to window
            }
        }

		DestroyAcceleratorTable(hAccelTable);

        if (ghTheme)
            CloseThemeData(ghTheme);
        if (ghThemeTB)
            CloseThemeData(ghThemeTB);

        return (msg.wParam); // Returns the value from PostQuitMessage

        lpCmdLine; // This will prevent 'unused formal parameter' warnings
}


/****************************************************************************

        FUNCTION: InitApplication(HINSTANCE)

        PURPOSE: Initializes window data and registers window class

        COMMENTS:

                This function is called at initialization time only if no other
                instances of the application are running.  This function performs
                initialization tasks that can be done once for any number of running
                instances.

                In this case, we initialize a window class by filling out a data
                structure of type WNDCLASS and calling the Windows RegisterClass()
                function.  Since all instances of this application use the same window
                class, we only need to do this when the first instance is initialized.


****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
        WNDCLASS  wc;

        // Fill in window class structure with parameters that describe the
        // main window.

        wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
        wc.lpfnWndProc   = (WNDPROC)WndProc;       // Window Procedure
        wc.cbClsExtra    = 0;                      // No per-class extra data.
        wc.cbWndExtra    = 0;                      // No per-window extra data.
        wc.hInstance     = hInstance;              // Owner of this class
        wc.hIcon         = LoadIcon (hInstance, L"DEICON"); // Icon name from .RC
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);// Cursor
        wc.hbrBackground = GetStockObject(WHITE_BRUSH); // Default color
        wc.lpszMenuName  = L"DEMENU";                // Menu name from .RC
        wc.lpszClassName = L"DrawEdgeClass";         // Name to register as

		// Register the window class and return success/failure code.
        return (RegisterClass(&wc));
}


/****************************************************************************

        FUNCTION:  InitInstance(HINSTANCE, int)

        PURPOSE:  Saves instance handle and creates main window

        COMMENTS:

                This function is called at initialization time for every instance of
                this application.  This function performs initialization tasks that
                cannot be shared by multiple instances.

                In this case, we save the instance handle in a static variable and
                create and display the main program window.

****************************************************************************/

BOOL InitInstance(
        HINSTANCE          hInstance,
        int             nCmdShow)
{
        // Save the instance handle in static variable, which will be used in
        // many subsequence calls from this application to Windows.

        hInst = hInstance; // Store instance handle in our global variable

        // Create a main window for this application instance.

        ghWnd = CreateWindow(
                L"DrawEdgeClass",     // See RegisterClass() call.
                L"DrawEdge() Demo",   // Text for window title bar.
                WS_OVERLAPPEDWINDOW, // Window style.
                CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, // Use default positioning
                NULL,                // Overlapped windows have no parent.
                NULL,                // Use the window class menu.
                hInstance,           // This instance owns this window.
                NULL                 // We don't use any data in our WM_CREATE
        );

        // If window could not be created, return "failure"
        if (!ghWnd) 
          return (FALSE);

        ghTheme = OpenThemeData(NULL, L"Button");
        ghThemeTB = OpenThemeData(NULL, L"Rebar");

        // Make the window visible; update its client area; and return "success"
        ShowWindow(ghWnd, nCmdShow); // Show the window
        UpdateWindow(ghWnd);         // Sends WM_PAINT message

        return (TRUE);              // We succeeded...

}

void UpdateMenu(HMENU hMenu, UINT iEdge, UINT iBorder)   
{
    // Set checks set for menu items
    CheckMenuItem (hMenu, IDM_BDR_RAISEDINNER, (iEdge & BDR_RAISEDINNER) == BDR_RAISEDINNER ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BDR_SUNKENINNER, (iEdge & BDR_SUNKENINNER) == BDR_SUNKENINNER ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BDR_RAISEDOUTER, (iEdge & BDR_RAISEDOUTER) == BDR_RAISEDOUTER ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BDR_SUNKENOUTER, (iEdge & BDR_SUNKENOUTER) == BDR_SUNKENOUTER ? MF_CHECKED : MF_UNCHECKED);
    
    CheckMenuItem (hMenu, IDM_EDGE_EDGE_BUMP,   (iEdge & EDGE_BUMP) == EDGE_BUMP ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_EDGE_EDGE_ETCHED, (iEdge & EDGE_ETCHED) == EDGE_ETCHED ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_EDGE_EDGE_RAISED, (iEdge & EDGE_RAISED) == EDGE_RAISED ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_EDGE_EDGE_SUNKEN, (iEdge & EDGE_SUNKEN) == EDGE_SUNKEN ? MF_CHECKED : MF_UNCHECKED);

    CheckMenuItem (hMenu, IDM_BORDER_BF_ADJUST, (iBorder & BF_ADJUST) == BF_ADJUST ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_BOTTOM, (iBorder & BF_BOTTOM) == BF_BOTTOM ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_DIAGONAL, (iBorder & BF_DIAGONAL) == BF_DIAGONAL ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_FLAT, (iBorder & BF_FLAT) == BF_FLAT ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_LEFT, (iBorder & BF_LEFT) == BF_LEFT ? MF_CHECKED : MF_UNCHECKED);                 
    CheckMenuItem (hMenu, IDM_BORDER_BF_MIDDLE, (iBorder & BF_MIDDLE) == BF_MIDDLE ? MF_CHECKED : MF_UNCHECKED);               
    CheckMenuItem (hMenu, IDM_BORDER_BF_MONO, (iBorder & BF_MONO) == BF_MONO ? MF_CHECKED : MF_UNCHECKED);                 
    CheckMenuItem (hMenu, IDM_BORDER_BF_RIGHT, (iBorder & BF_RIGHT) == BF_RIGHT ? MF_CHECKED : MF_UNCHECKED);                
    CheckMenuItem (hMenu, IDM_BORDER_BF_SOFT, (iBorder & BF_SOFT) == BF_SOFT ? MF_CHECKED : MF_UNCHECKED);                 
    CheckMenuItem (hMenu, IDM_BORDER_BF_TOP, (iBorder & BF_TOP) == BF_TOP ? MF_CHECKED : MF_UNCHECKED);                  
    
    CheckMenuItem (hMenu, IDM_BORDER_BF_RECT, (iBorder & BF_RECT) == BF_RECT ? MF_CHECKED : MF_UNCHECKED);                 
    CheckMenuItem (hMenu, IDM_BORDER_BF_BOTTOMLEFT, (iBorder & BF_BOTTOMLEFT) == BF_BOTTOMLEFT ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_BOTTOMRIGHT, (iBorder & BF_BOTTOMRIGHT) == BF_BOTTOMRIGHT ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_TOPLEFT, (iBorder & BF_TOPLEFT) == BF_TOPLEFT ? MF_CHECKED : MF_UNCHECKED);              
    CheckMenuItem (hMenu, IDM_BORDER_BF_TOPRIGHT, (iBorder & BF_TOPRIGHT) == BF_TOPRIGHT ? MF_CHECKED : MF_UNCHECKED);             
    
    CheckMenuItem (hMenu, IDM_BORDER_BF_DIAGONAL_ENDBOTTOMLEFT, (iBorder & BF_DIAGONAL_ENDBOTTOMLEFT) == BF_DIAGONAL_ENDBOTTOMLEFT ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_DIAGONAL_ENDBOTTOMRIGHT, (iBorder & BF_DIAGONAL_ENDBOTTOMRIGHT) == BF_DIAGONAL_ENDBOTTOMRIGHT ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_DIAGONAL_ENDTOPLEFT, (iBorder & BF_DIAGONAL_ENDTOPLEFT) == BF_DIAGONAL_ENDTOPLEFT ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem (hMenu, IDM_BORDER_BF_DIAGONAL_ENDTOPRIGHT, (iBorder & BF_DIAGONAL_ENDTOPRIGHT) == BF_DIAGONAL_ENDTOPRIGHT ? MF_CHECKED : MF_UNCHECKED); 
    
    DrawMenuBar(ghWnd);
}
void FillRectClr(HDC hdc, LPRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
    SetBkColor(hdc, clrSave);
}
BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags)
{
    RECT    rc, rcD;
    UINT    bdrType;
    COLORREF clrTL, clrBR;    
    int      cxBorder = GetSystemMetrics(SM_CXBORDER);
    int      cyBorder = GetSystemMetrics(SM_CYBORDER);

    //
    // Enforce monochromicity and flatness
    //    

    // if (oemInfo.BitCount == 1)
    //    flags |= BF_MONO;
    if (flags & BF_MONO)
        flags |= BF_FLAT;    

    CopyRect(&rc, lprc);

    //
    // Draw the border segment(s), and calculate the remaining space as we
    // go.
    //
    if (bdrType = (edge & BDR_OUTER))
    {
DrawBorder:
        //
        // Get colors.  Note the symmetry between raised outer, sunken inner and
        // sunken outer, raised inner.
        //

        if (flags & BF_FLAT)
        {
            if (flags & BF_MONO)
                clrBR = (bdrType & BDR_OUTER) ? GetSysColor(COLOR_WINDOWFRAME) : GetSysColor(COLOR_WINDOW);
            else
                clrBR = (bdrType & BDR_OUTER) ? GetSysColor(COLOR_BTNSHADOW): GetSysColor(COLOR_BTNFACE);
            
            clrTL = clrBR;
        }
        else
        {
            // 5 == HILIGHT
            // 4 == LIGHT
            // 3 == FACE
            // 2 == SHADOW
            // 1 == DKSHADOW

            switch (bdrType)
            {
                // +2 above surface
                case BDR_RAISEDOUTER:           // 5 : 4
                    clrTL = ((flags & BF_SOFT) ? GetSysColor(COLOR_BTNHIGHLIGHT) : GetSysColor(COLOR_3DLIGHT));
                    clrBR = GetSysColor(COLOR_3DDKSHADOW);     // 1
                    break;

                // +0 above surface
                case BDR_RAISEDINNER:           // 4 : 5
                    clrTL = ((flags & BF_SOFT) ? GetSysColor(COLOR_3DLIGHT) : GetSysColor(COLOR_BTNHIGHLIGHT));
                    clrBR = GetSysColor(COLOR_BTNSHADOW);       // 2
                    break;

                // -1 below surface
                case BDR_SUNKENOUTER:           // 1 : 2
                    clrTL = ((flags & BF_SOFT) ? GetSysColor(COLOR_3DDKSHADOW) : GetSysColor(COLOR_BTNSHADOW));
                    clrBR = GetSysColor(COLOR_BTNHIGHLIGHT);      // 5
                    break;

                // -2 below surface
                case BDR_SUNKENINNER:           // 2 : 1
                    clrTL = ((flags & BF_SOFT) ? GetSysColor(COLOR_BTNSHADOW) : GetSysColor(COLOR_3DDKSHADOW));
                    clrBR = GetSysColor(COLOR_3DLIGHT);        // 4
                    break;

                default:
                    return(FALSE);
            }
        }

        //
        // Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
        // BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
        // left.  If we ever decide to let the user set the light source to a
        // particular corner, then change this algorithm.
        //
            
        // Bottom Right edges
        if (flags & (BF_RIGHT | BF_BOTTOM))
        {            
            // Right
            if (flags & BF_RIGHT)
            {       
                rc.right -= cxBorder;
                // PatBlt(hdc, rc.right, rc.top, cxBorder, rc.bottom - rc.top, PATCOPY);
                rcD.left = rc.right;
                rcD.right = rc.right + cxBorder;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom;

                FillRectClr(hdc, &rcD, clrBR);
            }
            
            // Bottom
            if (flags & BF_BOTTOM)
            {
                rc.bottom -= cyBorder;
                // PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left, cyBorder, PATCOPY);
                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.bottom;
                rcD.bottom = rc.bottom + cyBorder;

                FillRectClr(hdc, &rcD, clrBR);
            }
        }
        
        // Top Left edges
        if (flags & (BF_TOP | BF_LEFT))
        {
            // Left
            if (flags & BF_LEFT)
            {
                // PatBlt(hdc, rc.left, rc.top, cxBorder, rc.bottom - rc.top, PATCOPY);
                rc.left += cxBorder;

                rcD.left = rc.left - cxBorder;
                rcD.right = rc.left;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom; 

                FillRectClr(hdc, &rcD, clrTL);
            }
            
            // Top
            if (flags & BF_TOP)
            {
                // PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, cyBorder, PATCOPY);
                rc.top += cyBorder;

                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.top - cyBorder;
                rcD.bottom = rc.top;

                FillRectClr(hdc, &rcD, clrTL);
            }
        }
        
    }

    if (bdrType = (edge & BDR_INNER))
    {
        //
        // Strip this so the next time through, bdrType will be 0.
        // Otherwise, we'll loop forever.
        //
        edge &= ~BDR_INNER;
        goto DrawBorder;
    }

    //
    // Fill the middle & clean up if asked
    //
    if (flags & BF_MIDDLE)    
        FillRectClr(hdc, &rc, (flags & BF_MONO) ? GetSysColor(COLOR_WINDOW) : GetSysColor(COLOR_BTNFACE));

    if (flags & BF_ADJUST)
        CopyRect(lprc, &rc);

    return(TRUE);
}

void PaintRect(HDC hDC, RECT *prect, HBRUSH hBrush, UINT iEdge, UINT iBorder, UINT nStyle)
{
    RECT rc;

    FillRect(hDC, prect, hBrush);
    SetRect(&rc, prect->left+16, prect->top +16, prect->right-16, prect->bottom-16);
    switch (nStyle)
    {
    case 0:
        DrawEdge(hDC, &rc, iEdge, iBorder);
        break;
    case 1:
        CCDrawEdge(hDC, &rc, iEdge, iBorder);
        break;
    case 2:
        if (ghTheme)
            DrawThemeEdge(ghTheme, hDC, 0, 0, &rc, iEdge, iBorder, NULL);
        break;
    case 3:
        if (ghThemeTB)
            DrawThemeEdge(ghThemeTB, hDC, 0, 0, &rc, iEdge, iBorder, NULL);
        break;
    default:
        ;
    }
}

/****************************************************************************

        FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)

        PURPOSE:  Processes messages

        MESSAGES:

        WM_COMMAND    - application menu (About dialog box)
        WM_DESTROY    - destroy window

        COMMENTS:

        To process the IDM_ABOUT message, call MakeProcInstance() to get the
        current instance address of the About() function.  Then call Dialog
        box which will create the box according to the information in your
        generic.rc file and turn control over to the About() function.  When
        it returns, free the intance address.

****************************************************************************/

LRESULT CALLBACK WndProc(
                HWND hWnd,         // window handle
                UINT message,      // type of message
                WPARAM uParam,     // additional information
                LPARAM lParam)     // additional information
{
	int wmId, wmEvent;
    static UINT iEdge = EDGE_SUNKEN;
    static UINT iBorder = BF_RECT | BF_MIDDLE;
	                   
	switch (message) {
        case WM_INITMENU:
            UpdateMenu(GetMenu(hWnd), iEdge, iBorder);
            break;
         
        case WM_THEMECHANGED:
            if (ghTheme)
                CloseThemeData(ghTheme);
            if (ghThemeTB)
                CloseThemeData(ghThemeTB);
            ghTheme = OpenThemeData(NULL, L"Button");
            ghThemeTB = OpenThemeData(NULL, L"Rebar");
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case WM_PAINT:
            {
              PAINTSTRUCT ps;
              HDC hDC = BeginPaint(hWnd, &ps);
              RECT rect;
              RECT rectCC, rectTH, rectTB;
              SIZE sizeText;
              int delta;
              WCHAR szDrawEdge[] = L"DrawEdge";
              WCHAR szCCDrawEdge[] = L"CCDrawEdge";
              WCHAR szDrawThemeEdge[] = L"DrawThemeEdge (Button)";
              WCHAR szDrawThemeEdgeTB[] = L"DrawThemeEdge (Rebar)";

              GetClientRect(hWnd, &rect);
              GetTextExtentPoint32(hDC, L"Dg", 2, &sizeText);
              rect.top += sizeText.cy;
              rect.bottom -= sizeText.cy;
              SetRect(&rect, rect.left, rect.top, (rect.right >> 1), rect.top + ((rect.bottom  - rect.top) >> 1));
              CopyRect(&rectCC, &rect);
              CopyRect(&rectTH, &rect);
              CopyRect(&rectTB, &rect);
              OffsetRect(&rectCC, rect.right, 0);
              OffsetRect(&rectTH, 0, rect.bottom);
              OffsetRect(&rectTB, rect.right, rect.bottom);
              
              // Divide into quarters
              SetRect(&rect, rect.left, rect.top, (rect.right >> 1), rect.top + ((rect.bottom - rect.top) >> 1));
              SetRect(&rectCC, rectCC.left, rectCC.top, 
                  rectCC.left + ((rectCC.right - rectCC.left) >> 1), rectCC.top + ((rectCC.bottom - rectCC.top) >> 1));
              SetRect(&rectTH, rectTH.left, rectTH.top, 
                  rectTH.left + ((rectTH.right - rectTH.left) >> 1), rectTH.top + ((rectTH.bottom - rectTH.top) >> 1));
              SetRect(&rectTB, rectTB.left, rectTB.top, 
                  rectTB.left + ((rectTB.right - rectTB.left) >> 1), rectTB.top + ((rectTB.bottom - rectTB.top) >> 1));
              
              // Fill upper left quarter
              PaintRect(hDC, &rect, GetStockObject(BLACK_BRUSH), iEdge, iBorder, 0);
              PaintRect(hDC, &rectCC, GetStockObject(BLACK_BRUSH), iEdge, iBorder, 1);
              PaintRect(hDC, &rectTH, GetStockObject(BLACK_BRUSH), iEdge, iBorder, 2);
              PaintRect(hDC, &rectTB, GetStockObject(BLACK_BRUSH), iEdge, iBorder, 3);

              // Fill upper right quarter
              delta = rect.right;
              OffsetRect(&rect, delta, 0);
              OffsetRect(&rectCC, delta, 0);
              OffsetRect(&rectTH, delta, 0);
              OffsetRect(&rectTB, delta, 0);
              PaintRect(hDC, &rect, GetStockObject(DKGRAY_BRUSH), iEdge, iBorder, 0);
              PaintRect(hDC, &rectCC, GetStockObject(DKGRAY_BRUSH), iEdge, iBorder, 1);
              PaintRect(hDC, &rectTH, GetStockObject(DKGRAY_BRUSH), iEdge, iBorder, 2);
              PaintRect(hDC, &rectTB, GetStockObject(DKGRAY_BRUSH), iEdge, iBorder, 3);

              // Fill lower right quarter
              delta = rect.bottom - rect.top;
              OffsetRect(&rect, 0, delta);
              OffsetRect(&rectCC, 0, delta);
              OffsetRect(&rectTH, 0, delta);
              OffsetRect(&rectTB, 0, delta);
              PaintRect(hDC, &rect, GetStockObject(GRAY_BRUSH), iEdge, iBorder, 0);
              PaintRect(hDC, &rectCC, GetStockObject(GRAY_BRUSH), iEdge, iBorder, 1);
              PaintRect(hDC, &rectTH, GetStockObject(GRAY_BRUSH), iEdge, iBorder, 2);
              PaintRect(hDC, &rectTB, GetStockObject(GRAY_BRUSH), iEdge, iBorder, 3);

              // Fill lower left quarter
              delta = -rect.left;
              OffsetRect(&rect, delta, 0);
              OffsetRect(&rectCC, delta, 0);
              OffsetRect(&rectTH, delta, 0);
              OffsetRect(&rectTB, delta, 0);
              PaintRect(hDC, &rect, GetStockObject(LTGRAY_BRUSH), iEdge, iBorder, 0);
              PaintRect(hDC, &rectCC, GetStockObject(LTGRAY_BRUSH), iEdge, iBorder, 1);
              PaintRect(hDC, &rectTH, GetStockObject(LTGRAY_BRUSH), iEdge, iBorder, 2);
              PaintRect(hDC, &rectTB, GetStockObject(LTGRAY_BRUSH), iEdge, iBorder, 3);

              TextOut(hDC, 0, 0, szDrawEdge, countof(szDrawEdge) - 1);
              TextOut(hDC, rectCC.left, 0, szCCDrawEdge, countof(szCCDrawEdge) - 1);
              TextOut(hDC, 0, rect.bottom, szDrawThemeEdge, countof(szDrawThemeEdge) - 1);
              TextOut(hDC, rectTB.left, rect.bottom, szDrawThemeEdgeTB, countof(szDrawThemeEdgeTB) - 1);
              
              EndPaint(hWnd, &ps);
            } 
            break;

        case WM_COMMAND:
            wmId    = LOWORD(uParam);
            wmEvent = HIWORD(uParam);

            switch (wmId) {
                case IDM_BDR_RAISEDINNER:
                    if (iEdge & BDR_SUNKENINNER) iEdge ^= BDR_SUNKENINNER;
                    iEdge ^= BDR_RAISEDINNER;
                    break;

                case IDM_BDR_SUNKENINNER:	                                  
                    if (iEdge & BDR_RAISEDINNER) iEdge ^= BDR_RAISEDINNER;
                    iEdge ^= BDR_SUNKENINNER;
                    break;

                case IDM_BDR_RAISEDOUTER:
                    if (iEdge & BDR_SUNKENOUTER) iEdge ^= BDR_SUNKENOUTER;
                    iEdge ^= BDR_RAISEDOUTER;
                    break;	

                case IDM_BDR_SUNKENOUTER:
                    if (iEdge & BDR_RAISEDOUTER) iEdge ^= BDR_RAISEDOUTER;
                    iEdge ^= BDR_SUNKENOUTER;
                    break;

		 		case IDM_EDGE_EDGE_BUMP:
                    iEdge ^= (iEdge & (BDR_RAISEDINNER | BDR_SUNKENINNER | BDR_RAISEDOUTER | BDR_SUNKENOUTER));
                    iEdge ^= EDGE_BUMP;
                    break;
              
		 		case IDM_EDGE_EDGE_ETCHED:
                    iEdge ^= (iEdge & (BDR_RAISEDINNER | BDR_SUNKENINNER | BDR_RAISEDOUTER | BDR_SUNKENOUTER));
                    iEdge ^= EDGE_ETCHED;
                    break;

		 		case IDM_EDGE_EDGE_RAISED:
                    iEdge ^= (iEdge & (BDR_RAISEDINNER | BDR_SUNKENINNER | BDR_RAISEDOUTER | BDR_SUNKENOUTER));
                    iEdge ^= EDGE_RAISED;
                    break;

		 		case IDM_EDGE_EDGE_SUNKEN:
                    iEdge ^= (iEdge & (BDR_RAISEDINNER | BDR_SUNKENINNER | BDR_RAISEDOUTER | BDR_SUNKENOUTER));
                    iEdge ^= EDGE_SUNKEN;
                    break;
        
		 		case IDM_BORDER_BF_ADJUST:
                    iBorder ^=  BF_ADJUST;
                    break;

		 		case IDM_BORDER_BF_BOTTOM:
                    iBorder ^=  BF_BOTTOM;
                    break;

		 		case IDM_BORDER_BF_DIAGONAL:
                    iBorder ^=  BF_DIAGONAL;
                    break;

		 		case IDM_BORDER_BF_FLAT:
                    iBorder ^=  BF_FLAT;
                    break;

		 		case IDM_BORDER_BF_LEFT:
                    iBorder ^=  BF_LEFT;
                    break;

		 		case IDM_BORDER_BF_MIDDLE:
                    iBorder ^=  BF_MIDDLE;
                    break;

		 		case IDM_BORDER_BF_MONO:
                    iBorder ^=  BF_MONO;
                    break;

		 		case IDM_BORDER_BF_RIGHT:
                    iBorder ^=  BF_RIGHT;
                    break;

		 		case IDM_BORDER_BF_SOFT:
                    iBorder ^=  BF_SOFT;
                    break;

		 		case IDM_BORDER_BF_TOP:
                    iBorder ^=  BF_TOP;
                    break;

		 		case IDM_BORDER_BF_RECT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_RECT;
                    break;

		 		case IDM_BORDER_BF_BOTTOMLEFT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_BOTTOMLEFT;
                    break;

		 		case IDM_BORDER_BF_BOTTOMRIGHT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_BOTTOMRIGHT;
                    break;

		 		case IDM_BORDER_BF_TOPLEFT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_TOPLEFT;
                    break;

		 		case IDM_BORDER_BF_TOPRIGHT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_TOPRIGHT;
                    break;

		 		case IDM_BORDER_BF_DIAGONAL_ENDBOTTOMLEFT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_DIAGONAL_ENDBOTTOMLEFT;
                    break;

		 		case IDM_BORDER_BF_DIAGONAL_ENDBOTTOMRIGHT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_DIAGONAL_ENDBOTTOMRIGHT;
                    break;

		 		case IDM_BORDER_BF_DIAGONAL_ENDTOPLEFT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_DIAGONAL_ENDTOPLEFT;
                    break;

		 		case IDM_BORDER_BF_DIAGONAL_ENDTOPRIGHT:
                    iBorder ^= (iBorder & (BF_RECT | BF_DIAGONAL));
                    iBorder ^=  BF_DIAGONAL_ENDTOPRIGHT;
                    break;

                case IDM_ABOUT:
                    DialogBox(hInst,          // current instance
                             L"ABOUTBOX",      // dlg resource to use
                             hWnd,            // parent handle
                             (DLGPROC)About); // About() instance address

                    break;

                case IDM_EXIT:
                    DestroyWindow (hWnd);
                    break;

                default:
                    return (DefWindowProc(hWnd, message, uParam, lParam));
            };
            
            UpdateMenu(GetMenu(hWnd), iEdge, iBorder);
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case WM_DESTROY:  // message: window being destroyed
                PostQuitMessage(0);
                break;
    
        default:          // Passes it on if unproccessed
                return (DefWindowProc(hWnd, message, uParam, lParam));
	}
	return (0);
}
           
/*****************************************************************************
 *																			 *
 *   FUNCTION: CenterWindow (HWND, HWND)									 *
 *																			 *
 *   PURPOSE:  Center one window over another								 *
 *																			 *
 *   COMMENTS:																 *
 *																			 *
 *   Dialog boxes take on the screen position that they were designed at,	 *
 *   which is not always appropriate. Centering the dialog over a particular *
 *   window usually results in a better position.							 *
 *																			 *
 ****************************************************************************/

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
        RECT    rChild, rParent;
        int     wChild, hChild, wParent, hParent;
        int     wScreen, hScreen, xNew, yNew;
        HDC     hdc;

        // Get the Height and Width of the child window
        GetWindowRect (hwndChild, &rChild);
        wChild = rChild.right - rChild.left;
        hChild = rChild.bottom - rChild.top;

        // Get the Height and Width of the parent window
        GetWindowRect (hwndParent, &rParent);
        wParent = rParent.right - rParent.left;
        hParent = rParent.bottom - rParent.top;

        // Get the display limits
        hdc = GetDC (hwndChild);
        wScreen = GetDeviceCaps (hdc, HORZRES);
        hScreen = GetDeviceCaps (hdc, VERTRES);
        ReleaseDC (hwndChild, hdc);

        // Calculate new X position, then adjust for screen
        xNew = rParent.left + ((wParent - wChild) /2);
        if (xNew < 0) {
                xNew = 0;
        } else if ((xNew+wChild) > wScreen) {
                xNew = wScreen - wChild;
        }

        // Calculate new Y position, then adjust for screen
        yNew = rParent.top  + ((hParent - hChild) /2);
        if (yNew < 0) {
                yNew = 0;
        } else if ((yNew+hChild) > hScreen) {
                yNew = hScreen - hChild;
        }

        // Set it, and return
        return SetWindowPos (hwndChild, NULL,
                xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


/*****************************************************************************
 *																			 *
 *   FUNCTION: About(HWND, UINT, WPARAM, LPARAM)							 *
 *																			 *
 *   PURPOSE:  Processes messages for "About" dialog box					 *
 *																			 *
 *   MESSAGES:																 *
 *																			 *
 *   WM_INITDIALOG - initialize dialog box									 *
 *   WM_COMMAND    - Input received											 *
 *																			 *
 *   COMMENTS:																 *
 *																			 *
 *   Display version information from the version section of the			 *
 *   application resource.													 *
 *																			 *
 *   Wait for user to click on "Ok" button, then close the dialog box.		 *
 *																			 *
 ****************************************************************************/

LRESULT CALLBACK About(
                HWND hDlg,           // window handle of the dialog box
                UINT message,        // type of message
                WPARAM uParam,       // message-specific information
                LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:  // message: initialize dialog box
            // Center the dialog over the application window
            CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
            return (TRUE);

        case WM_COMMAND:                      // message: received a command
            if (LOWORD(uParam) == IDOK || LOWORD(uParam) == IDCANCEL) { 
                EndDialog(hDlg, TRUE);        // Exit the dialog
                return (TRUE);
            }
            break;
    }
    return (FALSE); // Didn't process the message

    UNREFERENCED_PARAMETER(lParam); // This will prevent 'unused formal parameter' warnings
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\drawedge\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by DrawEdge.RC
//
#define IDM_BDR_RAISEDINNER             	    40001
#define IDM_BDR_SUNKENINNER             	    40002
#define IDM_BDR_RAISEDOUTER             	    40003
#define IDM_BDR_SUNKENOUTER             	    40004
#define IDM_EDGE_EDGE_BUMP                      40005
#define IDM_EDGE_EDGE_ETCHED                    40006
#define IDM_EDGE_EDGE_RAISED                    40007
#define IDM_EDGE_EDGE_SUNKEN                    40008
#define IDM_BORDER_BF_ADJUST                    40009
#define IDM_BORDER_BF_BOTTOM                    40010
#define IDM_BORDER_BF_BOTTOMLEFT                40011
#define IDM_BORDER_BF_BOTTOMRIGHT               40012
#define IDM_BORDER_BF_DIAGONAL                  40013
#define IDM_BORDER_BF_DIAGONAL_ENDBOTTOMLEFT    40014
#define IDM_BORDER_BF_DIAGONAL_ENDBOTTOMRIGHT   40015
#define IDM_BORDER_BF_DIAGONAL_ENDTOPLEFT       40016
#define IDM_BORDER_BF_DIAGONAL_ENDTOPRIGHT      40017
#define IDM_BORDER_BF_FLAT                      40018
#define IDM_BORDER_BF_LEFT                      40019
#define IDM_BORDER_BF_MIDDLE                    40020
#define IDM_BORDER_BF_MONO                      40021
#define IDM_BORDER_BF_RECT                      40022
#define IDM_BORDER_BF_RIGHT                     40023
#define IDM_BORDER_BF_SOFT                      40024
#define IDM_BORDER_BF_TOP                       40025
#define IDM_BORDER_BF_TOPLEFT                   40026
#define IDM_BORDER_BF_TOPRIGHT                  40027 
#define IDM_ABOUT                               40028
#define IDM_EXIT                                40029
#define DLG_VERFIRST                            101
#define DLG_VERLAST                             102
#define IDC_STATIC                              -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40030
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\framemetrics\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WINVER  0x0500

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

#define TESTFLAG(a,b)   (0!=((a) & (b)))
#define RECTWIDTH(prc)  ((prc)->right - (prc)->left)
#define RECTHEIGHT(prc) ((prc)->bottom - (prc)->top)
#define ARRAYSIZE(rg)   (sizeof(rg)/sizeof(*(rg)))


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\framemetrics\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FrameMetrics.rc
//
#define IDC_MYICON                      2
#define IDD_FRAMEMETRICS_DIALOG         102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_FRAMEMETRICS                107
#define IDI_SMALL                       108
#define IDC_FRAMEMETRICS                109
#define IDR_MAINFRAME                   128
#define ID_SCROLLBARS                   32771
#define ID_CAPTION                      32772
#define ID_MENUBAR                      32773
#define ID_BORDERS                      32774
#define ID_THICKFRAME                   32775
#define ID_CLOSEBUTTON                  32778
#define ID_MAXBUTTON                    32779
#define ID_MINBUTTON                    32780
#define ID_SYSICON                      32781
#define ID_MINMAX                       32782
#define ID_NONE                         32783
#define ID_ALL                          32784
#define ID_HELPBUTTON                   32785
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32786
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "mditest.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
		ON_WM_SETFOCUS()
		ON_WM_CREATE()
	ON_COMMAND(ID_FULLMDIMAXIMIZED, OnFullMdiMaximized)
	ON_UPDATE_COMMAND_UI(ID_FULLMDIMAXIMIZED, OnUpdateFullMdiMaximized)
	ON_WM_GETMINMAXINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
    :   m_fFullMdiMax(TRUE)
{
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CMDIChildWnd::PreCreateWindow(cs) )
		return FALSE;

	cs.dwExStyle &= ~WS_EX_CLIENTEDGE;
	cs.lpszClass = AfxRegisterWndClass(0);

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
void CChildFrame::OnFileClose() 
{

	SendMessage(WM_CLOSE);
}

int CChildFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// create a view to occupy the client area of the frame
	if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW, 
		CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
	{
		TRACE0("Failed to create view window\n");
		return -1;
	}

	return 0;
}

void CChildFrame::OnSetFocus(CWnd* pOldWnd) 
{
	CMDIChildWnd::OnSetFocus(pOldWnd);

	m_wndView.SetFocus();
}

BOOL CChildFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo) 
{
	// let the view have first crack at the command
	if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;
	
	// otherwise, do default handling
	return CMDIChildWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}


void CChildFrame::OnFullMdiMaximized() 
{
	m_fFullMdiMax = !m_fFullMdiMax;
}

void CChildFrame::OnUpdateFullMdiMaximized(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck( m_fFullMdiMax );
}

void CChildFrame::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) 
{
	CMDIChildWnd::OnGetMinMaxInfo(lpMMI);

    if( !m_fFullMdiMax )
    {
        CWnd* pParent = GetParent();
        if( pParent )
        {
            RECT rc;
            pParent->GetClientRect( &rc );

            lpMMI->ptMaxTrackSize.x = (rc.right - rc.left)/2;
            lpMMI->ptMaxTrackSize.y = (rc.bottom - rc.top)/2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\framemetrics\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	FrameMetrics.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__54A20A14_7B10_4F89_A933_5A8BF763A720__INCLUDED_)
#define AFX_CHILDFRM_H__54A20A14_7B10_4F89_A933_5A8BF763A720__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ChildView.h"

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	// view for the client area of the frame.
	CChildView m_wndView;
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
	afx_msg void OnFileClose();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnFullMdiMaximized();
	afx_msg void OnUpdateFullMdiMaximized(CCmdUI* pCmdUI);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    BOOL m_fFullMdiMax;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__54A20A14_7B10_4F89_A933_5A8BF763A720__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\childview.cpp ===
// ChildView.cpp : implementation of the CChildView class
//

#include "stdafx.h"
#include "mditest.h"
#include "ChildView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildView

CChildView::CChildView()
    :   _hwndEdit(NULL)
{
}

CChildView::~CChildView()
{
}


BEGIN_MESSAGE_MAP(CChildView,CWnd )
	//{{AFX_MSG_MAP(CChildView)
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) 
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	cs.dwExStyle |= WS_EX_CLIENTEDGE;
	cs.style &= ~WS_BORDER;
	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, 
		::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

	return TRUE;
}

void CChildView::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	
	// Do not call CWnd::OnPaint() for painting messages
}


int CChildView::OnCreate(LPCREATESTRUCT pcs) 
{
	if (CWnd ::OnCreate(pcs) == -1)
		return -1;

    RECT rc;
    GetClientRect( &rc );
	
	_hwndEdit = CreateWindowEx( 0, TEXT("Edit"), NULL, 
                                WS_CHILD|WS_VISIBLE|WS_VSCROLL|ES_MULTILINE|ES_AUTOHSCROLL,
                                0, 0, RECTWIDTH(&rc), RECTHEIGHT(&rc), *this, NULL,
                                AfxGetInstanceHandle(), 0 );
    if( IsWindow( _hwndEdit ) )
    {
        HFONT hf = CreateFont(-14, 0,0,0, FW_NORMAL, 0,0,0, ANSI_CHARSET, 0,0,0,0, TEXT("MS Sans Serif") );
        if( hf )
            ::SendMessage( _hwndEdit, WM_SETFONT, (WPARAM)hf, 0 );

        for( int i = 0; i < 100; i++ )
        {
            ::SendMessage( _hwndEdit, EM_REPLACESEL, 0, 
                (LPARAM)TEXT("Some random text and some more random text and some more random text. ")\
                        TEXT("Some random text and some more random text and some more random text.\r\n") );
            ::SendMessage( _hwndEdit, EM_SETSEL, -1, -1 );
        }
    }
	return 0;
}

void CChildView::OnSize(UINT nType, int cx, int cy) 
{
	CWnd ::OnSize(nType, cx, cy);
	
	if( IsWindow( _hwndEdit ) )
    {
        ::SetWindowPos( _hwndEdit, NULL, 0, 0, cx, cy, SWP_NOZORDER|SWP_NOACTIVATE );
    }
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\childview.h ===
// ChildView.h : interface of the CChildView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDVIEW_H__DFC11891_3A2B_46FF_B8E7_BE8A1D4B2473__INCLUDED_)
#define AFX_CHILDVIEW_H__DFC11891_3A2B_46FF_B8E7_BE8A1D4B2473__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CChildView window

class CChildView : public CWnd
{
// Construction
public:
	CChildView();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildView)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildView();

	// Generated message map functions
protected:
	//{{AFX_MSG(CChildView)
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    HWND _hwndEdit;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDVIEW_H__DFC11891_3A2B_46FF_B8E7_BE8A1D4B2473__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "mditest.h"
#include "rgn.h"

#include "MainFrm.h"
#include "NCMetricsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define TESTFLAG(bits,flag)  (((bits) & (flag))!=0)

void TestRgnData();

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_GETMINMAXINFO()
	ON_COMMAND(ID_FULLSCRNMAXIMIZED, OnFullScrnMaximized)
	ON_UPDATE_COMMAND_UI(ID_FULLSCRNMAXIMIZED, OnUpdateFullScrnMaximized)
	ON_COMMAND(ID_AWRWINDOW, OnAwrWindow)
	ON_COMMAND(ID_AWRWINDOWMENU, OnAwrWindowMenu)
	ON_COMMAND(ID_NONCLIENTMETRICS, OnNonClientMetrics)
	ON_COMMAND(ID_THINFRAME, OnThinFrame)
	ON_COMMAND(ID_DUMPMETRICS, OnDumpMetrics)
	ON_COMMAND(ID_MINIMIZEBOX, OnMinimizeBox)
	ON_UPDATE_COMMAND_UI(ID_MINIMIZEBOX, OnUpdateMinimizeBox)
	ON_COMMAND(ID_MAXIMIZEBOX, OnMaximizeBox)
	ON_UPDATE_COMMAND_UI(ID_MAXIMIZEBOX, OnUpdateMaximizeBox)
	ON_COMMAND(ID_SYSMENU, OnSysMenu)
	ON_UPDATE_COMMAND_UI(ID_SYSMENU, OnUpdateSysMenu)
	ON_UPDATE_COMMAND_UI(ID_CLOSEBTN, OnUpdateCloseBtn)
	ON_COMMAND(ID_CLOSEBTN, OnCloseBtn)
	ON_COMMAND(ID_TOOLFRAME, OnToolframe)
	ON_COMMAND(ID_ALTICON, OnAltIcon)
	ON_UPDATE_COMMAND_UI(ID_ALTICON, OnUpdateAltIcon)
	ON_COMMAND(ID_ALTTEXT, OnAltTitle)
	ON_UPDATE_COMMAND_UI(ID_ALTTEXT, OnUpdateAltTitle)
	ON_COMMAND(IDC_DCAPPCOMPAT, OnDcAppcompat)
	ON_UPDATE_COMMAND_UI(IDC_DCAPPCOMPAT, OnUpdateDcAppcompat)
	ON_COMMAND(IDC_DFCAPPCOMPAT, OnDfcAppcompat)
	ON_UPDATE_COMMAND_UI(IDC_DFCAPPCOMPAT, OnUpdateDfcAppcompat)
	ON_WM_NCPAINT()
	ON_COMMAND(ID_MINMAXSTRESS, OnMinMaxStress)
	ON_UPDATE_COMMAND_UI(ID_MINMAXSTRESS, OnUpdateMinMaxStress)
	ON_WM_WINDOWPOSCHANGING()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
    :   m_fFullScrnMax(TRUE),
        m_fAltIcon(FALSE),
        m_fAltTitle(FALSE),
        m_fDfcAppCompat(FALSE),
        m_fDcAppCompat(FALSE),
        m_fMinMaxStress(FALSE),
        m_pwiNormal0(NULL),
        m_hIcon(NULL)
{
}

CMainFrame::~CMainFrame()
{
    if( m_hAltIcon )
        DeleteObject( m_hAltIcon );
    if( m_hIcon )
        DeleteObject( m_hIcon );
}

LRESULT CALLBACK MsgWndProc( HWND hwnd, UINT uMsg, WPARAM lParam, LPARAM wParam )
{
    return DefWindowProc( hwnd, uMsg, lParam, wParam );
}

int GetPrime( ULONG number )
{
    int cPrimeCount = 0;
    if( number > 1 )
    {
        for( UINT i = 2; i < number; i++ )
        {
            if( 0 == number % i )
                cPrimeCount++;
        }
    }
    return cPrimeCount;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}
	if (!m_wndDlgBar.Create(this, IDR_MAINFRAME, 
		CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
	{
		TRACE0("Failed to create dialogbar\n");
		return -1;		// fail to create
	}

	if (!m_wndReBar.Create(this) ||
		!m_wndReBar.AddBar(&m_wndToolBar) ||
		!m_wndReBar.AddBar(&m_wndDlgBar))
	{
		TRACE0("Failed to create rebar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

    TestRgnData();
	return 0;
}

void _GetRectSize( LPCRECT prc, PPOINT pptSize )
{
    pptSize->x = RECTWIDTH(prc);
    pptSize->y = RECTHEIGHT(prc);
}

BOOL _EqualPoint( PPOINT pt1, PPOINT pt2 )
{
    return (pt1->x == pt2->x) && (pt1->y == pt2->y);
}



LRESULT CALLBACK AWRWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch(uMsg)
    {
        case WM_COMMAND:
        {
            if( ID_CLOSE == LOWORD(wParam) )
                DestroyWindow(hwnd);
            break;
        }

        case WM_SIZE:
        {
            RECT rcCli, rcWnd, rcAwr;
            POINT sizeWnd, sizeCli, sizeAwr;
            
            GetWindowRect(hwnd, &rcWnd);
            _GetRectSize(&rcWnd, &sizeWnd);
            GetClientRect(hwnd, &rcCli);
            _GetRectSize(&rcCli, &sizeCli);

            int cyMenu = GetSystemMetrics(SM_CYMENU);
            int cyMenuSize = GetSystemMetrics(SM_CYMENUSIZE);


            WINDOWINFO wi = {0};
            wi.cbSize = sizeof(wi);
            GetWindowInfo(hwnd, &wi);

            rcAwr = rcCli;
            AdjustWindowRectEx(&rcAwr, wi.dwStyle, GetMenu(hwnd) != NULL, wi.dwExStyle);
            _GetRectSize(&rcAwr, &sizeAwr);
            TRACE( TEXT("AWRex: cli(%d,%d), wnd(%d,%d), awr(%d,%d), %s\n\n"),
                    sizeCli, sizeWnd,  sizeAwr,
                    _EqualPoint(&sizeWnd, &sizeAwr) ? TEXT("Ok.") : TEXT("ERROR!") );
            break;
        }
    }
    
    return DefWindowProc( hwnd, uMsg, wParam, lParam );
}

//---------------------------------------------------------------------------
HRESULT _PrepareRegionDataForScaling(RGNDATA *pRgnData, LPCRECT prcImage, MARGINS *pMargins)
{
    //---- compute margin values ----
    int sw = prcImage->left;
    int lw = prcImage->left + pMargins->cxLeftWidth;
    int rw = prcImage->right - pMargins->cxRightWidth;

    int sh = prcImage->top;
    int th = prcImage->top + pMargins->cyTopHeight;
    int bh = prcImage->bottom - pMargins->cyBottomHeight;

    //---- step thru region data & customize it ----
    //---- classify each POINT according to a gridnum and ----
    //---- make it 0-relative to its grid location ----

    POINT *pt = (POINT *)pRgnData->Buffer;
    BYTE *pByte = (BYTE *)pRgnData->Buffer + pRgnData->rdh.nRgnSize;
    int iCount = 2 * pRgnData->rdh.nCount;

    for (int i=0; i < iCount; i++, pt++, pByte++)
    {
        if (pt->x < lw)
        {
            pt->x -= sw;

            if (pt->y < th)         // left top
            {
                *pByte = GN_LEFTTOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // left middle
            {
                *pByte = GN_LEFTMIDDLE;
                pt->y -= th;
            }
            else                    // left bottom
            {
                *pByte = GN_LEFTBOTTOM;
                pt->y -= bh;
            }
        }
        else if (pt->x < rw)
        {
            pt->x -= lw;

            if (pt->y < th)         // middle top
            {
                *pByte = GN_MIDDLETOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // middle middle
            {
                *pByte = GN_MIDDLEMIDDLE;
                pt->y -= th;
            }
            else                    // middle bottom
            {
                *pByte = GN_MIDDLEBOTTOM;
                pt->y -= bh;
            }
        }
        else
        {
            pt->x -= rw;

            if (pt->y < th)         // right top
            {
                *pByte = GN_RIGHTTOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // right middle
            {
                *pByte = GN_RIGHTMIDDLE;
                pt->y -= th;
            }
            else                    // right bottom
            {
                *pByte = GN_RIGHTBOTTOM;
                pt->y -= bh;
            }
        }

    }

    return S_OK;
} 

//---------------------------------------------------------------------------
void TestRgnData()
{
    HBITMAP hbm = (HBITMAP)LoadImage( 
        NULL, TEXT("f:\\testapplets\\mditest\\rgndatatest.bmp"),
        IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE );

    if( hbm )
    {
        HRGN hrgn;
        BITMAP bm;
        GetObject( hbm, sizeof(bm), &bm );

        if( SUCCEEDED( CreateBitmapRgn( hbm, 0, 0, -1, -1, FALSE, 0, RGB(255,0,255), 0, &hrgn ) ) )
        {
            LONG cb = GetRegionData(hrgn, 0, NULL);
            LONG cbRgnData = cb + sizeof(RGNDATAHEADER);
            BYTE* pbData = NULL;
            if( (pbData = new BYTE[cbRgnData]) != NULL )
            {
                RGNDATA* pRgnData = (RGNDATA*)pbData;
                if( GetRegionData(hrgn, cbRgnData, pRgnData) )
                {
                    MARGINS marSizing = {12,6,1,6};
                    RECT rcImage;
                    SetRect(&rcImage, 0, 0, bm.bmWidth, bm.bmHeight);
                    _PrepareRegionDataForScaling( pRgnData, &rcImage, &marSizing );
                }

                delete [] pbData;
            }


        }
    }
}

void TestPidHash()
{
    for( int rep = 0; rep < 500; rep++ )
    {
        ULONG cBestCollisions = -1;
        int   cBestBuckets = 0;
        for( int cBuckets = 0xFD9; cBuckets <= 0xFF3; cBuckets++ )
        {
            ULONG hashtable[2][1000] = {0};
            srand(GetTickCount());
            ULONG cCollisions = 0;
    
            for( int i=0; i < 1000; i++ )
            {
                ULONG pid = rand();
                ULONG hash = (pid << 4);
                hash %= cBuckets;

                for( int j = 0; j < i; j++ )
                {
                    if( hashtable[1][j] == hash )
                    {
                        ULONG pidOther  = hashtable[0][j];
                        ULONG hashOther = hashtable[1][j];
                        cCollisions++;
                    }
                }
                hashtable[0][i] = pid;
                hashtable[1][i] = hash;
            }

            if( cCollisions < cBestCollisions )
            {
                cBestCollisions = cCollisions;
                cBestBuckets = cBuckets;
            }
            
            //TRACE("Collision count using bucket count %04X: %d\n", cBuckets, cCollisions );
        }
        
        TRACE(TEXT("%04X\t%d\t%d\n"), cBestBuckets, cBestCollisions, GetPrime(cBestBuckets) );
    }
}  



//---------------------------------------------------------------------------
HWND CreateAWRWindow( HWND hwndParent, DWORD dwStyle, DWORD dwExStyle, BOOL fMenu )
{
    static WNDCLASS wc = {0};
    if( !wc.lpfnWndProc )
    {
        wc.style = CS_HREDRAW|CS_VREDRAW;
        wc.lpfnWndProc = AWRWndProc;  
        wc.hInstance = AfxGetInstanceHandle();
        wc.hCursor = ::LoadCursor( NULL, IDC_ARROW );
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszClassName = TEXT("AWRTestWnd");
        if( !RegisterClass( &wc ) )
            return NULL;
    }

    HMENU hMenu = NULL;
    if( fMenu )
        hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_AWRMENU) );

    return CreateWindowEx( dwExStyle, wc.lpszClassName, TEXT("AdustWindowRect test"), dwStyle,
                           0, 0, 640, 480, hwndParent, hMenu, wc.hInstance, NULL );
}

//---------------------------------------------------------------------------
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CMDIFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


void CMainFrame::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) 
{
	CMDIFrameWnd::OnGetMinMaxInfo(lpMMI);

    if( !m_fFullScrnMax )
    {
        //lpMMI->ptMaxPosition.x = lpMMI->ptMaxPosition.y = 0;
        lpMMI->ptMaxTrackSize.x = GetSystemMetrics(SM_CXSCREEN)/2;
        lpMMI->ptMaxTrackSize.y = GetSystemMetrics(SM_CYSCREEN)/2;
    }
}

void CMainFrame::OnFullScrnMaximized() 
{
	m_fFullScrnMax = !m_fFullScrnMax;
}

void CMainFrame::OnUpdateFullScrnMaximized(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck( m_fFullScrnMax );
}

void CMainFrame::OnAwrWindow() 
{
	HWND hwnd;
    if( (hwnd = CreateAWRWindow( 
        *this, WS_OVERLAPPEDWINDOW & ~WS_SYSMENU, WS_EX_CLIENTEDGE|WS_EX_CONTEXTHELP, FALSE )) != NULL )
    {
        ::ShowWindow(hwnd, SW_SHOW);
        ::UpdateWindow(hwnd);
    }
}

void CMainFrame::OnAwrWindowMenu() 
{
	HWND hwnd;
    if( (hwnd = CreateAWRWindow(
        *this, WS_OVERLAPPEDWINDOW, WS_EX_CLIENTEDGE, TRUE )) != NULL )
    {
        ::ShowWindow(hwnd, SW_SHOW);
        ::UpdateWindow(hwnd);
    }
}

void CMainFrame::OnNonClientMetrics() 
{
	CNCMetricsDlg dlg;
    dlg.DoModal();
}

LRESULT CALLBACK ToolFrameWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return DefWindowProc( hwnd, uMsg, wParam, lParam );
}


LRESULT CALLBACK ThinFrameWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return DefWindowProc( hwnd, uMsg, wParam, lParam );
}

void CMainFrame::OnToolframe() 
{
    static WNDCLASS wc = {0};
    if( !wc.lpfnWndProc )
    {
        wc.style = CS_HREDRAW|CS_VREDRAW;
        wc.lpfnWndProc = ToolFrameWndProc;  
        wc.hInstance = AfxGetInstanceHandle();
        wc.hCursor = ::LoadCursor( NULL, IDC_ARROW );
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszClassName = TEXT("ToolFrameTestWnd");
        if( !RegisterClass( &wc ) )
            return;
    }

    HWND hwnd = CreateWindowEx( WS_EX_TOOLWINDOW, wc.lpszClassName, TEXT("Tool Frame"), 
                                WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX,
                                CW_USEDEFAULT, 0, 280, 320, *this, NULL, wc.hInstance, NULL );

    if( hwnd )
    {
        ::UpdateWindow(hwnd);
        ::ShowWindow(hwnd, SW_SHOW);

    }
}

void CMainFrame::OnThinFrame() 
{
    static WNDCLASS wc = {0};
    if( !wc.lpfnWndProc )
    {
        wc.style = CS_HREDRAW|CS_VREDRAW;
        wc.lpfnWndProc = ThinFrameWndProc;  
        wc.hInstance = AfxGetInstanceHandle();
        wc.hCursor = ::LoadCursor( NULL, IDC_ARROW );
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszClassName = TEXT("ThinFrameTestWnd");
        if( !RegisterClass( &wc ) )
            return;
    }

    HWND hwnd = CreateWindowEx( WS_EX_DLGMODALFRAME, wc.lpszClassName, TEXT("Thin Frame"), WS_CAPTION|WS_SYSMENU,
                                CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, *this, NULL, wc.hInstance, NULL );

    if( hwnd )
    {
        ::UpdateWindow(hwnd);
        ::ShowWindow(hwnd, SW_SHOW);

    }
}

void CMainFrame::OnDumpMetrics() 
{
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof(ncm);
    int iBorder;

    SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
    SystemParametersInfo( SPI_GETBORDER, 0, &iBorder, 0 );
    
    #define SPEW_NCM(i)         TRACE(TEXT("NONCLIENTMETRICS::") TEXT(#i) TEXT(":\t%d\n"), ncm.##i );
    #define SPEW_SYSMET(sm)     TRACE(TEXT(#sm) TEXT(":\t%d\n"), GetSystemMetrics(sm) );

    TRACE(TEXT("SPI_BORDER:\t%d\n"), iBorder);
    
    SPEW_NCM(iBorderWidth);
    SPEW_NCM(iScrollWidth);
    SPEW_NCM(iScrollHeight);
    SPEW_NCM(iCaptionWidth);
    SPEW_NCM(iCaptionHeight);
    SPEW_NCM(iSmCaptionWidth);
    SPEW_NCM(iSmCaptionHeight);
    SPEW_NCM(iMenuWidth);
    SPEW_NCM(iMenuHeight);

    SPEW_SYSMET( SM_CXVSCROLL )
    SPEW_SYSMET( SM_CYHSCROLL )
    SPEW_SYSMET( SM_CYCAPTION )
    SPEW_SYSMET( SM_CXBORDER )
    SPEW_SYSMET( SM_CYBORDER )
    SPEW_SYSMET( SM_CYVTHUMB )
    SPEW_SYSMET( SM_CXHTHUMB )
    SPEW_SYSMET( SM_CXICON )
    SPEW_SYSMET( SM_CYICON )
    SPEW_SYSMET( SM_CYMENU )
    SPEW_SYSMET( SM_CYVSCROLL )
    SPEW_SYSMET( SM_CXHSCROLL )
    SPEW_SYSMET( SM_SWAPBUTTON )
    SPEW_SYSMET( SM_CXSIZE )
    SPEW_SYSMET( SM_CYSIZE )

    SPEW_SYSMET( SM_CXFIXEDFRAME )
    SPEW_SYSMET( SM_CYFIXEDFRAME )
    SPEW_SYSMET( SM_CXSIZEFRAME )
    SPEW_SYSMET( SM_CYSIZEFRAME )

    SPEW_SYSMET( SM_CXEDGE )
    SPEW_SYSMET( SM_CYEDGE )
    SPEW_SYSMET( SM_CXSMICON )
    SPEW_SYSMET( SM_CYSMICON )
    SPEW_SYSMET( SM_CYSMCAPTION )
    SPEW_SYSMET( SM_CXSMSIZE )
    SPEW_SYSMET( SM_CYSMSIZE )
    SPEW_SYSMET( SM_CXMENUSIZE )
    SPEW_SYSMET( SM_CYMENUSIZE )
    SPEW_SYSMET( SM_CXMINIMIZED )
    SPEW_SYSMET( SM_CYMINIMIZED )
    SPEW_SYSMET( SM_CXMAXIMIZED )
    SPEW_SYSMET( SM_CYMAXIMIZED )
    SPEW_SYSMET( SM_CXDRAG )
    SPEW_SYSMET( SM_CYDRAG )
}

void _ToggleStyle( CWnd* pwnd, DWORD dwStyle )
{
    BOOL fStyle = pwnd->GetStyle() & dwStyle;
    
    pwnd->ModifyStyle( fStyle ? dwStyle : 0,
                       fStyle ? 0 : dwStyle );
    pwnd->SetWindowPos( NULL, 0, 0, 0, 0, 
                        SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_DRAWFRAME );
}

void CMainFrame::OnMinimizeBox() 
{
	_ToggleStyle( this, WS_MINIMIZEBOX );
}

void CMainFrame::OnUpdateMinimizeBox(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable( GetStyle() & WS_SYSMENU );
    pCmdUI->SetCheck( GetStyle() & WS_MINIMIZEBOX );
}

void CMainFrame::OnMaximizeBox() 
{
	_ToggleStyle( this, WS_MAXIMIZEBOX );
}

void CMainFrame::OnUpdateMaximizeBox(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable( GetStyle() & WS_SYSMENU );
    pCmdUI->SetCheck( GetStyle() & WS_MAXIMIZEBOX );
	
}

void CMainFrame::OnSysMenu() 
{
    _ToggleStyle( this, WS_SYSMENU );
}

void CMainFrame::OnUpdateSysMenu(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck( GetStyle() & WS_SYSMENU );
}


BOOL _MNCanClose(HWND hwnd)
{
    BOOL fRetVal = FALSE;
    
    TITLEBARINFO tbi = {sizeof(tbi)};

    //---- don't use GetSystemMenu() - has user handle leak issues ----
    if (GetTitleBarInfo(hwnd, &tbi))
    {
        //---- mask out the good bits ----
        DWORD dwVal = (tbi.rgstate[5] & (~(STATE_SYSTEM_PRESSED | STATE_SYSTEM_FOCUSABLE)));
        fRetVal = (dwVal == 0);     // only if no bad bits are left
    }

    if ( !fRetVal && TESTFLAG(GetWindowLong(hwnd, GWL_EXSTYLE), WS_EX_MDICHILD) )
    {
        HMENU hMenu = GetSystemMenu(hwnd, FALSE);
        MENUITEMINFO menuInfo; 

        menuInfo.cbSize = sizeof(MENUITEMINFO);
        menuInfo.fMask = MIIM_STATE;
        if ( GetMenuItemInfo(hMenu, SC_CLOSE, FALSE, &menuInfo) )
        {
            fRetVal = !(menuInfo.fState & MFS_GRAYED) ? TRUE : FALSE;
        } 
    }
    return fRetVal;
}

void CMainFrame::OnUpdateCloseBtn(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck( _MNCanClose(m_hWnd) );
}

void CMainFrame::OnCloseBtn() 
{
	HMENU hMenu = ::GetSystemMenu(m_hWnd, FALSE);

    if( hMenu )
    {
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID|MIIM_STATE;

        if( GetMenuItemInfo(hMenu, SC_CLOSE, FALSE, &mii ) )
        {
            if( TESTFLAG(mii.fState, MF_DISABLED) )
            {
                mii.fState &= ~MF_DISABLED;
            }
            else
            {
                mii.fState |= MF_DISABLED;
            }
            SetMenuItemInfo(hMenu, SC_CLOSE, FALSE, &mii);
            SetWindowPos( NULL, 0, 0, 0, 0, 
                          SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_DRAWFRAME );
        }

        DestroyMenu(hMenu);
    }
}


void CMainFrame::OnAltIcon() 
{
    HICON hIcon = NULL;
	m_fAltIcon = !m_fAltIcon;

    if( m_fAltIcon )
    {
        if( !m_hAltIcon )
            m_hAltIcon = LoadIcon( AfxGetResourceHandle(), MAKEINTRESOURCE(IDI_ALTICON) );
        hIcon = m_hAltIcon;
    }
    else
    {
        if( !m_hIcon )
            m_hIcon = LoadIcon( AfxGetResourceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME) );
        hIcon = m_hIcon;
    }

    if( hIcon )
    {
        SendMessage( WM_SETICON, ICON_BIG, (LPARAM)hIcon );
    }
}

void CMainFrame::OnUpdateAltIcon(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck( m_fAltIcon );
}

void CMainFrame::OnAltTitle() 
{
	m_fAltTitle = !m_fAltTitle;
    LPCTSTR pszTitle = NULL;

    if( m_fAltTitle )
    {
        if( m_csAltTitle.IsEmpty() )
            m_csAltTitle.LoadString( IDS_ALTTEXT );
        pszTitle = m_csAltTitle;
    }
    else
    {
        if( m_csTitle.IsEmpty() )
            m_csTitle.LoadString( IDR_MAINFRAME );
        pszTitle = m_csTitle;
    }

    if( pszTitle )
        SetWindowText( pszTitle );
}

void CMainFrame::OnUpdateAltTitle(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck( m_fAltTitle );
}


void CMainFrame::OnDcAppcompat() 
{
	m_fDcAppCompat = ! m_fDcAppCompat;
    if( m_fDcAppCompat )
        m_fDfcAppCompat = FALSE;

    SetWindowPos( NULL, 0, 0, 0, 0, 
                  SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_DRAWFRAME );
}

void CMainFrame::OnUpdateDcAppcompat(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_fDcAppCompat);
}

void CMainFrame::OnDfcAppcompat() 
{
	m_fDfcAppCompat = ! m_fDfcAppCompat;
    if( m_fDfcAppCompat )
        m_fDcAppCompat = FALSE;

    SetWindowPos( NULL, 0, 0, 0, 0, 
                  SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_DRAWFRAME );
}

void CMainFrame::OnUpdateDfcAppcompat(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_fDfcAppCompat);
}

void CMainFrame::OnNcPaint() 
{
    if( m_fDcAppCompat || m_fDfcAppCompat )
    {
        RECT rc, rcCaption;
        GetWindowRect(&rc);
        OffsetRect(&rc, -rc.left, -rc.top );

	    int cxFrame = GetSystemMetrics( SM_CXSIZEFRAME );
        int cyFrame = GetSystemMetrics( SM_CYSIZEFRAME );
        int cyCaption = GetSystemMetrics( SM_CYCAPTION );

        rcCaption = rc;
        rcCaption.left  += cxFrame;
        rcCaption.right -= cxFrame;
        rcCaption.top   += cyFrame;
        rcCaption.bottom = rcCaption.top + cyCaption;

        HDC hdc = ::GetWindowDC(*this);

        if( hdc )
        {
            if( m_fDcAppCompat )
            {
                DrawCaption( *this, hdc, &rcCaption, DC_GRADIENT|DC_ICON|DC_SMALLCAP|DC_TEXT|0x1000 );
            }
            else if( m_fDfcAppCompat )
            {
                int cxEdge = GetSystemMetrics(SM_CXEDGE);
                int cyEdge = GetSystemMetrics(SM_CYEDGE);
                int cxSize = GetSystemMetrics(SM_CXSIZE);
            
                InflateRect(&rcCaption, -cxEdge, -cyEdge);
                rcCaption.left = rcCaption.right - cxSize;

                CMDIFrameWnd::OnNcPaint();
                DrawFrameControl( hdc, &rcCaption, DFC_CAPTION, DFCS_CAPTIONCLOSE );
            }

            ::ReleaseDC(*this, hdc);
        }
    }
    else
    {
        CMDIFrameWnd::OnNcPaint();
    }
}

void CMainFrame::DoMinMaxStress()
{
    //  Set up restored position as 1/2 screen size:
    int cxScrn = GetSystemMetrics(SM_CXSCREEN);
    int cyScrn = GetSystemMetrics(SM_CYSCREEN);

    ShowWindow( SW_SHOWNORMAL );
    SetWindowPos( NULL, 
                  cxScrn/4, cyScrn/4, 
                  cxScrn/2, cyScrn/2, 
                  SWP_NOZORDER|SWP_NOACTIVATE );

    //  Make note of SHOWNORMAL window pos
    WINDOWINFO wiNormal0, wiNormal, wiTest;
    wiNormal.cbSize = wiTest.cbSize = sizeof(wiNormal);
    GetWindowInfo( m_hWnd, &wiNormal0 );

    int nCmdShowTest = SW_MINIMIZE;

    do
    {
        MSG msg;
        while( PeekMessage( &msg, m_hWnd, 0, 0, PM_REMOVE ) )
        {
            if( WM_KEYDOWN == msg.message && VK_ESCAPE == msg.wParam )
            {
                m_fMinMaxStress = FALSE;
                break;
            }
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        ShowWindow( nCmdShowTest );
        GetWindowInfo( m_hWnd, &wiTest );

        m_pwiNormal0 = &wiNormal0;
        ShowWindow( SW_SHOWNORMAL );
        m_pwiNormal0 = NULL;

        GetWindowInfo( m_hWnd, &wiNormal );

        if( RECTWIDTH(&wiNormal.rcWindow) != RECTWIDTH(&wiNormal0.rcWindow) ||
            RECTHEIGHT(&wiNormal.rcWindow) != RECTHEIGHT(&wiNormal0.rcWindow) )
        {
            OutputDebugString( TEXT("MDITEST: SW_SHOWNORMAL size mismatch!!!\n") );
            DebugBreak();
        }

        nCmdShowTest = nCmdShowTest==SW_MINIMIZE ? SW_MAXIMIZE : SW_MINIMIZE;

    } while( m_fMinMaxStress );

    m_fMinMaxStress = FALSE;

}

void CMainFrame::OnMinMaxStress() 
{
	m_fMinMaxStress = !m_fMinMaxStress;

    if( m_fMinMaxStress )
    {
        DoMinMaxStress();
    }
}

void CMainFrame::OnUpdateMinMaxStress(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_fMinMaxStress);
}

void CMainFrame::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos) 
{
	if( m_fMinMaxStress && m_pwiNormal0 )
    {
        if( 0 == (lpwndpos->flags & SWP_NOSIZE) )
        {
            if( lpwndpos->cx != RECTWIDTH(&m_pwiNormal0->rcWindow) ||
                lpwndpos->cy!= RECTHEIGHT(&m_pwiNormal0->rcWindow) )
            {
                OutputDebugString( TEXT("MDITEST: WM_WINDOWPOSCHANGING SW_SHOWNORMAL size mismatch!!!\n") );
                DebugBreak();
            }
        }
    }
    
    CMDIFrameWnd::OnWindowPosChanging(lpwndpos);
	
	// TODO: Add your message handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\mditest.cpp ===
// mditest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "mditest.h"

#include "MainFrm.h"
#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMditestApp

BEGIN_MESSAGE_MAP(CMditestApp, CWinApp)
	//{{AFX_MSG_MAP(CMditestApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMditestApp construction

CMditestApp::CMditestApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMditestApp object

CMditestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMditestApp initialization

BOOL CMditestApp::InitInstance()
{
	// Standard initialization

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));



	CMDIFrameWnd* pFrame = new CMainFrame;
	m_pMainWnd = pFrame;

	// create main MDI frame window
	if (!pFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;

	// try to load shared MDI menus and accelerator table

	HINSTANCE hInst = AfxGetResourceHandle();
	m_hMDIMenu  = ::LoadMenu(hInst, MAKEINTRESOURCE(IDR_MDITESTYPE));
	m_hMDIAccel = ::LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_MDITESTYPE));


	pFrame->ShowWindow(m_nCmdShow);
	pFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMditestApp message handlers

int CMditestApp::ExitInstance() 
{
	if (m_hMDIMenu != NULL)
		FreeResource(m_hMDIMenu);
	if (m_hMDIAccel != NULL)
		FreeResource(m_hMDIAccel);

	return CWinApp::ExitInstance();
}

void CMditestApp::OnFileNew() 
{
	CMainFrame* pFrame = STATIC_DOWNCAST(CMainFrame, m_pMainWnd);

	// create a new MDI child window
	pFrame->CreateNewChild(
		RUNTIME_CLASS(CChildFrame), IDR_MDITESTYPE, m_hMDIMenu, m_hMDIAccel);
}



/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMditestApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMditestApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\mditest.h ===
// mditest.h : main header file for the MDITEST application
//

#if !defined(AFX_MDITEST_H__27AEDBDF_9E95_455B_BA25_B8C40137B1E9__INCLUDED_)
#define AFX_MDITEST_H__27AEDBDF_9E95_455B_BA25_B8C40137B1E9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMditestApp:
// See mditest.cpp for the implementation of this class
//

class CMditestApp : public CWinApp
{
public:
	CMditestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMditestApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
protected:
	HMENU m_hMDIMenu;
	HACCEL m_hMDIAccel;

public:
	//{{AFX_MSG(CMditestApp)
	afx_msg void OnAppAbout();
	afx_msg void OnFileNew();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MDITEST_H__27AEDBDF_9E95_455B_BA25_B8C40137B1E9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mditest.rc
//
#define IDC_APPLY                       3
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_MDITESTYPE                  129
#define IDR_AWRMENU                     130
#define IDS_ALTTEXT                     130
#define IDD_CHANGEMETRICS               132
#define IDD_THINFRAME                   134
#define IDI_ALTICON                     136
#define IDC_CAPTIONWIDTH                1001
#define IDC_CAPTIONFONTDESCR            1002
#define IDC_CAPTIONFONT                 1003
#define IDC_CAPTIONHEIGHT               1004
#define IDC_SCROLLBARWIDTH              1005
#define IDC_SCROLLBARHEIGHT             1006
#define IDC_BORDERWIDTH                 1007
#define IDC_MENUWIDTH                   1009
#define IDC_MENUHEIGHT                  1010
#define IDC_CAPTIONWIDTH2               1011
#define IDC_SMCAPTIONWIDTH              1011
#define IDC_CAPTIONHEIGHT2              1012
#define IDC_SMCAPTIONHEIGHT             1012
#define IDC_CAPTIONFONTDESCR2           1013
#define IDC_CAPTIONFONT2                1014
#define ID_FULLSCRNMAXIMIZED            32771
#define ID_FULLMDIMAXIMIZED             32772
#define ID_AWRWINDOW                    32773
#define ID_AWRWINDOWMENU                32774
#define ID_CLOSE                        32775
#define ID_NONCLIENTMETRICS             32776
#define ID_THINFRAME                    32777
#define ID_DUMPMETRICS                  32778
#define ID_SYSMENU                      32779
#define ID_MAXIMIZEBOX                  32780
#define ID_MINIMIZEBOX                  32781
#define ID_CLOSEBTN                     32782
#define ID_TOOLFRAME                    32783
#define ID_ALTICON                      32784
#define ID_ALTTEXT                      32785
#define IDC_DFCAPPCOMPAT                32786
#define IDC_DCAPPCOMPAT                 32787
#define ID_MINMAXSTRESS                 32788

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         32789
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\rgn.cpp ===
//-------------------------------------------------------------------------//
//  Rgn.cpp - Bitmap-to-Region transforms
//
//  History:
//  01/31/2000  scotthan   created
//-------------------------------------------------------------------------//

#include "stdafx.h"
#include "rgn.h"

//------------//
//  Helpers:

//-------------------------------------------------------------------------//
#define CX_USEDEFAULT   -1
#define CY_USEDEFAULT   -1

#define _ABS( val1, val2 )   ((val1)>(val2) ? (val1)-(val2) : (val2)-(val1))

//-------------------------------------------------------------------------//
inline BOOL IsColorMatch( COLORREF rgb1, COLORREF rgb2, int nTolerance = 0 )
{
    if( nTolerance == 0 )
        return (rgb1 << 8) == (rgb2 << 8);

    return _ABS(GetRValue(rgb1),GetRValue(rgb2)) <= nTolerance &&
           _ABS(GetGValue(rgb1),GetGValue(rgb2)) <= nTolerance &&
           _ABS(GetBValue(rgb1),GetBValue(rgb2)) <= nTolerance;
}

//-------------------------------------------------------------------------//
inline BOOL _IsNormalRect( IN LPCRECT prc )
{
    return (prc->right >= prc->left) &&
           (prc->bottom >= prc->top);
}

//-------------------------------------------------------------------------//
inline BOOL _IsOnScreenRect( IN LPCRECT prc )
{
    return prc->left >= 0 && prc->top >= 0 &&
           prc->right >= 0 && prc->bottom >= 0;
}

//-------------------------------------------------------------------------//
inline void _InPlaceUnionRect( IN OUT LPRECT prcDest, IN LPCRECT prcSrc )
{
    _ASSERTE(prcDest);
    _ASSERTE(prcSrc);
    _ASSERTE(_IsNormalRect(prcSrc));

    if( prcDest->left == -1 || prcDest->left > prcSrc ->left )
        prcDest->left = prcSrc ->left;

    if( prcDest->right == -1 || prcDest->right < prcSrc ->right )
        prcDest->right = prcSrc ->right;

    if( prcDest->top == -1 || prcDest->top > prcSrc ->top )
        prcDest->top = prcSrc ->top;

    if( prcDest->bottom == -1 || prcDest->bottom < prcSrc ->bottom )
        prcDest->bottom = prcSrc ->bottom;
}

//-------------------------------------------------------------------------//
//  Walks the pixels and computes the region
HRGN WINAPI _PixelsToRgn( 
    DWORD *pdwBits,
    int cxImageOffset,  // image cell horz offset
    int cyImageOffset,  // image cell vert offset
    int cxImage,        // image cell width
    int cyImage,        // image cell height
    int cxSrc,          // src bitmap width
    int cySrc,          // src bitmap height
    BOOL fAlphaChannel,
    int iAlphaThreshold,
    COLORREF rgbMask, 
    int nMaskTolerance )
{
    //  Establish a series of rectangles, each corresponding to a scan line (row)
    //  in the bitmap, that will comprise the region.
    const UINT RECTBLOCK = 512;
    UINT       nAllocRects = 0;
    HRGN       hrgnRet = NULL;
    HGLOBAL    hrgnData = GlobalAlloc( GMEM_MOVEABLE, 
                                    sizeof(RGNDATAHEADER) + (sizeof(RECT) * (nAllocRects + RECTBLOCK)) );

    if( hrgnData )
    {
        nAllocRects += RECTBLOCK;

        RGNDATA* prgnData = (RGNDATA*)GlobalLock( hrgnData );
        LPRECT   prgrc    = (LPRECT)prgnData->Buffer;

        ZeroMemory( prgnData, sizeof(prgnData->rdh) );
        prgnData->rdh.dwSize   = sizeof(prgnData->rdh);
        prgnData->rdh.iType    = RDH_RECTANGLES;
        SetRect( &prgnData->rdh.rcBound, -1, -1, -1, -1 );

        int cxMax = cxImageOffset + cxImage;
        int cyMax = cyImageOffset + cyImage;

        //  Compute a transparency mask if not specified.
        if( -1 == rgbMask )
            rgbMask = pdwBits[cxImageOffset + ((cyMax-1) * cxSrc)];

        //---- pixels in pdwBits[] have RBG's reversed ----
        //---- reverse our mask to match ----
        rgbMask = REVERSE3(rgbMask);        

        //---- rows in pdwBits[] are reversed (bottom to top) ----
        for( int y = cyImageOffset; y < cyMax; y++ ) // working bottom-to-top
        {
            //---- Scanning pixels left to right ----
            DWORD *pdwFirst = &pdwBits[cxImageOffset + y * cxSrc];
            DWORD *pdwLast = pdwFirst + cxImage - 1;
            DWORD *pdwPixel = pdwFirst;

            while (pdwPixel <= pdwLast)
            {
                //---- skip TRANSPARENT pixels to find next OPAQUE (on this row) ----
                if (fAlphaChannel)
                {
                    while ((pdwPixel <= pdwLast) && (ALPHACHANNEL(*pdwPixel) < iAlphaThreshold))
                        pdwPixel++;
                }
                else
                {
                    while ((pdwPixel <= pdwLast) && (IsColorMatch(*pdwPixel, rgbMask, nMaskTolerance)))
                        pdwPixel++;
                }

                if (pdwPixel > pdwLast)     // too far; try next row
                    break;       

                DWORD *pdw0 = pdwPixel;
                pdwPixel++;             // skip over current opaque pixel

                //---- skip OPAQUE pixels to find next TRANSPARENT (on this row) ----
                if (fAlphaChannel)
                {
                    while ((pdwPixel <= pdwLast) && (ALPHACHANNEL(*pdwPixel) >= iAlphaThreshold))
                        pdwPixel++;
                }
                else
                {
                    while ((pdwPixel <= pdwLast) && (! IsColorMatch(*pdwPixel, rgbMask, nMaskTolerance)))
                        pdwPixel++;
                }

                //---- got a stream of 1 or more opaque pixels on this row ----

                //  allocate more region rects if necessary (a particularly complex line)
                if( prgnData->rdh.nCount >= nAllocRects )
                {
                    GlobalUnlock( hrgnData );
                    prgnData = NULL;
                    hrgnData = GlobalReAlloc( hrgnData, 
                            sizeof(RGNDATAHEADER) + (sizeof(RECT) * (nAllocRects + RECTBLOCK)),
                            GMEM_MOVEABLE );

                    if( hrgnData )
                    {
                        nAllocRects += RECTBLOCK;
                        prgnData = (RGNDATA*)GlobalLock( hrgnData );
                        prgrc    = (LPRECT)prgnData->Buffer;
                        _ASSERTE(prgnData);
                    }
                }
                
                //  assign region rectangle
                int x0 = (int)(pdw0 - pdwFirst);
                int x = (int)(pdwPixel - pdwFirst);
                int y0 = y - cyImageOffset;

                SetRect( prgrc + prgnData->rdh.nCount, 
                         x0, cyMax - (y0+1), 
                         x,  cyMax - y0 );
                
                //  merge into bounding box
                _InPlaceUnionRect( &prgnData->rdh.rcBound, 
                                   prgrc + prgnData->rdh.nCount );
                prgnData->rdh.nCount++;

            } // while ()
        } // for(y)

        if( prgnData->rdh.nCount && _IsOnScreenRect(&prgnData->rdh.rcBound) )
        {
            //  Create the region representing the scan line.
            hrgnRet = ExtCreateRegion( NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT) * nAllocRects),
                                       prgnData );
        }

        // Free region def block.
        GlobalUnlock( hrgnData );
        GlobalFree( hrgnData );
    }

    return hrgnRet;
}

//-------------------------------------------------------------------------//
//  Creates a region based on a text string in the indicated font.
HRGN WINAPI CreateTextRgn( HFONT hf, LPCTSTR pszText )
{
    HRGN hrgnRet = NULL;

    if( pszText && *pszText )
    {
        int   cchText = lstrlen( pszText );

        //  Create a composite DC for assembling the region.
        HDC  hdcMem = CreateCompatibleDC( NULL );

        SetBkMode( hdcMem, TRANSPARENT );
        SetTextAlign( hdcMem, TA_TOP|TA_LEFT );
        HFONT hfOld = (HFONT)SelectObject( hdcMem, hf );

        //  Derive a region from a path.
        BeginPath( hdcMem );
        TextOut( hdcMem, 0, 0, pszText, cchText );
        EndPath( hdcMem );

        hrgnRet = PathToRegion( hdcMem );

        //  Clean up composite DC
        SelectObject( hdcMem, hfOld );
        DeleteDC( hdcMem );
    }

    return hrgnRet;
}

//-------------------------------------------------------------------------//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional 
//  (-1 == use the value of the first pixel as the key).
//
HRESULT WINAPI CreateBitmapRgn( 
    HBITMAP hbm, 
    int cxOffset,
    int cyOffset,
    int cx,
    int cy,
    BOOL fAlphaChannel,
    int iAlphaThreshold,
    COLORREF rgbMask, 
    int nMaskTolerance,
    OUT HRGN *phrgn)
{
    CBitmapPixels BitmapPixels;
    DWORD         *prgdwPixels;
    int           cwidth, cheight;

    HRESULT hr = BitmapPixels.OpenBitmap(NULL, hbm, TRUE, &prgdwPixels, &cwidth, &cheight);
    if (FAILED(hr))
        return hr;

    if (cx <= 0)
        cx = cwidth;

    if (cy <= 0)
        cy = cheight;

    HRGN hrgn = _PixelsToRgn(prgdwPixels, cxOffset, cyOffset, cx, cy, cwidth, cheight, fAlphaChannel,
        iAlphaThreshold, rgbMask, nMaskTolerance);
    
    if (! hrgn)
        return E_FAIL;

    *phrgn = hrgn;
    return S_OK;
}

//-------------------------------------------------------------------------//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional (-1 ==
//  use the value of the first pixel as the key).
//
HRGN WINAPI CreateScaledBitmapRgn( 
    HBITMAP hbm, 
    int cx,
    int cy,
    COLORREF rgbMask, 
    int nMaskTolerance )
{
    HRGN   hrgnRet = NULL;
    BITMAP bm;

    if( hbm && GetObject( hbm, sizeof(bm), &bm ) )
    {
        //  Create a memory DC to do the pixel walk
        HDC hdcMem = NULL;
        if( (hdcMem = CreateCompatibleDC(NULL)) != NULL )
        {
            if( CX_USEDEFAULT == cx )
                cx = bm.bmWidth;
            if( CY_USEDEFAULT == cy )
                cy = bm.bmHeight;

            //  Create a 32-bit empty bitmap for the walk
            BITMAPINFO bmi;
            ZeroMemory( &bmi, sizeof(bmi) );
            bmi.bmiHeader.biSize        = sizeof(bmi.bmiHeader);
            bmi.bmiHeader.biWidth       = cx;
            bmi.bmiHeader.biHeight      = cy;
            bmi.bmiHeader.biPlanes      = 1;
            bmi.bmiHeader.biBitCount    = 32;
            bmi.bmiHeader.biCompression = BI_RGB; // uncompressed.

            VOID*   pvBits = NULL;
            HBITMAP hbmMem  = CreateDIBSection( hdcMem, &bmi, DIB_RGB_COLORS, &pvBits, NULL, NULL );
            BITMAP  bmMem;

            if( hbmMem )
            {
                //  Transfer the image to our 32-bit format for the pixel walk.
                HBITMAP hbmMemOld = (HBITMAP)SelectObject( hdcMem, hbmMem );
                HDC hdc = CreateCompatibleDC( hdcMem );
                HBITMAP hbmOld = (HBITMAP)SelectObject( hdc, hbm );

                StretchBlt( hdcMem, 0, 0, cx, cy, 
                            hdc, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
                SelectObject( hdc, hbmOld );
                DeleteDC( hdc );
                
                GetObject( hbmMem, sizeof(bmMem), &bmMem );
                _ASSERTE(bmMem.bmBitsPixel == 32);
                _ASSERTE(bmMem.bmWidthBytes/bmMem.bmWidth == sizeof(DWORD));
                LPDWORD pdwBits = (LPDWORD)bmMem.bmBits;
                _ASSERTE(pdwBits != NULL);

                hrgnRet = _PixelsToRgn(pdwBits, 0, 0, cx, cy, cx, cy, FALSE, 0, rgbMask, nMaskTolerance);
              
                //  Delete 32-bit memory bitmap
                SelectObject( hdcMem, hbmMemOld ); 
                DeleteObject( hbmMem ); 
            }
            //  Delete memory DC
            DeleteDC(hdcMem);

        }
    }
    return hrgnRet;
}

//-------------------------------------------------------------------------//
int WINAPI AddToCompositeRgn( 
    IN OUT HRGN* phrgnComposite, 
    IN OUT HRGN hrgnSrc, 
    IN int cxOffset, 
    IN int cyOffset )
{
    int nRet = ERROR;

    if( NULL != phrgnComposite && NULL != hrgnSrc )
    {
        nRet = OffsetRgn( hrgnSrc, cxOffset, cyOffset );
        if( nRet != ERROR )
        {
            int nMode = RGN_OR;
            if( NULL == *phrgnComposite )
            {
                *phrgnComposite = CreateRectRgn(0,0,1,1);
                if( NULL == *phrgnComposite )
                    return ERROR;
                nMode = RGN_COPY;
            }
            nRet = CombineRgn( *phrgnComposite, hrgnSrc, *phrgnComposite, nMode );
        }
    }

    return nRet;
}

//-------------------------------------------------------------------------//
int WINAPI RemoveFromCompositeRgn( 
    HRGN hrgnDest, 
    LPCRECT prcRemove )
{
    _ASSERTE(hrgnDest);
    _ASSERTE(prcRemove);
    _ASSERTE(!IsRectEmpty(prcRemove));

    int nRet = ERROR;
    
    RECT rc = *prcRemove;
    HRGN hrgn;
    if( (hrgn = CreateRectRgnIndirect( &rc )) != NULL )
    {
        nRet = CombineRgn( hrgnDest, hrgnDest, hrgn, RGN_DIFF );
        DeleteObject( hrgn );
    }
    return nRet;
}

//-------------------------------------------------------------------------//
HRGN WINAPI CreateTiledRectRgn( 
    IN HRGN hrgnSrc, 
    IN int cxSrc, 
    IN int cySrc, 
    IN int cxDest, 
    IN int cyDest )
{
    HRGN hrgnBound = NULL; // return value
    HRGN hrgnTile = _DupRgn( hrgnSrc );

    if( hrgnTile )
    {
        //  Build up an unplaced, unclipped composite
        HRGN hrgnTmp = NULL;
        for( int y = 0; y < cyDest; y += cySrc )
        {
            for( int x = 0; x < cxDest; x += cxSrc )
            {
                AddToCompositeRgn( &hrgnTmp, hrgnTile, 
                                   (x ? cxSrc  : 0), (y ? cySrc : 0) );
            }
        }

        if( NULL != hrgnTmp )
        {
            //  Clip the composite to the specified rectangle
            hrgnBound = CreateRectRgn( 0, 0, cxDest, cyDest );
            if( hrgnBound )
            {
                
                if( ERROR == CombineRgn( hrgnBound, hrgnTmp, hrgnBound, RGN_AND ) )
                {
                    DeleteObject( hrgnBound );
                    hrgnBound = NULL;
                }
            }
            DeleteObject( hrgnTmp );   
        }
        DeleteObject( hrgnTile );
    }
    return hrgnBound;
}

//-------------------------------------------------------------------------//
HRGN WINAPI _DupRgn( HRGN hrgnSrc )
{
    if( hrgnSrc )
    {
        HRGN hrgnDest = CreateRectRgn(0,0,1,1);
        if (hrgnDest)
        {
            if (CombineRgn( hrgnDest, hrgnSrc, NULL, RGN_COPY ) )
                return hrgnDest;
    
            DeleteObject(hrgnDest);
        }
    }
    return NULL; 
}

//-------------------------------------------------------------------------//
//  _InternalHitTestRgn()
typedef enum  //  _InternalHitTestRgn return values:
{
    HTRGN_ERROR      = 0x0000,
    HTRGN_LEFT       = 0x0001,
    HTRGN_TOP        = 0x0002,
    HTRGN_RIGHT      = 0x0004,
    HTRGN_BOTTOM     = 0x0008,
    HTRGN_INSIDE     = 0x0010,
    HTRGN_OUTSIDE    = 0x0020,
} HTRGN;

UINT WINAPI _InternalHitTestRgn( 
    HRGN hrgn, 
    POINT pt, 
    DWORD dwHitMask, 
    UINT  cxMargin,
    UINT  cyMargin )
{
    UINT nRet = HTRGN_ERROR; 
    RECT rcBox;

    nRet |= PtInRegion( hrgn, pt.x, pt.y ) ? HTRGN_INSIDE : HTRGN_OUTSIDE;
    dwHitMask &= ~(HTRGN_INSIDE|HTRGN_OUTSIDE);
    
    if( (nRet & HTRGN_INSIDE) != 0 && 
        (dwHitMask != 0) && GetRgnBox( hrgn, &rcBox ) )
    {
        int x, y;
        if( dwHitMask & HTRGN_LEFT )
        {
            if( cxMargin )
            {
                //  move left until we're out of the region.
                for( x = pt.x; x >= rcBox.left && PtInRegion( hrgn, x, pt.y ); x-- );

                //  are we still in test range?
                if( pt.x - x < (int)cxMargin )
                    nRet |= HTRGN_LEFT;
            }
            else
                nRet |= HTRGN_LEFT;
        }

        if( dwHitMask & HTRGN_RIGHT )
        {
            if( cxMargin )
            {
                //  move right until we're out of the region.
                for( x = pt.x; x <= rcBox.right && PtInRegion( hrgn, x, pt.y ); x++ );

                //  are we still in test range?
                if( x - pt.x < (int)cxMargin )
                    nRet |= HTRGN_RIGHT;
            }
            else
                nRet |= HTRGN_RIGHT;
        }

        if( dwHitMask & HTRGN_TOP )
        {
            if( cyMargin )
            {
                //  move up until we're out of the region.
                for( y = pt.y; y >= rcBox.top && PtInRegion( hrgn, pt.x, y ); y-- );

                //  are we still in test range?
                if( pt.y - y < (int)cyMargin )
                    nRet |= HTRGN_TOP;
            }
            else
                nRet |= HTRGN_TOP;

        }

        if( dwHitMask & HTRGN_BOTTOM )
        {
            if( cyMargin )
            {
                //  move left until we're out of the region.
                for( y = pt.y; y <= rcBox.bottom && PtInRegion( hrgn, pt.x, y ); y++ );

                //  are we still in test range?
                if( y - pt.y < (int)cyMargin )
                    nRet |= HTRGN_BOTTOM;
            }
            else
                nRet |= HTRGN_BOTTOM;
        }
    }
    return nRet;

}

//-------------------------------------------------------------------------//
UINT _HitMaskFromHitCode( BOOL fHasCaption, WORD wSegmentHTCode, WORD* pnHTDefault )
{
    UINT nHitMask = 0;
    WORD nHTDefault = HTBORDER;

    switch (wSegmentHTCode)
    {
        case HTLEFT:
            nHitMask = HTRGN_LEFT;
            break;

        case HTTOPLEFT:
            nHitMask = HTRGN_TOP | HTRGN_LEFT;
            if( fHasCaption )
                nHTDefault = HTCAPTION;
            break;

        case HTBOTTOMLEFT:
            nHitMask = HTRGN_BOTTOM | HTRGN_LEFT;
            break;

        case HTTOP:
            nHitMask = HTRGN_TOP;
            if( fHasCaption )
                nHTDefault = HTCAPTION;
            break;

        case HTBOTTOM:
            nHitMask = HTRGN_BOTTOM;
            break;

        case HTTOPRIGHT:
            nHitMask = HTRGN_TOP | HTRGN_RIGHT;
            if( fHasCaption )
                nHTDefault = HTCAPTION;
            break;

        case HTRIGHT:
            nHitMask = HTRGN_RIGHT;
            break;

        case HTBOTTOMRIGHT:
            nHitMask = HTRGN_BOTTOM | HTRGN_RIGHT;
            break;
    }

    if( pnHTDefault ) *pnHTDefault = nHTDefault;
    return nHitMask;
}

//-------------------------------------------------------------------------//
WORD _HitCodeFromHitMask( UINT nHitMask, WORD nHTDefault )
{
    switch( nHitMask )
    {
        case HTRGN_LEFT:
            return HTLEFT;

        case HTRGN_RIGHT:
            return HTRIGHT;

        case HTRGN_TOP:
            return HTTOP;

        case HTRGN_BOTTOM:
            return HTBOTTOM;

        case HTRGN_TOP|HTRGN_LEFT:
            return HTTOPLEFT;

        case HTRGN_TOP|HTRGN_RIGHT:
            return HTTOPRIGHT;

        case HTRGN_BOTTOM|HTRGN_LEFT:
            return HTBOTTOMLEFT;

        case HTRGN_BOTTOM|HTRGN_RIGHT:
            return HTBOTTOMRIGHT;
    }
    return nHTDefault;
}

//-------------------------------------------------------------------------//
WORD WINAPI _HitTestRgn(    // can merge with _HitTestRgn() when it has no other callers
    HRGN hrgn, 
    POINT pt, 
    WORD  wSegmentHTCode,
    BOOL  fHasCaption,
    UINT  cxMargin,
    UINT  cyMargin )
{
    WORD nHTDefault = HTBORDER;
    UINT nHitMask   = _HitMaskFromHitCode( fHasCaption, wSegmentHTCode, &nHTDefault );
    UINT fHTRgn     = _InternalHitTestRgn( hrgn, pt, nHitMask|HTRGN_INSIDE, 
                                         cxMargin, cyMargin );
    
    if( fHTRgn & HTRGN_INSIDE )
    {
        fHTRgn &= ~HTRGN_INSIDE;
        return _HitCodeFromHitMask( fHTRgn, nHTDefault );
    }

    return HTNOWHERE;
}

//-------------------------------------------------------------------------//
HRESULT WINAPI _ScaleRectsAndCreateRegion(
    RGNDATA     *prd, 
    const RECT  *prc,
    MARGINS     *pMargins,
    HRGN        *phrgn)
{
    //---- note: "prd" is region data with the 2 points in each ----
    //---- rectangle made relative to its grid.  Also, after the points, ----
    //---- there is a BYTE for each point signifying the grid id (0-8) ----
    //---- that each point lies within.  the grid is determined using ----
    //---- the original region with the background "margins".   This is ----
    //---- done to make scaling the points as fast as possible. ----

    if (! prd)                  // required
        return E_POINTER;

    RECT rcBox = prd->rdh.rcBound;

    //---- compute margin values ----
    int lwFrom = rcBox.left + pMargins->cxLeftWidth;
    int rwFrom = rcBox.right - pMargins->cxRightWidth;
    int thFrom = rcBox.top + pMargins->cyTopHeight;
    int bhFrom = rcBox.bottom - pMargins->cyBottomHeight;

    int lwTo = prc->left + pMargins->cxLeftWidth;
    int rwTo = prc->right - pMargins->cxRightWidth;
    int thTo = prc->top + pMargins->cyTopHeight;
    int bhTo = prc->bottom - pMargins->cyBottomHeight;

    //---- compute offsets & factors ----
    int iLeftXOffset = prc->left;
    int iMiddleXOffset = lwTo;
    int iRightXOffset = rwTo;

    int iTopYOffset = prc->top;
    int iMiddleYOffset = thTo;
    int iBottomYOffset = bhTo;
        
    int iXMult = rwTo - lwTo;
    int iXDiv = rwFrom - lwFrom;
    int iYMult = bhTo - thTo;
    int iYDiv = bhFrom - thFrom;

    //---- allocte a buffer for the new points (rects) ----
    int newlen = sizeof(RGNDATAHEADER) + prd->rdh.nRgnSize;    // same # of rects
    BYTE *newData = (BYTE *)new BYTE[newlen];
    
    RGNDATA *prdNew = (RGNDATA *)newData;
    if (! prdNew)
        return E_OUTOFMEMORY;

    ZeroMemory(prdNew, sizeof(prd->rdh));

    prdNew->rdh.dwSize = sizeof(prdNew->rdh);
    prdNew->rdh.iType  = RDH_RECTANGLES;
    int cRects         = prd->rdh.nCount;
    prdNew->rdh.nCount = cRects;
    SetRect(&prdNew->rdh.rcBound, -1, -1, -1, -1);

    //---- step thru our custom data (POINT + BYTE combos) ----
    POINT *pt     = (POINT *)prd->Buffer;
    BYTE *pByte   = (BYTE *)prd->Buffer + prd->rdh.nRgnSize;
    int cPoints   = 2 * cRects;
    POINT *ptNew  = (POINT *)prdNew->Buffer;

    for (int i=0; i < cPoints; i++, pt++, pByte++, ptNew++)        // transform each "point"
    {
        switch (*pByte)
        {
            case GN_LEFTTOP:                 // left top
                ptNew->x = pt->x + iLeftXOffset;
                ptNew->y = pt->y + iTopYOffset;
                break;

            case GN_MIDDLETOP:               // middle top
                ptNew->x = (pt->x*iXMult)/iXDiv + iMiddleXOffset;
                ptNew->y = pt->y + iTopYOffset;
                break;

            case GN_RIGHTTOP:                // right top
                ptNew->x = pt->x + iRightXOffset;
                ptNew->y = pt->y + iTopYOffset;
                break;

            case GN_LEFTMIDDLE:              // left middle
                ptNew->x = pt->x + iLeftXOffset;
                ptNew->y = (pt->y*iYMult)/iYDiv + iMiddleYOffset;
                break;

            case GN_MIDDLEMIDDLE:            // middle middle
                ptNew->x = (pt->x*iXMult)/iXDiv + iMiddleXOffset;
                ptNew->y = (pt->y*iYMult)/iYDiv + iMiddleYOffset;
                break;

            case GN_RIGHTMIDDLE:             // right middle
                ptNew->x = pt->x + iRightXOffset;
                ptNew->y = (pt->y*iYMult)/iYDiv + iMiddleYOffset;
                break;

            case GN_LEFTBOTTOM:              // left bottom
                ptNew->x = pt->x + iLeftXOffset;
                ptNew->y = pt->y + iBottomYOffset;
                break;

            case GN_MIDDLEBOTTOM:             // middle bottom
                ptNew->x = (pt->x*iXMult)/iXDiv + iMiddleXOffset;
                ptNew->y = pt->y + iBottomYOffset;
                break;

            case GN_RIGHTBOTTOM:              // right bottom
                ptNew->x = pt->x + iRightXOffset;
                ptNew->y = pt->y + iBottomYOffset;
                break;
        }
    }

    //---- compute bounding box of new region ----
    RECT *pRect = (RECT *)prdNew->Buffer;
    RECT newBox = {-1, -1, -1, -1};

    for (i=0; i < cRects; i++, pRect++)
        _InPlaceUnionRect(&newBox, pRect);

    //---- create the new region ----
    prdNew->rdh.rcBound = newBox;
    HRGN hrgn = ExtCreateRegion(NULL, newlen, prdNew);
    
    delete [] newData;          // free prdNew (aka newdata)
    if (! hrgn)
        return GetLastError();

    *phrgn = hrgn;
    return S_OK;
}

//-------------------------------------------------------------------------//
WORD WINAPI _DefaultHitCodeFromSegCode( BOOL fHasCaption, WORD wSegHTcode )
{
    WORD nHTDefault;
    _HitMaskFromHitCode( fHasCaption, wSegHTcode, &nHTDefault );
    return nHTDefault;
}

//---------------------------------------------------------------------------------//
#ifdef _DEBUG
void RegionDebug(
  HRGN hrgn)
{
    DWORD len = GetRegionData(hrgn, 0, NULL);       // get required length
    ASSERT(len);

    RGNDATA *pRgnData = (RGNDATA *) new BYTE[len + sizeof(RGNDATAHEADER)];
    DWORD len2 = GetRegionData(hrgn, len, pRgnData);
    ASSERT(len == len2);
    
    int cnt = pRgnData->rdh.nCount;
    RECT rect = pRgnData->rdh.rcBound;
}
#endif


//-------------------------------------------------------------------------
CBitmapPixels::CBitmapPixels()
{
    _hdrBitmap = NULL;
    _iWidth = 0;
    _iHeight = 0;
}
//-------------------------------------------------------------------------
CBitmapPixels::~CBitmapPixels()
{
    if (_hdrBitmap)
	    delete [] (BYTE *)_hdrBitmap;
}
//-------------------------------------------------------------------------
HRESULT CBitmapPixels::OpenBitmap(HDC hdc, HBITMAP bitmap, BOOL fForceRGB32,
    DWORD OUT **pPixels, OPTIONAL OUT int *piWidth, OPTIONAL OUT int *piHeight, 
    OPTIONAL OUT int *piBytesPerPixel, OPTIONAL OUT int *piBytesPerRow)
{
    if (! pPixels)
        return E_INVALIDARG;

	BITMAP bminfo;
	
    GetObject(bitmap, sizeof(bminfo), &bminfo);
	_iWidth = bminfo.bmWidth;
	_iHeight = bminfo.bmHeight;

    int iBytesPerPixel;
    if ((fForceRGB32) || (bminfo.bmBitsPixel == 32)) 
        iBytesPerPixel = 4;
    else
        iBytesPerPixel = 3;
    
    int iRawBytes = _iWidth * iBytesPerPixel;
    int iBytesPerRow = 4*((iRawBytes+3)/4);

	int size = sizeof(BITMAPINFOHEADER) + _iHeight*iBytesPerRow;
	BYTE *dibBuff = new BYTE[size+100];    // avoid random GetDIBits() failures with 100 bytes padding (?)
    if (! dibBuff)
        return E_OUTOFMEMORY;

	_hdrBitmap = (BITMAPINFOHEADER *)dibBuff;
	memset(_hdrBitmap, 0, sizeof(BITMAPINFOHEADER));

	_hdrBitmap->biSize = sizeof(BITMAPINFOHEADER);
	_hdrBitmap->biWidth = _iWidth;
	_hdrBitmap->biHeight = _iHeight;
	_hdrBitmap->biPlanes = 1;
    _hdrBitmap->biBitCount = 8*iBytesPerPixel;
	_hdrBitmap->biCompression = BI_RGB;     
	
    bool fNeedRelease = false;

    if (! hdc)
    {
        hdc = GetWindowDC(NULL);
        fNeedRelease = true;
    }

    int linecnt = GetDIBits(hdc, bitmap, 0, _iHeight, DIBDATA(_hdrBitmap), (BITMAPINFO *)_hdrBitmap, 
        DIB_RGB_COLORS);
    ASSERT(linecnt == _iHeight);
    
    if (fNeedRelease)
        ReleaseDC(NULL, hdc);

	*pPixels = (DWORD *)DIBDATA(_hdrBitmap);

    if (piWidth)
        *piWidth = _iWidth;
    if (piHeight)
        *piHeight = _iHeight;

    if (piBytesPerPixel)
        *piBytesPerPixel = iBytesPerPixel;
    if (piBytesPerRow)
        *piBytesPerRow = iBytesPerRow;

    return S_OK;
}
//-------------------------------------------------------------------------
void CBitmapPixels::CloseBitmap(HDC hdc, HBITMAP hBitmap)
{
    if (_hdrBitmap)
    {
        if (hBitmap)        // rewrite bitmap
        {
            bool fNeedRelease = false;

            if (! hdc)
            {
                hdc = GetWindowDC(NULL);
                fNeedRelease = true;
            }

            SetDIBits(hdc, hBitmap, 0, _iHeight, DIBDATA(_hdrBitmap), (BITMAPINFO *)_hdrBitmap,
                DIB_RGB_COLORS);
        
            if ((fNeedRelease) && (hdc))
                ReleaseDC(NULL, hdc);
        }

	    delete [] (BYTE *)_hdrBitmap;
        _hdrBitmap = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__918137F4_65E3_4033_AF9C_74AAEEB223D5__INCLUDED_)
#define AFX_MAINFRM_H__918137F4_65E3_4033_AF9C_74AAEEB223D5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    void DoMinMaxStress();

	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;
	CReBar      m_wndReBar;
	CDialogBar      m_wndDlgBar;
    BOOL        m_fMinMaxStress;
    BOOL        m_fFullScrnMax;
    BOOL        m_fAltIcon;
    BOOL        m_fDfcAppCompat;
    BOOL        m_fDcAppCompat;
    HICON       m_hIcon;
    HICON       m_hAltIcon;
    BOOL        m_fAltTitle;
    CString     m_csTitle;
    CString     m_csAltTitle;
    WINDOWINFO* m_pwiNormal0;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnFullScrnMaximized();
	afx_msg void OnUpdateFullScrnMaximized(CCmdUI* pCmdUI);
	afx_msg void OnAwrWindow();
	afx_msg void OnAwrWindowMenu();
	afx_msg void OnNonClientMetrics();
	afx_msg void OnThinFrame();
	afx_msg void OnDumpMetrics();
	afx_msg void OnMinimizeBox();
	afx_msg void OnUpdateMinimizeBox(CCmdUI* pCmdUI);
	afx_msg void OnMaximizeBox();
	afx_msg void OnUpdateMaximizeBox(CCmdUI* pCmdUI);
	afx_msg void OnSysMenu();
	afx_msg void OnUpdateSysMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdateCloseBtn(CCmdUI* pCmdUI);
	afx_msg void OnCloseBtn();
	afx_msg void OnToolframe();
	afx_msg void OnAltIcon();
	afx_msg void OnUpdateAltIcon(CCmdUI* pCmdUI);
	afx_msg void OnAltTitle();
	afx_msg void OnUpdateAltTitle(CCmdUI* pCmdUI);
	afx_msg void OnDcAppcompat();
	afx_msg void OnUpdateDcAppcompat(CCmdUI* pCmdUI);
	afx_msg void OnDfcAppcompat();
	afx_msg void OnUpdateDfcAppcompat(CCmdUI* pCmdUI);
	afx_msg void OnNcPaint();
	afx_msg void OnMinMaxStress();
	afx_msg void OnUpdateMinMaxStress(CCmdUI* pCmdUI);
	afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__918137F4_65E3_4033_AF9C_74AAEEB223D5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\ncmetricsdlg.cpp ===
// NCMetricsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "mditest.h"
#include "NCMetricsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNCMetricsDlg dialog


CNCMetricsDlg::CNCMetricsDlg(CWnd* pParent /*=NULL*/)
	:   CDialog(CNCMetricsDlg::IDD, pParent),
        _fDlgInit(FALSE),
        _fChanged(FALSE)
{
    ZeroMemory( &_ncm, sizeof(_ncm) );
    _ncm.cbSize = sizeof(_ncm);
	//{{AFX_DATA_INIT(CNCMetricsDlg)
	//}}AFX_DATA_INIT
}


void CNCMetricsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNCMetricsDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNCMetricsDlg, CDialog)
	//{{AFX_MSG_MAP(CNCMetricsDlg)
	ON_EN_CHANGE(IDC_BORDERWIDTH, OnChanged)
	ON_BN_CLICKED(IDC_CAPTIONFONT, OnCaptionfont)
	ON_BN_CLICKED(IDC_CAPTIONFONT2, OnSmallCaptionFont)
	ON_BN_CLICKED(IDC_APPLY, OnApply)
	ON_EN_CHANGE(IDC_MENUWIDTH, OnChanged)
	ON_EN_CHANGE(IDC_MENUHEIGHT, OnChanged)
	ON_EN_CHANGE(IDC_SCROLLBARWIDTH, OnChanged)
	ON_EN_CHANGE(IDC_SCROLLBARHEIGHT, OnChanged)
	ON_EN_CHANGE(IDC_CAPTIONWIDTH, OnChanged)
	ON_EN_CHANGE(IDC_CAPTIONHEIGHT, OnChanged)
	ON_EN_CHANGE(IDC_CAPTIONWIDTH2, OnChanged)
	ON_EN_CHANGE(IDC_CAPTIONHEIGHT2, OnChanged)
	ON_EN_CHANGE(IDC_CAPTIONFONTDESCR, OnChanged)
	ON_EN_CHANGE(IDC_CAPTIONFONTDESCR2, OnChanged)
	ON_BN_CLICKED(IDOK, OnOk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNCMetricsDlg message handlers

BOOL CNCMetricsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
    _GetSPI( TRUE, TRUE );
    _fDlgInit = TRUE;
    _UpdateControls();
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNCMetricsDlg::_UpdateControls()
{
    ::EnableWindow( ::GetDlgItem( m_hWnd, IDC_APPLY ), _fChanged );
}

void CNCMetricsDlg::_GetSPI( BOOL fAcquire, BOOL fDlgSetValues )
{
    BOOL fSpi = fAcquire ? SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &_ncm, 0 ) : TRUE;

    if( fDlgSetValues )
    {
        SetDlgItemInt(IDC_BORDERWIDTH,     _ncm.iBorderWidth );
        
        SetDlgItemInt(IDC_SCROLLBARWIDTH,  _ncm.iScrollWidth );
        SetDlgItemInt(IDC_SCROLLBARHEIGHT, _ncm.iScrollHeight );
        
        SetDlgItemInt(IDC_MENUWIDTH,       _ncm.iMenuWidth );
        SetDlgItemInt(IDC_MENUHEIGHT,      _ncm.iMenuHeight );

	    SetDlgItemInt(IDC_CAPTIONWIDTH,    _ncm.iCaptionWidth );
	    SetDlgItemInt(IDC_CAPTIONHEIGHT,   _ncm.iCaptionHeight );
	    
	    SetDlgItemInt(IDC_SMCAPTIONWIDTH,    _ncm.iSmCaptionWidth );
	    SetDlgItemInt(IDC_SMCAPTIONHEIGHT,   _ncm.iSmCaptionHeight );

        int cyFont;
        TCHAR szFontDescr[128];

        HDC hdc = ::GetDC(NULL);

        cyFont = -MulDiv(_ncm.lfCaptionFont.lfHeight, 72, GetDeviceCaps(hdc, LOGPIXELSY));
        wsprintf( szFontDescr, TEXT("%s, %dpt"), _ncm.lfCaptionFont.lfFaceName, cyFont );
        SetDlgItemText(IDC_CAPTIONFONTDESCR, szFontDescr);
                  
        cyFont = -MulDiv(_ncm.lfSmCaptionFont.lfHeight, 72, GetDeviceCaps(hdc, LOGPIXELSY));
        wsprintf( szFontDescr, TEXT("%s, %dpt"), _ncm.lfSmCaptionFont.lfFaceName, cyFont );
        SetDlgItemText(IDC_CAPTIONFONTDESCR2, szFontDescr);

        ::ReleaseDC(NULL, hdc);

        _UpdateControls();
    }
}

void CNCMetricsDlg::_SetSPI( BOOL fAssign, BOOL fDlgSetValues )
{
    BOOL fGet = FALSE;

    if( fDlgSetValues )
    {    
        _ncm.iBorderWidth = GetDlgItemInt(IDC_BORDERWIDTH);
        
        _ncm.iScrollWidth = GetDlgItemInt(IDC_SCROLLBARWIDTH);
        _ncm.iScrollHeight = GetDlgItemInt(IDC_SCROLLBARHEIGHT);
        
        _ncm.iMenuWidth = GetDlgItemInt(IDC_MENUWIDTH);
        _ncm.iMenuHeight = GetDlgItemInt(IDC_MENUHEIGHT);

	    _ncm.iCaptionWidth = GetDlgItemInt(IDC_CAPTIONWIDTH);
	    _ncm.iCaptionHeight = GetDlgItemInt(IDC_CAPTIONHEIGHT);
	    
	    _ncm.iSmCaptionWidth = GetDlgItemInt(IDC_SMCAPTIONWIDTH);
	    _ncm.iSmCaptionHeight = GetDlgItemInt(IDC_SMCAPTIONHEIGHT );
    }

    if( fAssign )
    {
        SystemParametersInfo( SPI_SETNONCLIENTMETRICS, 0, &_ncm, 
                              SPIF_SENDCHANGE | SPIF_UPDATEINIFILE );
        _fChanged = FALSE;
    }
}

void CNCMetricsDlg::OnChanged() 
{
    _fChanged = _fDlgInit;
    _UpdateControls();
}

//-----------------------------------------------------------------------------------//
BOOL QueryCaptionFont( HWND hwndParent, LOGFONT* plf )
{
    LOGFONT lf = *plf;
    DWORD dwErr = 0;
	CHOOSEFONT cf;
    ZeroMemory( &cf, sizeof(cf) );
    cf.lStructSize = sizeof(cf);
    cf.hwndOwner = hwndParent;
    cf.lpLogFont = &lf;
    cf.iPointSize = 0;
    cf.Flags = CF_INITTOLOGFONTSTRUCT|CF_EFFECTS|CF_FORCEFONTEXIST|CF_SCREENFONTS;
    cf.lCustData; 
    cf.lpfnHook; 
    cf.lpszStyle; 
    cf.nFontType; 

    if( ChooseFont( &cf ) )
    {
        *plf = lf;
        return TRUE;
    }
    else
    {
        dwErr = CommDlgExtendedError();
    }
    return FALSE;
}

//-----------------------------------------------------------------------------------//
void CNCMetricsDlg::OnCaptionfont() 
{
	if( QueryCaptionFont( m_hWnd, &_ncm.lfCaptionFont ) )
    {
        _GetSPI(FALSE, TRUE);
        _fChanged = TRUE;
        _UpdateControls();
    }
}

//-----------------------------------------------------------------------------------//
void CNCMetricsDlg::OnSmallCaptionFont() 
{
	if( QueryCaptionFont( m_hWnd, &_ncm.lfSmCaptionFont ) )
    {
        _GetSPI(FALSE, TRUE);
        _fChanged = TRUE;
        _UpdateControls();
    }
}

//-----------------------------------------------------------------------------------//
void CNCMetricsDlg::OnApply() 
{
	_SetSPI( TRUE, TRUE );
}

//-----------------------------------------------------------------------------------//
void CNCMetricsDlg::OnOk() 
{
	_SetSPI( TRUE, TRUE );
    CDialog::OnOK();
}
/////////////////////////////////////////////////////////////////////////////
// CThinFrameDlg dialog


CThinFrameDlg::CThinFrameDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CThinFrameDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CThinFrameDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CThinFrameDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CThinFrameDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CThinFrameDlg, CDialog)
	//{{AFX_MSG_MAP(CThinFrameDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CThinFrameDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\ncmetricsdlg.h ===
#if !defined(AFX_NCMETRICSDLG_H__6A31D6FE_9073_49E5_A7DC_D4713679CB84__INCLUDED_)
#define AFX_NCMETRICSDLG_H__6A31D6FE_9073_49E5_A7DC_D4713679CB84__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NCMetricsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNCMetricsDlg dialog

class CNCMetricsDlg : public CDialog
{
// Construction
public:
	CNCMetricsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNCMetricsDlg)
	enum { IDD = IDD_CHANGEMETRICS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNCMetricsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void _GetSPI( BOOL, BOOL );
    void _SetSPI( BOOL, BOOL );
    void _UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CNCMetricsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChanged();
	afx_msg void OnCaptionfont();
	afx_msg void OnSmallCaptionFont();
	afx_msg void OnApply();
	afx_msg void OnOk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    BOOL _fChanged;
    BOOL _fDlgInit;
    NONCLIENTMETRICS _ncm;
};

/////////////////////////////////////////////////////////////////////////////
// CThinFrameDlg dialog

class CThinFrameDlg : public CDialog
{
// Construction
public:
	CThinFrameDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CThinFrameDlg)
	enum { IDD = IDD_THINFRAME };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CThinFrameDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CThinFrameDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NCMETRICSDLG_H__6A31D6FE_9073_49E5_A7DC_D4713679CB84__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mditest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__081C2078_58F7_4CA8_9685_5F0FBCCBB8B0__INCLUDED_)
#define AFX_STDAFX_H__081C2078_58F7_4CA8_9685_5F0FBCCBB8B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WINVER
#define WINVER 0x0500
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501
#endif  _WIN32_WINNT

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#define RECTWIDTH(prc)      ((prc)->right-(prc)->left)
#define RECTHEIGHT(prc)     ((prc)->bottom-(prc)->top)


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__081C2078_58F7_4CA8_9685_5F0FBCCBB8B0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\mditest\rgn.h ===
//-------------------------------------------------------------------------//
//  BmpRgn.h - Bitmap-to-Region transforms
//
//  History:
//  01/31/2000  scotthan   created
//-------------------------------------------------------------------------//

#ifndef __RGN_H__
#define __RGN_H__


//-----------------------------------------------------------------------
typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//---------------------------------------------------------------------------
enum GRIDNUM
{
    GN_LEFTTOP = 0,
    GN_MIDDLETOP = 1,
    GN_RIGHTTOP = 2,
    GN_LEFTMIDDLE = 3,
    GN_MIDDLEMIDDLE = 4,
    GN_RIGHTMIDDLE = 5,
    GN_LEFTBOTTOM = 6,
    GN_MIDDLEBOTTOM = 7,
    GN_RIGHTBOTTOM = 8
};

#define REVERSE3(c) ((RED(c) << 16) | (GREEN(c) << 8) | BLUE(c))
#define RED(c)      GetRValue(c)
#define GREEN(c)    GetGValue(c)
#define BLUE(c)     GetBValue(c)
#define ALPHACHANNEL(c) BYTE((c) >> 24)
#define DIBDATA(infohdr) (((BYTE *)(infohdr)) + infohdr->biSize + \
	infohdr->biClrUsed*sizeof(RGBQUAD))

//------------------------------------------------------------------------------------
class CBitmapPixels
{
public:
    CBitmapPixels();
    ~CBitmapPixels();

    //---- "OpenBitmap()" returns a ptr to pixel values in bitmap. ----
    //---- Rows go from bottom to top; Colums go from left to right. ----
    //---- IMPORTANT: pixel DWORDS have RGB bytes reversed from COLORREF ----
    HRESULT OpenBitmap(HDC hdc, HBITMAP bitmap, BOOL fForceRGB32,
        DWORD OUT **pPixels, OPTIONAL OUT int *piWidth=NULL, OPTIONAL OUT int *piHeight=NULL, 
        OPTIONAL OUT int *piBytesPerPixel=NULL, OPTIONAL OUT int *piBytesPerRow=NULL);

    void CloseBitmap(HDC hdc, HBITMAP hBitmap);

    //---- public data ----
    BITMAPINFOHEADER *_hdrBitmap;

protected:
    //---- private data ----
    int _iWidth;
    int _iHeight;
};

//-------------------------------------------------------------------------//
//  CreateBitmapRgn
//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional (-1 ==
//  use the value of the first pixel as the key).
//
EXTERN_C HRESULT WINAPI CreateBitmapRgn( 
    HBITMAP hbm, int cxOffset, int cyOffset, 
    int cx, int cy, BOOL fAlphaChannel, int iAlphaThreshold, COLORREF rgbMask, 
    int nMaskTolerance, OUT HRGN *phrgn);

//-------------------------------------------------------------------------//
//  CreateScaledBitmapRgn
//
//  Behaves in the same manner as CreateBitmapRgn, 
//  except builds a region based on a +scaled+ arbitrary bitmap.
EXTERN_C HRGN WINAPI CreateScaledBitmapRgn( 
    HBITMAP hbm, int cx, int cy, COLORREF rgbMask, int nMaskTolerance );

//-------------------------------------------------------------------------//
//  CreateTextRgn
//
//  Creates a region based on a text string in the indicated font.
//
EXTERN_C HRGN WINAPI CreateTextRgn( HFONT hf, LPCTSTR pszText );

//-------------------------------------------------------------------------//
//  AddToCompositeRgn
//
//  Wraps CombineRgn by managing composite creation and positioning
//  the source region (which is permanently offset). Returns one of:
//  NULLREGION, SIMPLEREGION, COMPLEXREGION, ERROR.
//
EXTERN_C int WINAPI AddToCompositeRgn( 
    HRGN* phrgnComposite, HRGN hrgnSrc, int cxOffset, int cyOffset );

//-------------------------------------------------------------------------//
//  RemoveFromCompositeRgn
//
//  Wraps CombineRgn by managing removal of rectangular region from
//  an existing destination region. Returns one of:
//  NULLREGION, SIMPLEREGION, COMPLEXREGION, ERROR.
//
EXTERN_C int WINAPI RemoveFromCompositeRgn( HRGN hrgnDest, LPCRECT prcRemove );

//-------------------------------------------------------------------------//
//  CreateTiledRectRgn
//
//  Returns a rectangular region composed of region tiles.
//
EXTERN_C HRGN WINAPI CreateTiledRectRgn( 
    HRGN hrgnTile, int cxTile, int cyTile, int cxBound, int cyBound );

//-------------------------------------------------------------------------//
//  Region utilities:
//
EXTERN_C HRGN WINAPI _DupRgn( HRGN hrgnSrc );

//-------------------------------------------------------------------------//
//  hit-testing
EXTERN_C WORD WINAPI _HitTestRgn( HRGN hrgn, POINT pt, WORD wSegmentHTCode, 
                                  BOOL fHasCaption, UINT cxMargin, UINT  cyMargin );
EXTERN_C WORD WINAPI _DefaultHitCodeFromSegCode( BOOL fHasCaption, WORD wSegHTcode );

//-------------------------------------------------------------------------//
//   Stretch/Tile rects from original region and create a new one
EXTERN_C HRESULT WINAPI _ScaleRectsAndCreateRegion(RGNDATA  *pCustomRgnData, 
    const RECT *pBoundRect, MARGINS *pMargins, HRGN *pHrgn);

//-------------------------------------------------------------------------//
#ifdef _DEBUG
void RegionDebug(HRGN hrgn);
#endif

#endif __RGN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ncperf\ncperf.h ===
#if !defined(AFX_NCPERF_H__FB1CC17F_8C2F_439B_AB23_E2D71A118CAD__INCLUDED_)
#define AFX_NCPERF_H__FB1CC17F_8C2F_439B_AB23_E2D71A118CAD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_NCPERF_H__FB1CC17F_8C2F_439B_AB23_E2D71A118CAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ncperf\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

// Windows Header Files:
#include <windows.h>
#include <mmsystem.h>

#endif __STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ncperf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NcPerf.rc
//
#define IDC_MYICON                      2
#define IDD_NCPERF_DIALOG               102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_NCPERF                      107
#define IDI_SMALL                       108
#define IDC_NCPERF                      109
#define IDR_MAINFRAME                   128
#define IDR_COVER                       129
#define IDD_RESULTS                     130
#define IDC_RESULTS                     1000
#define ID_START                        32771
#define IDM_STOP                        32773
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32774
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ncperf\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	NcPerf.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ncperf\ncperf.cpp ===
//-------------------------------------------------------------------------//
// NcPerf.cpp
//-------------------------------------------------------------------------//
#include "stdafx.h"
#include "resource.h"

#include <math.h>

//--- globals
HINSTANCE _hInst = NULL;								// current instance
HWND      _hwndMain = NULL;
HWND      _hwndMdiClient = NULL;
HWND      _hwndCover = NULL;

//  resize test
#define   SAMPLE_SIZE     1501
#define   MOVE_ANGLE_INCR   20 // angle interval, in degrees
SIZE      _sizeOffset = {2,2}; // size offset of cover window relative to main window
int       _nRadius = 250;      // radius 
int       _cRep = 0;           // current repitition
int       _nRot = 0;           // angle of rotation, in degrees.

//--- misc defs, helpers
#define   MAX_LOADSTRING      255
#define   MDICHILD_COUNT      6
#define   WC_NCPERFMAIN       TEXT("NcPerfMainWnd")
#define   WC_NCPERFCOVERWND   TEXT("NcPerfCoverWnd")
#define   WC_NCPERFMDICHILD   TEXT("NcPerfMdiChild")

#define   RECTWIDTH(prc)      ((prc)->right - (prc)->left)
#define   RECTHEIGHT(prc)     ((prc)->bottom - (prc)->top)
#define   SAFE_DELETE(p)      {delete (p); (p)=NULL;}

#define   WM_KICKRESIZE       (WM_USER+101)
#define   WM_STOPTEST         (WM_USER+102)

//--- fn forwards 
BOOL				RegisterClasses(HINSTANCE hInstance);
void                RunTests( HWND );
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	CoverWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	MdiChildProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	ResultsDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	NilDlgProc(HWND, UINT, WPARAM, LPARAM);
ULONG               AvgTime( ULONG, DWORD [], DWORD [][2], int, ULONG& );

class CResizeResults;
class CResizeData;
CResizeData* _pData = NULL;


//-------------------------------------------------------------------------//
class CResizeData
//-------------------------------------------------------------------------//
{
public:
    //-------------------------------------------------------------------------//
    CResizeData( HWND hwnd )
        : _hwnd(hwnd), _cSamples(-1), _cEraseP(0), _cNcPaintP(0),
          _cNcCalcR(0), _cNcPaintR(0), _cEraseR(0), _cPosChgR(0)
    {
        ZeroMemory( &_rcStart, sizeof(_rcStart) );
        ZeroMemory( &_rcStop, sizeof(_rcStop) );

        ZeroMemory( _rgdwSWP, sizeof(_rgdwSWP) );

        ZeroMemory( _rgdwEraseP, sizeof(_rgdwEraseP));
        ZeroMemory( _rgdwNcPaintP, sizeof(_rgdwNcPaintP));

        ZeroMemory( _rgdwNcCalcR, sizeof(_rgdwNcCalcR) );
        ZeroMemory( _rgdwNcPaintR, sizeof(_rgdwNcPaintR) );
        ZeroMemory( _rgdwEraseR, sizeof(_rgdwEraseR) );
        ZeroMemory( _rgdwPosChgR, sizeof(_rgdwPosChgR) );
    }

    //-------------------------------------------------------------------------//
    static BOOL Start( HWND hwnd )
    {
        SAFE_DELETE( _pData );
        if( (_pData = new CResizeData(hwnd)) == NULL )
            return FALSE;

        //  set timer.
        if( TIMERR_NOERROR != timeBeginPeriod(_tc.wPeriodMin) )
        {
            SAFE_DELETE(_pData);
            return FALSE;
        }

        int cxScr = GetSystemMetrics( SM_CXSCREEN );
        int cyScr = GetSystemMetrics( SM_CYSCREEN );
        int cxWnd = MulDiv( cxScr, 9, 10 );
        int cyWnd = MulDiv( cyScr, 9, 10 );
        int x = (cxScr - cxWnd)/2;
        int y = (cyScr - cyWnd)/2;
        _nRadius = min(cxWnd, cyWnd)/4;

        SetWindowPos( hwnd, NULL, x, y, cxWnd, cyWnd, 
                      SWP_NOZORDER|SWP_NOACTIVATE );

        GetWindowRect( hwnd, &_pData->_rcStop );
        
        _cTicks = 0; 
        _idTimer = timeSetEvent( 1, 0, TimerProc, 0, TIME_PERIODIC | TIME_CALLBACK_FUNCTION );
                        
        if( !_idTimer )
        {
            timeEndPeriod(_tc.wPeriodMin); 
            SAFE_DELETE(_pData);
            return FALSE;
        }

        return TRUE;
    }

    //-------------------------------------------------------------------------//
    static BOOL Stop( HWND hwnd )
    {
        static BOOL fInStop = FALSE;

        if( !fInStop )
        {
            fInStop = TRUE;
            if( _idTimer )
            {
                timeKillEvent( _idTimer );
                timeEndPeriod(_tc.wPeriodMin); 
                _idTimer = 0;
            }
    
            if( _hwndCover )
            {
                if( _pData )
                    GetWindowRect( hwnd, &_pData->_rcStop );
                DestroyWindow( _hwndCover );
            }

            if( _pData )
            {
                DialogBoxParam( _hInst, MAKEINTRESOURCE(IDD_RESULTS), hwnd, 
                                (DLGPROC)ResultsDlgProc, (LPARAM)_pData );
                SAFE_DELETE( _pData );
            }
            fInStop = FALSE;
        }


        return TRUE;
    }

    //-------------------------------------------------------------------------//
    static void CALLBACK TimerProc( UINT uID, UINT, DWORD, DWORD, DWORD )
    {
        _cTicks++;
    }

    //-------------------------------------------------------------------------//
    LPCTSTR Evaluate( INT& iEval )
    {
        ULONG nTimeMax = 0;

        static TCHAR szOut[MAX_PATH*4] = {0};

        LPCTSTR pszHdr = TEXT("Window rect: {%d,%d,%d,%d} = %d x %d\r\n")\
                         TEXT("Test time (ms): %d\r\n")\
                         TEXT("SetWindowPos iterations: %d\r\n");

        LPCTSTR pszStaticHdr = TEXT("Passive window msg stats:\r\n");

        LPCTSTR pszResizeHdr = TEXT("Resized window msg stats:\r\n");

        LPCTSTR pszMsgStats  = TEXT("\t%s: %d msgs, %d-%d ms latency\r\n");

        switch( iEval )
        {
            case 0:
                wsprintf( szOut, pszHdr,
                          _rcStop.left, _rcStop.top, _rcStop.right, _rcStop.bottom,
                          RECTWIDTH(&_rcStop), RECTHEIGHT(&_rcStop),
                          _cTicks, _cSamples );
                break;

            case 1:
                return pszStaticHdr;

            case 2:
            {
                DWORD nEraseTimeP0   = AvgTime( _cSamples, _rgdwSWP, _rgdwEraseP, 0, nTimeMax );
                DWORD nEraseTimePN   = AvgTime( _cSamples, _rgdwSWP, _rgdwEraseP, 1, nTimeMax );
                wsprintf( szOut, pszMsgStats,
                          TEXT("WM_ERASEBKGND"), _cEraseP, nEraseTimeP0, nEraseTimePN );
                break;
            }

            case 3:
            {
                DWORD nNcPaintTimeP0 = AvgTime( _cSamples, _rgdwSWP, _rgdwNcPaintP, 0, nTimeMax );
                DWORD nNcPaintTimePN = AvgTime( _cSamples, _rgdwSWP, _rgdwNcPaintP, 1, nTimeMax );
                wsprintf( szOut, pszMsgStats,
                          TEXT("WM_NCPAINT"), _cNcPaintP, nNcPaintTimeP0, nNcPaintTimePN );
                break;
            }

            case 4:
                return pszResizeHdr;

            case 5:
            {
                DWORD nNcCalcTimeR0  = AvgTime( _cSamples, _rgdwSWP, _rgdwNcCalcR, 0, nTimeMax );
                DWORD nNcCalcTimeRN  = AvgTime( _cSamples, _rgdwSWP, _rgdwNcCalcR, 1, nTimeMax );
                wsprintf( szOut, pszMsgStats,
                          TEXT("WM_NCCALCSIZE"), _cNcCalcR, nNcCalcTimeR0, nNcCalcTimeRN );
                break;
            }

            case 6:
            {
                DWORD nPosChgTimeR0  = AvgTime( _cSamples, _rgdwSWP, _rgdwPosChgR, 0, nTimeMax );
                DWORD nPosChgTimeRN  = AvgTime( _cSamples, _rgdwSWP, _rgdwPosChgR, 1, nTimeMax );
                wsprintf( szOut, pszMsgStats,
                          TEXT("WM_WINDOWPOSCHANGED"), _cPosChgR, nPosChgTimeR0, nPosChgTimeRN );
                break;
            }

            case 7:
            {
                DWORD nEraseTimeR0   = AvgTime( _cSamples, _rgdwSWP, _rgdwEraseR, 0, nTimeMax );
                DWORD nEraseTimeRN   = AvgTime( _cSamples, _rgdwSWP, _rgdwEraseR, 1, nTimeMax );
                wsprintf( szOut, pszMsgStats,
                          TEXT("WM_ERASEBKGND"), _cEraseR, nEraseTimeR0, nEraseTimeRN );
                break;
            }

            case 8:
            {
                DWORD nNcPaintTimeR0 = AvgTime( _cSamples, _rgdwSWP, _rgdwNcPaintR, 0, nTimeMax );
                DWORD nNcPaintTimeRN = AvgTime( _cSamples, _rgdwSWP, _rgdwNcPaintR, 1, nTimeMax );
                wsprintf( szOut, pszMsgStats,
                          TEXT("WM_NCPAINT"), _cNcPaintR, nNcPaintTimeR0, nNcPaintTimeRN );
                break;
            }

            default:
                return NULL;
        }
        return szOut;
    }

public:
    HWND  _hwnd;
    RECT  _rcStart;
    RECT  _rcStop;
    
    DWORD _cSamples;       // number of SetWindowPos calls issued to resize the window.

    DWORD _cEraseP;        // count of WM_ERASEBACKGROUNDs received by passive window
    DWORD _cNcPaintP;      // count of WM_NCPAINTs received by passive window

    DWORD _cNcCalcR;       // count of WM_NCCALCSIZEs received by resized window
    DWORD _cNcPaintR;      // count of WM_NCPAINTs received by resized window
    DWORD _cEraseR;        // count of WM_ERASEBACKGROUNDs received by resized window
    DWORD _cPosChgR;       // count of WM_WINDOWPOSCHANGED received by resized window

    DWORD _rgdwSWP[SAMPLE_SIZE];
    
    DWORD _rgdwEraseP[SAMPLE_SIZE][2];
    DWORD _rgdwNcPaintP[SAMPLE_SIZE][2];

    DWORD _rgdwNcCalcR[SAMPLE_SIZE][2];
    DWORD _rgdwNcPaintR[SAMPLE_SIZE][2];
    DWORD _rgdwEraseR[SAMPLE_SIZE][2];
    DWORD _rgdwPosChgR[SAMPLE_SIZE][2];

    static TIMECAPS  _tc;
    static UINT      _idTimer;
    static LONG      _cTicks;
};

TIMECAPS CResizeData::_tc = {0};
UINT     CResizeData::_idTimer = 0;
LONG     CResizeData::_cTicks = 0;


//-------------------------------------------------------------------------//
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_NCPERF);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if ( !TranslateMDISysAccel(_hwndMdiClient, &msg) &&
             !TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}


//-------------------------------------------------------------------------//
BOOL RegisterClasses(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	ZeroMemory( &wcex, sizeof(wcex) );
    wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)MainWndProc;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_NCPERF);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_APPWORKSPACE+1);
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_NCPERF);
	wcex.lpszClassName	= WC_NCPERFMAIN;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	if( !RegisterClassEx(&wcex) )
        return FALSE;

	wcex.style			= 0;
	wcex.lpfnWndProc	= (WNDPROC)CoverWndProc;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_NCPERF);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDR_COVER);
	wcex.lpszClassName	= WC_NCPERFCOVERWND;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	if( !RegisterClassEx(&wcex) )
        return FALSE;

	ZeroMemory( &wcex, sizeof(wcex) );
    wcex.cbSize         = sizeof(WNDCLASSEX); 
    wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)MdiChildProc;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_NCPERF);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszClassName	= WC_NCPERFMDICHILD;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	if( !RegisterClassEx(&wcex) )
        return FALSE;

    return TRUE;
}

//-------------------------------------------------------------------------//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    _hInst = hInstance; // Store instance handle in our global variable

	// Initialize global strings
    if( !RegisterClasses(hInstance) )
        return FALSE;

    if( TIMERR_NOERROR != timeGetDevCaps( &CResizeData::_tc, sizeof(CResizeData::_tc) ) )
        return FALSE;

    HWND hwnd = CreateWindow( WC_NCPERFMAIN, 
                              TEXT("NcPerf Test Window"), 
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, 
                              NULL, NULL, _hInst, NULL);

    if( hwnd )
    {
        ShowWindow(hwnd, nCmdShow);
        UpdateWindow(hwnd);
    }

    return TRUE;
}

//-------------------------------------------------------------------------//
BOOL Deg2Rad( double* pval )
{
    if( *pval >= 0 && *pval <= 360 )
    {
        *pval = ((*pval) * 22)/(7 * 180);
        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
void PinCover( HWND hwndMain )
{
    if( IsWindow(_hwndCover) )
    {
        RECT rc;
        GetWindowRect( hwndMain, &rc );
        InflateRect( &rc, -_sizeOffset.cx, -_sizeOffset.cx );
        SetWindowPos( _hwndCover, hwndMain, rc.left, rc.top, 
                      RECTWIDTH(&rc), RECTHEIGHT(&rc),
                      SWP_NOZORDER|SWP_NOACTIVATE );
    }
}

//-------------------------------------------------------------------------//
BOOL CirclePtNext( IN OUT INT* pnAngle /*degrees*/, OUT POINT& pt, OUT OPTIONAL BOOL* pfRoll )
{
    if( *pnAngle < 0 || *pnAngle >= 360 )
    {
        *pnAngle = 0;
        if( pfRoll )
            *pfRoll = TRUE;
    }

    //  increase angle
    double nAngle = _nRot + MOVE_ANGLE_INCR;

    //  establish new x, y
    if( Deg2Rad( &nAngle ) )
    {
        pt.x = (long)(_nRadius * cos( nAngle ));
        pt.y = (long)(_nRadius * sin( nAngle ));
        (*pnAngle) += MOVE_ANGLE_INCR;
        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
ULONG AvgTime( ULONG cSamples, DWORD rgdwStart[], DWORD rgdwStop[][2], int iStop, ULONG& nTimeMax  )
{
    ULONG dwTime = 0;
    
    for( ULONG i = 0, cnt = 0; i < cSamples; i++ )
    {
        if( rgdwStop[i][iStop] && rgdwStart[i] &&
            rgdwStop[i][iStop] > rgdwStart[i] )
        {
            dwTime += (rgdwStop[i][iStop] - rgdwStart[i]);
            cnt++;

            if( rgdwStop[i][iStop] > nTimeMax )
                nTimeMax = rgdwStop[i][iStop];
        }
    }

    return cnt ? (dwTime / cnt) : 0;
}

//-------------------------------------------------------------------------//
inline void LogMsg( DWORD rgdwMsg[][2], ULONG& cnt )
{
    DWORD nTick = CResizeData::_cTicks;
    if(!rgdwMsg[_pData->_cSamples][0] )
        rgdwMsg[_pData->_cSamples][0] = nTick;
    rgdwMsg[_pData->_cSamples][1] = nTick;
    cnt++;
}

//-------------------------------------------------------------------------//
void RunTests( HWND hwndMain )
{
    HWND hwnd = CreateWindow( WC_NCPERFCOVERWND, 
                              TEXT("NcPerf Cover Window"), 
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, 
                              NULL, NULL, _hInst, NULL);
    if( hwnd )
    {
        _cRep = 0;
        PinCover( hwndMain );
        ShowWindow( hwnd, SW_SHOWNORMAL );
        UpdateWindow( hwnd );

        if( CResizeData::Start( hwndMain ) )
        {
            for( int i=0; i < SAMPLE_SIZE; i++ )
            {
                PostMessage( hwndMain, WM_KICKRESIZE, 0, 0 );
            }
            PostMessage( hwndMain, WM_STOPTEST, 0, 0 );
        }
        else
        {
            DestroyWindow( hwnd );
        }
    }
}

//-------------------------------------------------------------------------//
inline void SWAP( long& x, long& y )
{
    long z = x;
    x = y;
    y = z;
}

//-------------------------------------------------------------------------//
inline void NORMALIZERECT( LPRECT prc )
{
    if( prc->right < prc->left )
        SWAP( prc->right, prc->left );
    if( prc->bottom < prc->top )
        SWAP( prc->bottom, prc->top );
}

enum RECTVERTEX
{
    LEFTTOP,
    RIGHTTOP,
    LEFTBOTTOM,
    RIGHTBOTTOM,
};

void _MoveVertex( RECTVERTEX v, IN OUT RECT& rc, const RECT& rcMain, const POINT& pt, IN OUT ULONG& fSwp )
{
    rc.left = rcMain.left + _sizeOffset.cx;
    rc.top  = rcMain.top  + _sizeOffset.cy;
    rc.right  = rcMain.right - _sizeOffset.cx;
    rc.bottom = rcMain.bottom - _sizeOffset.cy;

    switch( v )
    {
        case LEFTTOP:
            rc.left = rcMain.left + _nRadius + pt.x;
            rc.top  = rcMain.top + _nRadius + pt.y;
            fSwp |= SWP_NOMOVE;
            break;
        
        case RIGHTTOP:
            rc.right  = rcMain.right  - (_nRadius + pt.x);
            rc.top  = rcMain.top + _nRadius + pt.y;
            break;

        case LEFTBOTTOM:
            rc.left = rcMain.left + _nRadius + pt.x;
            rc.bottom = rcMain.bottom - (_nRadius + pt.y);
            break;

        case RIGHTBOTTOM:
            rc.right  = rcMain.right  - (_nRadius + pt.x);
            rc.bottom = rcMain.bottom - (_nRadius + pt.y);
            break;
    }
}

//-------------------------------------------------------------------------//
void ResizeCover( HWND hwndMain )
{
    POINT pt;
    BOOL  fRollover = FALSE;
    CirclePtNext( &_nRot, pt, &fRollover );

    RECT rc, rcMain;
    GetWindowRect( hwndMain, &rcMain );
    GetWindowRect( _hwndCover, &rc );
    ULONG nFlags = SWP_NOZORDER|SWP_NOACTIVATE;

    if( fRollover )
    {
        _cRep++;
        PinCover( hwndMain );
    }

    RECTVERTEX v = LEFTTOP;
    int phase = _cRep % 20;

    if( phase < 5 )
    {
        v = LEFTTOP;
    }
    else if( phase < 10 )
    {
        v = RIGHTTOP;
    }
    else if( phase < 15 )
    {
        v = LEFTBOTTOM;
    }
    else
    {
        v = RIGHTBOTTOM;
    }
    _MoveVertex( v, rc, rcMain, pt, nFlags );

    if( _pData->_cSamples + 1 >= SAMPLE_SIZE )
    {
        CResizeData::Stop( hwndMain );
    }
    else
    {
        _pData->_rgdwSWP[_pData->_cSamples] = CResizeData::_cTicks;
        SetWindowPos( _hwndCover, NULL, rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc),
                      SWP_NOZORDER|SWP_NOACTIVATE );
        _pData->_cSamples++;
    }
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lRet = 0L;
    switch (uMsg) 
	{
        case WM_KICKRESIZE:
            ResizeCover( hwnd );
            break;

        case WM_STOPTEST:
            CResizeData::Stop( hwnd );
            break;

        case WM_ERASEBKGND:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            if( _pData )
            {
                LogMsg( _pData->_rgdwEraseP, _pData->_cEraseP );
            }
            break;

        case WM_NCPAINT:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            if( _pData )
            {
                LogMsg( _pData->_rgdwNcPaintP, _pData->_cNcPaintP );
            }
            break;

		case WM_PAINT:
        {
	        PAINTSTRUCT ps;
	        HDC hdc;
			hdc = BeginPaint(hwnd, &ps);
			EndPaint(hwnd, &ps);
            break;
        }
			

        case WM_TIMER:
        {
            if( _hwndCover )
            {
                ResizeCover( hwnd );
            }
        }
        break;

		case WM_CREATE:
        {
            _hwndMain = hwnd;

#if 0
            RECT rc;
            GetClientRect( hwnd, &rc );
            CLIENTCREATESTRUCT  ccs = {0};
            ccs.idFirstChild = 1;
            _hwndMdiClient = CreateWindow( TEXT("MDICLIENT"), TEXT(""), 
                                           WS_CHILD|WS_VISIBLE|WS_HSCROLL|WS_VSCROLL,
                                           rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc), 
                                           hwnd, NULL, _hInst, &ccs );
            
            if( _hwndMdiClient )
            {
                MDICREATESTRUCT mcs = {0};

                mcs.szClass = WC_NCPERFMDICHILD;
                mcs.szTitle = TEXT("Nc Perf");
                mcs.hOwner = _hInst;
                mcs.x = CW_USEDEFAULT; mcs.y = 0; mcs.cx = CW_USEDEFAULT; mcs.cy = 0;
                mcs.style   = WS_OVERLAPPEDWINDOW;
                mcs.lParam  = 0;


                for( int i = 0; i < MDICHILD_COUNT; i++ )
                    SendMessage( _hwndMdiClient, WM_MDICREATE, 0, (LPARAM)&mcs); 

                SendMessage( _hwndMdiClient, WM_MDITILE, MDITILE_HORIZONTAL, 0 );
                
                return 0;
            }
            return -1;
#else
            return 0;
#endif 0

        }
        
        case WM_COMMAND:
			
            // Parse the menu selections:
			switch (LOWORD(wParam))
			{
                case ID_START:
                    RunTests( hwnd );
                    break;

                case IDM_STOP:
                    CResizeData::Stop( hwnd );
                    if( IsWindow( _hwndCover ) )
                        DestroyWindow( _hwndCover );
                    break; 

				case IDM_ABOUT:
                    DialogBox(_hInst, (LPCTSTR)IDD_ABOUTBOX, hwnd, (DLGPROC)NilDlgProc);
				    break;
				case IDM_EXIT:
				    DestroyWindow(hwnd);
				    break;
				default:
				    return DefWindowProc(hwnd, uMsg, wParam, lParam);
			}
			break;

		case WM_DESTROY:
            CResizeData::Stop(hwnd);
			PostQuitMessage(0);
			break;

		default:
			return _hwndMdiClient ?  
                    DefFrameProc(hwnd, _hwndMdiClient, uMsg, wParam, lParam) :
                    DefWindowProc(hwnd, uMsg, wParam, lParam);
   }
   return lRet;
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK CoverWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lRet = 0L;
    switch (uMsg) 
	{
		case WM_CREATE:
            _hwndCover = hwnd;
            return 0;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDM_STOP:
                    CResizeData::Stop( hwnd );
                    if( IsWindow( _hwndCover ) )
                        DestroyWindow( _hwndCover );
                    break; 
            }
            break;

        case WM_ERASEBKGND:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            if( _pData )
            {
                LogMsg( _pData->_rgdwEraseR, _pData->_cEraseR );
            }
            break;
        
        case WM_NCCALCSIZE:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            if( _pData )
            {
                LogMsg( _pData->_rgdwNcCalcR, _pData->_cNcCalcR );
            }
            break;

        case WM_NCPAINT:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            if( _pData )
            {
                LogMsg( _pData->_rgdwNcPaintR, _pData->_cNcPaintR );
            }
            break;

		case WM_PAINT:
        {
			PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
			EndPaint(hwnd, &ps);
			break;
        }

        case WM_WINDOWPOSCHANGED:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            if( _pData )
            {
                LogMsg( _pData->_rgdwPosChgR, _pData->_cPosChgR );
            }
            break;

        case WM_NCDESTROY:
            _hwndCover = NULL;
            break;

		default:
			return DefWindowProc(hwnd, uMsg, wParam, lParam);
   }
   return lRet;
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK MdiChildProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return DefMDIChildProc(hwnd, uMsg, wParam, lParam);
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK ResultsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    if( WM_INITDIALOG == uMsg )
    {
        if( lParam )
        {
            LPCTSTR pszRes;
            int i;
            for( i = 0; (pszRes = ((CResizeData*)lParam)->Evaluate(i)) != NULL; i++ )
            {
                SendDlgItemMessage( hwnd, IDC_RESULTS, EM_SETSEL, -1, 0 );
                SendDlgItemMessage( hwnd, IDC_RESULTS, EM_REPLACESEL, FALSE, (LPARAM)pszRes );
            }
        }
    }

    return NilDlgProc( hwnd, uMsg, wParam, lParam );
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK NilDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ninegrid\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	NineGrid.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ninegrid\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by NINEGRID.RC
//
#define IDR_MAINFRAME					128
#define IDD_NINEGRID_DIALOG		102
#define IDD_ABOUTBOX					103
#define IDS_APP_TITLE					103
#define IDM_ABOUT						104
#define IDM_EXIT						105
#define IDS_HELLO						106
#define IDI_NINEGRID	            107
#define IDI_SMALL						108
#define IDC_NINEGRID	            109
#define IDC_MYICON						2
#define IDC_STATIC	                    -1
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\spywindows\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DumpIcon.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\spywindows\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__CED75F4A_7D64_4EF9_B869_5655DFADAEA4__INCLUDED_)
#define AFX_STDAFX_H__CED75F4A_7D64_4EF9_B869_5655DFADAEA4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <wingdi.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CED75F4A_7D64_4EF9_B869_5655DFADAEA4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ninegrid\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ninegrid\main.cpp ===
//---------------------------------------------------------------------
//    Main.cpp - tests various ways of drawing a nine grid hBitmap
//---------------------------------------------------------------------
#include "stdafx.h"
#include "resource.h"
#include "tmutils.h"
#include "ninegrid.h"
#include <atlbase.h>
#include "stdio.h"
//---------------------------------------------------------------------
enum TESTNUM
{
    TN_ORIG,
    TN_CACHE,
    TN_DIRECT,
    TN_TRUE,
    TN_SOLID,
};
//---------------------------------------------------------------------
TESTNUM g_eTestNum = TN_CACHE;
SIZINGTYPE g_eSizingType = ST_TILE;

int iTestCount = 100;
//---------------------------------------------------------------------
#define MAX_LOADSTRING 100
//---------------------------------------------------------------------
HINSTANCE hInst;							
TCHAR szTitle[MAX_LOADSTRING];				
TCHAR szWindowClass[MAX_LOADSTRING];		
//---------------------------------------------------------------------
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

__int64 liFreq;
__int64 liStart;
__int64 liEnd;

HWND hwnd;

RECT rcButton = {50, 50, 150, 150};
RECT rcCompare = {200, 50, 300, 150};

RECT rcWindow = {50, 200, 450, 500};

BITMAPINFO *g_pBitmapHdr = NULL;
BYTE *g_pBits = NULL;
int g_iImageHeight = 0;

HBRUSH g_Brushes[5] = {0};
HBITMAP g_hBitmap;
HBITMAP g_hBitmap2;
//---------------------------------------------------------------------
__int64 TestButtonDrawing(HDC hdc, RECT *prc, int iCount)
{
    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);

    for (int i = 0; i < iCount; i++)
    {
        DrawFrameControl(hdc, prc, DFC_BUTTON, DFCS_BUTTONPUSH);
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);
    return (liEnd - liStart);
}
//---------------------------------------------------------------------
__int64 TestWindowDrawing(HDC hdc, RECT *prc, int iCount)
{
    int iCaptionHeight = GetSystemMetrics(SM_CYSIZE);
    int iBorderSize = 2;    // GetSystemMetrics(SM_CXBORDER);
    COLORREF crBorder = GetSysColor(COLOR_ACTIVEBORDER);

    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);

    for (int i = 0; i < iCount; i++)
    {
        RECT rcCaption = {prc->left, prc->top, prc->right, prc->top + iCaptionHeight};

        DrawCaption(hwnd, hdc, &rcCaption, DC_TEXT | DC_ICON | DC_ACTIVE | DC_GRADIENT);

        //---- draw rest of frame ----
        COLORREF crOld = SetBkColor(hdc, crBorder);

        //---- left border ----
        RECT rc = {prc->left, prc->top + iCaptionHeight, prc->left+iBorderSize, prc->bottom};
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

        //---- bottom border ----
        RECT rc2 = {prc->left, prc->bottom-iBorderSize, prc->right, prc->bottom};
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc2, NULL, 0, NULL);

        //---- right border ----
        RECT rc3 = {prc->right-iBorderSize, prc->top + iCaptionHeight, prc->right, prc->bottom};
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc3 , NULL, 0, NULL);

        //---- restore the color ----
        SetBkColor(hdc, crOld);
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);
    return (liEnd - liStart);
}
//---------------------------------------------------------------------
HRESULT CreateBitmapFromBits(HDC hdc, BITMAPINFOHEADER *pBitmapHdr, BYTE *pDibBits,
    HBITMAP *phBitmap)
{
    int iSetVal;
    HBITMAP hBitmap = NULL;
    HRESULT hr = S_OK;

    //---- create the actual bitmap ----
    hBitmap = CreateCompatibleBitmap(hdc, pBitmapHdr->biWidth, pBitmapHdr->biHeight);
    if (! hBitmap)
    {
        hr = GetLastError();
        goto exit;
    }

    iSetVal = SetDIBits(hdc, hBitmap, 0, pBitmapHdr->biHeight, pDibBits, (BITMAPINFO *)pBitmapHdr,
        DIB_RGB_COLORS);
    if (! iSetVal)
    {
        hr = GetLastError();
        goto exit;
    }
        
    *phBitmap = hBitmap;

exit:
    if (FAILED(hr))
    {
        if (hBitmap)
            DeleteObject(hBitmap);
    }

    return hr;
}
//---------------------------------------------------------------------------
__int64 TestOriginal(HDC hdc, RECT *prc, int iCount)
{
    if (! g_pBitmapHdr)
        return 0;

    //---- create bitmap from dib ---
    int iImageWidth = g_pBitmapHdr->bmiHeader.biWidth;
    int iImageHeight = g_pBitmapHdr->bmiHeader.biHeight / 5;

    //---- fill out the NineGrid struct ----
    NGINFO nginfo = {sizeof(NGINFO)};
    nginfo.hdcDest = hdc;
    nginfo.rcClip = *prc;
    nginfo.hBitmap = g_hBitmap;
    nginfo.dwOptions = 0;

    SetRect(&nginfo.rcSrc, 0, iImageHeight, iImageWidth, 2*iImageHeight);
    nginfo.rcDest = *prc;

    nginfo.iSrcMargins[0] = 4;    
    nginfo.iSrcMargins[1] = 4;    
    nginfo.iSrcMargins[2] = 9;    
    nginfo.iSrcMargins[3] = 9;

    nginfo.iDestMargins[0] = 4;    
    nginfo.iDestMargins[1] = 4;    
    nginfo.iDestMargins[2] = 9;    
    nginfo.iDestMargins[3] = 9;

    nginfo.eImageSizing = g_eSizingType;
    
    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);
    for (int i = 0; i < iCount; i++)
    {
        DrawNineGrid(&nginfo);
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);

    return (liEnd - liStart);
}
//---------------------------------------------------------------------------
__int64 TestTrue(HDC hdc, RECT *prc, int iCount)
{
    if (! g_pBitmapHdr)
        return 0;

    //---- create bitmap from dib ---
    int iImageWidth = g_pBitmapHdr->bmiHeader.biWidth;
    int iImageHeight = g_pBitmapHdr->bmiHeader.biHeight / 5;

    //---- fill out the NineGrid struct ----
    NGINFO nginfo = {sizeof(NGINFO)};
    nginfo.hdcDest = hdc;
    nginfo.rcClip = *prc;
    nginfo.hBitmap = g_hBitmap;
    nginfo.dwOptions = 0;

    SetRect(&nginfo.rcSrc, 0, iImageHeight, iImageWidth, 2*iImageHeight);
    nginfo.rcDest = *prc;

    nginfo.iDestMargins[0] = 0;    
    nginfo.iDestMargins[1] = 0;    
    nginfo.iDestMargins[2] = 0;    
    nginfo.iDestMargins[3] = 0;

    nginfo.iSrcMargins[0] = 0;    
    nginfo.iSrcMargins[1] = 0;    
    nginfo.iSrcMargins[2] = 0;    
    nginfo.iSrcMargins[3] = 0;

    nginfo.eImageSizing = ST_TRUESIZE;
    
    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);
    for (int i = 0; i < iCount; i++)
    {
        DrawNineGrid(&nginfo);
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);

    return (liEnd - liStart);
}
//---------------------------------------------------------------------------
__int64 TestSolid(HDC hdc, RECT *prc, int iCount)
{
    if (! g_pBitmapHdr)
        return 0;

    //---- create bitmap from dib ---
    int iImageWidth = g_pBitmapHdr->bmiHeader.biWidth;
    int iImageHeight = g_pBitmapHdr->bmiHeader.biHeight / 5;

    //---- fill out the NineGrid struct ----
    NGINFO nginfo = {sizeof(NGINFO)};
    nginfo.hdcDest = hdc;
    nginfo.rcClip = *prc;
    nginfo.hBitmap = g_hBitmap;
    nginfo.dwOptions = NGO_SOLIDBORDER | NGO_SOLIDCONTENT;

    SetRect(&nginfo.rcSrc, 0, iImageHeight, iImageWidth, 2*iImageHeight);
    nginfo.rcDest = *prc;

    nginfo.iDestMargins[0] = 2;    
    nginfo.iDestMargins[1] = 2;    
    nginfo.iDestMargins[2] = 2;    
    nginfo.iDestMargins[3] = 2;

    nginfo.iSrcMargins[0] = 2;    
    nginfo.iSrcMargins[1] = 2;    
    nginfo.iSrcMargins[2] = 2;    
    nginfo.iSrcMargins[3] = 2;

    nginfo.eImageSizing = g_eSizingType;
    
    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);
    for (int i = 0; i < iCount; i++)
    {
        DrawNineGrid(&nginfo);
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);

    return (liEnd - liStart);
}
//---------------------------------------------------------------------------
__int64 TestCache(HDC hdc, RECT *prc, int iCount)
{
    if (! g_pBitmapHdr)
        return 0;

    int iImageWidth = g_pBitmapHdr->bmiHeader.biWidth;
    int iImageHeight = g_pBitmapHdr->bmiHeader.biHeight / 5;

    //---- fill out the NineGrid struct ----
    NGINFO nginfo = {sizeof(NGINFO)};
    nginfo.hdcDest = hdc;
    nginfo.rcClip = *prc;
    nginfo.hBitmap = g_hBitmap;
    nginfo.dwOptions = NGO_CACHEBRUSHES;

    SetRect(&nginfo.rcSrc, 0, iImageHeight, iImageWidth, 2*iImageHeight);
    nginfo.rcDest = *prc;

    nginfo.iDestMargins[0] = 4;    
    nginfo.iDestMargins[1] = 4;    
    nginfo.iDestMargins[2] = 9;    
    nginfo.iDestMargins[3] = 9;

    nginfo.iSrcMargins[0] = 4;    
    nginfo.iSrcMargins[1] = 4;    
    nginfo.iSrcMargins[2] = 9;    
    nginfo.iSrcMargins[3] = 9;

    nginfo.pCachedBrushes = g_Brushes;

    nginfo.eImageSizing = g_eSizingType;
    
    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);
    for (int i = 0; i < iCount; i++)
    {
        DrawNineGrid(&nginfo);
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);

    return (liEnd - liStart);
}
//---------------------------------------------------------------------------
__int64 TestDirect(HDC hdc, RECT *prc, int iCount)
{
    if (! g_pBitmapHdr)
        return 0;

    //---- create bitmap from dib ---
    int iImageWidth = g_pBitmapHdr->bmiHeader.biWidth;
    int iImageHeight = g_pBitmapHdr->bmiHeader.biHeight / 5;

    //---- fill out the NineGrid struct ----
    NGINFO nginfo = {sizeof(NGINFO)};
    nginfo.hdcDest = hdc;
    nginfo.rcClip = *prc;
    nginfo.hBitmap = g_hBitmap;
    nginfo.pBits = g_pBits;
    nginfo.pbmHdr = (BITMAPINFOHEADER *)g_pBitmapHdr;
    nginfo.dwOptions = NGO_DIRECTBITS;

    SetRect(&nginfo.rcSrc, 0, iImageHeight, iImageWidth, 2*iImageHeight);
    nginfo.rcDest = *prc;

    nginfo.iSrcMargins[0] = 4;    
    nginfo.iSrcMargins[1] = 4;    
    nginfo.iSrcMargins[2] = 9;    
    nginfo.iSrcMargins[3] = 9;

    nginfo.iDestMargins[0] = 4;    
    nginfo.iDestMargins[1] = 4;    
    nginfo.iDestMargins[2] = 9;    
    nginfo.iDestMargins[3] = 9;

    nginfo.eImageSizing = g_eSizingType;
    
    QueryPerformanceCounter((LARGE_INTEGER*)&liStart);
    for (int i = 0; i < iCount; i++)
    {
        DrawNineGrid(&nginfo);
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);

    return (liEnd - liStart);
}
//---------------------------------------------------------------------------
void CompareTimes(LPCWSTR pszMsg, __int64 liBase, __int64 liCompare)
{
    char buff[100];
    USES_CONVERSION;

    double flSecs = double(liCompare)/double(liFreq);
    double flRatio = double(liCompare)/double(liBase);

    sprintf(buff, "%.4f secs (%.2f x)", flSecs, flRatio);
    MessageBox(NULL, A2W(buff), pszMsg, MB_OK);
}
//---------------------------------------------------------------------
HRESULT TestDrawing()
{
    RECT rc = {0,0,100,100};
    __int64 liButton, liWindow, liCompare;

    //---- initialize timing stuff ----
    QueryPerformanceFrequency((LARGE_INTEGER*)&liFreq);

    //---- create a memory hBitmap to write to ----
    HDC hdc = CreateCompatibleDC(NULL);
    HBITMAP hbmp = CreateBitmap(100, 100, 1, 24, NULL);
    SelectObject(hdc, hbmp);
    
    //---- also, get our window's dc so we can verify drawing visually ----
    HDC hdcWindow = GetWindowDC(hwnd);

    //---- first, time the reference "button" ----
    liButton = TestButtonDrawing(hdc, &rc, iTestCount);
    CompareTimes(L"Reference Button", liButton, liButton);

    //---- then, time the reference "window" ----
    liWindow = TestWindowDrawing(hdc, &rc, iTestCount);
    CompareTimes(L"Reference Window", liWindow, liWindow);

    HRESULT hr = E_FAIL;
    CBitmapPixels pixels;
    int iWidth, iHeight, iBytesPerPixel, iBytesPerRow;

    //---- load hBitmap ----
    g_hBitmap = (HBITMAP)LoadImage(hInst, L"ButtonBlue.bmp", IMAGE_BITMAP, 0, 0, 
        LR_LOADFROMFILE);
    if (! g_hBitmap)
        goto exit;

    //---- convert to DIBDATA ----
    hr = pixels.OpenBitmap(NULL, g_hBitmap, FALSE, (DWORD **)&g_pBits, &iWidth, &iHeight, 
        &iBytesPerPixel, &iBytesPerRow);
    if (FAILED(hr))
        goto exit;
    
    g_pBitmapHdr = (BITMAPINFO *)pixels._hdrBitmap;
    pixels._hdrBitmap = NULL;       // don't deallocate on exit

    CreateBitmapFromBits(hdc, (BITMAPINFOHEADER*) g_pBitmapHdr, g_pBits, &g_hBitmap2);

    switch (g_eTestNum)
    {
        case TN_ORIG:
            //---- time the original ninegrid ----
            liCompare = TestOriginal(hdc, &rc, iTestCount);
            CompareTimes(L"Original 9-grid", liButton, liCompare);
            break;

        case TN_CACHE:
            //---- time the cache ninegrid ----
            liCompare = TestCache(hdc, &rc, iTestCount);
            CompareTimes(L"Cache 9-grid", liButton, liCompare);
            break;

        case TN_TRUE:
            //---- time the TrueSize ninegrid ----
            liCompare = TestTrue(hdc, &rc, iTestCount);
            CompareTimes(L"TrueSize 9-grid", liButton, liCompare);
            break;

        case TN_DIRECT:
            //---- time the direct ninegrid ----
            liCompare = TestDirect(hdc, &rc, iTestCount);
            CompareTimes(L"Direct 9-grid", liButton, liCompare);
            break;

        case TN_SOLID:
            //---- time the solid border ninegrid ----
            liCompare = TestSolid(hdc, &rc, iTestCount);
            CompareTimes(L"Solid Border 9-grid", liButton, liCompare);
            break;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------
int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, int nCmdShow)
{
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_NINEGRID, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_NINEGRID);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}
//---------------------------------------------------------------------
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_NINEGRID);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)CreateSolidBrush(RGB(150, 230, 230));
	wcex.lpszMenuName	= (LPCWSTR)IDC_NINEGRID;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}
//---------------------------------------------------------------------
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

   hwnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

   if (!hwnd)
   {
      return FALSE;
   }

   TestDrawing();

   ShowWindow(hwnd, nCmdShow);
   UpdateWindow(hwnd);

   return TRUE;
}
//---------------------------------------------------------------------
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
	TCHAR szHello[MAX_LOADSTRING];
	LoadString(hInst, IDS_HELLO, szHello, MAX_LOADSTRING);

	switch (message) 
	{
		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;
				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);
			// TODO: Add any drawing code here...
			RECT rt;
			GetClientRect(hWnd, &rt);

            //---- paint test results ----
            TestButtonDrawing(ps.hdc, &rcButton, 1);

            TestWindowDrawing(ps.hdc, &rcWindow, 1);

            switch (g_eTestNum)
            {
                case TN_ORIG:
                    TestOriginal(ps.hdc, &rcCompare, 1);
                    break;

                case TN_CACHE:
                    TestCache(ps.hdc, &rcCompare, 1);
                    break;

                case TN_DIRECT:
                    TestDirect(ps.hdc, &rcCompare, 1);
                    break;

                case TN_TRUE:
                    TestTrue(ps.hdc, &rcCompare, 1);
                    break;

                case TN_SOLID:
                    TestSolid(ps.hdc, &rcCompare, 1);
                    break;
            }
            
            EndPaint(hWnd, &ps);
			break;
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
//---------------------------------------------------------------------
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
//---------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ninegrid\tmutils.h ===
//-------------------------------------------------------------------------
//	TmUtils.h - theme manager shared utilities
//-------------------------------------------------------------------------
#pragma once
//-------------------------------------------------------------------------
#define DIBDATA(infohdr) (((BYTE *)(infohdr)) + infohdr->biSize + \
	infohdr->biClrUsed*sizeof(RGBQUAD))

#define THEME_OFFSET(x)         int(x - _LoadingThemeFile._pbThemeData)
#define THEMEFILE_OFFSET(x)     int(x - pThemeFile->_pbThemeData)
//------------------------------------------------------------------------------------
class CBitmapPixels
{
public:
    CBitmapPixels();
    ~CBitmapPixels();

    //---- "OpenBitmap()" returns a ptr to pixel values in bitmap. ----
    //---- Rows go from bottom to top; Colums go from left to right. ----
    //---- IMPORTANT: pixel DWORDS have RGB bytes reversed from COLORREF ----
    HRESULT OpenBitmap(HDC hdc, HBITMAP bitmap, BOOL fForceRGB32,
        DWORD OUT **pPixels, OPTIONAL OUT int *piWidth=NULL, OPTIONAL OUT int *piHeight=NULL, 
        OPTIONAL OUT int *piBytesPerPixel=NULL, OPTIONAL OUT int *piBytesPerRow=NULL);

    void CloseBitmap(HDC hdc, HBITMAP hBitmap);

    //---- public data ----
    BITMAPINFOHEADER *_hdrBitmap;

protected:
    //---- private data ----
    int _iWidth;
    int _iHeight;
};
//------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\ninegrid\tmutils.cpp ===
//-------------------------------------------------------------------------
//	TmUtils.cpp - theme manager shared utilities
//-------------------------------------------------------------------------
#include "stdafx.h"
#include "TmUtils.h"
//-------------------------------------------------------------------------
CBitmapPixels::CBitmapPixels()
{
    _hdrBitmap = NULL;
    _iWidth = 0;
    _iHeight = 0;
}
//-------------------------------------------------------------------------
CBitmapPixels::~CBitmapPixels()
{
    if (_hdrBitmap)
	    delete [] (BYTE *)_hdrBitmap;
}
//-------------------------------------------------------------------------
HRESULT CBitmapPixels::OpenBitmap(HDC hdc, HBITMAP bitmap, BOOL fForceRGB32,
    DWORD OUT **pPixels, OPTIONAL OUT int *piWidth, OPTIONAL OUT int *piHeight, 
    OPTIONAL OUT int *piBytesPerPixel, OPTIONAL OUT int *piBytesPerRow)
{
    if (! pPixels)
        return E_INVALIDARG;

	BITMAP bminfo;
	
    GetObject(bitmap, sizeof(bminfo), &bminfo);
	_iWidth = bminfo.bmWidth;
	_iHeight = bminfo.bmHeight;

    int iBytesPerPixel = 3;

#if 0
    if ((fForceRGB32) || (bminfo.bmBitsPixel == 32)) 
        iBytesPerPixel = 4;
    else
        iBytesPerPixel = 3;
#endif
    
    int iRawBytes = _iWidth * iBytesPerPixel;
    int iBytesPerRow = 4*((iRawBytes+3)/4);

	int size = sizeof(BITMAPINFOHEADER) + _iHeight*iBytesPerRow;
	BYTE *dibBuff = new BYTE[size+100];    // avoid random GetDIBits() failures with 100 bytes padding (?)
    if (! dibBuff)
        return E_OUTOFMEMORY;

	_hdrBitmap = (BITMAPINFOHEADER *)dibBuff;
	memset(_hdrBitmap, 0, sizeof(BITMAPINFOHEADER));

	_hdrBitmap->biSize = sizeof(BITMAPINFOHEADER);
	_hdrBitmap->biWidth = _iWidth;
	_hdrBitmap->biHeight = _iHeight;
	_hdrBitmap->biPlanes = 1;
    _hdrBitmap->biBitCount = 8*iBytesPerPixel;
	_hdrBitmap->biCompression = BI_RGB;     
	
    bool fNeedRelease = false;

    if (! hdc)
    {
        hdc = GetWindowDC(NULL);
        fNeedRelease = true;
    }

    int linecnt = GetDIBits(hdc, bitmap, 0, _iHeight, DIBDATA(_hdrBitmap), (BITMAPINFO *)_hdrBitmap, 
        DIB_RGB_COLORS);
    
    if (fNeedRelease)
        ReleaseDC(NULL, hdc);

	*pPixels = (DWORD *)DIBDATA(_hdrBitmap);

    if (piWidth)
        *piWidth = _iWidth;
    if (piHeight)
        *piHeight = _iHeight;

    if (piBytesPerPixel)
        *piBytesPerPixel = iBytesPerPixel;
    if (piBytesPerRow)
        *piBytesPerRow = iBytesPerRow;

    return S_OK;
}
//-------------------------------------------------------------------------
void CBitmapPixels::CloseBitmap(HDC hdc, HBITMAP hBitmap)
{
    if (_hdrBitmap)
    {
        if (hBitmap)        // rewrite bitmap
        {
            bool fNeedRelease = false;

            if (! hdc)
            {
                hdc = GetWindowDC(NULL);
                fNeedRelease = true;
            }

            SetDIBits(hdc, hBitmap, 0, _iHeight, DIBDATA(_hdrBitmap), (BITMAPINFO *)_hdrBitmap,
                DIB_RGB_COLORS);
        
            if ((fNeedRelease) && (hdc))
                ReleaseDC(NULL, hdc);
        }

	    delete [] (BYTE *)_hdrBitmap;
        _hdrBitmap = NULL;
    }
}
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\aboutdlg.h ===
// aboutdlg.h : interface of the CAboutDlg class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ABOUTDLG_H__D257AE23_8649_4EA5_8E06_7D02205AEA28__INCLUDED_)
#define AFX_ABOUTDLG_H__D257AE23_8649_4EA5_8E06_7D02205AEA28__INCLUDED_

class CAboutDlg : public CDialogImpl<CAboutDlg>
{
public:
    enum { IDD = IDD_ABOUTBOX };

    BEGIN_MSG_MAP(CAboutDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
        COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
    END_MSG_MAP()

    LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
    {
        CenterWindow(GetParent());
        return TRUE;
    }

    LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        EndDialog(wID);
        return 0;
    }
};

#endif // !defined(AFX_ABOUTDLG_H__D257AE23_8649_4EA5_8E06_7D02205AEA28__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\spywindows\spywindows.cpp ===
// DumpIcon.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "stdio.h"
#include "commctrl.h"
#include "uxtheme.h"
#include <tmschema.h>

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

__int64 liStart;
__int64 liEnd;
__int64 liFreq;

__int64 liTotal = 0;

DWORD   dwCount = 0;
TCHAR g_szTestWindow[MAX_PATH];

void _GetProcFromComCtl32(FARPROC* ppfn, LPCSTR pszProc)
{
    static HMODULE g_hinstCC = 0;
    if (!g_hinstCC)
        g_hinstCC = GetModuleHandle(TEXT("comctl32.dll"));

    if (g_hinstCC)
        *ppfn = GetProcAddress(g_hinstCC, pszProc);
    else
    {
        // Hmm, This is a fatal error.... Dialog and Quit?
        *ppfn = NULL;
    }
}


#define STUB_COMCTL32_ORD(_ret, _fn, _args, _nargs, _ord, _err)               \
_ret __stdcall _fn _args                                                      \
{                                                                             \
    static _ret (__stdcall *_pfn##_fn) _args = (_ret (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (_ret (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, (LPCSTR)_ord);            \
    if (_pfn##_fn)                                                            \
        return _pfn##_fn _nargs;                                              \
    return (_ret)_err;                                                        \
}


STUB_COMCTL32_ORD(BOOL, SetWindowSubclass, (HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData), (hWnd, pfnSubclass, uIdSubclass, dwRefData), 410, FALSE);
STUB_COMCTL32_ORD(LRESULT , DefSubclassProc, (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam), (hWnd, uMsg, wParam, lParam), 413, 0);



LRESULT CALLBACK UxThemeTestHook(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    switch (uMsg)
    {
    case WM_PAINT:
        QueryPerformanceCounter((LARGE_INTEGER*)&liStart);
        LRESULT l = DefSubclassProc(hWnd, uMsg, wParam, lParam);
        QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);

        if (dwCount < 100)
        {
            liTotal += liEnd - liStart;
            dwCount++;
        }

        return l;
    }
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK HostWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CREATE:
        {
            RECT rc;
            GetClientRect(hwnd, &rc);

            for (int i=0; i < 100; i++)
            {
                HWND hwndTest = CreateWindow(g_szTestWindow, TEXT("0"), WS_CHILD | WS_VISIBLE, 
                    (RECTWIDTH(rc) / 10) * (i % 10),
                    (RECTHEIGHT(rc) / 10) * (i / 10),
                    RECTWIDTH(rc) / 10,
                    RECTHEIGHT(rc) / 10,
                    hwnd, NULL, NULL, NULL);
                if (hwndTest)
                    SetWindowSubclass(hwndTest, UxThemeTestHook, 1, NULL);
            }
        }
        break;

    case WM_CLOSE:
        {
            TCHAR sz[256];

            double fTimeFor100 = (float)(liTotal) / liFreq ;
            double fTimePer = (float)fTimeFor100 / 100;


            sprintf(sz, TEXT("The average time to render 100 %s is %f, The time to render 100 buttons is %f"), g_szTestWindow, fTimePer, fTimeFor100 );

            MessageBox(NULL, sz, TEXT("Time to render"), 0);

            PostQuitMessage(0);
        }
        break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


int __cdecl main(int cch, char* ppv[])
{
    lstrcpy(g_szTestWindow, TEXT("Button"));

    if (cch > 1)
        lstrcpy(g_szTestWindow, ppv[1]);


    QueryPerformanceFrequency((LARGE_INTEGER*)&liFreq);

    InitCommonControls();
    WNDCLASS wc = {0};
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpfnWndProc = HostWndProc;
    wc.lpszClassName = TEXT("UxThemeTestHost");
    RegisterClass(&wc);

    CreateWindow(TEXT("UxThemeTestHost"), TEXT("UxTheme Perf Testing"), WS_VISIBLE | WS_OVERLAPPEDWINDOW, 0, 0, 600, 600, NULL, NULL, NULL, NULL);

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        DispatchMessage(&msg);
    }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__B6365AB2_8C89_4148_B58F_CBC7DB386F31__INCLUDED_)
#define AFX_MAINFRM_H__B6365AB2_8C89_4148_B58F_CBC7DB386F31__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CFrameWindowImpl<CMainFrame>, public CUpdateUI<CMainFrame>,
        public CMessageFilter, public CIdleHandler
{
public:
    DECLARE_FRAME_WND_CLASS(NULL, IDR_MAINFRAME)

    CThreadCtlPerfView m_view;

    CCommandBarCtrl m_CmdBar;

    virtual BOOL PreTranslateMessage(MSG* pMsg)
    {
        if(CFrameWindowImpl<CMainFrame>::PreTranslateMessage(pMsg))
            return TRUE;

        return m_view.PreTranslateMessage(pMsg);
    }

    virtual BOOL OnIdle()
    {
        UIUpdateToolBar();
        return FALSE;
    }

    BEGIN_MSG_MAP(CMainFrame)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
        COMMAND_ID_HANDLER(ID_APP_EXIT, OnFileExit)
        COMMAND_ID_HANDLER(ID_FILE_NEW, OnFileNew)
        COMMAND_ID_HANDLER(ID_FILE_NEW_WINDOW, OnFileNewWindow)
        COMMAND_ID_HANDLER(ID_VIEW_TOOLBAR, OnViewToolBar)
        COMMAND_ID_HANDLER(ID_VIEW_STATUS_BAR, OnViewStatusBar)
        COMMAND_ID_HANDLER(ID_APP_ABOUT, OnAppAbout)
        CHAIN_MSG_MAP(CUpdateUI<CMainFrame>)
        CHAIN_MSG_MAP(CFrameWindowImpl<CMainFrame>)
    END_MSG_MAP()

    BEGIN_UPDATE_UI_MAP(CMainFrame)
        UPDATE_ELEMENT(ID_VIEW_TOOLBAR, UPDUI_MENUPOPUP)
        UPDATE_ELEMENT(ID_VIEW_STATUS_BAR, UPDUI_MENUPOPUP)
    END_UPDATE_UI_MAP()

    LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
    {
        // create command bar window
        HWND hWndCmdBar = m_CmdBar.Create(m_hWnd, rcDefault, NULL, ATL_SIMPLE_CMDBAR_PANE_STYLE);
        // attach menu
        m_CmdBar.AttachMenu(GetMenu());
        // load command bar images
        m_CmdBar.LoadImages(IDR_MAINFRAME);
        // remove old menu
        SetMenu(NULL);

        HWND hWndToolBar = CreateSimpleToolBarCtrl(m_hWnd, IDR_MAINFRAME, FALSE, ATL_SIMPLE_TOOLBAR_PANE_STYLE);

        CreateSimpleReBar(ATL_SIMPLE_REBAR_NOBORDER_STYLE);
        AddSimpleReBarBand(hWndCmdBar);
        AddSimpleReBarBand(hWndToolBar, NULL, TRUE);
        CreateSimpleStatusBar();

        m_hWndClient = m_view.Create(m_hWnd);

        UIAddToolBar(hWndToolBar);
        UISetCheck(ID_VIEW_TOOLBAR, 1);
        UISetCheck(ID_VIEW_STATUS_BAR, 1);

        CMessageLoop* pLoop = _Module.GetMessageLoop();
        pLoop->AddMessageFilter(this);
        pLoop->AddIdleHandler(this);

        WCHAR wzStatusText[256];
        __int64 liLast;

        ::QueryPerformanceCounter( (LARGE_INTEGER*) &liLast);
        (g_lpfnGetProcessMemoryInfo)(GetCurrentProcess(), &g_ProcessMem, sizeof(g_ProcessMem));
        wsprintf(wzStatusText, _T("Load time: %d ms. Workingset: %d bytes; peak %d bytes"), 
                    UINT(1000 * (liLast - g_liLast) / g_liFreq),
                    g_ProcessMem.WorkingSetSize,
                    g_ProcessMem.PeakWorkingSetSize);
        ::SendMessage(m_hWndStatusBar, SB_SIMPLE, TRUE, 0L);
        ::SendMessage(m_hWndStatusBar, SB_SETTEXT, (255 | SBT_NOBORDERS), (LPARAM)wzStatusText);
        
        if(OpenClipboard())
        {
            wsprintf(wzStatusText, _T("%d %d %d"), 
                    UINT(1000 * (liLast - g_liLast) / g_liFreq),
                    g_ProcessMem.WorkingSetSize,
                    g_ProcessMem.PeakWorkingSetSize);

            int nTextLen = (lstrlen(wzStatusText) + 1) * sizeof(TCHAR);
            HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE, nTextLen);
            if(hGlobal != NULL)
            {
                LPVOID lpText = GlobalLock(hGlobal);
                memcpy(lpText, wzStatusText, nTextLen);

                EmptyClipboard();
                GlobalUnlock(hGlobal);
                SetClipboardData(CF_UNICODETEXT, hGlobal);
            }
            CloseClipboard();
        }

        return 0;
    }

    LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
    {
        bHandled = FALSE;
        ::PostQuitMessage(0);
        ::PostThreadMessage(_Module.m_dwMainThreadID, WM_USER + 1, 0, 0L);
        return 0;
    }

    LRESULT OnMenuSelect(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        return 0;
    }

    LRESULT OnFileExit(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        PostMessage(WM_CLOSE);
        return 0;
    }

    LRESULT OnFileNew(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        // TODO: add code to initialize document

        return 0;
    }

    LRESULT OnFileNewWindow(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        ::PostThreadMessage(_Module.m_dwMainThreadID, WM_USER, 0, 0L);
        return 0;
    }

    LRESULT OnViewToolBar(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        static BOOL bVisible = TRUE;    // initially visible
        bVisible = !bVisible;
        CReBarCtrl rebar = m_hWndToolBar;
        int nBandIndex = rebar.IdToIndex(ATL_IDW_BAND_FIRST + 1);    // toolbar is 2nd added band
        rebar.ShowBand(nBandIndex, bVisible);
        UISetCheck(ID_VIEW_TOOLBAR, bVisible);
        UpdateLayout();
        return 0;
    }

    LRESULT OnViewStatusBar(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        BOOL bVisible = !::IsWindowVisible(m_hWndStatusBar);
        ::ShowWindow(m_hWndStatusBar, bVisible ? SW_SHOWNOACTIVATE : SW_HIDE);
        UISetCheck(ID_VIEW_STATUS_BAR, bVisible);
        UpdateLayout();
        return 0;
    }

    LRESULT OnAppAbout(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
        CAboutDlg dlg;
        dlg.DoModal();
        return 0;
    }
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__B6365AB2_8C89_4148_B58F_CBC7DB386F31__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ThreadCtlPerf.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDD_THREADCTLPERF_FORM          130
#define IDC_TESTBUTTON                  1000
#define IDC_EDIT3                       1001
#define IDC_EDIT_THEME                  1002
#define IDC_CLEARBUTTON                 1003
#define IDC_THEME_ALL                   1004
#define IDC_WS_MINIMIZEBOX              1005
#define IDC_THEME_PROCESS               1006
#define IDC_TARGET                      1007
#define IDC_WS_MAXIMIZEBOX              1008
#define IDC_ENABLE_FRAME                1009
#define IDC_ENABLE_DLG                  1010
#define IDC_THEME_EXEMPT                1011
#define IDC_UNTARGET                    1012
#define IDC_USERSWITCH                  1013
#define IDC_WS_CAPTION                  1014
#define IDC_WS_BORDER                   1015
#define IDC_WS_DLGFRAME                 1016
#define IDC_WS_VSCROLL                  1017
#define IDC_WS_HSCROLL                  1018
#define IDC_WS_SYSMENU                  1019
#define IDC_WS_THICKFRAME               1020
#define IDC_WS_MINIMIZEBOX2             1021
#define IDC_WS_MAXIMIZEBOX2             1022
#define IDC_WS_CAPTION2                 1023
#define IDC_EDIT1                       1024
#define IDC_BUTTON1                     1025
#define IDC_EDIT2                       1026
#define IDC_CHECK1                      1027
#define IDC_RADIO1                      1028
#define IDC_BUTTON4                     1029
#define IDC_COMBO1                      1030
#define IDC_LIST1                       1031
#define IDC_BUTTON5                     1032
#define IDC_LIST2                       1033
#define IDC_RADIO2                      1034
#define IDC_COMBO2                      1035
#define IDC_LIST3                       1036
#define IDC_RADIO3                      1037
#define IDC_COMBO3                      1038
#define IDC_SPIN1                       1039
#define IDC_WS_BORDER2                  1040
#define IDC_WS_DLGFRAME2                1041
#define IDC_WS_VSCROLL2                 1042
#define IDC_WS_HSCROLL2                 1043
#define IDC_WS_SYSMENU2                 1044
#define IDC_WS_THICKFRAME2              1045
#define IDC_SBVERT                      1046
#define IDC_SBHORZ                      1047
#define IDC_VERTICAL                    1048
#define IDC_HORIZONTAL                  1049
#define IDC_WS_EX_DLGMODALFRAME         1050
#define IDC_WS_EX_DLGMODALFRAME2        1051
#define IDC_CHECK2                      1052
#define IDC_PROGRESS1                   1053
#define IDC_MIN                         1054
#define IDC_MAX                         1055
#define IDC_PAGE                        1056
#define IDC_POS                         1057
#define IDC_TRACKPOS                    1058
#define IDC_MSGLIST                     1059
#define IDC_WS_EX_TOOLWINDOW            1060
#define IDC_WS_EX_TOOLWINDOW2           1061
#define IDC_CHECK3                      1062
#define IDC_PROGRESS2                   1063
#define IDC_SBVERTP                     1064
#define IDC_WS_EX_WINDOWEDGE            1065
#define IDC_SLIDER1                     1066
#define IDC_WS_EX_CLIENTEDGE            1067
#define IDC_WS_EX_WINDOWEDGE2           1068
#define IDC_SLIDER2                     1069
#define IDC_WS_EX_CLIENTEDGE2           1070
#define IDC_TAB1                        1071
#define IDC_SBHORZP                     1072
#define IDC_SBCTL_PORT                  1073
#define IDC_WINDOW_SB                   1074
#define IDC_SBCTL_STANDARD              1075
#define IDC_HOTKEY1                     1076
#define IDC_ANIMATE1                    1080
#define IDC_WS_EX_CONTEXTHELP           1081
#define IDC_BUTTON2                     1082
#define IDC_SPIN3                       1083
#define IDC_WS_EX_CONTEXTHELP2          1084
#define IDC_WS_EX_RIGHT                 1085
#define IDC_WS_EX_RIGHT2                1086
#define IDC_BUTTON6                     1087
#define IDC_WS_EX_LEFT                  1088
#define IDC_WS_EX_LEFT2                 1089
#define IDC_DATETIMEPICKER1             1090
#define IDC_TAB2                        1091
#define IDC_BUTTON3                     1100
#define IDC_WS_EX_RTLREADING            1101
#define IDC_WS_EX_RTLREADING2           1102
#define IDC_BUTTON7                     1103
#define IDC_WS_EX_LEFTSCROLLBAR         1104
#define IDC_BUTTON8                     1105
#define IDC_IPADDRESS1                  1106
#define IDC_WS_EX_RIGHTSCROLLBAR        1107
#define IDC_COMBOBOXEX1                 1108
#define IDC_WS_EX_STATICEDGE            1109
#define IDC_WS_EX_LEFTSCROLLBAR2        1110
#define IDC_WS_EX_RIGHTSCROLLBAR2       1111
#define IDC_WS_EX_STATICEDGE2           1112
#define IDC_MONTHCALENDAR1              1113
#define IDC_TREE1                       1120
#define IDC_COMBOBOXEX2                 1121
#define IDC_WS_EX_APPWINDOW             1122
#define IDC_WS_EX_APPWINDOW2            1123
#define IDC_COMBOBOXEX3                 1124
#define IDC_WS_EX_OVERLAPPEDWINDOW      1125
#define IDC_SCROLLBAR1                  1126
#define IDC_WS_EX_PALETTEWINDOW         1127
#define IDC_SCROLLBAR2                  1128
#define IDC_WS_EX_OVERLAPPEDWINDOW2     1129
#define IDC_WS_EX_PALETTEWINDOW2        1130
#define IDC_TREE2                       1131
#define IDC_WS_EX_LAYOUTRTL             1141
#define IDC_REBAR1                      1142
#define IDC_HEADER1                     1143
#define IDC_WS_EX_LAYOUTRTL2            1144
#define IDC_STATUS1                     1146
#define IDC_THEME_PREVIEW               1147
#define IDC_TARGETGROUP                 1148
#define IDC_PREVIEW                     1200
#define IDC_DISPLAYNAME                 1201
#define IDC_TOOLTIP                     1202
#define IDC_AUTHOR                      1203
#define IDC_WS_OVERLAPPED2              1204
#define IDC_WS_POPUP2                   1205
#define IDC_WS_CHILD2                   1206
#define IDC_TEST_WINDOW                 1207
#define IDC_TEST_DIALOG                 1208
#define IDC_CLOSE_TEST_WINDOW           1209
#define ID_FILE_NEW_WINDOW              32771
#define IDC_DIRPROMPT                   35001
#define IDC_DIRNAME                     35002
#define IDC_COLORCOMBO                  35005
#define IDC_SIZECOMBO                   35007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//    ThreadCtlPerf.pch will be the pre-compiled header
//    stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\samples.cpp ===
#include "stdafx.h"
#include "resource.h"

//-------------------------------------------------------------------------//
//  impl for all Samples pages
//-------------------------------------------------------------------------//

void Pickers_Init(HWND hwndPage);
void Movers_Init(HWND hwndPage);
void Lists_Init(HWND hwndPage);
void ListView_Init(HWND hwndPage, int iControlId);
void TreeView_Init(HWND hwndPage, int iControlId);

//---- init routines for "bars" dialog ----
void Header_Init(HWND hwndPage, int iControlId);
void Status_Init(HWND hwndPage, int iControlId);
void Toolbar_Init(HWND hwndPage, int iControlId, int iMaxButtons);
void Rebar_Init(HWND hwndPage, int iControlId);
//-------------------------------------------------------------------------//
// shared sample data

static WCHAR *Names[] = {L"One", L"Two", L"Three", L"Four", L"Five", L"Six",
    L"Seven", L"Eight", L"Nine", L"Ten", L"Eleven", L"Twelve", 
    L"Thirteen", L"Fourteen", L"Fifteen", L"Sixteen"};

static WCHAR *Buttons[] = {L"New", L"Open", L"Save", L"Cut",  L"Copy", L"Delete", 
    L"Undo", L"Redo", L"Print", L"Help\0"};

static int ButtonIndexes[] = {STD_FILENEW, STD_FILEOPEN, STD_FILESAVE, 
    STD_CUT, STD_COPY, STD_DELETE, STD_UNDO, STD_REDOW, STD_PRINT, STD_HELP};

static WCHAR *Columns[] = {L"Name", L"Phone", L"City", L"State"};

static WCHAR *Col1Items[] = {L"Chris", L"Lou", L"Richard", L"Mark", L"Roland", L"Paul",
    L"Scott", L"Aaron", L"Greg", L"Ken"};

static WCHAR *Col2Items[] = {L"555-1212", L"567-3434", L"656-4432", L"343-7788", L"706-0225", L"828-3043",
    L"706-4433", L"882-8080", L"334-3434", L"333-5430"};

static WCHAR *Col3Items[] = {L"Seattle", L"Redmond", L"Bellevue", L"Seattle", L"Woodinville", L"Kirkland",
    L"Kirkland", L"Woodinville", L"Redmond", L"Redmond"};

void InitControls(HWND hwndPage)
{
    Pickers_Init(hwndPage);
    Movers_Init(hwndPage);
    Lists_Init(hwndPage);
    ListView_Init(hwndPage, IDC_LIST1);
    ListView_Init(hwndPage, IDC_LIST2);
    TreeView_Init(hwndPage, IDC_TREE1);
    TreeView_Init(hwndPage, IDC_TREE2);
    Header_Init(hwndPage, IDC_HEADER1);
    Status_Init(hwndPage, IDC_STATUS1);
    //Toolbar_Init(hwndPage, IDC_TOOLBAR1);
    Rebar_Init(hwndPage, IDC_REBAR1);
}

//-------------------------------------------------------------------------//
void Pickers_Init(HWND hwndPage)
{
    HWND hwnd1 = GetDlgItem(hwndPage, IDC_TAB1);
    HWND hwnd2 = GetDlgItem(hwndPage, IDC_TAB2);
    TCITEM item;
    item.mask = TCIF_TEXT;

    for (int i=0; i < 4; i++)
    {
        item.pszText = Names[i];
        SendMessage(hwnd1, TCM_INSERTITEM, i, (LPARAM)&item);
        SendMessage(hwnd2, TCM_INSERTITEM, i, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
void Movers_Init(HWND hwndPage)
{
    HWND hwnd1 = GetDlgItem(hwndPage, IDC_PROGRESS1);
    HWND hwnd2 = GetDlgItem(hwndPage, IDC_PROGRESS2);
 
    SendMessage(hwnd1, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
    SendMessage(hwnd2, PBM_SETRANGE, 0, MAKELPARAM(0, 100));

    SendMessage(hwnd1, PBM_SETPOS, 33, 0);
    SendMessage(hwnd2, PBM_SETPOS, 33, 0);
}
//-------------------------------------------------------------------------//
void Lists_Init(HWND hwndPage)
{
    HWND hwnds[7];

    hwnds[0] = GetDlgItem(hwndPage, IDC_LIST1);
    hwnds[1] = GetDlgItem(hwndPage, IDC_COMBO1);
    hwnds[2] = GetDlgItem(hwndPage, IDC_COMBO2);
    hwnds[3] = GetDlgItem(hwndPage, IDC_COMBO3);
    hwnds[4] = GetDlgItem(hwndPage, IDC_COMBOBOXEX1);
    hwnds[5] = GetDlgItem(hwndPage, IDC_COMBOBOXEX2);
    hwnds[6] = GetDlgItem(hwndPage, IDC_COMBOBOXEX3);

    //---- listbox ----
    SendMessage(hwnds[0], LB_RESETCONTENT, 0, 0);
    for (int j=0; j < ARRAYSIZE(Names); j++)
        SendMessage(hwnds[0], LB_ADDSTRING, 0, (LPARAM)Names[j]);
    SendMessage(hwnds[0], LB_SETCURSEL, 0, 0);

    //---- comboboxes ----
    for (int i=1; i < 4; i++)
    {
        SendMessage(hwnds[i], CB_RESETCONTENT, 0, 0);

        for (int j=0; j < ARRAYSIZE(Names); j++)
            SendMessage(hwnds[i], CB_ADDSTRING, 0, (LPARAM)Names[j]);

        SendMessage(hwnds[i], CB_SETCURSEL, 0, 0);
    }

    //---- combo EX boxes ----
    COMBOBOXEXITEM exitem;
    exitem.mask = CBEIF_TEXT ;

    for (i=4; i < 7; i++)
    {
        SendMessage(hwnds[i], CB_RESETCONTENT, 0, 0);

        for (int j=0; j < ARRAYSIZE(Names); j++)
        {
            exitem.iItem = j;
            exitem.pszText = Names[j];
            SendMessage(hwnds[i], CBEM_INSERTITEM, 0, (LPARAM)&exitem);
        }

        SendMessage(hwnds[i], CB_SETCURSEL, 0, 0);
    }

}
//-------------------------------------------------------------------------//
void ListView_Init(HWND hwndPage, int iControlId) 
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the colums ----
    LVCOLUMN lvc; 
    memset(&lvc, 0, sizeof(lvc));
 
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH; 
    lvc.fmt = LVCFMT_LEFT; 
    lvc.cx = 100; 
 
    // Add the columns. 
    for (int c=0; c < ARRAYSIZE(Columns); c++)
    {
        lvc.iSubItem = c;
        lvc.pszText = Columns[c];
        SendMessage(hwnd, LVM_INSERTCOLUMN, c, (LPARAM)&lvc);
    } 

    //---- initialize the items ----
    LVITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = LVIF_TEXT;

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Col1Items); i++)  
    {
        item.pszText = Col1Items[i];
        item.iItem = i;
        item.iSubItem = 0;
        SendMessage(hwnd, LVM_INSERTITEM, 0, (LPARAM)&item);

        item.iSubItem = 1;
        item.pszText = Col2Items[i];
        SendMessage(hwnd, LVM_SETITEM, 0, (LPARAM)&item);

        item.iSubItem = 2;
        item.pszText = Col3Items[i];
        SendMessage(hwnd, LVM_SETITEM, 0, (LPARAM)&item);
    }
}
//-------------------------------------------------------------------------//
void TreeView_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the item ----
    TVINSERTSTRUCT tvs;
    memset(&tvs, 0, sizeof(tvs));
    tvs.itemex.mask = TVIF_TEXT;
    tvs.hInsertAfter = TVI_LAST;    

    tvs.itemex.pszText = L"Root";
    HTREEITEM hRoot = (HTREEITEM) SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvs);

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Col1Items); i++)  
    {
        tvs.itemex.pszText = Col1Items[i];
        tvs.hParent = hRoot;
        HTREEITEM hItem = (HTREEITEM) SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvs);

        if (hItem)
        {
            TVINSERTSTRUCT tvchild;
            memset(&tvchild, 0, sizeof(tvchild));
            tvchild.itemex.mask = TVIF_TEXT;
            tvchild.hInsertAfter = TVI_LAST;    
            tvchild.hParent = hItem;

            tvchild.itemex.pszText = Col2Items[i];
            SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvchild);

            tvchild.itemex.pszText = Col3Items[i];
            SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvchild);
        }
    }
}
//-------------------------------------------------------------------------//
void Header_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the item ----
    HDITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = HDI_WIDTH | HDI_TEXT;
    item.cxy = 60;

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Columns); i++)  
    {
        item.pszText = Columns[i];
        HTREEITEM hItem = (HTREEITEM) SendMessage(hwnd, HDM_INSERTITEM, i, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
void Status_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- setup the different sections ----
    int Widths[] = {200, 400, 600};
    SendMessage(hwnd, SB_SETPARTS, ARRAYSIZE(Widths), (LPARAM)Widths);

    //---- write some text ----
    SendMessage(hwnd, SB_SETTEXT, 0, (LPARAM)L"First Section");
    SendMessage(hwnd, SB_SETTEXT, 1, (LPARAM)L"Second Section");
    SendMessage(hwnd, SB_SETTEXT, 2, (LPARAM)L"Third Section");
}
//-------------------------------------------------------------------------//
void Toolbar_Init(HWND hwndPage, int iControlId, int iMaxButtons)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- send require toolbar init msg ----
    SendMessage(hwnd, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0); 

    //---- setup the bitmap images for buttons ----
    TBADDBITMAP abm = {HINST_COMMCTRL, IDB_STD_LARGE_COLOR};
    SendMessage(hwnd, TB_ADDBITMAP, 15, (LPARAM)&abm);

    TBBUTTON button;
    memset(&button, 0, sizeof(button));
    button.fsState = TBSTATE_ENABLED; 
    
    //int index = (int)SendMessage(hwnd, TB_ADDSTRING, NULL, (LPARAM)Buttons);

    int cnt = min(iMaxButtons, ARRAYSIZE(Buttons));

    for (int i=0; i < cnt; i++)
    {
        button.fsStyle = TBSTYLE_BUTTON; 
        button.iBitmap = ButtonIndexes[i];
        button.idCommand = i;
        button.iString = 0; // index + i;
        SendMessage(hwnd, TB_ADDBUTTONS, 1, LPARAM(&button));

        if ((i == 2) || (i == 5) || (i == 7) || (i == 9))
        {
            button.fsStyle = BTNS_SEP;
            SendMessage(hwnd, TB_ADDBUTTONS, 1, LPARAM(&button));
        }
    }

    SendMessage(hwnd, TB_AUTOSIZE, 0, 0); 
    ShowWindow(hwnd, SW_SHOW); 
}
//-------------------------------------------------------------------------//
void Rebar_Init(HWND hwndPage, int iControlId)
{
    HWND hwndRB = GetDlgItem(hwndPage, iControlId);
    if (! hwndRB)
        return;
 
   //---- initialize the rebar ----
   REBARINFO rbi;
   rbi.cbSize = sizeof(rbi); 
   rbi.fMask  = 0;
   rbi.himl   = (HIMAGELIST)NULL;
   SendMessage(hwndRB, RB_SETBARINFO, 0, (LPARAM)&rbi);
   
   //---- initialize the band ----
   REBARBANDINFO rbBand;   
   rbBand.cbSize = sizeof(REBARBANDINFO);  
   rbBand.fMask  = RBBIM_TEXT | RBBIM_STYLE | RBBIM_CHILD  | RBBIM_CHILDSIZE | RBBIM_SIZE;
   rbBand.fStyle = RBBS_GRIPPERALWAYS | RBBS_BREAK;
   // rbBand.hbmBack= LoadBitmap(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_BACKGROUND));   
   
   RECT rc;
   HWND hwndCB, hwndTB;

   // Create the combo box control to be added.
   hwndCB = CreateWindowEx(0, L"Combobox", L"Combo Text", WS_VISIBLE | WS_CHILD | WS_BORDER,
       0, 0, 100, 30, hwndRB, (HMENU)51, _Module.GetModuleInstance(), 0);
   
   // Set values unique to the band with the combo box.
   GetWindowRect(hwndCB, &rc);
   rbBand.lpText     = L"Combo Box";
   rbBand.hwndChild  = hwndCB;
   rbBand.cxMinChild = 20;
   rbBand.cyMinChild = HEIGHT(rc);
   rbBand.cx         = 120; // WIDTH(rc) + 20;

   // Add the band that has the combo box.
   LRESULT val = SendMessage(hwndRB, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);

#if 1
   // Create the toolbar control to be added.
   hwndTB = CreateWindowEx(0, TOOLBARCLASSNAME, L"", WS_VISIBLE | WS_CHILD | WS_BORDER,
       0, 0, 500, 30, hwndRB, (HMENU)52, _Module.GetModuleInstance(), 0);
   Toolbar_Init(hwndRB, 52, 3);

   // Set values unique to the band with the toolbar.
   rbBand.lpText     = L"Tool Bar";
   rbBand.hwndChild  = hwndTB;
   rbBand.cxMinChild = 20;

   DWORD dwBtnSize = (DWORD) SendMessage(hwndTB, TB_GETBUTTONSIZE, 0,0);
   rbBand.cyMinChild = HIWORD(dwBtnSize);
   
   GetWindowRect(hwndTB, &rc);
   rbBand.cx         = 450;     // WIDTH(rc) + 20;

   // Add the band that has the toolbar.
   val = SendMessage(hwndRB, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4DE40F48_8B7C_48C1_B976_B4E28340FEC9__INCLUDED_)
#define AFX_STDAFX_H__4DE40F48_8B7C_48C1_B976_B4E28340FEC9__INCLUDED_

// Change these values to use different versions
#ifndef WINVER
#define WINVER        0x0510
#endif
#ifndef _WIN32_IE
#define _WIN32_IE    0x0500
#endif
#define _RICHEDIT_VER    0x0300

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif  ARRAYSIZE

#define WIDTH(r) ((r).right - (r).left)
#define HEIGHT(r) ((r).bottom - (r).top)

#include <atlbase.h>
//#include <atlbase61.h>
#include <atlapp.h>

extern CAppModule _Module;

#include <atlwin.h>
#include <psapi.h>

extern HMODULE g_hPSAPI;
// Process memory counters struct.
extern PROCESS_MEMORY_COUNTERS g_ProcessMem;
// Initial process memory stuff
extern PROCESS_MEMORY_COUNTERS g_ProcessMemInit;
// Function pointer to GetProcessMemoryInfo.
typedef BOOL (_stdcall * PFNGETPROCESSMEMORYINFO)(HANDLE, PPROCESS_MEMORY_COUNTERS, DWORD);
extern PFNGETPROCESSMEMORYINFO g_lpfnGetProcessMemoryInfo;
// Timer
extern __int64 g_liFreq;
extern __int64 g_liLast;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4DE40F48_8B7C_48C1_B976_B4E28340FEC9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\threadctlperf.cpp ===
// ThreadCtlPerf.cpp : main source file for ThreadCtlPerf.exe
//

#include "stdafx.h"

#include <atlframe.h>
#include <atlctrls.h>
#include <atldlgs.h>
#include <atlctrlw.h>


#include "resource.h"

#include "ThreadCtlPerfView.h"
#include "aboutdlg.h"
#include "MainFrm.h"

const UINT knMAX_THREADS = 20;
HMODULE g_hPSAPI = NULL;
// Process memory counters struct.
PROCESS_MEMORY_COUNTERS g_ProcessMem;
// Initial process memory stuff
PROCESS_MEMORY_COUNTERS g_ProcessMemInit;
// Function pointer to GetProcessMemoryInfo.
PFNGETPROCESSMEMORYINFO g_lpfnGetProcessMemoryInfo = NULL;
__int64 g_liFreq = 0;
__int64 g_liLast = 0;

CAppModule _Module;

class CThreadCtlPerfThreadManager
{
public:
    // thread init param
    struct _RunData
    {
        LPTSTR lpstrCmdLine;
        int nCmdShow;
    };

    // thread proc
    static DWORD WINAPI RunThread(LPVOID lpData)
    {
        CMessageLoop theLoop;
        _Module.AddMessageLoop(&theLoop);

        _RunData* pData = (_RunData*)lpData;
        CMainFrame wndFrame;

        if(wndFrame.CreateEx() == NULL)
        {
            ATLTRACE(_T("Frame window creation failed!\n"));
            return 0;
        }

        wndFrame.ShowWindow(pData->nCmdShow);
        ::SetForegroundWindow(wndFrame);    // Win95 needs this
        delete pData;

        int nRet = theLoop.Run();

        _Module.RemoveMessageLoop();
        return nRet;
    }

    DWORD m_dwCount;
    HANDLE m_arrThreadHandles[MAXIMUM_WAIT_OBJECTS - 1];

    CThreadCtlPerfThreadManager() : m_dwCount(0)
    { }

// Operations
    DWORD AddThread(LPTSTR lpstrCmdLine, int nCmdShow)
    {
        if(m_dwCount == (MAXIMUM_WAIT_OBJECTS - 1))
        {
            ::MessageBox(NULL, _T("ERROR: Cannot create ANY MORE threads!!!"), _T("ThreadCtlPerf"), MB_OK);
            return 0;
        }

        _RunData* pData = new _RunData;
        pData->lpstrCmdLine = lpstrCmdLine;
        pData->nCmdShow = nCmdShow;
        DWORD dwThreadID;
        HANDLE hThread = ::CreateThread(NULL, 0, RunThread, pData, 0, &dwThreadID);
        if(hThread == NULL)
        {
            ::MessageBox(NULL, _T("ERROR: Cannot create thread!!!"), _T("ThreadCtlPerf"), MB_OK);
            return 0;
        }

        m_arrThreadHandles[m_dwCount] = hThread;
        m_dwCount++;
        return dwThreadID;
    }

    void RemoveThread(DWORD dwIndex)
    {
        ::CloseHandle(m_arrThreadHandles[dwIndex]);
        if(dwIndex != (m_dwCount - 1))
            m_arrThreadHandles[dwIndex] = m_arrThreadHandles[m_dwCount - 1];
        m_dwCount--;
    }

    int Run(LPTSTR lpstrCmdLine, int nCmdShow)
    {
        MSG msg;
        // force message queue to be created
        ::PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

        (g_lpfnGetProcessMemoryInfo)(GetCurrentProcess(), &g_ProcessMemInit, sizeof(g_ProcessMem));
        ::QueryPerformanceFrequency( (LARGE_INTEGER*) &g_liFreq);
        ::QueryPerformanceCounter( (LARGE_INTEGER*) &g_liLast);

        UINT nMaxThreads = 0;
        
        nMaxThreads = wcstol(lpstrCmdLine, 0, 10);

        if (nMaxThreads == 0)
            nMaxThreads = knMAX_THREADS;

        AddThread(lpstrCmdLine, nCmdShow);

        int nRet = m_dwCount;
        DWORD dwRet;
        while(m_dwCount > 0)
        {
            dwRet = ::MsgWaitForMultipleObjects(m_dwCount, m_arrThreadHandles, FALSE, INFINITE, QS_ALLINPUT);

            if(dwRet == 0xFFFFFFFF)
                ::MessageBox(NULL, _T("ERROR: Wait for multiple objects failed!!!"), _T("ThreadCtlPerf"), MB_OK);
            else if(dwRet >= WAIT_OBJECT_0 && dwRet <= (WAIT_OBJECT_0 + m_dwCount - 1))
                RemoveThread(dwRet - WAIT_OBJECT_0);
            else if(dwRet == (WAIT_OBJECT_0 + m_dwCount))
            {
                ::GetMessage(&msg, NULL, 0, 0);
                if(msg.message == WM_USER && m_dwCount < nMaxThreads)
                    AddThread(_T(""), SW_SHOWNORMAL);
                else if(msg.message == WM_USER + 1)
                    m_dwCount = 0;
                else
                    ::MessageBeep((UINT)-1);
            }
            else
                ::MessageBeep((UINT)-1);
        }

        return nRet;
    }
};

int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpstrCmdLine, int nCmdShow)
{
    HRESULT hRes = ::CoInitialize(NULL);
// If you are running on NT 4.0 or higher you can use the following call instead to 
// make the EXE free threaded. This means that calls come in on a random RPC thread.
//    HRESULT hRes = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
    ATLASSERT(SUCCEEDED(hRes));

#if (_WIN32_IE >= 0x0300)
    INITCOMMONCONTROLSEX iccx;
    iccx.dwSize = sizeof(iccx);
    //iccx.dwICC = ICC_COOL_CLASSES | ICC_BAR_CLASSES;
    iccx.dwICC = 0x3FFF;
    BOOL bRet = ::InitCommonControlsEx(&iccx);
    bRet;
    ATLASSERT(bRet);
#else
    ::InitCommonControls();
#endif

    hRes = _Module.Init(NULL, hInstance);
    ATLASSERT(SUCCEEDED(hRes));


    g_hPSAPI = ::LoadLibrary(_T("PSAPI.DLL"));
    int nRet = -1;
   
    if (g_hPSAPI)
    {
        // Load the function:
        g_lpfnGetProcessMemoryInfo = (PFNGETPROCESSMEMORYINFO)::GetProcAddress(g_hPSAPI, "GetProcessMemoryInfo");
        if (NULL != g_lpfnGetProcessMemoryInfo)
        {
            CThreadCtlPerfThreadManager mgr;
            nRet = mgr.Run(lpstrCmdLine, nCmdShow);
        }
        ::FreeLibrary(g_hPSAPI);
    }
    _Module.Term();
    ::CoUninitialize();

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\threadctlperfview.h ===
// ThreadCtlPerfView.h : interface of the CThreadCtlPerfView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_THREADCTLPERFVIEW_H__58D2A5C1_4E6F_472E_9F16_1F648CFBADF6__INCLUDED_)
#define AFX_THREADCTLPERFVIEW_H__58D2A5C1_4E6F_472E_9F16_1F648CFBADF6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

extern void InitControls(HWND hwndPage);

class CThreadCtlPerfView : public CDialogImpl<CThreadCtlPerfView>
{
public:
    enum { IDD = IDD_THREADCTLPERF_FORM };

    BOOL PreTranslateMessage(MSG* pMsg)
    {
        return IsDialogMessage(pMsg);
    }

    BEGIN_MSG_MAP(CThreadCtlPerfView)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

    LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
    {
        bHandled = FALSE;
        InitControls(m_hWnd);
        ::PostThreadMessage(_Module.m_dwMainThreadID, WM_USER, 0, 0L);
        return 0;
    }
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_THREADCTLPERFVIEW_H__58D2A5C1_4E6F_472E_9F16_1F648CFBADF6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\test\threadctlperf\threadctlperf.h ===
// ThreadCtlPerf.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\candy\makefile.inc ===
Candy.mstheme : themes.ini default.ini
    packthem .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\empty\makefile.inc ===
$(O)\empty.mst : themes.ini default.ini
    packthem /o $(O)\empty.mst /k .
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\luna\makefile.inc ===
$(O)\luna.mst : themes.ini Blue\Blue.ini Metallic\Metallic.ini Homestead\Homestead.ini
    packthem /o $(O)\luna.mst /k .
     $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\mallard\makefile.inc ===
$(O)\Test.mst : themes.ini default.ini paler.ini
    packthem /o $(O)\Test.mst /k .
     $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\native\makefile.inc ===
Native.mstheme : themes.ini default.ini 
    packthem .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\professional\makefile.inc ===
$(O)\pro.mst : themes.ini default.ini
    packthem /o $(O)\pro.mst /k .
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\makefile.inc ===
#
# cpstyle.uix is precompiled to include common Control Panel style information
# from shell\inc and theme-specific metrics information from the local project.
# This produces cpstyle.ui which is then included in shellstyle.rc
#
shellstyle.rc : $(O)\cpstyle.ui $(O)\style.ui

$(O)\cpstyle.ui : $(O)\cpstyle.uipp
    cleaninf -w $(O)\cpstyle.uipp $(O)\cpstyle.ui

$(O)\cpstyle.uipp : cpstyle.uix
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@

cpstyle.uix : ..\cpstyle_common.uix

$(O)\style.ui : $(O)\style.uipp
    cleaninf -w $(O)\style.uipp $(O)\style.ui

$(O)\style.uipp : style.uix
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\classic\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\common.h ===
#ifndef _COMMON_H_
#define _COMMON_H_


//
// Strings
//

#define IDS_TAHOMA                     1
#define IDS_FRANKLIN_GOTHIC_MEDIUM     2

#define IDS_FONT_WEIGHT_BOLD          10
#define IDS_FONT_WEIGHT_LGTITLE       11
#define IDS_FONT_WEIGHT_LGTEXT        12

#define IDS_FONT_SIZE_8               15
#define IDS_FONT_SIZE_10              16
#define IDS_FONT_SIZE_14              17
#define IDS_FONT_SIZE_21              18


//
// Bitmaps
//
// ID's below 100 are defined in shell\inc\shstyle.h
// ID's above 499 are defined in the theme specific header files
//

#define IDB_UP                       100
#define IDB_UPHOT                    101
#define IDB_DOWN                     102
#define IDB_DOWNHOT                  103
#define IDB_UPMAIN                   104
#define IDB_UPHOTMAIN                105
#define IDB_DOWNMAIN                 106
#define IDB_DOWNHOTMAIN              107

#define IDB_HEADERMAIN               110
#define IDB_HEADERSECTION            112

#endif // _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\classic\class_ss.h ===
// header file for classic theme specific elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\metallic\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themefiles\bla\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\blue\blue_ss.h ===
// header file for blue theme specific elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themefiles\dtc\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\blue\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themefiles\common\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themefiles\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themefiles\per\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themefiles\srv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themefiles\pro\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\homestead\home_ss.h ===
// header file for homestead theme specific elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\homestead\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themefiles\makefile.inc ===
# files on the cd need to be 8.3 (rename is taken care of in shl_img.inf)

$(O)\luna.the : Luna.theme
    copy $** $@

$(O)\classic.the : classic.theme
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\ntlparse.cpp ===
//---------------------------------------------------------------------------
//  NtlParse.cpp - parses a ".ntl" file (Native Theme Language)
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "scanner.h"
#include "NtlParse.h"
#include "Utils.h"
#include "SysMetrics.h"
#include "stringtable.h"
//---------------------------------------------------------------------------
#define SYSCOLOR_STRINGS
#include "SysColors.h"
//---------------------------------------------------------------------------
CNtlParser::CNtlParser()
{
    _pPCode = NULL;
    _iPCodeAllocSize = 0;

    _iIfLevel = 0;

    for (int i=0; i < ARRAYSIZE(_iStateOffsets); i++)
        _iStateOffsets[i] = 0;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::SourceError(int iMsgResId, ...)
{
    va_list args;
	va_start(args, iMsgResId);

    LPCWSTR pszParam1 = va_arg(args, LPCWSTR);
    LPCWSTR pszParam2 = va_arg(args, LPCWSTR);

    HRESULT hr = MakeErrorEx(iMsgResId, pszParam1, pszParam2,  _scan._szFileName, 
        _scan._szLineBuff,  _scan._iLineNum);
    
    va_end(args);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseBuffer(LPCWSTR pszSource, LPCWSTR pszSourceFileName,
    INtlParserCallBack *pCallBack, OUT BYTE **ppPCode, OUT int *piLen)
{
    HRESULT hr = S_OK;
    _pCallBack = pCallBack;

    _scan.AttachMultiLineBuffer(pszSource, pszSourceFileName);

    //---- jump to state table at end ----
    hr = EmitByte(NTL_JMP);
    if (FAILED(hr))
        goto exit;

    int iStateJumpOffset;
    iStateJumpOffset = int(_u.pb - _pPCode);

    hr = EmitInt(0);
    if (FAILED(hr))
        goto exit;

    if (! _scan.GetChar('['))
    {
        if (! _scan.EndOfFile())
        {
            hr = SourceError(IDS_MISSING_SECTION_LBRACKET);
            goto exit;
        }
    }

    while (! _scan.EndOfFile())           // process each section
    {
        WCHAR section[_MAX_PATH+1];
        _scan.GetId(section);

        if (lstrcmpi(section, L"OptionBits")==0)
        {
            hr = ParseOptionBitsSection();
        }
        else if (lstrcmpi(section, L"Drawing")==0)
        {
            hr = ParseDrawingSection();
        }
        else        // "globals", "sysmetrics", or class section
        {
            hr = SourceError(IDS_UNKNOWN_SECTION_NAME);
        }

        if (FAILED(hr))
            break;
    }

    if (FAILED(hr))
        goto exit;

    //---- update first jump to state table ----
    int *ip;
    ip = (int *)(_pPCode + iStateJumpOffset);
    *ip = (int)(_u.pb - _pPCode);

    //---- build state table at end of stream ----
    BYTE iMaxState;
    iMaxState = 0;
    for (BYTE i=ARRAYSIZE(_iStateOffsets)-1; i >= 0; i--)
    {
        if (_iStateOffsets[i])
        {
            iMaxState = i;
            break;
        }
    }

    hr = EmitByte(iMaxState);
    if (FAILED(hr))
        goto exit;

    for (int i=1; i <= iMaxState; i++)
    {
        hr = EmitInt(_iStateOffsets[i]);
        if (FAILED(hr))
            goto exit;
    }

exit:
    if (SUCCEEDED(hr))
    {
        *ppPCode = _pPCode;
        *piLen = (int)(_u.pb - _pPCode);
    }
    else
        delete [] _pPCode;

    _pPCode = NULL;
    _iPCodeAllocSize = 0;

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseOptionBitsSection()
{
    HRESULT hr = S_OK;
    WCHAR szOptionName[_MAX_PATH+1];

    if (!_scan.GetChar(']'))
        hr = SourceError(IDS_EXPECTED_END_OF_SECTION);
    else
    {
        while (! _scan.EndOfFile())
        {
            if (_scan.GetChar('['))         // start of new section
                break;

            if (! _scan.GetId(szOptionName))
            {
                hr = SourceError(IDS_OPTIONNAME_EXPECTED);
                break;
            }

            if (! _scan.GetChar('='))
            {
                hr = SourceError(IDS_EXPECTED_EQUALS_SIGN);
                break;
            }

            int iOptionValue;
            if (! _scan.GetNumber(&iOptionValue))
            {
                hr = SourceError(IDS_INT_EXPECTED);
                break;
            }

            hr = AddOptionBitName(szOptionName, iOptionValue);
            if (FAILED(hr))
                break;
        }
    }

    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::AddOptionBitName(LPCWSTR szOptionName, int iOptionValue)
{
    HRESULT hr = S_OK;
    OPTIONBITENTRY option;
    
    option.csName = szOptionName;
    option.iValue = iOptionValue;

    for (int i=0; i < _OptionBits.m_nSize; i++)
    {
        if ((iOptionValue == _OptionBits[i].iValue) && (lstrcmpi(szOptionName, _OptionBits[i].csName)==0))
            break;
    }

    if (i < _OptionBits.m_nSize)        // found
        hr = SourceError(IDS_ALREADY_DEFINED);
    else
        _OptionBits.Add(option);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::GetBitnumVal(LPCWSTR szName, BYTE *piValue)
{
    HRESULT hr;

    hr = MakeErrorEx(IDS_UNKNOWN_BITNAME, szName);
    for (BYTE i=0; i < _OptionBits.m_nSize; i++)
    {
        if (lstrcmpi(szName, _OptionBits[i].csName)==0)
        {
            *piValue = i;
            hr = S_OK;
            break;
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseDrawingSection()
{
    HRESULT hr = S_OK;
    WCHAR szStateName[_MAX_PATH+1];
    WCHAR szCmd[_MAX_PATH+1];

    if (! _scan.GetChar('('))
    {
        hr = SourceError(IDS_LEFTPAREN_EXPECTED);
        goto exit;
    }
    
    if (! _scan.GetId(szStateName))
    {
        hr = SourceError(IDS_STATENAME_EXPECTED);
        goto exit;
    }

    BYTE iStateNum;
    hr = GetStateNum(szStateName, &iStateNum);
    if (FAILED(hr))
        goto exit;
    
    if ((iStateNum < 1) || (iStateNum > MAX_STATES))
    {
        hr = SourceError(IDS_UNKNOWN_STATE, szStateName);
        goto exit;
    }

    _iStateOffsets[iStateNum] = int(_u.pb - _pPCode);

    if (! _scan.GetChar(']'))
    {
        hr = SourceError(IDS_RBRACKET_EXPECTED);
        goto exit;
    }

    while (! _scan.EndOfFile())
    {
        if (_scan.GetChar('['))         // start of new section
            break;

        if (! _scan.GetId(szCmd))
        {
            hr = SourceError(IDS_DRAWINGPROP_EXPECTED);
            break;
        }

        if (! _scan.GetChar('='))
        {
            hr = SourceError(IDS_EXPECTED_EQUALS_SIGN);
            break;
        }

        if (lstrcmpi(szCmd, L"AddBorder")==0)
            hr = ParseAddBorder();
        else if (lstrcmpi(szCmd, L"FillBorder")==0)
            hr = ParseFillBorder();
        else if (lstrcmpi(szCmd, L"LogicalRect")==0)
            hr = ParseLogicalRect();
        else if (lstrcmpi(szCmd, L"FillBrush")==0)
            hr = ParseFillBrush();
        else if (lstrcmpi(szCmd, L"LineBrush")==0)
            hr = ParseLineBrush();
        else if (lstrcmpi(szCmd, L"MoveTo")==0)
            hr = ParseMoveTo();
        else if (lstrcmpi(szCmd, L"LineTo")==0)
            hr = ParseLineTo();
        else if (lstrcmpi(szCmd, L"CurveTo")==0)
            hr = ParseCurveTo();
        else if (lstrcmpi(szCmd, L"Shape")==0)
            hr = ParseShape();
        else if (lstrcmpi(szCmd, L"EndShape")==0)
            hr = ParseEndShape();
        else if (lstrcmpi(szCmd, L"if")==0)
            hr = ParseIf();
        else if (lstrcmpi(szCmd, L"else")==0)
            hr = ParseElse();
        else if (lstrcmpi(szCmd, L"endif")==0)
            hr = ParseEndIf();
        else if (lstrcmpi(szCmd, L"SetOption")==0)
            hr = ParseSetOption();
        else if (lstrcmpi(szCmd, L"GotoState")==0)
            hr = ParseGotoState();
        else
            hr = SourceError(IDS_DRAWINGPROP_EXPECTED);

        if (FAILED(hr))
            goto exit;

        if (! _scan.EndOfLine())
        {
            hr =  SourceError(IDS_EXTRA_PROP_TEXT, _scan._p);
            goto exit;
        }

        _scan.ForceNextLine();
    }

    if (SUCCEEDED(hr))
        hr = EmitByte(NTL_RETURN);          // return to caller (no params)

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseLogicalRect()
{
    HRESULT hr;
    
    hr = EmitByte(NTL_LOGRECT);

    if (SUCCEEDED(hr))
    {
        if (! _scan.GetKeyword(L"RECT"))
        {
            hr = SourceError(IDS_RECT_EXPECTED);
        }
        else
        {
            hr = ParseEmitRect();
        }
    }
    
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::EmitCheck(int iLen)
{
    HRESULT hr = S_OK;

    int iOffset = (int)(_u.pb - _pPCode);

    if (iOffset + iLen > _iPCodeAllocSize)
    {
        int iSize = _iPCodeAllocSize + 4096;
        BYTE *pNew = (BYTE *)realloc(_pPCode, iSize);

        if (! pNew)
        {
            hr = MakeError32(E_OUTOFMEMORY);
        }
        else
        {
            _pPCode = pNew;
            _iPCodeAllocSize = iSize;
            _u.pb = _pPCode + iOffset;
        }
    }   

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::EmitByte(BYTE eOpCode)
{
    HRESULT hr = EmitCheck(1);
    if (SUCCEEDED(hr))
    {
        *_u.pb++ = eOpCode;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::EmitInt(int iValue)
{
    HRESULT hr = EmitCheck(sizeof(int));
    if (SUCCEEDED(hr))
    {
        *_u.pi++ = iValue;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::EmitShort(SHORT sValue)
{
    HRESULT hr = EmitCheck(sizeof(SHORT));
    if (SUCCEEDED(hr))
    {
        *_u.ps++ = sValue;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::EmitString(LPCWSTR szValue)
{
    int len = sizeof(WCHAR) * (1 + lstrlen(szValue));

    HRESULT hr = EmitCheck(len);
    if (SUCCEEDED(hr))
    {
        lstrcpy(_u.pw, szValue);
        _u.pb += len;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitPoint()
{
    HRESULT hr = S_OK;
    int ix, iy;

    if (! _scan.GetNumber(&ix))
    {
        hr = SourceError(IDS_INT_EXPECTED);
        goto exit;
    }

    if (! _scan.GetNumber(&iy))
    {
        hr = SourceError(IDS_INT_EXPECTED);
        goto exit;
    }

    hr = EmitInt(ix);
    if (FAILED(hr))
        goto exit;

    hr = EmitInt(iy);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitRect()
{
    HRESULT hr = S_OK;
    int iValue;
    
    for (int i=0; i < 4; i++)
    {
        if (! _scan.GetNumber(&iValue))
        {
            hr = SourceError(IDS_INT_EXPECTED);
            goto exit;
        }

        hr = EmitInt(iValue);
        if (FAILED(hr))
            goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitSize2()
{
    HRESULT hr = ParseEmitSize();          // first size
    if (FAILED(hr))
        goto exit;

    if (_scan.GetChar(','))
    {
        hr = ParseEmitSize();              // second size
        if (FAILED(hr))
            goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitSize4()
{
    HRESULT hr = ParseEmitSize();          // first size
    if (FAILED(hr))
        goto exit;

    if (_scan.GetChar(','))
    {
        hr = ParseEmitSize();              // second size
        if (FAILED(hr))
            goto exit;

        if (_scan.GetChar(','))
        {
            hr = ParseEmitSize();          // third size
            if (FAILED(hr))
                goto exit;

            if (! _scan.GetChar(','))
            {
                hr = SourceError(IDS_COMMA_EXPECTED);
                goto exit;
            }

            hr = ParseEmitSize();          // forth size
            if (FAILED(hr))
                goto exit;
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitSize()
{
    HRESULT hr = S_OK;
    int iValue;
    WCHAR szId[_MAX_PATH+1];

    if (_scan.GetNumber(&iValue))
    {
        hr = EmitInt(iValue);
        if (FAILED(hr))
            goto exit;
    }
    else if (_scan.GetId(szId))
    {
        int cnt = ARRAYSIZE(pszSysMetricIntNames);
        for (SHORT i=0; i < cnt; i++)
        {
            if (lstrcmpi(szId, pszSysMetricIntNames[i])==0)
            {
                hr = EmitByte(PT_SYSMETRICINDEX);
                if (FAILED(hr))
                    goto exit;

                hr = EmitShort(i);
                if (FAILED(hr))
                    goto exit;

                break;
            }

            if (i == cnt)
            {
                hr = SourceError(IDS_SIZE_EXPECTED);
                goto exit;
            }
        }
    }
    else
        hr = SourceError(IDS_SIZE_EXPECTED);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitImagefile()
{
    HRESULT hr = S_OK;

    int iIndex;
    if (! _scan.GetNumber(&iIndex))
        iIndex = 0;

    //---- emit imagefile ----
    hr = EmitByte(PT_IMAGEFILE);
    if (FAILED(hr))
        goto exit;

    hr = EmitByte((BYTE)iIndex);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitColor4()
{
    HRESULT hr = ParseEmitColor();          // first color
    if (FAILED(hr))
        goto exit;

    if (_scan.GetChar(','))
    {
        hr = ParseEmitColor();              // second color
        if (FAILED(hr))
            goto exit;

        if (_scan.GetChar(','))
        {
            hr = ParseEmitColor();          // third color
            if (FAILED(hr))
                goto exit;

            if (! _scan.GetChar(','))
            {
                hr = SourceError(IDS_COMMA_EXPECTED);
                goto exit;
            }

            hr = ParseEmitColor();          // forth color
            if (FAILED(hr))
                goto exit;
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitColor()
{
    HRESULT hr = S_OK;
    int iRed, iGreen, iBlue;
    WCHAR szColorId[_MAX_PATH+1];

    if (_scan.GetNumber(&iRed))         // RGB numbers specified
    {
        hr = EmitByte(PT_COLORREF);
        if (FAILED(hr))
            goto exit;

        if (! _scan.GetNumber(&iGreen))
        {
            hr = SourceError(IDS_INT_EXPECTED);
            goto exit;
        }

        if (! _scan.GetNumber(&iBlue))
        {
            hr = SourceError(IDS_INT_EXPECTED);
            goto exit;
        }

        COLORREF cr = RGB(iRed, iGreen, iBlue);

        hr = EmitInt(cr);
        if (FAILED(hr))
            goto exit;
    }
    else if (_scan.GetId(szColorId))
    {
        if (lstrcmpi(szColorId, L"NONE"))
            hr = EmitByte(PT_COLORNULL);
        else 
        {
            for (SHORT i=0; i < iSysColorSize; i++)
            {
                if (lstrcmpi(szColorId, pszSysColorNames[i])==0)
                {
                    hr = EmitByte(PT_SYSCOLORINDEX);
                    if (SUCCEEDED(hr))
                        hr = EmitShort(i);
                    break;
                }
            }

            if (i == iSysColorSize)
                hr = SourceError(IDS_COLORVALUE_EXPECTED);
        }
    }
    else
        hr = SourceError(IDS_COLORVALUE_EXPECTED);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEmitNone()
{
    HRESULT hr = EmitByte(PT_COLORNULL);
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseAddBorder()
{
    HRESULT hr = S_OK;

    while (SUCCEEDED(hr))
    {
        if (_scan.GetKeyword(L"SIZE"))
        {
            hr = ParseEmitSize4();
        }
        else if (_scan.GetKeyword(L"COLOR"))
        {
            hr = ParseEmitColor4();
        }
        else
            break;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseFillBorder()
{
    HRESULT hr = S_OK;

    while (SUCCEEDED(hr))
    {
        if (_scan.GetKeyword(L"COLOR"))
        {
            hr = ParseEmitColor();
        }
        else if (_scan.GetKeyword(L"IMAGEFILE"))
        {
            hr = ParseEmitImagefile();
        }
        else if (_scan.GetKeyword(L"NONE"))
        {
            hr = ParseEmitNone();
        }
        else
            break;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseFillBrush()
{
    HRESULT hr;
    
    hr = EmitByte(NTL_FILLBRUSH);

    while (SUCCEEDED(hr))
    {
        if (_scan.GetKeyword(L"COLOR"))
        {
            hr = ParseEmitColor();
        }
        else if (_scan.GetKeyword(L"IMAGEFILE"))
        {
            hr = ParseEmitImagefile();
        }
        else if (_scan.GetKeyword(L"NONE"))
        {
            hr = ParseEmitNone();
        }
        else
            break;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseLineBrush()
{
    HRESULT hr;
    
    hr = EmitByte(NTL_LINEBRUSH);

    if (_scan.GetKeyword(L"NONE"))
    {
        hr = ParseEmitNone();
    }
    else
    {
        while (SUCCEEDED(hr))
        {
            if (_scan.GetKeyword(L"COLOR"))
            {
                hr = ParseEmitColor();
            }
            else if (_scan.GetKeyword(L"SIZE"))
            {
                hr = ParseEmitSize();
            }
            else
                break;
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseMoveTo()
{
    HRESULT hr;
    
    hr = EmitByte(NTL_MOVETO);
    
    if (SUCCEEDED(hr))
    {
        if (! _scan.GetKeyword(L"POINT"))
            hr = SourceError(IDS_POINT_EXPECTED);
        else
            hr = ParseEmitPoint();
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseLineTo()
{
    HRESULT hr;
    
    hr = EmitByte(NTL_LINETO);
    
    if (SUCCEEDED(hr))
    {
        if (! _scan.GetKeyword(L"POINT"))
            hr = SourceError(IDS_POINT_EXPECTED);
        else
            hr = ParseEmitPoint();
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseCurveTo()
{
    HRESULT hr;
    
    hr = EmitByte(NTL_CURVETO);
    
    if (SUCCEEDED(hr))
    {
        if (! _scan.GetKeyword(L"POINT"))
            hr = SourceError(IDS_POINT_EXPECTED);
    }

    if (SUCCEEDED(hr))
        hr = ParseEmitPoint();
    
    if (SUCCEEDED(hr))
        hr = ParseEmitPoint();
    
    if (SUCCEEDED(hr))
        hr = ParseEmitPoint();

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseShape()
{
    HRESULT hr;
    
    hr = EmitByte(NTL_SHAPE);
    
    if (SUCCEEDED(hr))
    {
        if (! _scan.GetKeyword(L"POINT"))
            hr = SourceError(IDS_POINT_EXPECTED);
    }

    if (SUCCEEDED(hr))
        hr = ParseEmitPoint();

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEndShape()
{
    HRESULT hr;
    
    hr = EmitByte(NTL_ENDSHAPE);
    
    if (SUCCEEDED(hr))
    {
        if (! _scan.GetKeyword(L"POINT"))
            hr = SourceError(IDS_POINT_EXPECTED);
    }

    if (SUCCEEDED(hr))
        hr = ParseEmitPoint();

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseIf()
{
    HRESULT hr = S_OK;
    WCHAR szId[_MAX_PATH+1];
    NTL_OPCODE opcode;
    IFRECORD ifrec;
    
    if (! _scan.GetId(szId))
    {
        hr = SourceError(IDS_OPTIONNAME_EXPECTED);
        goto exit;
    }

    BYTE iBitnum;
    hr = GetBitnumVal(szId, &iBitnum);
    if (FAILED(hr))
        goto exit;

    if (! _scan.GetChar('('))
    {
        hr = SourceError(IDS_LEFTPAREN_EXPECTED);
        goto exit;
    }

    if (_scan.GetKeyword(L"on"))
    {
        opcode = NTL_JMPOFF;
    }
    else if (_scan.GetKeyword(L"off"))
    {
        opcode = NTL_JMPON;
    }
    else
    {
        hr = SourceError(IDS_ONOFF_EXPECTED);
        goto exit;
    }

    if (! _scan.GetChar(')'))
    {
        hr = SourceError(IDS_LEFTPAREN_EXPECTED);
        goto exit;
    }

    hr = EmitByte(static_cast<BYTE>(opcode));
    if (FAILED(hr))
        goto exit;

    hr = EmitByte(iBitnum);
    if (FAILED(hr))
        goto exit;

    //---- create a new active IFRECORD ----
    if (_iIfLevel == MAX_IF_NESTING)
    {
        hr = SourceError(IDS_MAX_IFNESTING);
        goto exit;
    }

    ifrec.iBitNum = iBitnum;
    ifrec.fIfOn = (opcode == NTL_JMPOFF);
    ifrec.iIfOffset = (int)(_u.pb - _pPCode);
    ifrec.iElseOffset = 0;

    _IfStack[_iIfLevel++] = ifrec;

    //---- emit the jump offset ----
    hr = EmitInt(0);        // will be fixed up later
    if (FAILED(hr))
        goto exit;

    
exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseElse()
{
    HRESULT hr = S_OK;
    WCHAR szId[_MAX_PATH+1];
    
    if (! _scan.GetId(szId))
    {
        hr = SourceError(IDS_OPTIONNAME_EXPECTED);
        goto exit;
    }

    BYTE iBitnum;
    hr = GetBitnumVal(szId, &iBitnum);
    if (FAILED(hr))
        goto exit;

    if (! _scan.GetChar('('))
    {
        hr = SourceError(IDS_LEFTPAREN_EXPECTED);
        goto exit;
    }

    BOOL fElseOn;
    if (_scan.GetKeyword(L"on"))
    {
        fElseOn = TRUE;
    }
    else if (_scan.GetKeyword(L"off"))
    {
        fElseOn = FALSE;
    }
    else
    {
        hr = SourceError(IDS_ONOFF_EXPECTED);
        goto exit;
    }

    if (! _scan.GetChar(')'))
    {
        hr = SourceError(IDS_LEFTPAREN_EXPECTED);
        goto exit;
    }

    //---- emit the JMP ----
    hr = EmitByte(NTL_JMP);
    if (FAILED(hr))
        goto exit;

    //---- validate the IFRECORD ----
    if (! _iIfLevel)
    {
        hr = SourceError(IDS_NOMATCHINGIF);
        goto exit;
    }
    
    IFRECORD *ifrec;
    ifrec = &_IfStack[_iIfLevel - 1];

    if (ifrec->iBitNum != iBitnum)
    {
        hr = SourceError(IDS_WRONG_IF_BITNAME);
        goto exit;
    }

    if (ifrec->fIfOn == fElseOn)
    {
        hr = SourceError(IDS_WRONG_ELSE_PARAM);
        goto exit;
    }
    
    //---- update the IFRECORD ----
    ifrec->iElseOffset = (int)(_u.pb - _pPCode);

    //---- emit the jump offset ----
    hr = EmitInt(0);        // will be fixed up later

    //---- fixup the IF jmp ----
    int *ip;
    ip = (int *)(_pPCode + ifrec->iIfOffset);
    *ip = (int)(_u.pb - _pPCode);      // point to next instruction
    ifrec->iIfOffset = 0;       // update no longer needed
    
exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseEndIf()
{
    HRESULT hr = S_OK;
    WCHAR szId[_MAX_PATH+1];
    
    if (! _scan.GetId(szId))
    {
        hr = SourceError(IDS_OPTIONNAME_EXPECTED);
        goto exit;
    }

    BYTE iBitnum;
    hr = GetBitnumVal(szId, &iBitnum);
    if (FAILED(hr))
        goto exit;

    //---- validate the IFRECORD ----
    if (! _iIfLevel)
    {
        hr = SourceError(IDS_NOMATCHINGIF);
        goto exit;
    }
    
    IFRECORD *ifrec;
    ifrec = &_IfStack[_iIfLevel - 1];

    if (ifrec->iBitNum != iBitnum)
    {
        hr = SourceError(IDS_WRONG_IF_BITNAME);
        goto exit;
    }

    //---- fixup where needed ----
    int *ip;
    if (ifrec->iIfOffset)
        ip = (int *)(_pPCode + ifrec->iIfOffset);
    else
        ip = (int *)(_pPCode + ifrec->iElseOffset);

    *ip = (int)(_u.pb - _pPCode);      // point to next instruction

    _iIfLevel--;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseSetOption()
{
    HRESULT hr = S_OK;
    WCHAR szId[_MAX_PATH+1];
    
    if (! _scan.GetId(szId))
    {
        hr = SourceError(IDS_OPTIONNAME_EXPECTED);
        goto exit;
    }

    BYTE iBitnum;
    hr = GetBitnumVal(szId, &iBitnum);
    if (FAILED(hr))
        goto exit;

    if (! _scan.GetChar('('))
    {
        hr = SourceError(IDS_LEFTPAREN_EXPECTED);
        goto exit;
    }

    BYTE opcode;
    if (_scan.GetKeyword(L"on"))
    {
        opcode = NTL_SETOPTION;
    }
    else if (_scan.GetKeyword(L"off"))
    {
        opcode = NTL_CLROPTION;
    }
    else
    {
        hr = SourceError(IDS_ONOFF_EXPECTED);
        goto exit;
    }

    hr = EmitByte(opcode);
    if (FAILED(hr))
        goto exit;
    
    hr = EmitByte(iBitnum);
    
exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::ParseGotoState()
{
    HRESULT hr = S_OK;
    WCHAR szId[_MAX_PATH+1];
    
    if (! _scan.GetId(szId))
    {
        hr = SourceError(IDS_STATEID_EXPECTED);
        goto exit;
    }

    BYTE iStateNum;
    hr = GetStateNum(szId, &iStateNum);
    if (FAILED(hr))
        goto exit;

    if ((iStateNum < 1) || (iStateNum > MAX_STATES))
    {
        hr = SourceError(IDS_BAD_STATENUM);
        goto exit;
    }

    if (! _iStateOffsets[iStateNum])
    {
        hr = SourceError(IDS_STATE_MUST_BE_DEFINED, szId);
        goto exit;
    }

    EmitByte(NTL_JMP);
    EmitInt(_iStateOffsets[iStateNum]);
    
exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CNtlParser::GetStateNum(LPCWSTR pszStateName, BYTE *piNum)
{
    HRESULT hr;

    if (_pCallBack)
        hr = _pCallBack->GetStateNum(pszStateName, piNum);
    else
    {
        hr = MakeError32(ERROR_INTERNAL_ERROR);     
        Log(LOG_ERROR, L"CNtlParser::GetStateNum - no callback defined");
    }
    
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\scanner.cpp ===
//---------------------------------------------------------------------------
//  Scanner.cpp - supports parsing general text files & lines with
//                a ";" style comment (rest of line is comment)
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "scanner.h"
#include "utils.h"
//---------------------------------------------------------------------------
CScanner::CScanner(LPCWSTR pszTextToScan)
{
    ResetAll(FALSE);

    _p = pszTextToScan;
    _pSymbol = NULL;
}
//---------------------------------------------------------------------------
CScanner::~CScanner()
{
    ResetAll(TRUE);
}
//---------------------------------------------------------------------------
void CScanner::UseSymbol(LPCWSTR pszSymbol)
{
    if (pszSymbol == NULL)
    {
        if (_pSymbol && *_p)
        {
            _p = _pSymbol;
        }
        _pSymbol = NULL;
    }
    else
    {
        _pSymbol = _p;
        _p = pszSymbol;
    }
}
//---------------------------------------------------------------------------
BOOL CScanner::ReadNextLine()
{
    if ((! _pszMultiLineBuffer) || (! *_pszMultiLineBuffer))          // end of multiple lines
    {
        _fEndOfFile = TRUE;
        return FALSE;
    }

    WCHAR *q = _szLineBuff;
    while ((*_pszMultiLineBuffer) && (*_pszMultiLineBuffer != '\r') && (*_pszMultiLineBuffer != '\n'))
        *q++ = *_pszMultiLineBuffer++;

    *q = 0;

    if (*_pszMultiLineBuffer == '\r')
        _pszMultiLineBuffer++;

    if (*_pszMultiLineBuffer == '\n')
        _pszMultiLineBuffer++;

    _p = _szLineBuff;
    _fBlankSoFar = TRUE;
    _iLineNum++;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::SkipSpaces()
{
    while (1)
    {
        while (IsSpace(*_p))
            _p++;

        if ((! *_p) || (*_p == ';'))      // end of line 
        {
            if ((_fBlankSoFar) && (! _fEndOfFile))
            {
                ReadNextLine();
                continue;
            }
        
            if (*_p == ';')              // comment
                _p += lstrlen(_p);         // skip to end of line

            return FALSE;
        }

        //---- good chars on this line ----
        _fBlankSoFar = FALSE;
        break;
    }

    return (*_p != 0);
}
//---------------------------------------------------------------------------
BOOL CScanner::GetId(LPWSTR pszIdBuff, DWORD dwMaxLen)
{
    if (! dwMaxLen)               // must have at least 1 space for NULL terminator
        return FALSE;

    SkipSpaces();

    WCHAR *v = pszIdBuff;

    while ((IsNameChar(FALSE)) && (--dwMaxLen))
        *v++ = *_p++;
    *v = 0;

    if (v == pszIdBuff)        // no chars found
        return FALSE;

    if (IsNameChar(FALSE))          // ran out of room
        return FALSE;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::GetIdPair(LPWSTR pszIdBuff, LPWSTR pszValueBuff, DWORD dwMaxLen)
{
    if (! dwMaxLen)               // must have at least 1 space for NULL terminator
        return FALSE;

    if (!GetId(pszIdBuff, dwMaxLen))
        return FALSE;

    if (!GetChar('='))
        return FALSE;

    SkipSpaces();
    // Take everything until the end of line
    lstrcpyn(pszValueBuff, _p, dwMaxLen);

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::GetFileName(LPWSTR pszFileNameBuff, DWORD dwMaxLen)
{
    if (! dwMaxLen)               // must have at least 1 space for NULL terminator
        return FALSE;

    SkipSpaces();

    WCHAR *v = pszFileNameBuff;

    while ((IsFileNameChar(FALSE)) && (--dwMaxLen))
        *v++ = *_p++;
    *v = 0;

    if (v == pszFileNameBuff)        // no chars found
        return FALSE;

    if (IsFileNameChar(FALSE))          // ran out of room
        return FALSE;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::GetNumber(int *piVal)
{
    SkipSpaces();

    if (! IsNumStart())
        return FALSE;

    *piVal = string2number(_p);
    if ((_p[0] == '0') && ((_p[1] == 'x') || (_p[1] == 'X')))      // hex num
        _p += 2;
    else
        _p++;            // skip over digit or sign

    //---- skip over number ---
    while (IsHexDigit(*_p))
        _p++;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::IsNameChar(BOOL fOkToSkip)
{
    if (fOkToSkip)
        SkipSpaces();

    return ((IsCharAlphaNumericW(*_p)) || (*_p == '_') || (*_p == '-'));
}
//---------------------------------------------------------------------------
BOOL CScanner::IsFileNameChar(BOOL fOkToSkip)
{
    if (fOkToSkip)
        SkipSpaces();

    return ((IsCharAlphaNumericW(*_p)) || (*_p == '_') || (*_p == '-') ||
        (*_p == ':') || (*_p == '\\') || (*_p == '.'));
}
//---------------------------------------------------------------------------
BOOL CScanner::IsNumStart()
{
    SkipSpaces();

    return ((IsDigit(*_p)) || (*_p == '-') || (*_p == '+'));
}
//---------------------------------------------------------------------------
BOOL CScanner::GetChar(const WCHAR val)
{
    SkipSpaces();

    if (*_p != val)
        return FALSE;

    _p++;        // skip over WCHAR
    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::GetKeyword(LPCWSTR pszKeyword)
{
    SkipSpaces();

    int len = lstrlenW(pszKeyword);

    LPWSTR p = (LPWSTR)alloca( (len+1)*sizeof(WCHAR));
    if (! p)
        return FALSE;

    lstrcpynW(p, _p, len);

    if (AsciiStrCmpI(p, pszKeyword)==0)
    {
        _p += len;
        return TRUE;
    }
    
    return FALSE;
}
//---------------------------------------------------------------------------
BOOL CScanner::EndOfLine()
{
    SkipSpaces();
    return (*_p == 0);
}
//---------------------------------------------------------------------------
BOOL CScanner::EndOfFile()
{
    return _fEndOfFile;
}
//---------------------------------------------------------------------------
BOOL CScanner::AttachLine(LPCWSTR pszLine)
{
    ResetAll(TRUE);
    _p = pszLine;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::AttachMultiLineBuffer(LPCWSTR pszBuffer, LPCWSTR pszFileName)
{
    ResetAll(TRUE);

    _p = _szLineBuff;
    _pszMultiLineBuffer = pszBuffer;

    lstrcpy_truncate(_szFileName, pszFileName, ARRAYSIZE(_szFileName));

    return TRUE;
}
//---------------------------------------------------------------------------
HRESULT CScanner::AttachFile(LPCWSTR pszFileName)
{
    ResetAll(TRUE);

    HRESULT hr = AllocateTextFile(pszFileName, &_pszFileText, NULL);
    if (FAILED(hr))
        return hr;

    _pszMultiLineBuffer = _pszFileText;

    lstrcpy_truncate(_szFileName, pszFileName, ARRAYSIZE(_szFileName));

    return S_OK;
}
//---------------------------------------------------------------------------
void CScanner::ResetAll(BOOL fPossiblyAllocated)
{
    _iLineNum = 0;
    _fEndOfFile = FALSE;
    _pszMultiLineBuffer = NULL;
    _fUnicodeInput = TRUE;
    _fBlankSoFar = TRUE;

    *_szFileName = 0;
    *_szLineBuff = 0;
    _p = _szLineBuff;

    if (fPossiblyAllocated)
    {
        if (_pszFileText)
        {
            LocalFree(_pszFileText);
            _pszFileText = NULL;
        }
    }
    else
        _pszFileText = NULL;
}
//---------------------------------------------------------------------------
BOOL CScanner::ForceNextLine()
{
    ReadNextLine();

    if (! SkipSpaces())
        return FALSE;

    return TRUE;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\log.cpp ===
//---------------------------------------------------------------------------
//    log.cpp - theme logging routines (shared in "inc" directory)
//---------------------------------------------------------------------------
#include "stdafx.h"
//---------------------------------------------------------------------------
#include "log.h"
#include <time.h>
#include <psapi.h>
#include "cfile.h"
#include "tmreg.h"
//---------------------------------------------------------------------------
//---- undo the defines that turn these into _xxx ----
#undef Log    
#undef LogStartUp    
#undef LogShutDown   
#undef LogControl    
#undef TimeToStr     
#undef StartTimer    
#undef StopTimer     
#undef OpenLogFile   
#undef CloseLogFile  
#undef LogOptionOn
#undef GetMemUsage
#undef GetUserCount
#undef GetGdiCount
//---------------------------------------------------------------------------
#define DEFAULT_LOGNAME                 L"c:\\Themes.log"
//---------------------------------------------------------------------------
struct LOGNAMEINFO
{
    LPCSTR pszOption;
    LPCSTR pszDescription;
};
//---------------------------------------------------------------------------
#define MAKE_LOG_STRINGS
#include "logopts.h"        // log options as strings
//-----------------------------------------------------------------
static const WCHAR szDayOfWeekArray[7][4] = { L"Sun", L"Mon", L"Tue", L"Wed", 
    L"Thu", L"Fri", L"Sat" } ;

static const WCHAR szMonthOfYearArray[12][4] = { L"Jan", L"Feb", L"Mar", 
    L"Apr", L"May", L"Jun", L"Jul", L"Aug", L"Sep", L"Oct", L"Nov", L"Dec" } ;
//-----------------------------------------------------------------
#define OPTIONCNT  (ARRAYSIZE(LogNames))

#define LOGPROMPT   "enter log cmd here."
//-----------------------------------------------------------------
//---- unprotected vars (set on init) ----
static WCHAR _szUtilProcessName[MAX_PATH] = {0};
static WCHAR _szLogAppName[MAX_PATH]      = {0};
static CRITICAL_SECTION csLogFile         = {0};
static BOOL bcsLogInited = FALSE;

static WCHAR szLogFileName[MAX_PATH+1];   
static BOOL fLogInitialized = FALSE;

//---- protected vars (thread safe) ----
static UCHAR uLogOptions[OPTIONCNT];        // protected by csLogFile
static UCHAR uBreakOptions[OPTIONCNT];      // protected by csLogFile
static DWORD dwLogStartTimer = 0;           // protected by csLogFile

static char szLastOptions[999] = {0};       // protected by csLogFile
static char szLogCmd[999] = {0};            // protected by csLogFile
static int iIndentCount = 0;                // protected by csLogFile

static WCHAR s_szWorkerBuffer[512];         // protected by csLogFile
static WCHAR s_szLogBuffer[512];            // protected by csLogFile
static CHAR s_szConBuffer[512];             // protected by csLogFile

static CSimpleFile *pLogFile = NULL;        // protected by csLogFile
//-----------------------------------------------------------------
void ParseLogOptions(UCHAR *uOptions, LPCSTR pszName, LPCSTR pszOptions, BOOL fEcho);
//-----------------------------------------------------------------
void RawCon(LPCSTR pszFormat, ...)
{
    CAutoCS cs(&csLogFile);

    va_list args;
    va_start(args, pszFormat);

    //---- format caller's string ----
    wvsprintfA(s_szConBuffer, pszFormat, args);

    OutputDebugStringA(s_szConBuffer);

    va_end(args);
}
//-----------------------------------------------------------------
void SetDefaultLoggingOptions()
{
    RESOURCE HKEY hklm = NULL;
    HRESULT hr = S_OK;

    //---- open hklm ----
    int code32 = RegOpenKeyEx(HKEY_LOCAL_MACHINE, THEMEMGR_REGKEY, 0,
        KEY_READ, &hklm);
    if (code32 != ERROR_SUCCESS)       
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- read the "LogCmd" value ----
    WCHAR szValBuff[MAX_PATH];
    hr = RegistryStrRead(hklm, THEMEPROP_LOGCMD, szValBuff, ARRAYSIZE(szValBuff));
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        ParseLogOptions(uLogOptions, "Log", W2A(szValBuff), FALSE);
    }

    //---- read the "BreakCmd" value ----
    hr = RegistryStrRead(hklm, THEMEPROP_BREAKCMD, szValBuff, ARRAYSIZE(szValBuff));
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        ParseLogOptions(uBreakOptions, "Break", W2A(szValBuff), FALSE);
    }

    //---- read the "LogAppName" value ----
    RegistryStrRead(hklm, THEMEPROP_LOGAPPNAME, _szLogAppName, ARRAYSIZE(_szLogAppName));

exit:
    if (hklm)
        RegCloseKey(hklm);
}
//-----------------------------------------------------------------
BOOL LogStartUp()
{
    BOOL fInit = FALSE;

    dwLogStartTimer = StartTimer();

    pLogFile = new CSimpleFile;
    if (! pLogFile)
        goto exit;

    //---- reset all log options ----
    for (int i=0; i < OPTIONCNT; i++)
    {
        uLogOptions[i] = 0;
        uBreakOptions[i] = 0;
    }

    //---- turn on default OUTPUT options ----
    uLogOptions[LO_CONSOLE] = TRUE;
    uLogOptions[LO_APPID] = TRUE;
    uLogOptions[LO_THREADID] = TRUE;

    //---- turn on default FILTER options ----
    uLogOptions[LO_ERROR] = TRUE;
    uLogOptions[LO_ASSERT] = TRUE;
    uLogOptions[LO_BREAK] = TRUE;
    uLogOptions[LO_PARAMS] = TRUE;
    uLogOptions[LO_ALWAYS] = TRUE;

    //---- turn on default BREAK options ----
    uBreakOptions[LO_ERROR] = TRUE;
    uBreakOptions[LO_ASSERT] = TRUE;

    InitializeCriticalSection(&csLogFile);
    bcsLogInited = TRUE;

    //---- get process name (log has its own copy) ----
    WCHAR szPath[MAX_PATH];
    if (! GetModuleFileNameW( NULL, szPath, ARRAYSIZE(szPath) ))
        goto exit;

    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szExt[_MAX_EXT];
    _wsplitpath(szPath, szDrive, szDir, _szUtilProcessName, szExt);

    strcpy(szLogCmd, LOGPROMPT);

    lstrcpy(szLogFileName, DEFAULT_LOGNAME);

    fLogInitialized = TRUE;

    SetDefaultLoggingOptions();
    fInit = TRUE;

exit:
    return fInit;
}
//---------------------------------------------------------------------------
BOOL LogShutDown()
{
    fLogInitialized = FALSE;

    SAFE_DELETE(pLogFile);

    if (bcsLogInited)
    {
        DeleteCriticalSection(&csLogFile);
    }

    return TRUE;
}
//---------------------------------------------------------------------------
void GetDateString(WCHAR *pszDateBuff, ULONG uMaxBuffChars)
{
    // Sent Date
    SYSTEMTIME stNow;
    WCHAR szMonth[10], szWeekDay[12] ; 

    GetLocalTime(&stNow);

    lstrcpynW(szWeekDay, szDayOfWeekArray[stNow.wDayOfWeek], ARRAYSIZE(szWeekDay)) ;
    lstrcpynW(szMonth, szMonthOfYearArray[stNow.wMonth-1], ARRAYSIZE(szMonth)) ;

    wsprintfW(pszDateBuff, L"%s, %u %s %u %2d:%02d:%02d ", szWeekDay, stNow.wDay, 
                                szMonth, stNow.wYear, stNow.wHour, 
                                stNow.wMinute, stNow.wSecond) ;
}
//---------------------------------------------------------------------------
void LogMsgToFile(LPCWSTR pszMsg)
{
    CAutoCS autoCritSect(&csLogFile);

    HRESULT hr;
    BOOL fWasOpen = pLogFile->IsOpen();

    if (! fWasOpen)
    {
        BOOL fNewFile = !FileExists(szLogFileName);
    
        hr = pLogFile->Append(szLogFileName, TRUE);
        if (FAILED(hr))
            goto exit;

        //---- write hdr if new file ----
        if (fNewFile)
        {
            WCHAR pszBuff[100];
            GetDateString(pszBuff, ARRAYSIZE(pszBuff));
            pLogFile->Printf(L"Theme log - %s\r\n\r\n", pszBuff);
        }
    }

    pLogFile->Write((void*)pszMsg, lstrlen(pszMsg)*sizeof(WCHAR));

exit:
    if (! fWasOpen)
        pLogFile->Close();
}
//---------------------------------------------------------------------------
void SimpleFileName(LPCSTR pszNarrowFile, OUT LPWSTR pszSimpleBuff)
{
    USES_CONVERSION;
    WCHAR *pszFile = A2W(pszNarrowFile);

    //---- remove current dir marker for VS error navigation ----
    if ((pszFile[0] == L'.') && (pszFile[1] == L'\\'))
    {
        wsprintf(pszSimpleBuff, L"f:\\nt\\shell\\Themes\\UxTheme\\%s", pszFile+2);
        
        if (! FileExists(pszSimpleBuff))
            wsprintf(pszSimpleBuff, L"f:\\nt\\shell\\Themes\\ThemeSel\\%s", pszFile+2);

        if (! FileExists(pszSimpleBuff))
            wsprintf(pszSimpleBuff, L"f:\\nt\\shell\\Themes\\packthem\\%s", pszFile+2);

        if (! FileExists(pszSimpleBuff))
            wsprintf(pszSimpleBuff, L"%s", pszFile+2);
    }
    else
        lstrcpy(pszSimpleBuff, pszFile);
}
//-----------------------------------------------------------------
#ifdef DEBUG                // pulls in psapi.dll
int GetMemUsage()
{
    ULONG           ulReturnLength;
    VM_COUNTERS     vmCounters;

    if (!NT_SUCCESS(NtQueryInformationProcess(GetCurrentProcess(),
                                              ProcessVmCounters,
                                              &vmCounters,
                                              sizeof(vmCounters),
                                              &ulReturnLength)))
    {
        ZeroMemory(&vmCounters, sizeof(vmCounters));
    }
    return static_cast<int>(vmCounters.WorkingSetSize);
}
#else
int GetMemUsage()
{
    return 0;
}
#endif 
//-----------------------------------------------------------------
int GetUserCount()
{
    HANDLE hp = GetCurrentProcess();
    return GetGuiResources(hp, GR_USEROBJECTS);
}
//-----------------------------------------------------------------
int GetGdiCount()
{
    HANDLE hp = GetCurrentProcess();
    return GetGuiResources(hp, GR_GDIOBJECTS);
}
//-----------------------------------------------------------------
void LogWorker(UCHAR uLogOption, LPCSTR pszSrcFile, int iLineNum, int iEntryExitCode, LPCWSTR pszMsg)
{
    CAutoCS cs(&csLogFile);

    WCHAR *p = s_szWorkerBuffer;
    BOOL fBreaking = (uBreakOptions[uLogOption]);

    if (fBreaking)     
    {
        OutputDebugString(L"\r\n");     // blank line at beginning

        WCHAR fn[_MAX_PATH+1];
        SimpleFileName(pszSrcFile, fn);

        wsprintf(s_szWorkerBuffer, L"%s [%d]: BREAK at %s(%d):\r\n", 
            _szUtilProcessName, GetCurrentThreadId(), fn, iLineNum);

        OutputDebugString(s_szWorkerBuffer);
    }

    //---- PRE API entry/exit indent adjustment ----
    if (iEntryExitCode == -1)
    {
        if (iIndentCount >= 2)
            iIndentCount -= 2;
    }

    //---- apply indenting ----
    for (int i=0; i < iIndentCount; i++)
        *p++ = ' ';

    //---- POST API entry/exit indent adjustment ----
    if (iEntryExitCode == 1)
    {
        iIndentCount += 2;
    }

    //---- apply app id ----
    if (uLogOptions[LO_APPID])
    {
        wsprintf(p, L"%s ", _szUtilProcessName);
        p += lstrlen(p);
    }

    //---- apply thread id ----
    if (uLogOptions[LO_THREADID])
    {
        wsprintf(p, L"[%d] ", GetCurrentThreadId());
        p += lstrlen(p);
    }

    //---- apply src id ----
    if (uLogOptions[LO_SRCID]) 
    {
        WCHAR fn[_MAX_PATH+1];
        SimpleFileName(pszSrcFile, fn);

        if (fBreaking)
            wsprintf(p, L"BREAK at %s(%d) : ", fn, iLineNum);
        else
            wsprintf(p, L"%s(%d) : ", fn, iLineNum);

        p += lstrlen(p);
    }
    
    //---- apply timer id ----
    if (uLogOptions[LO_TIMERID])
    {
        DWORD dwTicks = StopTimer(dwLogStartTimer);

        WCHAR buff[100];
        TimeToStr(dwTicks, buff);

        wsprintf(p, L"Timer: %s ", buff);
        p += lstrlen(p);
    }

    //---- apply clock id ----
    if (uLogOptions[LO_CLOCKID])
    {
        SYSTEMTIME stNow;
        GetLocalTime(&stNow);

        wsprintf(p, L"Clock: %02d:%02d:%02d.%03d ", stNow.wHour, 
            stNow.wMinute, stNow.wSecond, stNow.wMilliseconds);
        p += lstrlen(p);
    }

    //---- apply USER count ----
    if (uLogOptions[LO_USERCOUNT])
    {
        wsprintf(p, L"UserCount=%d ", GetUserCount());
        p += lstrlen(p);
    }

    //---- apply GDI count ----
    if (uLogOptions[LO_GDICOUNT])
    {
        wsprintf(p, L"GDICount=%d ", GetGdiCount());
        p += lstrlen(p);
    }

    //---- apply MEM usage ----
    if (uLogOptions[LO_MEMUSAGE])
    {
        int iUsage = GetMemUsage();
        wsprintf(p, L"MemUsage=%d ", iUsage);
        p += lstrlen(p);
    }

    //---- add "Assert:" or "Error:" strings as needed ----
    if (uLogOption == LO_ASSERT) 
    {
        lstrcpy(p, L"Assert: ");
        p += lstrlen(p);
    }
    else if (uLogOption == LO_ERROR) 
    {
        lstrcpy(p, L"Error: ");
        p += lstrlen(p);
    }
    
    //---- apply caller's msg ----
    lstrcpy(p, pszMsg);
    p += lstrlen(p);
    *p++ = '\r';        // end with CR
    *p++ = '\n';        // end with newline
    *p = 0;             // terminate string

    //---- log to CONSOLE and/or FILE ----
    if (uLogOptions[LO_CONSOLE])
        OutputDebugString(s_szWorkerBuffer);

    if (uLogOptions[LO_LOGFILE])
        LogMsgToFile(s_szWorkerBuffer);

    //---- process Heap Check ----
    if (uLogOptions[LO_HEAPCHECK])
    {
        HANDLE hh = GetProcessHeap();
        HeapValidate(hh, 0, NULL);
    }

    if (fBreaking)   
        OutputDebugString(L"\r\n");     // blank line at end

}
//-----------------------------------------------------------------
HRESULT OpenLogFile(LPCWSTR pszLogFileName)
{
    CAutoCS cs(&csLogFile);

    HRESULT hr = pLogFile->Create(pszLogFileName, TRUE);
    return hr;
}
//-----------------------------------------------------------------
void CloseLogFile()
{
    CAutoCS cs(&csLogFile);

    if (pLogFile)
        pLogFile->Close();
}
//-----------------------------------------------------------------
void Log(UCHAR uLogOption, LPCSTR pszSrcFile, int iLineNum, int iEntryExitCode, LPCWSTR pszFormat, ...)
{
    if (fLogInitialized)
    {
        CAutoCS cs(&csLogFile);

        //---- only log for a specified process? ----
        if (* _szLogAppName)
        {
            if (lstrcmpi(_szLogAppName, _szUtilProcessName) != 0)
                return;
        }

        while (1)
        {
            if (strncmp(szLogCmd, LOGPROMPT, 6)!=0)
            {
                LogControl(szLogCmd, TRUE);
                strcpy(szLogCmd, LOGPROMPT);
            
                DEBUG_BREAK;
            }
            else
                break;
        }

        if ((uLogOption >= 0) || (uLogOption < OPTIONCNT))
        {
            if (uLogOptions[uLogOption])
            {
                //---- apply caller's msg ----
                va_list args;
                va_start(args, pszFormat);
                wvsprintfW(s_szLogBuffer, pszFormat, args);
                va_end(args);
        
                LogWorker(uLogOption, pszSrcFile, iLineNum, iEntryExitCode, s_szLogBuffer);

            }

            if ((uBreakOptions[uLogOption]) && (uLogOption != LO_ASSERT))
                DEBUG_BREAK;
        }
    }
}
//-----------------------------------------------------------------
int MatchLogOption(LPCSTR lszOption)
{
    for (int i=0; i < OPTIONCNT; i++)
    {
        if (lstrcmpiA(lszOption, LogNames[i].pszOption)==0)
            return i;
    }

    return -1;      // not found
}
//-----------------------------------------------------------------
void ParseLogOptions(UCHAR *uOptions, LPCSTR pszName, LPCSTR pszOptions, BOOL fEcho)
{
    CAutoCS cs(&csLogFile);

    if (! fLogInitialized)
        return;

    //---- ignore debugger's multiple eval of same expression ----
    if (strcmp(pszOptions, szLastOptions)==0)
        return;

    //---- make a copy of options so we can put NULLs in it ----
    BOOL fErrors = FALSE;
    char szOptions[999];
    char *pszErrorText = NULL;
    strcpy(szOptions, pszOptions);

    //---- process each option in szOption ----
    char *p = strchr(szOptions, '.');
    if (p)      // easy termination for NTSD users
        *p = 0;

    p = szOptions;
    while (*p == ' ')
        p++;

    while ((p) && (*p))
    {
        //---- find end of current option "p" ----
        char *q = strchr(p, ' ');
        if (q)
            *q = 0;

        UCHAR fSet = TRUE;
        if (*p == '+')
            p++;
        else if (*p == '-')
        {
            fSet = FALSE;
            p++;
        }
        
        if (! fErrors)          // point to first error in case one is found
            pszErrorText = p;  

        int iLogOpt = MatchLogOption(p);

        if (iLogOpt != -1)
        {
            if (iLogOpt == LO_ALL)
            {
                for (int i=0; i < OPTIONCNT; i++)
                    uOptions[i] = fSet;
            }
            else
                uOptions[iLogOpt] = fSet;
        }
        else
            fErrors = TRUE;

        //---- skip to next valid space ----
        if (! q)
            break;

        q++;
        while (*q == ' ')
            q++;
        p = q;
    }

    //---- fixup inconsistent option settings ----
    if (! uOptions[LO_LOGFILE])
        uOptions[LO_CONSOLE] = TRUE;

    if ((! fErrors) && (fEcho))         
    {
        //---- display active log options ----
        BOOL fNoneSet = TRUE;

        RawCon("Active %s Options:\n", pszName);

        for (int i=0; i < LO_ALL; i++)
        {
            if (uOptions[i])
            {
                RawCon("+%s ", LogNames[i].pszOption);
                fNoneSet = FALSE;
            }
        }

        if (fNoneSet)
            RawCon("<none>\n");
        else
            RawCon("\n");

        //---- display active log filters (except "all") ----
        RawCon("Active Msg Filters:\n  ");

        for (i=LO_ALL+1; i < OPTIONCNT; i++)
        {
            if (uOptions[i])
            {
                RawCon("+%s ", LogNames[i].pszOption);
                fNoneSet = FALSE;
            }
        }

        if (fNoneSet)
            RawCon("<none>\n");
        else
            RawCon("\n");
    }
    else if (fErrors)
    {
        //---- one or more bad options - display available options ----
        RawCon("Error - unrecognized %s option: %s\n", pszName, pszErrorText);

        if (fEcho)
        {
            RawCon("Available Log Options:\n");
            for (int i=0; i < LO_ALL; i++)
            {
                RawCon("  +%-12s %s\n", 
                    LogNames[i].pszOption, LogNames[i].pszDescription);
            }

            RawCon("Available Msg Filters:\n");
            for (i=LO_ALL; i < OPTIONCNT; i++)
            {
                RawCon("  +%-12s %s\n", 
                    LogNames[i].pszOption, LogNames[i].pszDescription);
            }
        }
    }

    strcpy(szLastOptions, pszOptions);
}
//-----------------------------------------------------------------
void LogControl(LPCSTR pszOptions, BOOL fEcho)
{
    ParseLogOptions(uLogOptions, "Log", pszOptions, fEcho);
}
//---------------------------------------------------------------------------
DWORD StartTimer()
{
    LARGE_INTEGER now;
    QueryPerformanceCounter(&now);

    return DWORD(now.QuadPart);
}
//---------------------------------------------------------------------------
DWORD StopTimer(DWORD dwStartTime)
{
    LARGE_INTEGER now;
    QueryPerformanceCounter(&now);

    return DWORD(now.QuadPart) - dwStartTime;
}
//---------------------------------------------------------------------------
void TimeToStr(UINT uRaw, WCHAR *pszBuff)
{
    LARGE_INTEGER freq;
    QueryPerformanceFrequency(&freq);
    DWORD Freq = (UINT)freq.QuadPart;

    const _int64 factor6 = 1000000;
    _int64 secs = uRaw*factor6/Freq;

    wsprintfW(pszBuff, L"%u.%04u secs", UINT(secs/factor6), UINT(secs%factor6)/100);    
}
//---------------------------------------------------------------------------
BOOL LogOptionOn(int iLogOption)
{
    if ((iLogOption < 0) || (iLogOption >= OPTIONCNT))
        return FALSE;

    return (uLogOptions[iLogOption] != 0);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\stdafx.cpp ===
//---------------------------------------------------------------------------
//  stdafx.cpp - builds the precompiled hdr
//---------------------------------------------------------------------------
#include "stdafx.h"
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\errors.cpp ===
//---------------------------------------------------------------------------
//    errors.cpp - support for error handling/reporting
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <time.h>
#include "utils.h"
#include "errors.h"
//---------------------------------------------------------------------------
DWORD _tls_ErrorInfoIndex = 0xffffffff;         // index to tls pObjectPool
//---------------------------------------------------------------------------
TMERRINFO *GetParseErrorInfo(BOOL fOkToCreate)
{
    TMERRINFO *ei = NULL;

    if (_tls_ErrorInfoIndex != 0xffffffff)     // init-ed in ProcessAttach()
    {
        ei = (TMERRINFO *)TlsGetValue(_tls_ErrorInfoIndex);
        if ((! ei) && (fOkToCreate))          // not yet initialized
        {
            //---- create a thread-local TMERRINFO ----
            ei = new TMERRINFO;
            TlsSetValue(_tls_ErrorInfoIndex, ei);
        }
    }

    return ei;
}
//---------------------------------------------------------------------------
HRESULT MakeParseError(DWORD dwParseErrCode, OPTIONAL LPCWSTR pszMsgParam1, 
    OPTIONAL LPCWSTR pszMsgParam2, OPTIONAL LPCWSTR pszSourceName, 
    OPTIONAL LPCWSTR pszSourceLine, int iLineNum)
{
    TMERRINFO *pErrInfo = GetParseErrorInfo(TRUE);

    if (pErrInfo)       // record err info for later use
    {
        pErrInfo->dwParseErrCode = dwParseErrCode;
        pErrInfo->iLineNum = iLineNum;

        lstrcpy_truncate(pErrInfo->szMsgParam1, pszMsgParam1, ARRAYSIZE(pErrInfo->szMsgParam1));
        lstrcpy_truncate(pErrInfo->szMsgParam2, pszMsgParam2, ARRAYSIZE(pErrInfo->szMsgParam2));

        lstrcpy_truncate(pErrInfo->szFileName, pszSourceName, ARRAYSIZE(pErrInfo->szFileName));
        lstrcpy_truncate(pErrInfo->szSourceLine, pszSourceLine, ARRAYSIZE(pErrInfo->szSourceLine));
    }

    return HRESULT_FROM_WIN32(ERROR_UNKNOWN_PROPERTY);      // special code for parse failed
}
//---------------------------------------------------------------------------
HRESULT MakeError32(HRESULT hr)
{
    return HRESULT_FROM_WIN32(hr);
}
//---------------------------------------------------------------------------
HRESULT MakeErrorLast()
{
    HRESULT hr = GetLastError();
    return HRESULT_FROM_WIN32(hr);
}
//---------------------------------------------------------------------------
HRESULT MakeErrorParserLast()
{
    return HRESULT_FROM_WIN32(ERROR_UNKNOWN_PROPERTY);      // parse error info has already been set
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themedir\shellstyle\metallic\metal_ss.h ===
// header file for metallic theme specific elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\parser.cpp ===
//---------------------------------------------------------------------------
//  Parser.cpp - parses a "themes.ini" file and builds the ThemeInfo entries
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "scanner.h"
#include "Parser.h"
#include "Utils.h"
#include "TmUtils.h"
#include "TmSchema.h"
#include "TmReg.h"
//---------------------------------------------------------------------------
//#include "NtlParse.h"

#define SYSCOLOR_STRINGS
#include "SysColors.h"
//---------------------------------------------------------------------------
#define SCHEMA_STRINGS
#include "TmSchema.h"       // implements GetSchemaInfo()

#ifdef DEBUG
     // TODO: Isn't synchronized anymore (different processes), need to use a volatile reg key instead
    DWORD g_dwStockSize = 0;
#endif

static HBITMAP (*s_pfnSetBitmapAttributes)(HBITMAP, DWORD) = NULL;
static HBITMAP (*s_pfnClearBitmapAttributes)(HBITMAP, DWORD) = NULL;

//--------------------------------------------------------------------
CThemeParser::CThemeParser(BOOL fGlobalTheme)
{
    _pCallBackObj = NULL;
    _pNameCallBack = NULL;
    _fGlobalsDefined = FALSE;
    _fClassSectionDefined = FALSE;
    _fDefiningColorScheme = FALSE;
    _fUsingResourceProperties = FALSE;
    _fDefiningMetrics = FALSE;
    _fMetricsDefined = FALSE;
    _fGlobalTheme = FALSE;
    _crBlend = RGB(0, 0, 0xFF); // Hard code to blue
    
    *_szResPropValue = 0;       // not yet set

#ifdef DEBUG
    // Provide a means of disabling stock bitmaps
    BOOL fStock = TRUE;
    GetCurrentUserThemeInt(L"StockBitmaps", TRUE, &fStock);

    if (fStock && fGlobalTheme)
#else
    if (fGlobalTheme)
#endif
    {
        // Just don't use stock bitmaps when not running on Whistler
        if (s_pfnSetBitmapAttributes != NULL) 
        {
            _fGlobalTheme = TRUE;
        } else
        {
            HMODULE hMod = ::LoadLibrary(L"GDI32.DLL"); // No need to free
        
            if (hMod)
            {
                s_pfnSetBitmapAttributes = (HBITMAP (*)(HBITMAP, DWORD)) ::GetProcAddress(hMod, "SetBitmapAttributes");
                s_pfnClearBitmapAttributes = (HBITMAP (*)(HBITMAP, DWORD)) ::GetProcAddress(hMod, "ClearBitmapAttributes");

                if ((s_pfnSetBitmapAttributes != NULL) && (s_pfnClearBitmapAttributes != NULL))
                {
                    _fGlobalTheme = TRUE;
                }
            }
        }
    }
    
    *_szBaseSectionName = 0;
    *_szFullSectionName = 0;

    _iColorCount = 0;
    _iHueCount = 0;

    _uCharSet = DEFAULT_CHARSET;
    _iFontNumber = 0;
    _hinstThemeDll = NULL;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::SourceError(int iMsgResId, LPCWSTR pszParam1, LPCWSTR pszParam2)
{
    LPCWSTR pszSrcLine = _scan._szLineBuff;
    LPCWSTR pszFileName = _scan._szFileName;
    int iLineNum = _scan._iLineNum;

    if (*_szResPropValue)       // error in localizable property value
    {
        pszSrcLine = _szResPropValue;
        pszFileName = L"StringTable#";
        iLineNum = _iResPropId;
    }

    HRESULT hr = MakeParseError(iMsgResId, pszParam1, pszParam2, pszFileName, 
        pszSrcLine, iLineNum);
    
    return hr;
}
//---------------------------------------------------------------------------
PRIMVAL CThemeParser::GetPrimVal(LPCWSTR pszName)
{
    int symcnt = _Symbols.GetSize();

    for (int i=0; i < symcnt; i++)
    {
        if (AsciiStrCmpI(_Symbols[i].csName, pszName)==0)
            return _Symbols[i].ePrimVal;
    }

    return TMT_UNKNOWN;
}
//---------------------------------------------------------------------------
int CThemeParser::GetSymbolIndex(LPCWSTR pszName)
{
    int symcnt = _Symbols.GetSize();

    for (int i=0; i < symcnt; i++)
    {
        if (AsciiStrCmpI(_Symbols[i].csName, pszName)==0)
            return i;
    }

    return -1;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::AddSymbol(LPCWSTR pszName, SHORT sTypeNum, PRIMVAL ePrimVal)
{
    //---- ensure symbol doesn't already exist ----
    for (int i = 0; i < _Symbols.m_nSize; i++)
    {
        if (AsciiStrCmpI(_Symbols.m_aT[i].csName, pszName)==0)
            return SourceError(PARSER_IDS_TYPE_DEFINED_TWICE, pszName);
    }

    if (sTypeNum == -1)
        sTypeNum = (SHORT)_Symbols.GetSize();

    SYMBOL symbol;
    symbol.csName = pszName;
    symbol.sTypeNum = sTypeNum;
    symbol.ePrimVal = ePrimVal;
    
    _Symbols.Add(symbol);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::InitializeSymbols()
{
    _Symbols.RemoveAll();
    _StockBitmapCleanupList.RemoveAll();
    
    //---- get tm & comctl symbols ----
    const TMSCHEMAINFO *si = GetSchemaInfo();
    int cnt = si->iPropCount;
    const TMPROPINFO *pi = si->pPropTable;

    //---- first pass - add all symbols except ENUM definitions ----
    for (int i=0; i < cnt; i++)
    {
        if (pi[i].bPrimVal == TMT_ENUMDEF)
            continue;

        if (pi[i].bPrimVal == TMT_ENUMVAL)
            continue;

        HRESULT hr = AddSymbol(pi[i].pszName, pi[i].sEnumVal, pi[i].bPrimVal);
        if (FAILED(hr))
            return hr;
    }

    //---- second pass - add ENUM definitions ----
    int iEnumPropNum = -1;

    for (int i=0; i < cnt; i++)
    {
        if (pi[i].bPrimVal == TMT_ENUMDEF)
        {
            int iSymIndex = GetSymbolIndex(pi[i].pszName);

            if (iSymIndex == -1)       // not found - add it as a non-property enum symbol
            {
                HRESULT hr = AddSymbol(pi[i].pszName, -1, TMT_ENUM);
                if (FAILED(hr))
                    return hr;
    
                iSymIndex = GetSymbolIndex(pi[i].pszName);
            }

            if (iSymIndex > -1)
                iEnumPropNum = _Symbols[iSymIndex].sTypeNum;
            else
                iEnumPropNum = -1;

        }
        else if (pi[i].bPrimVal == TMT_ENUMVAL)
        {
            ENUMVAL enumval;
            enumval.csName = pi[i].pszName;
            enumval.iSymbolIndex = iEnumPropNum;
            enumval.iValue = pi[i].sEnumVal;

            _EnumVals.Add(enumval);
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseDocSection()
{
    _scan.ForceNextLine();        // get line after section line

    //---- just skip over all lines in this section ----
    while (1)
    {
        WCHAR szNameBuff[_MAX_PATH+1];

        if (_scan.GetChar('['))         // start of new section
            break;

        if (! _scan.GetId(szNameBuff))
            return SourceError(PARSER_IDS_EXPECTED_PROP_NAME);

        if (! _scan.GetChar('='))
            return SourceError(PARSER_IDS_EXPECTED_EQUALS_SIGN);

        int cnt = _Symbols.GetSize();

        for (int i=0; i < cnt; i++)
        {
            if (AsciiStrCmpI(_Symbols[i].csName, szNameBuff)==0)
                break;
        }

        int symtype;

        if (i == cnt)
            symtype = TMT_STRING;     // unknown string property
        else
            symtype = _Symbols[i].sTypeNum;

        HRESULT hr;

        //---- check to see if caller is querying for a doc property ----
        if ((_dwParseFlags & PTF_QUERY_DOCPROPERTY) && (lstrcmpi(_pszDocProperty, szNameBuff)==0))
            hr = ParseStringValue(symtype, _pszResult, _dwMaxResultChars);
        else
            hr = ParseStringValue(symtype);
    
        if (FAILED(hr))
            return hr;

        _scan.ForceNextLine();
    }

    //---- done with [documentation] section - turn off callback flag for properties ----
    _dwParseFlags &= (~PTF_CALLBACK_DOCPROPERTIES);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseClassSectionName(LPCWSTR pszFirstName, LPWSTR appsym)
{
    //---- validate section name ----
    //
    // optional:    appsym::
    //              _szClassName
    // optional:    .partsym

    WCHAR partsym[_MAX_PATH+1];
    WCHAR statesym[_MAX_PATH+1];

    *appsym = 0;
    *partsym = 0;

    _iPartId = -1;
    _iStateId = -1;

    //---- copy the section name for callbacks ----
    wsprintf(_szFullSectionName, L"%s%s", pszFirstName, _scan._p);
    WCHAR *p = wcschr(_szFullSectionName, ']');
    if (p)
        *p = 0;

    HRESULT hr;
    hr = hr_lstrcpy(_szClassName, pszFirstName, ARRAYSIZE(_szClassName));
    if (FAILED(hr))
        return hr;

    if (_scan.GetChar(':'))
    {
        hr = hr_lstrcpy(appsym, _szClassName, MAX_PATH);
        if (FAILED(hr))
            return hr;

        if (! _scan.GetChar(':'))
            return SourceError(PARSER_IDS_EXPECTED_DOUBLE_COLON);
        
        if (! _scan.GetId(_szClassName))
            return SourceError(PARSER_IDS_MISSING_SECT_HDR_NAME);
    }
    else 
        *appsym = 0;

    _fDefiningMetrics = (AsciiStrCmpI(_szClassName, L"SysMetrics")==0);

    if ((_fDefiningMetrics) && (*appsym))
        return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);

    if (_scan.GetChar('.'))      // an optional part id
    {
        //---- ensure a enum exists: <classname>Parts ----
        WCHAR classparts[_MAX_PATH+1];
        wsprintf(classparts, L"%sParts", _szClassName);

        int iSymIndex = GetSymbolIndex(classparts);
        if (iSymIndex == -1)        // doesn't exist
            return SourceError(PARSER_IDS_PARTS_NOT_DEFINED, _szClassName);

        //---- _scan the part name ----
        if (! _scan.GetId(partsym))
            return SourceError(PARSER_IDS_MISSING_SECT_HDR_PART);

        //---- validate that it is a value for the <classname>Parts ----
        hr = ValidateEnumSymbol(partsym, iSymIndex, &_iPartId);
        if (FAILED(hr))
            return hr;
    }

    if (_scan.GetChar('('))      // an optional state
    {
        //---- ensure a enum exists: <class or part name>States ----
        WCHAR statesname[_MAX_PATH+1];
        WCHAR *pszBaseName;

        if (_iPartId == -1)
            pszBaseName = _szClassName;
        else
            pszBaseName = partsym;

        wsprintf(statesname, L"%sStates", pszBaseName);

        int iSymIndex = GetSymbolIndex(statesname);
        if (iSymIndex == -1)
            return SourceError(PARSER_IDS_STATES_NOT_DEFINED, pszBaseName);

        if (! _scan.GetId(statesym))
            return SourceError(PARSER_IDS_MISSING_SECT_HDR_STATE);

        hr = ValidateEnumSymbol(statesym, iSymIndex, &_iStateId);
        if (FAILED(hr))
            return hr;

        if (! _scan.GetChar(')'))
            return SourceError(PARSER_IDS_EXPECTED_RPAREN);
    }

    if (_iPartId > -1)
    {
        _iPartId = _EnumVals[_iPartId].iValue;
        lstrcpy_truncate(_szBaseSectionName, partsym, ARRAYSIZE(_szBaseSectionName));
    }
    else        // not specified
    {
        lstrcpy_truncate(_szBaseSectionName, _szClassName, ARRAYSIZE(_szBaseSectionName));
        _iPartId = 0;
    }

    if (_iStateId > -1)
        _iStateId = _EnumVals[_iStateId].iValue;
    else
        _iStateId = 0;
    
    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_EXPECTED_END_OF_SECTION);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ValidateEnumSymbol(LPCWSTR pszName, int iSymType,
     int *pIndex)
{
    for (int i = 0; i < _EnumVals.m_nSize; i++)
    {
        if (AsciiStrCmpI(_EnumVals.m_aT[i].csName, pszName)==0)
        {
            if (_EnumVals.m_aT[i].iSymbolIndex == iSymType)
            {
                if (pIndex)
                    *pIndex = i;
                return S_OK;
            }
        }
    }

    return SourceError(PARSER_IDS_NOT_ENUM_VALNAME, pszName, (LPCWSTR)_Symbols[iSymType].csName);
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::AddThemeData(int iTypeNum, PRIMVAL ePrimVal, 
   const void *pData, DWORD dwLen)
{
    //Log("AddThemeData: typenum=%d, len=%d, data=0x%x", iTypeNum, dwLen, pData);

    if (! _pCallBackObj)
        return S_FALSE;

    HRESULT hr = _pCallBackObj->AddData((SHORT)iTypeNum, ePrimVal, pData, dwLen);
    if (FAILED(hr))
        return SourceError(PARSER_IDS_THEME_TOO_BIG);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseEnumValue(int iSymType)
{
    WCHAR valbuff[_MAX_PATH+1];
    HRESULT hr;
    int value;

    if (! _scan.GetId(valbuff))
        return SourceError(PARSER_IDS_ENUM_VALNAME_EXPECTED);

    int index;
    hr = ValidateEnumSymbol(valbuff, iSymType, &index);
    if (FAILED(hr))
        return hr;

    value = _EnumVals[index].iValue;

    hr = AddThemeData(iSymType, TMT_ENUM, &value, sizeof(value));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GetEnumValue(LPCWSTR pszEnumName, LPCWSTR pszEnumValName,
   int *piValue)
{
    if (! pszEnumName )
        return SourceError(PARSER_IDS_ENUM_NOT_DEFINED);
    
    //---- lookup the Enum Name ----
    int cnt = _Symbols.GetSize();

    for (int i=0; i < cnt; i++)
    {
        if (AsciiStrCmpI(_Symbols[i].csName, pszEnumName)==0)
            break;
    }

    if (i == cnt)
        return SourceError(PARSER_IDS_NOT_ENUM_VALNAME, pszEnumValName, pszEnumName);

    int iSymType = _Symbols[i].sTypeNum;

    //---- lookup the Enum value name ----
    int index;
    HRESULT hr = ValidateEnumSymbol(pszEnumValName, iSymType, &index);
    if (FAILED(hr))
        return hr;

    *piValue = _EnumVals[index].iValue;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseStringValue(int iSymType, LPWSTR pszBuff, DWORD dwMaxBuffChars)
{
    HRESULT hr;

    //---- just store the raw string ----
    _scan.SkipSpaces();

    if (_fDefiningMetrics)        
    {
        if ((iSymType < TMT_FIRSTSTRING) || (iSymType > TMT_LASTSTRING))
            return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);   
    }

    if (pszBuff)           // special call
    {
        hr = hr_lstrcpy(pszBuff, _scan._p, dwMaxBuffChars);
        if (FAILED(hr))
            return hr;
    }
    else
    {
        int len = 1 + lstrlen(_scan._p);

        hr = AddThemeData(iSymType, TMT_STRING, _scan._p, len*sizeof(WCHAR));
        if (FAILED(hr))
            return hr;
    }

    if ((iSymType >= TMT_FIRST_RCSTRING_NAME) && (iSymType <= TMT_LAST_RCSTRING_NAME))
    {
        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_DOCPROPERTIES))
        {
            int index = iSymType - TMT_FIRST_RCSTRING_NAME;

            BOOL fContinue = (*_pNameCallBack)(TCB_DOCPROPERTY, _scan._p, NULL, 
                NULL, index, _lNameParam);

            if (! fContinue)
                return MakeErrorParserLast();
        }
    }

    //---- advance _scanner to end of line ----
    _scan._p += lstrlen(_scan._p);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseIntValue(int iSymType, int *piValue)
{
    int value;
    if (! _scan.GetNumber(&value))
        return SourceError(PARSER_IDS_INT_EXPECTED);

    if (piValue)        // special call
        *piValue = value;
    else
    {
        HRESULT hr = AddThemeData(iSymType, TMT_INT, &value, sizeof(value));
        if (FAILED(hr))
            return hr;
    }

    if (iSymType == TMT_CHARSET)
    {
        if (_iFontNumber)
            return SourceError(PARSER_IDS_CHARSETFIRST);

        if (_fGlobalsDefined)
            return SourceError(PARSER_IDS_CHARSET_GLOBALS_ONLY);

        _uCharSet = (UCHAR) value;
    }

    if (iSymType == TMT_MINCOLORDEPTH)
    {
        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_MINCOLORDEPTH))
        {
            BOOL fContinue = (*_pNameCallBack)(TCB_MINCOLORDEPTH, _scan._szFileName, NULL, 
                NULL, value, _lNameParam);

            if (! fContinue)
                return MakeErrorParserLast();
        }
    }
        
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseBoolValue(int iSymType, LPCWSTR pszPropertyName)
{
    WCHAR valbuff[_MAX_PATH+1];
    BYTE bBoolVal;

    if (! _scan.GetId(valbuff))
        return SourceError(PARSER_IDS_BOOL_EXPECTED);

    if (AsciiStrCmpI(valbuff, L"true")==0)
        bBoolVal = 1;
    else if (AsciiStrCmpI(valbuff, L"false")==0)
        bBoolVal = 0;
    else
        return SourceError(PARSER_IDS_EXPECTED_TRUE_OR_FALSE);

    if (_fDefiningMetrics)        
    {
        if ((iSymType < TMT_FIRSTBOOL) || (iSymType > TMT_LASTBOOL))
            return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);     
    }

    //---- special handling for "MirrorImage" property ----
    if (iSymType == TMT_MIRRORIMAGE)
    {
        //---- handle MirrorImage callbacks (packtime) ----
        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_LOCALIZATIONS))
        {
            BOOL fContinue = (*_pNameCallBack)(TCB_MIRRORIMAGE, _szClassName, 
                _szFullSectionName, pszPropertyName, _iPartId, (LPARAM)bBoolVal);

            if (! fContinue)
                return MakeErrorParserLast();
        }

        //---- handle getting value from string table (loadtime) ----
        if (_fUsingResourceProperties)        // substitute resource value
        {
            WCHAR szValue[MAX_PATH];

            HRESULT hr = GetResourceProperty(pszPropertyName, szValue, ARRAYSIZE(szValue));
            if (SUCCEEDED(hr))
            {
                bBoolVal = (*szValue == '1');
            }
            else
            {
                hr = S_OK;      // non-fatal error
            }
        }
    }

    HRESULT hr = AddThemeData(iSymType, TMT_BOOL, &bBoolVal, sizeof(bBoolVal));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
COLORREF CThemeParser::ApplyColorSubstitution(COLORREF crOld)
{
    //---- apply SOLID color substitutions ----
    for (int i=0; i < _iColorCount; i++)
    {
        if (crOld == _crFromColors[i])
            return _crToColors[i];
    }

    //---- apply HUE color substitutions ----
    WORD wHue, wLum, wSat;
    RGBtoHLS(crOld, &wHue, &wLum, &wSat);

    for (i=0; i < _iHueCount; i++)
    {
        if (wHue == _bFromHues[i])      // hues match
        {
            COLORREF crNew = HLStoRGB(_bToHues[i], wLum, wSat);  // substitute new hue
            return crNew;
        }
    }

    return crOld;
}
//---------------------------------------------------------------------------
void CThemeParser::CleanupStockBitmaps()
{
    if (s_pfnClearBitmapAttributes)
    {
        for (int i=0; i < _StockBitmapCleanupList.m_nSize; i++)
        {
            HBITMAP hbm = (*s_pfnClearBitmapAttributes)(_StockBitmapCleanupList[i], SBA_STOCK);
            if (hbm)
            {
                DeleteObject(hbm);
            }
            else
            {
                // We are totally out of luck today aren't we
                Log(LOG_TMBITMAP, L"Failed to clear stock bitmap on cleanup");
            }
        }
    }

    _StockBitmapCleanupList.RemoveAll();
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseColorValue(int iSymType, COLORREF *pcrValue, COLORREF *pcrValue2)
{
    COLORREF color;
    HRESULT hr = S_OK;

#if 0
    if (_scan.GetId(idbuff))            // system color
    {
        hr = ParseSysColor(idbuff, &color);
        if (FAILED(hr))
            goto exit;
    }
    else
#endif

    {
        const WCHAR *parts[] = {L"r", L"g", L"b"};
        int ints[3] = {0};
        
        hr = GetIntList(ints, parts, ARRAYSIZE(ints), 0, 255);
        if (FAILED(hr))
        {
            hr = SourceError(PARSER_IDS_BAD_COLOR_VALUE);
            goto exit;
        }

        color = RGB(ints[0], ints[1], ints[2]);
    }

    if (! _fDefiningColorScheme)     
        color = ApplyColorSubstitution(color);

    if (_fDefiningMetrics)
    {
        if ((iSymType < TMT_FIRSTCOLOR) || (iSymType > TMT_LASTCOLOR))
        {
            hr = SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);     
            goto exit;
        }
    }

    if (pcrValue2)
    {
        *pcrValue2 = color;
    }

    if (pcrValue)       // special call
        *pcrValue = color;
    else
    {
        hr = AddThemeData(iSymType, TMT_COLOR, &color, sizeof(color));
        if (FAILED(hr))
            goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseMarginsValue(int iSymType)
{
    const WCHAR *parts[] = {L"lw", L"rw", L"th", L"bh"};
    int ints[4];

    HRESULT hr = GetIntList(ints, parts, ARRAYSIZE(ints), 0, 0);
    if (FAILED(hr))
        return SourceError(PARSER_IDS_BAD_MARGINS_VALUE);

    hr = AddThemeData(iSymType, TMT_MARGINS, ints, sizeof(ints));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseIntListValue(int iSymType)
{
    INTLIST IntList;
    HRESULT hr = S_OK;

    //---- unnamed parts ----
    for (int i=0; i < MAX_INTLIST_COUNT; i++)
    {
        if (! _scan.GetNumber(&IntList.iValues[i]))
        {
            if (_scan.EndOfLine())
                break;
         
            hr = SourceError(PARSER_IDS_NUMBER_EXPECTED, _scan._p);
            goto exit;
        }

        _scan.GetChar(',');      // optional comma
    }

    IntList.iValueCount = i;

    hr = AddThemeData(iSymType, TMT_INTLIST, &IntList, (1+i)*sizeof(int));
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::PackageNtlCode(LPCWSTR szFileName)
{
#if 0       // not yet supported
    HRESULT hr = S_OK;
    RESOURCE WCHAR *pszSource = NULL;
    BYTE *pPCode = NULL;
    int iPCodeLen;

    CNtlParser NtlParser;

    //---- add TMT_NTLDATA data ----
    WCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];
    _wsplitpath(szFileName, drive, dir, fname, ext);

    WCHAR szResName[_MAX_PATH+1];
    wsprintf(szResName, L"%s_NTL", fname);

    hr = AllocateTextResource(_hinstThemeDll, szResName, &pszSource);
    if (FAILED(hr))
        goto exit;

    hr = NtlParser.ParseBuffer(pszSource, szFileName, this, &pPCode, &iPCodeLen);
    if (FAILED(hr))
        goto exit;

    hr = AddThemeData(TMT_NTLDATA, TMT_NTLDATA, pPCode, iPCodeLen);
    if (FAILED(hr))
        goto exit;

exit:
    if (pszSource)
        delete [] pszSource;

    if (pPCode)
        delete [] pPCode;

    return hr;
#else
    return E_NOTIMPL;
#endif
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::PackageImageData(LPCWSTR szFileNameR, LPCWSTR szFileNameG, LPCWSTR szFileNameB, int iDibPropNum)
{
    HRESULT hr = S_OK;

    //---- add TMT_DIBDATA data ----
    WCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];

    _wsplitpath(szFileNameR, drive, dir, fname, ext);
    WCHAR szResName[_MAX_PATH+1];
    DWORD len = lstrlen(dir);
    
    if ((len) && (dir[len-1] == L'\\'))
    {
        dir[len-1] = L'_';
    }
    wsprintf(szResName, L"%s%s_BMP", dir, fname);
    HBITMAP hBitmapR = (HBITMAP) LoadImage(_hinstThemeDll, szResName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    if (!hBitmapR)
        return SourceError(PARSER_IDS_NOOPEN_IMAGE, szResName);

    //---- convert to DIBDATA ----
    CBitmapPixels pixels;
    DWORD *pPixelQuads;
    int iWidth, iHeight, iBytesPerPixel, iBytesPerRow, iPreviousBytesPerPixel;

    BOOL fUseDrawStream = TRUE;

#if 0        // keep this in sync with #if in imagefile.cpp
    //---- force old code drawing ----
    fUseDrawStream = FALSE;
#endif

    // Allocate a TMBITMAPHEADER in addition to the bitmap
    hr = pixels.OpenBitmap(NULL, hBitmapR, TRUE, &pPixelQuads, &iWidth, &iHeight, &iBytesPerPixel, 
        &iBytesPerRow, &iPreviousBytesPerPixel, TMBITMAPSIZE);
    if (FAILED(hr))
    {
        DeleteObject(hBitmapR);
        return hr;
    }

    BOOL fWasAlpha = (iPreviousBytesPerPixel == 4);

#if 0
    //---- apply loaded color scheme, if any ----
    if ((szFileNameG && szFileNameG[0]) && (szFileNameB && szFileNameB[0]))
    {
        _wsplitpath(szFileNameG, drive, dir, fname, ext);
        len = lstrlen(dir);
    
        if ((len) && (dir[len-1] == L'\\'))
        {
            dir[len-1] = L'_';
        }
        wsprintf(szResName, L"%s%s_BMP", dir, fname);
        HBITMAP hBitmapG = (HBITMAP) LoadImage(_hinstThemeDll, szResName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        _wsplitpath(szFileNameB, drive, dir, fname, ext);
        len = lstrlen(dir);
    
        if ((len) && (dir[len-1] == L'\\'))
        {
            dir[len-1] = L'_';
        }
        wsprintf(szResName, L"%s%s_BMP", dir, fname);
        HBITMAP hBitmapB = (HBITMAP) LoadImage(_hinstThemeDll, szResName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        DWORD dwRWeight = GetRValue(_crBlend);
        DWORD dwGWeight = GetGValue(_crBlend);
        DWORD dwBWeight = GetBValue(_crBlend);

        DWORD *pPixelQuadsG = NULL;
        DWORD *pPixelQuadsB = NULL;
        if (hBitmapG && hBitmapB)
        {
            HDC hdc = GetDC(NULL);
            if (hdc)
            {
                int dwLen = iWidth * iHeight;

                pPixelQuadsG = new DWORD[dwLen];
                if (pPixelQuadsG)
                {
                    pPixelQuadsB = new DWORD[dwLen];
                    if (pPixelQuadsB)
                    {
                        BITMAPINFO bi = {0};
                        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                        bi.bmiHeader.biWidth = iWidth;
                        bi.bmiHeader.biHeight = iHeight;
                        bi.bmiHeader.biPlanes = 1;
                        bi.bmiHeader.biBitCount = 32;
                        bi.bmiHeader.biCompression = BI_RGB;

                        if (GetDIBits(hdc, hBitmapG, 0, iHeight, pPixelQuadsG, &bi, DIB_RGB_COLORS) &&
                            GetDIBits(hdc, hBitmapB, 0, iHeight, pPixelQuadsB, &bi, DIB_RGB_COLORS))
                        {
                            DWORD* pdwR = pPixelQuads;
                            DWORD* pdwG = pPixelQuadsG;
                            DWORD* pdwB = pPixelQuadsB;
                            for (int i = 0; i < dwLen; i++)
                            {
                                if ((*pdwR & 0xffffff) != RGB(255,0,255))
                                {
                                    *pdwR = (*pdwR & 0xff000000) |
                                            RGB(min(((GetRValue(*pdwR) * dwRWeight) + (GetRValue(*pdwG) * dwGWeight) + (GetRValue(*pdwB) * dwBWeight)) >> 8, 0xff),
                                                min(((GetGValue(*pdwR) * dwRWeight) + (GetGValue(*pdwG) * dwGWeight) + (GetGValue(*pdwB) * dwBWeight)) >> 8, 0xff),
                                                min(((GetBValue(*pdwR) * dwRWeight) + (GetBValue(*pdwG) * dwGWeight) + (GetBValue(*pdwB) * dwBWeight)) >> 8, 0xff));
                                }
                                pdwR++;
                                pdwG++;
                                pdwB++;
                            }
                        }

                        delete[] pPixelQuadsB;
                    }
                    delete[] pPixelQuadsG;
                }
                ReleaseDC(NULL, hdc);
            }
        }
        else
        {
            OutputDebugString(L"Failed to load bitmaps");
        }

        if (hBitmapG)
        {
            DeleteObject(hBitmapG);
            hBitmapG = NULL;
        }

        if (hBitmapB)
        {
            DeleteObject(hBitmapB);
            hBitmapB = NULL;
        }
    }
#endif

    BITMAPINFOHEADER *pBitmapHdr = pixels._hdrBitmap;


    //---- if alpha present, pre-multiply RGB values (as per AlphaBlend()) API ----
    BOOL fTrueAlpha = FALSE;

    // We keep per-pixel alpha bitmaps as 32 bits DIBs, not compatible bitmaps 
    if (fWasAlpha) 
    {
        fTrueAlpha = (PreMultiplyAlpha(pPixelQuads, pBitmapHdr->biWidth, pBitmapHdr->biHeight) != 0);
#ifdef DEBUG            
        if (!fTrueAlpha)
            Log(LOG_TMBITMAP, L"%s is 32 bits, but not true alpha", szFileNameR);
#endif
    }
    
    HBITMAP hbmStock = NULL;
    BOOL fFlipped = FALSE;

    if (fUseDrawStream && _fGlobalTheme)
    {
        HDC hdc = ::GetWindowDC(NULL);

        if (hdc)
        {
            typedef struct {
                BITMAPINFOHEADER    bmih;
                ULONG               masks[3];
            } BITMAPHEADER;
            
            BITMAPHEADER bmi;

            bmi.bmih.biSize = sizeof(bmi.bmih);
            bmi.bmih.biWidth = pBitmapHdr->biWidth;
            bmi.bmih.biHeight = pBitmapHdr->biHeight;
            bmi.bmih.biPlanes = 1;
            bmi.bmih.biBitCount = 32;
            bmi.bmih.biCompression = BI_BITFIELDS;
            bmi.bmih.biSizeImage = 0;
            bmi.bmih.biXPelsPerMeter = 0;
            bmi.bmih.biYPelsPerMeter = 0;
            bmi.bmih.biClrUsed = 3;
            bmi.bmih.biClrImportant = 0;
            bmi.masks[0] = 0xff0000;    // red
            bmi.masks[1] = 0x00ff00;    // green
            bmi.masks[2] = 0x0000ff;    // blue

            hbmStock = CreateDIBitmap(hdc, &bmi.bmih, CBM_INIT |  CBM_CREATEDIB , pPixelQuads, (BITMAPINFO*)&bmi.bmih, DIB_RGB_COLORS);

            // Need to Force 32-bit DIBs in Multi-mon mode
            // Make it match the screen resolution setting if it is not an AlphaBlended image

#if 0
            if (hbmStock && !fTrueAlpha && !GetSystemMetrics(SM_REMOTESESSION))
            {
                BOOL fForce16 = FALSE; //(iPreviousBytesPerPixel <= 2);

                HDC hdcTemp = CreateCompatibleDC(hdc);
                if (hdcTemp)
                {
                    HBITMAP hbmTemp = CreateCompatibleBitmap(hdc, 2, 2);
                    if (hbmTemp)
                    {
                        BITMAPINFOHEADER bi = {0};
                        bi.biSize = sizeof(bi);

                        GetDIBits(hdcTemp, hbmTemp, 0, 1, NULL, (LPBITMAPINFO) &bi, DIB_RGB_COLORS);

                        /*WCHAR szTemp[256];
                        wsprintf(szTemp, L"We're in %d-bit mode.\n", bi.biBitCount);
                        OutputDebugString(szTemp);*/

                        bmi.bmih.biSize = sizeof(bmi.bmih);
                        bmi.bmih.biWidth = pBitmapHdr->biWidth;
                        bmi.bmih.biHeight = pBitmapHdr->biHeight;
                        bmi.bmih.biPlanes = 1;
                        bmi.bmih.biBitCount = 32;
                        bmi.bmih.biCompression = BI_BITFIELDS;
                        bmi.bmih.biSizeImage = 0;
                        bmi.bmih.biXPelsPerMeter = 0;
                        bmi.bmih.biYPelsPerMeter = 0;
                        bmi.bmih.biClrUsed = 3;
                        bmi.bmih.biClrImportant = 0;

                        if ((bi.biBitCount == 16) || (fForce16))
                        {
                            COLORREF crActual = 0;
                            
                            if (!fForce16)
                            {
                                HBITMAP hbmOld = (HBITMAP)SelectObject(hdcTemp, hbmTemp);
                                SetPixel(hdcTemp, 0, 0, RGB(0, 255, 0));
                                crActual = GetPixel(hdcTemp, 0, 0);
                                SelectObject(hdcTemp, hbmOld);
                            }
                            
                            bmi.bmih.biBitCount = 16;
                            if (fForce16 || (GetGValue(crActual) == 252))// Do a lame check for 5-6-5
                            {
                                bmi.masks[0] = 0xF800;
                                bmi.masks[1] = 0x07E0;
                                bmi.masks[2] = 0x001F;
                            }
                            else
                            {
                                bmi.masks[0] = 0x7C00; // 5-5-5 mode
                                bmi.masks[1] = 0x03E0;
                                bmi.masks[2] = 0x001F;
                            }
                        }
                        else if (bi.biBitCount == 24)
                        {
                            bmi.bmih.biBitCount = 24;
                            bmi.masks[0] = 0xff0000;    // red
                            bmi.masks[1] = 0x00ff00;    // green
                            bmi.masks[2] = 0x0000ff;    // blue
                        }

                        if (bmi.bmih.biBitCount != 32)
                        {
                            HBITMAP hbmNewStock = CreateDIBitmap(hdc, &bmi.bmih, CBM_INIT |  CBM_CREATEDIB , pPixelQuads, (BITMAPINFO*)&bmi.bmih, DIB_RGB_COLORS);
                            if (hbmNewStock)
                            {
                                HDC hdcNewStock = CreateCompatibleDC(hdc);
                                if (hdcNewStock)
                                {
                                    HBITMAP hbmOld = (HBITMAP)SelectObject(hdcNewStock, hbmNewStock);
                                    HBITMAP hbmOld2 = (HBITMAP)SelectObject(hdcTemp, hbmStock);

                                    BitBlt(hdcNewStock, 0, 0, pBitmapHdr->biWidth, pBitmapHdr->biHeight, hdcTemp, 0, 0, SRCCOPY);

                                    SelectObject(hdcTemp, hbmOld2);
                                    SelectObject(hdcNewStock, hbmOld);

                                    DeleteObject(hbmStock);
                                    hbmStock = hbmNewStock;
                                }
                                else
                                {
                                    DeleteObject(hbmNewStock);
                                }
                            }
                        }

                        DeleteObject(hbmTemp);
                    }
                    DeleteDC(hdcTemp);
                }
            }
#endif

            ::ReleaseDC(NULL, hdc);
        }

        if (!hbmStock)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            ASSERT(s_pfnSetBitmapAttributes != NULL);
            ASSERT(s_pfnClearBitmapAttributes != NULL);

            HBITMAP hbmOld = hbmStock;
            hbmStock = (*s_pfnSetBitmapAttributes)(hbmStock, SBA_STOCK); 

            if (hbmStock == NULL)
            {
                DeleteObject(hbmOld);
                Log(LOG_ALWAYS, L"UxTheme: SetBitmapAttributes failed in CParser::PackageImageData");

                hr = E_FAIL;
            } 
            else
            {
                _StockBitmapCleanupList.Add(hbmStock);
#ifdef DEBUG
                BITMAP bm;
                ::GetObject(hbmStock, sizeof bm, &bm);
                g_dwStockSize += bm.bmWidthBytes * bm.bmHeight;
                //Log(LOG_TMBITMAP, L"Created %d bytes of stock bitmaps, last is %8X", g_dwStockSize, hbmStock);
#endif
            }
        }
    } 

    ::DeleteObject(hBitmapR);

    // Fill in the TMBITMAPHEADER structure
    if (SUCCEEDED(hr))
    {
        TMBITMAPHEADER *psbh = (TMBITMAPHEADER*) pixels.Buffer();

        psbh->dwSize = TMBITMAPSIZE;
        psbh->fFlipped = fFlipped;
        psbh->hBitmap = hbmStock;
        psbh->fTrueAlpha = fTrueAlpha;
        psbh->dwColorDepth = iBytesPerPixel * 8;
        psbh->iBrushesOffset = 0;
        psbh->nBrushes = 0;

        if (hbmStock == NULL) // Pass DIB bits
        {
            int size = psbh->dwSize + sizeof(BITMAPINFOHEADER) + iHeight * iBytesPerRow;
            hr = AddThemeData(iDibPropNum, TMT_DIBDATA, psbh, size);
        } 
        else // Pass the TMBITMAPHEADER structure only
        {
            hr = AddThemeData(iDibPropNum, TMT_DIBDATA, psbh, psbh->dwSize);
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseFileNameValue(int iSymType, LPWSTR pszBuff, DWORD dwMaxBuffChars)
{
    WCHAR szFileNameR[_MAX_PATH+1] = {0};
    WCHAR szFileNameG[_MAX_PATH+1] = {0};
    WCHAR szFileNameB[_MAX_PATH+1] = {0};
    HRESULT hr = S_OK;

    if (! _scan.GetFileName(szFileNameR, ARRAYSIZE(szFileNameR)))
    {
        hr = SourceError(PARSER_IDS_ENUM_VALNAME_EXPECTED);
        goto exit;
    }

    if (_scan.GetFileName(szFileNameG, ARRAYSIZE(szFileNameG)))
    {
        _scan.GetFileName(szFileNameB, ARRAYSIZE(szFileNameB));
    }

    if (pszBuff)        // special call
    {
        hr = hr_lstrcpy(pszBuff, szFileNameR, dwMaxBuffChars);
        if (FAILED(hr))
            goto exit;
    }
    else if (_pCallBackObj)         // emit data
    {
        //---- add TMT_FILENAME data ----
        hr = AddThemeData(iSymType, TMT_FILENAME, &szFileNameR, sizeof(WCHAR)*(1+lstrlen(szFileNameR)));
        if (FAILED(hr))
            goto exit;
        if ((szFileNameG[0] != 0) && (szFileNameB[0] != 0))
        {
            hr = AddThemeData(iSymType, TMT_FILENAME, &szFileNameG, sizeof(WCHAR)*(1+lstrlen(szFileNameR)));
            if (FAILED(hr))
                goto exit;
            hr = AddThemeData(iSymType, TMT_FILENAME, &szFileNameB, sizeof(WCHAR)*(1+lstrlen(szFileNameR)));
            if (FAILED(hr))
                goto exit;
        }

        if (iSymType == TMT_IMAGEFILE)
        {
            hr = PackageImageData(szFileNameR, szFileNameG, szFileNameB, TMT_DIBDATA);
        }
        else if (iSymType == TMT_GLYPHIMAGEFILE)
        {
            hr = PackageImageData(szFileNameR, szFileNameG, szFileNameB, TMT_GLYPHDIBDATA);
        }
        else if (iSymType == TMT_STOCKIMAGEFILE)
        {
            hr = PackageImageData(szFileNameR, szFileNameG, szFileNameB, TMT_STOCKDIBDATA);
        }
        else if ((iSymType >= TMT_IMAGEFILE1) && (iSymType <= TMT_IMAGEFILE5))
        {
            hr = PackageImageData(szFileNameR, szFileNameG, szFileNameB, TMT_DIBDATA1 + (iSymType-TMT_IMAGEFILE1));
        }
#if 0           // not yet implemented
        else if (iSymType == TMT_NTLFILE)
        {
            hr = PackageNtlCode(szFileNameR);
        }
#endif

        if (FAILED(hr))
            goto exit;
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_FILENAMES))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_FILENAME, szFileNameR, NULL, NULL, iSymType, _lNameParam);
        if (! fContinue)
        {
            hr = MakeErrorParserLast();
            goto exit;
        }

        if (szFileNameG[0] && szFileNameB[0])
        {
            fContinue = (*_pNameCallBack)(TCB_FILENAME, szFileNameG, NULL, NULL, iSymType, _lNameParam);
            if (! fContinue)
            {
                hr = MakeErrorParserLast();
                goto exit;
            }
            fContinue = (*_pNameCallBack)(TCB_FILENAME, szFileNameB, NULL, NULL, iSymType, _lNameParam);
            if (! fContinue)
            {
                hr = MakeErrorParserLast();
                goto exit;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSizeValue(int iSymType)
{
    int val;
    if (! _scan.GetNumber(&val))   
        return SourceError(PARSER_IDS_INT_EXPECTED);

    int pixels;

    HRESULT hr = ParseSizeInfoUnits(val, L"pixels", &pixels);
    if (FAILED(hr))
        return hr;

    if (_fDefiningMetrics)        
    {
        if ((iSymType < TMT_FIRSTSIZE) || (iSymType > TMT_LASTSIZE))
            return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);  
    }

    hr = AddThemeData(iSymType, TMT_SIZE, &pixels, sizeof(pixels));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParsePositionValue(int iSymType)
{
    const WCHAR *parts[] = {L"x", L"y"};
    int ints[2];

    HRESULT hr = GetIntList(ints, parts, ARRAYSIZE(ints), 0, 0);
    if (FAILED(hr))
        return SourceError(PARSER_IDS_ILLEGAL_SIZE_VALUE);

    hr = AddThemeData(iSymType, TMT_POSITION, ints, sizeof(ints));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseRectValue(int iSymType, LPCWSTR pszPropertyName)
{
    const WCHAR *parts[] = {L"l", L"t", L"r", L"b"};
    int ints[4];

    HRESULT hr = GetIntList(ints, parts, ARRAYSIZE(ints), 0, 0);
    if (FAILED(hr))
        return SourceError(PARSER_IDS_ILLEGAL_RECT_VALUE);

    //---- special handling for localizable RECT properties ----
    if (iSymType == TMT_DEFAULTPANESIZE)
    {
        //---- handle localizable callback (packtime) ----
        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_LOCALIZATIONS))
        {
            BOOL fContinue = (*_pNameCallBack)(TCB_LOCALIZABLE_RECT, _szClassName, 
                _szFullSectionName, pszPropertyName, _iPartId, (LPARAM)(RECT *)ints);

            if (! fContinue)
                return MakeErrorParserLast();
        }

        //---- handle getting value from string table (loadtime) ----
        if (_fUsingResourceProperties)        // substitute resource value
        {
            WCHAR szValue[MAX_PATH];

            HRESULT hr = GetResourceProperty(pszPropertyName, szValue, ARRAYSIZE(szValue));
            if (SUCCEEDED(hr))
            {
                RECT rc;

                int cnt = swscanf(szValue, L"%d, %d, %d, %d", 
                    &rc.left, &rc.top, &rc.right, &rc.bottom);

                if (cnt == 4)
                {
                    //---- override with localized values ----
                    memcpy(ints, &rc, sizeof(int)*4);
                }

            }
            else
            {
                hr = S_OK;      // non-fatal error
            }
        }
    }

    hr = AddThemeData(iSymType, TMT_RECT, ints, sizeof(ints));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSizeInfoUnits(int iVal, LPCWSTR pszDefaultUnits, int *piPixels)
{
    WCHAR units[_MAX_PATH+1];
    HRESULT hr;

    //---- NOTE: this uses the THEME_DPI (96) for all size conversions! ----
    //---- this gives us consistent LOGFONT, etc. across diff. resolution screens ----
    //---- with the promise that we will do just-in-time DPI scaling, when appropriate ----

    if (! _scan.GetId(units))
    {
        hr = hr_lstrcpy(units, pszDefaultUnits, ARRAYSIZE(units));
        if (FAILED(hr))
            return hr;
    }

    if (AsciiStrCmpI(units, L"pixels")==0)
        ;       // already correct
    else if (AsciiStrCmpI(units, L"twips")==0)
    {
        iVal = -MulDiv(iVal, THEME_DPI, 20*72);  
    }
    else if (AsciiStrCmpI(units, L"points")==0)
    {
        iVal = -MulDiv(iVal, THEME_DPI, 72);  
    }
    else
        return SourceError(PARSER_IDS_UNKNOWN_SIZE_UNITS, units);

    *piPixels = iVal;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSysColor(LPCWSTR szId, COLORREF *pcrValue)
{
    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    //---- look up value of id ----
    int index = GetSymbolIndex(szId);
    if (index == -1)
        return SourceError(PARSER_IDS_UNKNOWN_SYS_COLOR);

    int iPropNum = _Symbols[index].sTypeNum;

    if ((iPropNum < TMT_FIRSTCOLOR) || (iPropNum > TMT_LASTCOLOR))
        return SourceError(PARSER_IDS_UNKNOWN_SYS_COLOR);

    *pcrValue = GetSysColor(iPropNum-TMT_FIRSTCOLOR);
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSysFont(LOGFONT *pFont)
{
    if (! _scan.GetChar('['))
        return SourceError(PARSER_IDS_LBRACKET_EXPECTED);

    WCHAR idbuff[_MAX_PATH+1];

    if (! _scan.GetId(idbuff))
        return SourceError(PARSER_IDS_EXPECTED_SYSFONT_ID);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    //---- look up value of id ----
    int index = GetSymbolIndex(idbuff);
    if (index == -1)
        return SourceError(PARSER_IDS_UNKNOWN_SYSFONT_ID);

    if ((index < TMT_FIRSTFONT) || (index > TMT_LASTFONT))
        return SourceError(PARSER_IDS_EXPECTED_SYSFONT_ID);

    //---- get value of specified font ----
    NONCLIENTMETRICS metrics;
    memset(&metrics, 0, sizeof(metrics));
    metrics.cbSize = sizeof(metrics);

    BOOL gotem = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(metrics), 
        &metrics, 0);
    if (! gotem)
        return MakeErrorLast();

    switch (index)
    {
        case TMT_CAPTIONFONT:
            *pFont = metrics.lfCaptionFont;
            break;

        case TMT_SMALLCAPTIONFONT:
            *pFont = metrics.lfSmCaptionFont;
            break;

        case TMT_MENUFONT:
            *pFont = metrics.lfMenuFont;
            break;
        
        case TMT_STATUSFONT:
            *pFont = metrics.lfStatusFont;
            break;
        
        case TMT_MSGBOXFONT:
            *pFont = metrics.lfMessageFont;
            break;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseFontValue(int iSymType, LPCWSTR pszPropertyName)
{
    LOGFONT font;
    WCHAR szLineBuff[_MAX_PATH+1];
    HRESULT hr;

    _scan.SkipSpaces();     // trim leading blanks

    memset(&font, 0, sizeof(font));
    font.lfWeight = FW_NORMAL;
    font.lfCharSet = _uCharSet;

#if 0           // turned off until we finalize design
    if (_scan.GetKeyword(L"SysFont"))
    {
        hr = ParseSysFont(&font);
        if (FAILED(hr))
            return hr;

        goto addit;
    }
#endif

    _iFontNumber++;
    BOOL fGotFont = FALSE;

    if (_fUsingResourceProperties)        // substitute resource font string
    {
        hr = GetResourceProperty(pszPropertyName, szLineBuff, ARRAYSIZE(szLineBuff));
        if (SUCCEEDED(hr))
        {
            fGotFont = TRUE;
        }
        else
        {
            hr = S_OK;
        }
    }

    if (! fGotFont)
    {
        //---- copy font specs from scanner ----
        hr = hr_lstrcpy(szLineBuff, _scan._p, ARRAYSIZE(szLineBuff));
        if (FAILED(hr))
            return hr;
    }

    //---- handle font callback ----
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_LOCALIZATIONS))
    {
        WCHAR *p = szLineBuff;
        while (IsSpace(*p))
                p++;

        BOOL fContinue = (*_pNameCallBack)(TCB_FONT, p, _szFullSectionName, 
            pszPropertyName, 0, _lNameParam);
        if (! fContinue)
            return MakeErrorParserLast();
    }

    //---- family name is required and must be first ----
    WCHAR *p;
    p = wcschr(szLineBuff, ',');
    if (! p)            // whole line is family name
    {
        hr = hr_lstrcpy(font.lfFaceName, szLineBuff, ARRAYSIZE(font.lfFaceName));   
        return hr;
    }

    *p++ = 0;
    hr = hr_lstrcpy(font.lfFaceName, szLineBuff, ARRAYSIZE(font.lfFaceName));
    if (FAILED(hr))
        return hr;

    _scan._p = p;

    int val;
    if (_scan.GetNumber(&val))       // font size
    {
        int pixels;

        hr = ParseSizeInfoUnits(val, L"points", &pixels);
        if (FAILED(hr))
            return hr;

        font.lfHeight = pixels;

        _scan.GetChar(',');      // optional comma
    }

    WCHAR flagname[_MAX_PATH+1];

    while (_scan.GetId(flagname))
    {
        if (AsciiStrCmpI(flagname, L"bold")==0)
            font.lfWeight = FW_BOLD;
        else if (AsciiStrCmpI(flagname, L"italic")==0)
            font.lfItalic = TRUE;
        else if (AsciiStrCmpI(flagname, L"underline")==0)
            font.lfUnderline = TRUE;
        else if (AsciiStrCmpI(flagname, L"strikeout")==0)
            font.lfStrikeOut = TRUE;
        else
            return SourceError(PARSER_IDS_UNKNOWN_FONT_FLAG, flagname);
    }

// addit:

    if (_fDefiningMetrics)        
    {
        if ((iSymType < TMT_FIRSTFONT) || (iSymType > TMT_LASTFONT))
            return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);     
    }

    hr = AddThemeData(iSymType, TMT_FONT, &font, sizeof(font));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseClassLine(int *piSymType, int *piValue, LPWSTR pszBuff, DWORD dwMaxBuffChars)
{
    WCHAR szNameBuff[_MAX_PATH+1];
    WCHAR szSymbol[MAX_INPUT_LINE+1];

    if (! _scan.GetId(szNameBuff))
        return SourceError(PARSER_IDS_EXPECTED_PROP_NAME);

    if (! _scan.GetChar('='))
        return SourceError(PARSER_IDS_EXPECTED_EQUALS_SIGN);

    int cnt = _Symbols.GetSize();

    for (int i=0; i < cnt; i++)
    {
        if (AsciiStrCmpI(_Symbols[i].csName, szNameBuff)==0)
            break;
    }

    if (i == cnt)
        return SourceError(PARSER_IDS_UNKNOWN_PROP, szNameBuff);

    int symtype = _Symbols[i].sTypeNum;
    
    HRESULT hr;

    // Handle substituted symbols
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTSYMBOLS))
    {
        if (wcschr(_scan._p, INI_MACRO_SYMBOL)) 
        {
            // Pass ##
            if (_scan.GetChar(INI_MACRO_SYMBOL) &&
                _scan.GetChar(INI_MACRO_SYMBOL))
            {
                WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];

                _wsplitpath(_scan._szFileName, szDrive, szDir, szBaseName, szExt);

                BOOL fContinue = (*_pNameCallBack)(TCB_NEEDSUBST, szBaseName, _scan._p, szSymbol, 
                    0, _lNameParam);
                if (! fContinue)
                    return MakeErrorParserLast();

                _scan.UseSymbol(szSymbol);
            }
        }
    }

    switch (_Symbols[i].ePrimVal)
    {
        case TMT_ENUM:
            hr = ParseEnumValue(symtype);
            break;
            
        case TMT_STRING:
            hr = ParseStringValue(symtype, pszBuff, dwMaxBuffChars);
            break;

        case TMT_INT:
            hr = ParseIntValue(symtype, piValue);
            break;

        case TMT_INTLIST:
            hr = ParseIntListValue(symtype);
            break;

        case TMT_BOOL:
            hr = ParseBoolValue(symtype, szNameBuff);
            break;

        case TMT_COLOR:
            {
                COLORREF cr;
                hr = ParseColorValue(symtype, (COLORREF *)piValue, &cr);
                if (SUCCEEDED(hr))
                {
                    if (lstrcmpi(_Symbols[i].csName, L"BLENDCOLOR") == 0)
                    {
                        _crBlend = cr;
                    }
                }
            }
            break;

        case TMT_MARGINS:
            hr = ParseMarginsValue(symtype);
            break;

        case TMT_FILENAME:
            hr = ParseFileNameValue(symtype, pszBuff, dwMaxBuffChars);
            break;

        case TMT_SIZE:
            hr = ParseSizeValue(symtype);
            break;

        case TMT_POSITION:
            hr = ParsePositionValue(symtype);
            break;

        case TMT_RECT:
            hr = ParseRectValue(symtype, szNameBuff);
            break;

        case TMT_FONT:
            hr = ParseFontValue(symtype, szNameBuff);
            break;

        default:
            hr = E_FAIL;
            break;
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTSYMBOLS))
    {
        _scan.UseSymbol(NULL);
    }

    *_szResPropValue = 0;       // not yet set

    if (FAILED(hr))
        return hr;

    if (piSymType)              // special call
        *piSymType = symtype;

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_EXTRA_PROP_TEXT, _scan._p);

    _scan.ForceNextLine();
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseColorSchemeSection()
{
    HRESULT hr;
    WCHAR SchemeName[_MAX_PATH+1];
    WCHAR DisplayName[_MAX_PATH+1];
    WCHAR ToolTip[MAX_INPUT_LINE+1];    
    WCHAR szBuff[MAX_INPUT_LINE+1];

    if (! _scan.GetChar('.'))
        return SourceError(PARSER_IDS_EXPECTED_DOT_SN);

    if (! _scan.GetId(SchemeName, ARRAYSIZE(SchemeName)))
        return SourceError(PARSER_IDS_CS_NAME_EXPECTED);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    _scan.ForceNextLine();        // get line after section line
    *ToolTip = 0;
    *DisplayName = 0;

    bool fCorrectScheme = (lstrcmpi(_ColorParam, SchemeName)==0);

    if (fCorrectScheme)     // initialize all subst. tables
    {
        hr = hr_lstrcpy(DisplayName, SchemeName, ARRAYSIZE(DisplayName));        // in case not specified
        if (FAILED(hr))
            return hr;


        for (int i=0; i < HUE_SUBCNT; i++)
        {
            _bFromHues[i] = 0;
            _bToHues[i] = 0;
        }

        for (i=0; i < COLOR_SUBCNT; i++)
        {
            _crFromColors[i] = 0;
            _crToColors[i] = 0;
        }
    }

    //----- put into vars to make coding/debugging easier ----
    int firstFromHue = TMT_FROMHUE1;
    int lastFromHue = TMT_FROMHUE1 + HUE_SUBCNT - 1;
    int firstToHue = TMT_TOHUE1;
    int lastToHue = TMT_TOHUE1 + HUE_SUBCNT - 1;

    int firstFromColor = TMT_FROMCOLOR1;
    int lastFromColor = TMT_FROMCOLOR1 + COLOR_SUBCNT - 1;
    int firstToColor = TMT_TOCOLOR1;
    int lastToColor = TMT_TOCOLOR1 + COLOR_SUBCNT - 1;

    while (1)       // parse each line
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
            break;

        int iSymType, iValue;

        _fDefiningColorScheme = TRUE;

        //---- parse the COLOR or INT property line ----
        hr = ParseClassLine(&iSymType, &iValue, szBuff, ARRAYSIZE(szBuff));

        _fDefiningColorScheme = FALSE;

        if (FAILED(hr))
            return hr;

        //---- store the HUE or COLOR param in local tables ----
        if ((iSymType >= firstFromHue) && (iSymType <= lastFromHue))
        {
            if (fCorrectScheme)
                _bFromHues[iSymType-firstFromHue] = (BYTE)iValue;
        }
        else if ((iSymType >= firstToHue) && (iSymType <= lastToHue))
        {
            if (fCorrectScheme)
                _bToHues[iSymType-firstToHue] = (BYTE)iValue;
        }
        else if ((iSymType >= firstFromColor) && (iSymType <= lastFromColor))
        {
            if (fCorrectScheme)
                _crFromColors[iSymType-firstFromColor] = (COLORREF)iValue;
        }
        else if ((iSymType >= firstToColor) && (iSymType <= lastToColor))
        {
            if (fCorrectScheme)
                _crToColors[iSymType-firstToColor] = (COLORREF)iValue;
        }
        else if (iSymType == TMT_DISPLAYNAME)
        {
            hr = hr_lstrcpy(DisplayName, szBuff, ARRAYSIZE(DisplayName));
            if (FAILED(hr))
                return hr;
        }
        else if (iSymType == TMT_TOOLTIP)
        {
            hr = hr_lstrcpy(ToolTip, szBuff, ARRAYSIZE(ToolTip));
            if (FAILED(hr))
                return hr;
        }
        else
        {
            return SourceError(PARSER_IDS_ILLEGAL_CS_PROPERTY);
        }
    }

    if (fCorrectScheme)     // adjust counts
    {
        _iHueCount = HUE_SUBCNT;
        while (_iHueCount > 0)
        {
            if (_bFromHues[_iHueCount-1] == _bToHues[_iHueCount-1])
                _iHueCount--;
            else
                break;
        }

        _iColorCount = COLOR_SUBCNT;
        while (_iColorCount > 0)
        {
            if (_crFromColors[_iColorCount-1] == _crToColors[_iColorCount-1])
                _iColorCount--;
            else
                break;
        }
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_COLORSECTION))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_COLORSCHEME, SchemeName, 
            DisplayName, ToolTip, 0, _lNameParam);
        if (! fContinue)
            return MakeErrorParserLast();
    }

    // Create an empty subst table
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, SchemeName, 
            NULL, NULL, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    }
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSizeSection()
{
    HRESULT hr;
    WCHAR szSizeName[_MAX_PATH+1];
    WCHAR szDisplayName[_MAX_PATH+1];
    WCHAR szToolTip[MAX_INPUT_LINE+1];    
    WCHAR szBuff[MAX_INPUT_LINE+1];

    if (! _scan.GetChar('.'))
        return SourceError(PARSER_IDS_EXPECTED_DOT_SN);

    if (! _scan.GetId(szSizeName, ARRAYSIZE(szSizeName)))
        return SourceError(PARSER_IDS_SS_NAME_EXPECTED);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    _scan.ForceNextLine();        // get line after section line

    while (1)       // parse each line of section
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
            break;

        int iSymType, iValue;

        //---- parse the property line ----
        hr = ParseClassLine(&iSymType, &iValue, szBuff, ARRAYSIZE(szBuff));
        if (FAILED(hr))
            return hr;

        if (iSymType == TMT_DISPLAYNAME)
        {
            hr = hr_lstrcpy(szDisplayName, szBuff, ARRAYSIZE(szDisplayName));
            if (FAILED(hr))
                return hr;
        }
        else if (iSymType == TMT_TOOLTIP)
        {
            hr = hr_lstrcpy(szToolTip, szBuff, ARRAYSIZE(szToolTip));
            if (FAILED(hr))
                return hr;
        }
        else
        {
            return SourceError(PARSER_IDS_ILLEGAL_SS_PROPERTY);
        }
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SIZESECTION))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_SIZENAME, szSizeName, 
            szDisplayName, szToolTip, 0, _lNameParam);
        if (! fContinue)
            return MakeErrorParserLast();
    }

    // Create an empty subst table
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSizeName, 
            NULL, NULL, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    }
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseFileSection()
{
    HRESULT hr;
    WCHAR szSizeName[_MAX_PATH+1];
    WCHAR szFileName[_MAX_PATH+1];
    WCHAR szColorSchemes[_MAX_PATH+1];
    WCHAR szSizes[MAX_INPUT_LINE+1];    
    WCHAR szBuff[MAX_INPUT_LINE+1];

    if (! _scan.GetChar('.'))
        return SourceError(PARSER_IDS_EXPECTED_DOT_SN);

    if (! _scan.GetId(szSizeName, ARRAYSIZE(szSizeName)))
        return SourceError(PARSER_IDS_FS_NAME_EXPECTED);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    _scan.ForceNextLine();        // get line after section line

    while (1)       // parse each line of section
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
            break;

        int iSymType, iValue;

        //---- parse the property line ----
        hr = ParseClassLine(&iSymType, &iValue, szBuff, ARRAYSIZE(szBuff));
        if (FAILED(hr))
            return hr;

        if (iSymType == TMT_FILENAME)
        {
            hr = hr_lstrcpy(szFileName, szBuff, ARRAYSIZE(szFileName));
        }
        else if (iSymType == TMT_COLORSCHEMES)
        {
            hr = hr_lstrcpy(szColorSchemes, szBuff, ARRAYSIZE(szColorSchemes));
        }
        else if (iSymType == TMT_SIZES)
        {
            hr = hr_lstrcpy(szSizes, szBuff, ARRAYSIZE(szSizes));
        }
        else
        {
            return SourceError(PARSER_IDS_ILLEGAL_SS_PROPERTY);
        }

        if (FAILED(hr))
            return hr;
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_FILESECTION))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_CDFILENAME, szSizeName, 
            szFileName, NULL, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    
        fContinue = (*_pNameCallBack)(TCB_CDFILECOMBO, szSizeName, 
            szColorSchemes, szSizes, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    }
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSizeName, 
            SUBST_TABLE_INCLUDE, szColorSchemes, 0, _lNameParam);
        if (! fContinue)
            return MakeErrorParserLast();

        fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSizeName, 
            SUBST_TABLE_INCLUDE, szSizes, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSubstSection()
{
    WCHAR szSubstTableName[_MAX_PATH+1];
    WCHAR szId[MAX_INPUT_LINE+1];    
    WCHAR szValue[MAX_INPUT_LINE+1];    
    BOOL  fFirst = TRUE;

    if (! _scan.GetChar('.'))
        return SourceError(PARSER_IDS_EXPECTED_DOT_SN);

    if (! _scan.GetId(szSubstTableName, ARRAYSIZE(szSubstTableName)))
        return SourceError(PARSER_IDS_FS_NAME_EXPECTED);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    _scan.ForceNextLine();        // get line after section line

    while (1)       // parse each line of section
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
        {
            // Call the callback once for creating the empty table
            if (fFirst && (_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
            {
                BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSubstTableName, 
                    NULL, NULL, 0, _lNameParam);

                if (! fContinue)
                    return MakeErrorParserLast();
            }
            break;
        }

        //---- parse the property line ----
        if (!_scan.GetIdPair(szId, szValue, ARRAYSIZE(szId)))
            return SourceError(PARSER_IDS_BAD_SUBST_SYMBOL);

        fFirst = FALSE;

        _scan.ForceNextLine();

        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
        {
            BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSubstTableName, 
                szId, szValue, 0, _lNameParam);

            if (! fContinue)
                return MakeErrorParserLast();
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GenerateEmptySection(LPCWSTR pszSectionName, int iPartId, int iStateId)
{
    int iStartIndex = 0;

    if (_pCallBackObj)
        iStartIndex = _pCallBackObj->GetNextDataIndex();

    int index = 0;      // will be updated later
    HRESULT hr = AddThemeData(TMT_JUMPTOPARENT, TMT_JUMPTOPARENT, &index, sizeof(index));
    if (FAILED(hr))
        return hr;

    if (_pCallBackObj)
    {
        int iLen = _pCallBackObj->GetNextDataIndex() - iStartIndex;

        hr = _pCallBackObj->AddIndex(L"", pszSectionName, iPartId, iStateId,
            iStartIndex, iLen);
        if (FAILED(hr))
            return hr;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseClassSection(LPCWSTR pszFirstName)
{
    HRESULT hr;
    int iStartIndex = 0;

    BOOL fGlobals = (AsciiStrCmpI(pszFirstName, GLOBALS_SECTION_NAME)==0);
    BOOL fMetrics = (AsciiStrCmpI(pszFirstName, SYSMETRICS_SECTION_NAME)==0);

    if (fGlobals)
    {
        if (_fClassSectionDefined)
            return SourceError(PARSER_IDS_GLOBALS_MUST_BE_FIRST);
    }
    else            // regular class section
    {
        if (_dwParseFlags & PTF_CLASSDATA_PARSE)
        {
            if (! _fGlobalsDefined)     // insert an empty [fGlobals] section
            {
                hr = GenerateEmptySection(GLOBALS_SECTION_NAME, 0, 0);
                if (FAILED(hr))
                    return hr;

                _fGlobalsDefined = true;
            }

            if ((! fMetrics) && (! _fMetricsDefined))   // insert an empty [sysmetrics] section
            {
                hr = GenerateEmptySection(SYSMETRICS_SECTION_NAME, 0, 0);
                if (FAILED(hr))
                    return hr;

                _fMetricsDefined = true;
            }
            else if ((fMetrics) && (_fClassSectionDefined))
                return SourceError(PARSER_IDS_METRICS_MUST_COME_BEFORE_CLASSES);
        }

        _fClassSectionDefined = TRUE;
    }

    WCHAR appsym[_MAX_PATH+1];

    if (_pCallBackObj)
        iStartIndex = _pCallBackObj->GetNextDataIndex();

    hr = ParseClassSectionName(pszFirstName, appsym);
    if (FAILED(hr))
        return hr;

    _scan.ForceNextLine();        // get line after section line

    while (1)       // parse each line
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
            break;

        hr = ParseClassLine();
        if (FAILED(hr))
            return hr;
    }

    //---- end this section of theme data ----
    int index = 0;      // will be updated later

    hr = AddThemeData(TMT_JUMPTOPARENT, TMT_JUMPTOPARENT, &index, sizeof(index));
    if (FAILED(hr))
        return hr;

    if (_pCallBackObj)
    {
        int iLen = _pCallBackObj->GetNextDataIndex() - iStartIndex;

        hr = _pCallBackObj->AddIndex(appsym, _szClassName, _iPartId, 
            _iStateId, iStartIndex, iLen);
        if (FAILED(hr))
            return hr;
    }

    if (fGlobals)
        _fGlobalsDefined = true;
    else if (fMetrics)
        _fMetricsDefined = true;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseThemeFile(LPCTSTR pszFileName, LPCWSTR pszColorParam, 
     IParserCallBack *pCallBack, THEMEENUMPROC pNameCallBack, LPARAM lNameParam, DWORD dwParseFlags)
{
    _pszDocProperty = NULL;

    HRESULT hr = InitializeSymbols();
    if (FAILED(hr))
        goto exit;

    hr = _scan.AttachFile(pszFileName);        // "pszBuffer" contains the filename
    if (FAILED(hr))
        goto exit;

    if (pszColorParam)
    {
        hr = hr_lstrcpy(_ColorParam, pszColorParam, ARRAYSIZE(_ColorParam));
        if (FAILED(hr))
            return hr;
    }
    else
        *_ColorParam = 0;

    _hinstThemeDll = NULL;

    hr = ParseThemeScanner(pCallBack, pNameCallBack, lNameParam, dwParseFlags);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseThemeBuffer(LPCWSTR pszBuffer, LPCWSTR pszFileName, 
     LPCWSTR pszColorParam, HINSTANCE hinstThemeDll,
     IParserCallBack *pCallBack, THEMEENUMPROC pNameCallBack, 
     LPARAM lNameParam, DWORD dwParseFlags, LPCWSTR pszDocProperty, OUT LPWSTR pszResult,
     DWORD dwMaxResultChars)
{
    _pszDocProperty = pszDocProperty;
    _pszResult = pszResult;

    //---- initialize in case not found ----
    if (_pszResult)
        *_pszResult = 0;

    _dwMaxResultChars = dwMaxResultChars;

    HRESULT hr = InitializeSymbols();
    if (FAILED(hr))
        goto exit;

    _hinstThemeDll = hinstThemeDll;

    _scan.AttachMultiLineBuffer(pszBuffer, pszFileName);

    if (pszColorParam)
    {
        hr = hr_lstrcpy(_ColorParam, pszColorParam, ARRAYSIZE(_ColorParam));
        if (FAILED(hr))
            return hr;
    }
    else
        *_ColorParam = 0;

    hr = ParseThemeScanner(pCallBack, pNameCallBack, lNameParam, dwParseFlags);

    //---- make error if doc property not found ----
    if ((SUCCEEDED(hr)) && (_dwParseFlags & PTF_QUERY_DOCPROPERTY) && (! *_pszResult))
    {
        hr = MakeError32(ERROR_NOT_FOUND);
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::LoadResourceProperties()
{
    WCHAR szFullString[2*MAX_PATH];
    WCHAR szBaseIniName[_MAX_PATH];  
    HRESULT hr = S_OK;

    //---- extract base .ini name ----
    WCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], ext[_MAX_EXT];
    _wsplitpath(_scan._szFileName, drive, dir, szBaseIniName, ext);

    //---- remove optional "_INI" part ----
    LPWSTR pszExt = wcsstr(szBaseIniName, L"_INI");
    if (pszExt)
        *pszExt = 0;

    //---- read all localizable property name/value pairs into memory ----
    for (int i=RES_BASENUM_PROPVALUEPAIRS; ; i++)
    {
        if (! LoadString(_hinstThemeDll, i, szFullString, ARRAYSIZE(szFullString)))
        {
            //---- no more properties avail ----
            break;
        }

        lstrcpy(_szResPropValue, szFullString);     // for proper error reporting
        _iResPropId = i;

        //---- does this property belong to current file? ----
        LPWSTR pszAtSign = wcschr(szFullString, '@');
        if (! pszAtSign)
        {
            hr = SourceError(PARSER_IDS_BAD_RES_PROPERTY);
            break;
        }

        //---- zero terminate ini name ----
        *pszAtSign = 0;

        if (lstrcmpi(szBaseIniName, szFullString) != 0)
            continue;

        //---- strip off the .ini name for faster comparing ----
        LPCWSTR pszName = pszAtSign+1;

        LPWSTR pszValue = wcschr(pszName, '=');
        if (pszValue)
        {
            pszValue++;     // skip over equals sign
        }
        else
        {
            hr = SourceError(PARSER_IDS_BAD_RES_PROPERTY);
            break;
        }

        //---- add the value ----
        CWideString cwValue(pszValue);
        _PropertyValues.Add(cwValue);

        //---- zero-terminate the name ----
        *pszValue = 0;

        //---- add the name ----
        CWideString cwName(pszName);
        _PropertyNames.Add(cwName);

        //---- add the id ----
        _iPropertyIds.Add(i);
    }

    return hr;
}
//---------------------------------------------------------------------------
void CThemeParser::EmptyResourceProperties()
{
    _PropertyNames.RemoveAll();
    _PropertyValues.RemoveAll();
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GetResourceProperty(LPCWSTR pszPropName, LPWSTR pszValueBuff,
    int cchMaxValueChars)
{
    WCHAR szPropTarget[2*MAX_PATH];
    HRESULT hr = S_OK;
    BOOL fFound = FALSE;

    wsprintf(szPropTarget, L"[%s]%s=", _szFullSectionName, pszPropName);

    for (int i=0; i < _PropertyNames.m_nSize; i++)
    {
        if (AsciiStrCmpI(szPropTarget, _PropertyNames[i])==0)
        {
            fFound = TRUE;

            hr = hr_lstrcpy(pszValueBuff, _PropertyValues[i], cchMaxValueChars);
            if (SUCCEEDED(hr))
            {
                hr = hr_lstrcpy(_szResPropValue, _PropertyValues[i], ARRAYSIZE(_szResPropValue));
                _iResPropId = _iPropertyIds[i];
            }
            break;
        }
    }

    if (! fFound)
        hr = E_FAIL;

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseThemeScanner(IParserCallBack *pCallBack, 
     THEMEENUMPROC pNameCallBack, LPARAM lNameParam, DWORD dwParseFlags)
{
    HRESULT hr;

    _pCallBackObj = pCallBack;

    _pNameCallBack = pNameCallBack;
    _lNameParam = lNameParam;
    _dwParseFlags = dwParseFlags;
    _fClassSectionDefined = FALSE;

    //---- setup for properties in the .res file ----
    EmptyResourceProperties();

    _fUsingResourceProperties = (pCallBack != NULL);

    if (_fUsingResourceProperties)
    {
        hr = LoadResourceProperties();
        if (FAILED(hr))
            goto exit;

        //---- set the error context for normal .ini parsing ----
        *_szResPropValue = 0;       // not yet set
    }

    //---- scan the first, non-comment WCHAR ----
    if (! _scan.GetChar('['))
    {
        if (! _scan.EndOfFile())
        {
            hr = SourceError(PARSER_IDS_LBRACKET_EXPECTED);
            goto exit;
        }
    }

    while (! _scan.EndOfFile())           // process each section
    {

        WCHAR section[_MAX_PATH+1];
        _scan.GetId(section);

        if (AsciiStrCmpI(section, L"documentation")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseDocSection();

            if (_dwParseFlags & PTF_QUERY_DOCPROPERTY)
                break;          // quicker to leave in middle of file

        }
        else if (AsciiStrCmpI(section, L"ColorScheme")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseColorSchemeSection();
        }
        else if (AsciiStrCmpI(section, L"Size")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseSizeSection();
        }
        else if (AsciiStrCmpI(section, L"File")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseFileSection();
        }
        else if (AsciiStrCmpI(section, L"Subst")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseSubstSection();
        }
        else        // "globals", "sysmetrics", or class section
        {
            if (_dwParseFlags & PTF_CONTAINER_PARSE)
                return SourceError(PARSER_IDS_BADSECT_THEMES_INI);

            hr = ParseClassSection(section);
        }

        if (FAILED(hr))
            goto exit;
    }

    //---- check for empty theme ----
    if (_dwParseFlags & PTF_CLASSDATA_PARSE)
    {
        if (! _fGlobalsDefined)     // insert an empty [fGlobals] section
        {
            hr = GenerateEmptySection(GLOBALS_SECTION_NAME, 0, 0);
            if (FAILED(hr))
                return hr;

            _fGlobalsDefined = true;
        }

        if (! _fMetricsDefined)   // insert an empty [sysmetrics] section
        {
            hr = GenerateEmptySection(SYSMETRICS_SECTION_NAME, 0, 0);
            if (FAILED(hr))
                return hr;
        }
    }

    hr = S_OK;

exit:
    _outfile.Close();

    _pCallBackObj = NULL;
    _pNameCallBack = NULL;
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GetIntList(int *pInts, LPCWSTR *pParts, int iCount, 
    int iMin, int iMax)
{
    bool bSet[255];     // assume 255 max ints


    //---- ensure we set each one once ----
    for (int i=0; i < iCount; i++)
        bSet[i] = false;

    if (wcschr(_scan._p, ':')) 
    {
        //---- named parts ----
        for (int i=0; i < iCount; i++)
        {
            WCHAR idbuff[_MAX_PATH+1];

            if (! _scan.GetId(idbuff))
                return SourceError(PARSER_IDS_VALUE_NAME_EXPECTED, _scan._p);
        
            for (int j=0; j < iCount; j++)
            {
                if (AsciiStrCmpI(pParts[j], idbuff)==0)
                    break;
            }

            if (j == iCount)        // unknown part name
                return SourceError(PARSER_IDS_UNKNOWN_VALUE_NAME, idbuff);

            if (bSet[j])            // name set twice
                return SourceError(PARSER_IDS_VALUE_PART_SPECIFIED_TWICE, idbuff);

            if (! _scan.GetChar(':'))
                return SourceError(PARSER_IDS_COLOR_EXPECTED, _scan._p);

            if (! _scan.GetNumber(&pInts[j]))
                return SourceError(PARSER_IDS_NUMBER_EXPECTED, _scan._p);

            bSet[j] = true;

            _scan.GetChar(',');      // optional comma
        }
    }
    else
    {
        //---- unnamed parts ----
        for (int i=0; i < iCount; i++)
        {
            if (! _scan.GetNumber(&pInts[i]))
                return SourceError(PARSER_IDS_NUMBER_EXPECTED, _scan._p);

            _scan.GetChar(',');      // optional comma
        }
    }

    //---- range check ----
    if (iMin != iMax)
    {
        for (i=0; i < iCount; i++)
        {
            if ((pInts[i] < iMin) || (pInts[i] > iMax))
                return SourceError(PARSER_IDS_NUMBER_OUT_OF_RANGE);
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GetPropertyNum(LPCWSTR pszName, int *piPropNum)
{
    //---- for perf, avoid loading all symbols each time this func is called ----
    //---- by using "GetSchemaInfo()" ----
  
    //---- get tm & comctl symbols ----
    const TMSCHEMAINFO *si = GetSchemaInfo();
    int cnt = si->iPropCount;
    const TMPROPINFO *pi = si->pPropTable;

    for (int i=0; i < cnt; i++)
    {
        if (pi[i].sEnumVal < TMT_FIRST_RCSTRING_NAME)
            continue;

        if (pi[i].sEnumVal > TMT_LAST_RCSTRING_NAME)
            break;

        if (AsciiStrCmpI(pszName, pi[i].pszName)==0)
        {
            *piPropNum = pi[i].sEnumVal - TMT_FIRST_RCSTRING_NAME;         // zero based
            return S_OK;
        }
    }

    return MakeError32(ERROR_NOT_FOUND);
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::BitmapColorReplacement(DWORD *pPixelBuff, UINT iWidth, UINT iHeight)
{
    if ((! _iHueCount) && (! _iColorCount))
        return S_OK;

    DWORD *pPixel = pPixelBuff;

    for (UINT r=0; r < iHeight; r++)         // for each row
    {
        for (UINT c=0; c < iWidth; c++, pPixel++)      // for each pixel in row
        {
            //---- try to apply a COLOR substitution ----
            if (_iColorCount)
            {
                COLORREF crPixel = REVERSE3(*pPixel);

                for (int h=0; h < _iColorCount; h++)
                {
                    if (_crFromColors[h] == crPixel)
                    {
                        //---- preserve alpha value when doing COLOR replacement ----
                        *pPixel = ((ALPHACHANNEL(*pPixel)) << 24) | REVERSE3(_crToColors[h]);
                        break;          // only one replacement per pixel
                    }
                }

                if (h < _iColorCount)       // don't try hues if we got COLOR match
                    continue;
            }

            if (_iHueCount)
            {
                WORD wPixelHue, wPixelLum, wPixelSat;
                RGBtoHLS(REVERSE3(*pPixel), &wPixelHue, &wPixelLum, &wPixelSat);

                //---- try to apply a HUE substitution ----
                for (int h=0; h < _iHueCount; h++)
                {
                    if (_bFromHues[h] == wPixelHue)
                    {
                        //---- preserve alpha value when doing HUE replacement ----
                        *pPixel = ((ALPHACHANNEL(*pPixel)) << 24) | REVERSE3(HLStoRGB(_bToHues[h], wPixelLum, wPixelSat)); 
                        break;          // only one replacement per pixel
                    };
                }

            }

        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GetStateNum(LPCWSTR pszStateName, BYTE *piNum)
{
    WCHAR statesname[_MAX_PATH+1];
    HRESULT hr = S_OK;

    if (! *_szBaseSectionName)
    {
        Log(LOG_ERROR, L"szBaseSectionName not set by caller of NtlRun");
        hr = SourceError(PARSER_IDS_INTERNAL_TM_ERROR);
        goto exit;
    }

    wsprintf(statesname, L"%sStates", _szBaseSectionName);

    int iSymIndex;
    iSymIndex = GetSymbolIndex(statesname);
    if (iSymIndex == -1)
    {
        hr = SourceError(PARSER_IDS_UNKNOWN_STATE, statesname);
        goto exit;
    }

    int iStateIndex;
    hr = ValidateEnumSymbol(statesname, iSymIndex, &iStateIndex);
    if (FAILED(hr))
        goto exit;

    *piNum = (BYTE)_EnumVals[iStateIndex].iValue;

exit:
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\signing.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Signing.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  A class to handle signing on themes.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

#include <stdafx.h>
#include "..\inc\signing.h"
#include <shlobj.h>

#define TBOOL(x)    (BOOL)(x)

//  --------------------------------------------------------------------------
//  CThemeSignature miscellaneous data and type declarations
//
//  Purpose:    These are private to the implementation of this class.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

static  const int   VSSIGN_TAG  =   0x84692426;         //  Magic number so we can validate that it is our signature

#define SIZE_PE_HEADER              0x130       // This is the size of the .msstyles file header that contains the checksum, rebase address and other info we want to allow to change.

typedef struct
{
    char                    cSignature[128];
} SIGNATURE;

typedef struct
{
    DWORD                   dwTag;          //  This should be VSSIGN_TAG
    DWORD                   dwSigSize;      //  Normally 128 bytes, the size of just the sign
    ULARGE_INTEGER          ulFileSize;      //  This is the total file size, including signature and SIGNATURE_BLOB_TAIL
} SIGNATURE_BLOB_TAIL;

typedef struct
{
    SIGNATURE               signature;
    SIGNATURE_BLOB_TAIL     blob;
} SIGNATURE_ON_DISK;

#define HRESULT_FROM_CRYPTO(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_SSPI << 16) | 0x80000000)))


//  --------------------------------------------------------------------------
//  CThemeSignature::static class constants
//
//  Purpose:    Holds all the constant static information that is shared by
//              both the signer and the verifier. This is private information
//              known only to this class.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

const WCHAR     CThemeSignature::s_szDescription[]      =   L"Microsoft Visual Style Signature";
const WCHAR     CThemeSignature::s_szThemeDirectory[]   =   L"Themes";


const BYTE s_keyPublic1[]     =   //  Public Key: #1
{
    0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00,
    0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x73, 0xAA, 0xFD, 0xFE, 0x2E, 0x34,
    0x75, 0x3B, 0xC2, 0x20, 0x72, 0xFC, 0x50, 0xCC, 0xD4, 0xE0, 0xDE, 0xC7, 0xA6,
    0x46, 0xC6, 0xDC, 0xE6, 0x6B, 0xF0, 0x58, 0x11, 0x88, 0x66, 0x54, 0x5F, 0x3D,
    0x81, 0x8C, 0xEF, 0x5F, 0x89, 0x51, 0xE4, 0x9C, 0x3F, 0x57, 0xA6, 0x22, 0xA9,
    0xE7, 0x0F, 0x4B, 0x56, 0x81, 0xD1, 0xA6, 0xBA, 0x24, 0xFF, 0x93, 0x17, 0xFE,
    0x64, 0xEF, 0xE5, 0x11, 0x90, 0x00, 0xDC, 0x37, 0xC2, 0x84, 0xEE, 0x7B, 0x12,
    0x43, 0xA4, 0xAF, 0xC3, 0x69, 0x57, 0xD1, 0x92, 0x96, 0x8E, 0x55, 0x0F, 0xE1,
    0xCD, 0x0F, 0xAE, 0xEA, 0xE8, 0x01, 0x83, 0x65, 0x32, 0xF1, 0x80, 0xDB, 0x08,
    0xD6, 0x01, 0x84, 0xB1, 0x09, 0x80, 0x3C, 0x27, 0x83, 0x9F, 0x16, 0x92, 0x86,
    0x4C, 0x8E, 0x15, 0xC7, 0x94, 0xE4, 0x27, 0xFF, 0x2B, 0xA4, 0x28, 0xDE, 0x9C,
    0x43, 0x5B, 0x5E, 0x14, 0xB6
};

#define SIZE_PUBLIC_KEY         148         // sizeof(s_keyPublic1)



HRESULT FixCryptoError(DWORD dwError)
{
    HRESULT hr = dwError;

    // Sometimes the return value from GetLastError() after Crypto APIs returns HRESULTS and sometimes not.
    if (0 == HRESULT_SEVERITY(dwError))
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


#define IS_DIGITW(x)   (((x) >= L'0') && ((x) <= L'9'))

BOOL StrToInt64ExInternalW(LPCWSTR pszString, DWORD dwFlags, LONGLONG *pllRet)
{
    BOOL bRet;

    if (pszString)
    {
        LONGLONG n;
        BOOL bNeg = FALSE;
        LPCWSTR psz;
        LPCWSTR pszAdj;

        // Skip leading whitespace
        //
        for (psz = pszString; *psz == L' ' || *psz == L'\n' || *psz == L'\t'; psz++)
            NULL;

        // Determine possible explicit signage
        //
        if (*psz == L'+' || *psz == L'-')
        {
            bNeg = (*psz == L'+') ? FALSE : TRUE;
            psz++;
        }

        // Or is this hexadecimal?
        //
        pszAdj = psz+1;
        if ((STIF_SUPPORT_HEX & dwFlags) &&
            *psz == L'0' && (*pszAdj == L'x' || *pszAdj == L'X'))
        {
            // Yes

            // (Never allow negative sign with hexadecimal numbers)
            bNeg = FALSE;
            psz = pszAdj+1;

            pszAdj = psz;

            // Do the conversion
            //
            for (n = 0; ; psz++)
            {
                if (IS_DIGITW(*psz))
                    n = 0x10 * n + *psz - L'0';
                else
                {
                    WCHAR ch = *psz;
                    int n2;

                    if (ch >= L'a')
                        ch -= L'a' - L'A';

                    n2 = ch - L'A' + 0xA;
                    if (n2 >= 0xA && n2 <= 0xF)
                        n = 0x10 * n + n2;
                    else
                        break;
                }
            }

            // Return TRUE if there was at least one digit
            bRet = (psz != pszAdj);
        }
        else
        {
            // No
            pszAdj = psz;

            // Do the conversion
            for (n = 0; IS_DIGITW(*psz); psz++)
                n = 10 * n + *psz - L'0';

            // Return TRUE if there was at least one digit
            bRet = (psz != pszAdj);
        }

        if (pllRet)
        {
            *pllRet = bNeg ? -n : n;
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}


//  --------------------------------------------------------------------------
//  CThemeSignature::CThemeSignature
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeSignature. Allocates required resources
//              to perform crypt functions. If these are expensive they can
//              be moved to a common initializing function to make the
//              constructor more lightweight. The destructor can still release
//              only the allocated resources.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------
CThemeSignature::CThemeSignature(OPTIONAL const BYTE * pvPrivateKey, OPTIONAL DWORD cbPrivateKeySize) :
    _hCryptProvider(NULL),
    _hCryptHash(NULL),
    _hCryptKey(NULL),
    _pvSignature(NULL),
    _dwSignatureSize(0)
{
    _Init(pvPrivateKey, cbPrivateKeySize);
}


//  --------------------------------------------------------------------------
//  CThemeSignature::CThemeSignature
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeSignature. Allocates required resources
//              to perform crypt functions. If these are expensive they can
//              be moved to a common initializing function to make the
//              constructor more lightweight. The destructor can still release
//              only the allocated resources.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------
CThemeSignature::CThemeSignature() :
    _hCryptProvider(NULL),
    _hCryptHash(NULL),
    _hCryptKey(NULL),
    _pvSignature(NULL),
    _dwSignatureSize(0)
{
    _Init(NULL, 0);
}


void CThemeSignature::_Init(OPTIONAL const BYTE * pvPrivateKey, OPTIONAL DWORD cbPrivateKeySize)
{
    _pvPrivateKey = pvPrivateKey;           // Okay if NULL
    _cbPrivateKeySize = cbPrivateKeySize;

    // TODO: Use PROV_RSA_SIG
    if (CryptAcquireContext(&_hCryptProvider,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_SILENT | CRYPT_VERIFYCONTEXT) != FALSE)
    {
        TBOOL(CryptCreateHash(_hCryptProvider,
                              CALG_SHA,
                              0,
                              0,
                              &_hCryptHash));
    }
}

//  --------------------------------------------------------------------------
//  CThemeSignature::~CThemeSignature
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeSignature. Release any allocated
//              resources used in the processing of this class.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

CThemeSignature::~CThemeSignature (void)

{
    if (_pvSignature != NULL)
    {
        LocalFree(_pvSignature);
        _pvSignature = NULL;
    }
    if (_hCryptKey != NULL)
    {
        TBOOL(CryptDestroyKey(_hCryptKey));
        _hCryptKey = NULL;
    }
    if (_hCryptHash != NULL)
    {
        TBOOL(CryptDestroyHash(_hCryptHash));
        _hCryptHash = NULL;

    }
    if (_hCryptProvider != NULL)
    {
        TBOOL(CryptReleaseContext(_hCryptProvider, 0));
        _hCryptProvider = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CThemeSignature::Verify
//
//  Arguments:  pszFilename     =   File path to verify.
//              fNoSFCCheck     =   Bypass SFC check?
//
//  Returns:    HRESULT
//
//  Purpose:    Verifies the signature on the given file path. Allows the
//              caller to bypass the SFC check.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::Verify(const WCHAR *pszFilename, bool fNoSFCCheck)
{
    HRESULT hr = S_OK;

    //  Do we need to check with SFC?
    if (fNoSFCCheck || !IsProtected(pszFilename))
    {
        //  Did the constructor complete successfully?
        hr = (HasProviderAndHash() ? S_OK : E_FAIL);
        if (SUCCEEDED(hr))
        {
            //  Create a public key.
            hr = CreateKey(KEY_PUBLIC);
            if (SUCCEEDED(hr))
            {
                HANDLE  hFile;

                //  Open the file READ-ONLY.
                hFile = CreateFileW(pszFilename,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    0,
                                    OPEN_EXISTING,
                                    0,
                                    0);
                if (INVALID_HANDLE_VALUE != hFile)
                {
                    //  Calculate the hash on the file.
                    hr = CalculateHash(hFile, KEY_PUBLIC);
                    if (SUCCEEDED(hr))
                    {
                        SIGNATURE   signature;

                        //  Read the signature of the file.
                        hr = ReadSignature(hFile, &signature);
                        if (SUCCEEDED(hr))
                        {
                            //  Check the signature.
                            if (CryptVerifySignature(_hCryptHash,
                                                     reinterpret_cast<BYTE*>(&signature),
                                                     sizeof(signature),
                                                     _hCryptKey,
                                                     s_szDescription,
                                                     0) != FALSE)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                hr = FixCryptoError(GetLastError());
                            }
                        }
                    }
                    TBOOL(CloseHandle(hFile));
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::Sign
//
//  Arguments:  pszFilename     =   File path to sign.
//
//  Returns:    HRESULT
//
//  Purpose:    Signs the given file with a digital signature. Used by the
//              theme packer application.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::Sign(const WCHAR *pszFilename)
{
    HRESULT hr = E_FAIL;

    //  Did the constructor complete successfully?
    if (HasProviderAndHash())
    {
        hr = CreateKey(KEY_PRIVATE);
        if (SUCCEEDED(hr))
        {
            HANDLE  hFile;

            //  Open the file READ-ONLY. We will open it READ-WRITE when needed.
            hFile = CreateFileW(pszFilename,
                                GENERIC_READ,
                                0,
                                0,
                                OPEN_EXISTING,
                                0,
                                0);
            if (INVALID_HANDLE_VALUE != hFile)
            {
                //  Calculate the hash on the file.
                hr = CalculateHash(hFile, KEY_PRIVATE);
                TBOOL(CloseHandle(hFile));      // We need to close this now because other calls down below will want to open it.
                hFile = NULL;

                if (SUCCEEDED(hr))
                {
                    //  Sign the hash.
                    hr = SignHash();
                    if (SUCCEEDED(hr))
                    {
                        //  Write the signature.
                        hr = WriteSignature(pszFilename,
                                            _pvSignature,
                                            _dwSignatureSize);
                        if (S_OK == hr)
                        {
                            CThemeSignature themeSignature(_pvPrivateKey, _cbPrivateKeySize);

                            //  Verify the signature with a new instance of the verifier.
                            hr = themeSignature.Verify(pszFilename, true);
                        }
                    }
                }
            }
            else
            {
                DWORD   dwErrorCode;

                dwErrorCode = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErrorCode);
            }
        }
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::Generate
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Generates the public key and prints it out. I assume (but
//              don't know that this is a helper function that isn't used
//              much at all.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::Generate(void)
{
    HRESULT hr;

    // 0x04000000 is a 1024-bit key.
    if (CryptGenKey(_hCryptProvider,
                    AT_SIGNATURE,
                    (RSA1024BIT_KEY | CRYPT_CREATE_SALT | CRYPT_EXPORTABLE),
                    &_hCryptKey) != FALSE)
    {
        void    *pvKeyPublic;
        DWORD   dwKeyPublicSize;

        hr = CreateExportKey(PUBLICKEYBLOB, pvKeyPublic, dwKeyPublicSize);
        if (SUCCEEDED(hr))
        {
            void    *pvKeyPrivate;
            DWORD   dwKeyPrivateSize;

            hr = CreateExportKey(PRIVATEKEYBLOB, pvKeyPrivate, dwKeyPrivateSize);
            if (SUCCEEDED(hr))
            {
                wprintf(L"Public Key:\n");
                PrintKey(pvKeyPublic, dwKeyPublicSize);
                wprintf(L"\n\nPrivate Key:\n");
                PrintKey(pvKeyPrivate, dwKeyPrivateSize);
                LocalFree(pvKeyPrivate);
            }
            LocalFree(pvKeyPublic);
        }
    }
    else
    {
        hr = FixCryptoError(GetLastError());
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::IsProtected
//
//  Arguments:  pszFilename     =   File path to check protection on.
//
//  Returns:    bool
//
//  Purpose:    Determines whether this file is a known theme. This used to
//              check for SFC but because this code is called before SFC has
//              started up this doesn't work.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-10  vtan        consolidated into a class
//              2000-09-10  vtan        removed SFC (bryanst delta)
//  --------------------------------------------------------------------------
bool CThemeSignature::IsProtected(const WCHAR *pszFilename)  const
{
    return false;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::HasProviderAndHash
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the constructor completed successfully.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------
bool CThemeSignature::HasProviderAndHash(void)   const
{
    return((_hCryptProvider != NULL) && (_hCryptHash != NULL));
}







const BYTE * CThemeSignature::_GetPublicKey(void)
{
    const BYTE * pKeyToReturn = NULL;

    pKeyToReturn = s_keyPublic1;

    return pKeyToReturn;
}


//  --------------------------------------------------------------------------
//  CThemeSignature::CreateKey
//
//  Arguments:  keyType     =   Key type to create.
//
//  Returns:    HRESULT
//
//  Purpose:    Creates the specified key type.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::CreateKey(KEY_TYPES keyType)
{
    HRESULT hr = S_OK;

    switch (keyType)
    {
        DWORD dwDataLength;
        const BYTE  *pData;

        case KEY_PUBLIC:
            pData = _GetPublicKey();
            dwDataLength = SIZE_PUBLIC_KEY;
            goto importKey;
        case KEY_PRIVATE:
            if (!_pvPrivateKey || (0 == _cbPrivateKeySize))
            {
                return E_INVALIDARG;
            }

            pData = _pvPrivateKey;
            dwDataLength = _cbPrivateKeySize;

importKey:
            if (pData)
            {
                if (!CryptImportKey(_hCryptProvider,
                                   pData,
                                   dwDataLength,
                                   0,
                                   0,
                                   &_hCryptKey))
                {
                    hr = FixCryptoError(GetLastError());
                }
            }
            else
            {
                hr = E_FAIL;
            }
            break;
        default:
            ASSERTMSG(false, "Unknown key type passed to CThemeSignature::CreateKey");
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::CalculateHash
//
//  Arguments:  hFile       =   File to hash.
//              keyType     =   Type of hash to generate.
//
//  Returns:    HRESULT
//
//  Purpose:    Hashes the file contents. How much is hashed depends on
//              whether the public or private key is used. The public key
//              means that this is a verification so the signature and blob
//              are NOT hashed. Otherwise a private key means that this is a
//              signing and the whole file must be hashed (because the
//              signature and blob are not present).
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::CalculateHash(HANDLE hFile, KEY_TYPES keyType)
{
    HRESULT hr = S_OK;
    HANDLE hSection;

    //  Create a section object for this file.
    hSection = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 0,
                                 NULL);
    if (hSection != NULL)
    {
        void * pV;

        //  Map the section into the address space.
        pV = MapViewOfFile(hSection,
                           FILE_MAP_READ,
                           0,
                           0,
                           0);
        if (pV != NULL)
        {
            ULARGE_INTEGER ulFileSize;

            //  Get the file's size
            ulFileSize.LowPart = GetFileSize(hFile, &ulFileSize.HighPart);
            if (ulFileSize.LowPart == INVALID_FILE_SIZE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            } 
            else
            {
                switch (keyType)
                {
                    case KEY_PUBLIC:
                        //  PUBLIC: do NOT has the signature and blob.
                        ulFileSize.QuadPart -= sizeof(SIGNATURE_ON_DISK);
                        break;
                    case KEY_PRIVATE:
                        //  PRIVATE: hash everything.
                        break;
                    default:
                        ASSERTMSG(false, "Unknown key type passed to CThemeSignature::CreateKey");
                        break;
                }

                // Skip the PE Header
                ulFileSize.QuadPart -= SIZE_PE_HEADER;
                pV = (void *) (((BYTE *) pV) + SIZE_PE_HEADER);

                //  Add the data to the hash object. Protect the access to the
                //  mapped view with __try and __except. If an exception is
                //  thrown it's caught here where it's mapped to ERROR_OUTOFMEMORY.

                __try
                {
                    if (!CryptHashData(_hCryptHash,
                                      reinterpret_cast<BYTE*>(pV),
                                      ulFileSize.LowPart, 0))
                    {
                        hr = FixCryptoError(GetLastError());
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            TBOOL(UnmapViewOfFile(pV));
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        TBOOL(CloseHandle(hSection));
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeSignature::SignHash
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Signs the hash and generates a signature. The signature is
//              allocated and released in the destructor.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::SignHash(void)
{
    HRESULT hr = S_OK;

    if (CryptSignHash(_hCryptHash,
                      AT_SIGNATURE,
                      s_szDescription,
                      0,
                      NULL,
                      &_dwSignatureSize))
    {
        _pvSignature = LocalAlloc(LMEM_FIXED, _dwSignatureSize);
        if (_pvSignature != NULL)
        {
            if (!CryptSignHash(_hCryptHash,
                              AT_SIGNATURE,
                              s_szDescription,
                              0,
                              reinterpret_cast<BYTE*>(_pvSignature),
                              &_dwSignatureSize))
            {
                hr = FixCryptoError(GetLastError());
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = FixCryptoError(GetLastError());
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::ReadSignature
//
//  Arguments:  hFile           =   File to read signature from.
//              pvSignature     =   Buffer to read signature to.
//
//  Returns:    HRESULT
//
//  Purpose:    Reads the signature from the given file. The format is known
//              and this function will move the file pointer accordingly.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::ReadSignature(HANDLE hFile, void *pvSignature)
{
    HRESULT hr;
    DWORD dwErrorCode;
    ULARGE_INTEGER ulFileSize;

    ulFileSize.LowPart = GetFileSize(hFile, &ulFileSize.HighPart);
    if (ulFileSize.LowPart == INVALID_FILE_SIZE)
    {
       hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        LARGE_INTEGER           iPosition;
        SIGNATURE_BLOB_TAIL     signatureBlobTail;
        DWORD                   dwPtr;

        //  Move the file pointer to the end of the file less the size of the
        //  signature's tail blob so that we read that to verify the signature
        //  is present.
        iPosition.QuadPart = -static_cast<int>(sizeof(signatureBlobTail));
        dwPtr = SetFilePointer(hFile,
                               iPosition.LowPart,
                               &iPosition.HighPart,
                               FILE_END);
        if ((dwPtr != INVALID_SET_FILE_POINTER) || ((dwErrorCode = GetLastError()) == ERROR_SUCCESS))
        {
            DWORD   dwNumberOfBytesRead;

            //  Read the signature blob in from the end of the file.
            if (ReadFile(hFile,
                         &signatureBlobTail,
                         sizeof(signatureBlobTail),
                         &dwNumberOfBytesRead,
                         NULL))
            {

                //  Verify that the blob is what we expect it to be.
                if ((sizeof(signatureBlobTail) == dwNumberOfBytesRead) &&                       //  we were able to read the correct size
                    (VSSIGN_TAG == signatureBlobTail.dwTag) &&                                  //  it has our signature
                    (ulFileSize.QuadPart == signatureBlobTail.ulFileSize.QuadPart))      //  it is the same size
                {
                    iPosition.QuadPart = -static_cast<int>(sizeof(signatureBlobTail) + signatureBlobTail.dwSigSize);

                    ASSERT(sizeof(SIGNATURE) == signatureBlobTail.dwSigSize); // If this doesn't match, we need to dynamically allocate the size of the signature.

                    //  Set the file pointer back past the signature AND the blob.
                    dwPtr = SetFilePointer(hFile,
                                           iPosition.LowPart,
                                           &iPosition.HighPart,
                                           FILE_END);
                    if ((dwPtr != INVALID_SET_FILE_POINTER) || ((dwErrorCode = GetLastError()) == ERROR_SUCCESS))
                    {
                        //  Read the signature to the given buffer.
                        if (ReadFile(hFile,
                                     pvSignature,
                                     sizeof(SIGNATURE),
                                     &dwNumberOfBytesRead,
                                     NULL) != FALSE)
                        {
                            if (dwNumberOfBytesRead == sizeof(SIGNATURE))
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                        else
                        {
                            dwErrorCode = GetLastError();
                            hr = HRESULT_FROM_WIN32(dwErrorCode);
                        }
                    }
                    else
                    {
                        // already filled in dwErrorCode in the if statement
                        hr = HRESULT_FROM_WIN32(dwErrorCode);
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                dwErrorCode = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErrorCode);
            }
        }
        else
        {
            // already filled in dwErrorCode in the if statement
            hr = HRESULT_FROM_WIN32(dwErrorCode);
        }
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::WriteSignature
//
//  Arguments:  pszFilename         =   File path to write signature to.
//              pvSignature         =   Signature to write.
//              dwSignatureSize     =   Size of signature to write.
//
//  Returns:    HRESULT
//
//  Purpose:    Opens the file WRITE. Moves the file pointer to the end of the
//              file and writes the signature AND blob out.
//
//              DESCRIPTION:
//              This function will write the signature from the file.  This is
//              the layout of the blob we add to the file:
//
//              Layout:
//              Start       End     Contents
//              0 byte      n Byte  The original file
//              n           n+m     Our signature (m bytes long, normally 128)
//              n+m         n+4+m   Our tag (VSSIGN_TAG)
//              n+4+m       n+8+m   'm', the size of our Signature.
//              n+8+m       n+16+m  The file size (n+m+16)   n is normally 16 bytes.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::WriteSignature(const WCHAR *pszFilename, const void *pvSignature, DWORD dwSignatureSize)
{
    HRESULT     hr = S_OK;
    DWORD       dwErrorCode;
    HANDLE      hFile;

    hFile = CreateFileW(pszFilename,
                        GENERIC_WRITE,
                        0,
                        0,
                        OPEN_EXISTING,
                        0,
                        0);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        LARGE_INTEGER   iPosition;
        DWORD           dwPtr;

        iPosition.QuadPart = 0;
        dwPtr = SetFilePointer(hFile,
                               iPosition.LowPart,
                               &iPosition.HighPart,
                               FILE_END);
        if ((dwPtr != INVALID_SET_FILE_POINTER) || ((dwErrorCode = GetLastError()) == ERROR_SUCCESS))
        {
            SIGNATURE_BLOB_TAIL     signatureBlobTail;

            signatureBlobTail.dwTag = VSSIGN_TAG;
            signatureBlobTail.dwSigSize = dwSignatureSize;

            signatureBlobTail.ulFileSize.LowPart = GetFileSize(hFile, &signatureBlobTail.ulFileSize.HighPart);
            if (signatureBlobTail.ulFileSize.LowPart == INVALID_FILE_SIZE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                DWORD   dwNumberOfBytesWritten;

                signatureBlobTail.ulFileSize.QuadPart += (sizeof(signatureBlobTail) + dwSignatureSize);
                if (WriteFile(hFile,
                              pvSignature,
                              dwSignatureSize,
                              &dwNumberOfBytesWritten,
                              NULL) != FALSE)
                {
                    if (!WriteFile(hFile,
                                  &signatureBlobTail,
                                  sizeof(signatureBlobTail),
                                  &dwNumberOfBytesWritten,
                                  NULL))
                    {
                        dwErrorCode = GetLastError();
                        hr = HRESULT_FROM_WIN32(dwErrorCode);
                    }
                }
                else
                {
                    dwErrorCode = GetLastError();
                    hr = HRESULT_FROM_WIN32(dwErrorCode);
                }
            }
        }
        else
        {
            // dwErrorCode already filled by if statement
            hr = HRESULT_FROM_WIN32(dwErrorCode);
        }
        TBOOL(CloseHandle(hFile));
    }
    else
    {
        dwErrorCode = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErrorCode);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeSignature::CreateExportKey
//
//  Arguments:  dwBlobType  =   Blob type.
//              pvKey       =   Key data (returned).
//              dwKeySize   =   Key size (returned).
//
//  Returns:    HRESULT
//
//  Purpose:    Creates export keys for the given blob type. The caller must
//              released the returned buffer allocated.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::CreateExportKey(DWORD dwBlobType, void*& pvKey, DWORD& dwKeySize)
{
    HRESULT hr = S_OK;

    pvKey = NULL;
    dwKeySize = 0;
    if (CryptExportKey(_hCryptKey,
                       NULL,
                       dwBlobType,
                       0,
                       NULL,
                       &dwKeySize))
    {
        pvKey = LocalAlloc(LMEM_FIXED, dwKeySize);
        if (pvKey != NULL)
        {
            if (!CryptExportKey(_hCryptKey,
                               NULL,
                               dwBlobType,
                               0,
                               reinterpret_cast<BYTE*>(pvKey),
                               &dwKeySize))
            {
                LocalFree(pvKey);
                pvKey = NULL;
                dwKeySize = 0;
                hr = FixCryptoError(GetLastError());
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = FixCryptoError(GetLastError());
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::PrintKey
//
//  Arguments:  pvKey       =   Key data.
//              dwKeySize   =   Key data size.
//
//  Returns:    <none>
//
//  Purpose:    Prints the key information out (presumably for debugging).
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

void CThemeSignature::PrintKey(const void *pvKey, DWORD dwKeySize)

{
    DWORD   dwIndex;

    for (dwIndex = 0; dwIndex < dwKeySize; ++dwIndex)
    {
        if (dwIndex != 0)
        {
            wprintf(L", ");
            if (0 == (dwIndex % 13))
            {
                wprintf(L"\n");     // Next line
            }
        }
        wprintf(L"0x%02X", static_cast<const BYTE*>(pvKey)[dwIndex]);
    }
    wprintf(L"\nSize: %d\n", dwKeySize);
}

//  --------------------------------------------------------------------------
//  CThemeSignature::SafeStringConcatenate
//
//  Arguments:  pszString1  =   String to concatenate to.
//              pszString2  =   String to concatenate.
//              cchString1  =   Count of characters in pszString1.
//
//  Returns:    bool
//
//  Purpose:    Safely concatenates the contents of pszString2 to pszString1
//              to prevent buffer overflow and possible stack corruption.
//              Returns whether successful or not.
//
//  History:    2000-09-10  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeSignature::SafeStringConcatenate (WCHAR *pszString1, const WCHAR *pszString2, DWORD cchString1)    const

{
    bool    fResult;

    if ((lstrlenW(pszString1) + lstrlenW(pszString2) + sizeof('\0')) < cchString1)
    {
        lstrcatW(pszString1, pszString2);
        fResult = true;
    }
    else
    {
        fResult = false;
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CheckThemeFileSignature
//
//  Arguments:  Theme filename to check signature on.
//
//  Returns:    HRESULT
//
//  Purpose:    Flat function to reference guts of this module
//
//  History:    2000-09-28  rfernand        created
//  --------------------------------------------------------------------------
HRESULT CheckThemeFileSignature(LPCWSTR pszName)
{
    CThemeSignature themeSignature;

    HRESULT hr = themeSignature.Verify(pszName, false);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set (doesn't use CrtDbgReport)
//---------------------------------------------------------------------------
#ifndef _STDAFX_THEMELDR_
#define _STDAFX_THEMELDR_
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define _ATL_NO_ATTRIBUTES
#define _ATL_APARTMENT_THREADED
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
//---------------------------------------------------------------------------
#define _THEMELDR_
//---------------------------------------------------------------------------
#include <w4warn.h>
//---------------------------------------------------------------------------
#include "autos.h"
#include "log.h"
#include "Errors.h"
#include "Utils.h"
#include "SimpStr.h"
#include "stringtable.h"
//---------------------------------------------------------------------------
#include <atlbase.h> 
//---------------------------------------------------------------------------
#endif //_STDAFX_THEMELDR_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\main.cpp ===
//-------------------------------------------------------------------------//
// main.cpp
//-------------------------------------------------------------------------//
#include "pch.h"
#include "resource.h"
#include "main.h"
#include "pageinfo.h"
#include "tmreg.h"
#include "themeldr.h"
//-------------------------------------------------------------------------//
#define MAX_LOADSTRING 100
#define THEMESEL_WNDCLASS   TEXT("ThemeSelWnd")

//-------------------------------------------------------------------------//
class CWndBase
//-------------------------------------------------------------------------//
{
public:
    CWndBase()             { Detach(); }
    virtual ~CWndBase()    { Detach(); }
    
    BOOL Attach( HWND hwnd );
    void Detach()   { _hwnd = NULL; }
    operator HWND() { return _hwnd; }

    virtual void RepositionChildren( BOOL fCalcScroll, int cx = -1, int cy = -1) {}

protected:
    HWND _hwnd;
};

//-------------------------------------------------------------------------//
inline BOOL CWndBase::Attach( HWND hwnd )  {
    if( IsWindow( hwnd ) ) {
        _hwnd = hwnd; 
        return TRUE;
    }
    return FALSE;
};

//-------------------------------------------------------------------------//
class CChildTabWnd : public CWndBase
//-------------------------------------------------------------------------//
{
public:
    CChildTabWnd()
        :   _prgPages(0), 
            _cPages(0), 
            _iCurPage(-1), 
            _rghwndPages(NULL), 
            _rgrcPages(NULL) {}

    ~CChildTabWnd() { delete [] _rghwndPages; delete [] _rgrcPages; }

    HWND Create( DWORD dwExStyle, DWORD dwStyle,
                 const RECT& rc, HWND  hwndParent, UINT nID,
                 HINSTANCE hInst, LPVOID pvParam );

    int  CreatePages( const PAGEINFO rgPages[], int cPages );
    BOOL ShowPage( int iPage );
    HWND GetCurPage();
    BOOL GetCurPageRect( LPRECT prc );
    BOOL GetExtent( SIZE* psizeExtent );

    BOOL HandleNotify( NMHDR* pnmh, LRESULT* plRet );

    BOOL TranslateAccelerator( HWND, LPMSG );
    virtual void RepositionChildren( BOOL fCalcScroll, int cx = -1, int cy = -1);

private:
    const PAGEINFO* _prgPages;
    HWND*           _rghwndPages;   // page HWNDs
    RECT*           _rgrcPages;     // native page window size
    int             _cPages;
    int             _iCurPage;
};

//-------------------------------------------------------------------------//
class CMainWnd : public CWndBase
//-------------------------------------------------------------------------//
{
public:
    CMainWnd()
    {
        ZeroMemory( &_siVert, sizeof(_siVert) ); 
        ZeroMemory( &_siHorz, sizeof(_siHorz) ); 
    }
    ~CMainWnd() {}
    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
    void                    RepositionChildren( BOOL fCalcScroll, int cx = -1, int cy = -1);
    void                    Scroll( WPARAM wParam, int nBar );
    BOOL                    TranslateAccelerator( HWND hwnd, LPMSG pmsg)    {
                                return _wndTab.TranslateAccelerator( hwnd, pmsg );
                            }

    CChildTabWnd _wndTab;
    SCROLLINFO   _siVert;
    SCROLLINFO   _siHorz;

} _wndMain;

//-------------------------------------------------------------------------//
// Foward declarations of functions included in this code module:
ATOM                _RegisterWndClasses(HINSTANCE hInstance);
BOOL                _InitInstance(HINSTANCE, int);
BOOL                _InitThemeOptions( HINSTANCE, LPCTSTR lpCmdLine, BOOL* pfDone );
BOOL                _FoundPrevInstance( LPCWSTR lpCmdLine );
LRESULT CALLBACK    _MainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    _NilDlgProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    _AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    _SyntaxDlgProc(HWND, UINT, WPARAM, LPARAM);

//-------------------------------------------------------------------------//
// Global vars:
HINSTANCE        g_hInst = NULL;                    // module handle
TCHAR            g_szAppTitle[MAX_LOADSTRING] = {0};  // app title
int              g_iCurPage  = -1;
HWND             g_hwndMain = NULL;
THEMESEL_OPTIONS g_options = {0};
BOOL             g_fHide = FALSE;
BOOL             g_fMinimize = FALSE;

UINT             WM_THEMESEL_COMMUNICATION = 
                    RegisterWindowMessage(_TEXT("WM_THEMESEL_COMMUNICATION"));

// module static data
COLORREF         s_Colors[TM_COLORCOUNT];
BOOL             s_fFlatMenus;
BOOL             s_fDropShadows;

//-------------------------------------------------------------------------//
typedef BOOL (WINAPI *PFN_TMINIT)(HINSTANCE hInst);
//-------------------------------------------------------------------------//
BOOL InitThemeManager(BOOL fPreventInitTheme)
{
    if (fPreventInitTheme)
    {
        //---- easy way: just turn off reg key ----
        SetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, 0);
    }

    //---= if theme manager is already running, don't start our local guy ----
    if (FindWindow(L"ThemeManagerWindowClass", NULL))
        return TRUE;

    //---- load msgina (theme manager) ----
    HINSTANCE hInstMsgina = LoadLibraryW(L"msgina.dll");
    if (! hInstMsgina)
    {
        MessageBox(NULL, L"Could not load msgina.dll", L"Fatal Error", MB_OK);
        return FALSE;
    }

    //---- find TMInitialize() ----
    PFN_TMINIT pfnTmInit = (PFN_TMINIT) GetProcAddress(hInstMsgina, (LPCSTR)49);

    // TM_Initialize is only exported as ordinal 49 at this point (9/27/00)
    if (! pfnTmInit)
        pfnTmInit = (PFN_TMINIT) GetProcAddress(hInstMsgina, (LPCSTR) 49);

    if (! pfnTmInit)
    {
        MessageBox(NULL, L"Could not find msgina entrypoint: TM_Initialize", L"Fatal Error", MB_OK);
        return FALSE;
    }

    //---- initialize theme manager ----
    pfnTmInit(hInstMsgina);

    return TRUE;
}
//-------------------------------------------------------------------------//
EXTERN_C APIENTRY _tWinMain( 
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR    lpCmdLine,
    int       nCmdShow)
{
    //---- initialize globals in themeldr.lib ----
    ThemeLibStartUp(FALSE);

    //---- initialize our globals ----
    g_hInst = hInstance; // Store instance handle in our global variable

    MSG msg;
    HACCEL hAccelTable;

    if (_FoundPrevInstance( lpCmdLine ))
        return 0;

    _SaveSystemSettings( );

    // Perform application initialization:
    BOOL fDone;
    if( !_InitThemeOptions( hInstance, lpCmdLine, &fDone ) )
        return 1;

    //---- turn off theme mgr for now, until msgina supports this again ----
    //if (! InitThemeManager(g_options.fPreventInitTheming))
    //    return 1;

    if (fDone)  // completed cmdline task OK
        return 0;

    if (g_fHide)
        nCmdShow = SW_HIDE;    
    else if (g_fMinimize)
        nCmdShow = SW_MINIMIZE;  

    if( !_InitInstance( hInstance, nCmdShow )) 
        return 1;

    hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_THEMESEL));

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
            continue;

        if (msg.message == WM_THEMECHANGED)
        {
            //Log(LOG_TMCHANGE, L"MessageLoop: WM_THEMECHANGED on hwnd=0x%x (IsWindow()=%d)", 
                //msg.hwnd, IsWindow(msg.hwnd));
        }

        //if( _wndMain.TranslateAccelerator( msg.hwnd, &msg ) )
        //    continue;
            
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}

//-------------------------------------------------------------------------//
ATOM _RegisterWndClasses(HINSTANCE hInstance)
{
    WNDCLASSEX wcex;

    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    icc.dwICC  = ICC_TAB_CLASSES;
    InitCommonControlsEx( &icc );

    wcex.cbSize         = sizeof(WNDCLASSEX); 

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = CMainWnd::WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_THEMESEL));
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = MAKEINTRESOURCE(IDC_THEMESEL);
    wcex.lpszClassName  = THEMESEL_WNDCLASS;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassEx(&wcex);
}

//-------------------------------------------------------------------------//
HWND CChildTabWnd::Create(
    DWORD dwExStyle,
    DWORD dwStyle,
    const RECT& rc,
    HWND  hwndParent,
    UINT  nID,
    HINSTANCE hInst,
    LPVOID pvParam )
{
    _hwnd = CreateWindowEx( dwExStyle, WC_TABCONTROL, TEXT(""), 
                            dwStyle | (WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|TCS_MULTILINE|TCS_HOTTRACK), 
                            rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc), 
                            hwndParent, IntToPtr_(HMENU, nID), hInst, pvParam );
    return _hwnd;
}

#define VALIDPAGE(iPage,cPages) (((iPage) >=0) && ((iPage) < (cPages)))
//-------------------------------------------------------------------------//
int CChildTabWnd::CreatePages( const PAGEINFO rgPages[], int cPages )
{
    _cPages = 0;
    _prgPages = NULL;
    delete [] _rghwndPages;
    delete [] _rgrcPages;
    _rghwndPages = NULL;
    _rgrcPages = NULL;
    
    for( int i = 0; i < cPages; i++ )
    {
        TCITEM tci;
        TCHAR  szText[MAX_LOADSTRING];

        ZeroMemory( &tci, sizeof(tci) );
        tci.mask = (rgPages[i].nIDSTitle ? TCIF_TEXT : 0);

        LoadString( g_hInst, rgPages[i].nIDSTitle, szText, ARRAYSIZE(szText) );
        tci.pszText = szText;

        if( SendMessage( _hwnd, TCM_INSERTITEM, _cPages, (LPARAM)&tci ) == _cPages )
            _cPages++;
    }

    if( _cPages )
        _prgPages = rgPages;

    if( (_rghwndPages = new HWND[_cPages]) != NULL )
        ZeroMemory( _rghwndPages, _cPages * sizeof(HWND) );
    if( (_rgrcPages = new RECT[_cPages]) != NULL )
        ZeroMemory( _rgrcPages, _cPages * sizeof(RECT) );

    return _cPages;
}

//-------------------------------------------------------------------------//
HWND CChildTabWnd::GetCurPage()
{
    if( VALIDPAGE( _iCurPage, _cPages ) && 
        IsWindow(_rghwndPages[_iCurPage]) )
        return _rghwndPages[_iCurPage];
    return NULL;
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::GetCurPageRect( LPRECT prc )
{
    if( VALIDPAGE( _iCurPage, _cPages ) && 
        !IsRectEmpty(_rgrcPages + _iCurPage) )
    {
        *prc = _rgrcPages[_iCurPage];
        return TRUE;
    }
    return FALSE;        
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::GetExtent( SIZE* pext )
{
    RECT rc;
    if( GetCurPageRect( &rc ) )
    {
        SendMessage( _hwnd, TCM_ADJUSTRECT, TRUE, (LPARAM)&rc );
        pext->cx = RECTWIDTH(&rc);
        pext->cy = RECTHEIGHT(&rc);
        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::ShowPage( int iPage )
{
    if( iPage == _iCurPage )
        return TRUE;

    HWND hwndCurPage = GetCurPage();
    BOOL bInit = FALSE;

    if( hwndCurPage )
    {
        ShowWindow( hwndCurPage, SW_HIDE );
        EnableWindow( hwndCurPage, FALSE );
    }
    else
        bInit = TRUE;

    if( VALIDPAGE( iPage, _cPages ) ) 
    {
        if( !IsWindow(_rghwndPages[iPage]) )
            _rghwndPages[iPage] = _prgPages[iPage].pfnCreateInstance( _hwnd );
            
        if( IsWindow( _rghwndPages[iPage] ) )
        {
            _iCurPage = iPage;
            hwndCurPage = GetCurPage();
            
            if( hwndCurPage )
            {
                if( bInit )
                {
                    //  Set tab font
                    HFONT hf = (HFONT)SendMessage( hwndCurPage, WM_GETFONT, 0, 0L );
                    if( hf )
                        SendMessage( _hwnd, WM_SETFONT, (WPARAM)hf, 0L );
                }

                if( IsRectEmpty( _rgrcPages + iPage ) )
                {
                    //  Initialize native page rect.
                    GetWindowRect( _rghwndPages[iPage], _rgrcPages + iPage );
                    OffsetRect( _rgrcPages + iPage, 
                                -_rgrcPages[iPage].left, -_rgrcPages[iPage].top );
                    
                    //  Position page using TCM_ADJUSTRECT.
                    //  note: ignore width, height when we reposition, as TCM_ADJUSTRECT 
                    //  might have clipped them to its current client area)
                    RECT rcPage ;
                    GetWindowRect( _hwnd, &rcPage );
                    OffsetRect( &rcPage, -rcPage.left, -rcPage.top );
                    SendMessage( _hwnd, TCM_ADJUSTRECT, FALSE, (LPARAM)&rcPage );

                    SetWindowPos( hwndCurPage, NULL, rcPage.left, rcPage.top,
                                  RECTWIDTH(_rgrcPages + iPage), RECTHEIGHT(_rgrcPages + iPage), 
                                  SWP_NOACTIVATE|SWP_NOZORDER );
                }
                
                //  Inform parent of new scroll limits
                _wndMain.RepositionChildren( TRUE );

                ShowWindow( hwndCurPage, SW_SHOW );
                EnableWindow( hwndCurPage, TRUE );
                SetFocus( hwndCurPage );
            }
        }
    }
    return _iCurPage == iPage;
}

//-------------------------------------------------------------------------//
void CChildTabWnd::RepositionChildren( BOOL fCalcScroll, int cx, int cy )
{
    SIZE sizeDlg;
    HWND hwndDlg = GetCurPage();
       
    if( IsWindow( hwndDlg ) && GetExtent( &sizeDlg ) )
    {
        RECT rcPage;
        
        if( cx < 0 || cy < 0 )
        {
            GetWindowRect( _hwnd, &rcPage );
            OffsetRect( &rcPage, -rcPage.left, -rcPage.top );
        }
        else
        {
            SetRect( &rcPage, 0, 0, cx, cy );
        }

        SendMessage( _hwnd, TCM_ADJUSTRECT, FALSE, (LPARAM)&rcPage );

        SetWindowPos( hwndDlg, NULL, rcPage.left, rcPage.top, 
                      min(RECTWIDTH(&rcPage), sizeDlg.cx),
                      min(RECTHEIGHT(&rcPage), sizeDlg.cy),
                      SWP_NOACTIVATE|SWP_NOZORDER );
    }
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::TranslateAccelerator( HWND hwnd, LPMSG pmsg)
{
    HWND hwndCurPage = GetCurPage();
    if( hwndCurPage || IsChild( hwndCurPage, hwnd ) )
        return IsDialogMessage( hwndCurPage, pmsg );
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::HandleNotify( NMHDR* pnmh, LRESULT* plRet )
{
    *plRet = 0;
    switch( pnmh->code )
    {
        case TCN_SELCHANGE:
        {
            ShowPage( TabCtrl_GetCurSel( _hwnd ) );
            return TRUE;
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    if( _RegisterWndClasses(hInstance) )
    {
       if( LoadString(hInstance, IDS_APP_TITLE, g_szAppTitle, MAX_LOADSTRING) )
       {
           CreateWindowEx( WS_EX_CLIENTEDGE, 
                           THEMESEL_WNDCLASS, g_szAppTitle, 
                           WS_OVERLAPPEDWINDOW|WS_HSCROLL|WS_VSCROLL,
                           CW_USEDEFAULT, CW_USEDEFAULT, 800, 560, 
                           NULL, NULL, hInstance, NULL);
            
           if( IsWindow( _wndMain ) )
           {
                g_hwndMain = _wndMain;

                ShowWindow(_wndMain, nCmdShow);
                UpdateWindow(_wndMain);
           }
       }
    }
    return TRUE;
}

//-------------------------------------------------------------------------//
HRESULT _ProcessFileName( LPCTSTR pszThemeFile, LPCWSTR pszColor, LPCWSTR pszSize, BOOL* pfDone  )
{
    HRESULT hr;
    *pfDone = FALSE;

    hr = S_OK;

    if (pszThemeFile)
        hr = _ApplyTheme(pszThemeFile, pszColor, pszSize, pfDone);

    return hr;
}

//-------------------------------------------------------------------------//
void ShowThemeError(HRESULT hr)
{
    WCHAR szBuff[2*MAX_PATH];

    if (THEME_PARSING_ERROR(hr))
    {
        PARSE_ERROR_INFO Info = {sizeof(Info)};

        HRESULT hr2 = GetThemeParseErrorInfo(&Info);
        if (SUCCEEDED(hr2))
        {
            lstrcpy(szBuff, Info.szMsg);
        }
        else
        {
            wsprintf(szBuff, L"Unknown parsing error");
        }
    }
    else
    {
        // normal win32 error
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, szBuff, ARRAYSIZE(szBuff), NULL);
    }

    MessageBoxW(NULL, szBuff, L"Error Loading Theme", MB_OK);
}
//-------------------------------------------------------------------------//
HRESULT _ApplyTheme( LPCTSTR pszThemeFile, LPCWSTR pszColor, LPCWSTR pszSize, BOOL* pfDone  )
{
    HRESULT hr = E_FAIL;
    if (pfDone)
        *pfDone = FALSE;

    if (pszThemeFile && *pszThemeFile)
    {
        HTHEMEFILE htf;

        //---- OpenThemeFile needs filename fully qualified ----
        TCHAR szFullName[MAX_PATH];

        GetFullPathName(pszThemeFile, ARRAYSIZE(szFullName), szFullName, NULL); 

        hr = OpenThemeFile(szFullName, pszColor, pszSize, &htf, TRUE);

        if (FAILED(hr))
            ShowThemeError(hr);
        else
        {
            //---- apply theme ----
            DWORD dwFlags = 0;

#if 0           // not currently supported
            if (g_options.fExceptTarget)
                dwFlags |= AT_EXCLUDEAPP;
            
            if (! g_options.fEnableFrame)
                dwFlags |= AT_DISABLE_FRAME_THEMING;

            if (! g_options.fEnableDialog)
                dwFlags |= AT_DISABLE_DIALOG_THEMING;
#endif

            if (! g_options.hwndPreviewTarget)      // if not preview
                dwFlags |= AT_LOAD_SYSMETRICS;

            hr = ApplyTheme(htf, dwFlags, g_options.hwndPreviewTarget);
            if (hr)
                ShowThemeError(hr);

            CloseThemeFile(htf);       // we don't need to hold open anymore
        }
    }

    return hr;
}

//-------------------------------------------------------------------------//
BOOL _FoundPrevInstance( LPCWSTR lpCmdLine )
{

    HWND hwndPrev = FindWindow(THEMESEL_WNDCLASS, NULL);
    if (! hwndPrev)
        return FALSE;

    //---- find out what we are trying to do with this 2nd version ----
    LPCWSTR p = lpCmdLine;
    BOOL fUnload = FALSE;

    if ((*p == '-') || (*p == '/'))
    {
        p++;
        if ((*p == 'u') || (*p == 'U'))
            fUnload = TRUE;
    }

    //---- send a special msg and exit ----
    BOOL fGotIt = (BOOL)SendMessage(hwndPrev, WM_THEMESEL_COMMUNICATION, fUnload, 0);
    return fGotIt;
}

//-------------------------------------------------------------------------//
BOOL _InitThemeOptions( HINSTANCE hInstance, LPCTSTR lpCmdLine, BOOL *pfDone )
{
    LPCTSTR pszThemeFile = NULL;

    if( 0 == g_options.cbSize )
    {
        g_options.cbSize = sizeof(g_options);
        g_options.fEnableFrame = TRUE;
        g_options.fEnableDialog = TRUE;
        g_options.fPreventInitTheming = FALSE;
        g_options.fUserSwitch = FALSE;
        g_options.fExceptTarget = FALSE;
        g_options.hwndPreviewTarget = NULL;
        *g_options.szTargetApp = 0;
    }

    //---- other cmd line switches ----
    // -a<appname> (to set targeted app)
    // -t (to set themesel as target app)
    // -l (to load "Professional" theme and exit)
    // -u (to clear theme and exit)


    while (*lpCmdLine)           // process cmd line args
    {
        while (isspace(*lpCmdLine))
            lpCmdLine++;

        if ((*lpCmdLine == '-') || (*lpCmdLine == '/'))
        {
            lpCmdLine++;
            WCHAR lowp = towlower(*lpCmdLine);

            if (lowp == '?')
            {
                DialogBox( g_hInst, MAKEINTRESOURCE(IDD_SYNTAX), NULL, _SyntaxDlgProc );
                return FALSE;
            }
            else if (lowp == 'f')
                g_options.fEnableFrame = FALSE;
            else if (lowp == 'd')
                g_options.fEnableDialog = FALSE;
            else if (lowp == 'p')
                g_options.fPreventInitTheming = TRUE;
            else if ((lowp == 'a') || (lowp == 'x'))
            {
                g_options.fExceptTarget = (lowp == 'x');
                lpCmdLine++;;
                LPCTSTR q = lpCmdLine;
                while ((*lpCmdLine) && (! isspace(*lpCmdLine)))
                    lpCmdLine++;
                int len = int(lpCmdLine - q);
                if (len)
                    memcpy(g_options.szTargetApp, q, sizeof(WCHAR)*len);
                g_options.szTargetApp[len] = 0;
                continue;
            }
            else if (lowp == 't')
                lstrcpy(g_options.szTargetApp, L"ThemeSel");
            else if (lowp == 'l')           // load "business" theme and minimize
            {
                pszThemeFile = DEFAULT_THEME;
                g_fMinimize = TRUE;

            }
            else if (lowp == 'z')           // load "business" theme and hide
            {
                pszThemeFile = DEFAULT_THEME;
                g_fHide = TRUE;
            }
            else if (lowp == 'u')           // just unload theme & exit
            {
                //---- turn off theme from previous run, if any ----
                ApplyTheme(NULL, 0, NULL);
                return FALSE;               // exit
            }
            else
            {
                MessageBox(NULL, L"Unrecognized switch", L"Error", MB_OK);
                return FALSE;
            }
            lpCmdLine++;        // skip over switch letter
        }
        else
        {
            pszThemeFile = lpCmdLine;
            break;
        }
    }

    return SUCCEEDED(_ProcessFileName( pszThemeFile, NULL, NULL, pfDone ));
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK CMainWnd::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;

    switch (uMsg) 
    {
        case WM_NCCREATE:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            _wndMain.Attach( hwnd );
            break;

        case WM_NCDESTROY:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            _wndMain.Detach();
            break;

        case WM_CREATE:
        {
            RECT rc;
            GetClientRect( hwnd, &rc );
            if( !_wndMain._wndTab.Create( 0, WS_VISIBLE, rc, _wndMain, 0, g_hInst, 0 ) )
                return -1;

            if( _wndMain._wndTab.CreatePages( g_rgPageInfo, g_cPageInfo ) )
                _wndMain._wndTab.ShowPage(0);

            break;
        }

        case WM_HSCROLL:
        case WM_VSCROLL:
            _wndMain.Scroll( wParam, uMsg == WM_VSCROLL ? SB_VERT : SB_HORZ );
            break;

        case WM_COMMAND:
        {
            int wmId    = LOWORD(wParam); 
            int wmEvent = HIWORD(wParam); 
            BOOL fFake;

            // Parse the menu selections:
            switch (wmId)
            {
                case IDM_ABOUT:
                   DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hwnd, _AboutDlgProc);
                   break;
                case IDM_APPLY:
                   GeneralPage_OnTestButton(g_hwndGeneralPage, 0, NULL, NULL, fFake);
                   break;
                case IDM_DUMP:
                   GeneralPage_OnDumpTheme();
                   break;
                case IDM_REMOVE:
                   GeneralPage_OnClearButton(g_hwndGeneralPage, 0, NULL, NULL, fFake);
                   break;
                case IDM_EXIT:
                   DestroyWindow(hwnd);
                   break;
                default:
                   lRet = DefWindowProc(hwnd, uMsg, wParam, lParam);
            }
            break;
        }

        case WM_ERASEBKGND:
            return 1L;

        case WM_DESTROY:
            _ShutDown( FALSE );
            PostQuitMessage(0);
            break;

        case WM_SIZE:
        {
            POINTS pts = MAKEPOINTS(lParam);
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            _wndMain.RepositionChildren( TRUE, pts.x, pts.y );
            break;
        }

        case WM_NOTIFY:
        {
            if( ((NMHDR*)lParam)->hwndFrom == _wndMain._wndTab )
            {
                if( _wndMain._wndTab.HandleNotify( (NMHDR*)lParam, &lRet ) )
                   return lRet;
            }
            break;
        }
        
        default:
            if (uMsg == WM_THEMESEL_COMMUNICATION)      // msg from another instance of themesel
            {
                if (wParam == 1)            // exit
                    _ShutDown( TRUE );
                else
                    ShowWindow(g_hwndMain, SW_NORMAL);

                return 1;
            }

            lRet = DefWindowProc(hwnd, uMsg, wParam, lParam);
   }
   return lRet;
}

//-------------------------------------------------------------------------//
void CMainWnd::RepositionChildren( BOOL fCalcScroll, int cx, int cy )
{
    if( IsWindow( _wndTab ) )
    {
        RECT rcClient = {0};
        if( cx < 0 || cy < 0 )
        {
            GetClientRect( _hwnd, &rcClient );
            cx = RECTWIDTH(&rcClient);
            cy = RECTHEIGHT(&rcClient);
        }
        else
        {
            rcClient.right  = cx;
            rcClient.bottom = cy;
        }

        SIZE  sizeMin;
        if( _wndTab.GetExtent(&sizeMin) )
        {
            if( fCalcScroll )
            {
                POINT pos;
                pos.x = _siHorz.nPos;
                pos.y = _siVert.nPos;

                _siHorz.fMask = _siVert.fMask = (SIF_RANGE|SIF_PAGE);

                _siHorz.nPage = cx; // thumb width
                _siVert.nPage = cy; // thumb height

                SIZE sizeDelta; // difference between what we have to show and what is shown.
                sizeDelta.cx = sizeMin.cx - _siHorz.nPage;
                sizeDelta.cy = sizeMin.cy - _siVert.nPage;

                //  establish maximum scroll positions
                _siHorz.nMax = sizeDelta.cx > 0 ? sizeMin.cx - 1 : 0;
                _siVert.nMax = sizeDelta.cy > 0 ? sizeMin.cy - 1 : 0;

                //  establish horizontal scroll pos
                if( sizeDelta.cx <= 0 )   
                    _siHorz.nPos = 0;  // scroll to extreme left if we're removing scroll bar
                else if( sizeDelta.cx < _siHorz.nPos ) 
                    _siHorz.nPos = sizeDelta.cx; // remove right-hand vacancy

                if( _siHorz.nPos != pos.x )
                    _siHorz.fMask |= SIF_POS;

                //  establish vertical scroll pos
                if( sizeDelta.cy <= 0 )  
                    _siVert.nPos = 0; // scroll to top if we're removing scroll bar
                else if( sizeDelta.cy < _siVert.nPos ) 
                    _siVert.nPos = sizeDelta.cy; // remove lower-portion vacancy

                if( _siVert.nPos != pos.y )
                    _siVert.fMask |= SIF_POS; 

                //  Note: can't call SetScrollInfo here, as it may generate
                //  a WM_SIZE and recurse back to this function before we had a 
                //  chance to SetWindowPos() our subdlg.  So defer it until after 
                //  we've done this.
            }

            SetWindowPos( _wndTab, NULL, -_siHorz.nPos, -_siVert.nPos, 
                          _siHorz.nPos + max(cx, sizeMin.cx), 
                          _siVert.nPos + max(cy, sizeMin.cy),
                          SWP_NOZORDER|SWP_NOACTIVATE );

            _wndTab.RepositionChildren( FALSE );

            if( fCalcScroll )
            {
                SetScrollInfo( _hwnd, SB_HORZ, &_siHorz, TRUE );
                SetScrollInfo( _hwnd, SB_VERT, &_siVert, TRUE );
            }
        }
    }
}

//-------------------------------------------------------------------------//
void CMainWnd::Scroll( WPARAM wParam, int nBar )
{
    SCROLLINFO* psi = SB_VERT == nBar ? &_siVert : 
                      SB_HORZ == nBar ? &_siHorz : NULL;

    const LONG  nLine = 15;
    UINT uSBCode = LOWORD(wParam);
    int  nNewPos = HIWORD(wParam);
    int  nDeltaMax = (psi->nMax - psi->nPage) + 1;

    if( !psi )
    {
        _ASSERTE(FALSE);
        return;
    }

    switch( uSBCode )
    {
        case SB_LEFT:
            psi->nPos--;
            break;
        case SB_RIGHT:
            psi->nPos++;
            break;
        case SB_LINELEFT:
            psi->nPos = max( psi->nPos - nLine, 0 );
            break;
        case SB_LINERIGHT:
            psi->nPos = min( psi->nPos + nLine, nDeltaMax );
            break;
        case SB_PAGELEFT:
            psi->nPos = max( psi->nPos - (int)psi->nPage, 0 );
            break;
        case SB_PAGERIGHT:
            psi->nPos = min( psi->nPos + (int)psi->nPage, nDeltaMax );
            break;
        case SB_THUMBTRACK:
            psi->nPos = nNewPos;
            break;
        case SB_THUMBPOSITION:
            psi->nPos = nNewPos;
            break;
        case SB_ENDSCROLL:
            return;
    }
    psi->fMask = SIF_POS;
    
    SetScrollInfo( _hwnd, nBar, psi, TRUE );
    RepositionChildren( FALSE );
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK _NilDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
                return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            break;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK _AboutDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return _NilDlgProc( hDlg, uMsg, wParam, lParam );
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK _SyntaxDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return _NilDlgProc( hDlg, uMsg, wParam, lParam );
}

//---------------------------------------------------------------------------
void _SaveSystemSettings( )
{
    //---- save off system colors for later restoration ----
    for (int i=0; i < TM_COLORCOUNT; i++)
        s_Colors[i] = GetSysColor(i);

    //---- save off "flatmenu" and "dropshadows" settings ---
    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&s_fFlatMenus, 0);
    SystemParametersInfo(SPI_GETDROPSHADOW, 0, (PVOID)&s_fDropShadows, 0);
} 

//---------------------------------------------------------------------------
void _RestoreSystemSettings(HWND hwndGeneralPage, BOOL fUnloadOneOnly)
{
    //---- turn off current Theme ----
    HWND hwndPreview = hwndGeneralPage ? GetPreviewHwnd(hwndGeneralPage) : NULL;

    if (fUnloadOneOnly)         // remove the "active" theme
    {
        if (hwndPreview)       
        {
            ApplyTheme(NULL, 0, hwndPreview);
            return;
        }
        else
        {
            //---- fall thru & restore sys metrics ----
            ApplyTheme(NULL, 0, NULL);
        }
    }
    else
    {
        ApplyTheme(NULL, 0, hwndPreview);
    }

    //---- restore system colors ----
    int iIndexes[TM_COLORCOUNT];

    for (int i=0; i < TM_COLORCOUNT; i++)
        iIndexes[i] = i;

    SetSysColors(TM_COLORCOUNT, iIndexes, s_Colors);

    //---- restore "flatmenu" and "dropshadows" settings ---
    SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(s_fFlatMenus), SPIF_SENDCHANGE);
    SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(s_fFlatMenus), SPIF_SENDCHANGE);
}

//---------------------------------------------------------------------------
void _ShutDown( BOOL bQuit )
{
    if( bQuit )
        PostQuitMessage(0);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\genlpage.cpp ===
#include "pch.h"
#include "resource.h"
#include "main.h"
#include <stdio.h>

//-------------------------------------------------------------------------//
//  'General' page impl
//-------------------------------------------------------------------------//

//  CreateIntance, DlgProc
HWND    CALLBACK GeneralPage_CreateInstance( HWND hwndParent );
INT_PTR CALLBACK GeneralPage_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
//  Message Handlers
LRESULT CALLBACK GeneralPage_OnThemeSelected( HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnColorSelected( HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnEdit( HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnInitDialog(HWND hwndPage, UINT, WPARAM, LPARAM, BOOL&);
LRESULT CALLBACK GeneralPage_OnDestroy( HWND hwndPage, UINT, WPARAM, LPARAM, BOOL&);

//  Misc
BOOL    CALLBACK GeneralPage_AddProccessNamesCB( HWND hwnd, LPARAM lParam );
void             GeneralPage_AddProcessNamesToCombos( HWND hwndPage );

//  Utility Methods
void GeneralPage_RefreshThemeName( HWND hwndPage ); 
BOOL GeneralPage_EnumProc( enum THEMECALLBACK tcbType, LPCWSTR pszName, LPCWSTR pszDisplayName, 
     LPCWSTR pszToolTip, int iIndex, LPARAM lParam  );
void GeneralPage_AddProcessNamesToCombos( HWND hwndPage );
void GeneralPage_EnableDlgButtons( HWND hwndPage );
void GeneralPage_RebuildThemes(HWND hwndPage, LPCWSTR pszCurrentTheme);

HWND g_hwndGeneralPage = NULL;
//-------------------------------------------------------------------------//
void ExpandDirIntoFullThemeFileName(LPCWSTR pszSubDir, LPWSTR pszFileName)
{
    //---- turn this into a real theme file name ----
    WCHAR szRelativeDir[_MAX_PATH+1];
    wsprintf(szRelativeDir, L"%s\\%s.msstyles", pszSubDir, pszSubDir);

    WCHAR *pszBaseName;
    GetFullPathName(szRelativeDir, MAX_PATH, pszFileName, &pszBaseName);
}
//-------------------------------------------------------------------------//
INT_PTR CALLBACK GeneralPage_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L;
    switch( uMsg )
    {
        case WM_INITDIALOG:
            lRet = GeneralPage_OnInitDialog( hwndPage, uMsg, wParam, lParam, bHandled );
            break;

        case WM_COMMAND:
        {
            HWND hwndCtl = (HWND)lParam;
            UINT uCode   = HIWORD(wParam);
            switch( LOWORD(wParam) )
            {
                case IDC_TESTBUTTON:
                    lRet = GeneralPage_OnTestButton( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;
    
                case IDC_CLEARBUTTON:
                    lRet = GeneralPage_OnClearButton( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;

                case IDC_DIRNAME:
                    lRet = GeneralPage_OnThemeSelected( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;

                case IDC_COLORCOMBO:
                    lRet = GeneralPage_OnColorSelected( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;

                case IDC_EDIT_THEME:
                    lRet = GeneralPage_OnEdit( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;

                case IDC_TARGET:
                case IDC_UNTARGET:
                    if( CBN_DROPDOWN == uCode )
                    {
                        //  Keep process names fresh.
                        GeneralPage_AddProcessNamesToCombos( hwndPage );
                    }
                    break;
            }
            GeneralPage_EnableDlgButtons( hwndPage );
            break;
        }

        case WM_DESTROY:
            lRet = GeneralPage_OnDestroy( hwndPage, uMsg, wParam, lParam, bHandled );
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
HWND CALLBACK GeneralPage_CreateInstance( HWND hwndParent )
{
    g_hwndGeneralPage = CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_PAGE_GENERAL),
                         hwndParent,  GeneralPage_DlgProc );

    return g_hwndGeneralPage;
}

//---------------------------------------------------------------------------
BOOL ThemeEnumerator(enum THEMECALLBACK tcbType, LPCWSTR pszName, 
    LPCWSTR pszDisplayName, LPCWSTR pszToolTip, int iIndex, LPARAM lParam)
{
    HWND combo = (HWND)lParam;

    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBase[_MAX_FNAME], szExt[_MAX_EXT];
    WCHAR szBaseName[MAX_PATH];
    _tsplitpath(pszName, szDrive, szDir, szBase, szExt);
    wsprintf(szBaseName, L".\\%s\\%s%s", szBase, szBase, szExt);

    int index = (int)SendMessage(combo, CB_ADDSTRING, 0, (LPARAM)szBaseName);

    if (! index)            // first one added
    {
        ::SetWindowText(combo, szBaseName);
        
        //---- simulate a selection change ----
        ::SendMessage(combo, CB_SETCURSEL, 0, 0);
    }

    return TRUE;
}

//---------------------------------------------------------------------------
void GeneralPage_RebuildThemes(HWND hwndPage, LPCWSTR pszCurrentTheme)
{
    HWND hwndCombo = GetDlgItem(hwndPage, IDC_DIRNAME);
    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);

    WCHAR szFullDir[_MAX_PATH+1];
    WCHAR *pszBaseName;
    DWORD val = GetFullPathName(L".", ARRAYSIZE(szFullDir), szFullDir, &pszBaseName);
    if (! val)
    {
        MessageBox(NULL, L"GetFullPathName() failure", L"Error", MB_OK);
        return;
    }

    //---- enum actual theme DLL's ----
    HRESULT hr = EnumThemes(szFullDir, ThemeEnumerator, (LPARAM)hwndCombo);
    ATLASSERT(SUCCEEDED(hr));

    //---- enum theme subdirs ----
    HANDLE hFile = NULL;
    BOOL   bFile = TRUE;
    WIN32_FIND_DATA wfd;
    hr = S_FALSE;       // assume interrupted until we complete
    bFile = TRUE;

    for( hFile = FindFirstFile( TEXT("*.*"), &wfd ); hFile != INVALID_HANDLE_VALUE && bFile;
         bFile = FindNextFile( hFile, &wfd ) )
    {
        WCHAR *p = wfd.cFileName;

        if(! ( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ))
            continue;

        if ((lstrcmp(wfd.cFileName, TEXT("."))==0) || (lstrcmp(wfd.cFileName, TEXT(".."))==0))
            continue;

        if (_tcsicmp(p, _TEXT("obj"))==0)           // dev directory
            continue;

        SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)wfd.cFileName);
    }

    //---- select the first theme ----
    int index = (int)SendMessage(hwndCombo, CB_FINDSTRINGEXACT, 0, (LPARAM)pszCurrentTheme);
    if (index < 0)
        index = 0;
    
    SendMessage(hwndCombo, CB_SETCURSEL, index, NULL);
}
//---------------------------------------------------------------------------
LRESULT GeneralPage_OnInitDialog(HWND hwndPage, UINT, WPARAM wid, LPARAM, BOOL&)
{
    GeneralPage_RefreshThemeName( hwndPage );

#if 0       // testing SetWindowTheme()
    HWND hwndOK = GetDlgItem(hwndPage, IDC_TESTBUTTON);
    if (hwndOK)
        SetWindowTheme(hwndOK, L"themeok", NULL);

    HWND hwndCancel = GetDlgItem(hwndPage, IDC_CLEARBUTTON);
    if (hwndCancel)
        SetWindowTheme(hwndCancel, NULL, L"CancelButton");
#endif

    GeneralPage_RebuildThemes(hwndPage, DEFAULT_THEME);

    //---- simulate a selection ----
    BOOL mybool;
    GeneralPage_OnThemeSelected(hwndPage, 0, 0, 0, mybool);
    
    GeneralPage_AddProcessNamesToCombos( hwndPage );

    CheckDlgButton( hwndPage, IDC_THEME_ALL,     *g_options.szTargetApp == 0 );
    CheckDlgButton( hwndPage, IDC_THEME_PROCESS, *g_options.szTargetApp != 0 && !g_options.fExceptTarget);
    CheckDlgButton( hwndPage, IDC_THEME_EXEMPT,  *g_options.szTargetApp != 0 &&  g_options.fExceptTarget );
    CheckDlgButton( hwndPage, IDC_THEME_PREVIEW,  g_options.hwndPreviewTarget != 0 );
    CheckDlgButton( hwndPage, IDC_ENABLE_FRAME,   g_options.fEnableFrame );
    CheckDlgButton( hwndPage, IDC_ENABLE_DLG,     g_options.fEnableDialog );
    CheckDlgButton( hwndPage, IDC_USERSWITCH,     g_options.fUserSwitch );
    GeneralPage_EnableDlgButtons( hwndPage );

    //---- set preview edit text to hwndPage ----
    WCHAR szBuff[_MAX_PATH+1];
    wsprintf(szBuff, L"%x", hwndPage);
    SetDlgItemText(hwndPage, IDC_PREVIEW, szBuff);

    return 0;
}

//---------------------------------------------------------------------------
void GeneralPage_EnableDlgButtons( HWND hwndPage )
{
    EnableWindow( GetDlgItem( hwndPage, IDC_TARGET ), IsDlgButtonChecked( hwndPage, IDC_THEME_PROCESS )!=0 );
    EnableWindow( GetDlgItem( hwndPage, IDC_UNTARGET ), IsDlgButtonChecked( hwndPage, IDC_THEME_EXEMPT )!=0 );
    EnableWindow( GetDlgItem( hwndPage, IDC_PREVIEW ), IsDlgButtonChecked( hwndPage, IDC_THEME_PREVIEW )!=0 );
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnDumpTheme()
{
    HTHEME hTheme = OpenThemeData(NULL, L"globals");
    if (hTheme)
    {
        HTHEMEFILE hThemeFile;
        if (SUCCEEDED(OpenThemeFileFromData(hTheme, &hThemeFile)))
        {
            HRESULT hr = DumpLoadedThemeToTextFile(hThemeFile, L"theme.dmp", TRUE, TRUE);
            if (FAILED(hr))
                MessageBox(NULL, L"DumpLoadedThemeToTextFile() Failed", L"Error", MB_OK);

            CloseThemeFile(hThemeFile);
        }

        CloseThemeData(hTheme);
    }

    return 0;
}
//---------------------------------------------------------------------------
LRESULT GeneralPage_OnTestButton( HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{
    //---- get theme szFileName ----
    WCHAR szThemeFileName[_MAX_PATH+1];
    GetDlgItemText(hwndPage, IDC_DIRNAME, szThemeFileName, ARRAYSIZE(szThemeFileName));

    //---- is it a dir? ----
    DWORD dwMask = GetFileAttributes(szThemeFileName);
    BOOL fDir = ((dwMask != 0xffffffff) && (dwMask & FILE_ATTRIBUTE_DIRECTORY));

    if (fDir)               // do auto convert to a .msstyles file
    {
        //---- run "packthem" against the dir ----
        WCHAR szDirName[_MAX_PATH+1];
        wcscpy(szDirName, szThemeFileName);

        WCHAR szCmdLine[2*_MAX_PATH+1];
        wsprintf(szCmdLine, L"/e %s", szDirName);

        HRESULT hr = SyncCmdLineRun(L"packthem.exe", szCmdLine);
        if (FAILED(hr))
        {
            LPWSTR szErrMsg;
            hr = AllocateTextFile(L"packthem.err", &szErrMsg, NULL);
            if (FAILED(hr))
            {
                MessageBox(NULL, L"Unknown Error", L"Error in packing Theme", MB_OK);
                return FALSE;
            }

            MessageBox(NULL, szErrMsg, L"Error in packing Theme", MB_OK);
            LocalFree(szErrMsg);

            return FALSE;
        }

        GeneralPage_RebuildThemes(hwndPage, szDirName);

        //---- convert into a DLL name ----
        ExpandDirIntoFullThemeFileName(szDirName, szThemeFileName);
    }

    WCHAR ColorParam[MAX_PATH+1];
    WCHAR SizeParam[MAX_PATH+1];

    *ColorParam = 0;
    *SizeParam = 0;

    //---- extract ColorParam ----
    HWND hwndCombo;
    hwndCombo = GetDlgItem(hwndPage, IDC_COLORCOMBO);
    int index;
    index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index > -1)
        SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)ColorParam);

    //---- extract SizeParam ----
    hwndCombo = GetDlgItem(hwndPage, IDC_SIZECOMBO);
    index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index > -1)
        SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)SizeParam);

    g_options.fExceptTarget = IsDlgButtonChecked( hwndPage, IDC_THEME_EXEMPT ) != 0;
    if( g_options.fExceptTarget )
    {
        GetDlgItemText( hwndPage, IDC_UNTARGET, 
                        g_options.szTargetApp, 
                        ARRAYSIZE(g_options.szTargetApp) );
    }
    else if( IsDlgButtonChecked( hwndPage, IDC_THEME_PROCESS ) != 0 )
    {
        GetDlgItemText( hwndPage, IDC_TARGET, 
                        g_options.szTargetApp, 
                        ARRAYSIZE(g_options.szTargetApp) );
    }
    else
        *g_options.szTargetApp = 0;

    //---- extract Preview info ----
    g_options.hwndPreviewTarget = GetPreviewHwnd(hwndPage);
    
    g_options.fEnableFrame = IsDlgButtonChecked( hwndPage, IDC_ENABLE_FRAME ) != 0;
    g_options.fEnableDialog = IsDlgButtonChecked( hwndPage, IDC_ENABLE_DLG ) != 0;
    g_options.fUserSwitch = IsDlgButtonChecked( hwndPage, IDC_USERSWITCH ) != 0;

    _ApplyTheme(szThemeFileName, ColorParam, SizeParam, NULL);

    GeneralPage_RefreshThemeName( hwndPage );

    return TRUE;
}

//---------------------------------------------------------------------------
HWND GetPreviewHwnd(HWND hwndGeneralPage)
{
    if (! hwndGeneralPage)
        return NULL;

    BOOL fPreview = IsDlgButtonChecked( hwndGeneralPage, IDC_THEME_PREVIEW ) != 0;
    if (! fPreview)
        return NULL;

    WCHAR szTempBuff[_MAX_PATH+1];

    GetDlgItemText(hwndGeneralPage, IDC_PREVIEW, szTempBuff, ARRAYSIZE(szTempBuff));

    LONG val;
    int cnt = swscanf(szTempBuff, L"%lx", &val);
    if (! cnt)
        val = 0;

    return (HWND)IntToPtr(val);
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnClearButton(HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{   
#if 0       // testing SetWindowTheme()
    HWND hwndOK = GetDlgItem(hwndPage, IDC_TESTBUTTON);
    if (hwndOK)
        SetWindowTheme(hwndOK, NULL, NULL);

    HWND hwndCancel = GetDlgItem(hwndPage, IDC_CLEARBUTTON);
    if (hwndCancel)
        SetWindowTheme(hwndCancel, NULL, NULL);
#endif

    _RestoreSystemSettings(hwndPage, TRUE);
    
    GeneralPage_RefreshThemeName( hwndPage );
    return 0;
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnThemeSelected( HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{
    //---- get theme szFileName ----
    WCHAR szFileName[MAX_PATH+1];
    WCHAR szSubDir[MAX_PATH+1];

    HWND hwndCombo = GetDlgItem(hwndPage, IDC_DIRNAME);
    int index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index == -1)
        *szFileName = 0;
    else
    {
        ::SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)szSubDir);

        //---- turn this into a real theme file name ----
        ExpandDirIntoFullThemeFileName(szSubDir, szFileName);
    }

    //---- enum the theme colors ----
    HWND hwnd = GetDlgItem(hwndPage, IDC_COLORCOMBO);
    ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    for (DWORD c=0; ; c++)
    {
        THEMENAMEINFO names;

        if (FAILED(EnumThemeColors(szFileName, NULL, c, &names)))
            break;

        ::SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)names.szName);
    }
    

    //---- remove choices if only 1 entry ----
    if (c < 2) 
    {
        ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
        ::EnableWindow(hwnd, FALSE);
    }
    else
    {
        ::EnableWindow(hwnd, TRUE);
        SendMessage(hwnd, CB_SETCURSEL, 0, 0);
    }

    BOOL fDummy;
    GeneralPage_OnColorSelected(hwndPage, 0, 0, 0, fDummy);

    WCHAR szBuff[MAX_PATH+1];
    HRESULT hr;

    //---- update DisplayName ----
    hr = GetThemeDocumentationProperty(szFileName, L"DisplayName", szBuff, ARRAYSIZE(szBuff));
    if (FAILED(hr))
        wcscpy(szBuff, L"<not available>");
    SetDlgItemText(hwndPage, IDC_DISPLAYNAME, szBuff);

    //---- update ToolTip ----
    hr = GetThemeDocumentationProperty(szFileName, L"Tooltip", szBuff, ARRAYSIZE(szBuff));
    if (FAILED(hr))
        wcscpy(szBuff, L"<not available>");
    SetDlgItemText(hwndPage, IDC_TOOLTIP, szBuff);

    //---- update Author ----
    hr = GetThemeDocumentationProperty(szFileName, L"author", szBuff, ARRAYSIZE(szBuff));
    if (FAILED(hr))
        wcscpy(szBuff, L"<not available>");
    SetDlgItemText(hwndPage, IDC_AUTHOR, szBuff);

    return 1;
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnColorSelected( HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{
    //---- get theme szFileName ----
    WCHAR szFileName[MAX_PATH+1];
    HWND hwndCombo = GetDlgItem(hwndPage, IDC_DIRNAME);
    int index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index == -1)
        *szFileName = 0;
    else
        ::SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)szFileName);

    //---- get the currently selected color ----
    WCHAR szColor[_MAX_PATH+1];
    HWND hwnd = GetDlgItem(hwndPage, IDC_COLORCOMBO);
    GetWindowText(hwnd, szColor, ARRAYSIZE(szColor));

    //---- get the current size name ----
    WCHAR szSizeName[MAX_PATH+1];
    HWND hwndSize = GetDlgItem(hwndPage, IDC_SIZECOMBO);
    GetWindowText(hwndSize, szSizeName, ARRAYSIZE(szSizeName));

    //---- enum the theme sizes for the specified color ----
    hwnd = GetDlgItem(hwndPage, IDC_SIZECOMBO);

    if (* szColor)      // only set size if a color is set
    {
        ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

        for (DWORD s=0; ; s++)              // enumerate sizes
        {
            THEMENAMEINFO names;

            if (FAILED(EnumThemeSizes(szFileName, szColor, s, &names)))
                break;

            ::SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)names.szName);
        }

        //---- remove choices if only 1 entry ----
        if (s < 2) 
        {
            ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
            ::EnableWindow(hwnd, FALSE);
        }
        else
        {
            ::EnableWindow(hwnd, TRUE);

            //---- try to select previously set size ----
            int index = (int)SendMessage(hwnd, CB_FINDSTRINGEXACT, 0, (LPARAM)szSizeName);
            if (index == -1)
                index = 0;
            SendMessage(hwnd, CB_SETCURSEL, index, 0);
        }
    }
    else
    {
        ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
        ::EnableWindow(hwnd, FALSE);
    }

    return 1;
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnEdit( HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{
    //---- get theme szFileName ----
    WCHAR szBuff[1024];
    WCHAR szFileName[MAX_PATH+1];

    HWND hwndCombo = GetDlgItem(hwndPage, IDC_DIRNAME);
    int index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index == -1)
        *szFileName = 0;
    else
    {
        ::SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)szBuff);
        
        WCHAR *p = wcschr(szBuff, L'.');
        if (p)
            *p = 0;     // remove file extension of DLL name

        WCHAR *pStart = wcsrchr(szBuff, L'\\');
        if (pStart)
            pStart++;
        else
            pStart = szBuff;

        //---- try for classdata file; fallback onto container file ----
        wsprintf(szFileName, TEXT("%s\\%s"), pStart, USUAL_CLASSDATA_NAME);
        if (! FileExists(szFileName))
            wsprintf(szFileName, TEXT("%s\\%s"), pStart, CONTAINER_NAME);
    }

    HANDLE hInst = CmdLineRun(L"notepad.exe", szFileName, FALSE);
    CloseHandle(hInst);

    return 1;
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnDestroy( HWND hwndPage, UINT, WPARAM wid, LPARAM, BOOL&)
{
    return 0;
}

//---------------------------------------------------------------------------
void GeneralPage_RefreshThemeName( HWND hwndPage )
{
    WCHAR szName[MAX_PATH+1];
    WCHAR szColor[MAX_PATH+1];
    WCHAR szSize[MAX_PATH+1];
    WCHAR wtitle[1024];

    BOOL fThemeActive = IsThemeActive();

    if (fThemeActive)
    {
        HRESULT hr = GetCurrentThemeName(szName, ARRAYSIZE(szName), 
            szColor, ARRAYSIZE(szColor), szSize, ARRAYSIZE(szSize));

        if (FAILED(hr))
            lstrcpy(szName, L"<unavailable>");
        else if (! *szName)
            lstrcpy_truncate(wtitle, g_szAppTitle, ARRAYSIZE(wtitle));
        else
        {
            //---- remove all dirs preceeding last backslash ----
            WCHAR *p = wcsrchr(szName, L'\\');
            if (p)                 
                wsprintf(wtitle, L"%s - %s", p+1, g_szAppTitle);
            else
                wsprintf(wtitle, L"%s - %s", szName, g_szAppTitle);
        }
    }
    else
        lstrcpy_truncate(wtitle, g_szAppTitle, ARRAYSIZE(wtitle));

    HWND hMain = GetParent(GetParent(hwndPage));
    SetWindowText(hMain, wtitle);
}

//---------------------------------------------------------------------------
BOOL GeneralPage_EnumProc( enum THEMECALLBACK tcbType, LPCWSTR pszName, 
    LPCWSTR pszDisplayName, LPCWSTR pszToolTip, int iIndex, LPARAM lParam )
{
    HWND hwnd = (HWND)lParam;
    ::SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)pszName);

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL CALLBACK GeneralPage_AddProccessNamesCB( HWND hwnd, LPARAM lParam )
{
    HWND hwndPage = (HWND)lParam;
    _ASSERTE( IsWindow(hwndPage) );

    DWORD dwProcessID = 0;
    if( !GetWindowThreadProcessId( hwnd, &dwProcessID ) )
        return TRUE;
        
    HANDLE hProcess = OpenProcess( PROCESS_VM_READ|PROCESS_QUERY_INFORMATION, FALSE, dwProcessID );
    if( NULL == hProcess )
        return TRUE;

    HMODULE rghModules[64];
    DWORD   cbRet1 = 0;
    if( EnumProcessModules( hProcess, rghModules, sizeof(rghModules), &cbRet1 ) )
    {
        for( UINT j = 0; j < (min( cbRet1, sizeof(rghModules) ))/sizeof(DWORD); j++ )
        {
            TCHAR szModule[MAX_PATH];
            if( GetModuleFileNameEx( hProcess, rghModules[j], szModule, ARRAYSIZE(szModule) ) )
            {
                CharLower( szModule );
                TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szApp[_MAX_FNAME], szExt[_MAX_EXT];
                _tsplitpath(szModule, szDrive, szDir, szApp, szExt);

                if( 0 == lstrcmp( szExt, TEXT(".exe") ) )
                {
                    if( SendDlgItemMessage( hwndPage, IDC_TARGET, CB_FINDSTRINGEXACT, -1, (LPARAM)szApp ) == CB_ERR )
                    {
                        INT_PTR iSel = (INT_PTR)SendDlgItemMessage( hwndPage, IDC_TARGET, CB_ADDSTRING, -1, (LPARAM)szApp );
                        if( 0 == lstrcmpi( szApp, g_options.szTargetApp ) )
                            SendDlgItemMessage( hwndPage, IDC_TARGET, CB_SETCURSEL, iSel, 0L );
                    }
                    
                    if( SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_FINDSTRINGEXACT, -1, (LPARAM)szApp ) == CB_ERR )
                    {
                        INT_PTR iSel = (INT_PTR)SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_ADDSTRING, -1, (LPARAM)szApp );
                        if( 0 == lstrcmpi( szApp, g_options.szTargetApp ) )
                            SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_SETCURSEL, iSel, 0L );
                    }
                }

            }
        }
    }
    CloseHandle( hProcess );
    return TRUE;
}

//---------------------------------------------------------------------------
void GeneralPage_AddProcessNamesToCombos( HWND hwndPage )
{ 
    //---- this will enum all windows (top level & all child levels) ----
    EnumChildWindows( GetDesktopWindow(), GeneralPage_AddProccessNamesCB, (LPARAM)hwndPage );
    
    if( *g_options.szTargetApp )
    {
        if( CB_ERR == SendDlgItemMessage( hwndPage, IDC_TARGET, CB_GETCURSEL, 0, 0L ) )
        {
            INT_PTR iSel = SendDlgItemMessage( hwndPage, IDC_TARGET, CB_ADDSTRING, -1, 
                                              (LPARAM)g_options.szTargetApp );
            SendDlgItemMessage( hwndPage, IDC_TARGET, CB_SETCURSEL, iSel, 0L );
        }

        if( CB_ERR == SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_GETCURSEL, 0, 0L ) )
        {
            INT_PTR iSel = SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_ADDSTRING, -1, 
                                               (LPARAM)g_options.szTargetApp );
            SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_SETCURSEL, iSel, 0L );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\main.h ===
//-------------------------------------------------------------------------//
//  main.h
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  THEMESEL_OPTIONS
typedef struct {
    DWORD cbSize;
    BOOL  fEnableFrame;        // -f to disable
    BOOL  fEnableDialog;       // -d to enable
    BOOL  fPreventInitTheming; // -p to enable
    BOOL  fExceptTarget;       // -x<appname> (to omit app)
    BOOL  fUserSwitch;
    HWND  hwndPreviewTarget;        
    TCHAR szTargetApp[MAX_PATH];                    
} THEMESEL_OPTIONS ;

extern THEMESEL_OPTIONS g_options;

HRESULT _ApplyTheme( LPCTSTR pszThemeFile, LPCWSTR pszColor, LPCWSTR pszSize, BOOL *pfDone  );

HWND GetPreviewHwnd(HWND hwndGeneralPage);
LRESULT CALLBACK GeneralPage_OnTestButton( HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnClearButton(HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnDumpTheme();

extern HWND g_hwndGeneralPage;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\pageinfo.cpp ===
#include "pch.h"
#include "resource.h"
#include "pageinfo.h"

//-------------------------------------------------------------------------//
//  Page boot; Add your page info here...
//-------------------------------------------------------------------------//

//  (1) Add CreateInstance forward:
HWND CALLBACK GeneralPage_CreateInstance( HWND hwndParent );
HWND CALLBACK StylesPage_CreateInstance( HWND hwndParent );
HWND CALLBACK SBPage_CreateInstance( HWND hwndParent );

HWND CALLBACK StaticsPage_CreateInstance( HWND hwndParent );
HWND CALLBACK ButtonsPage_CreateInstance( HWND hwndParent );
HWND CALLBACK EditPage_CreateInstance( HWND hwndParent );
HWND CALLBACK ListsPage_CreateInstance( HWND hwndParent );
HWND CALLBACK MoversPage_CreateInstance( HWND hwndParent );
HWND CALLBACK ListViewPage_CreateInstance( HWND hwndParent );
HWND CALLBACK TreeViewPage_CreateInstance( HWND hwndParent );
HWND CALLBACK PickersPage_CreateInstance( HWND hwndParent );
HWND CALLBACK BarsPage_CreateInstance( HWND hwndParent );
//-------------------------------------------------------------------------//
//  (2) Add PageInfo entry
const PAGEINFO g_rgPageInfo[] =
{
    { GeneralPage_CreateInstance, IDS_PAGE_GENERAL },
    { StylesPage_CreateInstance,  IDS_PAGE_STYLES },
    { SBPage_CreateInstance,      IDS_PAGE_SCROLLBARS },
    { StaticsPage_CreateInstance, IDS_PAGE_STATICS },
    { ButtonsPage_CreateInstance, IDS_PAGE_BUTTONS },
    { EditPage_CreateInstance, IDS_PAGE_EDIT },
    { ListsPage_CreateInstance, IDS_PAGE_LISTS },
    { MoversPage_CreateInstance, IDS_PAGE_MOVERS },
    { ListViewPage_CreateInstance, IDS_PAGE_LISTVIEW },
    { TreeViewPage_CreateInstance, IDS_PAGE_TREEVIEW },
    { PickersPage_CreateInstance, IDS_PAGE_PICKERS },
    { BarsPage_CreateInstance, IDS_PAGE_BARS },
};
const int g_cPageInfo = ARRAYSIZE(g_rgPageInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\tmutils.cpp ===
//-------------------------------------------------------------------------
//	TmUtils.cpp - theme manager shared utilities
//-------------------------------------------------------------------------
#include "stdafx.h"
#include "TmUtils.h"
#include "ThemeFile.h"
#include "loader.h"
//-------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
CMemoryDC::CMemoryDC()
{
    _hBitmap = NULL;
    _hdc = NULL;
    _hOldBitmap = NULL;
}
//-------------------------------------------------------------------------
CMemoryDC::~CMemoryDC()
{
    CloseDC();
}
//-------------------------------------------------------------------------
HRESULT CMemoryDC::OpenDC(HDC hdcSource, int iWidth, int iHeight)
{
    HRESULT hr;
    BOOL fDeskDC = FALSE;

    if (! hdcSource)
    {
        hdcSource = GetWindowDC(NULL);
        if (! hdcSource)
        {
            hr = MakeErrorLast();
            goto exit;
        }
        fDeskDC = TRUE;
    }

    _hBitmap = CreateCompatibleBitmap(hdcSource, iWidth, iHeight);
    if (! _hBitmap)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    _hdc = CreateCompatibleDC(hdcSource);
    if (! _hdc)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    _hOldBitmap = (HBITMAP) SelectObject(_hdc, _hBitmap);
    if (! _hOldBitmap)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    hr = S_OK;

exit:
    if (fDeskDC)
        ReleaseDC(NULL, hdcSource);

    if (FAILED(hr))
        CloseDC();

    return hr;
}
//-------------------------------------------------------------------------
void CMemoryDC::CloseDC()
{
    if (_hOldBitmap)
    {
        SelectObject(_hdc, _hOldBitmap);
        _hOldBitmap = NULL;
    }

    if (_hdc)
    {
        DeleteDC(_hdc);
        _hdc = NULL;
    }

    if (_hBitmap)
    {
        DeleteObject(_hBitmap);
        _hBitmap = NULL;
    }
}
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
CBitmapPixels::CBitmapPixels()
{
    _hdrBitmap = NULL;
    _buffer = NULL;
    _iWidth = 0;
    _iHeight = 0;
}
//-------------------------------------------------------------------------
CBitmapPixels::~CBitmapPixels()
{
    if (_buffer)
	    delete [] (BYTE *)_buffer;
}
//-------------------------------------------------------------------------
BYTE* CBitmapPixels::Buffer()
{
    return _buffer;
}
//-------------------------------------------------------------------------
HRESULT CBitmapPixels::OpenBitmap(HDC hdc, HBITMAP bitmap, BOOL fForceRGB32,
    DWORD OUT **pPixels, OPTIONAL OUT int *piWidth, OPTIONAL OUT int *piHeight, 
    OPTIONAL OUT int *piBytesPerPixel, OPTIONAL OUT int *piBytesPerRow, 
    OPTIONAL OUT int *piPreviousBytesPerPixel, OPTIONAL UINT cbBytesBefore)
{
    if (! pPixels)
        return MakeError32(E_INVALIDARG);

    bool fNeedRelease = false;

    if (! hdc)
    {
        hdc = GetWindowDC(NULL);
        if (! hdc)
        {
            return MakeErrorLast();
        }

        fNeedRelease = true;
    }

	BITMAP bminfo;
	
    GetObject(bitmap, sizeof(bminfo), &bminfo);
	_iWidth = bminfo.bmWidth;
	_iHeight = bminfo.bmHeight;

    int iBytesPerPixel;

    if (piPreviousBytesPerPixel != NULL)
    {
        *piPreviousBytesPerPixel = bminfo.bmBitsPixel / 8;
    }

    if ((fForceRGB32) || (bminfo.bmBitsPixel == 32)) 
        iBytesPerPixel = 4;
    else
        iBytesPerPixel = 3;
    
    int iRawBytes = _iWidth * iBytesPerPixel;
    int iBytesPerRow = 4*((iRawBytes+3)/4);

	int size = sizeof(BITMAPINFOHEADER) + _iHeight*iBytesPerRow;
	_buffer = new BYTE[size + cbBytesBefore + 100];    // avoid random GetDIBits() failures with 100 bytes padding (?)
    if (! _buffer)
        return MakeError32(E_OUTOFMEMORY);

	_hdrBitmap = (BITMAPINFOHEADER *)(_buffer + cbBytesBefore);
	memset(_hdrBitmap, 0, sizeof(BITMAPINFOHEADER));

	_hdrBitmap->biSize = sizeof(BITMAPINFOHEADER);
	_hdrBitmap->biWidth = _iWidth;
	_hdrBitmap->biHeight = _iHeight;
	_hdrBitmap->biPlanes = 1;
    _hdrBitmap->biBitCount = static_cast<WORD>(8*iBytesPerPixel);
	_hdrBitmap->biCompression = BI_RGB;     
	
#ifdef  DEBUG
    int linecnt = 
#endif
    GetDIBits(hdc, bitmap, 0, _iHeight, DIBDATA(_hdrBitmap), (BITMAPINFO *)_hdrBitmap, 
        DIB_RGB_COLORS);
    ATLASSERT(linecnt == _iHeight);

    if (fNeedRelease)
        ReleaseDC(NULL, hdc);

	*pPixels = (DWORD *)DIBDATA(_hdrBitmap);

    if (piWidth)
        *piWidth = _iWidth;
    if (piHeight)
        *piHeight = _iHeight;

    if (piBytesPerPixel)
        *piBytesPerPixel = iBytesPerPixel;
    if (piBytesPerRow)
        *piBytesPerRow = iBytesPerRow;

    return S_OK;
}
//-------------------------------------------------------------------------
void CBitmapPixels::CloseBitmap(HDC hdc, HBITMAP hBitmap)
{
    if (_hdrBitmap && _buffer)
    {
        if (hBitmap)        // rewrite bitmap
        {
            bool fNeedRelease = false;

            if (! hdc)
            {
                hdc = GetWindowDC(NULL);
                fNeedRelease = true;
            }

            SetDIBits(hdc, hBitmap, 0, _iHeight, DIBDATA(_hdrBitmap), (BITMAPINFO *)_hdrBitmap,
                DIB_RGB_COLORS);
        
            if ((fNeedRelease) && (hdc))
                ReleaseDC(NULL, hdc);
        }

	    delete [] (BYTE *)_buffer;
        _hdrBitmap = NULL;
        _buffer = NULL;
    }
}
//-------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
HRESULT LoadThemeLibrary(LPCWSTR pszThemeName, HINSTANCE *phInst)
{
    HRESULT hr = S_OK;
    HINSTANCE hInst = NULL;

    hInst = LoadLibraryEx(pszThemeName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (! hInst)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- is this version supported? ----
    void *pvVersion;
    DWORD dwVersionLength;
    hr = GetPtrToResource(hInst, L"PACKTHEM_VERSION", MAKEINTRESOURCE(1), &pvVersion, &dwVersionLength);
    if (SUCCEEDED(hr))
    {
        if (dwVersionLength != sizeof(SHORT))
            hr = E_FAIL;
        else
        {
            SHORT sVersionNum = *(SHORT *)pvVersion;
            if (sVersionNum != PACKTHEM_VERSION)
                hr = E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    *phInst = hInst;

exit:
    if (FAILED(hr))
    {
        if (hInst)
            FreeLibrary(hInst);
    }

    return hr;
}
//---------------------------------------------------------------------------
LPCWSTR ThemeString(CUxThemeFile *pThemeFile, int iOffset)
{
    LPCWSTR p = L"";

    if ((pThemeFile) && (pThemeFile->_pbThemeData) && (iOffset > 0))
    {
        p = (LPCWSTR) (pThemeFile->_pbThemeData + iOffset);
    }

    return p;
}
//---------------------------------------------------------------------------
int GetLoadIdFromTheme(CUxThemeFile *pThemeFile)
{
    int iLoadId = 0;

    if (pThemeFile)
    {
        THEMEHDR *hdr = (THEMEHDR *)pThemeFile->_pbThemeData;
        iLoadId = hdr->iLoadId;
    }

    return iLoadId;
}
//---------------------------------------------------------------------------
HRESULT GetThemeNameId(CUxThemeFile *pThemeFile, LPWSTR pszFileNameBuff, UINT cchFileNameBuff,
    LPWSTR pszColorParam, UINT cchColorParam, LPWSTR pszSizeParam, UINT cchSizeParam, int *piSysMetricsOffset, LANGID *pwLangID)
{
    HRESULT hr = S_OK;
    THEMEHDR *hdr = (THEMEHDR *)pThemeFile->_pbThemeData;

    if (piSysMetricsOffset)
        *piSysMetricsOffset = hdr->iSysMetricsOffset;

    if (pszFileNameBuff)
    {
        hr = hr_lstrcpy(pszFileNameBuff, ThemeString(pThemeFile, hdr->iDllNameOffset), cchFileNameBuff);
    }

    if (SUCCEEDED(hr) && pszColorParam)
    {
        hr = hr_lstrcpy(pszColorParam, ThemeString(pThemeFile, hdr->iColorParamOffset), cchColorParam);
    }

    if (SUCCEEDED(hr) && pszSizeParam)
    {
        hr = hr_lstrcpy(pszSizeParam, ThemeString(pThemeFile, hdr->iSizeParamOffset), cchSizeParam);
    }

    if (SUCCEEDED(hr) && pwLangID)
        *pwLangID = (LANGID) hdr->dwLangID;

    return hr;
}
//---------------------------------------------------------------------------
BOOL ThemeMatch (CUxThemeFile *pThemeFile, LPCWSTR pszThemeName, LPCWSTR pszColorName, LPCWSTR pszSizeName, LANGID wLangID)
{
    WCHAR   szThemeFileName[MAX_PATH];
    WCHAR   szColorParam[MAX_PATH];
    WCHAR   szSizeParam[MAX_PATH];
    LANGID  wThemeLangID = 0;
    bool    bLangMatch = true;

    HRESULT hr = GetThemeNameId(pThemeFile, 
        szThemeFileName, ARRAYSIZE(szThemeFileName), 
        szColorParam, ARRAYSIZE(szColorParam),
        szSizeParam, ARRAYSIZE(szSizeParam), NULL, &wThemeLangID);

    if (wLangID != 0 && ((wThemeLangID != wLangID) || (wLangID != GetUserDefaultUILanguage())))
    {
        Log(LOG_TMLOAD, L"UxTheme: Reloading theme because of language change.");
        Log(LOG_TMLOAD, L"UxTheme: User LangID=0x%x, current theme=0x%x, LastUserLangID=0x%x", GetUserDefaultUILanguage(), wThemeLangID, wLangID);
        bLangMatch = false;
    }
    
    return(SUCCEEDED(hr) &&
           (lstrcmpiW(pszThemeName, szThemeFileName) == 0) &&
           (lstrcmpiW(pszColorName, szColorParam) == 0) &&
           (lstrcmpiW(pszSizeName, szSizeParam) == 0) &&
           bLangMatch);
}
//---------------------------------------------------------------------------
HRESULT GetColorSchemeIndex(HINSTANCE hInst, LPCWSTR pszColor, int *piIndex)
{
    HRESULT hr;
    WCHAR szColor[_MAX_PATH+1];

    for (int i=0; i < 1000; i++)
    {
        hr = GetResString(hInst, L"COLORNAMES", i, szColor, ARRAYSIZE(szColor));
        if (FAILED(hr))
            break;
        
        if (lstrcmpi(pszColor, szColor)==0)
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(ERROR_NOT_FOUND);      // not found
}
//---------------------------------------------------------------------------
HRESULT GetSizeIndex(HINSTANCE hInst, LPCWSTR pszSize, int *piIndex)
{
    HRESULT hr;
    WCHAR szSize[_MAX_PATH+1];

    for (int i=0; i < 1000; i++)
    {
        hr = GetResString(hInst, L"SIZENAMES", i, szSize, ARRAYSIZE(szSize));
        if (FAILED(hr))
            break;

        if (lstrcmpi(pszSize, szSize)==0)
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(ERROR_NOT_FOUND);      // not found
}
//---------------------------------------------------------------------------
HRESULT FindComboData(HINSTANCE hDll, COLORSIZECOMBOS **ppCombos)
{
    HRSRC hRsc = FindResource(hDll, L"COMBO", L"COMBODATA");
    if (! hRsc)
        return MakeErrorLast();

    HGLOBAL hGlobal = LoadResource(hDll, hRsc);
    if (! hGlobal)
        return MakeErrorLast();

    *ppCombos = (COLORSIZECOMBOS *)LockResource(hGlobal);
    if (! *ppCombos)
        return MakeErrorLast();

    return S_OK;
}
//---------------------------------------------------------------------------
BOOL FormatLocalMsg(HINSTANCE hInst, int iStringNum, 
    LPWSTR pszMessageBuff, DWORD dwMaxMessageChars, DWORD *pdwParams, TMERRINFO *pErrInfo)
{
    BOOL fGotMsg = FALSE;
    WCHAR szBuff[_MAX_PATH+1];
    WCHAR *p;

    //----- get string from string table ----
    if (LoadString(hInst, iStringNum, szBuff, ARRAYSIZE(szBuff)))
    {
        //---- repl %1 or %2 with %s ----
        p = szBuff;
        while (*p)
        {
            if (*p == '%')
            {
                p++;
                if ((*p == '1') || (*p == '2'))
                    *p = 's';
                p++;
            }
            else 
                p++;
        }

        int len = lstrlen(szBuff);
        if (len)
        {
            wsprintf(pszMessageBuff, szBuff, pErrInfo->szMsgParam1, pErrInfo->szMsgParam2);
            fGotMsg = TRUE;
        }
    }

    return fGotMsg;
}
//---------------------------------------------------------------------------
HRESULT _FormatParseMessage(TMERRINFO *pErrInfo,
    OUT LPWSTR pszMessageBuff, DWORD dwMaxMessageChars)
{
    LogEntry(L"_FormatParseMessage");

    HRESULT hr = S_OK;

    DWORD dwParams[] = {PtrToInt(pErrInfo->szMsgParam1), PtrToInt(pErrInfo->szMsgParam2)};
    DWORD dwCode = pErrInfo->dwParseErrCode;
    BOOL fGotMsg = FALSE;

    int iStringNum = SCODE_CODE(dwCode);

    //---- get process name (see if we are "packthem.exe" ----
    WCHAR szPath[MAX_PATH];
    if (! GetModuleFileNameW( NULL, szPath, ARRAYSIZE(szPath) ))
        goto exit;

    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBase[_MAX_FNAME], szExt[_MAX_EXT];
    _wsplitpath(szPath, szDrive, szDir, szBase, szExt);

    if (lstrcmpi(szBase, L"packthem")==0)       // give packthem priority
    {
        fGotMsg = FormatLocalMsg(GetModuleHandle(NULL), iStringNum, 
            pszMessageBuff, dwMaxMessageChars, dwParams, pErrInfo);
    }

    if (! fGotMsg)      // try normal route: uxtheme.dll
    {
        HINSTANCE hInst = LoadLibrary(L"uxtheme.dll");
        if (! hInst)
        {
            Log(LOG_ALWAYS, L"_FormatParseMessage: Could not load uxtheme.dll");
            hr = E_FAIL;
            goto exit;
        }

        fGotMsg = FormatLocalMsg(hInst, iStringNum, 
            pszMessageBuff, dwMaxMessageChars, dwParams, pErrInfo);
        FreeLibrary(hInst);
    }

    if (! fGotMsg)
        hr = MakeErrorLast();

exit:
    LogExit(L"_FormatParseMessage");
    return hr;
}
//---------------------------------------------------------------------------
HRESULT _GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo)
{
    LogEntry(L"_GetThemeParseErrorInfo");

    HRESULT hr = S_OK;

    if (pInfo->dwSize != sizeof(PARSE_ERROR_INFO))        // unsupported size
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    TMERRINFO *pErrInfo = GetParseErrorInfo(TRUE);
    if (! pErrInfo)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    //---- convert code into msg using param strings ----
    hr = _FormatParseMessage(pErrInfo, pInfo->szMsg, ARRAYSIZE(pInfo->szMsg));
    if (FAILED(hr))
        goto exit;

    //---- transfer the other info ----
    pInfo->dwParseErrCode = pErrInfo->dwParseErrCode;
    pInfo->iLineNum = pErrInfo->iLineNum;

    lstrcpy_truncate(pInfo->szFileName, pErrInfo->szFileName, ARRAYSIZE(pInfo->szFileName));
    lstrcpy_truncate(pInfo->szSourceLine, pErrInfo->szSourceLine, ARRAYSIZE(pInfo->szSourceLine));

exit:
    LogExit(L"_GetThemeParseErrorInfo");
    return hr;
}
//---------------------------------------------------------------------------
HRESULT _ParseThemeIniFile(LPCWSTR pszFileName,  
    DWORD dwParseFlags, OPTIONAL THEMEENUMPROC pfnCallBack, OPTIONAL LPARAM lparam) 
{
    LogEntry(L"ParseThemeIniFile");
    HRESULT hr;

    CThemeParser *pParser = new CThemeParser;
    if (! pParser)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    hr = pParser->ParseThemeFile(pszFileName, NULL, NULL, pfnCallBack, lparam, 
        dwParseFlags);

    delete pParser;

exit:
    LogExit(L"ParseThemeIniFile");
    return hr; 
}
//---------------------------------------------------------------------------
BOOL ThemeLibStartUp(BOOL fThreadAttach)
{
    BOOL fInit = FALSE;

    if (fThreadAttach)
    {
        //---- nothing to do here ----
    }
    else        // process
    {
        _tls_ErrorInfoIndex = TlsAlloc();
        if (_tls_ErrorInfoIndex == (DWORD)-1)
            goto exit;

        if (! LogStartUp())
            goto exit;
        
        if (! UtilsStartUp())
            goto exit;
    }
    fInit = TRUE;

exit:
    return fInit;
}
//---------------------------------------------------------------------------
BOOL ThemeLibShutDown(BOOL fThreadDetach)
{
    if (fThreadDetach)
    {
        //---- destroy the thread-local Error Info ----
        TMERRINFO * ei = GetParseErrorInfo(FALSE);
        if (ei)
        {
            TlsSetValue(_tls_ErrorInfoIndex, NULL);
            delete ei;
        }
    }
    else            // process
    {
        UtilsShutDown();
        LogShutDown();

        if (_tls_ErrorInfoIndex != (DWORD)-1)
        {
            TlsFree(_tls_ErrorInfoIndex);
            _tls_ErrorInfoIndex = (DWORD)-1;
        }
    }

    return TRUE;
}
//---------------------------------------------------------------------------
HRESULT GetThemeSizeId(int iSysSizeId, int *piThemeSizeId)
{
    HRESULT hr = S_OK;
    
    *piThemeSizeId = 0;

    switch (iSysSizeId)
    {
        case SM_CXSIZEFRAME:
            *piThemeSizeId = TMT_SIZINGBORDERWIDTH;
            break;

        case SM_CYSIZEFRAME:
            *piThemeSizeId = TMT_SIZINGBORDERWIDTH;
            break;

        case SM_CXVSCROLL:
            *piThemeSizeId = TMT_SCROLLBARWIDTH;
            break;

        case SM_CYHSCROLL:
            *piThemeSizeId = TMT_SCROLLBARHEIGHT;
            break;

        case SM_CXSIZE:
            *piThemeSizeId = TMT_CAPTIONBARWIDTH;
            break;

        case SM_CYSIZE:
            *piThemeSizeId = TMT_CAPTIONBARHEIGHT;
            break;

        case SM_CXSMSIZE:
            *piThemeSizeId = TMT_SMCAPTIONBARWIDTH;
            break;

        case SM_CYSMSIZE:
            *piThemeSizeId = TMT_SMCAPTIONBARHEIGHT;
            break;

        case SM_CXMENUSIZE:
            *piThemeSizeId = TMT_MENUBARWIDTH;
            break;

        case SM_CYMENUSIZE:
            *piThemeSizeId = TMT_MENUBARHEIGHT;
            break;

        default:
            hr = MakeError32(E_INVALIDARG);
            break;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT _EnumThemeSizes(HINSTANCE hInst, LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, OUT THEMENAMEINFO *ptn, BOOL fCheckColorDepth)
{
    HRESULT hr;

    COLORSIZECOMBOS *combos;
    hr = FindComboData(hInst, &combos);
    if (FAILED(hr))
        goto exit;

    int iMinColor,  iMaxColor;
    iMinColor = 0;
    iMaxColor = combos->cColorSchemes-1;

    if (pszColorScheme)       // translate "pszColorScheme" into a color number
    {
        int index;

        hr = GetColorSchemeIndex(hInst, pszColorScheme, &index);
        if (FAILED(hr))
            goto exit;
        
        //---- restrict our search to just this color ----
        iMinColor = index;
        iMaxColor = index;
    }

    int s, c;
    DWORD dwSizeNum;
    dwSizeNum = 0;
    BOOL gotall;
    gotall = FALSE;

    DWORD dwCurMinDepth = 0;
        
    if (fCheckColorDepth)
    {
        dwCurMinDepth = MinimumDisplayColorDepth();
    }

    for (s=0; s < combos->cSizes; s++)
    {
        BOOL fFoundOne = FALSE;

        for (c=iMinColor; c <= iMaxColor; c++)
        {
            if (COMBOENTRY(combos, c, s) != -1)
            {
                fFoundOne = TRUE;
                break;
            }
        }

        if (fFoundOne && (!fCheckColorDepth || CheckMinColorDepth(hInst, dwCurMinDepth, COMBOENTRY(combos, c, s))))
        {
            if (dwSizeNum++ == dwSizeIndex)
            {
                hr = GetResString(hInst, L"SIZENAMES", s, ptn->szName, ARRAYSIZE(ptn->szName));
                if (FAILED(hr))
                    *ptn->szName = 0;
            
                if (! LoadString(hInst, s+RES_BASENUM_SIZEDISPLAYS, ptn->szDisplayName, ARRAYSIZE(ptn->szDisplayName)))
                    *ptn->szDisplayName = 0;

                if (! LoadString(hInst, s+RES_BASENUM_SIZETOOLTIPS, ptn->szToolTip, ARRAYSIZE(ptn->szToolTip)))
                    *ptn->szToolTip = 0;
        
                gotall = TRUE;
                break;
            }
        }
    }

    if ((SUCCEEDED(hr)) && (! gotall))
        hr = MakeError32(ERROR_NOT_FOUND);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT _EnumThemeColors(HINSTANCE hInst, LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, OUT THEMENAMEINFO *ptn, BOOL fCheckColorDepth)
{
    HRESULT hr;

    COLORSIZECOMBOS *combos;
    hr = FindComboData(hInst, &combos);
    if (FAILED(hr))
        goto exit;

    int iMinSize,  iMaxSize;
    iMinSize = 0;
    iMaxSize = combos->cSizes-1;

    if (pszSizeName)       // translate "pszSizeName" into a size number
    {
        int index;

        hr = GetSizeIndex(hInst, pszSizeName, &index);
        if (FAILED(hr))
            goto exit;

        //---- restrict our search to just this size ----
        iMinSize = index;
        iMaxSize = index;
    }

    int s, c;
    DWORD dwColorNum;
    dwColorNum = 0;

    BOOL gotall;
    gotall = FALSE;

    DWORD dwCurMinDepth = 0;
        
    if (fCheckColorDepth)
    {
        dwCurMinDepth = MinimumDisplayColorDepth();
    }

    for (c=0; c < combos->cColorSchemes; c++)
    {
        BOOL fFoundOne = FALSE;

        for (s=iMinSize; s <= iMaxSize; s++)
        {
            if (COMBOENTRY(combos, c, s) != -1)
            {
                fFoundOne = TRUE;
                break;
            }
        }

        if (fFoundOne && (!fCheckColorDepth || CheckMinColorDepth(hInst, dwCurMinDepth, COMBOENTRY(combos, c, s))))
        {
            if (dwColorNum++ == dwColorIndex)
            {
                hr = GetResString(hInst, L"COLORNAMES", c, ptn->szName, ARRAYSIZE(ptn->szName));
                if (FAILED(hr))
                    *ptn->szName = 0;

                if (! LoadString(hInst, c+RES_BASENUM_COLORDISPLAYS, ptn->szDisplayName, ARRAYSIZE(ptn->szDisplayName)))
                    *ptn->szDisplayName = 0;

                if (! LoadString(hInst, c+RES_BASENUM_COLORTOOLTIPS, ptn->szToolTip, ARRAYSIZE(ptn->szToolTip)))
                    *ptn->szToolTip = 0;

                gotall = true;
                break;
            }
        }
    }

    if ((SUCCEEDED(hr)) && (! gotall))
        hr = MakeError32(ERROR_NOT_FOUND);

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\utils.cpp ===
//---------------------------------------------------------------------------
//    utils.cpp - theme code utilities (shared in "inc" directory)
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <time.h>
#include "utils.h"
#include "cfile.h"
#include "stringtable.h"
//---------------------------------------------------------------------------
HINSTANCE hinstUxCtrl = NULL;               // protected by _csUtils

IMAGE_DRAWPROC ImageList_DrawProc = NULL;       // protected by _csUtils
IMAGE_LOADPROC ImageList_LoadProc = NULL;       // protected by _csUtils
PFNDRAWSHADOWTEXT CCDrawShadowText = NULL;
IMAGE_DESTROYPROC ImageList_DestroyProc = NULL; // protected by _csUtils

int g_iScreenDpi = THEME_DPI;               // only initialized 
//---------------------------------------------------------------------------
CRITICAL_SECTION _csUtils = {0};            // unprotected (set during init)
//---------------------------------------------------------------------------
#define __ascii_towlower(c)     ( (((c) >= L'A') && ((c) <= L'Z')) ? ((c) - L'A' + L'a') : (c) )

// A string compare that explicitely only works on english characters
// This avoids locale problems like Hungarian, without a performance hit.
// NOTE: Intended for theme schema properties. Theme file names, colors styles and size styles 
// shouldn't be passed to this function, nor any display name.
int AsciiStrCmpI(const WCHAR *dst, const WCHAR *src)
{
    WCHAR f,l;

    if (dst == NULL)
    {
        return src == NULL ? 0 : -1;
    }
    if (src == NULL)
    {
        return 1;
    }

    do {
#ifdef DEBUG
        if (*dst > 127 || *src > 127)
        {
            Log(LOG_ERROR, L"AsciiStrCmpI: Non-Ascii comparing %s and %s", dst, src);
        }
#endif
        f = (WCHAR)__ascii_towlower(*dst);
        l = (WCHAR)__ascii_towlower(*src);
        dst++;
        src++;
    } while ( (f) && (f == l) );

    return (int)(f - l);
}
//---------------------------------------------------------------------------
BOOL lstrtoken(LPWSTR psz, WCHAR wch)
{
    ATLASSERT(psz != NULL);

    LPWSTR p = psz;
    while (*p)
    {
        if (*p == wch)
        {
            *p = 0;
            return TRUE;
        }
        p = CharNextW(p);
    }
    return FALSE;
}
//---------------------------------------------------------------------------
BOOL FileExists(LPCWSTR pszFileName)
{
    DWORD dwMask = GetFileAttributes(pszFileName);
    return (dwMask != 0xffffffff);
}
//---------------------------------------------------------------------------
BOOL UtilsStartUp()
{
    InitializeCriticalSection(&_csUtils);

    hinstUxCtrl = NULL;

    //---- set screen dpi (per session) ----
    HDC hdc = GetWindowDC(NULL);
    if (hdc)
    {
        g_iScreenDpi = GetDeviceCaps(hdc, LOGPIXELSX);
        ReleaseDC(NULL, hdc);
    }

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL UtilsShutDown()
{
    DeleteCriticalSection(&_csUtils);

    if (hinstUxCtrl)
    {
        FreeLibrary(hinstUxCtrl);
        hinstUxCtrl = NULL;
    }

    return FALSE;
}
//---------------------------------------------------------------------------
void ErrorBox(LPCSTR pszFormat, ...)
{
    va_list args;
    va_start(args, pszFormat);

    char szMsgBuff[2048];

    wvsprintfA(szMsgBuff, pszFormat, args);
    MessageBoxA(NULL, szMsgBuff, "Error", MB_OK);

    va_end(args);
}
//---------------------------------------------------------------------------
HANDLE CmdLineRun(LPCTSTR pszExeName, LPCTSTR pszParams, BOOL fHide)
{
    STARTUPINFO si;
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;       // don't mess with our cursor

    if (fHide)
    {
        si.dwFlags |= STARTF_USESHOWWINDOW;         // hide window
        si.wShowWindow = SW_HIDE;
    }

    PROCESS_INFORMATION pi;
    TCHAR pszExeBuff[_MAX_PATH];
    TCHAR pszParmsBuff[_MAX_PATH];

    // Copy to buffers to avoid AVs
    if (pszParams)
    {
        pszParmsBuff[0] = L'"';

        // -1 for trailing NULL, -2 for quotation marks, -1 for space between EXE and args
        HRESULT hr = hr_lstrcpy(pszParmsBuff+1, pszExeName, ARRAYSIZE(pszParmsBuff) - 4);
        if (FAILED(hr))
            return NULL;

        int cchUsed = lstrlen(pszParmsBuff);
        pszParmsBuff[cchUsed++] = L'"'; // closing quotation mark
        pszParmsBuff[cchUsed++] = L' '; // We need a space before the cmd line
        hr = hr_lstrcpy(pszParmsBuff + cchUsed, pszParams, ARRAYSIZE(pszParmsBuff) - cchUsed - 1);
        if (FAILED(hr))
            return NULL;
    }

    LPTSTR lpFilePart;

    if (0 == SearchPath(NULL, pszExeName, NULL, ARRAYSIZE(pszExeBuff), pszExeBuff, &lpFilePart))
        return NULL;

    BOOL bSuccess = CreateProcess(pszExeBuff, pszParams ? pszParmsBuff : NULL, NULL, NULL,
        FALSE, 0, NULL, NULL, &si, &pi);
    if (! bSuccess)
        return NULL;

    return pi.hProcess;
}
//---------------------------------------------------------------------------
HRESULT SyncCmdLineRun(LPCTSTR pszExeName, LPCTSTR pszParams)
{
    HANDLE hInst;

    hInst = CmdLineRun(pszExeName, pszParams);
    if (! hInst)
    {
        Log(LOG_ALWAYS, L"CmdLineRun failed to create hInst.  Cmd=%s", pszExeName);
        return MakeError32(E_FAIL);      // could not run program
    }

    HRESULT hr = S_OK;

    //---- wait for packthem to terminate ----
    DWORD dwVal;
    dwVal = WaitForSingleObject(hInst, INFINITE);

    if (dwVal != WAIT_OBJECT_0)
    {
        Log(LOG_ERROR, L"CmdLineRun timed out.  Cmd=%s", pszExeName);
        hr = MakeError32(E_FAIL);            // timed out
        goto exit;
    }

    DWORD dwExitCode;
    if (! GetExitCodeProcess(hInst, &dwExitCode))
    {
        Log(LOG_ALWAYS, L"CmdLineRun failed to get exit code.  Cmd=%s", pszExeName);
        hr = MakeError32(E_FAIL);          // could not get exit code
        goto exit;
    }

    if (dwExitCode)
    {
        Log(LOG_ALWAYS, L"CmdLineRun returned error.  Cmd=%s, ExitCode=%d", pszExeName, dwExitCode);
        hr = MakeError32(E_FAIL);          // did not complete successfully
        goto exit;
    }

exit:

    CloseHandle(hInst);
    return hr;
}
//---------------------------------------------------------------------------
void ForceDesktopRepaint()
{
    //---- keep for now (some non-subclassed controls don't repaint otherwise) ----
    InvalidateRect(NULL, NULL, TRUE);   // all windows
}
//---------------------------------------------------------------------------
//  color conversion routines copied from comdlg\color2.c
//---------------------------------------------------------------------------
#define HLSMAX  240
#define RGBMAX  255
#define UNDEFINED (HLSMAX * 2 / 3)
//---------------------------------------------------------------------------
void RGBtoHLS(COLORREF rgb, WORD *pwHue, WORD *pwLum, WORD *pwSat)
{
    WORD R, G, B;                 // input RGB values
    WORD cMax,cMin;               // max and min RGB values
    WORD cSum,cDif;
    SHORT Rdelta, Gdelta, Bdelta; // intermediate value: % of spread from max

    WORD bHue, bLum, bSat;
    //
    //  get R, G, and B out of DWORD.
    //
    R = GetRValue(rgb);
    G = GetGValue(rgb);
    B = GetBValue(rgb);

    //
    //  Calculate lightness.
    //
    cMax = max(max(R, G), B);
    cMin = min(min(R, G), B);
    cSum = cMax + cMin;
    bLum = (WORD)(((cSum * (DWORD)HLSMAX) + RGBMAX) / (2 * RGBMAX));

    cDif = cMax - cMin;
    if (!cDif)
    {
        //
        //  r = g = b --> Achromatic case.
        //
        bSat = 0;                         // saturation
        bHue = UNDEFINED;                 // hue
    }
    else
    {
        //
        //  Chromatic case.
        //

        //
        //  Saturation.
        //
        //  Note: Division by cSum is not a problem, as cSum can only
        //        be 0 if the RGB value is 0L, and that is achromatic.
        //
        if (bLum <= (HLSMAX / 2))
        {
            bSat = (WORD)(((cDif * (DWORD) HLSMAX) + (cSum / 2) ) / cSum);
        }
        else
        {
            bSat = (WORD)((DWORD)((cDif * (DWORD)HLSMAX) +
                               (DWORD)((2 * RGBMAX - cSum) / 2)) /
                       (2 * RGBMAX - cSum));
        }

        //
        //  Hue.
        //
        Rdelta = (SHORT)((((cMax - R) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);
        Gdelta = (SHORT)((((cMax - G) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);
        Bdelta = (SHORT)((((cMax - B) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);

        if (R == cMax)
        {
            bHue = Bdelta - Gdelta;
        }
        else if (G == cMax)
        {
            bHue = (WORD)((HLSMAX / 3) + Rdelta - Bdelta);
        }
        else  // (B == cMax)
        {
            bHue = (WORD)(((2 * HLSMAX) / 3) + Gdelta - Rdelta);
        }

        if ((short)bHue < 0)
        {
            //
            //  This can occur when R == cMax and G is > B.
            //
            bHue += HLSMAX;
        }
        if (bHue >= HLSMAX)
        {
            bHue -= HLSMAX;
        }
    }

    if (pwHue)
        *pwHue = bHue;

    if (pwLum)
        *pwLum = bLum;

    if (pwSat)
        *pwSat = bSat;
}
//---------------------------------------------------------------------------
WORD HueToRGB(WORD n1, WORD n2, WORD hue)
{
    if (hue >= HLSMAX)
    {
        hue -= HLSMAX;
    }

    //
    //  Return r, g, or b value from this tridrant.
    //
    if (hue < (HLSMAX / 6))
    {
        return ((WORD)(n1 + (((n2 - n1) * hue + (HLSMAX / 12)) / (HLSMAX / 6))));
    }
    if (hue < (HLSMAX/2))
    {
        return (n2);
    }
    if (hue < ((HLSMAX*2)/3))
    {
        return ((WORD)(n1 + (((n2 - n1) * (((HLSMAX * 2) / 3) - hue) +
                       (HLSMAX / 12)) / (HLSMAX / 6))));
    }
    else
    {
        return (n1);
    }
}
//---------------------------------------------------------------------------
DWORD HLStoRGB(WORD hue, WORD lum, WORD sat)
{
    WORD R, G, B;                      // RGB component values
    WORD Magic1, Magic2;               // calculated magic numbers

    if (sat == 0)
    {
        //
        //  Achromatic case.
        //
        R = G = B = (WORD)((lum * RGBMAX) / HLSMAX);
    }
    else
    {
        //
        //  Chromatic case
        //

        //
        //  Set up magic numbers.
        //
        if (lum <= (HLSMAX / 2))
        {
            Magic2 = (WORD)((lum * ((DWORD)HLSMAX + sat) + (HLSMAX / 2)) / HLSMAX);
        }
        else
        {
            Magic2 = lum + sat -
                     (WORD)(((lum * sat) + (DWORD)(HLSMAX / 2)) / HLSMAX);
        }
        Magic1 = (WORD)(2 * lum - Magic2);

        //
        //  Get RGB, change units from HLSMAX to RGBMAX.
        //
        R = (WORD)(((HueToRGB(Magic1, Magic2, (WORD)(hue + (HLSMAX / 3))) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
        G = (WORD)(((HueToRGB(Magic1, Magic2, hue) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
        B = (WORD)(((HueToRGB(Magic1, Magic2, (WORD)(hue - (HLSMAX / 3))) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
    }
    return (RGB(R, G, B));
}
//---------------------------------------------------------------------------
BOOL GetMyExePath(LPWSTR pszNameBuff)
{
    //---- extract the dir that calling program is running in ----
    WCHAR filename[_MAX_PATH+1];
    GetModuleFileName(NULL, filename, ARRAYSIZE(filename));

    WCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];
    _wsplitpath(filename, drive, dir, fname, ext);

    wsprintf(pszNameBuff, L"%s%psz", drive, dir);

    return TRUE;
}
//---------------------------------------------------------------------------
HRESULT SetFileExt(LPCWSTR pszOrigName, LPCWSTR pszNewExt, OUT LPWSTR pszNewNameBuff)
{
    WCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];
    _wsplitpath(pszOrigName, drive, dir, fname, ext);
    _wmakepath(pszNewNameBuff, drive, dir, fname, pszNewExt);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT GetPtrToResource(HINSTANCE hInst, LPCWSTR pszResType, LPCWSTR pszResName,
    OUT void **ppBytes, OPTIONAL OUT DWORD *pdwBytes)
{
    HRSRC hRsc = FindResource(hInst, pszResName, pszResType);
    if (! hRsc)
        return MakeErrorLast();

    DWORD dwBytes = SizeofResource(hInst, hRsc);
    if (! dwBytes)
        return MakeErrorLast();

    HGLOBAL hGlobal = LoadResource(hInst, hRsc);
    if (! hGlobal)
        return MakeErrorLast();

    void *v = (WCHAR *)LockResource(hGlobal);
    if (! v)
        return MakeErrorLast();

    *ppBytes = v;

    if (pdwBytes)
        *pdwBytes = dwBytes;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT GetResString(HINSTANCE hInst, LPCWSTR pszResType, int id, LPWSTR pszBuff,
    DWORD dwMaxBuffChars)
{
    WCHAR *p;

    HRESULT hr = GetPtrToResource(hInst, pszResType, MAKEINTRESOURCE(1), (void **)&p);
    if (SUCCEEDED(hr))
    {
        while ((*p) && (id))
        {
            p += (1 + lstrlen(p));
            id--;
        }

        if (*p)
        {
            hr = hr_lstrcpy(pszBuff, p, dwMaxBuffChars);
        }
        else
        {
            hr = MakeError32(ERROR_NOT_FOUND);
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT AllocateTextResource(HINSTANCE hInst, LPCWSTR pszResName, WCHAR **ppszText)
{
    WCHAR *p, *q;
    DWORD dwBytes, dwChars;
    HRESULT hr;

    //---- allocate so that we can add a NULL at the end of the file string ----

    hr = GetPtrToResource(hInst, L"TEXTFILE", pszResName, (void **)&p, &dwBytes);
    if (FAILED(hr))
        goto exit;

    dwChars = (dwBytes+1)/2;

    if ((dwChars) && (p[0] == 0xfeff))       // remove UNICODE hdr
    {
        dwChars--;
        p++;
    }

    q = new WCHAR[dwChars+1];
    if (!q)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    memcpy(q, p, dwChars*sizeof(WCHAR));
    q[dwChars] = 0;

    *ppszText = q;

exit:
    return hr;
}
//---------------------------------------------------------------------------
void ReplChar(LPWSTR pszBuff, WCHAR wOldVal, WCHAR wNewVal)
{
    WCHAR *p = pszBuff;

    while (*p)
    {
        if (*p == wOldVal)
            *p = wNewVal;
        p++;
    }
}
//---------------------------------------------------------------------------
WCHAR *StringDup(LPCWSTR pszOrig)
{
    int len = lstrlen(pszOrig);

    WCHAR *str = new WCHAR[1+len];
    if (str)
        lstrcpy(str, pszOrig);

    return str;
}
//---------------------------------------------------------------------------
void ApplyStringProp(HWND hwnd, LPCWSTR pszStringVal, ATOM atom)
{
    if (hwnd)
    {
        //---- remove previous value ----
        ATOM atomStringVal = (ATOM)GetProp(hwnd, (LPCTSTR)atom);
        if (atomStringVal)
        {
            DeleteAtom(atomStringVal);      // decrement refcnt
            RemoveProp(hwnd, (LPCTSTR)atom);
        }

        //---- add new string as an atom ----
        if (pszStringVal)
        {
            //---- if string is empty, change it since AddAtom() doesn't ----
            //---- support empty strings (returns NULL) ----
            if (! *pszStringVal)
                pszStringVal = L"$";       // should never compare equal to a class name

            atomStringVal = AddAtom(pszStringVal);
            if (atomStringVal)
                SetProp(hwnd, (LPCTSTR)atom, (void *)atomStringVal);
        }
    }
}
//---------------------------------------------------------------------------
HRESULT EnsureUxCtrlLoaded()
{
    CAutoCS cs(&_csUtils);

    if (! hinstUxCtrl)
    {
        TCHAR szPath[MAX_PATH];
        GetModuleFileName(GetModuleHandle(TEXT("UxTheme.dll")), szPath, ARRAYSIZE(szPath));

        ACTCTX act = {0};
        act.cbSize = sizeof(act);
        act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpResourceName = MAKEINTRESOURCE(1);
        act.lpSource = szPath;
        HANDLE hActCtx = CreateActCtx(&act);
        ULONG_PTR ulCookie = 0;
        if (hActCtx != INVALID_HANDLE_VALUE)
            ActivateActCtx(hActCtx, &ulCookie);

        hinstUxCtrl = LoadLibrary(L"comctl32.dll");

        if (ulCookie)
            DeactivateActCtx(0, ulCookie);

        if (hActCtx != INVALID_HANDLE_VALUE)
            ReleaseActCtx(hActCtx);
    }

    if ((hinstUxCtrl) && (! ImageList_DrawProc))
    {
        ImageList_DrawProc = (IMAGE_DRAWPROC)GetProcAddress(hinstUxCtrl, "ImageList_DrawIndirect");
#if 1           // testing DrawThemeIcon()
        ImageList_LoadProc = (IMAGE_LOADPROC)GetProcAddress(hinstUxCtrl, "ImageList_LoadImage");
        ImageList_DestroyProc = (IMAGE_DESTROYPROC)GetProcAddress(hinstUxCtrl, "ImageList_Destroy");
#endif

        CCDrawShadowText = (PFNDRAWSHADOWTEXT)GetProcAddress(hinstUxCtrl, "DrawShadowText");
    }

    if ((ImageList_DrawProc) && (CCDrawShadowText))
        return S_OK;

    return MakeError32(E_FAIL);      // something went wrong
}
//---------------------------------------------------------------------------
BOOL IsUnicode(LPCSTR pszBuff, int *piUnicodeStartOffset)
{
    int iOffset = 0;
    BOOL fUnicode = FALSE;

    if ((pszBuff[0] == 0xff) && (pszBuff[1] == 0xfe))       // unicode marker
    {
        iOffset = 2;
        fUnicode = TRUE;
    }
    else if (! pszBuff[1])
    {
        // this check works well for .ini files because of the limited
        // legal chars it can start with
        fUnicode = TRUE;
    }

    if (piUnicodeStartOffset)
        *piUnicodeStartOffset = iOffset;

    return fUnicode;
}
//---------------------------------------------------------------------------
HRESULT AnsiToUnicode(LPSTR pszSource, LPWSTR pszDest, DWORD dwMaxDestChars)
{
    int len = 1 + static_cast<int>(strlen(pszSource));

    int retval = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszSource, len,
        pszDest, dwMaxDestChars);
    if (! retval)
        return MakeErrorLast();

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT AllocateTextFile(LPCWSTR szFileName, OUT LPWSTR *ppszFileText,
   OUT OPTIONAL BOOL *pfWasAnsi)
{
    HRESULT hr;
    CSimpleFile infile;

    hr = infile.Open(szFileName);
    if (FAILED(hr))
        return hr;

    //---- read the file ----
    DWORD len = infile.GetFileSize();

    //---- assume ANSI; adjust if UNICODE ----
    DWORD dw;
    LPSTR pOrig = (LPSTR) LocalAlloc(0, 2+len);          // space for 2-byte UNICODE NULL
    if (! pOrig)
        return MakeErrorLast();

    if (len)
    {
        hr = infile.Read((LPSTR)pOrig, len, &dw);
        if (FAILED(hr))
        {
            LocalFree(pOrig);
            return hr;
        }

        if (dw != len)
        {
            LocalFree(pOrig);
            return MakeError32(E_FAIL);
        }
    }

    infile.Close();

    //---- null terminate for both cases ----
    pOrig[len] = 0;
    pOrig[len+1] = 0;

    int iOffset;

    if (IsUnicode(pOrig, &iOffset))
    {
        if ((iOffset) && (len))     // shift away the UNICODE signature bits
            memmove(pOrig, pOrig+iOffset, len-iOffset);

        *ppszFileText = (LPWSTR)pOrig;

        if (pfWasAnsi)
            *pfWasAnsi = FALSE;

        return S_OK;
    }

    //---- need to translate to UNICODE ----
    LPWSTR pUnicode = (LPWSTR) LocalAlloc(0, sizeof(WCHAR)*(len+1));
    if (! pUnicode)
    {
        hr = MakeErrorLast();
        LocalFree(pOrig);
        return hr;
    }

    hr = AnsiToUnicode((LPSTR)pOrig, pUnicode, len+1);
    if (FAILED(hr))
    {
        LocalFree(pOrig);
        LocalFree(pUnicode);
        return hr;
    }

    LocalFree(pOrig);
    *ppszFileText = pUnicode;

    if (pfWasAnsi)
        *pfWasAnsi = TRUE;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT TextToFile(LPCWSTR szFileName, LPCWSTR szText)
{
    CSimpleFile outfile;
    HRESULT hr = outfile.Create(szFileName);
    if (FAILED(hr))
        return hr;

    hr = outfile.Write((void*)szText, lstrlenW(szText)*sizeof(WCHAR));
    if (FAILED(hr))
        return hr;

    outfile.Close();

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT AddPathIfNeeded(LPCWSTR pszFileName, LPCWSTR pszPath, LPWSTR pszFullName,
    DWORD dwFullChars)
{
    HRESULT hr;

    if (! pszFileName)
        return MakeError32(E_FAIL);

    DWORD len = lstrlen(pszFileName);
    BOOL fQualified = ((*pszFileName == L'\\') || ((len > 1) && (pszFileName[1] == ':')));

    if (fQualified)
    {
        if (dwFullChars < len+1)
            return MakeError32(E_FAIL);

        hr = hr_lstrcpy(pszFullName, pszFileName, dwFullChars);
        if (FAILED(hr))
            return hr;
    }
    else
    {
        DWORD len2 = lstrlen(pszPath);
        if (dwFullChars < len+len2+2)
            return MakeError32(E_FAIL);

        if ((len2) && (pszPath[len2-1] == '\\'))
            wsprintf(pszFullName, L"%s%psz", pszPath, pszFileName);
        else
            wsprintf(pszFullName, L"%s\\%s", pszPath, pszFileName);
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HICON _GetWindowIcon(HWND hwnd, BOOL fPerferLargeIcon)
{
    const WPARAM rgGetIconParam[] = { ICON_SMALL2, ICON_SMALL, ICON_BIG };
    const WPARAM rgGetIconParamLarge[] = { ICON_BIG, ICON_SMALL2, ICON_SMALL };
    const int    rgClassIconParam[] = { GCLP_HICONSM, GCLP_HICON };
    HICON hicon = NULL;
    const WPARAM * pIcons = (fPerferLargeIcon ? rgGetIconParamLarge : rgGetIconParam);
    int   i;

    //  try WM_GETICON
    for( i = 0; i < ARRAYSIZE(rgGetIconParam) && NULL == hicon; i++ )
    {
        SendMessageTimeout(hwnd, WM_GETICON, pIcons[i], 0, SMTO_ABORTIFHUNG | SMTO_BLOCK,
            500, (PULONG_PTR)&hicon);
    }

    //  try GetClassLong
    for( i = 0; i < ARRAYSIZE(rgClassIconParam) && NULL == hicon; i++ )
    {
        // next we try the small class icon
        hicon = (HICON)GetClassLongPtr(hwnd, rgClassIconParam[i]);
    }

    return hicon;
}
//---------------------------------------------------------------------------
HRESULT hr_lstrcpy(LPWSTR pszDest, LPCWSTR pszSrc, DWORD dwMaxDestChars)
{
    if ((! pszDest) || (! pszSrc))
        return MakeError32(E_INVALIDARG);

    DWORD dwSrcChars = lstrlen(pszSrc);
    if (dwSrcChars + 1 > dwMaxDestChars)
        return MakeError32(E_FAIL);              // buffer too small for long string

    lstrcpy(pszDest, pszSrc);

    return S_OK;
}
//---------------------------------------------------------------------------
void lstrcpy_truncate(LPWSTR pszDest, LPCWSTR pszSrc, DWORD dwMaxDestChars)
{
    if (! dwMaxDestChars)        // nothing to do
        return;

    DWORD dwSrcChars;

    if (pszSrc)
        dwSrcChars = lstrlen(pszSrc);
    else
        dwSrcChars = 0;

    if (dwSrcChars > dwMaxDestChars-1)      // truncate string
        dwSrcChars = dwMaxDestChars-1;

    if (dwSrcChars)
        memcpy(pszDest, pszSrc, dwSrcChars*sizeof(WCHAR));

    pszDest[dwSrcChars] = 0;
}
//---------------------------------------------------------------------------
int string2number(LPCWSTR psz)
{
    int temp = 0, base = 10;
    int nNeg = 1;

    if (*psz == L'-')
    {
        nNeg = -1;
        psz++;
    }
    else if (*psz == L'+')
        psz++;
    if (*psz == '0')
    {
        ++psz;
        switch(*psz)
        {
        case L'X':
        case L'x':
            ++psz;
            base = 16;
            break;
        }
    }
    while (*psz)
    {
        switch (*psz)
        {
        case L'0': case L'1': case L'2': case L'3': case L'4':
        case L'5': case L'6': case L'7': case L'8': case L'9':
            temp = (temp * base) + (*psz++ - L'0');
            break;
        case L'a': case L'b': case L'c': case L'd': case L'e': case L'f':
            if (base == 10)
                return (nNeg*temp);
            temp = (temp * base) + (*psz++ - L'a' + 10);
            break;
        case L'A': case L'B': case L'C': case L'D': case L'E': case L'F':
            if (base == 10)
                return (nNeg*temp);
            temp = (temp * base) + (*psz++ - L'A' + 10);
            break;
        default:
            return (nNeg*temp);
        }
    }
    return (nNeg*temp);
}
//---------------------------------------------------------------------------
HRESULT GetDirBaseName(LPCWSTR pszDirName, LPWSTR pszBaseBuff, DWORD dwMaxBaseChars)
{
    //---- extract last node of dir name ----
    LPCWSTR p = wcsrchr(pszDirName, '\\');
    if ((p) && (p > pszDirName) && (! p[1]))         // last char - try next one to left
        p = wcsrchr(p-1, '//');

    if (p)
        return hr_lstrcpy(pszBaseBuff, p, dwMaxBaseChars);

    return hr_lstrcpy(pszBaseBuff, pszDirName, dwMaxBaseChars);
}
//---------------------------------------------------------------------------
BOOL AsciiScanStringList(
    LPCWSTR pwszString,
    LPCWSTR* rgpwszList,
    int cStrings,
    BOOL fIgnoreCase )
{
    int (* pfnCompare)( LPCWSTR, LPCWSTR ) =
        fIgnoreCase ? AsciiStrCmpI : lstrcmp;

    for( int i = 0; i < cStrings; i++ )
    {
        if( 0 == pfnCompare( pwszString, rgpwszList[i] ) )
        {
            return TRUE;
        }
    }
    return FALSE;
}
//---------------------------------------------------------------------------
BOOL UnExpandEnvironmentString(LPCWSTR pszPath, LPCWSTR pszEnvVar, LPWSTR pszResult, UINT cbResult)
{
    DWORD nToCmp;
    WCHAR szEnvVar[MAX_PATH];
    szEnvVar[0] = 0;

    ExpandEnvironmentStringsW(pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar)); // don't count the NULL
    nToCmp = lstrlenW(szEnvVar);
   
    if (CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, nToCmp, pszPath, nToCmp))
    {
        if (lstrlenW(pszPath) - (int)nToCmp  + lstrlenW(pszEnvVar) < (int)cbResult)
        {
            lstrcpyW(pszResult, pszEnvVar);
            lstrcpyW(pszResult + lstrlenW(pszResult), pszPath + nToCmp);
            return TRUE;
        }
    }
    return FALSE;
}
//---------------------------------------------------------------------------
HRESULT RegistryIntWrite(HKEY hKey, LPCWSTR pszValueName, int iValue)
{
    HRESULT hr = S_OK;
    WCHAR valbuff[_MAX_PATH+1];

    wsprintf(valbuff, L"%d", iValue);
    int len = (1 + lstrlen(valbuff)) * sizeof(WCHAR);

    int code32 = RegSetValueEx(hKey, pszValueName, NULL, REG_SZ,
        (BYTE *)valbuff, len);

    if (code32 != ERROR_SUCCESS)
        hr = MakeError32(code32);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT RegistryStrWrite(HKEY hKey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    HRESULT hr = S_OK;
    int len = (1 + lstrlen(pszValue)) * (sizeof(WCHAR));

    int code32 = RegSetValueEx(hKey, pszValueName, NULL, REG_SZ,
        (BYTE *)pszValue, len);

    if (code32 != ERROR_SUCCESS)
        hr = MakeError32(code32);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT RegistryStrWriteExpand(HKEY hKey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    HRESULT hr = S_OK;
    int len;
    WCHAR szResult[_MAX_PATH + 1];
    LPCWSTR pszPath = pszValue;

    if (UnExpandEnvironmentString(pszValue, L"%SystemRoot%", szResult, ARRAYSIZE(szResult)))
        pszPath = szResult;

    len = (1 + lstrlen(pszPath)) * (sizeof(WCHAR));

    int code32 = RegSetValueEx(hKey, pszValueName, NULL, REG_EXPAND_SZ,
        (BYTE *)pszPath, len);

    if (code32 != ERROR_SUCCESS)
        hr = MakeError32(code32);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT RegistryIntRead(HKEY hKey, LPCWSTR pszValueName, int *piValue)
{
    HRESULT hr = S_OK;
    DWORD dwValType;
    WCHAR valbuff[_MAX_PATH+1];
    DWORD dwByteSize = sizeof(valbuff);         // bytes, not chars

    int code32 = RegQueryValueEx(hKey, pszValueName, NULL, &dwValType,
        (BYTE *)valbuff, &dwByteSize);

    if (code32 == ERROR_SUCCESS)
    {
        *piValue = string2number(valbuff);
    }
    else
        hr = MakeError32(code32);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT RegistryStrRead(HKEY hKey, LPCWSTR pszValueName, LPWSTR pszBuff, DWORD dwMaxChars)
{
    HRESULT hr = S_OK;
    DWORD dwValType = 0;
    DWORD dwByteSize = dwMaxChars * sizeof(WCHAR);      // in bytes

    int code32 = RegQueryValueEx(hKey, pszValueName, NULL, &dwValType,
        (BYTE *)pszBuff, &dwByteSize);

    if (code32 != ERROR_SUCCESS)
    {
        hr = MakeError32(code32);
        goto exit;
    }

    if (dwValType == REG_EXPAND_SZ || wcschr(pszBuff, L'%'))
    {
        int len = sizeof(WCHAR) * (1 + lstrlen(pszBuff));
        LPWSTR szTempBuff = (LPWSTR)alloca(len);
        if (szTempBuff)
        {
            lstrcpy(szTempBuff, pszBuff);

            DWORD dwChars = ExpandEnvironmentStrings(szTempBuff, pszBuff, dwMaxChars);
            if (dwChars > dwMaxChars)           // caller's buffer too small
            {
                hr = MakeError32(ERROR_INSUFFICIENT_BUFFER);
            }
        }
    }

exit:
    return hr;
}

//---------------------------------------------------------------------------
BOOL PreMultiplyAlpha(DWORD *pPixelBuff, UINT iWidth, UINT iHeight)
{
    BOOL fTrueAlpha = FALSE;

    DWORD *pdw = pPixelBuff;

    for (int i = iWidth * iHeight - 1; i >= 0; i--)
    {
        COLORREF cr = *pdw;
        int iAlpha = ALPHACHANNEL(cr);

        if ((iAlpha != 255) && (iAlpha != 0))
            fTrueAlpha = TRUE;

        pdw++;
    }

    pdw = pPixelBuff;
    
    if (fTrueAlpha)
    {
        for (UINT r=0; r < iHeight; r++)
        {
            for (UINT c=0; c < iWidth; c++)
            {
                COLORREF cr = *pdw;
                int iAlpha = ALPHACHANNEL(cr);

                int iRed = (RED(cr)*iAlpha)/255;
                int iGreen = (GREEN(cr)*iAlpha)/255;
                int iBlue = (BLUE(cr)*iAlpha)/255;

                *pdw++ = (RGB(iRed, iGreen, iBlue) | (iAlpha << 24));
            }
        }
    }

    return fTrueAlpha;
}
//---------------------------------------------------------------------------
HRESULT MakeFlippedBitmap(HBITMAP hSrcBitmap, HBITMAP *phFlipped)
{
    HRESULT hr = S_OK;
    BOOL fSucceeded = FALSE;

    Log(LOG_TMBITMAP, L"MakeFlippedBitmap %08X", hSrcBitmap);

    //---- setup SOURCE dc/bitmap ----
    HDC hdcSrc = CreateCompatibleDC(NULL);
    if (hdcSrc)
    {
        DWORD dwSrcLayout = GetLayout(hdcSrc);

        HBITMAP hOldSrcBitmap = (HBITMAP)SelectObject(hdcSrc, hSrcBitmap);
        if (hOldSrcBitmap)
        {
            //---- setup DEST dc/bitmap ----

            //---- MSDN doc for CreateCompatibleBitmap says that this works correctly ----
            //---- if a DIB is selected in the dc ----

            BITMAP bm;
            if (GetObject(hSrcBitmap, sizeof(bm), &bm))
            {
                int iWidth = bm.bmWidth;
                int iHeight = bm.bmHeight;
            
                HBITMAP hDestBitmap = CreateCompatibleBitmap(hdcSrc, iWidth, iHeight);
                if (hDestBitmap)
                {
                    HDC hdcDest = CreateCompatibleDC(hdcSrc);
                    if (hdcDest)
                    {
                        HBITMAP hOldDestBitmap = (HBITMAP)SelectObject(hdcDest, hDestBitmap);
                        if (hOldDestBitmap)
                        {
                            //---- toggle layout ----
                            DWORD dwOldDestLayout;

                            if (dwSrcLayout & LAYOUT_RTL)
                                dwOldDestLayout = SetLayout(hdcDest, 0);
                            else
                                dwOldDestLayout = SetLayout(hdcDest, LAYOUT_RTL);

                            //---- mirror the bits from src to dest ----
                            if (BitBlt(hdcDest, 0, 0, iWidth, iHeight, hdcSrc, 0, 0, SRCCOPY))
                            {
                                *phFlipped = hDestBitmap;
                                fSucceeded = TRUE;
                            }

                            SelectObject(hdcDest, hOldDestBitmap);
                        }

                        DeleteDC(hdcDest);
                    }

                    if (! fSucceeded)
                        DeleteObject(hDestBitmap);
                }
            }

            SelectObject(hdcSrc, hOldSrcBitmap);
        }

        DeleteDC(hdcSrc);
    }

    if (! fSucceeded)
        hr = GetLastError();

    return hr;
}

//---------------------------------------------------------------------------
HRESULT FlipDIB32(DWORD *pBits, UINT iWidth, UINT iHeight)
{
    DWORD temp;
    DWORD *pTemp1;
    DWORD *pTemp2;
    HRESULT hr = S_OK;

    if (pBits == NULL || iWidth == 0 || iHeight == 0)
    {
        Log(LOG_TMBITMAP, L"FlipDIB32 failed.");

        return E_INVALIDARG;
    }

    for (UINT iRow = 0; iRow < iHeight; iRow++)
    {
        for (UINT iCol = 0; iCol < iWidth / 2; iCol++)
        {
            pTemp1 = pBits + iRow * iWidth + iCol;
            pTemp2 = pBits + (iRow + 1) * iWidth - iCol - 1;
            temp = *pTemp1;
            *pTemp1 = *pTemp2;
            *pTemp2 = temp;
        }
    }

    return hr;
}

//---------------------------------------------------------------------------
// IsBiDiLocalizedSystem is taken from stockthk.lib and simplified
//  (it's only a wrapper for GetUserDefaultUILanguage and GetLocaleInfo)
//---------------------------------------------------------------------------
typedef struct {
    LANGID LangID;
    BOOL   bInstalled;
    } MUIINSTALLLANG, *LPMUIINSTALLLANG;

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

/***************************************************************************\
* Mirror_EnumUILanguagesProc
*
* Enumerates MUI installed languages on W2k
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam)
{
    int langID = 0;

    ConvertHexStringToIntW(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{
    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    EnumUILanguagesW(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}

/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    int           iLCID=0L;
    static BOOL   bRet = (BOOL)(DWORD)-1;
    static LANGID langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (bRet != (BOOL)(DWORD)-1)
    {
        if (bRet && pLangID)
        {
            *pLangID = langID;
        }
        return bRet;
    }

    bRet = FALSE;
    /*
     * Need to use NT5 detection method (Multiligual UI ID)
     */
    langID = GetUserDefaultUILanguage();

    if( langID )
    {
        WCHAR wchLCIDFontSignature[16];
        iLCID = MAKELCID( langID , SORT_DEFAULT );

        /*
         * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
         * convert to decimal value and call GetLocaleInfo afterwards.
         * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
         */

        if( GetLocaleInfoW( iLCID , 
                            LOCALE_FONTSIGNATURE , 
                            (WCHAR *) &wchLCIDFontSignature[0] ,
                            (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
        {
  
            /* Let's verify the bits we have a BiDi UI locale */
            if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(langID) )
            {
                bRet = TRUE;
            }
        }
    }

    if (bRet && pLangID)
    {
        *pLangID = langID;
    }
    return bRet;
}
//---------------------------------------------------------------------------

BOOL IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}
//---------------------------------------------------------------------------

BOOL GetWindowDesktopName(HWND hwnd, LPWSTR pszName, DWORD dwMaxChars)
{
    BOOL fGotName = FALSE;

    DWORD dwThreadId = GetWindowThreadProcessId(hwnd, NULL);
    HDESK hDesk = GetThreadDesktop(dwThreadId);
    if (hDesk)
    {
        fGotName = GetUserObjectInformation(hDesk, UOI_NAME, pszName, dwMaxChars*sizeof(WCHAR), NULL);
    }

    return fGotName;
}
//---------------------------------------------------------------------------
void SafeSendMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DWORD dwFlags = SMTO_BLOCK | SMTO_ABORTIFHUNG;
    DWORD dwTimeout = 250;          // .25 secs
    ULONG_PTR puRetVal;

    if (! SendMessageTimeout(hwnd, uMsg, wParam, lParam, dwFlags, dwTimeout, &puRetVal))
    {
        Log(LOG_TMLOAD, L"SEND TIMEOUT: msg=0x%x being POSTED to hwnd=0x%x",
            uMsg, hwnd);

        PostMessage(hwnd, uMsg, wParam, lParam);
    }
}
//---------------------------------------------------------------------------
int FontPointSize(int iFontHeight)
{
    return -MulDiv(iFontHeight, 72, THEME_DPI);
}
//---------------------------------------------------------------------------
void ScaleFontForHdcDpi(HDC hdc, LOGFONT *plf)
{
    if (plf->lfHeight < 0)          // specified in points
    {
        if (! hdc)
        {
            ScaleFontForScreenDpi(plf);
        }
        else
        {
            int iDpi = GetDeviceCaps(hdc, LOGPIXELSX);
            plf->lfHeight = MulDiv(plf->lfHeight, iDpi, THEME_DPI);
        }
    }
}

//---------------------------------------------------------------------------
int ScaleSizeForHdcDpi(HDC hdc, int iValue)
{
    int iScaledValue;

    if (! hdc)
    {
        iScaledValue = ScaleSizeForScreenDpi(iValue);
    }
    else
    {
        int iDpi = GetDeviceCaps(hdc, LOGPIXELSX);
        iScaledValue = MulDiv(iValue, iDpi, THEME_DPI);
    }

    return iScaledValue;
}
//---------------------------------------------------------------------------
//  --------------------------------------------------------------------------
//  MinimumDisplayColorDepth
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//              
//  Purpose:    Iterates all monitors attached to the system and finds those
//              that are active. Returns the lowest bit depth availabe. This
//              is the lowest common denominator.
//
//  History:    2001-04-11  lmouton     moved from services.cpp
//              2000-11-11  vtan        created (rewritten from themeldr.cpp)
//  --------------------------------------------------------------------------

DWORD   MinimumDisplayColorDepth (void)

{
    DWORD           dwMinimumDepth, dwIndex;
    bool            fContinue;
    DISPLAY_DEVICE  displayDevice;

    dwMinimumDepth = 0;
    ZeroMemory(&displayDevice, sizeof(displayDevice));
    dwIndex = 0;
    do
    {
        displayDevice.cb = sizeof(displayDevice);
        fContinue = (EnumDisplayDevices(NULL, dwIndex++, &displayDevice, 0) != FALSE);
        if (fContinue)
        {
            if ((displayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) != 0)
            {
                DEVMODE     devMode;

                ZeroMemory(&devMode, sizeof(devMode));
                devMode.dmSize = sizeof(devMode);
                devMode.dmDriverExtra = 0;
                if (EnumDisplaySettings(displayDevice.DeviceName, ENUM_CURRENT_SETTINGS, &devMode) != FALSE)
                {
                    if ((dwMinimumDepth == 0) || (dwMinimumDepth > devMode.dmBitsPerPel))
                    {
                        dwMinimumDepth = devMode.dmBitsPerPel;
                    }
                }
            }
        }
    } while (fContinue);
    
    // Note: We can fail here (return 0) because when a session is disconnected, the desktop is attached to 
    // a hidden display. OK to fail silently then.

    return(dwMinimumDepth);
}

//  --------------------------------------------------------------------------
//  CheckMinColorDepth
//
//  Arguments:  hInst           msstyle module handle
//              dwCurMinDepth   current minimum active screen resolution
//              iIndex          index to the color/size combo to test, or
//                              -1 to enumerate them all        
//
//  Returns:    bool            true if at least a color/size combo supports
//                              the current screen resolution
//              
//  History:    2001-04-11  lmouton     created
//  --------------------------------------------------------------------------
bool CheckMinColorDepth(HINSTANCE hInst, DWORD dwCurMinDepth, int iIndex)
{
    BYTE *pBytes = NULL;
    DWORD dwBytes = 0;

    bool bMatch = true; // OK if the resource doesn't exist

    if (SUCCEEDED(GetPtrToResource(hInst, L"MINDEPTH", MAKEINTRESOURCE(1), (void**) &pBytes, &dwBytes)) && dwBytes > 0)
    {
        bMatch = false;

        if (iIndex != -1)
        {
            if (*((WORD*) pBytes + iIndex) <= dwCurMinDepth)
                bMatch = true;
        }
        else
        {
            WORD wDepth = *((WORD*) pBytes);

            while (wDepth != 0)
            {
                if (wDepth <= (WORD) dwCurMinDepth)
                {
                    bMatch = true;
                    break;
                }
                pBytes += sizeof(WORD);
                wDepth = *((WORD*) pBytes);
            }
        }
    }

    return bMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeldr\tmreg.cpp ===
//---------------------------------------------------------------------------
/