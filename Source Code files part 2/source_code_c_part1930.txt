COLOR_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_3_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_OPERATION                              31:29
#define NV095_COMBINE_COLOR_OPERATION_ADD                          (0x00000001)
#define NV095_COMBINE_COLOR_OPERATION_ADD2                         (0x00000002)
#define NV095_COMBINE_COLOR_OPERATION_ADD4                         (0x00000003)
#define NV095_COMBINE_COLOR_OPERATION_ADDSIGNED                    (0x00000004)
#define NV095_COMBINE_COLOR_OPERATION_MUX                          (0x00000005)
#define NV095_COMBINE_COLOR_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV095_COMBINE_COLOR_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV095_COMBINE_FACTOR                                       (0x00000334)
#define NV095_COMBINE_FACTOR_BLUE                                  7:0
#define NV095_COMBINE_FACTOR_GREEN                                 15:8
#define NV095_COMBINE_FACTOR_RED                                   23:16
#define NV095_COMBINE_FACTOR_ALPHA                                 31:24
#define NV095_BLEND                                                (0x00000338)
#define NV095_BLEND_MASK_BIT                                       5:0
#define NV095_BLEND_MASK_BIT_LSB                                   (0x00000010)
#define NV095_BLEND_MASK_BIT_MSB                                   (0x00000020)
#define NV095_BLEND_SHADEMODE                                      7:6
#define NV095_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV095_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV095_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV095_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV095_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV095_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV095_BLEND_SPECULARENABLE                                 15:12
#define NV095_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV095_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV095_BLEND_FOGENABLE                                      19:16
#define NV095_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV095_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV095_BLEND_ALPHABLENDENABLE                               23:20
#define NV095_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV095_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV095_BLEND_SRCBLEND                                       27:24
#define NV095_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV095_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV095_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV095_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV095_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV095_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV095_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV095_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV095_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV095_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV095_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV095_BLEND_DESTBLEND                                      31:28
#define NV095_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV095_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV095_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV095_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV095_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV095_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV095_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV095_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV095_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV095_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV095_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV095_CONTROL0                                             (0x0000033C)
#define NV095_CONTROL0_ALPHAREF                                    7:0
#define NV095_CONTROL0_ALPHAFUNC                                   11:8
#define NV095_CONTROL0_ALPHAFUNC_NEVER                             (0x00000001)
#define NV095_CONTROL0_ALPHAFUNC_LESS                              (0x00000002)
#define NV095_CONTROL0_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV095_CONTROL0_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV095_CONTROL0_ALPHAFUNC_GREATER                           (0x00000005)
#define NV095_CONTROL0_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV095_CONTROL0_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV095_CONTROL0_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV095_CONTROL0_ALPHATESTENABLE                             12:12
#define NV095_CONTROL0_ALPHATESTENABLE_FALSE                       (0x00000000)
#define NV095_CONTROL0_ALPHATESTENABLE_TRUE                        (0x00000001)
#define NV095_CONTROL0_ORIGIN                                      13:13
#define NV095_CONTROL0_ORIGIN_CENTER                               (0x00000000)
#define NV095_CONTROL0_ORIGIN_CORNER                               (0x00000001)
#define NV095_CONTROL0_ZENABLE                                     15:14
#define NV095_CONTROL0_ZENABLE_FALSE                               (0x00000000)
#define NV095_CONTROL0_ZENABLE_TRUE                                (0x00000001)
#define NV095_CONTROL0_ZFUNC                                       19:16
#define NV095_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV095_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV095_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV095_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV095_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV095_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV095_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV095_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV095_CONTROL0_CULLMODE                                    21:20
#define NV095_CONTROL0_CULLMODE_NONE                               (0x00000001)
#define NV095_CONTROL0_CULLMODE_CW                                 (0x00000002)
#define NV095_CONTROL0_CULLMODE_CCW                                (0x00000003)
#define NV095_CONTROL0_DITHERENABLE                                22:22
#define NV095_CONTROL0_DITHERENABLE_FALSE                          (0x00000000)
#define NV095_CONTROL0_DITHERENABLE_TRUE                           (0x00000001)
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE                        23:23
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV095_CONTROL0_ZWRITEENABLE                                24:24
#define NV095_CONTROL0_ZWRITEENABLE_FALSE                          (0x00000000)
#define NV095_CONTROL0_ZWRITEENABLE_TRUE                           (0x00000001)
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE                        25:25
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                  (0x00000000)
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                   (0x00000001)
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE                          26:26
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV095_CONTROL0_RED_WRITE_ENABLE                            27:27
#define NV095_CONTROL0_RED_WRITE_ENABLE_FALSE                      (0x00000000)
#define NV095_CONTROL0_RED_WRITE_ENABLE_TRUE                       (0x00000001)
#define NV095_CONTROL0_GREEN_WRITE_ENABLE                          28:28
#define NV095_CONTROL0_GREEN_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV095_CONTROL0_GREEN_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV095_CONTROL0_BLUE_WRITE_ENABLE                           29:29
#define NV095_CONTROL0_BLUE_WRITE_ENABLE_FALSE                     (0x00000000)
#define NV095_CONTROL0_BLUE_WRITE_ENABLE_TRUE                      (0x00000001)
#define NV095_CONTROL0_Z_FORMAT                                    31:30
#define NV095_CONTROL0_Z_FORMAT_FIXED                              (0x00000001)
#define NV095_CONTROL0_Z_FORMAT_FLOAT                              (0x00000002)
#define NV095_CONTROL1                                             (0x00000340)
#define NV095_CONTROL1_STENCIL_TEST_ENABLE                         3:0
#define NV095_CONTROL1_STENCIL_TEST_ENABLE_FALSE                   (0x00000000)
#define NV095_CONTROL1_STENCIL_TEST_ENABLE_TRUE                    (0x00000001)
#define NV095_CONTROL1_STENCIL_FUNC                                7:4
#define NV095_CONTROL1_STENCIL_FUNC_NEVER                          (0x00000001)
#define NV095_CONTROL1_STENCIL_FUNC_LESS                           (0x00000002)
#define NV095_CONTROL1_STENCIL_FUNC_EQUAL                          (0x00000003)
#define NV095_CONTROL1_STENCIL_FUNC_LESSEQUAL                      (0x00000004)
#define NV095_CONTROL1_STENCIL_FUNC_GREATER                        (0x00000005)
#define NV095_CONTROL1_STENCIL_FUNC_NOTEQUAL                       (0x00000006)
#define NV095_CONTROL1_STENCIL_FUNC_GREATEREQUAL                   (0x00000007)
#define NV095_CONTROL1_STENCIL_FUNC_ALWAYS                         (0x00000008)
#define NV095_CONTROL1_STENCIL_REF                                 15:8
#define NV095_CONTROL1_STENCIL_MASK_READ                           23:16
#define NV095_CONTROL1_STENCIL_MASK_WRITE                          31:24
#define NV095_CONTROL2                                             (0x00000344)
#define NV095_CONTROL2_STENCIL_OP_FAIL                             3:0
#define NV095_CONTROL2_STENCIL_OP_FAIL_KEEP                        (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_FAIL_ZERO                        (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_FAIL_REPLACE                     (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INCRSAT                     (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_FAIL_DECRSAT                     (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INVERT                      (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INCR                        (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_FAIL_DECR                        (0x00000008)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL                            7:4
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_KEEP                       (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_ZERO                       (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_REPLACE                    (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT                    (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT                    (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INVERT                     (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INCR                       (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_DECR                       (0x00000008)
#define NV095_CONTROL2_STENCIL_OP_ZPASS                            31:8
#define NV095_CONTROL2_STENCIL_OP_ZPASS_KEEP                       (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_ZERO                       (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_REPLACE                    (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INCRSAT                    (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_DECRSAT                    (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INVERT                     (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INCR                       (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_DECR                       (0x00000008)
#define NV095_FOG_COLOR                                            (0x00000348)
#define NV095_TLMTVERTEX(i)                                        (0x00000400\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SX(i)                                     (0x00000400\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SY(i)                                     (0x00000404\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SZ(i)                                     (0x00000408\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_RHW(i)                                    (0x0000040C\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_COLOR(i)                                  (0x00000410\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_COLOR_BLUE                                7:0
#define NV095_TLMTVERTEX_COLOR_GREEN                               15:8
#define NV095_TLMTVERTEX_COLOR_RED                                 23:16
#define NV095_TLMTVERTEX_COLOR_ALPHA                               31:24
#define NV095_TLMTVERTEX_SPECULAR(i)                               (0x00000414\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SPECULAR_BLUE                             7:0
#define NV095_TLMTVERTEX_SPECULAR_GREEN                            15:8
#define NV095_TLMTVERTEX_SPECULAR_RED                              23:16
#define NV095_TLMTVERTEX_SPECULAR_FOG                              31:24
#define NV095_TLMTVERTEX_TU0(i)                                    (0x00000418\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TV0(i)                                    (0x0000041C\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TU1(i)                                    (0x00000420\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TV1(i)                                    (0x00000424\
                                                                   +(i)*0x0028)
#define NV095_DRAW_PRIMITIVE(a)                                    (0x00000540\
                                                                   +(a)*0x0004)
#define NV095_DRAW_PRIMITIVE_I0                                    3:0
#define NV095_DRAW_PRIMITIVE_I1                                    7:4
#define NV095_DRAW_PRIMITIVE_I2                                    11:8
#define NV095_DRAW_PRIMITIVE_I3                                    15:12
#define NV095_DRAW_PRIMITIVE_I4                                    19:16
#define NV095_DRAW_PRIMITIVE_I5                                    31:20

// This typedef really should be the same as Nv12CelsiusPrimitive, but this
// causes the NV03/NV04_CHANNEL_PIO union to become too large for the 16bit
// compiler. Since we don't expect to use a PIO channel with Celsius, we'll
// just use the old DWORD size typedef.


typedef NvV32 Nv096Typedef;


/* class NV15_CELSIUS_PRIMITIVE */
#define  NV15_CELSIUS_PRIMITIVE                                    (0x00000096)
/* NvNotification[] elements */
#define NV096_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV096_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV096_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV096_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV096_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV096_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV096_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved00[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved01[0xc/4];
    NvV32 SyncSetRead;
    NvV32 SyncSetWrite;
    NvV32 SyncSetModulo;
    NvV32 SyncIncrementWrite;
    NvV32 SyncStall;
    NvV32 Reserved17[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved02[0x3c/4];
    NvV32 SetContextDmaNotifies;
    NvV32 SetContextDmaA;
    NvV32 SetContextDmaB;
    NvV32 SetContextDmaVertex;
    NvV32 SetContextDmaState;
    NvV32 SetContextDmaColor;
    NvV32 SetContextDmaZeta;
    NvV32 Reserved03[0x64/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvU32 SetTextureOffset[2];
    NvV32 SetTextureFormat[2];
    NvV32 SetTextureControl0[2];
    NvV32 SetTextureControl1[2];
    NvV32 SetTextureControl2[2];
    NvV32 SetTextureImageRect[2];
    NvV32 SetTextureFilter[2];
    NvV32 SetTexturePalette[2];
    NvV32 Reserved04[0x8/4];
    NvV32 SetCombinerAlphaICW[2];
    NvV32 SetCombinerColorICW[2];
    NvV32 SetCombineFactor[2];
    NvV32 SetCombinerAlphaOCW[2];
    NvV32 SetCombiner0ColorOCW;
    NvV32 SetCombiner1ColorOCW;
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvV32 SetColorKeyColor[2];
    NvV32 SetWindowClipType;
    NvV32 Reserved05[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinEnable;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvV32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvV32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvV32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvV32 SetStencilFuncRef;
    NvV32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvV32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvV32 SetMaterialEmission[3];
    NvV32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
        NvV32 S;
        NvV32 T;
        NvV32 R;
        NvV32 Q;
    } SetTexgen[2];
    NvV32 SetTextureMatrix0Enable;
    NvV32 SetTextureMatrix1Enable;
    NvV32 SetTLMode;
    NvV32 SetPointSize;
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved06[0x8/4];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvV32 Reserved07[0x40/4];
    NvF32 SetTexgenSPlane0[4];
    NvF32 SetTexgenTPlane0[4];
    NvF32 SetTexgenRPlane0[4];
    NvF32 SetTexgenQPlane0[4];
    NvF32 SetTexgenSPlane1[4];
    NvF32 SetTexgenTPlane1[4];
    NvF32 SetTexgenRPlane1[4];
    NvF32 SetTexgenQPlane1[4];
    NvF32 SetFogParams[3];
    NvF32 SetFogPlane[4];
    NvV32 Reserved08[0x4/4];
    NvF32 SetSpecularParams[6];
    NvV32 Reserved09[0xc/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved0a[0x18/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 Flush;
    NvF32 SetEyeDirectionSW[3];
    NvV32 Reserved0b[0xc8/4];
    struct {
        NvF32 AmbientColor[3];
        NvF32 DiffuseColor[3];
        NvF32 SpecularColor[3];
        NvF32 LocalRange;
        NvF32 InfiniteHalfVector[3];
        NvF32 InfiniteDirection[3];
        NvF32 SpotFalloff[3];
        NvF32 SpotDirection[4];
        NvF32 LocalPosition[3];
        NvF32 LocalAttenuation[3];
        NvV32 Reserved0c[0xc/4];
    } SetLight[8];
    NvF32 SetVertex3f[3];
    NvV32 Reserved0d[0xc/4];
    NvF32 SetVertex4f[4];
    NvS16 SetVertex4s[4];
    NvF32 SetNormal3f[3];
    NvV32 Reserved0e[0x4/4];
    NvS16 SetNormal3s[3];
    NvV16 Reserved0f[0xa/2];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvV32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvV32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS16 SetTexcoord0_2s[2];
    NvV32 Reserved10[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS16 SetTexcoord0_4s[4];
    NvF32 SetTexcoord1_2f[2];
    NvS16 SetTexcoord1_2s[2];
    NvV32 Reserved11[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS16 SetTexcoord1_4s[4];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvV32 Reserved12[0x4/4];
    NvV32 SetEdgeFlag;
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvU32 SetVertexArrayOffset;
    NvV32 SetVertexArrayFormat;
    NvU32 SetDiffuseArrayOffset;
    NvV32 SetDiffuseArrayFormat;
    NvU32 SetSpecularArrayOffset;
    NvV32 SetSpecularArrayFormat;
    NvU32 SetTexCoord0ArrayOffset;
    NvV32 SetTexCoord0ArrayFormat;
    NvU32 SetTexCoord1ArrayOffset;
    NvV32 SetTexCoord1ArrayFormat;
    NvU32 SetNormalArrayOffset;
    NvV32 SetNormalArrayFormat;
    NvU32 SetWeightArrayOffset;
    NvV32 SetWeightArrayFormat;
    NvU32 SetFogArrayOffset;
    NvV32 SetFogArrayFormat;
    NvV32 Reserved13[0xbc/4];
    NvV32 SetBeginEnd;
    NvV16 ArrayElement16[256];
    NvV32 Reserved14[0xfc/4];
    NvV32 SetBeginEnd2;
    NvV32 ArrayElement32[64];
    NvV32 Reserved15[0x1fc/4];
    NvV32 SetBeginEnd3;
    NvV32 DrawArrays[128];
    NvV32 DebugInit[10];
    NvV32 SetMaterialEmissionSW[3];
    NvV32 Reserved16[1];
    NvF32 SetViewportOffsetSW[4];
    NvF32 SetPassthruViewportOffsetSW[4];
    NvV32 Reserved18[0x1a4/4];
    NvV32 SetBeginEnd4;
    NvV32 InlineArray[512];
} Nv12CelsiusPrimitive;


#define NV096_TYPEDEF                                      Nv12CelsiusPrimitive
#define NV096_SET_OBJECT                                           (0x00000000)


#define NV096_DEBUG_INIT(i)                                        (0x00001600+(i)*4)


#define NV096_FLUSH                                                        0x00000728


#define NV096_NO_OPERATION                                                 0x00000100


#define NV096_NOTIFY                                                       0x00000104
#define NV096_NOTIFY_TYPE                                                        23:0
#define NV096_NOTIFY_TYPE_WRITE_ONLY                                       0x00000000
#define NV096_NOTIFY_TYPE_WRITE_THEN_AWAKEN                                0x00000001


#define NV096_SET_WARNING_ENABLE                                           0x00000108
#define NV096_SET_WARNING_ENABLE_V                                               23:0
#define NV096_SET_WARNING_ENABLE_V_FALSE                                   0x00000000
#define NV096_SET_WARNING_ENABLE_V_TRUE                                    0x00000001


#define NV096_GET_STATE                                                    0x0000010c
#define NV096_GET_STATE_GETSTATE                                                 31:0
#define NV096_GET_STATE_GETSTATE_ALL_STATE                                 0x00000001
#define NV096_GET_STATE_PUTSTATE_ALL_STATE                                 0x00000002
#define NV096_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE                   0x00000003
#define NV096_GET_STATE_GETSTATE_RENDERING_STATE                           0x00000004
#define NV096_GET_STATE_GETSTATE_GEOMETRY_STATE                            0x00000005
#define NV096_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM                        0x00000006
#define NV096_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM                          0x00000007

#define NV096_WAIT_FOR_IDLE                                                0x00000110

#define NV096_SYNC_SET_READ                                                0x00000120
#define NV096_SYNC_SET_WRITE                                               0x00000124
#define NV096_SYNC_SET_MODULO                                              0x00000128
#define NV096_SYNC_INCREMENT_WRITE                                         0x0000012c
#define NV096_SYNC_STALL                                                   0x00000130

#define NV096_PM_TRIGGER                                                   0x00000140


#define NV096_SET_CONTEXT_DMA_NOTIFIES                                     0x00000180


#define NV096_SET_CONTEXT_DMA_A                                            0x00000184


#define NV096_SET_CONTEXT_DMA_B                                            0x00000188


#define NV096_SET_CONTEXT_DMA_VERTEX                                       0x0000018c


#define NV096_SET_CONTEXT_DMA_STATE                                        0x00000190


#define NV096_SET_CONTEXT_DMA_COLOR                                        0x00000194


#define NV096_SET_CONTEXT_DMA_ZETA                                         0x00000198


#define NV096_SET_SURFACE_CLIP_HORIZONTAL                                  0x00000200
#define NV096_SET_SURFACE_CLIP_HORIZONTAL_X                                      15:0
#define NV096_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                 31:16


#define NV096_SET_SURFACE_CLIP_VERTICAL                                    0x00000204
#define NV096_SET_SURFACE_CLIP_VERTICAL_Y                                        15:0
#define NV096_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                  31:16


#define NV096_SET_SURFACE_FORMAT                                           0x00000208
#define NV096_SET_SURFACE_FORMAT_COLOR                                            7:0
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                0x00000001
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                0x00000002
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                           0x00000003
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                0x00000004
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                0x00000005
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            0x00000006
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            0x00000007
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000008
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_B8                               0x00000009
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_G8B8                             0x0000000A
#define NV096_SET_SURFACE_FORMAT_TYPE                                            15:8
#define NV096_SET_SURFACE_FORMAT_TYPE_PITCH                                0x00000001
#define NV096_SET_SURFACE_FORMAT_TYPE_SWIZZLE                              0x00000002
#define NV096_SET_SURFACE_FORMAT_WIDTH                                          23:16
#define NV096_SET_SURFACE_FORMAT_WIDTH_1                                   0x00000000
#define NV096_SET_SURFACE_FORMAT_WIDTH_2                                   0x00000001
#define NV096_SET_SURFACE_FORMAT_WIDTH_4                                   0x00000002
#define NV096_SET_SURFACE_FORMAT_WIDTH_8                                   0x00000003
#define NV096_SET_SURFACE_FORMAT_WIDTH_16                                  0x00000004
#define NV096_SET_SURFACE_FORMAT_WIDTH_32                                  0x00000005
#define NV096_SET_SURFACE_FORMAT_WIDTH_64                                  0x00000006
#define NV096_SET_SURFACE_FORMAT_WIDTH_128                                 0x00000007
#define NV096_SET_SURFACE_FORMAT_WIDTH_256                                 0x00000008
#define NV096_SET_SURFACE_FORMAT_WIDTH_512                                 0x00000009
#define NV096_SET_SURFACE_FORMAT_WIDTH_1024                                0x0000000A
#define NV096_SET_SURFACE_FORMAT_WIDTH_2048                                0x0000000B
#define NV096_SET_SURFACE_FORMAT_HEIGHT                                         31:24
#define NV096_SET_SURFACE_FORMAT_HEIGHT_1                                  0x00000000
#define NV096_SET_SURFACE_FORMAT_HEIGHT_2                                  0x00000001
#define NV096_SET_SURFACE_FORMAT_HEIGHT_4                                  0x00000002
#define NV096_SET_SURFACE_FORMAT_HEIGHT_8                                  0x00000003
#define NV096_SET_SURFACE_FORMAT_HEIGHT_16                                 0x00000004
#define NV096_SET_SURFACE_FORMAT_HEIGHT_32                                 0x00000005
#define NV096_SET_SURFACE_FORMAT_HEIGHT_64                                 0x00000006
#define NV096_SET_SURFACE_FORMAT_HEIGHT_128                                0x00000007
#define NV096_SET_SURFACE_FORMAT_HEIGHT_256                                0x00000008
#define NV096_SET_SURFACE_FORMAT_HEIGHT_512                                0x00000009
#define NV096_SET_SURFACE_FORMAT_HEIGHT_1024                               0x0000000A
#define NV096_SET_SURFACE_FORMAT_HEIGHT_2048                               0x0000000B


#define NV096_SET_SURFACE_PITCH                                            0x0000020c
#define NV096_SET_SURFACE_PITCH_COLOR                                            15:0
#define NV096_SET_SURFACE_PITCH_ZETA                                            31:16


#define NV096_SET_SURFACE_COLOR_OFFSET                                     0x00000210
#define NV096_SET_SURFACE_COLOR_OFFSET_V                                         31:0


#define NV096_SET_SURFACE_ZETA_OFFSET                                      0x00000214
#define NV096_SET_SURFACE_ZETA_OFFSET_V                                          31:0


#define NV096_SET_TEXTURE_OFFSET(i)                                (0x00000218+(i)*4)
#define NV096_SET_TEXTURE_OFFSET_V                                               31:0


#define NV096_SET_TEXTURE_FORMAT(i)                                (0x00000220+(i)*4)
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA                                      1:0
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                   2:2
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                      0x00000000
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                       0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH                                       4:3
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER                         0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH                                       6:5
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER                         0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_COLOR                                           11:7
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_Y8                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_AY8                              0x00000001
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                         0x00000003
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                         0x00000004
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5                           0x00000005
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000006
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8                         0x00000007
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5                      0x00000008
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5                        0x00000009
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4                      0x0000000A
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8                      0x0000000B
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5                    0x0000000C
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8                   0x0000000E
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8                   0x0000000F
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5                   0x00000010
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5                     0x00000011
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8                   0x00000012
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8                         0x00000013
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8                        0x00000014
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9                      0x00000015
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8                       0x00000016
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8                       0x00000017
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8                     0x00000018
#define NV096_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                  15:12
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U                                    19:16
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                             0x00000000
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                             0x00000003
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                            0x00000004
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                            0x00000005
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                            0x00000006
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                           0x00000007
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                           0x00000008
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                           0x00000009
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                          0x0000000A
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                          0x0000000B
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V                                    23:20
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                             0x00000000
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                             0x00000003
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                            0x00000004
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                            0x00000005
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                            0x00000006
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                           0x00000007
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                           0x00000008
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                           0x00000009
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                          0x0000000A
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                          0x0000000B
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU                                26:24
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP                      0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR                    0x00000002
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP                     0x00000003
#define NV096_SET_TEXTURE_FORMAT_WRAPU                                          27:27
#define NV096_SET_TEXTURE_FORMAT_WRAPU_FALSE                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_WRAPU_TRUE                                0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV                                30:28
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP                      0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR                    0x00000002
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP                     0x00000003
#define NV096_SET_TEXTURE_FORMAT_WRAPV                                          31:31
#define NV096_SET_TEXTURE_FORMAT_WRAPV_FALSE                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_WRAPV_TRUE                                0x00000001


#define NV096_SET_TEXTURE_CONTROL0(i)                              (0x00000228+(i)*4)
#define NV096_SET_TEXTURE_CONTROL0_ENABLE                                       30:30
#define NV096_SET_TEXTURE_CONTROL0_ENABLE_FALSE                            0x00000000
#define NV096_SET_TEXTURE_CONTROL0_ENABLE_TRUE                             0x00000001
#define NV096_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                                29:18
#define NV096_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                 17:6
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                  5:4
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                         0x00000000
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                         0x00000001
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                             3:3
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE                0x00000000
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                 0x00000001
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                              2:2
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                 0x00000000
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                  0x00000001
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                            1:0
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE               0x00000000
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA               0x00000001
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA                0x00000002
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL                0x00000003


#define NV096_SET_TEXTURE_CONTROL1(i)                              (0x00000230+(i)*4)
#define NV096_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                  31:16
#define NV096_SET_TEXTURE_CONTROL1_ZERO                                          15:0


#define NV096_SET_TEXTURE_CONTROL2(i)                              (0x00000238+(i)*4)
#define NV096_SET_TEXTURE_CONTROL2_PERTURB_DU                                    11:0
#define NV096_SET_TEXTURE_CONTROL2_PERTURB_DV                                   23:12
#define NV096_SET_TEXTURE_CONTROL2_IMAGE_LODF                                   31:24


#define NV096_SET_TEXTURE_IMAGE_RECT(i)                            (0x00000240+(i)*4)
#define NV096_SET_TEXTURE_IMAGE_RECT_WIDTH                                      31:16
#define NV096_SET_TEXTURE_IMAGE_RECT_HEIGHT                                      15:0


#define NV096_SET_TEXTURE_FILTER(i)                                (0x00000248+(i)*4)
#define NV096_SET_TEXTURE_FILTER_MIPMAPLODBIAS                                   23:0
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN                                     27:24
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST                        0x00000001
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR                         0x00000002
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST                     0x00000003
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR                      0x00000004
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST               0x00000005
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR                0x00000006
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG                                     31:28
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST                        0x00000001
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR                         0x00000002


#define NV096_SET_TEXTURE_PALETTE(i)                               (0x00000250+(i)*4)
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA                                     5:0
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                            0x00000000
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                            0x00000001
#define NV096_SET_TEXTURE_PALETTE_PALETTE_OFFSET                                 31:6


#define NV096_SET_COMBINER_ALPHA_ICW(i)                            (0x00000260+(i)*4)
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP                                      31:29
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA                                    28:28
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE                                   27:24
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP                                      23:21
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA                                    20:20
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE                                   19:16
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP                                      15:13
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA                                    12:12
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE                                    11:8
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP                                        7:5
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA                                      4:4
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE                                     3:0
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV096_SET_COMBINER_COLOR_ICW(i)                            (0x00000268+(i)*4)
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP                                      31:29
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA                                    28:28
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE                                   27:24
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP                                      23:21
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA                                    20:20
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE                                   19:16
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP                                      15:13
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA                                    12:12
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE                                    11:8
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP                                        7:5
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA                                      4:4
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE                                     3:0
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV096_SET_COMBINE_FACTOR(i)                                (0x00000270+(i)*4)
#define NV096_SET_COMBINE_FACTOR_BLUE                                             7:0
#define NV096_SET_COMBINE_FACTOR_GREEN                                           15:8
#define NV096_SET_COMBINE_FACTOR_RED                                            23:16
#define NV096_SET_COMBINE_FACTOR_ALPHA                                          31:24


#define NV096_SET_COMBINER_ALPHA_OCW(i)                            (0x00000278+(i)*4)
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION                                  31:15
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                     0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS                0x00000001
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1                0x00000002
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS           0x00000003
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2                0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1               0x00000006
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                 14:14
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                      0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                       0x00000001
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST                                     11:8
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST                                       7:4
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                          0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                          0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                          0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                          0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                          0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                          0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                          0x0000000D
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST                                       3:0
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                          0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                          0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                          0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                          0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                          0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                          0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                          0x0000000D


#define NV096_SET_COMBINER0_COLOR_OCW                                      0x00000280
#define NV096_SET_COMBINER0_COLOR_OCW_ZERO                                      31:27
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION                                 26:15
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE                                14:14
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST                                    11:8
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST                                      7:4
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST                                      3:0
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV096_SET_COMBINER1_COLOR_OCW                                      0x00000284
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT                           31:28
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE                  0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO                  0x00000002
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT                                27:27
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB                       0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB                       0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION                                 26:15
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE                                14:14
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST                                    11:8
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST                                      7:4
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST                                      3:0
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV096_SET_COMBINER_SPECULAR_FOG_CW0                                0x00000288
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                           31:29
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                             28:28
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                            27:24
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                           23:21
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                             20:20
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                            19:16
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                           15:13
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                             12:12
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                             11:8
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                             7:5
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                               4:4
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                              3:0
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD           0x0000000F


#define NV096_SET_COMBINER_SPECULAR_FOG_CW1                                0x0000028c
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                           31:29
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                             28:28
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                            27:24
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                           23:21
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                             20:20
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                            19:16
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                           15:13
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                             12:12
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                             11:8
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                        7:7
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE           0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE            0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5                6:6
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE   0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE    0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12               5:0
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE   0x00000020


#define NV096_SET_CONTROL0                                                 0x00000290
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA                                   31:24
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                        0x00000000
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                         0x00000001
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE                                   23:20
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                        0x00000000
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                         0x00000001
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                 19:16
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                      0x00000000
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                       0x00000001
#define NV096_SET_CONTROL0_Z_FORMAT                                             15:12
#define NV096_SET_CONTROL0_Z_FORMAT_FIXED                                  0x00000000
#define NV096_SET_CONTROL0_Z_FORMAT_FLOAT                                  0x00000001
#define NV096_SET_CONTROL0_WBUFFER_SELECT                                        11:8
#define NV096_SET_CONTROL0_WBUFFER_SELECT_0                                0x00000000
#define NV096_SET_CONTROL0_WBUFFER_SELECT_1                                0x00000001
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE                                   7:0
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                       0x00000001


#define NV096_SET_LIGHT_CONTROL                                            0x00000294
#define NV096_SET_LIGHT_CONTROL_LOCALEYE                                        31:16
#define NV096_SET_LIGHT_CONTROL_LOCALEYE_FALSE                             0x00000000
#define NV096_SET_LIGHT_CONTROL_LOCALEYE_TRUE                              0x00000001
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE                                 15:2
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT                    0x00000000
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT                0x00000001
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                              1:1
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                 0x00000000
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                  0x00000001
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN                                0:0
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE                   0x00000000
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE                    0x00000001


#define NV096_SET_COLOR_MATERIAL                                           0x00000298
#define NV096_SET_COLOR_MATERIAL_V                                               31:0
#define NV096_SET_COLOR_MATERIAL_V_DISABLED                                0x00000000
#define NV096_SET_COLOR_MATERIAL_V_EMISSION                                0x00000001
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT                                 0x00000002
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT                        0x00000003
#define NV096_SET_COLOR_MATERIAL_V_DIFFUSE                                 0x00000004
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE                        0x00000005
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE                         0x00000006
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE                0x00000007
#define NV096_SET_COLOR_MATERIAL_V_SPECULAR                                0x00000008
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR                       0x00000009
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR                        0x0000000A
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR               0x0000000B
#define NV096_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR                        0x0000000C
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR               0x0000000D
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR                0x0000000E
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR       0x0000000F


#define NV096_SET_FOG_MODE                                                 0x0000029c
#define NV096_SET_FOG_MODE_FOG_MODE                                              31:0
#define NV096_SET_FOG_MODE_FOG_MODE_LINEAR                                 0x00002601
#define NV096_SET_FOG_MODE_FOG_MODE_EXP                                    0x00000800
#define NV096_SET_FOG_MODE_FOG_MODE_EXP2                                   0x00000801
#define NV096_SET_FOG_MODE_FOG_MODE_EXP_ABS                                0x00000802
#define NV096_SET_FOG_MODE_FOG_MODE_EXP2_ABS                               0x00000803


#define NV096_SET_FOG_GEN_MODE                                             0x000002a0
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE                                      31:0
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT                      0x00000000
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL                         0x00000001
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR                         0x00000002
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR                     0x00000003


#define NV096_SET_FOG_ENABLE                                               0x000002a4
#define NV096_SET_FOG_ENABLE_V                                                   31:0
#define NV096_SET_FOG_ENABLE_V_FALSE                                       0x00000000
#define NV096_SET_FOG_ENABLE_V_TRUE                                        0x00000001


#define NV096_SET_FOG_COLOR                                               0x000002a8
#define NV096_SET_FOG_COLOR_FOG_COLOR_RED                                        7:0
#define NV096_SET_FOG_COLOR_FOG_COLOR_GREEN                                     15:8
#define NV096_SET_FOG_COLOR_FOG_COLOR_BLUE                                     23:16
#define NV096_SET_FOG_COLOR_FOG_COLOR_ALPHA                                    31:24


#define NV096_SET_COLOR_KEY_COLOR(i)                               (0x000002ac+(i)*4)
#define NV096_SET_COLOR_KEY_COLOR_V                                              31:0


#define NV096_SET_WINDOW_CLIP_TYPE                                         0x000002b4
#define NV096_SET_WINDOW_CLIP_TYPE_V                                             31:0
#define NV096_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                             0x00000000
#define NV096_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                             0x00000001


#define NV096_SET_WINDOW_CLIP_HORIZONTAL(i)                        (0x000002c0+(i)*4)
#define NV096_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                    15:0
#define NV096_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                   31:16


#define NV096_SET_WINDOW_CLIP_VERTICAL(i)                          (0x000002e0+(i)*4)
#define NV096_SET_WINDOW_CLIP_VERTICAL_YMIN                                      15:0
#define NV096_SET_WINDOW_CLIP_VERTICAL_YMAX                                     31:16


#define NV096_SET_ALPHA_TEST_ENABLE                                        0x00000300
#define NV096_SET_ALPHA_TEST_ENABLE_V                                            31:0
#define NV096_SET_ALPHA_TEST_ENABLE_V_FALSE                                0x00000000
#define NV096_SET_ALPHA_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV096_SET_BLEND_ENABLE                                             0x00000304
#define NV096_SET_BLEND_ENABLE_V                                                 31:0
#define NV096_SET_BLEND_ENABLE_V_FALSE                                     0x00000000
#define NV096_SET_BLEND_ENABLE_V_TRUE                                      0x00000001


#define NV096_SET_CULL_FACE_ENABLE                                         0x00000308
#define NV096_SET_CULL_FACE_ENABLE_V                                             31:0
#define NV096_SET_CULL_FACE_ENABLE_V_FALSE                                 0x00000000
#define NV096_SET_CULL_FACE_ENABLE_V_TRUE                                  0x00000001


#define NV096_SET_DEPTH_TEST_ENABLE                                        0x0000030c
#define NV096_SET_DEPTH_TEST_ENABLE_V                                            31:0
#define NV096_SET_DEPTH_TEST_ENABLE_V_FALSE                                0x00000000
#define NV096_SET_DEPTH_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV096_SET_DITHER_ENABLE                                            0x00000310
#define NV096_SET_DITHER_ENABLE_V                                                31:0
#define NV096_SET_DITHER_ENABLE_V_FALSE                                    0x00000000
#define NV096_SET_DITHER_ENABLE_V_TRUE                                     0x00000001


#define NV096_SET_LIGHTING_ENABLE                                          0x00000314
#define NV096_SET_LIGHTING_ENABLE_V                                              31:0
#define NV096_SET_LIGHTING_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_LIGHTING_ENABLE_V_TRUE                                   0x00000001


#define NV096_SET_POINT_PARAMS_ENABLE                                      0x00000318
#define NV096_SET_POINT_PARAMS_ENABLE_V                                          31:0
#define NV096_SET_POINT_PARAMS_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_POINT_PARAMS_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_POINT_SMOOTH_ENABLE                                      0x0000031c
#define NV096_SET_POINT_SMOOTH_ENABLE_V                                          31:0
#define NV096_SET_POINT_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_POINT_SMOOTH_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_LINE_SMOOTH_ENABLE                                       0x00000320
#define NV096_SET_LINE_SMOOTH_ENABLE_V                                           31:0
#define NV096_SET_LINE_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV096_SET_LINE_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV096_SET_POLY_SMOOTH_ENABLE                                       0x00000324
#define NV096_SET_POLY_SMOOTH_ENABLE_V                                           31:0
#define NV096_SET_POLY_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV096_SET_POLY_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV096_SET_SKIN_ENABLE                                              0x00000328
#define NV096_SET_SKIN_ENABLE_V                                                  31:0
#define NV096_SET_SKIN_ENABLE_V_FALSE                                      0x00000000
#define NV096_SET_SKIN_ENABLE_V_TRUE                                       0x00000001


#define NV096_SET_STENCIL_TEST_ENABLE                                      0x0000032c
#define NV096_SET_STENCIL_TEST_ENABLE_V                                          31:0
#define NV096_SET_STENCIL_TEST_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_STENCIL_TEST_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_POLY_OFFSET_POINT_ENABLE                                 0x00000330
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V                                     31:0
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                         0x00000000
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                          0x00000001


#define NV096_SET_POLY_OFFSET_LINE_ENABLE                                  0x00000334
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V                                      31:0
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                          0x00000000
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                           0x00000001


#define NV096_SET_POLY_OFFSET_FILL_ENABLE                                  0x00000338
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V                                      31:0
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                          0x00000000
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                           0x00000001


#define NV096_SET_ALPHA_FUNC                                               0x0000033c
#define NV096_SET_ALPHA_FUNC_V                                                   31:0
#define NV096_SET_ALPHA_FUNC_V_NEVER                                       0x00000200
#define NV096_SET_ALPHA_FUNC_V_LESS                                        0x00000201
#define NV096_SET_ALPHA_FUNC_V_EQUAL                                       0x00000202
#define NV096_SET_ALPHA_FUNC_V_LEQUAL                                      0x00000203
#define NV096_SET_ALPHA_FUNC_V_GREATER                                     0x00000204
#define NV096_SET_ALPHA_FUNC_V_NOTEQUAL                                    0x00000205
#define NV096_SET_ALPHA_FUNC_V_GEQUAL                                      0x00000206
#define NV096_SET_ALPHA_FUNC_V_ALWAYS                                      0x00000207


#define NV096_SET_ALPHA_REF                                                0x00000340


#define NV096_SET_BLEND_FUNC_SFACTOR                                       0x00000344
#define NV096_SET_BLEND_FUNC_SFACTOR_V                                           31:0
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ZERO                                0x00000000
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE                                 0x00000001
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                           0x00000300
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                           0x00000302
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV096_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                           0x00000304
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV096_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                           0x00000306
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                  0x00000308
#define NV096_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV096_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV096_SET_BLEND_FUNC_DFACTOR                                       0x00000348
#define NV096_SET_BLEND_FUNC_DFACTOR_V                                           31:0
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ZERO                                0x00000000
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE                                 0x00000001
#define NV096_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                           0x00000300
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV096_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                           0x00000302
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV096_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                           0x00000304
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV096_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                           0x00000306
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV096_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV096_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV096_SET_BLEND_COLOR                                              0x0000034c
#define NV096_SET_BLEND_COLOR_V                                                  31:0


#define NV096_SET_BLEND_EQUATION                                           0x00000350
#define NV096_SET_BLEND_EQUATION_V                                               31:0
#define NV096_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                           0x0000800A
#define NV096_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                   0x0000800B
#define NV096_SET_BLEND_EQUATION_V_FUNC_ADD                                0x00008006
#define NV096_SET_BLEND_EQUATION_V_MIN                                     0x00008007
#define NV096_SET_BLEND_EQUATION_V_MAX                                     0x00008008


#define NV096_SET_DEPTH_FUNC                                               0x00000354
#define NV096_SET_DEPTH_FUNC_V                                                   31:0
#define NV096_SET_DEPTH_FUNC_V_NEVER                                       0x00000200
#define NV096_SET_DEPTH_FUNC_V_LESS                                        0x00000201
#define NV096_SET_DEPTH_FUNC_V_EQUAL                                       0x00000202
#define NV096_SET_DEPTH_FUNC_V_LEQUAL                                      0x00000203
#define NV096_SET_DEPTH_FUNC_V_GREATER                                     0x00000204
#define NV096_SET_DEPTH_FUNC_V_NOTEQUAL                                    0x00000205
#define NV096_SET_DEPTH_FUNC_V_GEQUAL                                      0x00000206
#define NV096_SET_DEPTH_FUNC_V_ALWAYS                                      0x00000207


#define NV096_SET_COLOR_MASK                                               0x00000358
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                 31:24
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                       0x00000001
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE                                   23:16
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                        0x00000000
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                         0x00000001
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                  15:8
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                       0x00000001
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                    7:0
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                       0x00000000
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                        0x00000001


#define NV096_SET_DEPTH_MASK                                               0x0000035c
#define NV096_SET_DEPTH_MASK_V                                                   31:0
#define NV096_SET_DEPTH_MASK_V_FALSE                                       0x00000000
#define NV096_SET_DEPTH_MASK_V_TRUE                                        0x00000001


#define NV096_SET_STENCIL_MASK                                             0x00000360
#define NV096_SET_STENCIL_MASK_V                                                 31:0


#define NV096_SET_STENCIL_FUNC                                             0x00000364
#define NV096_SET_STENCIL_FUNC_V                                                 31:0
#define NV096_SET_STENCIL_FUNC_V_NEVER                                     0x00000200
#define NV096_SET_STENCIL_FUNC_V_LESS                                      0x00000201
#define NV096_SET_STENCIL_FUNC_V_EQUAL                                     0x00000202
#define NV096_SET_STENCIL_FUNC_V_LEQUAL                                    0x00000203
#define NV096_SET_STENCIL_FUNC_V_GREATER                                   0x00000204
#define NV096_SET_STENCIL_FUNC_V_NOTEQUAL                                  0x00000205
#define NV096_SET_STENCIL_FUNC_V_GEQUAL                                    0x00000206
#define NV096_SET_STENCIL_FUNC_V_ALWAYS                                    0x00000207


#define NV096_SET_STENCIL_FUNC_REF                                         0x00000368
#define NV096_SET_STENCIL_FUNC_REF_V                                             31:0


#define NV096_SET_STENCIL_FUNC_MASK                                        0x0000036c
#define NV096_SET_STENCIL_FUNC_MASK_V                                            31:0


#define NV096_SET_STENCIL_OP_FAIL                                          0x00000370
#define NV096_SET_STENCIL_OP_FAIL_V                                              31:0
#define NV096_SET_STENCIL_OP_FAIL_V_KEEP                                   0x00001E00
#define NV096_SET_STENCIL_OP_FAIL_V_ZERO                                   0x00000000
#define NV096_SET_STENCIL_OP_FAIL_V_REPLACE                                0x00001E01
#define NV096_SET_STENCIL_OP_FAIL_V_INCRSAT                                0x00001E02
#define NV096_SET_STENCIL_OP_FAIL_V_DECRSAT                                0x00001E03
#define NV096_SET_STENCIL_OP_FAIL_V_INVERT                                 0x0000150A
#define NV096_SET_STENCIL_OP_FAIL_V_INCR                                   0x00008507
#define NV096_SET_STENCIL_OP_FAIL_V_DECR                                   0x00008508


#define NV096_SET_STENCIL_OP_ZFAIL                                         0x00000374
#define NV096_SET_STENCIL_OP_ZFAIL_V                                             31:0
#define NV096_SET_STENCIL_OP_ZFAIL_V_KEEP                                  0x00001E00
#define NV096_SET_STENCIL_OP_ZFAIL_V_ZERO                                  0x00000000
#define NV096_SET_STENCIL_OP_ZFAIL_V_REPLACE                               0x00001E01
#define NV096_SET_STENCIL_OP_ZFAIL_V_INCRSAT                               0x00001E02
#define NV096_SET_STENCIL_OP_ZFAIL_V_DECRSAT                               0x00001E03
#define NV096_SET_STENCIL_OP_ZFAIL_V_INVERT                                0x0000150A
#define NV096_SET_STENCIL_OP_ZFAIL_V_INCR                                  0x00008507
#define NV096_SET_STENCIL_OP_ZFAIL_V_DECR                                  0x00008508


#define NV096_SET_STENCIL_OP_ZPASS                                         0x00000378
#define NV096_SET_STENCIL_OP_ZPASS_V                                             31:0
#define NV096_SET_STENCIL_OP_ZPASS_V_KEEP                                  0x00001E00
#define NV096_SET_STENCIL_OP_ZPASS_V_ZERO                                  0x00000000
#define NV096_SET_STENCIL_OP_ZPASS_V_REPLACE                               0x00001E01
#define NV096_SET_STENCIL_OP_ZPASS_V_INCRSAT                               0x00001E02
#define NV096_SET_STENCIL_OP_ZPASS_V_DECRSAT                               0x00001E03
#define NV096_SET_STENCIL_OP_ZPASS_V_INVERT                                0x0000150A
#define NV096_SET_STENCIL_OP_ZPASS_V_INCR                                  0x00008507
#define NV096_SET_STENCIL_OP_ZPASS_V_DECR                                  0x00008508


#define NV096_SET_SHADE_MODE                                               0x0000037c
#define NV096_SET_SHADE_MODE_V                                                   31:0
#define NV096_SET_SHADE_MODE_V_FLAT                                        0x00001D00
#define NV096_SET_SHADE_MODE_V_SMOOTH                                      0x00001D01


#define NV096_SET_LINE_WIDTH                                               0x00000380
#define NV096_SET_LINE_WIDTH_V                                                   31:0


#define NV096_SET_POLYGON_OFFSET_SCALE_FACTOR                              0x00000384
#define NV096_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                  31:0


#define NV096_SET_POLYGON_OFFSET_BIAS                                      0x00000388
#define NV096_SET_POLYGON_OFFSET_BIAS_V                                          31:0


#define NV096_SET_FRONT_POLYGON_MODE                                       0x0000038c
#define NV096_SET_FRONT_POLYGON_MODE_V                                           31:0
#define NV096_SET_FRONT_POLYGON_MODE_V_POINT                               0x00001B00
#define NV096_SET_FRONT_POLYGON_MODE_V_LINE                                0x00001B01
#define NV096_SET_FRONT_POLYGON_MODE_V_FILL                                0x00001B02


#define NV096_SET_BACK_POLYGON_MODE                                        0x00000390
#define NV096_SET_BACK_POLYGON_MODE_V                                            31:0
#define NV096_SET_BACK_POLYGON_MODE_V_POINT                                0x00001B00
#define NV096_SET_BACK_POLYGON_MODE_V_LINE                                 0x00001B01
#define NV096_SET_BACK_POLYGON_MODE_V_FILL                                 0x00001B02


#define NV096_SET_CLIP_MIN                                                 0x00000394
#define NV096_SET_CLIP_MIN_V                                                     31:0


#define NV096_SET_CLIP_MAX                                                 0x00000398
#define NV096_SET_CLIP_MAX_V                                                     31:0


#define NV096_SET_CULL_FACE                                                0x0000039c
#define NV096_SET_CULL_FACE_V                                                    31:0
#define NV096_SET_CULL_FACE_V_FRONT                                        0x00000404
#define NV096_SET_CULL_FACE_V_BACK                                         0x00000405
#define NV096_SET_CULL_FACE_V_FRONT_AND_BACK                               0x00000408


#define NV096_SET_FRONT_FACE                                               0x000003a0
#define NV096_SET_FRONT_FACE_V                                                   31:0
#define NV096_SET_FRONT_FACE_V_CW                                          0x00000900
#define NV096_SET_FRONT_FACE_V_CCW                                         0x00000901


#define NV096_SET_NORMALIZATION_ENABLE                                     0x000003a4
#define NV096_SET_NORMALIZATION_ENABLE_V                                         31:0
#define NV096_SET_NORMALIZATION_ENABLE_V_FALSE                             0x00000000
#define NV096_SET_NORMALIZATION_ENABLE_V_TRUE                              0x00000001


#define NV096_SET_MATERIAL_EMISSION(i)                             (0x000003a8+(i)*4)


#define NV096_SET_MATERIAL_ALPHA                                           0x000003b4


#define NV096_SET_SPECULAR_ENABLE                                          0x000003b8
#define NV096_SET_SPECULAR_ENABLE_V                                              31:0
#define NV096_SET_SPECULAR_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_SPECULAR_ENABLE_V_TRUE                                   0x00000001


#define NV096_SET_LIGHT_ENABLE_MASK                                        0x000003bc
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0                                        1:0
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1                                        3:2
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2                                        5:4
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3                                        7:6
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4                                        9:8
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5                                      11:10
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6                                      13:12
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7                                      15:14
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                            0x00000003


#define NV096_SET_TEXGEN_S(i)                                     (0x000003c0+(i)*16)
#define NV096_SET_TEXGEN_S_V                                                     31:0
#define NV096_SET_TEXGEN_S_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_S_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_S_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_S_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_S_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_S_V_SPHERE_MAP                                    0x00002402
#define NV096_SET_TEXGEN_S_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_T(i)                                     (0x000003c4+(i)*16)
#define NV096_SET_TEXGEN_T_V                                                     31:0
#define NV096_SET_TEXGEN_T_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_T_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_T_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_T_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_T_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_T_V_SPHERE_MAP                                    0x00002402
#define NV096_SET_TEXGEN_T_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_R(i)                                     (0x000003c8+(i)*16)
#define NV096_SET_TEXGEN_R_V                                                     31:0
#define NV096_SET_TEXGEN_R_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_R_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_R_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_R_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_R_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_R_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_Q(i)                                     (0x000003cc+(i)*16)
#define NV096_SET_TEXGEN_Q_V                                                     31:0
#define NV096_SET_TEXGEN_Q_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_Q_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_Q_V_OBJECT_LINEAR                                 0x00002401


#define NV096_SET_TEXTURE_MATRIX0_ENABLE                                   0x000003e0
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V                                       31:0
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE                           0x00000000
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE                            0x00000001


#define NV096_SET_TEXTURE_MATRIX1_ENABLE                                   0x000003e4
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V                                       31:0
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE                           0x00000000
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE                            0x00000001


#define NV096_SET_TLMODE                                                   0x000003e8
#define NV096_SET_TLMODE_PASSTHROUGH                                              0:0
#define NV096_SET_TLMODE_PASSTHROUGH_TRUE                                  0x00000001
#define NV096_SET_TLMODE_PASSTHROUGH_FALSE                                 0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_0                                               1:1
#define NV096_SET_TLMODE_W_DIVIDE_0_DISABLE                                0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_0_ENABLE                                 0x00000001
#define NV096_SET_TLMODE_W_DIVIDE_1                                               2:2
#define NV096_SET_TLMODE_W_DIVIDE_1_DISABLE                                0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_1_ENABLE                                 0x00000001


#define NV096_SET_POINT_SIZE                                               0x000003ec
#define NV096_SET_POINT_SIZE_V                                                   31:0


#define NV096_SET_SWATH_WIDTH                                              0x000003f0
#define NV096_SET_SWATH_WIDTH_V                                                  31:0
#define NV096_SET_SWATH_WIDTH_V_8                                          0x00000000
#define NV096_SET_SWATH_WIDTH_V_16                                         0x00000001
#define NV096_SET_SWATH_WIDTH_V_32                                         0x00000002
#define NV096_SET_SWATH_WIDTH_V_64                                         0x00000003


#define NV096_SET_FLAT_SHADE_OP                                            0x000003f4
#define NV096_SET_FLAT_SHADE_OP_V                                                31:0
#define NV096_SET_FLAT_SHADE_OP_V_LAST_VTX                                 0x00000000
#define NV096_SET_FLAT_SHADE_OP_V_FIRST_VTX                                0x00000001


#define NV096_SET_MODEL_VIEW_MATRIX0(i)                            (0x00000400+(i)*4)


#define NV096_SET_MODEL_VIEW_MATRIX1(i)                            (0x00000440+(i)*4)


#define NV096_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                    (0x00000480+(i)*4)


#define NV096_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                    (0x000004c0+(i)*4)


#define NV096_SET_COMPOSITE_MATRIX(i)                              (0x00000500+(i)*4)


#define NV096_SET_TEXTURE_MATRIX0(i)                               (0x00000540+(i)*4)


#define NV096_SET_TEXTURE_MATRIX1(i)                               (0x00000580+(i)*4)


#define NV096_SET_TEXGEN_SPLANE0(i)                                (0x00000600+(i)*4)


#define NV096_SET_TEXGEN_TPLANE0(i)                                (0x00000610+(i)*4)


#define NV096_SET_TEXGEN_RPLANE0(i)                                (0x00000620+(i)*4)


#define NV096_SET_TEXGEN_QPLANE0(i)                                (0x00000630+(i)*4)


#define NV096_SET_TEXGEN_SPLANE1(i)                                (0x00000640+(i)*4)


#define NV096_SET_TEXGEN_TPLANE1(i)                                (0x00000650+(i)*4)


#define NV096_SET_TEXGEN_RPLANE1(i)                                (0x00000660+(i)*4)


#define NV096_SET_TEXGEN_QPLANE1(i)                                (0x00000670+(i)*4)


#define NV096_SET_FOG_PARAMS(i)                                    (0x00000680+(i)*4)


#define NV096_SET_FOG_PLANE(i)                                     (0x0000068c+(i)*4)


#define NV096_SET_SPECULAR_PARAMS(i)                               (0x000006a0+(i)*4)


#define NV096_SET_SCENE_AMBIENT_COLOR(i)                           (0x000006c4+(i)*4)


#define NV096_SET_VIEWPORT_OFFSET(i)                               (0x000006e8+(i)*4)


#define NV096_SET_POINT_PARAMS(i)                                  (0x000006f8+(i)*4)


#define NV096_SET_EYE_POSITION(i)                                  (0x00000718+(i)*4)

#define NV096_SET_EYE_DIRECTION_SW(i)                              (0x0000072c+(i)*4)


#define NV096_SET_LIGHT_AMBIENT_COLOR(i,j)                 (0x00000800+(i)*128+(j)*4)


#define NV096_SET_LIGHT_DIFFUSE_COLOR(i,j)                 (0x0000080c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPECULAR_COLOR(i,j)                (0x00000818+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_RANGE(i)                           (0x00000824+(i)*128)


#define NV096_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)          (0x00000828+(i)*128+(j)*4)


#define NV096_SET_LIGHT_INFINITE_DIRECTION(i,j)            (0x00000834+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPOT_FALLOFF(i,j)                  (0x00000840+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPOT_DIRECTION(i,j)                (0x0000084c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_POSITION(i,j)                (0x0000085c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_ATTENUATION(i,j)             (0x00000868+(i)*128+(j)*4)


#define NV096_SET_VERTEX3F(i)                                      (0x00000c00+(i)*4)


#define NV096_SET_VERTEX4F(i)                                      (0x00000c18+(i)*4)


#define NV096_SET_VERTEX4S(i)                                      (0x00000c28+(i)*4)


#define NV096_SET_NORMAL3F(i)                                      (0x00000c30+(i)*4)


#define NV096_SET_NORMAL3S(i)                                      (0x00000c40+(i)*2)


#define NV096_SET_DIFFUSE_COLOR4F(i)                               (0x00000c50+(i)*4)


#define NV096_SET_DIFFUSE_COLOR3F(i)                               (0x00000c60+(i)*4)


#define NV096_SET_DIFFUSE_COLOR4UB                                         0x00000c6c


#define NV096_SET_SPECULAR_COLOR4F(i)                              (0x00000c70+(i)*4)


#define NV096_SET_SPECULAR_COLOR3F(i)                              (0x00000c80+(i)*4)


#define NV096_SET_SPECULAR_COLOR4UB                                        0x00000c8c


#define NV096_SET_TEXCOORD0_2F(i)                                  (0x00000c90+(i)*4)


#define NV096_SET_TEXCOORD0_2S(i)                                  (0x00000c98+(i)*2)


#define NV096_SET_TEXCOORD0_4F(i)                                  (0x00000ca0+(i)*4)


#define NV096_SET_TEXCOORD0_4S(i)                                  (0x00000cb0+(i)*2)


#define NV096_SET_TEXCOORD1_2F(i)                                  (0x00000cb8+(i)*4)


#define NV096_SET_TEXCOORD1_2S(i)                                  (0x00000cc0+(i)*2)


#define NV096_SET_TEXCOORD1_4F(i)                                  (0x00000cc8+(i)*4)


#define NV096_SET_TEXCOORD1_4S(i)                                  (0x00000cd8+(i)*2)


#define NV096_SET_FOG1F                                                    0x00000ce0


#define NV096_SET_WEIGHT1F                                                 0x00000ce4


#define NV096_SET_EDGE_FLAG                                                0x00000cec


#define NV096_INVALIDATE_VERTEX_CACHE_FILE                                 0x00000cf0


#define NV096_INVALIDATE_VERTEX_FILE                                       0x00000cf4


#define NV096_TL_NOP                                                       0x00000cf8


#define NV096_TL_SYNC                                                      0x00000cfc


#define NV096_SET_VERTEX_ARRAY_OFFSET                                      0x00000d00
#define NV096_SET_VERTEX_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_VERTEX_ARRAY_FORMAT                                      0x00000d04
#define NV096_SET_VERTEX_ARRAY_FORMAT_W                                         31:24
#define NV096_SET_VERTEX_ARRAY_FORMAT_W_NONE                               0x00000000
#define NV096_SET_VERTEX_ARRAY_FORMAT_W_PRESENT                            0x00000001
#define NV096_SET_VERTEX_ARRAY_FORMAT_STRIDE                                     23:8
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_2                               0x00000002
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_4                               0x00000004
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_DIFFUSE_ARRAY_OFFSET                                     0x00000d08
#define NV096_SET_DIFFUSE_ARRAY_OFFSET_OFFSET                                    27:0


#define NV096_SET_DIFFUSE_ARRAY_FORMAT                                     0x00000d0c
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_STRIDE                                    31:8
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE                                       7:4
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4                              0x00000004
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE                                       3:0
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA             0x00000000
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA             0x00000004


#define NV096_SET_SPECULAR_ARRAY_OFFSET                                    0x00000d10
#define NV096_SET_SPECULAR_ARRAY_OFFSET_OFFSET                                   27:0


#define NV096_SET_SPECULAR_ARRAY_FORMAT                                    0x00000d14
#define NV096_SET_SPECULAR_ARRAY_FORMAT_STRIDE                                   31:8
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE                                      7:4
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_0                             0x00000000
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_3                             0x00000003
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_4                             0x00000004
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE                                      3:0
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA            0x00000000
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT                         0x00000002
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA            0x00000004


#define NV096_SET_TEX_COORD0_ARRAY_OFFSET                                  0x00000d18
#define NV096_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET                                 27:0


#define NV096_SET_TEX_COORD0_ARRAY_FORMAT                                  0x00000d1c
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE                                 31:8
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE                                    7:4
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE                                    3:0
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV096_SET_TEX_COORD1_ARRAY_OFFSET                                  0x00000d20
#define NV096_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET                                 27:0


#define NV096_SET_TEX_COORD1_ARRAY_FORMAT                                  0x00000d24
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE                                 31:8
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE                                    7:4
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE                                    3:0
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV096_SET_NORMAL_ARRAY_OFFSET                                      0x00000d28
#define NV096_SET_NORMAL_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_NORMAL_ARRAY_FORMAT                                      0x00000d2c
#define NV096_SET_NORMAL_ARRAY_FORMAT_STRIDE                                     31:8
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_WEIGHT_ARRAY_OFFSET                                      0x00000d30
#define NV096_SET_WEIGHT_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_WEIGHT_ARRAY_FORMAT                                      0x00000d34
#define NV096_SET_WEIGHT_ARRAY_FORMAT_STRIDE                                     31:8
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE_1                               0x00000001
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_FOG_ARRAY_OFFSET                                         0x00000d38
#define NV096_SET_FOG_ARRAY_OFFSET_OFFSET                                        27:0


#define NV096_SET_FOG_ARRAY_FORMAT                                         0x00000d3c
#define NV096_SET_FOG_ARRAY_FORMAT_STRIDE                                        31:8
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE                                           7:4
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE_0                                  0x00000000
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE_1                                  0x00000001
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE                                           3:0
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE_SHORT                              0x00000001
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT                              0x00000002

#define NV096_SET_LOGIC_OP_ENABLE                                          0x00000d40
#define NV096_SET_LOGIC_OP_ENABLE_V                                              31:0
#define NV096_SET_LOGIC_OP_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_LOGIC_OP_ENABLE_V_TRUE                                   0x00000001

#define NV096_SET_LOGIC_OP                                                 0x00000d44
#define NV096_SET_LOGIC_OP_V                                                     31:0
#define NV096_SET_LOGIC_OP_V_CLEAR                                         0x00001500
#define NV096_SET_LOGIC_OP_V_AND                                           0x00001501
#define NV096_SET_LOGIC_OP_V_AND_REVERSE                                   0x00001502
#define NV096_SET_LOGIC_OP_V_COPY                                          0x00001503
#define NV096_SET_LOGIC_OP_V_AND_INVERTED                                  0x00001504
#define NV096_SET_LOGIC_OP_V_NOOP                                          0x00001505
#define NV096_SET_LOGIC_OP_V_XOR                                           0x00001506
#define NV096_SET_LOGIC_OP_V_OR                                            0x00001507
#define NV096_SET_LOGIC_OP_V_NOR                                           0x00001508
#define NV096_SET_LOGIC_OP_V_EQUIV                                         0x00001509
#define NV096_SET_LOGIC_OP_V_INVERT                                        0x0000150a
#define NV096_SET_LOGIC_OP_V_OR_REVERSE                                    0x0000150b
#define NV096_SET_LOGIC_OP_V_COPY_INVERTED                                 0x0000150c
#define NV096_SET_LOGIC_OP_V_OR_INVERTED                                   0x0000150d
#define NV096_SET_LOGIC_OP_V_NAND                                          0x0000150e
#define NV096_SET_LOGIC_OP_V_SET                                           0x0000150f

#define NV096_SET_BEGIN_END                                                0x00000dfc
#define NV096_SET_BEGIN_END_OP                                                   31:0
#define NV096_SET_BEGIN_END_OP_END                                         0x00000000
#define NV096_SET_BEGIN_END_OP_POINTS                                      0x00000001
#define NV096_SET_BEGIN_END_OP_LINES                                       0x00000002
#define NV096_SET_BEGIN_END_OP_LINE_LOOP                                   0x00000003
#define NV096_SET_BEGIN_END_OP_LINE_STRIP                                  0x00000004
#define NV096_SET_BEGIN_END_OP_TRIANGLES                                   0x00000005
#define NV096_SET_BEGIN_END_OP_TRIANGLE_STRIP                              0x00000006
#define NV096_SET_BEGIN_END_OP_TRIANGLE_FAN                                0x00000007
#define NV096_SET_BEGIN_END_OP_QUADS                                       0x00000008
#define NV096_SET_BEGIN_END_OP_QUAD_STRIP                                  0x00000009
#define NV096_SET_BEGIN_END_OP_POLYGON                                     0x0000000A


#define NV096_ARRAY_ELEMENT16(i)                                   (0x00000e00+(i)*2)


#define NV096_SET_BEGIN_END2                                               0x000010fc
#define NV096_SET_BEGIN_END2_OP                                                  31:0
#define NV096_SET_BEGIN_END2_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END2_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END2_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END2_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END2_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END2_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END2_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END2_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END2_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END2_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END2_OP_POLYGON                                    0x0000000A


#define NV096_ARRAY_ELEMENT32(i)                                   (0x00001100+(i)*4)


#define NV096_SET_BEGIN_END3                                               0x000013fc
#define NV096_SET_BEGIN_END3_OP                                                  31:0
#define NV096_SET_BEGIN_END3_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END3_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END3_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END3_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END3_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END3_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END3_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END3_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END3_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END3_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END3_OP_POLYGON                                    0x0000000A


#define NV096_DRAW_ARRAYS(i)                                       (0x00001400+(i)*4)
#define NV096_DRAW_ARRAYS_COUNT                                                 31:24
#define NV096_DRAW_ARRAYS_START_INDEX                                            23:0


/* These methods are accepted between a begin/end. */
#define NV096_SET_MATERIAL_EMISSION_SW(i)                          (0x00001628+(i)*4)
#define NV096_SET_VIEWPORT_OFFSET_SW(i)                            (0x00001638+(i)*4)
/* The PASSTHRU_VIEWPORT_OFFSET aliases to row 1 of the MODEL_VIEW_MATRIX1 */
#define NV096_SET_PASSTHRU_VIEWPORT_OFFSET_SW(i)                   (0x00001648+(i)*4)


#define NV096_SET_BEGIN_END4                                               0x000017fc
#define NV096_SET_BEGIN_END4_OP                                                  31:0
#define NV096_SET_BEGIN_END4_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END4_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END4_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END4_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END4_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END4_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END4_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END4_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END4_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END4_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END4_OP_POLYGON                                    0x0000000A


#define NV096_INLINE_ARRAY(i)                                      (0x00001800+(i)*4)



typedef NvV32 Nv1196Typedef;


/* class NV11_CELSIUS_PRIMITIVE */
#define  NV11_CELSIUS_PRIMITIVE                                    (0x00001196)
/* NvNotification[] elements */
#define NV1196_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV1196_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV1196_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV1196_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV1196_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV1196_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV1196_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved0004[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved0114[0xc/4];
    NvV32 SetFlipRead;
    NvV32 SetFlipWrite;
    NvV32 SetFlipModulo;
    NvV32 FlipIncrementWrite;
    NvV32 FlipStall;
    NvV32 Reserved0134[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved0144[0x3c/4];
    NvU32 SetContextDmaNotifies;
    NvU32 SetContextDmaA;
    NvU32 SetContextDmaB;
    NvU32 SetContextDmaVertex;
    NvU32 SetContextDmaState;
    NvU32 SetContextDmaColor;
    NvU32 SetContextDmaZeta;
    NvV32 Reserved019c[0x64/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvU32 SetTextureOffset[2];
    NvV32 SetTextureFormat[2];
    NvV32 SetTextureControl0[2];
    NvV32 SetTextureControl1[2];
    NvV32 SetTextureControl2[2];
    NvV32 SetTextureImageRect[2];
    NvV32 SetTextureFilter[2];
    NvV32 SetTexturePalette[2];
    NvV32 Reserved0258[0x8/4];
    NvV32 SetCombinerAlphaICW[2];
    NvV32 SetCombinerColorICW[2];
    NvV32 SetCombineFactor[2];
    NvV32 SetCombinerAlphaOCW[2];
    NvV32 SetCombiner0ColorOCW;
    NvV32 SetCombiner1ColorOCW;
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvU32 SetColorKeyColor[2];
    NvV32 SetWindowClipType;
    NvV32 Reserved02b8[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinEnable;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvU32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvU32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvU32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvU32 SetStencilFuncRef;
    NvU32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvU32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvF32 SetMaterialEmission[3];
    NvF32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
    NvV32 S;
    NvV32 T;
    NvV32 R;
    NvV32 Q;
    } SetTexgen[2];
    NvV32 SetTextureMatrix0Enable;
    NvV32 SetTextureMatrix1Enable;
    NvV32 SetTLMode;
    NvU32 SetPointSize;
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved03f8[0x8/4];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvV32 Reserved05c0[0x40/4];
    NvF32 SetTexgenSPlane0[4];
    NvF32 SetTexgenTPlane0[4];
    NvF32 SetTexgenRPlane0[4];
    NvF32 SetTexgenQPlane0[4];
    NvF32 SetTexgenSPlane1[4];
    NvF32 SetTexgenTPlane1[4];
    NvF32 SetTexgenRPlane1[4];
    NvF32 SetTexgenQPlane1[4];
    NvF32 SetFogParams[3];
    NvF32 SetFogPlane[4];
    NvV32 Reserved069c[0x4/4];
    NvF32 SetSpecularParams[6];
    NvV32 Reserved06b8[0xc/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved06d0[0x18/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 Flush;
    NvF32 SetEyeDirectionSW[3];
    NvV32 Reserved0738[0xc8/4];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvF32 LocalRange;
    NvF32 InfiniteHalfVector[3];
    NvF32 InfiniteDirection[3];
    NvF32 SpotFalloff[3];
    NvF32 SpotDirection[4];
    NvF32 LocalPosition[3];
    NvF32 LocalAttenuation[3];
    NvV32 Reserved0874[0xc/4];
    } SetLight[8];
    NvF32 SetVertex3f[3];
    NvV32 Reserved0c0c[0xc/4];
    NvF32 SetVertex4f[4];
    NvS32 SetVertex4s[2];
    NvF32 SetNormal3f[3];
    NvV32 Reserved0c3c[0x4/4];
    NvS32 SetNormal3s[2];
    NvV32 Reserved0c48[0x8/4];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvU32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvU32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS32 SetTexcoord0_2s;
    NvV32 Reserved0c9c[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS32 SetTexcoord0_4s[2];
    NvF32 SetTexcoord1_2f[2];
    NvS32 SetTexcoord1_2s;
    NvV32 Reserved0cc4[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS32 SetTexcoord1_4s[2];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvV32 Reserved0ce8[0x4/4];
    NvU32 SetEdgeFlag;
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvU32 SetVertexArrayOffset;
    NvV32 SetVertexArrayFormat;
    NvU32 SetDiffuseArrayOffset;
    NvV32 SetDiffuseArrayFormat;
    NvU32 SetSpecularArrayOffset;
    NvV32 SetSpecularArrayFormat;
    NvU32 SetTexCoord0ArrayOffset;
    NvV32 SetTexCoord0ArrayFormat;
    NvU32 SetTexCoord1ArrayOffset;
    NvV32 SetTexCoord1ArrayFormat;
    NvU32 SetNormalArrayOffset;
    NvV32 SetNormalArrayFormat;
    NvU32 SetWeightArrayOffset;
    NvV32 SetWeightArrayFormat;
    NvU32 SetFogArrayOffset;
    NvV32 SetFogArrayFormat;
    NvV32 SetLogicOpEnable;
    NvV32 SetLogicOp;
    NvV32 Reserved0d48[0xb4/4];
    NvV32 SetBeginEnd;
    NvV32 ArrayElement16[128];
    NvV32 Reserved1000[0xfc/4];
    NvV32 SetBeginEnd2;
    NvU32 ArrayElement32[64];
    NvV32 Reserved1200[0x1fc/4];
    NvV32 SetBeginEnd3;
    NvV32 DrawArrays[128];
    NvV32 DebugInit[10];
    NvV32 SetMaterialEmissionSW[3];
    NvV32 Reserved1634[1];
    NvF32 SetViewportOffsetSW[4];
    NvF32 SetPassthruViewportOffsetSW[4];
    NvV32 Reserved1648[0x1a4/4];
    NvV32 SetBeginEnd4;
    NvU32 InlineArray[512];
} Nv11CelsiusPrimitive;

#define NV1196_TYPEDEF                                      Nv11CelsiusPrimitive
#define NV1196_SET_OBJECT                                          (0x00000000)

#define NV1196_NO_OPERATION                                                0x00000100
#define NV1196_NO_OPERATION_V                                                    31:0

#define NV1196_FLUSH                                                       0x00000728
#define NV1196_FLUSH_V                                                           31:0

#define NV1196_NOTIFY                                                      0x00000104
#define NV1196_NOTIFY_TYPE                                                       31:0
#define NV1196_NOTIFY_TYPE_WRITE_ONLY                                      0x00000000
#define NV1196_NOTIFY_TYPE_WRITE_THEN_AWAKEN                               0x00000001

#define NV1196_SET_WARNING_ENABLE                                          0x00000108
#define NV1196_SET_WARNING_ENABLE_V                                              31:0
#define NV1196_SET_WARNING_ENABLE_V_STOP                                   0x00000000
#define NV1196_SET_WARNING_ENABLE_V_WRITE_ONLY                             0x00000001
#define NV1196_SET_WARNING_ENABLE_V_WRITE_THEN_AWAKEN                      0x00000002

#define NV1196_GET_STATE                                                   0x0000010c
#define NV1196_GET_STATE_GETSTATE                                                31:0
#define NV1196_GET_STATE_GETSTATE_ALL_STATE                                0x00000001
#define NV1196_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE                  0x00000002
#define NV1196_GET_STATE_GETSTATE_RENDERING_STATE                          0x00000003
#define NV1196_GET_STATE_GETSTATE_GEOMETRY_STATE                           0x00000004

#define NV1196_WAIT_FOR_IDLE                                               0x00000110
#define NV1196_WAIT_FOR_IDLE_V                                                   31:0

#define NV1196_PM_TRIGGER                                                  0x00000140
#define NV1196_PM_TRIGGER_V                                                      31:0
#define NV1196_PM_TRIGGER_V_NOP                                            0x00000000
#define NV1196_PM_TRIGGER_V_TRIGGER                                        0x00000001

#define NV1196_SET_FLIP_READ                                               0x00000120
#define NV1196_SET_FLIP_WRITE                                              0x00000124
#define NV1196_SET_FLIP_MODULO                                             0x00000128
#define NV1196_FLIP_INCREMENT_WRITE                                        0x0000012c
#define NV1196_FLIP_STALL                                                  0x00000130

#define NV1196_SET_CONTEXT_DMA_NOTIFIES                                    0x00000180
#define NV1196_SET_CONTEXT_DMA_NOTIFIES_V                                        31:0

#define NV1196_SET_CONTEXT_DMA_A                                           0x00000184
#define NV1196_SET_CONTEXT_DMA_A_V                                               31:0

#define NV1196_SET_CONTEXT_DMA_B                                           0x00000188
#define NV1196_SET_CONTEXT_DMA_B_V                                               31:0

#define NV1196_SET_CONTEXT_DMA_VERTEX                                      0x0000018c
#define NV1196_SET_CONTEXT_DMA_VERTEX_V                                          31:0

#define NV1196_SET_CONTEXT_DMA_STATE                                       0x00000190
#define NV1196_SET_CONTEXT_DMA_STATE_V                                           31:0

#define NV1196_SET_CONTEXT_DMA_COLOR                                       0x00000194
#define NV1196_SET_CONTEXT_DMA_COLOR_V                                           31:0

#define NV1196_SET_CONTEXT_DMA_ZETA                                        0x00000198
#define NV1196_SET_CONTEXT_DMA_ZETA_V                                            31:0

#define NV1196_SET_SURFACE_CLIP_HORIZONTAL                                 0x00000200
#define NV1196_SET_SURFACE_CLIP_HORIZONTAL_X                                     15:0
#define NV1196_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                31:16

#define NV1196_SET_SURFACE_CLIP_VERTICAL                                   0x00000204
#define NV1196_SET_SURFACE_CLIP_VERTICAL_Y                                       15:0
#define NV1196_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                 31:16

#define NV1196_SET_SURFACE_FORMAT                                          0x00000208
#define NV1196_SET_SURFACE_FORMAT_COLOR                                           7:0
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5               0x00000001
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5               0x00000002
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                          0x00000003
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8               0x00000004
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8               0x00000005
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8           0x00000006
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8           0x00000007
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                        0x00000008
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_B8                              0x00000009
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_G8B8                            0x0000000A
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1R5G5B5_Z1R5G5B5           0x00000011
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1R5G5B5_O1R5G5B5           0x00000012
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_R5G6B5                      0x00000013
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X8R8G8B8_Z8R8G8B8           0x00000014
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X8R8G8B8_O8R8G8B8           0x00000015
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1A7R8G8B8_Z1A7R8G8B8       0x00000016
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1A7R8G8B8_O1A7R8G8B8       0x00000017
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_A8R8G8B8                    0x00000018
#define NV1196_SET_SURFACE_FORMAT_TYPE                                           15:8
#define NV1196_SET_SURFACE_FORMAT_TYPE_PITCH                               0x00000001
#define NV1196_SET_SURFACE_FORMAT_TYPE_SWIZZLE                             0x00000002
#define NV1196_SET_SURFACE_FORMAT_WIDTH                                         23:16
#define NV1196_SET_SURFACE_FORMAT_WIDTH_1                                  0x00000000
#define NV1196_SET_SURFACE_FORMAT_WIDTH_2                                  0x00000001
#define NV1196_SET_SURFACE_FORMAT_WIDTH_4                                  0x00000002
#define NV1196_SET_SURFACE_FORMAT_WIDTH_8                                  0x00000003
#define NV1196_SET_SURFACE_FORMAT_WIDTH_16                                 0x00000004
#define NV1196_SET_SURFACE_FORMAT_WIDTH_32                                 0x00000005
#define NV1196_SET_SURFACE_FORMAT_WIDTH_64                                 0x00000006
#define NV1196_SET_SURFACE_FORMAT_WIDTH_128                                0x00000007
#define NV1196_SET_SURFACE_FORMAT_WIDTH_256                                0x00000008
#define NV1196_SET_SURFACE_FORMAT_WIDTH_512                                0x00000009
#define NV1196_SET_SURFACE_FORMAT_WIDTH_1024                               0x0000000A
#define NV1196_SET_SURFACE_FORMAT_WIDTH_2048                               0x0000000B
#define NV1196_SET_SURFACE_FORMAT_HEIGHT                                        31:24
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_1                                 0x00000000
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_2                                 0x00000001
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_4                                 0x00000002
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_8                                 0x00000003
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_16                                0x00000004
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_32                                0x00000005
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_64                                0x00000006
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_128                               0x00000007
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_256                               0x00000008
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_512                               0x00000009
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_1024                              0x0000000A
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_2048                              0x0000000B

#define NV1196_SET_SURFACE_PITCH                                           0x0000020c
#define NV1196_SET_SURFACE_PITCH_COLOR                                           15:0
#define NV1196_SET_SURFACE_PITCH_ZETA                                           31:16

#define NV1196_SET_SURFACE_COLOR_OFFSET                                    0x00000210
#define NV1196_SET_SURFACE_COLOR_OFFSET_V                                        31:0

#define NV1196_SET_SURFACE_ZETA_OFFSET                                     0x00000214
#define NV1196_SET_SURFACE_ZETA_OFFSET_V                                         31:0

#define NV1196_SET_TEXTURE_OFFSET(i)                               (0x00000218+(i)*4)
#define NV1196_SET_TEXTURE_OFFSET_V                                              31:0

#define NV1196_SET_TEXTURE_FORMAT(i)                               (0x00000220+(i)*4)
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA                                     1:0
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                  2:2
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                     0x00000000
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                      0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH                                      4:3
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER                        0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH                                      6:5
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER                        0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_COLOR                                          11:7
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_Y8                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_AY8                             0x00000001
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                        0x00000003
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                        0x00000004
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5                          0x00000005
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8                        0x00000006
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8                        0x00000007
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5                     0x00000008
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5                       0x00000009
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4                     0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8                     0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5                   0x0000000C
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8                  0x0000000E
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8                  0x0000000F
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5                  0x00000010
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5                    0x00000011
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8                  0x00000012
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8                        0x00000013
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8                       0x00000014
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9                     0x00000015
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8                      0x00000016
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8                      0x00000017
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8                    0x00000018
#define NV1196_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U                                   19:16
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                            0x00000000
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                            0x00000003
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                           0x00000004
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                           0x00000005
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                           0x00000006
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                          0x00000007
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                          0x00000008
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                          0x00000009
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                         0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                         0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V                                   23:20
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                            0x00000000
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                            0x00000003
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                           0x00000004
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                           0x00000005
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                           0x00000006
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                          0x00000007
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                          0x00000008
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                          0x00000009
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                         0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                         0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU                               26:24
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP                     0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR                   0x00000002
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP                    0x00000003
#define NV1196_SET_TEXTURE_FORMAT_WRAPU                                         27:27
#define NV1196_SET_TEXTURE_FORMAT_WRAPU_FALSE                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_WRAPU_TRUE                               0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV                               30:28
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP                     0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR                   0x00000002
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP                    0x00000003
#define NV1196_SET_TEXTURE_FORMAT_WRAPV                                         31:31
#define NV1196_SET_TEXTURE_FORMAT_WRAPV_FALSE                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_WRAPV_TRUE                               0x00000001

#define NV1196_SET_TEXTURE_CONTROL0(i)                             (0x00000228+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE                                      31:30
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE_FALSE                           0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE_TRUE                            0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                               29:18
#define NV1196_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                17:6
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                 5:4
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                        0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                        0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                            3:3
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE               0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                             2:2
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                 0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                           1:0
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE              0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA              0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA               0x00000002
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL               0x00000003

#define NV1196_SET_TEXTURE_CONTROL1(i)                             (0x00000230+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                 31:16

#define NV1196_SET_TEXTURE_CONTROL2(i)                             (0x00000238+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL2_PERTURB_DU                                   11:0
#define NV1196_SET_TEXTURE_CONTROL2_PERTURB_DV                                  23:12
#define NV1196_SET_TEXTURE_CONTROL2_IMAGE_LODF                                  31:24

#define NV1196_SET_TEXTURE_IMAGE_RECT(i)                           (0x00000240+(i)*4)
#define NV1196_SET_TEXTURE_IMAGE_RECT_WIDTH                                     31:16
#define NV1196_SET_TEXTURE_IMAGE_RECT_HEIGHT                                     15:0

#define NV1196_SET_TEXTURE_FILTER(i)                               (0x00000248+(i)*4)
#define NV1196_SET_TEXTURE_FILTER_MIPMAPLODBIAS                                  12:0
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN                                    27:24
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST                       0x00000001
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR                        0x00000002
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST                    0x00000003
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR                     0x00000004
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST              0x00000005
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR               0x00000006
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG                                    31:28
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST                       0x00000001
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR                        0x00000002

#define NV1196_SET_TEXTURE_PALETTE(i)                              (0x00000250+(i)*4)
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA                                    5:0
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                           0x00000000
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                           0x00000001
#define NV1196_SET_TEXTURE_PALETTE_PALETTE_OFFSET                                31:6

#define NV1196_SET_COMBINER_ALPHA_ICW(i)                           (0x00000260+(i)*4)
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP                                     31:29
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA                                   28:28
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE                                  27:24
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP                                     23:21
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA                                   20:20
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE                                  19:16
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP                                     15:13
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA                                   12:12
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE                                   11:8
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP                                       7:5
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA                                     4:4
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE                                    3:0
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                       0x0000000D

#define NV1196_SET_COMBINER_COLOR_ICW(i)                           (0x00000268+(i)*4)
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP                                     31:29
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA                                   28:28
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE                                  27:24
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP                                     23:21
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA                                   20:20
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE                                  19:16
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP                                     15:13
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA                                   12:12
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE                                   11:8
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP                                       7:5
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA                                     4:4
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE                                    3:0
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                       0x0000000D

#define NV1196_SET_COMBINE_FACTOR(i)                               (0x00000270+(i)*4)
#define NV1196_SET_COMBINE_FACTOR_BLUE                                            7:0
#define NV1196_SET_COMBINE_FACTOR_GREEN                                          15:8
#define NV1196_SET_COMBINE_FACTOR_RED                                           23:16
#define NV1196_SET_COMBINE_FACTOR_ALPHA                                         31:24

#define NV1196_SET_COMBINER_ALPHA_OCW(i)                           (0x00000278+(i)*4)
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION                                 31:15
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                14:14
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST                                    11:8
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST                                      7:4
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                         0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                         0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                         0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                         0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                         0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                         0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                         0x0000000D
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST                                      3:0
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                         0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                         0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                         0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                         0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                         0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                         0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                         0x0000000D

#define NV1196_SET_COMBINER0_COLOR_OCW                                     0x00000280
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION                                31:15
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT                   0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS              0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1              0x00000002
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS         0x00000003
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2              0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1             0x00000006
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE                               14:14
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE                    0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE                     0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE                            13:13
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE                            12:12
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST                                   11:8
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0                       0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4                       0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5                       0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8                       0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9                       0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C                       0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D                       0x0000000D
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST                                     7:4
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST                                     3:0
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D                        0x0000000D

#define NV1196_SET_COMBINER1_COLOR_OCW                                     0x00000284
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT                          31:28
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE                 0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO                 0x00000002
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT                               27:27
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB                      0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB                      0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION                                26:15
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT                   0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS              0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1              0x00000002
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS         0x00000003
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2              0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1             0x00000006
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE                               14:14
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE                    0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE                     0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE                            13:13
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE                            12:12
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST                                   11:8
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0                       0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4                       0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5                       0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8                       0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9                       0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C                       0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D                       0x0000000D
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST                                     7:4
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST                                     3:0
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D                        0x0000000D

#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0                               0x00000288
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                          31:29
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                            28:28
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                           27:24
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                          23:21
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                            20:20
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                           19:16
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                          15:13
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                            12:12
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                            11:8
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                            7:5
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                              4:4
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                             3:0
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD          0x0000000F

#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1                               0x0000028c
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                          31:29
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                            28:28
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                           27:24
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                          23:21
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                            20:20
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                           19:16
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                          15:13
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                            12:12
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                            11:8
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                       7:7
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE          0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE           0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5               6:6
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE  0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE   0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12              5:0
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE  0x00000020

#define NV1196_SET_CONTROL0                                                0x00000290
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA                                  31:24
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                       0x00000000
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                        0x00000001
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE                                  23:20
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                       0x00000000
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                        0x00000001
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                19:16
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_CONTROL0_Z_FORMAT                                            15:12
#define NV1196_SET_CONTROL0_Z_FORMAT_FIXED                                 0x00000000
#define NV1196_SET_CONTROL0_Z_FORMAT_FLOAT                                 0x00000001
#define NV1196_SET_CONTROL0_WBUFFER_SELECT                                       11:8
#define NV1196_SET_CONTROL0_WBUFFER_SELECT_0                               0x00000000
#define NV1196_SET_CONTROL0_WBUFFER_SELECT_1                               0x00000001
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE                                  7:0
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                      0x00000001

#define NV1196_SET_LIGHT_CONTROL                                           0x00000294
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE                                       31:16
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE_FALSE                            0x00000000
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE_TRUE                             0x00000001
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE                                15:2
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT                   0x00000000
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT               0x00000001
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                             1:1
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                0x00000000
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                 0x00000001
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN                               0:0
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE                  0x00000000
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE                   0x00000001

#define NV1196_SET_COLOR_MATERIAL                                          0x00000298
#define NV1196_SET_COLOR_MATERIAL_V                                              31:0
#define NV1196_SET_COLOR_MATERIAL_V_DISABLED                               0x00000000
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION                               0x00000001
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT                                0x00000002
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT                       0x00000003
#define NV1196_SET_COLOR_MATERIAL_V_DIFFUSE                                0x00000004
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE                       0x00000005
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE                        0x00000006
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE               0x00000007
#define NV1196_SET_COLOR_MATERIAL_V_SPECULAR                               0x00000008
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR                      0x00000009
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR                       0x0000000A
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR              0x0000000B
#define NV1196_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR                       0x0000000C
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR              0x0000000D
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR               0x0000000E
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR      0x0000000F

#define NV1196_SET_FOG_MODE                                                0x0000029c
#define NV1196_SET_FOG_MODE_FOG_MODE                                             31:0
#define NV1196_SET_FOG_MODE_FOG_MODE_LINEAR                                0x00002601
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP                                   0x00000800
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP2                                  0x00000801
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP_ABS                               0x00000802
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP2_ABS                              0x00000803

#define NV1196_SET_FOG_GEN_MODE                                            0x000002a0
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE                                     31:0
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT                     0x00000000
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL                        0x00000001
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR                        0x00000002
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR                    0x00000003

#define NV1196_SET_FOG_ENABLE                                              0x000002a4
#define NV1196_SET_FOG_ENABLE_V                                                  31:0
#define NV1196_SET_FOG_ENABLE_V_FALSE                                      0x00000000
#define NV1196_SET_FOG_ENABLE_V_TRUE                                       0x00000001

#define NV1196_SET_FOG_COLOR                                               0x000002a8
#define NV1196_SET_FOG_COLOR_RED                                                  7:0
#define NV1196_SET_FOG_COLOR_GREEN                                               15:8
#define NV1196_SET_FOG_COLOR_BLUE                                               23:16
#define NV1196_SET_FOG_COLOR_ALPHA                                              31:24

#define NV1196_SET_COLOR_KEY_COLOR(i)                              (0x000002ac+(i)*4)
#define NV1196_SET_COLOR_KEY_COLOR_V                                             31:0

#define NV1196_SET_WINDOW_CLIP_TYPE                                        0x000002b4
#define NV1196_SET_WINDOW_CLIP_TYPE_V                                            31:0
#define NV1196_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                            0x00000000
#define NV1196_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                            0x00000001

#define NV1196_SET_WINDOW_CLIP_HORIZONTAL(i)                       (0x000002c0+(i)*4)
#define NV1196_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                   11:0
#define NV1196_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                  27:16

#define NV1196_SET_WINDOW_CLIP_VERTICAL(i)                         (0x000002e0+(i)*4)
#define NV1196_SET_WINDOW_CLIP_VERTICAL_YMIN                                     11:0
#define NV1196_SET_WINDOW_CLIP_VERTICAL_YMAX                                    27:16

#define NV1196_SET_ALPHA_TEST_ENABLE                                       0x00000300
#define NV1196_SET_ALPHA_TEST_ENABLE_V                                           31:0
#define NV1196_SET_ALPHA_TEST_ENABLE_V_FALSE                               0x00000000
#define NV1196_SET_ALPHA_TEST_ENABLE_V_TRUE                                0x00000001

#define NV1196_SET_BLEND_ENABLE                                            0x00000304
#define NV1196_SET_BLEND_ENABLE_V                                                31:0
#define NV1196_SET_BLEND_ENABLE_V_FALSE                                    0x00000000
#define NV1196_SET_BLEND_ENABLE_V_TRUE                                     0x00000001

#define NV1196_SET_CULL_FACE_ENABLE                                        0x00000308
#define NV1196_SET_CULL_FACE_ENABLE_V                                            31:0
#define NV1196_SET_CULL_FACE_ENABLE_V_FALSE                                0x00000000
#define NV1196_SET_CULL_FACE_ENABLE_V_TRUE                                 0x00000001

#define NV1196_SET_DEPTH_TEST_ENABLE                                       0x0000030c
#define NV1196_SET_DEPTH_TEST_ENABLE_V                                           31:0
#define NV1196_SET_DEPTH_TEST_ENABLE_V_FALSE                               0x00000000
#define NV1196_SET_DEPTH_TEST_ENABLE_V_TRUE                                0x00000001

#define NV1196_SET_DITHER_ENABLE                                           0x00000310
#define NV1196_SET_DITHER_ENABLE_V                                               31:0
#define NV1196_SET_DITHER_ENABLE_V_FALSE                                   0x00000000
#define NV1196_SET_DITHER_ENABLE_V_TRUE                                    0x00000001

#define NV1196_SET_LIGHTING_ENABLE                                         0x00000314
#define NV1196_SET_LIGHTING_ENABLE_V                                             31:0
#define NV1196_SET_LIGHTING_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_LIGHTING_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_POINT_PARAMS_ENABLE                                     0x00000318
#define NV1196_SET_POINT_PARAMS_ENABLE_V                                         31:0
#define NV1196_SET_POINT_PARAMS_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_POINT_PARAMS_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_POINT_SMOOTH_ENABLE                                     0x0000031c
#define NV1196_SET_POINT_SMOOTH_ENABLE_V                                         31:0
#define NV1196_SET_POINT_SMOOTH_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_POINT_SMOOTH_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_LINE_SMOOTH_ENABLE                                      0x00000320
#define NV1196_SET_LINE_SMOOTH_ENABLE_V                                          31:0
#define NV1196_SET_LINE_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV1196_SET_LINE_SMOOTH_ENABLE_V_TRUE                               0x00000001

#define NV1196_SET_POLY_SMOOTH_ENABLE                                      0x00000324
#define NV1196_SET_POLY_SMOOTH_ENABLE_V                                          31:0
#define NV1196_SET_POLY_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV1196_SET_POLY_SMOOTH_ENABLE_V_TRUE                               0x00000001

#define NV1196_SET_SKIN_ENABLE                                             0x00000328
#define NV1196_SET_SKIN_ENABLE_V                                                 31:0
#define NV1196_SET_SKIN_ENABLE_V_FALSE                                     0x00000000
#define NV1196_SET_SKIN_ENABLE_V_TRUE                                      0x00000001

#define NV1196_SET_STENCIL_TEST_ENABLE                                     0x0000032c
#define NV1196_SET_STENCIL_TEST_ENABLE_V                                         31:0
#define NV1196_SET_STENCIL_TEST_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_STENCIL_TEST_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_POLY_OFFSET_POINT_ENABLE                                0x00000330
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V                                    31:0
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                        0x00000000
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                         0x00000001

#define NV1196_SET_POLY_OFFSET_LINE_ENABLE                                 0x00000334
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V                                     31:0
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                         0x00000000
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                          0x00000001

#define NV1196_SET_POLY_OFFSET_FILL_ENABLE                                 0x00000338
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V                                     31:0
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                         0x00000000
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                          0x00000001

#define NV1196_SET_ALPHA_FUNC                                              0x0000033c
#define NV1196_SET_ALPHA_FUNC_V                                                  31:0
#define NV1196_SET_ALPHA_FUNC_V_NEVER                                      0x00000200
#define NV1196_SET_ALPHA_FUNC_V_LESS                                       0x00000201
#define NV1196_SET_ALPHA_FUNC_V_EQUAL                                      0x00000202
#define NV1196_SET_ALPHA_FUNC_V_LEQUAL                                     0x00000203
#define NV1196_SET_ALPHA_FUNC_V_GREATER                                    0x00000204
#define NV1196_SET_ALPHA_FUNC_V_NOTEQUAL                                   0x00000205
#define NV1196_SET_ALPHA_FUNC_V_GEQUAL                                     0x00000206
#define NV1196_SET_ALPHA_FUNC_V_ALWAYS                                     0x00000207

#define NV1196_SET_ALPHA_REF                                               0x00000340
#define NV1196_SET_ALPHA_REF_V                                                   31:0

#define NV1196_SET_BLEND_FUNC_SFACTOR                                      0x00000344
#define NV1196_SET_BLEND_FUNC_SFACTOR_V                                          31:0
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ZERO                               0x00000000
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE                                0x00000001
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                          0x00000300
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                0x00000301
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                          0x00000302
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                0x00000303
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                          0x00000304
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                0x00000305
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                          0x00000306
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                0x00000307
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                 0x00000308
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                     0x00008001
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR           0x00008002
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                     0x00008003
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA           0x00008004

#define NV1196_SET_BLEND_FUNC_DFACTOR                                      0x00000348
#define NV1196_SET_BLEND_FUNC_DFACTOR_V                                          31:0
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ZERO                               0x00000000
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE                                0x00000001
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                          0x00000300
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                0x00000301
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                          0x00000302
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                0x00000303
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                          0x00000304
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                0x00000305
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                          0x00000306
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                0x00000307
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_SATURATE                 0x00000308
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                     0x00008001
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR           0x00008002
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                     0x00008003
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA           0x00008004

#define NV1196_SET_BLEND_COLOR                                             0x0000034c
#define NV1196_SET_BLEND_COLOR_V                                                 31:0

#define NV1196_SET_BLEND_EQUATION                                          0x00000350
#define NV1196_SET_BLEND_EQUATION_V                                              31:0
#define NV1196_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                          0x0000800A
#define NV1196_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                  0x0000800B
#define NV1196_SET_BLEND_EQUATION_V_FUNC_ADD                               0x00008006
#define NV1196_SET_BLEND_EQUATION_V_MIN                                    0x00008007
#define NV1196_SET_BLEND_EQUATION_V_MAX                                    0x00008008

#define NV1196_SET_DEPTH_FUNC                                              0x00000354
#define NV1196_SET_DEPTH_FUNC_V                                                  31:0
#define NV1196_SET_DEPTH_FUNC_V_NEVER                                      0x00000200
#define NV1196_SET_DEPTH_FUNC_V_LESS                                       0x00000201
#define NV1196_SET_DEPTH_FUNC_V_EQUAL                                      0x00000202
#define NV1196_SET_DEPTH_FUNC_V_LEQUAL                                     0x00000203
#define NV1196_SET_DEPTH_FUNC_V_GREATER                                    0x00000204
#define NV1196_SET_DEPTH_FUNC_V_NOTEQUAL                                   0x00000205
#define NV1196_SET_DEPTH_FUNC_V_GEQUAL                                     0x00000206
#define NV1196_SET_DEPTH_FUNC_V_ALWAYS                                     0x00000207

#define NV1196_SET_COLOR_MASK                                              0x00000358
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                31:24
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE                                  23:16
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                       0x00000000
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                        0x00000001
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                 15:8
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                   7:0
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                      0x00000000
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                       0x00000001

#define NV1196_SET_DEPTH_MASK                                              0x0000035c
#define NV1196_SET_DEPTH_MASK_V                                                  31:0
#define NV1196_SET_DEPTH_MASK_V_FALSE                                      0x00000000
#define NV1196_SET_DEPTH_MASK_V_TRUE                                       0x00000001

#define NV1196_SET_STENCIL_MASK                                            0x00000360
#define NV1196_SET_STENCIL_MASK_V                                                31:0

#define NV1196_SET_STENCIL_FUNC                                            0x00000364
#define NV1196_SET_STENCIL_FUNC_V                                                31:0
#define NV1196_SET_STENCIL_FUNC_V_NEVER                                    0x00000200
#define NV1196_SET_STENCIL_FUNC_V_LESS                                     0x00000201
#define NV1196_SET_STENCIL_FUNC_V_EQUAL                                    0x00000202
#define NV1196_SET_STENCIL_FUNC_V_LEQUAL                                   0x00000203
#define NV1196_SET_STENCIL_FUNC_V_GREATER                                  0x00000204
#define NV1196_SET_STENCIL_FUNC_V_NOTEQUAL                                 0x00000205
#define NV1196_SET_STENCIL_FUNC_V_GEQUAL                                   0x00000206
#define NV1196_SET_STENCIL_FUNC_V_ALWAYS                                   0x00000207

#define NV1196_SET_STENCIL_FUNC_REF                                        0x00000368
#define NV1196_SET_STENCIL_FUNC_REF_V                                            31:0

#define NV1196_SET_STENCIL_FUNC_MASK                                       0x0000036c
#define NV1196_SET_STENCIL_FUNC_MASK_V                                           31:0

#define NV1196_SET_STENCIL_OP_FAIL                                         0x00000370
#define NV1196_SET_STENCIL_OP_FAIL_V                                             31:0
#define NV1196_SET_STENCIL_OP_FAIL_V_KEEP                                  0x00001E00
#define NV1196_SET_STENCIL_OP_FAIL_V_ZERO                                  0x00000000
#define NV1196_SET_STENCIL_OP_FAIL_V_REPLACE                               0x00001E01
#define NV1196_SET_STENCIL_OP_FAIL_V_INCRSAT                               0x00001E02
#define NV1196_SET_STENCIL_OP_FAIL_V_DECRSAT                               0x00001E03
#define NV1196_SET_STENCIL_OP_FAIL_V_INVERT                                0x0000150A
#define NV1196_SET_STENCIL_OP_FAIL_V_INCR                                  0x00008507
#define NV1196_SET_STENCIL_OP_FAIL_V_DECR                                  0x00008508

#define NV1196_SET_STENCIL_OP_ZFAIL                                        0x00000374
#define NV1196_SET_STENCIL_OP_ZFAIL_V                                            31:0
#define NV1196_SET_STENCIL_OP_ZFAIL_V_KEEP                                 0x00001E00
#define NV1196_SET_STENCIL_OP_ZFAIL_V_ZERO                                 0x00000000
#define NV1196_SET_STENCIL_OP_ZFAIL_V_REPLACE                              0x00001E01
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INCRSAT                              0x00001E02
#define NV1196_SET_STENCIL_OP_ZFAIL_V_DECRSAT                              0x00001E03
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INVERT                               0x0000150A
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INCR                                 0x00008507
#define NV1196_SET_STENCIL_OP_ZFAIL_V_DECR                                 0x00008508

#define NV1196_SET_STENCIL_OP_ZPASS                                        0x00000378
#define NV1196_SET_STENCIL_OP_ZPASS_V                                            31:0
#define NV1196_SET_STENCIL_OP_ZPASS_V_KEEP                                 0x00001E00
#define NV1196_SET_STENCIL_OP_ZPASS_V_ZERO                                 0x00000000
#define NV1196_SET_STENCIL_OP_ZPASS_V_REPLACE                              0x00001E01
#define NV1196_SET_STENCIL_OP_ZPASS_V_INCRSAT                              0x00001E02
#define NV1196_SET_STENCIL_OP_ZPASS_V_DECRSAT                              0x00001E03
#define NV1196_SET_STENCIL_OP_ZPASS_V_INVERT                               0x0000150A
#define NV1196_SET_STENCIL_OP_ZPASS_V_INCR                                 0x00008507
#define NV1196_SET_STENCIL_OP_ZPASS_V_DECR                                 0x00008508

#define NV1196_SET_SHADE_MODE                                              0x0000037c
#define NV1196_SET_SHADE_MODE_V                                                  31:0
#define NV1196_SET_SHADE_MODE_V_FLAT                                       0x00001D00
#define NV1196_SET_SHADE_MODE_V_SMOOTH                                     0x00001D01

#define NV1196_SET_LINE_WIDTH                                              0x00000380
#define NV1196_SET_LINE_WIDTH_V                                                  31:0

#define NV1196_SET_POLYGON_OFFSET_SCALE_FACTOR                             0x00000384
#define NV1196_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                 31:0

#define NV1196_SET_POLYGON_OFFSET_BIAS                                     0x00000388
#define NV1196_SET_POLYGON_OFFSET_BIAS_V                                         31:0

#define NV1196_SET_FRONT_POLYGON_MODE                                      0x0000038c
#define NV1196_SET_FRONT_POLYGON_MODE_V                                          31:0
#define NV1196_SET_FRONT_POLYGON_MODE_V_POINT                              0x00001B00
#define NV1196_SET_FRONT_POLYGON_MODE_V_LINE                               0x00001B01
#define NV1196_SET_FRONT_POLYGON_MODE_V_FILL                               0x00001B02

#define NV1196_SET_BACK_POLYGON_MODE                                       0x00000390
#define NV1196_SET_BACK_POLYGON_MODE_V                                           31:0
#define NV1196_SET_BACK_POLYGON_MODE_V_POINT                               0x00001B00
#define NV1196_SET_BACK_POLYGON_MODE_V_LINE                                0x00001B01
#define NV1196_SET_BACK_POLYGON_MODE_V_FILL                                0x00001B02

#define NV1196_SET_CLIP_MIN                                                0x00000394
#define NV1196_SET_CLIP_MIN_V                                                    31:0

#define NV1196_SET_CLIP_MAX                                                0x00000398
#define NV1196_SET_CLIP_MAX_V                                                    31:0

#define NV1196_SET_CULL_FACE                                               0x0000039c
#define NV1196_SET_CULL_FACE_V                                                   31:0
#define NV1196_SET_CULL_FACE_V_FRONT                                       0x00000404
#define NV1196_SET_CULL_FACE_V_BACK                                        0x00000405
#define NV1196_SET_CULL_FACE_V_FRONT_AND_BACK                              0x00000408

#define NV1196_SET_FRONT_FACE                                              0x000003a0
#define NV1196_SET_FRONT_FACE_V                                                  31:0
#define NV1196_SET_FRONT_FACE_V_CW                                         0x00000900
#define NV1196_SET_FRONT_FACE_V_CCW                                        0x00000901

#define NV1196_SET_NORMALIZATION_ENABLE                                    0x000003a4
#define NV1196_SET_NORMALIZATION_ENABLE_V                                        31:0
#define NV1196_SET_NORMALIZATION_ENABLE_V_FALSE                            0x00000000
#define NV1196_SET_NORMALIZATION_ENABLE_V_TRUE                             0x00000001

#define NV1196_SET_MATERIAL_EMISSION(i)                            (0x000003a8+(i)*4)
#define NV1196_SET_MATERIAL_EMISSION_V                                           31:0

#define NV1196_SET_MATERIAL_ALPHA                                          0x000003b4
#define NV1196_SET_MATERIAL_ALPHA_V                                              31:0

#define NV1196_SET_SPECULAR_ENABLE                                         0x000003b8
#define NV1196_SET_SPECULAR_ENABLE_V                                             31:0
#define NV1196_SET_SPECULAR_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_SPECULAR_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_LIGHT_ENABLE_MASK                                       0x000003bc
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0                                       1:0
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1                                       3:2
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2                                       5:4
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3                                       7:6
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4                                       9:8
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5                                     11:10
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6                                     13:12
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7                                     15:14
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                           0x00000003

#define NV1196_SET_TEXGEN_S(i)                                    (0x000003c0+(i)*16)
#define NV1196_SET_TEXGEN_S_V                                                    31:0
#define NV1196_SET_TEXGEN_S_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_S_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_S_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_S_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_S_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_S_V_SPHERE_MAP                                   0x00002402
#define NV1196_SET_TEXGEN_S_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_T(i)                                    (0x000003c4+(i)*16)
#define NV1196_SET_TEXGEN_T_V                                                    31:0
#define NV1196_SET_TEXGEN_T_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_T_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_T_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_T_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_T_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_T_V_SPHERE_MAP                                   0x00002402
#define NV1196_SET_TEXGEN_T_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_R(i)                                    (0x000003c8+(i)*16)
#define NV1196_SET_TEXGEN_R_V                                                    31:0
#define NV1196_SET_TEXGEN_R_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_R_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_R_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_R_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_R_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_R_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_Q(i)                                    (0x000003cc+(i)*16)
#define NV1196_SET_TEXGEN_Q_V                                                    31:0
#define NV1196_SET_TEXGEN_Q_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_Q_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_Q_V_OBJECT_LINEAR                                0x00002401

#define NV1196_SET_TEXTURE_MATRIX0_ENABLE                                  0x000003e0
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V                                      31:0
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE                          0x00000000
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE                           0x00000001

#define NV1196_SET_TEXTURE_MATRIX1_ENABLE                                  0x000003e4
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V                                      31:0
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE                          0x00000000
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE                           0x00000001

#define NV1196_SET_TLMODE                                                  0x000003e8
#define NV1196_SET_TLMODE_PASSTHROUGH                                             0:0
#define NV1196_SET_TLMODE_PASSTHROUGH_TRUE                                 0x00000001
#define NV1196_SET_TLMODE_PASSTHROUGH_FALSE                                0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_0                                              1:1
#define NV1196_SET_TLMODE_W_DIVIDE_0_DISABLE                               0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_0_ENABLE                                0x00000001
#define NV1196_SET_TLMODE_W_DIVIDE_1                                              2:2
#define NV1196_SET_TLMODE_W_DIVIDE_1_DISABLE                               0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_1_ENABLE                                0x00000001

#define NV1196_SET_POINT_SIZE                                              0x000003ec
#define NV1196_SET_POINT_SIZE_V                                                  31:0

#define NV1196_SET_SWATH_WIDTH                                             0x000003f0
#define NV1196_SET_SWATH_WIDTH_V                                                 31:0
#define NV1196_SET_SWATH_WIDTH_V_8                                         0x00000000
#define NV1196_SET_SWATH_WIDTH_V_16                                        0x00000001
#define NV1196_SET_SWATH_WIDTH_V_32                                        0x00000002
#define NV1196_SET_SWATH_WIDTH_V_64                                        0x00000003

#define NV1196_SET_FLAT_SHADE_OP                                           0x000003f4
#define NV1196_SET_FLAT_SHADE_OP_V                                               31:0
#define NV1196_SET_FLAT_SHADE_OP_V_LAST_VTX                                0x00000000
#define NV1196_SET_FLAT_SHADE_OP_V_FIRST_VTX                               0x00000001

#define NV1196_SET_MODEL_VIEW_MATRIX0(i)                           (0x00000400+(i)*4)
#define NV1196_SET_MODEL_VIEW_MATRIX0_V                                          31:0

#define NV1196_SET_MODEL_VIEW_MATRIX1(i)                           (0x00000440+(i)*4)
#define NV1196_SET_MODEL_VIEW_MATRIX1_V                                          31:0

#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                   (0x00000480+(i)*4)
#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX0_V                                  31:0

#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                   (0x000004c0+(i)*4)
#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX1_V                                  31:0

#define NV1196_SET_COMPOSITE_MATRIX(i)                             (0x00000500+(i)*4)
#define NV1196_SET_COMPOSITE_MATRIX_V                                            31:0

#define NV1196_SET_TEXTURE_MATRIX0(i)                              (0x00000540+(i)*4)
#define NV1196_SET_TEXTURE_MATRIX0_V                                             31:0

#define NV1196_SET_TEXTURE_MATRIX1(i)                              (0x00000580+(i)*4)
#define NV1196_SET_TEXTURE_MATRIX1_V                                             31:0

#define NV1196_SET_TEXGEN_SPLANE0(i)                               (0x00000600+(i)*4)
#define NV1196_SET_TEXGEN_SPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_TPLANE0(i)                               (0x00000610+(i)*4)
#define NV1196_SET_TEXGEN_TPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_RPLANE0(i)                               (0x00000620+(i)*4)
#define NV1196_SET_TEXGEN_RPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_QPLANE0(i)                               (0x00000630+(i)*4)
#define NV1196_SET_TEXGEN_QPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_SPLANE1(i)                               (0x00000640+(i)*4)
#define NV1196_SET_TEXGEN_SPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_TPLANE1(i)                               (0x00000650+(i)*4)
#define NV1196_SET_TEXGEN_TPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_RPLANE1(i)                               (0x00000660+(i)*4)
#define NV1196_SET_TEXGEN_RPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_QPLANE1(i)                               (0x00000670+(i)*4)
#define NV1196_SET_TEXGEN_QPLANE1_V                                              31:0

#define NV1196_SET_FOG_PARAMS(i)                                   (0x00000680+(i)*4)
#define NV1196_SET_FOG_PARAMS_V                                                  31:0

#define NV1196_SET_FOG_PLANE(i)                                    (0x0000068c+(i)*4)
#define NV1196_SET_FOG_PLANE_V                                                   31:0

#define NV1196_SET_SPECULAR_PARAMS(i)                              (0x000006a0+(i)*4)
#define NV1196_SET_SPECULAR_PARAMS_V                                             31:0

#define NV1196_SET_SCENE_AMBIENT_COLOR(i)                          (0x000006c4+(i)*4)
#define NV1196_SET_SCENE_AMBIENT_COLOR_V                                         31:0

#define NV1196_SET_VIEWPORT_OFFSET(i)                              (0x000006e8+(i)*4)
#define NV1196_SET_VIEWPORT_OFFSET_V                                             31:0

#define NV1196_SET_POINT_PARAMS(i)                                 (0x000006f8+(i)*4)
#define NV1196_SET_POINT_PARAMS_V                                                31:0

#define NV1196_SET_EYE_POSITION(i)                                 (0x00000718+(i)*4)
#define NV1196_SET_EYE_POSITION_V                                                31:0

#define NV1196_SET_EYE_DIRECTION_SW(i)                             (0x0000072c+(i)*4)

#define NV1196_SET_LIGHT_AMBIENT_COLOR(i,j)                (0x00000800+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_AMBIENT_COLOR_V                                         31:0

#define NV1196_SET_LIGHT_DIFFUSE_COLOR(i,j)                (0x0000080c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_DIFFUSE_COLOR_V                                         31:0

#define NV1196_SET_LIGHT_SPECULAR_COLOR(i,j)               (0x00000818+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPECULAR_COLOR_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_RANGE(i)                          (0x00000824+(i)*128)
#define NV1196_SET_LIGHT_LOCAL_RANGE_V                                           31:0

#define NV1196_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)         (0x00000828+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_INFINITE_HALF_VECTOR_V                                  31:0

#define NV1196_SET_LIGHT_INFINITE_DIRECTION(i,j)           (0x00000834+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_INFINITE_DIRECTION_V                                    31:0

#define NV1196_SET_LIGHT_SPOT_FALLOFF(i,j)                 (0x00000840+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPOT_FALLOFF_V                                          31:0

#define NV1196_SET_LIGHT_SPOT_DIRECTION(i,j)               (0x0000084c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPOT_DIRECTION_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_POSITION(i,j)               (0x0000085c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_LOCAL_POSITION_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_ATTENUATION(i,j)            (0x00000868+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_LOCAL_ATTENUATION_V                                     31:0

#define NV1196_SET_VERTEX3F(i)                                     (0x00000c00+(i)*4)
#define NV1196_SET_VERTEX3F_V                                                    31:0

#define NV1196_SET_VERTEX4F(i)                                     (0x00000c18+(i)*4)
#define NV1196_SET_VERTEX4F_V                                                    31:0

#define NV1196_SET_VERTEX4S(i)                                     (0x00000c28+(i)*4)
#define NV1196_SET_VERTEX4S_V                                                    31:0

#define NV1196_SET_NORMAL3F(i)                                     (0x00000c30+(i)*4)
#define NV1196_SET_NORMAL3F_V                                                    31:0

#define NV1196_SET_NORMAL3S(i)                                     (0x00000c40+(i)*4)
#define NV1196_SET_NORMAL3S_V                                                    31:0

#define NV1196_SET_DIFFUSE_COLOR4F(i)                              (0x00000c50+(i)*4)
#define NV1196_SET_DIFFUSE_COLOR4F_V                                             31:0

#define NV1196_SET_DIFFUSE_COLOR3F(i)                              (0x00000c60+(i)*4)
#define NV1196_SET_DIFFUSE_COLOR3F_V                                             31:0

#define NV1196_SET_DIFFUSE_COLOR4UB                                        0x00000c6c
#define NV1196_SET_DIFFUSE_COLOR4UB_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR4F(i)                             (0x00000c70+(i)*4)
#define NV1196_SET_SPECULAR_COLOR4F_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR3F(i)                             (0x00000c80+(i)*4)
#define NV1196_SET_SPECULAR_COLOR3F_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR4UB                                       0x00000c8c
#define NV1196_SET_SPECULAR_COLOR4UB_V                                           31:0

#define NV1196_SET_TEXCOORD0_2F(i)                                 (0x00000c90+(i)*4)
#define NV1196_SET_TEXCOORD0_2F_V                                                31:0

#define NV1196_SET_TEXCOORD0_2S                                            0x00000c98
#define NV1196_SET_TEXCOORD0_2S_V                                                31:0

#define NV1196_SET_TEXCOORD0_4F(i)                                 (0x00000ca0+(i)*4)
#define NV1196_SET_TEXCOORD0_4F_V                                                31:0

#define NV1196_SET_TEXCOORD0_4S(i)                                 (0x00000cb0+(i)*4)
#define NV1196_SET_TEXCOORD0_4S_V                                                31:0

#define NV1196_SET_TEXCOORD1_2F(i)                                 (0x00000cb8+(i)*4)
#define NV1196_SET_TEXCOORD1_2F_V                                                31:0

#define NV1196_SET_TEXCOORD1_2S                                            0x00000cc0
#define NV1196_SET_TEXCOORD1_2S_V                                                31:0

#define NV1196_SET_TEXCOORD1_4F(i)                                 (0x00000cc8+(i)*4)
#define NV1196_SET_TEXCOORD1_4F_V                                                31:0

#define NV1196_SET_TEXCOORD1_4S(i)                                 (0x00000cd8+(i)*4)
#define NV1196_SET_TEXCOORD1_4S_V                                                31:0

#define NV1196_SET_FOG1F                                                   0x00000ce0
#define NV1196_SET_FOG1F_V                                                       31:0

#define NV1196_SET_WEIGHT1F                                                0x00000ce4
#define NV1196_SET_WEIGHT1F_V                                                    31:0

#define NV1196_SET_EDGE_FLAG                                               0x00000cec
#define NV1196_SET_EDGE_FLAG_V                                                   31:0

#define NV1196_INVALIDATE_VERTEX_CACHE_FILE                                0x00000cf0
#define NV1196_INVALIDATE_VERTEX_CACHE_FILE_V                                    31:0

#define NV1196_INVALIDATE_VERTEX_FILE                                      0x00000cf4
#define NV1196_INVALIDATE_VERTEX_FILE_V                                          31:0

#define NV1196_TL_NOP                                                      0x00000cf8
#define NV1196_TL_NOP_V                                                          31:0

#define NV1196_TL_SYNC                                                     0x00000cfc
#define NV1196_TL_SYNC_V                                                         31:0

#define NV1196_SET_VERTEX_ARRAY_OFFSET                                     0x00000d00
#define NV1196_SET_VERTEX_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_DIFFUSE_ARRAY_OFFSET                                    0x00000d08
#define NV1196_SET_DIFFUSE_ARRAY_OFFSET_OFFSET                                   31:0

#define NV1196_SET_SPECULAR_ARRAY_OFFSET                                   0x00000d10
#define NV1196_SET_SPECULAR_ARRAY_OFFSET_OFFSET                                  31:0

#define NV1196_SET_TEX_COORD0_ARRAY_OFFSET                                 0x00000d18
#define NV1196_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET                                31:0

#define NV1196_SET_TEX_COORD1_ARRAY_OFFSET                                 0x00000d20
#define NV1196_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET                                31:0

#define NV1196_SET_NORMAL_ARRAY_OFFSET                                     0x00000d28
#define NV1196_SET_NORMAL_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_WEIGHT_ARRAY_OFFSET                                     0x00000d30
#define NV1196_SET_WEIGHT_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_FOG_ARRAY_OFFSET                                        0x00000d38
#define NV1196_SET_FOG_ARRAY_OFFSET_OFFSET                                       31:0

#define NV1196_SET_VERTEX_ARRAY_FORMAT                                     0x00000d04
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W                                        31:24
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W_NONE                              0x00000000
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W_PRESENT                           0x00000001
#define NV1196_SET_VERTEX_ARRAY_FORMAT_STRIDE                                    23:8
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_2                              0x00000002
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_4                              0x00000004
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_DIFFUSE_ARRAY_FORMAT                                    0x00000d0c
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_STRIDE                                   31:8
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE                                      7:4
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0                             0x00000000
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3                             0x00000003
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4                             0x00000004
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE                                      3:0
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA            0x00000000
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT                         0x00000002
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA            0x00000004

#define NV1196_SET_SPECULAR_ARRAY_FORMAT                                   0x00000d14
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_STRIDE                                  31:8
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE                                     7:4
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_0                            0x00000000
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_3                            0x00000003
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_4                            0x00000004
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE                                     3:0
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA           0x00000000
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT                        0x00000002
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA           0x00000004

#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT                                 0x00000d1c
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE                                31:8
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE                                   7:4
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0                          0x00000000
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1                          0x00000001
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2                          0x00000002
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3                          0x00000003
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4                          0x00000004
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE                                   3:0
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT                      0x00000001
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT                      0x00000002

#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT                                 0x00000d24
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE                                31:8
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE                                   7:4
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0                          0x00000000
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1                          0x00000001
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2                          0x00000002
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3                          0x00000003
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4                          0x00000004
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE                                   3:0
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT                      0x00000001
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT                      0x00000002

#define NV1196_SET_NORMAL_ARRAY_FORMAT                                     0x00000d2c
#define NV1196_SET_NORMAL_ARRAY_FORMAT_STRIDE                                    31:8
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_WEIGHT_ARRAY_FORMAT                                     0x00000d34
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_STRIDE                                    31:8
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE_1                              0x00000001
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_FOG_ARRAY_FORMAT                                        0x00000d3c
#define NV1196_SET_FOG_ARRAY_FORMAT_STRIDE                                       31:8
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE                                          7:4
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE_0                                 0x00000000
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE_1                                 0x00000001
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE                                          3:0
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE_SHORT                             0x00000001
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT                             0x00000002

#define NV1196_SET_LOGIC_OP_ENABLE                                         0x00000d40
#define NV1196_SET_LOGIC_OP_ENABLE_V                                             31:0
#define NV1196_SET_LOGIC_OP_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_LOGIC_OP_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_LOGIC_OP                                                0x00000d44
#define NV1196_SET_LOGIC_OP_V                                                    31:0
#define NV1196_SET_LOGIC_OP_V_CLEAR                                        0x00001500
#define NV1196_SET_LOGIC_OP_V_AND                                          0x00001501
#define NV1196_SET_LOGIC_OP_V_AND_REVERSE                                  0x00001502
#define NV1196_SET_LOGIC_OP_V_COPY                                         0x00001503
#define NV1196_SET_LOGIC_OP_V_AND_INVERTED                                 0x00001504
#define NV1196_SET_LOGIC_OP_V_NOOP                                         0x00001505
#define NV1196_SET_LOGIC_OP_V_XOR                                          0x00001506
#define NV1196_SET_LOGIC_OP_V_OR                                           0x00001507
#define NV1196_SET_LOGIC_OP_V_NOR                                          0x00001508
#define NV1196_SET_LOGIC_OP_V_EQUIV                                        0x00001509
#define NV1196_SET_LOGIC_OP_V_INVERT                                       0x0000150A
#define NV1196_SET_LOGIC_OP_V_OR_REVERSE                                   0x0000150B
#define NV1196_SET_LOGIC_OP_V_COPY_INVERTED                                0x0000150C
#define NV1196_SET_LOGIC_OP_V_OR_INVERTED                                  0x0000150D
#define NV1196_SET_LOGIC_OP_V_NAND                                         0x0000150E
#define NV1196_SET_LOGIC_OP_V_SET                                          0x0000150F

#define NV1196_SET_BEGIN_END                                               0x00000dfc
#define NV1196_SET_BEGIN_END_OP                                                  31:0
#define NV1196_SET_BEGIN_END_OP_END                                        0x00000000
#define NV1196_SET_BEGIN_END_OP_POINTS                                     0x00000001
#define NV1196_SET_BEGIN_END_OP_LINES                                      0x00000002
#define NV1196_SET_BEGIN_END_OP_LINE_LOOP                                  0x00000003
#define NV1196_SET_BEGIN_END_OP_LINE_STRIP                                 0x00000004
#define NV1196_SET_BEGIN_END_OP_TRIANGLES                                  0x00000005
#define NV1196_SET_BEGIN_END_OP_TRIANGLE_STRIP                             0x00000006
#define NV1196_SET_BEGIN_END_OP_TRIANGLE_FAN                               0x00000007
#define NV1196_SET_BEGIN_END_OP_QUADS                                      0x00000008
#define NV1196_SET_BEGIN_END_OP_QUAD_STRIP                                 0x00000009
#define NV1196_SET_BEGIN_END_OP_POLYGON                                    0x0000000A

#define NV1196_ARRAY_ELEMENT16(i)                                  (0x00000e00+(i)*4)
#define NV1196_ARRAY_ELEMENT16_VERTEX0                                           15:0
#define NV1196_ARRAY_ELEMENT16_VERTEX1                                          31:16

#define NV1196_SET_BEGIN_END2                                              0x000010fc
#define NV1196_SET_BEGIN_END2_OP                                                 31:0
#define NV1196_SET_BEGIN_END2_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END2_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END2_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END2_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END2_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END2_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END2_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END2_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END2_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END2_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END2_OP_POLYGON                                   0x0000000A

#define NV1196_ARRAY_ELEMENT32(i)                                  (0x00001100+(i)*4)
#define NV1196_ARRAY_ELEMENT32_V                                                 31:0

#define NV1196_SET_BEGIN_END3                                              0x000013fc
#define NV1196_SET_BEGIN_END3_OP                                                 31:0
#define NV1196_SET_BEGIN_END3_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END3_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END3_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END3_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END3_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END3_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END3_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END3_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END3_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END3_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END3_OP_POLYGON                                   0x0000000A

#define NV1196_DRAW_ARRAYS(i)                                      (0x00001400+(i)*4)
#define NV1196_DRAW_ARRAYS_COUNT                                                31:24
#define NV1196_DRAW_ARRAYS_START_INDEX                                           23:0

/* These methods are accepted between a begin/end. */
#define NV1196_SET_MATERIAL_EMISSION_SW(i)                          (0x00001628+(i)*4)
#define NV1196_SET_VIEWPORT_OFFSET_SW(i)                            (0x00001638+(i)*4)
/* The PASSTHRU_VIEWPORT_OFFSET aliases to row 1 of the MODEL_VIEW_MATRIX1 */
#define NV1196_SET_PASSTHRU_VIEWPORT_OFFSET_SW(i)                   (0x00001648+(i)*4)

#define NV1196_SET_BEGIN_END4                                              0x000017fc
#define NV1196_SET_BEGIN_END4_OP                                                 31:0
#define NV1196_SET_BEGIN_END4_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END4_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END4_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END4_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END4_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END4_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END4_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END4_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END4_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END4_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END4_OP_POLYGON                                   0x0000000A

#define NV1196_INLINE_ARRAY(i)                                     (0x00001800+(i)*4)
#define NV1196_INLINE_ARRAY_V                                                    31:0

#define NV1196_DEBUG_INIT(i)                                       (0x00001600+(i)*4)
#define NV1196_DEBUG_INIT_V                                                      31:0


// This typedef really should be the same as Nv20KelvinPrimitive, but this
// causes the NV03/NV04_CHANNEL_PIO union to become too large for the 16bit
// compiler. Since we don't expect to use a PIO channel with Celsius, we'll
// just use the old DWORD size typedef.

typedef NvV32 Nv097Typedef;

/* class NV20_KELVIN_PRIMITIVE */
#define  NV20_KELVIN_PRIMITIVE                                    (0x00000097)
/* NvNotification[] elements */
#define NV097_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV097_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV097_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV097_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV097_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV097_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV097_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved0004[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved0114[0xc/4];
    NvU32 SetFlipRead;
    NvU32 SetFlipWrite;
    NvU32 SetFlipModulo;
    NvV32 FlipIncrementWrite;
    NvV32 FlipStall;
    NvV32 Reserved0134[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved0144[0x3c/4];
    NvU32 SetContextDmaNotifies;
    NvU32 SetContextDmaA;
    NvU32 SetContextDmaB;
    NvV32 Reserved018c[0x4/4];
    NvU32 SetContextDmaState;
    NvU32 SetContextDmaColor;
    NvU32 SetContextDmaZeta;
    NvU32 SetContextDmaVertexA;
    NvU32 SetContextDmaVertexB;
    NvU32 SetContextDmaSemaphore;
    NvU32 SetContextDmaReport;
    NvV32 Reserved01ac[0x54/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvV32 Reserved0218[0x48/4];
    NvV32 SetCombinerAlphaICW[8];
    NvV32 Reserved0280[0x8/4];
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvV32 Reserved02ac[0x8/4];
    NvV32 SetWindowClipType;
    NvV32 Reserved02b8[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinMode;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvU32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvU32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvU32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvU32 SetStencilFuncRef;
    NvU32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvU32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvF32 SetMaterialEmission[3];
    NvF32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
    NvV32 S;
    NvV32 T;
    NvV32 R;
    NvV32 Q;
    } SetTexgen[4];
    NvV32 Reserved0400[0x20/4];
    NvV32 SetTextureMatrixEnable[4];
    NvV32 Reserved0430[0xc/4];
    NvU32 SetPointSize;
    NvF32 SetProjectionMatrix[16];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetModelViewMatrix2[16];
    NvF32 SetModelViewMatrix3[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix2[16];
    NvF32 SetInverseModelViewMatrix3[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvF32 SetTextureMatrix2[16];
    NvF32 SetTextureMatrix3[16];
    NvV32 Reserved07c0[0x80/4];
    struct {
    NvF32 S[4];
    NvF32 T[4];
    NvF32 R[4];
    NvF32 Q[4];
    } SetTexgenPlane[4];
    NvV32 Reserved0940[0x80/4];
    NvF32 SetFogParams[3];
    NvV32 SetTexgenViewModel;
    NvF32 SetFogPlane[4];
    NvF32 SetSpecularParams[6];
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved0a00[0x10/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved0a1c[0x4/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 SetCombinerFactor0[8];
    NvV32 SetCombinerFactor1[8];
    NvV32 SetCombinerAlphaOCW[8];
    NvV32 SetCombinerColorICW[8];
    NvU32 SetColorKeyColor[4];
    NvF32 SetViewportScale[4];
    NvU32 SetTransformProgram[32];
    NvF32 SetTransformConstant[32];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvV32 Reserved0c24[0x1c/4];
    } SetBackLight[8];
    NvV32 Reserved0e00[0x200/4];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvF32 LocalRange;
    NvF32 InfiniteHalfVector[3];
    NvF32 InfiniteDirection[3];
    NvF32 SpotFalloff[3];
    NvF32 SpotDirection[4];
    NvF32 LocalPosition[3];
    NvF32 LocalAttenuation[3];
    NvV32 Reserved1074[0xc/4];
    } SetLight[8];
    NvV32 Reserved1400[0x7c/4];
    NvV32 SetStippleControl;
    NvU32 SetStipplePattern[32];
    NvF32 SetVertex3f[3];
    NvV32 Reserved150c[0xc/4];
    NvF32 SetVertex4f[4];
    NvS32 SetVertex4s[2];
    NvF32 SetNormal3f[3];
    NvV32 Reserved153c[0x4/4];
    NvS32 SetNormal3s[2];
    NvV32 Reserved1548[0x8/4];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvU32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvU32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS32 SetTexcoord0_2s;
    NvV32 Reserved159c[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS32 SetTexcoord0_4s[2];
    NvF32 SetTexcoord1_2f[2];
    NvS32 SetTexcoord1_2s;
    NvV32 Reserved15c4[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS32 SetTexcoord1_4s[2];
    NvF32 SetTexcoord2_2f[2];
    NvS32 SetTexcoord2_2s;
    NvV32 Reserved15ec[0x4/4];
    NvF32 SetTexcoord2_4f[4];
    NvS32 SetTexcoord2_4s[2];
    NvF32 SetTexcoord3_2f[2];
    NvS32 SetTexcoord3_2s;
    NvV32 Reserved1614[0xc/4];
    NvF32 SetTexcoord3_4f[4];
    NvS32 SetTexcoord3_4s[2];
    NvV32 Reserved1638[0x60/4];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvF32 SetWeight2f[2];
    NvV32 Reserved16a8[0x8/4];
    NvF32 SetWeight3f[3];
    NvV32 SetEdgeFlag;
    NvF32 SetWeight4f[4];
    NvF32 SetTransformFixedConst3[4];
    NvF32 SetTransformFixedConst0[4];
    NvF32 SetTransformFixedConst1[4];
    NvF32 SetTransformFixedConst2[4];
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvV32 SetVertexDataArrayOffset[16];
    NvV32 SetVertexDataArrayFormat[16];
    NvF32 SetBackSceneAmbientColor[3];
    NvF32 SetBackMaterialAlpha;
    NvF32 SetBackMaterialEmission[3];
    NvV32 SetLogicOpEnable;
    NvV32 SetLogicOp;
    NvV32 SetTwoSideLightEn;
    NvV32 ClearReportValue;
    NvV32 SetZpassPixelCountEnable;
    NvV32 GetReport;
    NvF32 SetTLConstZero[3];
    NvF32 SetEyeDirection[3];
    NvF32 SetLinearFogConst[3];
    NvV32 SetShaderClipPlaneMode;
    NvV32 SetBeginEnd;
    NvV32 ArrayElement16;
    NvV32 Reserved1804[0x4/4];
    NvU32 ArrayElement32;
    NvV32 Reserved180c[0x4/4];
    NvV32 DrawArrays;
    NvV32 Reserved1814[0x4/4];
    NvU32 InlineArray;
    NvF32 SetEyeVector[3];
    NvU32 InlineVertexReuse;
    NvV32 Reserved182c[0x54/4];
    struct {
    NvF32 M[2];
    } SetVertexData2f[16];
    NvS32 SetVertexData2s[16];
    NvS32 SetVertexData4ub[16];
    struct {
    NvS32 M[2];
    } SetVertexData4s[16];
    struct {
    NvF32 M[4];
    } SetVertexData4f[16];
    struct {
    NvU32 Offset;
    NvV32 Format;
    NvV32 Address;
    NvV32 Control0;
    NvV32 Control1;
    NvV32 Filter;
    NvV32 Reserved1b18[0x4/4];
    NvV32 ImageRect;
    NvV32 Palette;
    NvU32 BorderColor;
    NvF32 SetBumpEnvMat00;
    NvF32 SetBumpEnvMat01;
    NvF32 SetBumpEnvMat11;
    NvF32 SetBumpEnvMat10;
    NvF32 SetBumpEnvScale;
    NvF32 SetBumpEnvOffset;
    } SetTexture[4];
    NvV32 Reserved1c00[0x164/4];
    NvV32 ParkAttribute;
    NvV32 UnparkAttribute;
    NvU32 SetSemaphoreOffset;
    NvU32 BackEndWriteSemaphoreRelease;
    NvU32 TextureReadSemaphoreRelease;
    NvV32 SetZMinMaxControl;
    NvV32 SetAntiAliasingControl;
    NvV32 SetCompressZBufferEn;
    NvV32 SetOccludeZStencilEn;
    NvV32 Reserved1d88[0x4/4];
    NvU32 SetZStencilClearValue;
    NvU32 SetColorClearValue;
    NvV32 ClearSurface;
    NvV32 SetClearRectHorizontal;
    NvV32 SetClearRectVertical;
    NvV32 Reserved1da0[0x40/4];
    NvV32 SetBeginPatch0;
    NvV32 SetBeginPatch1;
    NvV32 SetBeginPatch2;
    NvV32 SetBeginPatch3;
    NvV32 SetEndPatch;
    NvV32 SetBeginEndSwatch;
    NvV32 SetBeginEndCurve;
    NvV32 Reserved1dfc[0x4/4];
    NvF32 SetCurveCoefficients[4];
    NvV32 SetBeginTransition0;
    NvV32 SetBeginTransition1;
    NvV32 SetBeginTransition2;
    NvV32 SetEndTransition;
    NvV32 SetSpecularFogFactor[2];
    NvF32 SetBackSpecularParams[6];
    NvV32 SetCombinerColorOCW[8];
    NvV32 SetCombinerControl;
    NvV32 Reserved1e64[0x4/4];
    NvF32 SetShadowZSlopeThreshold;
    NvV32 SetShadowDepthFunc;
    NvV32 SetShaderStageProgram;
    NvV32 SetDotRGBMapping;
    NvV32 SetShaderOtherStageInput;
    NvV32 Reserved1e7c[0x4/4];
    NvF32 SetTransformData[4];
    NvU32 LaunchTransformProgram;
    NvV32 SetTransformExecutionMode;
    NvV32 SetTransformProgramCxtWriteEn;
    NvU32 SetTransformProgramLoad;
    NvU32 SetTransformProgramStart;
    NvU32 SetTransformConstantLoad;
    NvV32 Reserved1ea8[0x118/4];
    NvV32 DebugInit[10];
    NvV32 Reserved1fe8[0x18/4];
} Nv20KelvinPrimitive;

#define NV097_NO_OPERATION                                                  0x00000100

#define NV097_NOTIFY                                                        0x00000104
#define NV097_NOTIFY_TYPE                                                         31:0
#define NV097_NOTIFY_TYPE_WRITE_ONLY                                        0x00000000
#define NV097_NOTIFY_TYPE_WRITE_THEN_AWAKEN                                 0x00000001

#define NV097_SET_WARNING_ENABLE                                            0x00000108
#define NV097_SET_WARNING_ENABLE_V                                                31:0
#define NV097_SET_WARNING_ENABLE_V_STOP                                     0x00000000
#define NV097_SET_WARNING_ENABLE_V_WRITE_ONLY                               0x00000001
#define NV097_SET_WARNING_ENABLE_V_WRITE_THEN_AWAKEN                        0x00000002

#define NV097_GET_STATE                                                     0x0000010c
#define NV097_GET_STATE_GETSTATE                                                  31:0
#define NV097_GET_STATE_GETSTATE_ALL_STATE                                  0x00000001
#define NV097_GET_STATE_GETSTATE_PUT_ALL_STATE                              0x00000002
#define NV097_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM                         0x00000006
#define NV097_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM                           0x00000007

#define NV097_WAIT_FOR_IDLE                                                 0x00000110

#define NV097_PM_TRIGGER                                                    0x00000140
#define NV097_PM_TRIGGER_V                                                        31:0
#define NV097_PM_TRIGGER_V_NOP                                              0x00000000
#define NV097_PM_TRIGGER_V_TRIGGER                                          0x00000001

#define NV097_SET_FLIP_READ                                                 0x00000120
#define NV097_SET_FLIP_READ_V                                                     31:0

#define NV097_SET_FLIP_WRITE                                                0x00000124
#define NV097_SET_FLIP_WRITE_V                                                    31:0

#define NV097_SET_FLIP_MODULO                                               0x00000128
#define NV097_SET_FLIP_MODULO_V                                                   31:0

#define NV097_FLIP_INCREMENT_WRITE                                          0x0000012c

#define NV097_FLIP_STALL                                                    0x00000130

#define NV097_SET_CONTEXT_DMA_NOTIFIES                                      0x00000180
#define NV097_SET_CONTEXT_DMA_NOTIFIES_V                                          31:0

#define NV097_SET_CONTEXT_DMA_A                                             0x00000184
#define NV097_SET_CONTEXT_DMA_A_V                                                 31:0

#define NV097_SET_CONTEXT_DMA_B                                             0x00000188
#define NV097_SET_CONTEXT_DMA_B_V                                                 31:0

#define NV097_SET_CONTEXT_DMA_STATE                                         0x00000190
#define NV097_SET_CONTEXT_DMA_STATE_V                                             31:0

#define NV097_SET_CONTEXT_DMA_COLOR                                         0x00000194
#define NV097_SET_CONTEXT_DMA_COLOR_V                                             31:0

#define NV097_SET_CONTEXT_DMA_ZETA                                          0x00000198
#define NV097_SET_CONTEXT_DMA_ZETA_V                                              31:0

#define NV097_SET_CONTEXT_DMA_VERTEX_A                                      0x0000019c
#define NV097_SET_CONTEXT_DMA_VERTEX_A_V                                          31:0

#define NV097_SET_CONTEXT_DMA_VERTEX_B                                      0x000001a0
#define NV097_SET_CONTEXT_DMA_VERTEX_B_V                                          31:0

#define NV097_SET_CONTEXT_DMA_SEMAPHORE                                     0x000001a4
#define NV097_SET_CONTEXT_DMA_SEMAPHORE_V                                         31:0

#define NV097_SET_CONTEXT_DMA_REPORT                                        0x000001a8
#define NV097_SET_CONTEXT_DMA_REPORT_V                                            31:0

#define NV097_SET_SURFACE_CLIP_HORIZONTAL                                   0x00000200
#define NV097_SET_SURFACE_CLIP_HORIZONTAL_X                                       15:0
#define NV097_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                  31:16

#define NV097_SET_SURFACE_CLIP_VERTICAL                                     0x00000204
#define NV097_SET_SURFACE_CLIP_VERTICAL_Y                                         15:0
#define NV097_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                   31:16

#define NV097_SET_SURFACE_PITCH                                             0x0000020c
#define NV097_SET_SURFACE_PITCH_COLOR                                             15:0
#define NV097_SET_SURFACE_PITCH_ZETA                                             31:16

#define NV097_SET_SURFACE_COLOR_OFFSET                                      0x00000210
#define NV097_SET_SURFACE_COLOR_OFFSET_V                                          31:0

#define NV097_SET_SURFACE_ZETA_OFFSET                                       0x00000214
#define NV097_SET_SURFACE_ZETA_OFFSET_V                                           31:0

#define NV097_SET_COMBINER_ALPHA_ICW(i)                             (0x00000260+(i)*4)
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP                                       31:29
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA                                     28:28
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE                                    27:24
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP                                       23:21
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA                                     20:20
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE                                    19:16
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP                                       15:13
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA                                     12:12
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE                                     11:8
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP                                         7:5
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA                                       4:4
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE                                      3:0
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                         0x0000000D

#define NV097_SET_COMBINER_COLOR_ICW(i)                             (0x00000ac0+(i)*4)
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP                                       31:29
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA                                     28:28
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE                                    27:24
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP                                       23:21
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA                                     20:20
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE                                    19:16
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP                                       15:13
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA                                     12:12
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE                                     11:8
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP                                         7:5
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA                                       4:4
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE                                      3:0
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                         0x0000000D

#define NV097_SET_COMBINER_FACTOR0(i)                               (0x00000a60+(i)*4)
#define NV097_SET_COMBINER_FACTOR0_BLUE                                            7:0
#define NV097_SET_COMBINER_FACTOR0_GREEN                                          15:8
#define NV097_SET_COMBINER_FACTOR0_RED                                           23:16
#define NV097_SET_COMBINER_FACTOR0_ALPHA                                         31:24

#define NV097_SET_COMBINER_FACTOR1(i)                               (0x00000a80+(i)*4)
#define NV097_SET_COMBINER_FACTOR1_BLUE                                            7:0
#define NV097_SET_COMBINER_FACTOR1_GREEN                                          15:8
#define NV097_SET_COMBINER_FACTOR1_RED                                           23:16
#define NV097_SET_COMBINER_FACTOR1_ALPHA                                         31:24

#define NV097_SET_COMBINER_ALPHA_OCW(i)                             (0x00000aa0+(i)*4)
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION                                   31:15
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                      0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS                 0x00000001
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1                 0x00000002
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS            0x00000003
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2                 0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1                0x00000006
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                  14:14
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                       0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                        0x00000001
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST                                      11:8
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                          0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                          0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                          0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                          0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                          0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_A                          0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_B                          0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                          0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                          0x0000000D
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST                                        7:4
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                           0x0000000D
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST                                        3:0
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                           0x0000000D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0                                 0x00000288
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                            31:29
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                              28:28
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                             27:24
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                            23:21
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                              20:20
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                             19:16
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                            15:13
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                              12:12
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                              11:8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                              7:5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                                4:4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                               3:0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD            0x0000000F

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1                                 0x0000028c
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                            31:29
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                              28:28
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                             27:24
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                            23:21
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                              20:20
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                             19:16
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                            15:13
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                              12:12
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                              11:8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                         7:7
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE            0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE             0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5                 6:6
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE    0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE     0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12                5:0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE    0x00000020

#define NV097_SET_CONTROL0                                                  0x00000290
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT                                   31:28
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_PASS                         0x00000000
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_CRYCB_TO_RGB                 0x00000001
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_SCRYSCB_TO_RGB               0x00000002
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA                                    27:24
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                         0x00000000
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                          0x00000001
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE                                    23:20
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                         0x00000000
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                          0x00000001
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                  19:16
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                       0x00000000
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                        0x00000001
#define NV097_SET_CONTROL0_Z_FORMAT                                              15:12
#define NV097_SET_CONTROL0_Z_FORMAT_FIXED                                   0x00000000
#define NV097_SET_CONTROL0_Z_FORMAT_FLOAT                                   0x00000001
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE                                    7:0
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                        0x00000001

#define NV097_SET_LIGHT_CONTROL                                             0x00000294
#define NV097_SET_LIGHT_CONTROL_LOCALEYE                                         16:16
#define NV097_SET_LIGHT_CONTROL_LOCALEYE_FALSE                              0x00000000
#define NV097_SET_LIGHT_CONTROL_LOCALEYE_TRUE                               0x00000001
#define NV097_SET_LIGHT_CONTROL_SOUT                                             31:17
#define NV097_SET_LIGHT_CONTROL_SOUT_ZERO_OUT                               0x00000000
#define NV097_SET_LIGHT_CONTROL_SOUT_PASSTHROUGH                            0x00000001
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                               1:0
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                  0x00000000
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                   0x00000001

#define NV097_SET_COLOR_MATERIAL                                            0x00000298
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL                                 1:0
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DISABLE                  0x00000000
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DIFFUSE_VTX_COLOR        0x00000001
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_SPECULAR_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL                                  3:2
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE                   0x00000000
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DIFFUSE_VTX_COLOR         0x00000001
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_SPECULAR_VTX_COLOR        0x00000002
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL                                     5:4
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE                      0x00000000
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DIFFUSE_VTX_COLOR            0x00000001
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_SPECULAR_VTX_COLOR           0x00000002
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL                                 7:6
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE                  0x00000000
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DIFFUSE_VTX_COLOR        0x00000001
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_SPECULAR_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL                            9:8
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DISABLE             0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DIFF_VTX_COLOR      0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_SPEC_VTX_COLOR      0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL                           11:10
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DISABLE              0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DIFF_VTX_COLOR       0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_SPEC_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL                              13:12
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DISABLE                 0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DIFF_VTX_COLOR          0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_SPEC_VTX_COLOR          0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL                          15:14
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DISABLE             0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DIFF_VTX_COLOR      0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_SPEC_VTX_COLOR      0x00000002

#define NV097_SET_FOG_MODE                                                  0x0000029c
#define NV097_SET_FOG_MODE_V                                                      31:0
#define NV097_SET_FOG_MODE_V_LINEAR                                         0x00002601
#define NV097_SET_FOG_MODE_V_EXP                                            0x00000800
#define NV097_SET_FOG_MODE_V_EXP2                                           0x00000801
#define NV097_SET_FOG_MODE_V_EXP_ABS                                        0x00000802
#define NV097_SET_FOG_MODE_V_EXP2_ABS                                       0x00000803
#define NV097_SET_FOG_MODE_V_LINEAR_ABS                                     0x00000804

#define NV097_SET_FOG_GEN_MODE                                              0x000002a0
#define NV097_SET_FOG_GEN_MODE_V                                                  31:0
#define NV097_SET_FOG_GEN_MODE_V_SPEC_ALPHA                                 0x00000000
#define NV097_SET_FOG_GEN_MODE_V_RADIAL                                     0x00000001
#define NV097_SET_FOG_GEN_MODE_V_PLANAR                                     0x00000002
#define NV097_SET_FOG_GEN_MODE_V_ABS_PLANAR                                 0x00000003
#define NV097_SET_FOG_GEN_MODE_V_FOG_X                                      0x00000006

#define NV097_SET_FOG_ENABLE                                                0x000002a4
#define NV097_SET_FOG_ENABLE_V                                                    31:0
#define NV097_SET_FOG_ENABLE_V_FALSE                                        0x00000000
#define NV097_SET_FOG_ENABLE_V_TRUE                                         0x00000001

#define NV097_SET_FOG_COLOR                                                 0x000002a8
#define NV097_SET_FOG_COLOR_RED                                                    7:0
#define NV097_SET_FOG_COLOR_GREEN                                                 15:8
#define NV097_SET_FOG_COLOR_BLUE                                                 23:16
#define NV097_SET_FOG_COLOR_ALPHA                                                31:24

#define NV097_SET_COLOR_KEY_COLOR(i)                                (0x00000ae0+(i)*4)
#define NV097_SET_COLOR_KEY_COLOR_V                                               31:0

#define NV097_SET_WINDOW_CLIP_TYPE                                          0x000002b4
#define NV097_SET_WINDOW_CLIP_TYPE_V                                              31:0
#define NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                              0x00000000
#define NV097_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                              0x00000001

#define NV097_SET_WINDOW_CLIP_HORIZONTAL(i)                         (0x000002c0+(i)*4)
#define NV097_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                     11:0
#define NV097_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                    27:16

#define NV097_SET_WINDOW_CLIP_VERTICAL(i)                           (0x000002e0+(i)*4)
#define NV097_SET_WINDOW_CLIP_VERTICAL_YMIN                                       11:0
#define NV097_SET_WINDOW_CLIP_VERTICAL_YMAX                                      27:16

#define NV097_SET_ALPHA_TEST_ENABLE                                         0x00000300
#define NV097_SET_ALPHA_TEST_ENABLE_V                                             31:0
#define NV097_SET_ALPHA_TEST_ENABLE_V_FALSE                                 0x00000000
#define NV097_SET_ALPHA_TEST_ENABLE_V_TRUE                                  0x00000001

#define NV097_SET_BLEND_ENABLE                                              0x00000304
#define NV097_SET_BLEND_ENABLE_V                                                  31:0
#define NV097_SET_BLEND_ENABLE_V_FALSE                                      0x00000000
#define NV097_SET_BLEND_ENABLE_V_TRUE                                       0x00000001

#define NV097_SET_CULL_FACE_ENABLE                                          0x00000308
#define NV097_SET_CULL_FACE_ENABLE_V                                              31:0
#define NV097_SET_CULL_FACE_ENABLE_V_FALSE                                  0x00000000
#define NV097_SET_CULL_FACE_ENABLE_V_TRUE                                   0x00000001

#define NV097_SET_DEPTH_TEST_ENABLE                                         0x0000030c
#define NV097_SET_DEPTH_TEST_ENABLE_V                                             31:0
#define NV097_SET_DEPTH_TEST_ENABLE_V_FALSE                                 0x00000000
#define NV097_SET_DEPTH_TEST_ENABLE_V_TRUE                                  0x00000001

#define NV097_SET_DITHER_ENABLE                                             0x00000310
#define NV097_SET_DITHER_ENABLE_V                                                 31:0
#define NV097_SET_DITHER_ENABLE_V_FALSE                                     0x00000000
#define NV097_SET_DITHER_ENABLE_V_TRUE                                      0x00000001

#define NV097_SET_LIGHTING_ENABLE                                           0x00000314
#define NV097_SET_LIGHTING_ENABLE_V                                               31:0
#define NV097_SET_LIGHTING_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_LIGHTING_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_POINT_PARAMS_ENABLE                                       0x00000318
#define NV097_SET_POINT_PARAMS_ENABLE_V                                           31:0
#define NV097_SET_POINT_PARAMS_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_POINT_PARAMS_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_POINT_SMOOTH_ENABLE                                       0x0000031c
#define NV097_SET_POINT_SMOOTH_ENABLE_V                                           31:0
#define NV097_SET_POINT_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_POINT_SMOOTH_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_LINE_SMOOTH_ENABLE                                        0x00000320
#define NV097_SET_LINE_SMOOTH_ENABLE_V                                            31:0
#define NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE                                0x00000000
#define NV097_SET_LINE_SMOOTH_ENABLE_V_TRUE                                 0x00000001

#define NV097_SET_POLY_SMOOTH_ENABLE                                        0x00000324
#define NV097_SET_POLY_SMOOTH_ENABLE_V                                            31:0
#define NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE                                0x00000000
#define NV097_SET_POLY_SMOOTH_ENABLE_V_TRUE                                 0x00000001

#define NV097_SET_STIPPLE_CONTROL                                           0x0000147c
#define NV097_SET_STIPPLE_CONTROL_V                                               31:0
#define NV097_SET_STIPPLE_CONTROL_V_OFF                                     0x00000000
#define NV097_SET_STIPPLE_CONTROL_V_POLYGON                                 0x00000001

#define NV097_SET_STIPPLE_PATTERN(i)                                (0x00001480+(i)*4)
#define NV097_SET_STIPPLE_PATTERN_V                                               31:0

#define NV097_SET_SKIN_MODE                                                 0x00000328
#define NV097_SET_SKIN_MODE_V                                                     31:0
#define NV097_SET_SKIN_MODE_V_OFF                                           0x00000000
#define NV097_SET_SKIN_MODE_V_2G                                            0x00000001
#define NV097_SET_SKIN_MODE_V_2                                             0x00000002
#define NV097_SET_SKIN_MODE_V_3G                                            0x00000003
#define NV097_SET_SKIN_MODE_V_3                                             0x00000004
#define NV097_SET_SKIN_MODE_V_4G                                            0x00000005
#define NV097_SET_SKIN_MODE_V_4                                             0x00000006

#define NV097_SET_STENCIL_TEST_ENABLE                                       0x0000032c
#define NV097_SET_STENCIL_TEST_ENABLE_V                                           31:0
#define NV097_SET_STENCIL_TEST_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_STENCIL_TEST_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_POLY_OFFSET_POINT_ENABLE                                  0x00000330
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V                                      31:0
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                          0x00000000
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                           0x00000001

#define NV097_SET_POLY_OFFSET_LINE_ENABLE                                   0x00000334
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V                                       31:0
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                           0x00000000
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                            0x00000001

#define NV097_SET_POLY_OFFSET_FILL_ENABLE                                   0x00000338
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V                                       31:0
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                           0x00000000
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                            0x00000001

#define NV097_SET_ALPHA_FUNC                                                0x0000033c
#define NV097_SET_ALPHA_FUNC_V                                                    31:0
#define NV097_SET_ALPHA_FUNC_V_NEVER                                        0x00000200
#define NV097_SET_ALPHA_FUNC_V_LESS                                         0x00000201
#define NV097_SET_ALPHA_FUNC_V_EQUAL                                        0x00000202
#define NV097_SET_ALPHA_FUNC_V_LEQUAL                                       0x00000203
#define NV097_SET_ALPHA_FUNC_V_GREATER                                      0x00000204
#define NV097_SET_ALPHA_FUNC_V_NOTEQUAL                                     0x00000205
#define NV097_SET_ALPHA_FUNC_V_GEQUAL                                       0x00000206
#define NV097_SET_ALPHA_FUNC_V_ALWAYS                                       0x00000207

#define NV097_SET_ALPHA_REF                                                 0x00000340
#define NV097_SET_ALPHA_REF_V                                                     31:0

#define NV097_SET_BLEND_FUNC_SFACTOR                                        0x00000344
#define NV097_SET_BLEND_FUNC_SFACTOR_V                                            31:0
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ZERO                                 0x00000000
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE                                  0x00000001
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                            0x00000300
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                  0x00000301
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                            0x00000302
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                  0x00000303
#define NV097_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                            0x00000304
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                  0x00000305
#define NV097_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                            0x00000306
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                  0x00000307
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                   0x00000308
#define NV097_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                       0x00008001
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR             0x00008002
#define NV097_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                       0x00008003
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA             0x00008004

#define NV097_SET_BLEND_FUNC_DFACTOR                                        0x00000348
#define NV097_SET_BLEND_FUNC_DFACTOR_V                                            31:0
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ZERO                                 0x00000000
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE                                  0x00000001
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                            0x00000300
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                  0x00000301
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                            0x00000302
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                  0x00000303
#define NV097_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                            0x00000304
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                  0x00000305
#define NV097_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                            0x00000306
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                  0x00000307
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_SATURATE                   0x00000308
#define NV097_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                       0x00008001
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR             0x00008002
#define NV097_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                       0x00008003
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA             0x00008004

#define NV097_SET_BLEND_COLOR                                               0x0000034c
#define NV097_SET_BLEND_COLOR_V                                                   31:0

#define NV097_SET_BLEND_EQUATION                                            0x00000350
#define NV097_SET_BLEND_EQUATION_V                                                31:0
#define NV097_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                            0x0000800A
#define NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                    0x0000800B
#define NV097_SET_BLEND_EQUATION_V_FUNC_ADD                                 0x00008006
#define NV097_SET_BLEND_EQUATION_V_MIN                                      0x00008007
#define NV097_SET_BLEND_EQUATION_V_MAX                                      0x00008008
#define NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT_SIGNED             0x0000F005
#define NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED                          0x0000F006

#define NV097_SET_DEPTH_FUNC                                                0x00000354
#define NV097_SET_DEPTH_FUNC_V                                                    31:0
#define NV097_SET_DEPTH_FUNC_V_NEVER                                        0x00000200
#define NV097_SET_DEPTH_FUNC_V_LESS                                         0x00000201
#define NV097_SET_DEPTH_FUNC_V_EQUAL                                        0x00000202
#define NV097_SET_DEPTH_FUNC_V_LEQUAL                                       0x00000203
#define NV097_SET_DEPTH_FUNC_V_GREATER                                      0x00000204
#define NV097_SET_DEPTH_FUNC_V_NOTEQUAL                                     0x00000205
#define NV097_SET_DEPTH_FUNC_V_GEQUAL                                       0x00000206
#define NV097_SET_DEPTH_FUNC_V_ALWAYS                                       0x00000207

#define NV097_SET_COLOR_MASK                                                0x00000358
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                  31:24
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                        0x00000001
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE                                    23:16
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                         0x00000000
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                          0x00000001
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                   15:8
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                        0x00000001
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                     7:0
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                        0x00000000
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                         0x00000001

#define NV097_SET_DEPTH_MASK                                                0x0000035c
#define NV097_SET_DEPTH_MASK_V                                                    31:0
#define NV097_SET_DEPTH_MASK_V_FALSE                                        0x00000000
#define NV097_SET_DEPTH_MASK_V_TRUE                                         0x00000001

#define NV097_SET_STENCIL_MASK                                              0x00000360
#define NV097_SET_STENCIL_MASK_V                                                  31:0

#define NV097_SET_STENCIL_FUNC                                              0x00000364
#define NV097_SET_STENCIL_FUNC_V                                                  31:0
#define NV097_SET_STENCIL_FUNC_V_NEVER                                      0x00000200
#define NV097_SET_STENCIL_FUNC_V_LESS                                       0x00000201
#define NV097_SET_STENCIL_FUNC_V_EQUAL                                      0x00000202
#define NV097_SET_STENCIL_FUNC_V_LEQUAL                                     0x00000203
#define NV097_SET_STENCIL_FUNC_V_GREATER                                    0x00000204
#define NV097_SET_STENCIL_FUNC_V_NOTEQUAL                                   0x00000205
#define NV097_SET_STENCIL_FUNC_V_GEQUAL                                     0x00000206
#define NV097_SET_STENCIL_FUNC_V_ALWAYS                                     0x00000207

#define NV097_SET_STENCIL_FUNC_REF                                          0x00000368
#define NV097_SET_STENCIL_FUNC_REF_V                                              31:0

#define NV097_SET_STENCIL_FUNC_MASK                                         0x0000036c
#define NV097_SET_STENCIL_FUNC_MASK_V                                             31:0

#define NV097_SET_STENCIL_OP_FAIL                                           0x00000370
#define NV097_SET_STENCIL_OP_FAIL_V                                               31:0
#define NV097_SET_STENCIL_OP_FAIL_V_KEEP                                    0x00001E00
#define NV097_SET_STENCIL_OP_FAIL_V_ZERO                                    0x00000000
#define NV097_SET_STENCIL_OP_FAIL_V_REPLACE                                 0x00001E01
#define NV097_SET_STENCIL_OP_FAIL_V_INCRSAT                                 0x00001E02
#define NV097_SET_STENCIL_OP_FAIL_V_DECRSAT                                 0x00001E03
#define NV097_SET_STENCIL_OP_FAIL_V_INVERT                                  0x0000150A
#define NV097_SET_STENCIL_OP_FAIL_V_INCR                                    0x00008507
#define NV097_SET_STENCIL_OP_FAIL_V_DECR                                    0x00008508

#define NV097_SET_STENCIL_OP_ZFAIL                                          0x00000374
#define NV097_SET_STENCIL_OP_ZFAIL_V                                              31:0
#define NV097_SET_STENCIL_OP_ZFAIL_V_KEEP                                   0x00001E00
#define NV097_SET_STENCIL_OP_ZFAIL_V_ZERO                                   0x00000000
#define NV097_SET_STENCIL_OP_ZFAIL_V_REPLACE                                0x00001E01
#define NV097_SET_STENCIL_OP_ZFAIL_V_INCRSAT                                0x00001E02
#define NV097_SET_STENCIL_OP_ZFAIL_V_DECRSAT                                0x00001E03
#define NV097_SET_STENCIL_OP_ZFAIL_V_INVERT                                 0x0000150A
#define NV097_SET_STENCIL_OP_ZFAIL_V_INCR                                   0x00008507
#define NV097_SET_STENCIL_OP_ZFAIL_V_DECR                                   0x00008508

#define NV097_SET_STENCIL_OP_ZPASS                                          0x00000378
#define NV097_SET_STENCIL_OP_ZPASS_V                                              31:0
#define NV097_SET_STENCIL_OP_ZPASS_V_KEEP                                   0x00001E00
#define NV097_SET_STENCIL_OP_ZPASS_V_ZERO                                   0x00000000
#define NV097_SET_STENCIL_OP_ZPASS_V_REPLACE                                0x00001E01
#define NV097_SET_STENCIL_OP_ZPASS_V_INCRSAT                                0x00001E02
#define NV097_SET_STENCIL_OP_ZPASS_V_DECRSAT                                0x00001E03
#define NV097_SET_STENCIL_OP_ZPASS_V_INVERT                                 0x0000150A
#define NV097_SET_STENCIL_OP_ZPASS_V_INCR                                   0x00008507
#define NV097_SET_STENCIL_OP_ZPASS_V_DECR                                   0x00008508

#define NV097_SET_SHADE_MODE                                                0x0000037c
#define NV097_SET_SHADE_MODE_V                                                    31:0
#define NV097_SET_SHADE_MODE_V_FLAT                                         0x00001D00
#define NV097_SET_SHADE_MODE_V_SMOOTH                                       0x00001D01

#define NV097_SET_LINE_WIDTH                                                0x00000380
#define NV097_SET_LINE_WIDTH_V                                                    31:0

#define NV097_SET_POLYGON_OFFSET_SCALE_FACTOR                               0x00000384
#define NV097_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                   31:0

#define NV097_SET_POLYGON_OFFSET_BIAS                                       0x00000388
#define NV097_SET_POLYGON_OFFSET_BIAS_V                                           31:0

#define NV097_SET_FRONT_POLYGON_MODE                                        0x0000038c
#define NV097_SET_FRONT_POLYGON_MODE_V                                            31:0
#define NV097_SET_FRONT_POLYGON_MODE_V_POINT                                0x00001B00
#define NV097_SET_FRONT_POLYGON_MODE_V_LINE                                 0x00001B01
#define NV097_SET_FRONT_POLYGON_MODE_V_FILL                                 0x00001B02

#define NV097_SET_BACK_POLYGON_MODE                                         0x00000390
#define NV097_SET_BACK_POLYGON_MODE_V                                             31:0
#define NV097_SET_BACK_POLYGON_MODE_V_POINT                                 0x00001B00
#define NV097_SET_BACK_POLYGON_MODE_V_LINE                                  0x00001B01
#define NV097_SET_BACK_POLYGON_MODE_V_FILL                                  0x00001B02

#define NV097_SET_CLIP_MIN                                                  0x00000394
#define NV097_SET_CLIP_MIN_V                                                      31:0

#define NV097_SET_CLIP_MAX                                                  0x00000398
#define NV097_SET_CLIP_MAX_V                                                      31:0

#define NV097_SET_CULL_FACE                                                 0x0000039c
#define NV097_SET_CULL_FACE_V                                                     31:0
#define NV097_SET_CULL_FACE_V_FRONT                                         0x00000404
#define NV097_SET_CULL_FACE_V_BACK                                          0x00000405
#define NV097_SET_CULL_FACE_V_FRONT_AND_BACK                                0x00000408

#define NV097_SET_FRONT_FACE                                                0x000003a0
#define NV097_SET_FRONT_FACE_V                                                    31:0
#define NV097_SET_FRONT_FACE_V_CW                                           0x00000900
#define NV097_SET_FRONT_FACE_V_CCW                                          0x00000901

#define NV097_SET_NORMALIZATION_ENABLE                                      0x000003a4
#define NV097_SET_NORMALIZATION_ENABLE_V                                          31:0
#define NV097_SET_NORMALIZATION_ENABLE_V_FALSE                              0x00000000
#define NV097_SET_NORMALIZATION_ENABLE_V_TRUE                               0x00000001

#define NV097_SET_MATERIAL_EMISSION(i)                              (0x000003a8+(i)*4)
#define NV097_SET_MATERIAL_EMISSION_V                                             31:0

#define NV097_SET_MATERIAL_ALPHA                                            0x000003b4
#define NV097_SET_MATERIAL_ALPHA_V                                                31:0

#define NV097_SET_BACK_MATERIAL_ALPHA                                       0x000017ac
#define NV097_SET_BACK_MATERIAL_ALPHA_V                                           31:0

#define NV097_SET_SPECULAR_ENABLE                                           0x000003b8
#define NV097_SET_SPECULAR_ENABLE_V                                               31:0
#define NV097_SET_SPECULAR_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_SPECULAR_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_LIGHT_ENABLE_MASK                                         0x000003bc
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0                                         1:0
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1                                         3:2
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2                                         5:4
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3                                         7:6
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4                                         9:8
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5                                       11:10
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6                                       13:12
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7                                       15:14
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                             0x00000003

#define NV097_SET_VERTEX_DATA2F_M(i,j)                        (0x00001880+(i)*8+(j)*4)
#define NV097_SET_VERTEX_DATA2F_M_V                                               31:0

#define NV097_SET_VERTEX_DATA4F_M(i,j)                       (0x00001a00+(i)*16+(j)*4)
#define NV097_SET_VERTEX_DATA4F_M_V                                               31:0

#define NV097_SET_VERTEX_DATA2S(i)                                  (0x00001900+(i)*4)
#define NV097_SET_VERTEX_DATA2S_V                                                 31:0

#define NV097_SET_VERTEX_DATA4UB(i)                                 (0x00001940+(i)*4)
#define NV097_SET_VERTEX_DATA4UB_V                                                31:0

#define NV097_SET_VERTEX_DATA4S_M(i,j)                        (0x00001980+(i)*8+(j)*4)
#define NV097_SET_VERTEX_DATA4S_M_V                                               31:0

#define NV097_SET_TEXGEN_S(i)                                      (0x000003c0+(i)*16)
#define NV097_SET_TEXGEN_S_V                                                      31:0
#define NV097_SET_TEXGEN_S_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_S_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_S_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_S_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_S_V_OBJECT_LINEAR                                  0x00002401
#define NV097_SET_TEXGEN_S_V_SPHERE_MAP                                     0x00002402

#define NV097_SET_TEXGEN_T(i)                                      (0x000003c4+(i)*16)
#define NV097_SET_TEXGEN_T_V                                                      31:0
#define NV097_SET_TEXGEN_T_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_T_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_T_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_T_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_T_V_OBJECT_LINEAR                                  0x00002401
#define NV097_SET_TEXGEN_T_V_SPHERE_MAP                                     0x00002402

#define NV097_SET_TEXGEN_R(i)                                      (0x000003c8+(i)*16)
#define NV097_SET_TEXGEN_R_V                                                      31:0
#define NV097_SET_TEXGEN_R_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_R_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_R_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_R_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_R_V_OBJECT_LINEAR                                  0x00002401

#define NV097_SET_TEXGEN_Q(i)                                      (0x000003cc+(i)*16)
#define NV097_SET_TEXGEN_Q_V                                                      31:0
#define NV097_SET_TEXGEN_Q_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_Q_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_Q_V_OBJECT_LINEAR                                  0x00002401

#define NV097_SET_TEXGEN_VIEW_MODEL                                         0x000009cc
#define NV097_SET_TEXGEN_VIEW_MODEL_V                                             31:0
#define NV097_SET_TEXGEN_VIEW_MODEL_V_LOCAL_VIEWER                          0x00000000
#define NV097_SET_TEXGEN_VIEW_MODEL_V_INFINITE_VIEWER                       0x00000001

#define NV097_SET_TEXTURE_MATRIX_ENABLE(i)                          (0x00000420+(i)*4)
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V                                         31:0
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE                             0x00000000
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE                              0x00000001

#define NV097_SET_POINT_SIZE                                                0x0000043c
#define NV097_SET_POINT_SIZE_V                                                    31:0

#define NV097_SET_SWATH_WIDTH                                               0x000009f8
#define NV097_SET_SWATH_WIDTH_V                                                   31:0
#define NV097_SET_SWATH_WIDTH_V_8                                           0x00000000
#define NV097_SET_SWATH_WIDTH_V_16                                          0x00000001
#define NV097_SET_SWATH_WIDTH_V_32                                          0x00000002
#define NV097_SET_SWATH_WIDTH_V_64                                          0x00000003
#define NV097_SET_SWATH_WIDTH_V_128                                         0x00000004
#define NV097_SET_SWATH_WIDTH_V_OFF                                         0x0000000F

#define NV097_SET_FLAT_SHADE_OP                                             0x000009fc
#define NV097_SET_FLAT_SHADE_OP_V                                                 31:0
#define NV097_SET_FLAT_SHADE_OP_V_LAST_VTX                                  0x00000000
#define NV097_SET_FLAT_SHADE_OP_V_FIRST_VTX                                 0x00000001

#define NV097_SET_PROJECTION_MATRIX(i)                              (0x00000440+(i)*4)
#define NV097_SET_PROJECTION_MATRIX_V                                             31:0

#define NV097_SET_MODEL_VIEW_MATRIX0(i)                             (0x00000480+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX0_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX1(i)                             (0x000004c0+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX1_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX2(i)                             (0x00000500+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX2_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX3(i)                             (0x00000540+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX3_V                                            31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                     (0x00000580+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX0_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                     (0x000005c0+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX1_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX2(i)                     (0x00000600+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX2_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX3(i)                     (0x00000640+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX3_V                                    31:0

#define NV097_SET_COMPOSITE_MATRIX(i)                               (0x00000680+(i)*4)
#define NV097_SET_COMPOSITE_MATRIX_V                                              31:0

#define NV097_SET_TEXTURE_MATRIX0(i)                                (0x000006c0+(i)*4)
#define NV097_SET_TEXTURE_MATRIX0_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX1(i)                                (0x00000700+(i)*4)
#define NV097_SET_TEXTURE_MATRIX1_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX2(i)                                (0x00000740+(i)*4)
#define NV097_SET_TEXTURE_MATRIX2_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX3(i)                                (0x00000780+(i)*4)
#define NV097_SET_TEXTURE_MATRIX3_V                                               31:0

#define NV097_SET_TEXGEN_PLANE_S(i,j)                        (0x00000840+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_S_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_T(i,j)                        (0x00000850+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_T_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_R(i,j)                        (0x00000860+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_R_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_Q(i,j)                        (0x00000870+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_Q_V                                                31:0

#define NV097_SET_FOG_PARAMS(i)                                     (0x000009c0+(i)*4)
#define NV097_SET_FOG_PARAMS_V                                                    31:0

#define NV097_SET_FOG_PLANE(i)                                      (0x000009d0+(i)*4)
#define NV097_SET_FOG_PLANE_V                                                     31:0

#define NV097_SET_SPECULAR_PARAMS(i)                                (0x000009e0+(i)*4)
#define NV097_SET_SPECULAR_PARAMS_V                                               31:0

#define NV097_SET_BACK_SPECULAR_PARAMS(i)                           (0x00001e28+(i)*4)
#define NV097_SET_BACK_SPECULAR_PARAMS_V                                          31:0

#define NV097_SET_SCENE_AMBIENT_COLOR(i)                            (0x00000a10+(i)*4)
#define NV097_SET_SCENE_AMBIENT_COLOR_V                                           31:0

#define NV097_SET_VIEWPORT_SCALE(i)                                 (0x00000af0+(i)*4)
#define NV097_SET_VIEWPORT_SCALE_V                                                31:0

#define NV097_SET_VIEWPORT_OFFSET(i)                                (0x00000a20+(i)*4)
#define NV097_SET_VIEWPORT_OFFSET_V                                               31:0

#define NV097_SET_POINT_PARAMS(i)                                   (0x00000a30+(i)*4)
#define NV097_SET_POINT_PARAMS_V                                                  31:0

#define NV097_SET_EYE_POSITION(i)                                   (0x00000a50+(i)*4)
#define NV097_SET_EYE_POSITION_V                                                  31:0

#define NV097_SET_BACK_LIGHT_AMBIENT_COLOR(i,j)              (0x00000c00+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_AMBIENT_COLOR_V                                      31:0

#define NV097_SET_BACK_LIGHT_DIFFUSE_COLOR(i,j)              (0x00000c0c+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_DIFFUSE_COLOR_V                                      31:0

#define NV097_SET_BACK_LIGHT_SPECULAR_COLOR(i,j)             (0x00000c18+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_SPECULAR_COLOR_V                                     31:0

#define NV097_SET_LIGHT_AMBIENT_COLOR(i,j)                  (0x00001000+(i)*128+(j)*4)
#define NV097_SET_LIGHT_AMBIENT_COLOR_V                                           31:0

#define NV097_SET_LIGHT_DIFFUSE_COLOR(i,j)                  (0x0000100c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_DIFFUSE_COLOR_V                                           31:0

#define NV097_SET_LIGHT_SPECULAR_COLOR(i,j)                 (0x00001018+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPECULAR_COLOR_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_RANGE(i)                            (0x00001024+(i)*128)
#define NV097_SET_LIGHT_LOCAL_RANGE_V                                             31:0

#define NV097_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)           (0x00001028+(i)*128+(j)*4)
#define NV097_SET_LIGHT_INFINITE_HALF_VECTOR_V                                    31:0

#define NV097_SET_LIGHT_INFINITE_DIRECTION(i,j)             (0x00001034+(i)*128+(j)*4)
#define NV097_SET_LIGHT_INFINITE_DIRECTION_V                                      31:0

#define NV097_SET_LIGHT_SPOT_FALLOFF(i,j)                   (0x00001040+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPOT_FALLOFF_V                                            31:0

#define NV097_SET_LIGHT_SPOT_DIRECTION(i,j)                 (0x0000104c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPOT_DIRECTION_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_POSITION(i,j)                 (0x0000105c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_LOCAL_POSITION_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_ATTENUATION(i,j)              (0x00001068+(i)*128+(j)*4)
#define NV097_SET_LIGHT_LOCAL_ATTENUATION_V                                       31:0

#define NV097_SET_VERTEX3F(i)                                       (0x00001500+(i)*4)
#define NV097_SET_VERTEX3F_V                                                      31:0

#define NV097_SET_VERTEX4F(i)                                       (0x00001518+(i)*4)
#define NV097_SET_VERTEX4F_V                                                      31:0

#define NV097_SET_VERTEX4S(i)                                       (0x00001528+(i)*4)
#define NV097_SET_VERTEX4S_V                                                      31:0

#define NV097_SET_NORMAL3F(i)                                       (0x00001530+(i)*4)
#define NV097_SET_NORMAL3F_V                                                      31:0

#define NV097_SET_NORMAL3S(i)                                       (0x00001540+(i)*4)
#define NV097_SET_NORMAL3S_V                                                      31:0

#define NV097_SET_DIFFUSE_COLOR4F(i)                                (0x00001550+(i)*4)
#define NV097_SET_DIFFUSE_COLOR4F_V                                               31:0

#define NV097_SET_DIFFUSE_COLOR3F(i)                                (0x00001560+(i)*4)
#define NV097_SET_DIFFUSE_COLOR3F_V                                               31:0

#define NV097_SET_DIFFUSE_COLOR4UB                                          0x0000156c
#define NV097_SET_DIFFUSE_COLOR4UB_V                                              31:0

#define NV097_SET_SPECULAR_COLOR4F(i)                               (0x00001570+(i)*4)
#define NV097_SET_SPECULAR_COLOR4F_V                                              31:0

#define NV097_SET_SPECULAR_COLOR3F(i)                               (0x00001580+(i)*4)
#define NV097_SET_SPECULAR_COLOR3F_V                                              31:0

#define NV097_SET_SPECULAR_COLOR4UB                                         0x0000158c
#define NV097_SET_SPECULAR_COLOR4UB_V                                             31:0

#define NV097_SET_TEXCOORD0_2F(i)                                   (0x00001590+(i)*4)
#define NV097_SET_TEXCOORD0_2F_V                                                  31:0

#define NV097_SET_TEXCOORD0_2S                                              0x00001598
#define NV097_SET_TEXCOORD0_2S_V                                                  31:0

#define NV097_SET_TEXCOORD0_4F(i)                                   (0x000015a0+(i)*4)
#define NV097_SET_TEXCOORD0_4F_V                                                  31:0

#define NV097_SET_TEXCOORD0_4S(i)                                   (0x000015b0+(i)*4)
#define NV097_SET_TEXCOORD0_4S_V                                                  31:0

#define NV097_SET_TEXCOORD1_2F(i)                                   (0x000015b8+(i)*4)
#define NV097_SET_TEXCOORD1_2F_V                                                  31:0

#define NV097_SET_TEXCOORD1_2S                                              0x000015c0
#define NV097_SET_TEXCOORD1_2S_V                                                  31:0

#define NV097_SET_TEXCOORD1_4F(i)                                   (0x000015c8+(i)*4)
#define NV097_SET_TEXCOORD1_4F_V                                                  31:0

#define NV097_SET_TEXCOORD1_4S(i)                                   (0x000015d8+(i)*4)
#define NV097_SET_TEXCOORD1_4S_V                                                  31:0

#define NV097_SET_TEXCOORD2_2F(i)                                   (0x000015e0+(i)*4)
#define NV097_SET_TEXCOORD2_2F_V                                                  31:0

#define NV097_SET_TEXCOORD2_2S                                              0x000015e8
#define NV097_SET_TEXCOORD2_2S_V                                                  31:0

#define NV097_SET_TEXCOORD2_4F(i)                                   (0x000015f0+(i)*4)
#define NV097_SET_TEXCOORD2_4F_V                                                  31:0

#define NV097_SET_TEXCOORD2_4S(i)                                   (0x00001600+(i)*4)
#define NV097_SET_TEXCOORD2_4S_V                                                  31:0

#define NV097_SET_TEXCOORD3_2F(i)                                   (0x00001608+(i)*4)
#define NV097_SET_TEXCOORD3_2F_V                                                  31:0

#define NV097_SET_TEXCOORD3_2S                                              0x00001610
#define NV097_SET_TEXCOORD3_2S_V                                                  31:0

#define NV097_SET_TEXCOORD3_4F(i)                                   (0x00001620+(i)*4)
#define NV097_SET_TEXCOORD3_4F_V                                                  31:0

#define NV097_SET_TEXCOORD3_4S(i)                                   (0x00001630+(i)*4)
#define NV097_SET_TEXCOORD3_4S_V                                                  31:0

#define NV097_SET_FOG1F                                                     0x00001698
#define NV097_SET_FOG1F_V                                                         31:0

#define NV097_SET_WEIGHT1F                                                  0x0000169c
#define NV097_SET_WEIGHT1F_V                                                      31:0

#define NV097_SET_WEIGHT2F(i)                                       (0x000016a0+(i)*4)
#define NV097_SET_WEIGHT2F_V                                                      31:0

#define NV097_SET_WEIGHT3F(i)                                       (0x000016b0+(i)*4)
#define NV097_SET_WEIGHT3F_V                                                      31:0

#define NV097_SET_WEIGHT4F(i)                                       (0x000016c0+(i)*4)
#define NV097_SET_WEIGHT4F_V                                                      31:0

#define NV097_SET_EDGE_FLAG                                                 0x000016bc
#define NV097_SET_EDGE_FLAG_V                                                     31:0
#define NV097_SET_EDGE_FLAG_V_FALSE                                         0x00000000
#define NV097_SET_EDGE_FLAG_V_TRUE                                          0x00000001

#define NV097_SET_TRANSFORM_FIXED_CONST0(i)                         (0x000016e0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST0_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST1(i)                         (0x000016f0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST1_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST2(i)                         (0x00001700+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST2_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST3(i)                         (0x000016d0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST3_V                                        31:0

#define NV097_SET_TLCONST_ZERO(i)                                   (0x000017d4+(i)*4)
#define NV097_SET_TLCONST_ZERO_V                                                  31:0

#define NV097_SET_EYE_DIRECTION(i)                                  (0x000017e0+(i)*4)
#define NV097_SET_EYE_DIRECTION_V                                                 31:0

#define NV097_SET_LINEAR_FOG_CONST(i)                               (0x000017ec+(i)*4)
#define NV097_SET_LINEAR_FOG_CONST_V                                              31:0

#define NV097_INVALIDATE_VERTEX_CACHE_FILE                                  0x00001710

#define NV097_INVALIDATE_VERTEX_FILE                                        0x00001714

#define NV097_TL_NOP                                                        0x00001718

#define NV097_TL_SYNC                                                       0x0000171c

#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET(i)                       (0x00001720+(i)*4)
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA                           31:31
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_A             0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_B             0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_OFFSET                                 30:0

#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT(i)                       (0x00001760+(i)*4)
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_STRIDE                                 31:8
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE                                    7:4
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED                    0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3W                          0x00000007
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE                                    3:0
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D                      0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S1                          0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F                           0x00000002
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_OGL                      0x00000004
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K                        0x00000005
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_CMP                         0x00000006

#define NV097_SET_LOGIC_OP_ENABLE                                           0x000017bc
#define NV097_SET_LOGIC_OP_ENABLE_V                                               31:0
#define NV097_SET_LOGIC_OP_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_LOGIC_OP_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_LOGIC_OP                                                  0x000017c0
#define NV097_SET_LOGIC_OP_V                                                      31:0
#define NV097_SET_LOGIC_OP_V_CLEAR                                          0x00001500
#define NV097_SET_LOGIC_OP_V_AND                                            0x00001501
#define NV097_SET_LOGIC_OP_V_AND_REVERSE                                    0x00001502
#define NV097_SET_LOGIC_OP_V_COPY                                           0x00001503
#define NV097_SET_LOGIC_OP_V_AND_INVERTED                                   0x00001504
#define NV097_SET_LOGIC_OP_V_NOOP                                           0x00001505
#define NV097_SET_LOGIC_OP_V_XOR                                            0x00001506
#define NV097_SET_LOGIC_OP_V_OR                                             0x00001507
#define NV097_SET_LOGIC_OP_V_NOR                                            0x00001508
#define NV097_SET_LOGIC_OP_V_EQUIV                                          0x00001509
#define NV097_SET_LOGIC_OP_V_INVERT                                         0x0000150A
#define NV097_SET_LOGIC_OP_V_OR_REVERSE                                     0x0000150B
#define NV097_SET_LOGIC_OP_V_COPY_INVERTED                                  0x0000150C
#define NV097_SET_LOGIC_OP_V_OR_INVERTED                                    0x0000150D
#define NV097_SET_LOGIC_OP_V_NAND                                           0x0000150E
#define NV097_SET_LOGIC_OP_V_SET                                            0x0000150F

#define NV097_SET_BEGIN_END                                                 0x000017fc
#define NV097_SET_BEGIN_END_OP                                                    31:0
#define NV097_SET_BEGIN_END_OP_END                                          0x00000000
#define NV097_SET_BEGIN_END_OP_POINTS                                       0x00000001
#define NV097_SET_BEGIN_END_OP_LINES                                        0x00000002
#define NV097_SET_BEGIN_END_OP_LINE_LOOP                                    0x00000003
#define NV097_SET_BEGIN_END_OP_LINE_STRIP                                   0x00000004
#define NV097_SET_BEGIN_END_OP_TRIANGLES                                    0x00000005
#define NV097_SET_BEGIN_END_OP_TRIANGLE_STRIP                               0x00000006
#define NV097_SET_BEGIN_END_OP_TRIANGLE_FAN                                 0x00000007
#define NV097_SET_BEGIN_END_OP_QUADS                                        0x00000008
#define NV097_SET_BEGIN_END_OP_QUAD_STRIP                                   0x00000009
#define NV097_SET_BEGIN_END_OP_POLYGON                                      0x0000000A

#define NV097_ARRAY_ELEMENT16                                               0x00001800
#define NV097_ARRAY_ELEMENT16_VERTEX0                                             15:0
#define NV097_ARRAY_ELEMENT16_VERTEX1                                            31:16

#define NV097_ARRAY_ELEMENT32                                               0x00001808
#define NV097_ARRAY_ELEMENT32_V                                                   31:0

#define NV097_DRAW_ARRAYS                                                   0x00001810
#define NV097_DRAW_ARRAYS_COUNT                                                  31:24
#define NV097_DRAW_ARRAYS_START_INDEX                                             23:0

#define NV097_INLINE_VERTEX_REUSE                                           0x00001828
#define NV097_INLINE_VERTEX_REUSE_V                                               31:0

#define NV097_INLINE_ARRAY                                                  0x00001818
#define NV097_INLINE_ARRAY_V                                                      31:0

#define NV097_SET_TEXTURE_OFFSET(i)                                (0x00001b00+(i)*64)
#define NV097_SET_TEXTURE_OFFSET_V                                                31:0

#define NV097_SET_TEXTURE_FORMAT(i)                                (0x00001b04+(i)*64)
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA                                       1:0
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                    2:2
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                       0x00000000
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                        0x00000001
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE                                     3:3
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_TEXTURE                      0x00000000
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR                        0x00000001
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY                                    7:4
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_ONE                         0x00000001
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO                         0x00000002
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE                       0x00000003
#define NV097_SET_TEXTURE_FORMAT_COLOR                                            15:8
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y8                                0x00000000
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_AY8                               0x00000001
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A1R5G5B5                          0x00000002
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X1R5G5B5                          0x00000003
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A4R4G4B4                          0x00000004
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G6B5                            0x00000005
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8R8G8B8                          0x00000006
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8                          0x00000007
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_I8_A8R8G8B8                       0x0000000B
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5                      0x0000000C
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8                     0x0000000E
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8                     0x0000000F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5                    0x00000010
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5                      0x00000011
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8                    0x00000012
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8                          0x00000013
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8                         0x00000014
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9                       0x00000015
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8                        0x00000016
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8                        0x00000017
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8                      0x00000018
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8                                0x00000019
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8Y8                              0x0000001A
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8                         0x0000001B
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5                    0x0000001C
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4                    0x0000001D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8                    0x0000001E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8                          0x0000001F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8                        0x00000020
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8                0x00000024
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8                0x00000025
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8                  0x00000026
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R6G5B5                            0x00000027
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_G8B8                              0x00000028
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R8B8                              0x00000029
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_X8_Y24_FIXED                0x0000002A
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_X8_Y24_FLOAT                0x0000002B
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_Y16_FIXED                   0x0000002C
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_Y16_FLOAT                   0x0000002D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED          0x0000002E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT          0x0000002F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED             0x00000030
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT             0x00000031
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y16                               0x00000032
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_YB_16_YA_16                       0x00000033
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6              0x00000034
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16                         0x00000035
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16                    0x00000036
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5                      0x00000037
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G5B5A1                          0x00000038
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R4G4B4A4                          0x00000039
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8B8G8R8                          0x0000003A
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_B8G8R8A8                          0x0000003B
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R8G8B8A8                          0x0000003C
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1                    0x0000003D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4                    0x0000003E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8                    0x0000003F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8                    0x00000040
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8                    0x00000041
#define NV097_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                   19:16
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U                                     23:20
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                            0x00000009
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                           0x0000000A
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                           0x0000000B
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_4096                           0x0000000C
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V                                     27:24
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                            0x00000009
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                           0x0000000A
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                           0x0000000B
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_4096                           0x0000000C
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P                                     31:28
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_512                            0x00000009

#define NV097_SET_TEXTURE_ADDRESS(i)                               (0x00001b08+(i)*64)
#define NV097_SET_TEXTURE_ADDRESS_U                                                3:0
#define NV097_SET_TEXTURE_ADDRESS_U_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_U_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_U_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_U_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U                                        7:4
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_V                                               11:8
#define NV097_SET_TEXTURE_ADDRESS_V_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_V_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_V_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_V_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V                                      15:12
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_P                                              19:16
#define NV097_SET_TEXTURE_ADDRESS_P_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_P_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_P_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_P_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P                                      23:20
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q                                      31:24
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_TRUE                            0x00000001

#define NV097_SET_TEXTURE_CONTROL0(i)                              (0x00001b0c+(i)*64)
#define NV097_SET_TEXTURE_CONTROL0_ENABLE                                        31:30
#define NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE                             0x00000000
#define NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE                              0x00000001
#define NV097_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                                 29:18
#define NV097_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                  17:6
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                   5:4
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                          0x00000000
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                          0x00000001
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_2                          0x00000002
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_3                          0x00000003
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                              3:3
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE                 0x00000000
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                  0x00000001
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                               2:2
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                  0x00000000
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                   0x00000001
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                             1:0
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE                0x00000000
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA                0x00000001
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA                 0x00000002
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL                 0x00000003

#define NV097_SET_TEXTURE_CONTROL1(i)                              (0x00001b10+(i)*64)
#define NV097_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                   31:16

#define NV097_SET_TEXTURE_FILTER(i)                                (0x00001b14+(i)*64)
#define NV097_SET_TEXTURE_FILTER_MIPMAP_LOD_BIAS                                  12:0
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL                              15:13
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX                0x00000001
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_GAUSSIAN_3              0x00000002
#define NV097_SET_TEXTURE_FILTER_MIN                                             23:16
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0                               0x00000001
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0                              0x00000002
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_NEARESTLOD                         0x00000003
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_NEARESTLOD                        0x00000004
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_TENT_LOD                           0x00000005
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_TENT_LOD                          0x00000006
#define NV097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0                    0x00000007
#define NV097_SET_TEXTURE_FILTER_MAG                                             27:24
#define NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0                               0x00000001
#define NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0                              0x00000002
#define NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0                    0x00000004
#define NV097_SET_TEXTURE_FILTER_ASIGNED                                         28:28
#define NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_RSIGNED                                         29:29
#define NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_GSIGNED                                         30:30
#define NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_BSIGNED                                         31:31
#define NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_ENABLED                        0x00000001

#define NV097_SET_TEXTURE_IMAGE_RECT(i)                            (0x00001b1c+(i)*64)
#define NV097_SET_TEXTURE_IMAGE_RECT_WIDTH                                       31:16
#define NV097_SET_TEXTURE_IMAGE_RECT_HEIGHT                                       15:0

#define NV097_SET_TEXTURE_PALETTE(i)                               (0x00001b20+(i)*64)
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA                                      1:0
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                             0x00000000
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                             0x00000001
#define NV097_SET_TEXTURE_PALETTE_LENGTH                                           5:2
#define NV097_SET_TEXTURE_PALETTE_LENGTH_256                                0x00000000
#define NV097_SET_TEXTURE_PALETTE_LENGTH_128                                0x00000001
#define NV097_SET_TEXTURE_PALETTE_LENGTH_64                                 0x00000002
#define NV097_SET_TEXTURE_PALETTE_LENGTH_32                                 0x00000003
#define NV097_SET_TEXTURE_PALETTE_OFFSET                                          31:6

#define NV097_SET_TEXTURE_BORDER_COLOR(i)                          (0x00001b24+(i)*64)
#define NV097_SET_TEXTURE_BORDER_COLOR_V                                          31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(i)                    (0x00001b28+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01(i)                    (0x00001b2c+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11(i)                    (0x00001b30+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10(i)                    (0x00001b34+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE(i)                    (0x00001b38+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET(i)                   (0x00001b3c+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET_V                                   31:0

#define NV097_PARK_ATTRIBUTE                                                0x00001d64

#define NV097_UNPARK_ATTRIBUTE                                              0x00001d68

#define NV097_SET_SEMAPHORE_OFFSET                                          0x00001d6c
#define NV097_SET_SEMAPHORE_OFFSET_V                                              31:0

#define NV097_BACK_END_WRITE_SEMAPHORE_RELEASE                              0x00001d70
#define NV097_BACK_END_WRITE_SEMAPHORE_RELEASE_V                                  31:0

#define NV097_TEXTURE_READ_SEMAPHORE_RELEASE                                0x00001d74
#define NV097_TEXTURE_READ_SEMAPHORE_RELEASE_V                                    31:0

#define NV097_SET_ZMIN_MAX_CONTROL                                          0x00001d78
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN                                3:0
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_FALSE                   0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_TRUE                    0x00000001
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN                                       7:4
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CULL                           0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CLAMP                          0x00000001
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W                                  11:8
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_FALSE                      0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_TRUE                       0x00000001

#define NV097_SET_ANTI_ALIASING_CONTROL                                     0x00001d7c
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE                                     3:0
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE                        0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_TRUE                         0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE                          7:4
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE_DISABLE           0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE_ENABLE            0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE                              11:8
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE_DISABLE                0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE_ENABLE                 0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_SAMPLE_MASK                              31:16

#define NV097_SET_COMPRESS_ZBUFFER_EN                                       0x00001d80
#define NV097_SET_COMPRESS_ZBUFFER_EN_V                                           31:0
#define NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE                             0x00000000
#define NV097_SET_COMPRESS_ZBUFFER_EN_V_ENABLE                              0x00000001

#define NV097_SET_OCCLUDE_ZSTENCIL_EN                                       0x00001d84
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN                                  0:0
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE                   0x00000000
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_ENABLE                    0x00000001
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN                           1:1
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN_DISABLE            0x00000000
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN_ENABLE             0x00000001

#define NV097_SET_SURFACE_FORMAT                                            0x00000208
#define NV097_SET_SURFACE_FORMAT_COLOR                                             3:0
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                 0x00000001
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                 0x00000002
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                            0x00000003
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                 0x00000004
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                 0x00000005
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8             0x00000006
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8             0x00000007
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                          0x00000008
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_B8                                0x00000009
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8                              0x0000000A
#define NV097_SET_SURFACE_FORMAT_ZETA                                              7:4
#define NV097_SET_SURFACE_FORMAT_ZETA_Z16                                   0x00000001
#define NV097_SET_SURFACE_FORMAT_ZETA_Z24S8                                 0x00000002
#define NV097_SET_SURFACE_FORMAT_TYPE                                             11:8
#define NV097_SET_SURFACE_FORMAT_TYPE_PITCH                                 0x00000001
#define NV097_SET_SURFACE_FORMAT_TYPE_SWIZZLE                               0x00000002
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING                                   15:12
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1                     0x00000000
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_CORNER_2              0x00000001
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_SQUARE_OFFSET_4              0x00000002
#define NV097_SET_SURFACE_FORMAT_WIDTH                                           23:16
#define NV097_SET_SURFACE_FORMAT_WIDTH_1                                    0x00000000
#define NV097_SET_SURFACE_FORMAT_WIDTH_2                                    0x00000001
#define NV097_SET_SURFACE_FORMAT_WIDTH_4                                    0x00000002
#define NV097_SET_SURFACE_FORMAT_WIDTH_8                                    0x00000003
#define NV097_SET_SURFACE_FORMAT_WIDTH_16                                   0x00000004
#define NV097_SET_SURFACE_FORMAT_WIDTH_32                                   0x00000005
#define NV097_SET_SURFACE_FORMAT_WIDTH_64                                   0x00000006
#define NV097_SET_SURFACE_FORMAT_WIDTH_128                                  0x00000007
#define NV097_SET_SURFACE_FORMAT_WIDTH_256                                  0x00000008
#define NV097_SET_SURFACE_FORMAT_WIDTH_512                                  0x00000009
#define NV097_SET_SURFACE_FORMAT_WIDTH_1024                                 0x0000000A
#define NV097_SET_SURFACE_FORMAT_WIDTH_2048                                 0x0000000B
#define NV097_SET_SURFACE_FORMAT_WIDTH_4096                                 0x0000000C
#define NV097_SET_SURFACE_FORMAT_HEIGHT                                          31:24
#define NV097_SET_SURFACE_FORMAT_HEIGHT_1                                   0x00000000
#define NV097_SET_SURFACE_FORMAT_HEIGHT_2                                   0x00000001
#define NV097_SET_SURFACE_FORMAT_HEIGHT_4                                   0x00000002
#define NV097_SET_SURFACE_FORMAT_HEIGHT_8                                   0x00000003
#define NV097_SET_SURFACE_FORMAT_HEIGHT_16                                  0x00000004
#define NV097_SET_SURFACE_FORMAT_HEIGHT_32                                  0x00000005
#define NV097_SET_SURFACE_FORMAT_HEIGHT_64                                  0x00000006
#define NV097_SET_SURFACE_FORMAT_HEIGHT_128                                 0x00000007
#define NV097_SET_SURFACE_FORMAT_HEIGHT_256                                 0x00000008
#define NV097_SET_SURFACE_FORMAT_HEIGHT_512                                 0x00000009
#define NV097_SET_SURFACE_FORMAT_HEIGHT_1024                                0x0000000A
#define NV097_SET_SURFACE_FORMAT_HEIGHT_2048                                0x0000000B
#define NV097_SET_SURFACE_FORMAT_HEIGHT_4096                                0x0000000C

#define NV097_SET_ZSTENCIL_CLEAR_VALUE                                      0x00001d8c
#define NV097_SET_ZSTENCIL_CLEAR_VALUE_V                                          31:0

#define NV097_SET_COLOR_CLEAR_VALUE                                         0x00001d90
#define NV097_SET_COLOR_CLEAR_VALUE_V                                             31:0

#define NV097_CLEAR_SURFACE                                                 0x00001d94
#define NV097_CLEAR_SURFACE_Z                                                      0:0
#define NV097_CLEAR_SURFACE_Z_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_Z_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_STENCIL                                                1:1
#define NV097_CLEAR_SURFACE_STENCIL_DISABLE                                 0x00000000
#define NV097_CLEAR_SURFACE_STENCIL_ENABLE                                  0x00000001
#define NV097_CLEAR_SURFACE_R                                                      4:4
#define NV097_CLEAR_SURFACE_R_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_R_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_G                                                      5:5
#define NV097_CLEAR_SURFACE_G_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_G_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_B                                                      6:6
#define NV097_CLEAR_SURFACE_B_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_B_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_A                                                      7:7
#define NV097_CLEAR_SURFACE_A_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_A_ENABLE                                        0x00000001

#define NV097_SET_CLEAR_RECT_HORIZONTAL                                     0x00001d98
#define NV097_SET_CLEAR_RECT_HORIZONTAL_XMIN                                      15:0
#define NV097_SET_CLEAR_RECT_HORIZONTAL_XMAX                                     31:16

#define NV097_SET_CLEAR_RECT_VERTICAL                                       0x00001d9c
#define NV097_SET_CLEAR_RECT_VERTICAL_YMIN                                        15:0
#define NV097_SET_CLEAR_RECT_VERTICAL_YMAX                                       31:16

#define NV097_SET_BEGIN_PATCH0                                              0x00001de0
#define NV097_SET_BEGIN_PATCH0_POSITION_DEGREE                                     3:0
#define NV097_SET_BEGIN_PATCH0_PARAM1_DEGREE                                       7:4
#define NV097_SET_BEGIN_PATCH0_PARAM2_DEGREE                                      11:8
#define NV097_SET_BEGIN_PATCH0_PARAM3_DEGREE                                     15:12
#define NV097_SET_BEGIN_PATCH0_PARAM4_DEGREE                                     19:16
#define NV097_SET_BEGIN_PATCH0_PARAM5_DEGREE                                     23:20
#define NV097_SET_BEGIN_PATCH0_PARAM6_DEGREE                                     27:24
#define NV097_SET_BEGIN_PATCH0_PARAM7_DEGREE                                     31:28

#define NV097_SET_BEGIN_PATCH1                                              0x00001de4
#define NV097_SET_BEGIN_PATCH1_PARAM8_DEGREE                                       3:0
#define NV097_SET_BEGIN_PATCH1_PARAM9_DEGREE                                       7:4
#define NV097_SET_BEGIN_PATCH1_PARAM10_DEGREE                                     11:8
#define NV097_SET_BEGIN_PATCH1_PARAM11_DEGREE                                    15:12
#define NV097_SET_BEGIN_PATCH1_PARAM12_DEGREE                                    19:16
#define NV097_SET_BEGIN_PATCH1_PARAM13_DEGREE                                    23:20
#define NV097_SET_BEGIN_PATCH1_PARAM14_DEGREE                                    27:24
#define NV097_SET_BEGIN_PATCH1_PARAM15_DEGREE                                    31:28

#define NV097_SET_BEGIN_PATCH2                                              0x00001de8
#define NV097_SET_BEGIN_PATCH2_SWATCH_ROWS                                         7:0
#define NV097_SET_BEGIN_PATCH2_SWATCH_COLS                                        15:8
#define NV097_SET_BEGIN_PATCH2_SWATCH_SIZE                                       20:16
#define NV097_SET_BEGIN_PATCH2_PARTIAL_SWATCH_WIDTH                              25:21
#define NV097_SET_BEGIN_PATCH2_PARTIAL_SWATCH_HEIGHT                             30:26
#define NV097_SET_BEGIN_PATCH2_PATCH_TYPE                                        31:31
#define NV097_SET_BEGIN_PATCH2_PATCH_TYPE_SQUARE                            0x00000000

#define NV097_SET_BEGIN_PATCH3                                              0x00001dec
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS                                            2:0
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_NONE                                0x00000000
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST                               0x00000001
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_LAST                                0x00000002
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST_AND_LAST                      0x00000003
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_REV_FIRST                           0x00000005
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_REV_LAST                            0x00000006
#define NV097_SET_BEGIN_PATCH3_COL_TRNS                                            5:3
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_NONE                                0x00000000
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST                               0x00000001
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_LAST                                0x00000002
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST_AND_LAST                      0x00000003
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_REV_FIRST                           0x00000005
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_REV_LAST                            0x00000006
#define NV097_SET_BEGIN_PATCH3_POSITION_GUARD_CURVE_DEGREE                         9:6
#define NV097_SET_BEGIN_PATCH3_NORMAL_GUARD_CURVE_DEGREE                         13:10
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE                                         15:14
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_TRI_STRIP                          0x00000000
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_REVERSED_TRI_STRIP                 0x00000001
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_BW_TRI_STRIP                       0x00000002
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_BW_REVERSED_TRI_STRIP              0x00000003
#define NV097_SET_BEGIN_PATCH3_TESSELATION                                       16:16
#define NV097_SET_BEGIN_PATCH3_TESSELATION_ADAPTIVE_STITCH                  0x00000000
#define NV097_SET_BEGIN_PATCH3_TESSELATION_FIXED_STITCH                     0x00000001
#define NV097_SET_BEGIN_PATCH3_NUM_COEFFS                                        31:24

#define NV097_SET_END_PATCH                                                 0x00001df0

#define NV097_SET_BEGIN_END_SWATCH                                          0x00001df4
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD                                      3:0
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_END                           0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_BEGIN                         0x00000001
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH                                       7:4
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_CONTINUE                       0x00000000
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_NEW                            0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW                                 11:8
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_FALSE                     0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_TRUE                      0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL                                15:12
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_FALSE                     0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_TRUE                      0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH                                  19:16
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_FULL_HEIGHT                 0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_PARTIAL_HEIGHT              0x00000001
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH                                 31:20
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_FULL_WIDTH                 0x00000000
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_PARTIAL_WIDTH              0x00000001

#define NV097_SET_BEGIN_END_CURVE                                           0x00001df8
#define NV097_SET_BEGIN_END_CURVE_CMD                                              3:0
#define NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA                        0x00000000
#define NV097_SET_BEGIN_END_CURVE_CMD_STRIP_CURVE                           0x00000001
#define NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE                      0x00000002
#define NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE                     0x00000003
#define NV097_SET_BEGIN_END_CURVE_CMD_OUTER_TRANSITION_CURVE                0x00000004
#define NV097_SET_BEGIN_END_CURVE_CMD_INNER_TRANSITION_CURVE                0x00000005
#define NV097_SET_BEGIN_END_CURVE_CMD_OUTER_END_PT                          0x00000006
#define NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT                          0x00000007

#define NV097_SET_CURVE_COEFFICIENTS(i)                             (0x00001e00+(i)*4)
#define NV097_SET_CURVE_COEFFICIENTS_V                                            31:0

#define NV097_SET_BEGIN_TRANSITION0                                         0x00001e10
#define NV097_SET_BEGIN_TRANSITION0_POSITION_DEGREE                                3:0
#define NV097_SET_BEGIN_TRANSITION0_PARAM1_DEGREE                                  7:4
#define NV097_SET_BEGIN_TRANSITION0_PARAM2_DEGREE                                 11:8
#define NV097_SET_BEGIN_TRANSITION0_PARAM3_DEGREE                                15:12
#define NV097_SET_BEGIN_TRANSITION0_PARAM4_DEGREE                                19:16
#define NV097_SET_BEGIN_TRANSITION0_PARAM5_DEGREE                                23:20
#define NV097_SET_BEGIN_TRANSITION0_PARAM6_DEGREE                                27:24
#define NV097_SET_BEGIN_TRANSITION0_PARAM7_DEGREE                                31:28

#define NV097_SET_BEGIN_TRANSITION1                                         0x00001e14
#define NV097_SET_BEGIN_TRANSITION1_PARAM8_DEGREE                                  3:0
#define NV097_SET_BEGIN_TRANSITION1_PARAM9_DEGREE                                  7:4
#define NV097_SET_BEGIN_TRANSITION1_PARAM10_DEGREE                                11:8
#define NV097_SET_BEGIN_TRANSITION1_PARAM11_DEGREE                               15:12
#define NV097_SET_BEGIN_TRANSITION1_PARAM12_DEGREE                               19:16
#define NV097_SET_BEGIN_TRANSITION1_PARAM13_DEGREE                               23:20
#define NV097_SET_BEGIN_TRANSITION1_PARAM14_DEGREE                               27:24
#define NV097_SET_BEGIN_TRANSITION1_PARAM15_DEGREE                               31:28

#define NV097_SET_BEGIN_TRANSITION2                                         0x00001e18
#define NV097_SET_BEGIN_TRANSITION2_INSIDE_SEGMENTS                                9:0
#define NV097_SET_BEGIN_TRANSITION2_OUTSIDE_SEGMENTS                             19:10
#define NV097_SET_BEGIN_TRANSITION2_NUM_COEFFS                                   31:24

#define NV097_SET_END_TRANSITION                                            0x00001e1c

#define NV097_SET_SHADOW_ZSLOPE_THRESHOLD                                   0x00001e68
#define NV097_SET_SHADOW_ZSLOPE_THRESHOLD_V                                       31:0

#define NV097_SET_SHADOW_DEPTH_FUNC                                         0x00001e6c
#define NV097_SET_SHADOW_DEPTH_FUNC_V                                             31:0
#define NV097_SET_SHADOW_DEPTH_FUNC_V_NEVER                                 0x00000000
#define NV097_SET_SHADOW_DEPTH_FUNC_V_LESS                                  0x00000001
#define NV097_SET_SHADOW_DEPTH_FUNC_V_EQUAL                                 0x00000002
#define NV097_SET_SHADOW_DEPTH_FUNC_V_LEQUAL                                0x00000003
#define NV097_SET_SHADOW_DEPTH_FUNC_V_GREATER                               0x00000004
#define NV097_SET_SHADOW_DEPTH_FUNC_V_NOTEQUAL                              0x00000005
#define NV097_SET_SHADOW_DEPTH_FUNC_V_GEQUAL                                0x00000006
#define NV097_SET_SHADOW_DEPTH_FUNC_V_ALWAYS                                0x00000007

#define NV097_SET_SHADER_STAGE_PROGRAM                                      0x00001e70
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0                                      4:0
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1                                      9:5
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT                   0x00000011
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2                                    14:10
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BRDF                          0x00000008
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ST                        0x00000009
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW                        0x0000000A
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE           0x0000000B
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT                   0x00000011
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3                                    19:15
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BRDF                          0x00000008
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST                        0x00000009
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW                        0x0000000A
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR          0x0000000C
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D                    0x0000000D
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE                  0x0000000E
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST    0x00000012

#define NV097_SET_EYE_VECTOR(i)                                     (0x0000181c+(i)*4)
#define NV097_SET_EYE_VECTOR_V                                                    31:0

#define NV097_SET_DOT_RGBMAPPING                                            0x00001e74
#define NV097_SET_DOT_RGBMAPPING_STAGE1                                            3:0
#define NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_NV                  0x00000007
#define NV097_SET_DOT_RGBMAPPING_STAGE2                                            7:4
#define NV097_SET_DOT_RGBMAPPING_STAGE2_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_NV                  0x00000007
#define NV097_SET_DOT_RGBMAPPING_STAGE3                                           11:8
#define NV097_SET_DOT_RGBMAPPING_STAGE3_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_NV                  0x00000007

#define NV097_SET_SHADER_CLIP_PLANE_MODE                                    0x000017f8
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S                                  0:0
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T                                  1:1
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R                                  2:2
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q                                  3:3
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S                                  4:4
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T                                  5:5
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R                                  6:6
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q                                  7:7
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S                                  8:8
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T                                  9:9
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R                                10:10
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q                                11:11
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S                                12:12
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T                                13:13
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R                                14:14
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q                                15:15
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q_CLIPGEZ                   0x00000001

#define NV097_SET_SHADER_OTHER_STAGE_INPUT                                  0x00001e78
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1                                 15:0
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2                                19:16
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_1                 0x00000001
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3                                23:20
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_1                 0x00000001
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_2                 0x00000002

#define NV097_SET_SPECULAR_FOG_FACTOR(i)                            (0x00001e20+(i)*4)
#define NV097_SET_SPECULAR_FOG_FACTOR_BLUE                                         7:0
#define NV097_SET_SPECULAR_FOG_FACTOR_GREEN                                       15:8
#define NV097_SET_SPECULAR_FOG_FACTOR_RED                                        23:16
#define NV097_SET_SPECULAR_FOG_FACTOR_ALPHA                                      31:24

#define NV097_SET_COMBINER_CONTROL                                          0x00001e60
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT                                 7:0
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE                      0x00000001
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_TWO                      0x00000002
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_THREE                    0x00000003
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_FOUR                     0x00000004
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_FIVE                     0x00000005
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_SIX                      0x00000006
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_SEVEN                    0x00000007
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_EIGHT                    0x00000008
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT                                     11:8
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT_LSB                           0x00000000
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB                           0x00000001
#define NV097_SET_COMBINER_CONTROL_FACTOR0                                       15:12
#define NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL                  0x00000000
#define NV097_SET_COMBINER_CONTROL_FACTOR0_EACH_STAGE                       0x00000001
#define NV097_SET_COMBINER_CONTROL_FACTOR1                                       31:16
#define NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL                  0x00000000
#define NV097_SET_COMBINER_CONTROL_FACTOR1_EACH_STAGE                       0x00000001

#define NV097_SET_COMBINER_COLOR_OCW(i)                             (0x00001e40+(i)*4)
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB                              31:19
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE                 0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE           0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD                              18:18
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE                 0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE           0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_OP                                          17:15
#define NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT                             0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT_BIAS                        0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1                        0x00000002
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1_BIAS                   0x00000003
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY2                        0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTRIGHTBY1                       0x00000006
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE                                  14:14
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE                       0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_TRUE                        0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE                               13:13
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE                    0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_TRUE                     0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE                               12:12
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE                    0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_TRUE                     0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST                                      11:8
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0                          0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_4                          0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_5                          0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_8                          0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_9                          0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_A                          0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_B                          0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C                          0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_D                          0x0000000D
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST                                        7:4
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_D                           0x0000000D
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST                                        3:0
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D                           0x0000000D

#define NV097_SET_TRANSFORM_EXECUTION_MODE                                  0x00001e94
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE                                    1:0
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED                       0x00000000
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_PROGRAM                     0x00000002
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE                             31:2
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_USER                  0x00000000
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV                  0x00000001

#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN                            0x00001e98
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V                                31:0
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V_READ_ONLY                0x00000000
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V_READ_WRITE               0x00000001

#define NV097_SET_TRANSFORM_PROGRAM_LOAD                                    0x00001e9c
#define NV097_SET_TRANSFORM_PROGRAM_LOAD_PROG_LD_PTR                              31:0

#define NV097_SET_TRANSFORM_PROGRAM_START                                   0x00001ea0
#define NV097_SET_TRANSFORM_PROGRAM_START_V                                       31:0

#define NV097_SET_TRANSFORM_PROGRAM(i)                              (0x00000b00+(i)*4)
#define NV097_SET_TRANSFORM_PROGRAM_V                                             31:0

#define NV097_SET_TRANSFORM_CONSTANT_LOAD                                   0x00001ea4
#define NV097_SET_TRANSFORM_CONSTANT_LOAD_CONST_LD_PTR                            31:0

#define NV097_SET_TRANSFORM_CONSTANT(i)                             (0x00000b80+(i)*4)
#define NV097_SET_TRANSFORM_CONSTANT_V                                            31:0

#define NV097_SET_TRANSFORM_DATA(i)                                 (0x00001e80+(i)*4)
#define NV097_SET_TRANSFORM_DATA_V                                                31:0

#define NV097_LAUNCH_TRANSFORM_PROGRAM                                      0x00001e90
#define NV097_LAUNCH_TRANSFORM_PROGRAM_V                                          31:0

#define NV097_SET_TWO_SIDE_LIGHT_EN                                         0x000017c4
#define NV097_SET_TWO_SIDE_LIGHT_EN_V                                             31:0
#define NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE                                 0x00000000
#define NV097_SET_TWO_SIDE_LIGHT_EN_V_TRUE                                  0x00000001

#define NV097_SET_BACK_SCENE_AMBIENT_COLOR(i)                       (0x000017a0+(i)*4)
#define NV097_SET_BACK_SCENE_AMBIENT_COLOR_V                                      31:0

#define NV097_SET_BACK_MATERIAL_EMISSION(i)                         (0x000017b0+(i)*4)
#define NV097_SET_BACK_MATERIAL_EMISSION_V                                        31:0

#define NV097_CLEAR_REPORT_VALUE                                            0x000017c8
#define NV097_CLEAR_REPORT_VALUE_TYPE                                             31:0
#define NV097_CLEAR_REPORT_VALUE_TYPE_ZPASS_PIXEL_CNT                       0x00000001

#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE                                  0x000017cc
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V                                      31:0
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE                          0x00000000
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_TRUE                           0x00000001

#define NV097_GET_REPORT                                                    0x000017d0
#define NV097_GET_REPORT_OFFSET                                                   23:0
#define NV097_GET_REPORT_TYPE                                                    31:24
#define NV097_GET_REPORT_TYPE_ZPASS_PIXEL_CNT                               0x00000001

/* These methods are accepted between a begin/end. */
#define NV097_SET_VIEWPORT_OFFSET_SW(i)                             (0x00001f00+(i)*4)
/* The PASSTHRU_VIEWPORT_OFFSET aliases to row 1 of the MODEL_VIEW_MATRIX1 */
#define NV097_SET_PASSTHRU_VIEWPORT_OFFSET_SW(i)                    (0x00001f10+(i)*4)

#define NV097_DEBUG_INIT(i)                                         (0x00001fc0+(i)*4)
#define NV097_DEBUG_INIT_V                                                        31:0
#define NV097_TYPEDEF                                              Nv20KelvinPrimitive
#define NV097_SET_OBJECT                                                  (0x00000000)


// XXXmjc Shaun Ho and John Montrym will roll these into the master file at some point.
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_ZERO               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_DIFFUSE            NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPECULAR           NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX0               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX1               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX2               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX3               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPARE0             NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPARE1             NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_ZERO                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_DIFFUSE             NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPECULAR            NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX0                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX1                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX2                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX3                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPARE0              NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPARE1              NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_ZERO                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_DIFFUSE             NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPECULAR            NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX0                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX1                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX2                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX3                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPARE0              NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPARE1              NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_ZERO               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_DIFFUSE            NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPECULAR           NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX0               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX1               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX2               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX3               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPARE0             NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPARE1             NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_ZERO                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_DIFFUSE             NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPECULAR            NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX0                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX1                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX2                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX3                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPARE0              NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPARE1              NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_ZERO                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_DIFFUSE             NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPECULAR            NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX0                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX1                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX2                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX3                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPARE0              NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPARE1              NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D


/* class NV15_CONTEXT_SURFACE_SWIZZLED */
#define  NV15_CONTEXT_SURFACE_SWIZZLED                             (0x0000009E)
/* NvNotification[] elements */
#define NV09E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV09E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV09E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV09E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV09E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV09E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV09E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV09E_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetFormat;               /* height_width_color V8_V8_V16     0300-0303*/
 NvU32 SetOffset;               /* byte offset of top-left pixel    0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv09eTypedef, Nv15ContextSurfaceSwizzled;
#define NV09E_TYPEDEF                                Nv15ContextSurfaceSwizzled
/* dma method offsets, fields, and values */
#define NV09E_SET_OBJECT                                           (0x00000000)
#define NV09E_NO_OPERATION                                         (0x00000100)
#define NV09E_NOTIFY                                               (0x00000104)
#define NV09E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV09E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV09E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV09E_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV09E_SET_FORMAT                                           (0x00000300)
#define NV09E_SET_FORMAT_COLOR                                     15:0
#define NV09E_SET_FORMAT_COLOR_LE_Y8                               (0x00000001)
#define NV09E_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV09E_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV09E_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000004)
#define NV09E_SET_FORMAT_COLOR_LE_Y16                              (0x00000005)
#define NV09E_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV09E_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV09E_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV09E_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV09E_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x0000000A)
#define NV09E_SET_FORMAT_COLOR_LE_Y32                              (0x0000000B)
#define NV09E_SET_FORMAT_WIDTH                                     23:16
#define NV09E_SET_FORMAT_WIDTH_2                                   (0x00000001)
#define NV09E_SET_FORMAT_WIDTH_4                                   (0x00000002)
#define NV09E_SET_FORMAT_WIDTH_8                                   (0x00000003)
#define NV09E_SET_FORMAT_WIDTH_16                                  (0x00000004)
#define NV09E_SET_FORMAT_WIDTH_32                                  (0x00000005)
#define NV09E_SET_FORMAT_WIDTH_64                                  (0x00000006)
#define NV09E_SET_FORMAT_WIDTH_128                                 (0x00000007)
#define NV09E_SET_FORMAT_WIDTH_256                                 (0x00000008)
#define NV09E_SET_FORMAT_WIDTH_512                                 (0x00000009)
#define NV09E_SET_FORMAT_WIDTH_1024                                (0x0000000A)
#define NV09E_SET_FORMAT_WIDTH_2048                                (0x0000000B)
#define NV09E_SET_FORMAT_HEIGHT                                    31:24
#define NV09E_SET_FORMAT_HEIGHT_2                                  (0x00000001)
#define NV09E_SET_FORMAT_HEIGHT_4                                  (0x00000002)
#define NV09E_SET_FORMAT_HEIGHT_8                                  (0x00000003)
#define NV09E_SET_FORMAT_HEIGHT_16                                 (0x00000004)
#define NV09E_SET_FORMAT_HEIGHT_32                                 (0x00000005)
#define NV09E_SET_FORMAT_HEIGHT_64                                 (0x00000006)
#define NV09E_SET_FORMAT_HEIGHT_128                                (0x00000007)
#define NV09E_SET_FORMAT_HEIGHT_256                                (0x00000008)
#define NV09E_SET_FORMAT_HEIGHT_512                                (0x00000009)
#define NV09E_SET_FORMAT_HEIGHT_1024                               (0x0000000A)
#define NV09E_SET_FORMAT_HEIGHT_2048                               (0x0000000B)
#define NV09E_SET_OFFSET                                           (0x00000304)


/* class NV15_IMAGE_BLIT */
#define  NV15_IMAGE_BLIT                                           (0x0000009F)
/* NvNotification[] elements */
#define NV09F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV09F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV09F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV09F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV09F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV09F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV09F_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 SyncSetRead;             /*                                  0120-0123*/
 NvV32 SyncSetWrite;            /*                                  0124-0127*/
 NvV32 SyncSetModulo;           /*                                  0128-012b*/
 NvV32 SyncIncrementWrite;      /* ignored                          012c-012f*/
 NvV32 SyncStall;               /* ignored                          0130-0133*/
 NvV32 SyncIncrementReadRange;  /* scanline range to check 0 or 1   0134-0137*/
 NvV32 Reserved02[0x012];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved03[0x057];
 NvV32 SetOperation;            /* NV09F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved04[0x73d];
} Nv09fTypedef, Nv12ImageBlit;
#define NV09F_TYPEDEF                                             Nv12ImageBlit
/* dma method offsets, fields, and values */
#define NV09F_SET_OBJECT                                           (0x00000000)
#define NV09F_NO_OPERATION                                         (0x00000100)
#define NV09F_NOTIFY                                               (0x00000104)
#define NV09F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV09F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV09F_SYNC_SET_READ                                        (0x00000120)
#define NV09F_SYNC_SET_WRITE                                       (0x00000124)
#define NV09F_SYNC_SET_MODULO                                      (0x00000128)
#define NV09F_SYNC_INCREMENT_WRITE                                 (0x0000012C)
#define NV09F_SYNC_STALL                                           (0x00000130)
#define NV09F_SYNC_INCREMENT_READ_RANGE                            (0x00000134)
#define NV09F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV09F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV09F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV09F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV09F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV09F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV09F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV09F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV09F_SET_OPERATION                                        (0x000002FC)
#define NV09F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV09F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV09F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV09F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV09F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV09F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV09F_CONTROL_POINT_IN                                     (0x00000300)
#define NV09F_CONTROL_POINT_IN_X                                   15:0
#define NV09F_CONTROL_POINT_IN_Y                                   31:16
#define NV09F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV09F_CONTROL_POINT_OUT_X                                  15:0
#define NV09F_CONTROL_POINT_OUT_Y                                  31:16
#define NV09F_SIZE                                                 (0x00000308)
#define NV09F_SIZE_WIDTH                                           15:0
#define NV09F_SIZE_HEIGHT                                          31:16


/* class NV20_IMAGE_BLIT */
#define  NV20_IMAGE_BLIT                                            (0x0000205F)
/* NvNotification[] elements */
#define NV205F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV205F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV205F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV205F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV205F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV205F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV205F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV205F_NOTIFY_*                  0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 SyncSetRead;             /*                                  0120-0123*/
 NvV32 SyncSetWrite;            /*                                  0124-0127*/
 NvV32 SyncSetModulo;           /*                                  0128-012b*/
 NvV32 SyncIncrementWrite;      /* ignored                          012c-012f*/
 NvV32 SyncStall;               /* ignored                          0130-0133*/
 NvV32 SyncIncrementReadRange;  /* ignored                          0134-0137*/
 NvV32 Reserved02[0x012];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved03[0x057];
 NvV32 SetOperation;            /* NV205F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved04[0x73d];
} Nv205fTypedef, Nv20ImageBlit;
#define NV205F_TYPEDEF                                             Nv20ImageBlit
/* dma method offsets, fields, and values */
#define NV205F_SET_OBJECT                                           (0x00000000)
#define NV205F_NO_OPERATION                                         (0x00000100)
#define NV205F_NOTIFY                                               (0x00000104)
#define NV205F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV205F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV205F_SYNC_SET_READ                                        (0x00000120)
#define NV205F_SYNC_SET_WRITE                                       (0x00000124)
#define NV205F_SYNC_SET_MODULO                                      (0x00000128)
#define NV205F_SYNC_INCREMENT_WRITE                                 (0x0000012C)
#define NV205F_SYNC_STALL                                           (0x00000130)
#define NV205F_SYNC_INCREMENT_READ_RANGE                            (0x00000134)
#define NV205F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV205F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV205F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV205F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV205F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV205F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV205F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV205F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV205F_SET_OPERATION                                        (0x000002FC)
#define NV205F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV205F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV205F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV205F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV205F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV205F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV205F_CONTROL_POINT_IN                                     (0x00000300)
#define NV205F_CONTROL_POINT_IN_X                                   15:0
#define NV205F_CONTROL_POINT_IN_Y                                   31:16
#define NV205F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV205F_CONTROL_POINT_OUT_X                                  15:0
#define NV205F_CONTROL_POINT_OUT_Y                                  31:16
#define NV205F_SIZE                                                 (0x00000308)
#define NV205F_SIZE_WIDTH                                           15:0
#define NV205F_SIZE_HEIGHT                                          31:16


/* class NV03_DEVICE_XX */
#define  NV03_DEVICE_XX                                            (0x000000FF)
/* NvNotification[] fields and values */
#define NV0FF_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0FFTypedef, Nv03DeviceXX;
#define  NV0FF_TYPEDEF                                             Nv03DeviceXX

typedef V032 Nvff0Typedef;

typedef V032 Nvff1Typedef;

typedef V032 Nvff2Typedef;

typedef V032 Nvff3Typedef;

typedef V032 Nvff4Typedef;


/* class NV_CONTEXT_ERROR_TO_MEMORY */
#define  NV_CONTEXT_ERROR_TO_MEMORY                                (0x00000FF5)
/* NvNotification[] elements */
#define NVFF5_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF5_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF5_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF5_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} Nvff5Typedef, NvContextErrorToMemory;
#define NVFF5_TYPEDEF                                    NvContextErrorToMemory
/* dma method offsets, fields, and values */
#define NVFF5_SET_OBJECT(s)                              (0x00040000+8192*(s))
#define NVFF5_NO_OPERATION(s)                            (0x00040100+8192*(s))
#define NVFF5_NOTIFY(s)                                  (0x00040104+8192*(s))
#define NVFF5_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF5_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF5_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00040180+8192*(s))
#define NVFF5_SET_DMA_SPECIFIER(s)                       (0x000C0300+8192*(s))
/* obsolete stuff */
#define nvContextErrorToMemory                           NvContextErrorToMemory


/* class NV_VIDEO_COLOR_KEY */
#define  NV_VIDEO_COLOR_KEY                                        (0x00000FF6)
/* NvNotification[] elements */
#define NVFF6_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF6_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF6_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput[3];        /* NV1_PATCHCORD_VIDEO               0204-020b*/
 V032 Reserved02[0x03c];
 V032 SetColorFormat;          /* NVFF6_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColorKey;             /* color to compare with             0304-0307*/
 V032 SetPoint;                /* y_x, S16_S16 in pixels, top-left  0308-030b*/
 V032 SetSize;                 /* height_width U16_U16 in pixels    030c-030f*/
 V032 Reserved03[0x73c];
} Nvff6Typedef, NvVideoColorKey;
#define NVFF6_TYPEDEF                                    NvVideoColorKey
/* dma method offsets, fields, and values */
#define NVFF6_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF6_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF6_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF6_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF6_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF6_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF6_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF6_SET_VIDEO_INPUT(s,i)                       (0x00000204+8192*(s)+\
                                                                       4*(i))
#define NVFF6_SET_COLOR_FORMAT(s)                        (0x00000300+8192*(s))
#define NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8                (0x00000001)
#define NVFF6_SET_COLOR_FORMAT_LE_X24Y8                  (0x00000002)
#define NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5            (0x00000003)
#define NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5              (0x00000004)
#define NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5              (0x00000005)
#define NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8               (0x00000006)
#define NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8               (0x00000007)
#define NVFF6_SET_COLOR_FORMAT_LE_A16Y16                 (0x00000008)
#define NVFF6_SET_COLOR_FORMAT_LE_X16Y16                 (0x00000009)
#define NVFF6_SET_COLOR_KEY(s)                           (0x00000304+8192*(s))
#define NVFF6_SET_POINT(s)                               (0x00000308+8192*(s))
#define NVFF6_SET_POINT_X                                15:0
#define NVFF6_SET_POINT_Y                                31:16
#define NVFF6_SET_SIZE(s)                                (0x0000030C+8192*(s))
#define NVFF6_SET_SIZE_WIDTH                             15:0
#define NVFF6_SET_SIZE_HEIGHT                            31:16
/* obsolete stuff */
#define nvVideoColorKey                                  NvVideoColorKey


/* class NV_VIDEO_SCALER */
#define  NV_VIDEO_SCALER                                           (0x00000FF7)
/* NvNotification[] elements */
#define NVFF7_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF7_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF7_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x03e];
 V032 SetDeltaDuDx;            /* S12d20 ratio du/dx                0300-0303*/
 V032 SetDeltaDvDy;            /* S12d20 ratio dv/dy                0304-0307*/
 V032 SetPoint;                /* y_x S16_S16 in pixels, top-left   0308-030b*/
 V032 Reserved03[0x73d];
} Nvff7Typedef, NvVideoScaler;
#define NVFF7_TYPEDEF                                    NvVideoScaler
/* dma method offsets, fields, and values */
#define NVFF7_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF7_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF7_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF7_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF7_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF7_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF7_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF7_SET_VIDEO_INPUT(s)                         (0x00000204+8192*(s))
#define NVFF7_SET_DELTA_DU_DX(s)                         (0x00000300+8192*(s))
#define NVFF7_SET_DELTA_DV_DY(s)                         (0x00000304+8192*(s))
#define NVFF7_SET_POINT(s)                               (0x00000308+8192*(s))
#define NVFF7_SET_POINT_X                                15:0
#define NVFF7_SET_POINT_Y                                31:16
/* obsolete stuff */
#define nvVideoScaler                                    NvVideoScaler


/* class NV_VIDEO_FROM_MEMORY */
#define  NV_VIDEO_FROM_MEMORY                                      (0x00000FF8)
/* NvNotification[] elements */
#define NVFF8_NOTIFIERS_NOTIFY                                     (0)
#define NVFF8_NOTIFIERS_IMAGE_SCAN(b)                              (1+(b))
#define NVFF8_NOTIFIERS_GET_OFFSET_NOTIFY(b)                       (3+(b))
/* NvNotification[] fields and values */
#define NVFF8_NOTIFICATION_INFO16_BUFFER_NOT_STARTED               (0x0001)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_OFFSET_VALID              (0x0002)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_DONE                      (0x0003)
#define NVFF8_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_PATCH                  (0x0400)
#define NVFF8_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF8_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NVFF8_STOP_TRANSFER_VALUE         0108-010b*/
 V032 SetPatch;                /* NVFF8_SET_PATCH_*                 010c-010f*/
 V032 Reserved00[0x01c];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage[2];   /* NV1_CONTEXT_DMA_FROM_MEMORY       0184-018b*/
 V032 Reserved01[0x01d];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 Reserved02[0x03f];
 struct {                      /* start of methods in array         0300-    */
  U032 offset;                 /* byte offset of top-left pixel       00-  03*/
  U032 pitch;                  /* bytes, vertical pixel delta         04-  07*/
  V032 size;                   /* height_width U16_U16 in pixels      08-  0b*/
  V032 format;                 /* field_color V16_V16                 0c-  0f*/
  V032 notify;                 /* NVFF8_IMAGE_SCAN_NOTIFY_*           10-  13*/
 } ImageScan[2];               /* end of methods in array               -0327*/
 V032 GetOffsetNotify[2];      /* NVFF8_GET_OFFSET_NOTIFY_*         0328-032f*/
 V032 Reserved03[0x734];
} Nvff8Typedef, NvVideoFromMemory;
#define NVFF8_TYPEDEF                                    NvVideoFromMemory
/* dma method offsets, fields, and values */
#define NVFF8_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF8_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF8_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF8_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF8_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF8_STOP_TRANSFER(s)                           (0x00000108+8192*(s))
#define NVFF8_STOP_TRANSFER_VALUE                        (0x00000000)
#define NVFF8_SET_PATCH(s)                               (0x0000010C+8192*(s))
#define NVFF8_SET_PATCH_INVALIDATE                       (0x00000000)
#define NVFF8_SET_PATCH_VALIDATE                         (0x00000001)
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF8_SET_CONTEXT_DMA_IMAGE(s,b)                 (0x00000184+8192*(s)+\
                                                                        4*(b))
#define NVFF8_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF8_IMAGE_SCAN(s,b)                            (0x00000300+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_OFFSET(s,b)                     (0x00000300+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_PITCH(s,b)                      (0x00000304+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_SIZE(s,b)                       (0x00000308+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_SIZE_WIDTH                      15:0
#define NVFF8_IMAGE_SCAN_SIZE_HEIGHT                     31:16
#define NVFF8_IMAGE_SCAN_FORMAT(s,b)                     (0x0000030C+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR                    15:0
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8              (0x00000001)
#define NV_VFM_FORMAT_COLOR_LE_Y8_P4                      0x00000001
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8      (0x00000002)
#define NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8                   0x00000002
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8      (0x00000003)
#define NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8                   0x00000003
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5       (0x00000004)
#define NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2                0x00000004
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5          (0x00000005)
#define NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2                  0x00000005
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8     (0x00000006)
#define NV_VFM_FORMAT_COLOR_LE_X8R8G8B8                   0x00000006
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD                    31:16
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_PROGRESSIVE        (0x00000001)
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_EVEN_FIELD         (0x00000002)
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_ODD_FIELD          (0x00000003)
#define NVFF8_IMAGE_SCAN_NOTIFY(s,b)                     (0x00000310+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
#define NVFF8_GET_OFFSET_NOTIFY(s,b)                     (0x00000328+8192*(s)+\
                                                                        4*(b))
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
/* obsolete stuff */
#define nvVideoFromMemory                                NvVideoFromMemory
#define SetImageCtxDma                                   SetContextDmaImage
#define SetImageNotifyCtxDma                             SetContextDmaNotifies


/* class NV_VIDEO_COLORMAP */
#define  NV_VIDEO_COLORMAP                                         (0x00000FF9)
/* NvNotification[] elements */
#define NVFF9_NOTIFIERS_NOTIFY                                     (0)
#define NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY                      (1)
/* NvNotification[] fields and values */
#define NVFF9_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF9_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 SetContextDmaColormap;   /* NV_CONTEXT_DMA_FROM_MEMORY        0184-0187*/
 V032 Reserved01[0x01e];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x040];
 U032 SetColormapStart;        /* offset in bytes                   0308-030b*/
 U032 SetColormapLength;       /* in bytes                          030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update         0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, starts transfer         0314-0317*/
 V032 Reserved03[0x73a];
} Nvff9Typedef, NvVideoColormap;
#define NVFF9_TYPEDEF                                    NvVideoColormap
/* dma method offsets, fields, and values */
#define NVFF9_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF9_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF9_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF9_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF9_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF9_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF9_SET_CONTEXT_DMA_COLORMAP(s)                (0x00000184+8192*(s))
#define NVFF9_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF9_SET_VIDEO_INPUT(s)                         (0x00000204+8192*(s))
#define NVFF9_SET_COLORMAP_START(s)                      (0x00000308+8192*(s))
#define NVFF9_SET_COLORMAP_LENGTH(s)                     (0x0000030C+8192*(s))
#define NVFF9_COLORMAP_DIRTY_START(s)                    (0x00000310+8192*(s))
#define NVFF9_COLORMAP_DIRTY_LENGTH(s)                   (0x00000314+8192*(s))
/* obsolete stuff */
#define nvVideoColormap                                  NvVideoColormap


/* class NV_VIDEO_SINK */
#define  NV_VIDEO_SINK                                             (0x00000FFA)
/* NvNotification[] elements */
#define NVFFA_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFA_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFA_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFA_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoInput[64];       /* NV1_PATCHCORD_VIDEO               0200-02ff*/
 V032 Reserved02[0x740];
} NvffaTypedef, NvVideoSink;
#define NVFFA_TYPEDEF                                    NvVideoSink
/* dma method offsets, fields, and values */
#define NVFFA_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFA_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFA_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFA_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFA_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFA_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFA_SET_VIDEO_INPUT(s,i)                       (0x00000200+8192*(s)+\
                                                                        4*(i))
/* obsolete stuff */
#define nvVideoSink                                      NvVideoSink


/* class NV_PATCHCORD_VIDEO */
#define  NV_PATCHCORD_VIDEO                                        (0x00000FFB)
/* NvNotification[] entries, values, errors, warnings */
#define NVFFB_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} NvffbTypedef, NvPatchcordVideo;
#define NVFFB_TYPEDEF                                    NvPatchcordVideo
/* obsolete stuff */
#define nvPatchcordVideo                                 NvPatchcordVideo


/* class NV_CONTEXT_DMA_IN_MEMORY */
#define  NV_CONTEXT_DMA_IN_MEMORY                                  (0x00000FFC)
/* NvNotification[] elements */
#define NVFFC_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFC_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFC_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFC_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* On X86 address[1] is the selector    0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffcTypedef, NvContextDmaInMemory;
#define NVFFC_TYPEDEF                                    NvContextDmaInMemory
/* dma method offsets, fields, and values */
#define NVFFC_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFC_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFC_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFC_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFC_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFC_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFC_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaInMemory                             NvContextDmaInMemory


/* class NV_CONTEXT_DMA_TO_MEMORY */
#define  NV_CONTEXT_DMA_TO_MEMORY                                  (0x00000FFD)
/* NvNotification[] elements */
#define NVFFD_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFD_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFD_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFD_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffdTypedef, NvContextDmaToMemory;
#define NVFFD_TYPEDEF                                    NvContextDmaToMemory
/* dma method offsets, fields, and values */
#define NVFFD_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFD_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFD_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFD_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFD_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFD_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFD_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaToMemory                             NvContextDmaToMemory


/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define  NV_CONTEXT_DMA_FROM_MEMORY                                (0x00000FFE)
/* NvNotification[] elements */
#define NVFFE_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFE_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFE_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFE_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffeTypedef, NvContextDmaFromMemory;
#define NVFFE_TYPEDEF                                    NvContextDmaFromMemory
/* dma method offsets, fields, and values */
#define NVFFE_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFE_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFE_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFE_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFE_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaFromMemory                           NvContextDmaFromMemory


/* class NV_CLASS */
#define  NV_CLASS                                                  (0x00000FFF)
/* NvNotification[] elements */
#define NVFFF_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFF_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFF_NOTIFICATION_STATUS_WARNING_UNAVAILABLE              (0x0002)
#define NVFFF_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFF_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 V032 Create;                  /* 32-bit handle of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit handle of object           0304-0307*/
 V032 Reserved02[0x73e];
} NvfffTypedef, NvClass;
#define NVFFF_TYPEDEF                                    NvClass
/* dma method offsets, fields, and values */
#define NVFFF_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFF_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFF_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFF_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFF_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFF_CREATE(s)                                  (0x00000300+8192*(s))
#define NVFFF_DESTROY(s)                                 (0x00000304+8192*(s))
/* obsolete stuff */
#define nvClass                                          NvClass



 /***************************************************************************\
|*                                 Channels                                  *|
 \***************************************************************************/

typedef NvV32 Nv068Typedef;

typedef NvV32 Nv069Typedef;

/* class NV03_CHANNEL_PIO */
#define  NV03_CHANNEL_PIO                                          (0x0000006A)
/* NvNotification[] fields and values */
#define NV06A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV06A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06A_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL               (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x003];
#ifdef NV_BIG_ENDIAN
 NvU32 Free;                    /* 32 bit free count, read only     0010-0013*/
 NvU32 Zero;                    /* zeroes, read only                0014-0017*/
#else
 NvU16 Free;                    /* free count, read only            0010-0011*/
 NvU16 Zero[3];                 /* zeroes, read only                0012-0017*/
#endif
 NvV32 Reserved01[0x03A];
} Nv03ControlPio;
typedef volatile struct {
 NvV32 SetObject;               /* handle of current object         0000-0003*/
 Nv03ControlPio control;        /* flow control                     0000-00ff*/
 union {                        /* start of class methods           0100-    */
  Nv000Typedef NV000_TYPEDEF;
  Nv001Typedef NV001_TYPEDEF;
  Nv002Typedef NV002_TYPEDEF;
  Nv003Typedef NV003_TYPEDEF;
  Nv004Typedef NV004_TYPEDEF;
  Nv005Typedef NV005_TYPEDEF;
  Nv006Typedef NV006_TYPEDEF;
  Nv007Typedef NV007_TYPEDEF;
  Nv008Typedef NV008_TYPEDEF;
  Nv009Typedef NV009_TYPEDEF;
  Nv00aTypedef NV00A_TYPEDEF;
  Nv00bTypedef NV00B_TYPEDEF;
  Nv00cTypedef NV00C_TYPEDEF;
  Nv00dTypedef NV00D_TYPEDEF;
  Nv00eTypedef NV00E_TYPEDEF;
  Nv00fTypedef NV00F_TYPEDEF;
  Nv010Typedef NV010_TYPEDEF;
  Nv011Typedef NV011_TYPEDEF;
  Nv012Typedef NV012_TYPEDEF;
  Nv013Typedef NV013_TYPEDEF;
  Nv014Typedef NV014_TYPEDEF;
  Nv015Typedef NV015_TYPEDEF;
  Nv016Typedef NV016_TYPEDEF;
  Nv017Typedef NV017_TYPEDEF;
  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01aTypedef NV01A_TYPEDEF;
  Nv01bTypedef NV01B_TYPEDEF;
  Nv01cTypedef NV01C_TYPEDEF;
  Nv01dTypedef NV01D_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv020Typedef NV020_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv022Typedef NV022_TYPEDEF;
  Nv023Typedef NV023_TYPEDEF;
  Nv024Typedef NV024_TYPEDEF;
  Nv025Typedef NV025_TYPEDEF;
  Nv026Typedef NV026_TYPEDEF;
  Nv027Typedef NV027_TYPEDEF;
  Nv028Typedef NV028_TYPEDEF;
  Nv029Typedef NV029_TYPEDEF;
  Nv02aTypedef NV02A_TYPEDEF;
  Nv02bTypedef NV02B_TYPEDEF;
  Nv02cTypedef NV02C_TYPEDEF;
  Nv02dTypedef NV02D_TYPEDEF;
  Nv02eTypedef NV02E_TYPEDEF;
  Nv02fTypedef NV02F_TYPEDEF;
  Nv030Typedef NV030_TYPEDEF;
  Nv031Typedef NV031_TYPEDEF;
  Nv032Typedef NV032_TYPEDEF;
  Nv033Typedef NV033_TYPEDEF;
  Nv034Typedef NV034_TYPEDEF;
  Nv035Typedef NV035_TYPEDEF;
  Nv036Typedef NV036_TYPEDEF;
  Nv037Typedef NV037_TYPEDEF;
  Nv038Typedef NV038_TYPEDEF;
  Nv039Typedef NV039_TYPEDEF;
  Nv03aTypedef NV03A_TYPEDEF;
  Nv03bTypedef NV03B_TYPEDEF;
  Nv03cTypedef NV03C_TYPEDEF;
  Nv03dTypedef NV03D_TYPEDEF;
  Nv03eTypedef NV03E_TYPEDEF;
  Nv03fTypedef NV03F_TYPEDEF;
  Nv040Typedef NV040_TYPEDEF;
  Nv041Typedef NV041_TYPEDEF;
  Nv042Typedef NV042_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv044Typedef NV044_TYPEDEF;
  Nv045Typedef NV045_TYPEDEF;
  Nv046Typedef NV046_TYPEDEF;
  Nv047Typedef NV047_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv049Typedef NV049_TYPEDEF;
  Nv04aTypedef NV04A_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv04cTypedef NV04C_TYPEDEF;
  Nv04dTypedef NV04D_TYPEDEF;
  Nv04eTypedef NV04E_TYPEDEF;
  Nv04fTypedef NV04F_TYPEDEF;
  Nv050Typedef NV050_TYPEDEF;
  Nv051Typedef NV051_TYPEDEF;
  Nv052Typedef NV052_TYPEDEF;
  Nv053Typedef NV053_TYPEDEF;
  Nv054Typedef NV054_TYPEDEF;
  Nv055Typedef NV055_TYPEDEF;
  Nv096Typedef NV096_TYPEDEF;
  Nv057Typedef NV057_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05aTypedef NV05A_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;
  Nv05cTypedef NV05C_TYPEDEF;
  Nv05dTypedef NV05D_TYPEDEF;
  Nv05eTypedef NV05E_TYPEDEF;
  Nv05fTypedef NV05F_TYPEDEF;
  Nv060Typedef NV060_TYPEDEF;
  Nv061Typedef NV061_TYPEDEF;
  Nv062Typedef NV062_TYPEDEF;
  Nv063Typedef NV063_TYPEDEF;
  Nv064Typedef NV064_TYPEDEF;
  Nv065Typedef NV065_TYPEDEF;
  Nv066Typedef NV066_TYPEDEF;
  Nv067Typedef NV067_TYPEDEF;
/*Nv068Typedef NV068_TYPEDEF;*/
/*Nv069Typedef NV069_TYPEDEF;*/
/*Nv06aTypedef NV06A_TYPEDEF;*/
/*Nv06bTypedef NV06B_TYPEDEF;*/
/*Nv06cTypedef NV06C_TYPEDEF;*/
/*Nv06dTypedef NV06D_TYPEDEF;*/
/*Nv06eTypedef NV06E_TYPEDEF;*/
  Nv06fTypedef NV06F_TYPEDEF;
  Nv070Typedef NV070_TYPEDEF;
  Nv071Typedef NV071_TYPEDEF;
  Nv072Typedef NV072_TYPEDEF;
  Nv073Typedef NV073_TYPEDEF;
  Nv074Typedef NV074_TYPEDEF;
  Nv075Typedef NV075_TYPEDEF;
  Nv076Typedef NV076_TYPEDEF;
  Nv077Typedef NV077_TYPEDEF;
  Nv078Typedef NV078_TYPEDEF;
  Nv079Typedef NV079_TYPEDEF;
  Nv07aTypedef NV07A_TYPEDEF;
  Nv07bTypedef NV07B_TYPEDEF;
  Nv07cTypedef NV07C_TYPEDEF;
  Nv07dTypedef NV07D_TYPEDEF;
  Nv07eTypedef NV07E_TYPEDEF;
  Nv07fTypedef NV07F_TYPEDEF;
  Nv080Typedef NV080_TYPEDEF;
  Nv081Typedef NV081_TYPEDEF;
  Nv082Typedef NV082_TYPEDEF;
  Nv083Typedef NV083_TYPEDEF;
  Nv084Typedef NV084_TYPEDEF;
  Nv085Typedef NV085_TYPEDEF;
  Nv086Typedef NV086_TYPEDEF;
  Nv087Typedef NV087_TYPEDEF;
  Nv088Typedef NV088_TYPEDEF;
  Nv089Typedef NV089_TYPEDEF;
  Nv093Typedef NV093_TYPEDEF;
  Nv094Typedef NV094_TYPEDEF;
  Nv095Typedef NV095_TYPEDEF;
  Nvff0Typedef NVFF0_TYPEDEF;
  Nvff1Typedef NVFF1_TYPEDEF;
  Nvff2Typedef NVFF2_TYPEDEF;
  Nvff3Typedef NVFF3_TYPEDEF;
  Nvff4Typedef NVFF4_TYPEDEF;
  Nvff5Typedef NVFF5_TYPEDEF;
  Nvff6Typedef NVFF6_TYPEDEF;
  Nvff7Typedef NVFF7_TYPEDEF;
  Nvff8Typedef NVFF8_TYPEDEF;
  Nvff9Typedef NVFF9_TYPEDEF;
  NvffaTypedef NVFFA_TYPEDEF;
  NvffbTypedef NVFFB_TYPEDEF;
  NvffcTypedef NVFFC_TYPEDEF;
  NvffdTypedef NVFFD_TYPEDEF;
  NvffeTypedef NVFFE_TYPEDEF;
  NvfffTypedef NVFFF_TYPEDEF;
#ifdef __GNUC__         /* anon union does not work on GCC */
 }  cls   ;         /* end of class methods                  -1fff*/
#else  /* __GNUC__ */
 }  /* cls */  ;    /* end of class methods                  -1fff*/
#endif /* __GNUC__ */

} Nv03SubchannelPio;
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv03SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv03ChannelPio;              /* end of array of subchannels           -ffff*/
/* fields and values */
#define NV06A_FIFO_GUARANTEED_SIZE                                 (0x007C)
#define NV06A_FIFO_EMPTY                                           (0x007C)
#define NV06A_FIFO_FULL                                            (0x0000)
/* obsolete stuff */
#define NV3_CHANNEL_PIO                                            (0x0000006A)
#define Nv3ControlPio                                            Nv03ControlPio
#define Nv3SubchannelPio                                      Nv03SubchannelPio
#define Nv3ChannelPio                                            Nv03ChannelPio
#define NvChannel                                                Nv03ChannelPio
#define nv03ChannelPio                                           Nv03ChannelPio


/* class NV03_CHANNEL_DMA */
#define  NV03_CHANNEL_DMA                                          (0x0000006B)
/* NvNotification[] fields and values */
#define NV06B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06bTypedef, Nv03ChannelDma;
#define NV06B_TYPEDEF                                            Nv03ChannelDma
#define nv03ChannelDma                                           Nv03ChannelDma


/* class NV04_CHANNEL_PIO */
#define  NV04_CHANNEL_PIO                                          (0x0000006D)
/* NvNotification[] fields and values */
#define NV06D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV06D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06D_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL               (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x003];
#ifdef NV_BIG_ENDIAN
 NvU32 Free;                    /* 32 bit free count, read only     0010-0013*/
 NvU32 Zero;                    /* zeroes, read only                0014-0017*/
#else
 NvU16 Free;                    /* free count, read only            0010-0011*/
 NvU16 Zero[3];                 /* zeroes, read only                0012-0017*/
#endif
 NvV32 Reserved01[0x03A];
} Nv04ControlPio;
typedef volatile struct {
 NvV32 SetObject;               /* handle of current object         0000-0003*/
 Nv04ControlPio control;        /* flow control                     0000-00ff*/
 union {                        /* start of class methods           0100-    */
  Nv000Typedef NV000_TYPEDEF;
  Nv001Typedef NV001_TYPEDEF;
  Nv002Typedef NV002_TYPEDEF;
  Nv003Typedef NV003_TYPEDEF;
  Nv004Typedef NV004_TYPEDEF;
  Nv005Typedef NV005_TYPEDEF;
  Nv006Typedef NV006_TYPEDEF;
  Nv007Typedef NV007_TYPEDEF;
  Nv008Typedef NV008_TYPEDEF;
  Nv009Typedef NV009_TYPEDEF;
  Nv00aTypedef NV00A_TYPEDEF;
  Nv00bTypedef NV00B_TYPEDEF;
  Nv00cTypedef NV00C_TYPEDEF;
  Nv00dTypedef NV00D_TYPEDEF;
  Nv00eTypedef NV00E_TYPEDEF;
  Nv00fTypedef NV00F_TYPEDEF;
  Nv010Typedef NV010_TYPEDEF;
  Nv011Typedef NV011_TYPEDEF;
  Nv012Typedef NV012_TYPEDEF;
  Nv013Typedef NV013_TYPEDEF;
  Nv014Typedef NV014_TYPEDEF;
  Nv015Typedef NV015_TYPEDEF;
  Nv016Typedef NV016_TYPEDEF;
  Nv017Typedef NV017_TYPEDEF;
  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01aTypedef NV01A_TYPEDEF;
  Nv01bTypedef NV01B_TYPEDEF;
  Nv01cTypedef NV01C_TYPEDEF;
  Nv01dTypedef NV01D_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv020Typedef NV020_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv022Typedef NV022_TYPEDEF;
  Nv023Typedef NV023_TYPEDEF;
  Nv024Typedef NV024_TYPEDEF;
  Nv025Typedef NV025_TYPEDEF;
  Nv026Typedef NV026_TYPEDEF;
  Nv027Typedef NV027_TYPEDEF;
  Nv028Typedef NV028_TYPEDEF;
  Nv029Typedef NV029_TYPEDEF;
  Nv02aTypedef NV02A_TYPEDEF;
  Nv02bTypedef NV02B_TYPEDEF;
  Nv02cTypedef NV02C_TYPEDEF;
  Nv02dTypedef NV02D_TYPEDEF;
  Nv02eTypedef NV02E_TYPEDEF;
  Nv02fTypedef NV02F_TYPEDEF;
  Nv030Typedef NV030_TYPEDEF;
  Nv031Typedef NV031_TYPEDEF;
  Nv032Typedef NV032_TYPEDEF;
  Nv033Typedef NV033_TYPEDEF;
  Nv034Typedef NV034_TYPEDEF;
  Nv035Typedef NV035_TYPEDEF;
  Nv036Typedef NV036_TYPEDEF;
  Nv037Typedef NV037_TYPEDEF;
  Nv038Typedef NV038_TYPEDEF;
  Nv039Typedef NV039_TYPEDEF;
  Nv03aTypedef NV03A_TYPEDEF;
  Nv03bTypedef NV03B_TYPEDEF;
  Nv03cTypedef NV03C_TYPEDEF;
  Nv03dTypedef NV03D_TYPEDEF;
  Nv03eTypedef NV03E_TYPEDEF;
  Nv03fTypedef NV03F_TYPEDEF;
  Nv040Typedef NV040_TYPEDEF;
  Nv041Typedef NV041_TYPEDEF;
  Nv042Typedef NV042_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv044Typedef NV044_TYPEDEF;
  Nv045Typedef NV045_TYPEDEF;
  Nv046Typedef NV046_TYPEDEF;
  Nv047Typedef NV047_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv049Typedef NV049_TYPEDEF;
  Nv04aTypedef NV04A_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv04cTypedef NV04C_TYPEDEF;
  Nv04dTypedef NV04D_TYPEDEF;
  Nv04eTypedef NV04E_TYPEDEF;
  Nv04fTypedef NV04F_TYPEDEF;
  Nv050Typedef NV050_TYPEDEF;
  Nv051Typedef NV051_TYPEDEF;
  Nv052Typedef NV052_TYPEDEF;
  Nv053Typedef NV053_TYPEDEF;
  Nv054Typedef NV054_TYPEDEF;
  Nv055Typedef NV055_TYPEDEF;
  Nv096Typedef NV096_TYPEDEF;
  Nv057Typedef NV057_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05aTypedef NV05A_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;
  Nv05cTypedef NV05C_TYPEDEF;
  Nv05dTypedef NV05D_TYPEDEF;
  Nv05eTypedef NV05E_TYPEDEF;
  Nv05fTypedef NV05F_TYPEDEF;
  Nv060Typedef NV060_TYPEDEF;
  Nv061Typedef NV061_TYPEDEF;
  Nv062Typedef NV062_TYPEDEF;
  Nv063Typedef NV063_TYPEDEF;
  Nv064Typedef NV064_TYPEDEF;
  Nv065Typedef NV065_TYPEDEF;
  Nv066Typedef NV066_TYPEDEF;
  Nv067Typedef NV067_TYPEDEF;
/*Nv068Typedef NV068_TYPEDEF;*/
/*Nv069Typedef NV069_TYPEDEF;*/
/*Nv06aTypedef NV06A_TYPEDEF;*/
/*Nv06bTypedef NV06B_TYPEDEF;*/
/*Nv06cTypedef NV06C_TYPEDEF;*/
/*Nv06dTypedef NV06D_TYPEDEF;*/
/*Nv06eTypedef NV06E_TYPEDEF;*/
  Nv06fTypedef NV06F_TYPEDEF;
  Nv070Typedef NV070_TYPEDEF;
  Nv071Typedef NV071_TYPEDEF;
  Nv072Typedef NV072_TYPEDEF;
  Nv073Typedef NV073_TYPEDEF;
  Nv074Typedef NV074_TYPEDEF;
  Nv075Typedef NV075_TYPEDEF;
  Nv076Typedef NV076_TYPEDEF;
  Nv077Typedef NV077_TYPEDEF;
  Nv078Typedef NV078_TYPEDEF;
  Nv079Typedef NV079_TYPEDEF;
  Nv07aTypedef NV07A_TYPEDEF;
  Nv07bTypedef NV07B_TYPEDEF;
  Nv07cTypedef NV07C_TYPEDEF;
  Nv07dTypedef NV07D_TYPEDEF;
  Nv07eTypedef NV07E_TYPEDEF;
  Nv07fTypedef NV07F_TYPEDEF;
  Nv080Typedef NV080_TYPEDEF;
  Nv081Typedef NV081_TYPEDEF;
  Nv082Typedef NV082_TYPEDEF;
  Nv083Typedef NV083_TYPEDEF;
  Nv084Typedef NV084_TYPEDEF;
  Nv085Typedef NV085_TYPEDEF;
  Nv086Typedef NV086_TYPEDEF;
  Nv087Typedef NV087_TYPEDEF;
  Nv088Typedef NV088_TYPEDEF;
  Nv089Typedef NV089_TYPEDEF;
  Nv093Typedef NV093_TYPEDEF;
  Nv094Typedef NV094_TYPEDEF;
  Nv095Typedef NV095_TYPEDEF;
  Nv097Typedef NV097_TYPEDEF;
  Nv1189Typedef NV1189_TYPEDEF;
  Nv205fTypedef NV205F_TYPEDEF;
  Nv207cTypedef NV207C_TYPEDEF;
  Nvff0Typedef NVFF0_TYPEDEF;
  Nvff1Typedef NVFF1_TYPEDEF;
  Nvff2Typedef NVFF2_TYPEDEF;
  Nvff3Typedef NVFF3_TYPEDEF;
  Nvff4Typedef NVFF4_TYPEDEF;
  Nvff5Typedef NVFF5_TYPEDEF;
  Nvff6Typedef NVFF6_TYPEDEF;
  Nvff7Typedef NVFF7_TYPEDEF;
  Nvff8Typedef NVFF8_TYPEDEF;
  Nvff9Typedef NVFF9_TYPEDEF;
  NvffaTypedef NVFFA_TYPEDEF;
  NvffbTypedef NVFFB_TYPEDEF;
  NvffcTypedef NVFFC_TYPEDEF;
  NvffdTypedef NVFFD_TYPEDEF;
  NvffeTypedef NVFFE_TYPEDEF;
  NvfffTypedef NVFFF_TYPEDEF;
#ifdef __GNUC__         /* anon union does not work on GCC */
 }  cls   ;         /* end of class methods                  -1fff*/
#else  /* __GNUC__ */
 }  /* cls */  ;    /* end of class methods                  -1fff*/
#endif /* __GNUC__ */
} Nv04SubchannelPio;
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv04SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv04ChannelPio;              /* end of array of subchannels           -ffff*/
/* fields and values */
#define NV06D_FIFO_GUARANTEED_SIZE                                 (0x0200)
#define NV06D_FIFO_EMPTY                                           (0x0200)
#define NV06D_FIFO_FULL                                            (0x0000)


/* class NV04_CHANNEL_DMA */
#define  NV04_CHANNEL_DMA                                          (0x0000006C)
/* NvNotification[] fields and values */
#define NV06C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06cTypedef, Nv04ChannelDma;
#define NV06C_TYPEDEF                                            Nv04ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only            0040-0043*/
 NvU32 Get;                     /* get offset, read only             0044-0047*/
 NvV32 Ignored01[0x002];
 NvU32 StallNotifier;           /* Set stall notifier                0050-0053*/
 NvU32 StallChannel;            /* Stall the channel                 0054-0057*/
 NvV32 Ignored02[0x7EA];
} Nv04ControlDma;
/* obsolete stuff */
#define NV4_CHANNEL_DMA                                            (0x0000006C)
#define Nv4ChannelDma                                            Nv04ChannelDma
#define nv4ChannelDma                                            Nv04ChannelDma
#define Nv4ControlDma                                            Nv04ControlDma


/* class NV10_CHANNEL_DMA */
#define  NV10_CHANNEL_DMA                                          (0x0000006E)
/* NvNotification[] fields and values */
#define NV06E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06eTypedef, Nv10ChannelDma;
#define NV06E_TYPEDEF                                            Nv10ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only           0040-0043*/
 NvU32 Get;                     /* get offset, read only            0044-0047*/
 NvU32 Reference;               /* reference value, read only       0048-004b*/
 NvV32 Ignored01[0x7ed];
} Nv06eControl, Nv10ControlDma;
/* fields and values */
#define NV06E_NUMBER_OF_SUBCHANNELS                                (8)
#define NV06E_SET_OBJECT                                           (0x00000000)
#define NV06E_SET_REFERENCE                                        (0x00000050)
#define NV06E_SWAP_EXTENSION                                       (0x00000090)

/* class NV20_CHANNEL_DMA */
#define  NV20_CHANNEL_DMA                                          (0x0000206E)
/* NvNotification[] fields and values */
#define NV206E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT              (0x2000)
#define NV206E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT          (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv206eTypedef, Nv20ChannelDma;
#define NV206E_TYPEDEF                                           Nv20ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only           0040-0043*/
 NvU32 Get;                     /* get offset, read only            0044-0047*/
 NvU32 Reference;               /* reference value, read only       0048-004b*/
 NvV32 Ignored01[0x7ed];
} Nv206eControl, Nv20ControlDma;
/* fields and values */
#define NV206E_NUMBER_OF_SUBCHANNELS                               (8)
#define NV206E_SET_OBJECT                                          (0x00000000)
#define NV206E_SET_REFERENCE                                       (0x00000050)
#define NV206E_SET_CONTEXT_DMA_SEMAPHORE                           (0x00000060)
#define NV206E_SEMAPHORE_OFFSET                                    (0x00000064)
#define NV206E_SEMAPHORE_ACQUIRE                                   (0x00000068)
#define NV206E_SEMAPHORE_RELEASE                                   (0x0000006c)
#define NV206E_SWAP_EXTENSION                                      (0x00000090)
#define NV206E_SUBROUTINE_RETURN_SW                                (0x0000009c)

 /***************************************************************************\
|*                            Well Known Objects                             *|
 \***************************************************************************/


/* object NV01_NULL_OBJECT */
#define   NV01_NULL_OBJECT                                         (0x00000000)
/* obsolete stuff */
#define NV1_NULL_OBJECT                                            (0x00000000)



 /***************************************************************************\
|*                               Notification                                *|
 \***************************************************************************/


/***** NvNotification Structure *****/
/*
 * NV objects return information about method completion to clients via an
 * array of notification structures in main memory.
 *
 * The client sets the status field to NV???_NOTIFICATION_STATUS_IN_PROGRESS.
 * NV fills in the NvNotification[] data structure in the following order:
 * timeStamp, otherInfo32, otherInfo16, and then status.
 */


/* memory data structures */
typedef volatile struct {
 struct {                      /*                                   0000-    */
  NvU32 nanoseconds[2];        /* nanoseconds since Jan. 1, 1970       0-   7*/
 } timeStamp;                  /*                                       -0007*/
 NvV32 info32;                 /* info returned depends on method   0008-000b*/
 NvV16 info16;                 /* info returned depends on method   000c-000d*/
 NvV16 status;                 /* user sets bit 15, NV sets status  000e-000f*/
} NvNotification;
/* status values */

 /***************************************************************************\
|*                          NvGraphicsState                                  *|
 \***************************************************************************/
/***** NvGraphicsState Structure *****/
/*
 * This represents the state structure that's passed between the Celsius
 * GetState method and the RM (in nv10 and eventually the HW). The context
 * DMA passed to NV056_SET_CONTEXT_DMA_STATE should be at least this size.
 */

typedef volatile struct {
    struct _PerFragmentState {
        // *** dword 0
        NvU32          pad0 : 8;
        NvU32     alphaFunc : 4;
        NvU32          pad1 : 4;
        NvU32     depthFunc : 4;
        NvU32          pad2 : 4;
        NvU32     depthMask : 1;
        NvU32          pad3 : 1;
        NvU32     alphaMask : 1;
        NvU32       redMask : 1;
        NvU32     greenMask : 1;
        NvU32      blueMask : 1;
        NvU32          pad4 : 2;
        // *** dword 1
        NvU32          pad5 : 4;
        NvU32   stencilFunc : 4;
        NvU32    stencilRef : 8;
        NvU32          pad6 : 8;
        NvU32   stencilMask : 8;
        // *** dword 2
        NvU32       sfailOp : 4;
        NvU32       zfailOp : 4;
        NvU32       zpassOp : 4;
        NvU32         pad7 : 20;
        // *** dword 3
        NvU32 blendEquation : 3;
        NvU32          pad8 : 1;
        NvU32      srcBlend : 4;
        NvU32     destBlend : 4;
        NvU32         pad9 : 20;
    } PerFragmentState;
    struct _PerVertexState {
        NvF32           pad0[4];
        NvF32   primaryColor[4];
        NvF32 secondaryColor[3];
        NvF32          fogCoord;
        NvF32    texCoord[2][4];
        NvF32         normal[3];
        NvF32              pad1;
        NvF32      vertexWeight;
        NvU32           pad2[7];
        NvU32              pad3;
        NvU32      edgeFlag : 8;
        NvU32         pad4 : 24;
        NvU32           pad5[2];
    } PerVertexState;
    NvU32       glBeginEndState;
    struct _VertexArrayState {
        NvU32      vertexOffset;
        NvU32      vertexFormat;
        NvU32     diffuseOffset;
        NvU32     diffuseFormat;
        NvU32    specularOffset;
        NvU32    specularFormat;
        NvU32   texCoord0Offset;
        NvU32   texCoord0Format;
        NvU32   texCoord1Offset;
        NvU32   texCoord1Format;
        NvU32      normalOffset;
        NvU32      normalFormat;
        NvU32      weightOffset;
        NvU32      weightFormat;
        NvU32         fogOffset;
        NvU32         fogFormat;
    } VertexArrayState;
    struct _PrimitiveAssmState {
        NvU32    primAssm[3*16];
    } PrimitiveAssmState;
} NvGraphicsState;

 /***************************************************************************\
|*                          Object Allocation Parameters                     *|
 \***************************************************************************/

// XXX need to add versioning to these
//     version #'s should probably have engine number encoded to protect against
//     caller using the wrong typedef.
// XXX need to convert to engine creation params whenever possible
// XXX try to delete pInfo

// class 0x07c creation parameters
typedef struct
{
    NvU32   version;
    NvP64   pInfo;
    NvU32   logicalHeadId;

} NV07C_ALLOCATION_PARAMETERS;

// class 0x207c creation parameters
typedef struct
{
    NvU32   version;
    NvP64   pInfo;
    NvU32   logicalHeadId;

} NV207C_ALLOCATION_PARAMETERS;

// class 0x07a creation parameters
typedef struct
{
    NvU32   version;
    NvP64   pInfo;
    NvU32   logicalHeadId;

} NV07A_ALLOCATION_PARAMETERS;

// GR engine creation parameters
typedef struct
{
    NvU32   version;
    NvU32   flags;
} NV_GR_ALLOCATION_PARAMETERS;

// GR engine flags; must match hal layout.
#define NV_GR_ALLOCATION_PARAMETERS_FLAGS_ENDIAN_OVERRIDE          1:0
#define NV_GR_ALLOCATION_PARAMETERS_FLAGS_ENDIAN_OVERRIDE_NONE      0     // use native endianness
#define NV_GR_ALLOCATION_PARAMETERS_FLAGS_ENDIAN_OVERRIDE_LITTLE    1
#define NV_GR_ALLOCATION_PARAMETERS_FLAGS_ENDIAN_OVERRIDE_BIG       2

 /***************************************************************************\
|*                          NVIDIA Debug Extensions                         *|
 \***************************************************************************/

/*
 * These class numbers are a temporary hack to allow the debugger
 * client to use the NvAlloc interface to access debugger services.
 */
#define  NVDE_REGISTER_DEBUGGER                                    (0xDE000001)
#define  NVDE_UNREGISTER_DEBUGGER                                  (0xDE000002)
#define  NVDE_READ_MEMORY                                          (0xDE000003)
#define  NVDE_WRITE_MEMORY                                         (0xDE000004)
#define  NVDE_GET_EVENT_INFORMATION                                (0xDE000005)
#define  NVDE_TEST                                                 (0xDE00ffff)

#define NVDE_DEBUGGER                                              (0xDE000000)

/*
 * Status codes.
 */
#define NVDE_STATUS_SUCCESS                                         (0x0000)
#define NVDE_STATUS_ERROR_STATE_IN_USE                              (0x0001)
#define NVDE_STATUS_ERROR_BAD_ARGUMENT                              (0x0002)

/*
 * Class-specific parameter blocks.
 */
typedef struct
{
    NvU64 EventHandle;
    NvU32 EventClass;
} NVDE_ALLOCATION_PARAMETERS;

// must be replaced by NVDE class
typedef struct
{
    NvU32 TrapEvent;
} NVDE_REGISTER_DEBUGGER_PARAMETERS;

// must be replaced by NVDE class
typedef struct
{
    NvU32 foo;
} NVDE_UNREGISTER_DEBUGGER_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 Address;
    NvU32 Size;
    NvU32 Data;
} NVDE_READ_MEMORY_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 Address;
    NvU32 Size;
    NvU32 Data;
} NVDE_WRITE_MEMORY_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 CallBackAddress;
} NVDE_TEST_PARAMETERS;

typedef NvU32 (*NVDE_TEST_FUNC)(void);

// must be moved to NVDE class
typedef struct
{
    U032 Count;
    U032 Event[32][8];
} NVDE_GET_EVENT_INFORMATION_PARAMETERS;

/* class NV01_DEVICE_AUDIO */
#define  NV01_DEVICE_AUDIO                                         (0x000000A0)
/* NvNotification[] fields and values */
#define NV0A0_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A0_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A0_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0A0Typedef, Nv01DeviceAudio;
#define  NV0A0_TYPEDEF                                             Nv01DeviceAudio

#define NV01_CONTEXT_DMA_AUDIO                                      (0x000000A1)
/* NvNotification[] fields and values */
#define NV0A1_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A1_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A1_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)

#define NV1B_AUDIO_OBJECT                                           (0x000000A2)
/* NvNotification[] fields and values */
#define NV0A2_NOTIFICATION_STATUS_NOT_IMPLEMENTED                   (0x0000)
#define NV0A2_NOTIFICATION_STATUS_REQUESTED                         (0x0001)
#define NV0A2_NOTIFICATION_STATUS_METHOD_UNKNOWN                    (0x0002)
#define NV0A2_NOTIFICATION_STATUS_BAD_ARGUMENT                      (0x2000)
#define NV0A2_NOTIFICATION_STATUS_CURRENT_NOT_SET                   (0x0004)
#define NV0A2_NOTIFICATION_STATUS_ANTECEDENT_NOT_SET                (0x0005)
#define NV0A2_NOTIFICATION_STATUS_VOICE_ACTIVE                      (0x0006)
#define NV0A2_NOTIFICATION_STATUS_NOT_DATA_TYPE_BUFFER              (0x0007)

/* class NV01_DEVICE_EXTERNAL_CODEC */
#define  NV01_DEVICE_EXTERNAL_CODEC                                 (0x000000A3)
/* NvNotification[] fields and values */
#define NV0A0_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A0_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A0_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0A3Typedef, Nv03DeviceExternalCodec;
#define  NV0A3_TYPEDEF                                             Nv01DeviceCodec

#define NV01_CONTEXT_DMA_EXTERNAL_CODEC                             (0x000000A4)
/* NvNotification[] fields and values */
#define NV0A1_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A1_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A1_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)

#define NV01_EXTERNAL_CODEC_OBJECT                                  (0x000000A5)
/* NvNotification[] fields and values */
#define NV0A2_NOTIFICATION_STATUS_NOT_IMPLEMENTED                   (0x0000)
#define NV0A2_NOTIFICATION_STATUS_REQUESTED                         (0x0001)
#define NV0A2_NOTIFICATION_STATUS_METHOD_UNKNOWN                    (0x0002)
#define NV0A2_NOTIFICATION_STATUS_BAD_ARGUMENT                      (0x2000)
#define NV0A2_NOTIFICATION_STATUS_CURRENT_NOT_SET                   (0x0004)
#define NV0A2_NOTIFICATION_STATUS_ANTECEDENT_NOT_SET                (0x0005)
#define NV0A2_NOTIFICATION_STATUS_VOICE_ACTIVE                      (0x0006)
#define NV0A2_NOTIFICATION_STATUS_NOT_DATA_TYPE_BUFFER              (0x0007)

#define NV01_EXTERNAL_CODEC_WRITE                                   (0x000000A6)
// define the errors here later
#define NV01_EXTERNAL_CODEC_READ                                    (0x000000A7)
// define the errors here later

// this IOCTL manages system memory for the client - see AUDIO_ALLOC_MEMORY / AUDIO_FREE_MEMORY
#define NV01_MEMORY_AUDIO		                                    (0x000000A8)

// class 0x0A1 creation params (NV01_CONTEXT_DMA_AUDIO)

typedef union
{
	struct
	{
		NvU32 : 32;
	}codec;

	struct
	{
		NvU32  : 27;
		// interrupts originating from FE/SE
		NvU32 FEMethodOverFlow : 1;	// user method fifo has been overwritten
		NvU32 FEVoice : 1;			// end-of-buffer / end-of-stream
		NvU32 FENotify : 1;			// notifier originating from the FE has been written
		NvU32 DeltaPanic : 1;		// delta panic
		NvU32 DeltaWarning : 1;		// delta warning
	}apu;
	
	NvU32 uValue;					// set to ~0x0 (for codec) if the ISR fn is to be called regardless
} INTR_MASK;

typedef void (*PISRCALLBACK)(NvV32,	/* service context*/ 
							NvU32,	/* interrupt mask (INTR_MASK.uValue) with bits of triggered intr set */
							NvV32);	/* info based on reason */

typedef struct
{
	NvV32			pResList;		/*	address of resource structure	*/
	NvU8			uRevisionID;	/*	HW Revision ID of the chip - byte 0x8 in the PCI config */
	NvV32			pDevObj;		/*	address of device object		*/		
	PISRCALLBACK	pISRFn;			/*	address to an optional ISR		*/
	NvV32			pServiceContext;/*	service context for the ISR		*/
	INTR_MASK		IntrMask;		/*	set the bits for which pISRFn needs to be called	*/
	NvU32			uDeviceRef;		/*	device reference				*/
} AUDIO_INIT_DEVICE;

/*
Arguments:
		IN pResourceList - 	of type PCM_RESOURCE_LIST (WDM) - translated resource list got in IRP_MN_START_DEVICE
				of type CM_CONFIG (Win9X VxD)
				of type PCI_COMMON_CONFIG (NT4)
				TBD for linux.
	 	IN pDeviceObject - only valid in NT and WDM, ignored in Win9X VxD
		IN pISRFn (optional) - not recommended unless it is absolutely necessary.  
								The driver can install it to handle interrupts from the codec if it needs to.  
								Type - void pISRFn(U032 ServiceContext);
		IN uServiceContext (optional) - value passed back to the pISRFn if installed.
		OUT pDeviceRef	- device ref returned by the RM
*/

// notifier structures used between the client and the audio RM
typedef struct 
{
	NvU32 volatile  GSCNT;
	NvU32 volatile  CurrentOffset;
	NvU32 volatile  Zero;
	NvU8 volatile	Res0;
	NvU8 volatile	SamplesAvailable;       // not in sync
	NvU8 volatile	EnvelopeActive;         // not in sync
	NvU8 volatile	Status;
} NV1BA0NOTIFICATION, *PNV1BA0NOTIFICATION;

// notifier for GP
typedef struct 
{
	NvU32 volatile  GSCNT;
    NvU32 volatile	Method;
	NvU32 volatile	Data;
	NvU8 volatile	ReturnCode;
	NvU8 volatile	Res0;
	NvU8 volatile	Res1;
	NvU8 volatile	Status;
} NVAUDGPNOTIFICATION, *PNVAUDGPNOTIFICATION;

// status codes for GP notifiers
#define NV_AUDGP_NOTIFICATION_STATUS_IN_PROGRESS       0x00000000
#define NV_AUDGP_NOTIFICATION_STATUS_DONE_SUCCESS      0x00000001

// defines the "type" for context DMA
#define AUDIO_CONTEXT_DMA_SESGE         0x1
#define AUDIO_CONTEXT_DMA_SESSL         0x2
#define AUDIO_CONTEXT_DMA_GPSGE         0x3
#define AUDIO_CONTEXT_DMA_FENOTIFIER    0x4
#define AUDIO_CONTEXT_DMA_EPSGE         0x5
#define AUDIO_CONTEXT_DMA_GPNOTIFIER    0x6
#define AUDIO_CONTEXT_DMA_EPNOTIFIER    0x7
#define AUDIO_CONTEXT_DMA_GPFXPARAM     0x8
#define AUDIO_CONTEXT_DMA_GPFXDSPCODE   0x9

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU8	uType;              // one of the values defined above
	NvU32	uBaseAddress;       // base address for the type. (must be 4K aligned)
	NvU32	uMaxOffset;         // max offset for the type. (must be 4K aligned)
	NvU32	uHandle;            // OUT: handle of the context DMA
} APU_AP_ALLOC_CONTEXT_DMA;

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU32	uHandle;            // handle of the context DMA
} APU_AP_FREE_CONTEXT_DMA;


#define GSCNT_OFF                   0 
#define GSCNT_ACSYNC                1   /* updated for every AC_SYNC pulse (48KHz) */
#define GSCNT_SW                    2   /* client will update it */
#define GSCNT_FREE_RUNNING          3 

// class 0x0A2 creation parameters (NV1B_AUDIO_PROCESSOR)
typedef union
{
    struct
    {	
        NvU32 FEISORead     : 1;
        NvU32 FEISOWrite    : 1;
        NvU32 FEISONotify   : 1;
        NvU32 FEISOPIO      : 1;
        NvU32 SEISORead     : 1;
        NvU32 SEISOWrite    : 1;
        NvU32 SEISOSampleRead : 1;
        NvU32 GSCNT         : 2;        // see values defined above
        NvU32               : 23;
    }fields;
    
    NvU32 uValue;
} APU_AP_FLAGS;

typedef struct 
{
    NvV32           pObjectDmaBuffer;           // in buffer for global effects dma commands.
    NvV32           pObjectNotifiesBuffer;      // in buffer for voice notifies
    NvV32           pObjectGlobalNotifiesBuffer; // in buffer for global notifies
    APU_AP_FLAGS    flags; 
    VOID_PTR        pioBase; 
    NvU32           limitFifo; 
    NvU32           limitBandwidth; 
    NvU32           limitBlockClock; 
    NvU32           overhead; 
    
    NvU32           uVoiceCount;        // in/out req # of voices , return #
    NvU32           uVoice3dCount;      // in/out req # of 3d voices , return #
    NvU32           uHRTFCount;         // in/out req # of HRTFs, return #
    NvU32           uSubmixCount;       // in/out req # of Submixes, return #
    NvU32           uSegInCount;        // in/out req # of segments for input, return #
    NvU32           uSGEInCount;        // in/out req # of 4K SGE for input, return #
    NvU32           uSGEOutCount;       // in/out req # of 4K SGE for output, return #
    VOID_PTR        pGPCommandQ;        // base address of CommandQ of the GP.  Offsets for method/data
                                        // pair are got from NV1BA0_CHANNEL_DMA_PUT/NV1BA0_CHANNEL_DMA_GET

    // global sample count values - ignored if GSCNT = GSCNT_FREE_RUNNING
    NvU32           uExternalGSCNT;     // in updated according to the GSCNT flag above
    NvU32           uInternalGSCNT;     // in updated by HW, by frame_size everytime output is made to sys mem
    NvU32           uDeltaGSCNT;        // in if (uInternalGSCNT - uExternalGSCNT) < uDeltaGSCNT, HW renders
    
    VOID_PTR        pVoiceList;         // out (DEBUG ONLY) - linear address of the voice structure
    VOID_PTR        pGPScratchLin;      // out linear pointer to GP scratch memory
}APU_AP_CREATE;


typedef struct
{
    VOID_PTR        pioBase;
    NvU32           uUseForAC3;         // in - reserve for Ac-3 encode, no other effects can be loaded

    NvU32           uSGEOutCount;       // in/out req # of 4K SGE for output, return #

    // global sample counts applied only to teh EP
    NvU32           uInternalGSCNT;     // in updated by HW, by frame_size everytime output is made to sys mem
    NvU32           uDeltaGSCNT;        // in if (uInternalGSCNT - APU_AP_CREATE::uExternalGSCNT) < uDeltaGSCNT, HW renders
    NvU32           uStepSize;          // in step size added to uInternalGSCNT each frame
    VOID_PTR        pEPScratchLin;      // out linear pointer to EP scratch memory
    NvU32           uAC3GpOutputOffset; // DEBUG only!  offset into GP scratch that has the AC3 output
} APU_EP_CREATE;

typedef APU_AP_CREATE NV0A2_ALLOCATION_PARAMETERS;

// NV01_EXTERNAL_CODEC_OBJECT

// class 0x0A5 creation parameters (NV01_EXTERNAL_CODEC_OBJECT)
typedef struct
{
	VOID_PTR	pioBaseMixer;
	VOID_PTR	pioBaseAci;
} CODEC_AUDIO_CREATE;

// the object alloc structure is used, both for codec and APU object allocation
// uObjectCode codes
#define	AUDIO_OBJECT_AP					0x1
#define AUDIO_OBJECT_EP					0x2
#define CODEC_OBJECT_AUDIO				0x3
#define CODEC_OBJECT_MODEM				0x4		/* not supported */

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU8	uObjectCode;
	NvV32	pParam;	
} APU_OBJECT;

#define CODEC_ACCESS_08				1
#define CODEC_ACCESS_16				2
#define CODEC_ACCESS_32				4

// alloc params for NV01_EXTERNAL_CODEC_READ & NV01_EXTERNAL_CODEC_WRITE
typedef struct
{
	NvU32	    uDeviceRef;	            // device reference
	VOID_PTR	BaseAddr;               // base address for which read/write is made
	NvU32	    Offset;                 // offset from the base address for which access is to be made
	NvV32	    AccessType;             // hardware access type
	/*
	for BYTE reads/writes	ValidBytes = CODEC_ACCESS_08 valid Val field = u8
	for WORD reads/writes	ValidBytes = CODEC_ACCESS_16 valid Val field = u16
	for DWORD reads/writes	ValidBytes = CODEC_ACCESS_32 valid Val Field = u32
	any other value for ValidBytes is illegal
	*/
	union
	{
		NvU8	u8;
		NvU16	u16;
		NvU32	u32;
	}Val;
}CODEC_ACCESS_PARAMS;


// 0xA8 memory management paramters

#define MEM_ALIGN_4K					0x00000000
#define MEM_ALIGN_8K					0x00000001		
#define MEM_ALIGN_16K					0x00000003
#define MEM_ALIGN_32K					0x00000007
#define MEM_ALIGN_64K					0x0000000F
#define MEM_ALIGN_128K					0x0000001F
#define MEM_ALIGN_DONT_CARE				0xFFFFFFFF

// for allocation use:
typedef struct
{
	NvU32       uSize;          // IN:	size of memory to be allocated in bytes
	NvU32       uAlignMask;     // IN:	alignment mask to get physically contiguous memory
                                // use ALIGN_DONT_CARE if it need not be aligned and physically contiguous
	VOID_PTR    pLinearAddress; // OUT: linear address of allocated memory (NULL on failure)
} AUDIO_ALLOC_MEMORY;

// for freeing memory use:
typedef struct
{
	VOID_PTR    pLinearAddress; // IN: linear address of allocated memory
} AUDIO_FREE_MEMORY;

#ifdef __cplusplus
};          // extern "C" {
#endif

#endif /* NV32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\NvImage.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: NvImage.h                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    10/03/2000  Created                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVIMAGE_H_
#define _NVIMAGE_H_

#ifdef  DEFINE_JPEG_TYPES
#include <stdio.h>
#include <string.h>
#include "jpeglib.h"
#else   //~DEFINE_JPEG_TYPES
struct jpeg_decompress_struct {
    DWORD Pan;
};
typedef BYTE JSAMPLE;
#endif  //~DEFINE_JPEG_TYPES

typedef void (__stdcall *SCANLINEPROCESS)(void *, int);

typedef enum _JPEGParameterType_ {
    JPEG_WRITE_QUALITY      = 1,
    JPEG_READ_DEPTH         = 2,
} JPEGPARAMETERTYPE;

#ifdef __cplusplus

typedef class CImageObject
{
    /*
     * methods
     */
public:
    virtual void WINAPI CompressJPEG (void *pAddr, DWORD dwWidth, DWORD dwHeight, char * filename);
    virtual void WINAPI GetJPEGInfoFile (char * filename, DWORD *pWidth, DWORD *pHeight, DWORD *pBPP);
    virtual void WINAPI GetJPEGInfo (char *pcBuffer, int nLength, DWORD *pWidth, DWORD *pHeight, DWORD *pBPP);
    virtual DWORD WINAPI SetJPEGParameters (JPEGPARAMETERTYPE type, DWORD value);
    virtual void WINAPI DecompressJPEGFile (char * filename, SCANLINEPROCESS ScanlineProcess = NULL);
		virtual void WINAPI DecompressJPEG (char *pcBuffer, int nLength, SCANLINEPROCESS ScanlineProcess = NULL);
    virtual void WINAPI GetImageParameters (char *&Start, char *&Current, DWORD &Width, DWORD &Height, DWORD &BPP);
    virtual DWORD WINAPI DestroyImageObject(void);
    CImageObject();
    ~CImageObject();
protected:
    void write_JPEG_file (char * filename, int quality);
    int  get_JPEG_file_info (char * filename, struct jpeg_decompress_struct *pCinfo);
    int  get_JPEG_buffer_info (char *pBuffer, int nLength, struct jpeg_decompress_struct *pCinfo);
    int  read_JPEG_file (char * filename, SCANLINEPROCESS ScanlineProcess);
		int  read_JPEG_buffer (char *pBuffer, int nLength, SCANLINEPROCESS ScanlineProcess);
    void __stdcall InternalScanlineProcess(LPVOID pBuf, int stride);
protected:
    int       out_quality;          /* Specify quality of the subsequent compression 0-100, 100 being highest. */ 
    JSAMPLE * out_image_buffer;	    /* Points to large array of R,G,B-order data */
    int       out_image_height;	    /* Number of rows in image */
    int       out_image_width;		/* Number of columns in image */
    char     *image_buffer;
    char     *image_ptr;
    DWORD     image_width; 
    DWORD     image_height; 
    DWORD     image_depth;  
} CIMAGEOBJECT, *LPCIMAGEOBJECT;


typedef DWORD (WINAPI *CREATEIMAGEOBJECT)(LPCIMAGEOBJECT &pImageOpject);
extern DWORD WINAPI CreateImageObject(LPCIMAGEOBJECT &pImageOpject);

#else   //__cplusplus==0

typedef struct CImageObject
{
    struct  CImageObjectVtbl FAR *lpVtbl;
} CIMAGEOBJECT, *LPCIMAGEOBJECT;

struct  CImageObjectVtbl {
    void    (WINAPI *CompressJPEG)(LPCIMAGEOBJECT, void *pAddr, DWORD dwWidth, DWORD dwHeight, char * filename);
    void    (WINAPI *GetJPEGInfoFile)(LPCIMAGEOBJECT, char * filename, DWORD *pWidth, DWORD *pHeight, DWORD *pBPP);
    void    (WINAPI *GetJPEGInfo)(LPCIMAGEOBJECT, char *pcBuffer, int nLength, DWORD *pWidth, DWORD *pHeight, DWORD *pBPP);
    DWORD   (WINAPI *SetJPEGParameters)(LPCIMAGEOBJECT, JPEGPARAMETERTYPE type, DWORD value);
    void    (WINAPI *DecompressJPEGFile)(LPCIMAGEOBJECT, char * filename, SCANLINEPROCESS ScanlineProcess);
    void    (WINAPI *DecompressJPEG)(LPCIMAGEOBJECT, char *pcBuffer, int nLength, SCANLINEPROCESS ScanlineProcess);
    void    (WINAPI *GetImageParameters)(LPCIMAGEOBJECT, char **Start, char **Current, DWORD *Width, DWORD *Height, DWORD *BPP);
    DWORD   (WINAPI *DestroyImageObject)(LPCIMAGEOBJECT);
};


typedef DWORD (WINAPI *CREATEIMAGEOBJECT)(LPCIMAGEOBJECT *pImageOpject);
extern DWORD WINAPI CreateImageObject(LPCIMAGEOBJECT *pImageOpject);

#endif  //__cplusplus==0

#endif _NVIMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\nvrmarch.inc ===
;/*
;-----------------------------Module-Header-----------------------------;
; Module Name:  NVRMARCH.INC
;
;  Constants for interface to the Resource Manager
;
; Created: 6/12/98
; Author:  ARG
;
; Copyright (C) 1993,1998 NVidia Corporation. All Rights Reserved.
;
; History:
;-----------------------------------------------------------------------;

ifndef  NVRMARCH_INCLUDED
; This seems to break the stupid assembler in strange and mysterious
; ways.  It appears that this file is re-read on the second pass, or
; at least is reevaluated, which produces "phase errors" galore because
; the condition is now different.  This is not rocket science.
;NVRMARCH_INCLUDED       equ     1

comment ~  */

#ifndef NVRMARCH_INCLUDED
#define NVRMARCH_INCLUDED       1

/* ~


ORD_WEP                                 equ      1
ORD_NvSysDispatch                       equ      3
ORD_NvSysNotifyCallback                 equ      4
ORD_NvSysIpcCallback                    equ      5
ORD_NvSysClientExit                     equ      6
ORD_NVSysSetCursor                      equ      7
ORD_NvSysMoveCursor                     equ      8
ORD_NvSysGetScreenInfo                  equ      9
ORD_NvSysOpen                           equ      10
ORD_NvSysClose                          equ      11
ORD_NvSysGetRamInfo                     equ      12
ORD_NvSysSetCanvasRect                  equ      13
ORD_NvSysSetCanvasClip                  equ      14
ORD_NvSysInstallCallback                equ      15
ORD_NvSysAllocPages                     equ      16
ORD_NvSysFreePages                      equ      17
ORD_NvInstallCallback                   equ      22
ORD_NvSysGetBufferInfo                  equ      23
ORD_NvSysSetCanvas                      equ      24
ORD_NvConfigGet                         equ      25
ORD_NvConfigSet                         equ      26
ORD_NvConfigUpdate                      equ      27
ORD_NvConfigVersion                     equ      28
ORD_NvConfigVga                         equ      29
ORD_NvSysSetCanvasRegion                equ      30
ORD_NvSysSetCursorImage                 equ      35
ORD_NvSysMoveCursorMulti                equ      36
ORD_NvSysSetCursorImageMulti            equ      37
ORD_NvSysUpdateImageOffsetFormat        equ      38
ORD_DllEntryPoint                       equ      40
ORD_THK_ThunkData16                     equ      41
ORD_NvSysGetHardwarePointers            equ      50
ORD_NvDeviceBaseGet                     equ      51
ORD_NvDeviceLimitGet                    equ      52
ORD_NvDeviceSelectorGet                 equ      53
ORD_NvSysGetCurrentBufferFlatPointer    equ      54
ORD_NvSysSetColorCursor                 equ      70
ORD_NvSysShowHideCursor                 equ      71
ORD_NvSysGetCursorEmulatePosPointers    equ      72
ORD_NvSysFlushFifo                      equ      80
ORD_NvSysDisplayModeHook                equ      90
ORD_NvSysLockPages                      equ      100
ORD_NvSysUnlockPages                    equ      101
ORD_NvSysDriverConnect                  equ      102
ORD_NvSysDriverDisConnect               equ      103
ORD_NvSysClearScreen                    equ      200
ORD_NvSysRegisterDisplayDriver          equ      201
ORD_NvIoControl                         equ      299
ORD_Nv01Free                            equ      300
ORD_Nv01AllocRoot                       equ      301
ORD_Nv01AllocMemory                     equ      302
ORD_Nv01AllocContextDma                 equ      303
ORD_Nv01AllocChannelPio                 equ      304
ORD_Nv01AllocObject                     equ      305
ORD_Nv01AllocDevice                     equ      306
ORD_Nv03AllocChannelDma                 equ      307
ORD_Nv03DmaFlowControl                  equ      308
ORD_Nv01Interrupt                       equ      309
ORD_Nv01AllocEvent                      equ      310
ORD_NvI2CAccess                         equ      311
ORD_Nv04ConfigGetEx                     equ      312
ORD_Nv04ConfigSetEx                     equ      313
ORD_Nv04Alloc                           equ      314

; GDI and Video channel HANDLE definitions

NV_WIN_ROOT                                     equ             00002001h
NV_WIN_DEVICE                                   equ             00002002h
NV_WIN_CHANNEL                                  equ             00002003h

;
; GDI Context Dma Handles
;

NV_WIN_CONTEXT_DMA_TO_SYS_MEMORY                EQU             00001000h
NV_WIN_WB_CONTEXT_DMA_TO_VIDEO_MEMORY           EQU             00001002h
NV_WIN_WB_CONTEXT_DMA_TO_SYS_MEMORY             EQU             00001003h
NV_WIN_NOTIFIER_CONTEXT_DMA_TO_MEMORY           EQU             00001005h
NV_WIN_PUSHER_NOTIFIER_CONTEXT_DMA_TO_MEMORY    EQU             00001007h
NV_WIN_CONTEXT_DMA_IN_MEMORY                    EQU             00001010h
NV_WIN_CONTEXT_DMA_FROM_VIDEO_MEMORY            EQU             00001012h
NV_WIN_CONTEXT_DMA_FROM_MEMORY                  EQU             00001015h
NV_WIN_WB_CONTEXT_DMA_FROM_SYS_MEMORY           EQU             00001017h
NV_WIN_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT           EQU             00001020h
NV_WIN_WB_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT        EQU             00001022h

NV01_NULL_OBJECT                                equ             0

comment ~
*/

#define ORD_WEP                                  1
#define ORD_NvSysDispatch                        3
#define ORD_NvSysNotifyCallback                  4
#define ORD_NvSysIpcCallback                     5
#define ORD_NvSysClientExit                      6
#define ORD_NVSysSetCursor                       7
#define ORD_NvSysMoveCursor                      8
#define ORD_NvSysGetScreenInfo                   9
#define ORD_NvSysOpen                            10
#define ORD_NvSysClose                           11
#define ORD_NvSysGetRamInfo                      12
#define ORD_NvSysSetCanvasRect                   13
#define ORD_NvSysSetCanvasClip                   14
#define ORD_NvSysInstallCallback                 15
#define ORD_NvSysAllocPages                      16
#define ORD_NvSysFreePages                       17
#define ORD_NvInstallCallback                    22
#define ORD_NvSysGetBufferInfo                   23
#define ORD_NvSysSetCanvas                       24
#define ORD_NvConfigGet                          25
#define ORD_NvConfigSet                          26
#define ORD_NvConfigUpdate                       27
#define ORD_NvConfigVersion                      28
#define ORD_NvConfigVga                          29
#define ORD_NvSysSetCanvasRegion                 30
#define ORD_NvSysSetCursorImage                  35
#define ORD_DllEntryPoint                        40
#define ORD_THK_ThunkData16                      41
#define ORD_NvSysGetHardwarePointers             50
#define ORD_NvDeviceBaseGet                      51
#define ORD_NvDeviceLimitGet                     52
#define ORD_NvDeviceSelectorGet                  53
#define ORD_NvSysGetCurrentBufferFlatPointe      54
#define ORD_NvSysSetColorCursor                  70
#define ORD_NvSysShowHideCursor                  71
#define ORD_NvSysGetCursorEmulatePosPointer      72
#define ORD_NvSysFlushFifo                       80
#define ORD_NvSysDisplayModeHook                 90
#define ORD_NvSysLockPages                       100
#define ORD_NvSysUnlockPages                     101
#define ORD_NvSysDriverConnect                   102
#define ORD_NvSysDriverDisConnect                103
#define ORD_NvSysClearScreen                     200
#define ORD_NvIoControl                          299
#define ORD_Nv01Free                             300
#define ORD_Nv01AllocRoot                        301
#define ORD_Nv01AllocMemory                      302
#define ORD_Nv01AllocContextDma                  303
#define ORD_Nv01AllocChannelPio                  304
#define ORD_Nv01AllocObject                      305
#define ORD_Nv01AllocDevice                      306
#define ORD_Nv03AllocChannelDma                  307
#define ORD_Nv03DmaFlowControl                   308
#define ORD_Nv01Interrupt                        309
#define ORD_Nv01AllocEvent                       310
#define ORD_NvI2CAccess                          311


// GDI and Video channel HANDLE definitions

#define NV_WIN_ROOT                              0x00002001
#define NV_WIN_DEVICE                            0x00002002
#define NV_WIN_CHANNEL                           0x00002003

/* ~


;  funct NV01_ALLOC_ROOT parameters
ALLOC_ROOT_PARAM    STRUC           ;                   */ typedef struct {                 /*
    ALLOC_ROOT_hObjectNew   dd  ?   ; client handle ret */ unsigned long    hObjectNew;     /*
    ALLOC_ROOT_hClass       dd  ?   ;                   */ unsigned long    hClass;         /*
    ALLOC_ROOT_status       dd  ?   ;                   */ unsigned long    status;         /*
ALLOC_ROOT_PARAM    ENDS            ;                   */ } Alloc_Root_Param;              /*

; Neat-o! MASM 5.20 is only good for 31 characters on identifiers!
; Equates definitions must be unique before this point:
;                              |

ALLOC_ROOT_STATUS_SUCCESS                       equ     00000000h
ALLOC_ROOT_STATUS_ERROR_OPERATING_SYSTEM        equ     00000001h
ALLOC_ROOT_STATUS_ERROR_BAD_PARENT_OBJECT       equ     00000002h
ALLOC_ROOT_STATUS_ERROR_BAD_NEW_OBJECT          equ     00000003h
ALLOC_ROOT_STATUS_ERROR_BAD_CLASS               equ     00000004h
ALLOC_ROOT_STATUS_ERROR_INSUFFICIENT_RESOURCES  equ     00000005h

ALLOC_ROOT_CLASS_ROOT                           equ     00000000h

Nv01AllocRoot_MAC macro buffer,hClass
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClass
        mov     [bx].ALLOC_ROOT_hClass,edx
        mov     [bx].ALLOC_ROOT_status,ALLOC_ROOT_STATUS_SUCCESS
        cCall   Nv01AllocRoot
        pop     edx
endm

comment ~  */

#define ALLOC_ROOT_STATUS_SUCCESS                       0x00000000
#define ALLOC_ROOT_STATUS_ERROR_OPERATING_SYSTEM        0x00000001
#define ALLOC_ROOT_STATUS_ERROR_BAD_PARENT_OBJECT       0x00000002
#define ALLOC_ROOT_STATUS_ERROR_BAD_NEW_OBJECT          0x00000003
#define ALLOC_ROOT_STATUS_ERROR_BAD_CLASS               0x00000004
#define ALLOC_ROOT_STATUS_ERROR_INSUFFICIENT_RESOURCES  0x00000005

#define ALLOC_ROOT_CLASS_ROOT                           0x00000000

/* ~


NVOS21_STATUS_SUCCESS                           equ     00000000
NVOS21_STATUS_ERROR_OPERATING_SYSTEM            equ     00000001
NVOS21_STATUS_ERROR_BAD_ROOT                    equ     00000002
NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT           equ     00000003
NVOS21_STATUS_ERROR_BAD_OBJECT_NEW              equ     00000004
NVOS21_STATUS_ERROR_BAD_CLASS                   equ     00000005
NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES      equ     00000006

ALLOC_PARAM      STRUC
  ALLOC_hRoot                   dd      ?
  ALLOC_hObjectParent           dd      ?
  ALLOC_hObjectNew              dd      ?
  ALLOC_hClass                  dd      ?
  ALLOC_pAllocParms             dd      ?
  ALLOC_Null                    dd      0       
  ALLOC_status                  dd      ?
ALLOC_PARAM      ENDS

ALLOC_DEV_PARAM    STRUC            ;                   */ typedef struct {                 /*
    ALLOC_DEV_hObjectParent dd  ?   ; client handle     */ unsigned long    hObjectParent;  /*
    ALLOC_DEV_hObjectNew    dd  ?   ;                   */ unsigned long    hObjectNew;     /*
    ALLOC_DEV_hClass        dd  ?   ;                   */ unsigned long    hClass;         /*
    ALLOC_DEV_szName        dd  ?   ;                   */ unsigned long    szName;         /*
    ALLOC_DEV_status        dd  ?   ;                   */ unsigned long    status;         /*
ALLOC_DEV_PARAM    ENDS             ;                   */ } Alloc_Dev_Param;               /*

ALLOC_DEV_STATUS_SUCCESS                        equ     00000000h
ALLOC_DEV_STATUS_ERR_OPERATING_SYSTEM           equ     00000001h
ALLOC_DEV_STATUS_ERR_BAD_PARENT_OBJECT          equ     00000002h
ALLOC_DEV_STATUS_ERR_BAD_NEW_OBJECT             equ     00000003h
ALLOC_DEV_STATUS_ERR_BAD_CLASS                  equ     00000004h
ALLOC_DEV_STATUS_ERR_INSUFFICIENT_RESOURCES     equ     00000005h

Nv01AllocDevice_MAC macro buffer,hObjectParent,hObjectNew,hClass,szName
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_DEV_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_DEV_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_DEV_hClass, edx

        lea     ax, szName              ; Flatten the device name
        mov     dx, ds

        DPMI_Flatten

        shl     edx, 16
        mov     dx, ax

        lea     bx, buffer
        mov     [bx].ALLOC_DEV_szName, edx
        mov     [bx].ALLOC_DEV_status,ALLOC_DEV_STATUS_SUCCESS
        cCall   Nv01AllocDevice
        pop     edx
endm

; THE C-EQUIVALENTS OF THESE DEFINITIONS ARE FOUND IN NV32.H
; KEEP THEM IN SYNC!
NV01_DEVICE_0                                   equ     00000080h
NV01_DEVICE_1                                   equ     00000081h
NV01_DEVICE_2                                   equ     00000082h
NV01_DEVICE_3                                   equ     00000083h
NV01_DEVICE_4                                   equ     00000084h
NV01_DEVICE_5                                   equ     00000085h
NV01_DEVICE_6                                   equ     00000086h
NV01_DEVICE_7                                   equ     00000087h
NV01_CONTEXT_DMA                                equ     00000002h
NV01_CONTEXT_DMA_FROM_MEMORY                    equ     00000002h
NV01_CONTEXT_DMA_TO_MEMORY                      equ     00000003h
NV01_CONTEXT_DMA_IN_MEMORY                      equ     0000003Dh
NV01_CONTEXT_ERROR_TO_MEMORY                    equ     0000003Eh
NV03_CHANNEL_PIO                                equ     0000006Ah
NV03_CHANNEL_DMA                                equ     0000006Bh
NV04_CHANNEL_DMA                                equ     0000006Ch
NV01_MEMORY_SYSTEM                              equ     0000003Eh
NV01_MEMORY_LOCAL_PRIVILEGED                    equ     0000003Fh
NV01_MEMORY_LOCAL_USER                          equ     00000040h

comment ~  */

#define ALLOC_DEV_STATUS_SUCCESS                        0x00000000
#define ALLOC_DEV_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_DEV_STATUS_ERR_BAD_OBJECT_PARENT          0x00000002
#define ALLOC_DEV_STATUS_ERR_BAD_OBJECT_NEW             0x00000003
#define ALLOC_DEV_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_DEV_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000005

/* ~

ALLOC_MEMORY_PARAM     STRUC           ;               */ typedef struct {                 /*
    ALLOC_MEMORY_hObjectClient dd  ?   ; client handle */ unsigned long    hObjectClient;  /*
    ALLOC_MEMORY_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_MEMORY_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_MEMORY_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_MEMORY_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_MEMORY_pBase         dd  ?   ;               */ unsigned long    pBase;          /*
                               dd  ?   ;               */ unsigned long    pBase_high;     /*
    ALLOC_MEMORY_pLimit        dd  ?   ;               */ unsigned long    pLimit;         /*
                               dd  ?   ;               */ unsigned long    pLimit_high;    /*
    ALLOC_MEMORY_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_MEMORY_PARAM     ENDS            ;               */ } Alloc_Memory_Param;            /*

ALLOC_MEMORY_FLAGS_CONTIGUOUS_PHYSICALITY               equ 00000000h
ALLOC_MEMORY_FLAGS_NONCONTIGUOUS_PHYSICALITY            equ 00000010h

ALLOC_MEMORY_FLAGS_LOCATION_PCI                         equ 00000000h
ALLOC_MEMORY_FLAGS_LOCATION_AGP                         equ 00000100h

ALLOC_MEMORY_FLAGS_UNCACHED                             equ 00000000h
ALLOC_MEMORY_FLAGS_CACHED                               equ 00001000h
ALLOC_MEMORY_FLAGS_WRITE_COMBINE                        equ 00002000h
ALLOC_MEMORY_FLAGS_WRITE_THROUGH                        equ 00003000h
ALLOC_MEMORY_FLAGS_WRITE_PROTECT                        equ 00004000h
ALLOC_MEMORY_FLAGS_WRITE_BACK                           equ 00005000h

ALLOC_MEMORY_STATUS_SUCCESS                             equ 00000000h
ALLOC_MEMORY_STATUS_ERR_OPERATING_SYSTEM                equ 00000001h
ALLOC_MEMORY_STATUS_ERR_BAD_PARENT_OBJECT               equ 00000002h
ALLOC_MEMORY_STATUS_ERR_BAD_NEW_OBJECT                  equ 00000003h
ALLOC_MEMORY_STATUS_ERR_BAD_CLASS                       equ 00000004h
ALLOC_MEMORY_STATUS_ERR_BAD_FLAGS                       equ 00000005h
ALLOC_MEMORY_STATUS_ERR_INSUFFICIENT_RESOURCES          equ 00000006h

Nv01AllocMemory_MAC macro buffer,hObjectClient,hObjectParent,hObjectNew,hClass,flags,limit
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectClient
        mov     [bx].ALLOC_MEMORY_hObjectClient,edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_MEMORY_hObjectParent,edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_MEMORY_hObjectNew,edx
        mov     edx, hClass
        mov     [bx].ALLOC_MEMORY_hClass,edx
        mov     edx, flags
        mov     [bx].ALLOC_MEMORY_flags,edx
        mov     dword ptr [bx].ALLOC_MEMORY_pBase, 0
        mov     dword ptr [bx].ALLOC_MEMORY_pBase+4, 0
        mov     edx, limit
        mov     [bx].ALLOC_MEMORY_pLimit,edx
        mov     dword ptr [bx].ALLOC_MEMORY_pLimit+4, 0
        mov     [bx].ALLOC_MEMORY_status,ALLOC_MEMORY_STATUS_SUCCESS
        cCall   Nv01AllocMemory
        pop     edx
endm

comment ~  */

#define ALLOC_MEMORY_FLAGS_CONTIGUOUS_PHYSICALITY               0x00000000
#define ALLOC_MEMORY_FLAGS_NONCONTIGUOUS_PHYSICALITY            0x00000010

#define ALLOC_MEMORY_FLAGS_LOCATION_PCI                         0x00000000
#define ALLOC_MEMORY_FLAGS_LOCATION_AGP                         0x00000100

#define ALLOC_MEMORY_FLAGS_UNCACHED                             0x00000000
#define ALLOC_MEMORY_FLAGS_CACHED                               0x00001000
#define ALLOC_MEMORY_FLAGS_WRITE_COMBINE                        0x00002000
#define ALLOC_MEMORY_FLAGS_WRITE_THROUGH                        0x00003000
#define ALLOC_MEMORY_FLAGS_WRITE_PROTECT                        0x00004000
#define ALLOC_MEMORY_FLAGS_WRITE_BACK                           0x00005000

#define ALLOC_MEMORY_STATUS_SUCCESS                             0x00000000
#define ALLOC_MEMORY_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define ALLOC_MEMORY_STATUS_ERR_BAD_PARENT_OBJECT               0x00000002
#define ALLOC_MEMORY_STATUS_ERR_BAD_NEW_OBJECT                  0x00000003
#define ALLOC_MEMORY_STATUS_ERR_BAD_CLASS                       0x00000004
#define ALLOC_MEMORY_STATUS_ERR_BAD_FLAGS                       0x00000005
#define ALLOC_MEMORY_STATUS_ERR_INSUFFICIENT_RESOURCES          0x00000006

/* ~

ALLOC_CTX_DMA_PARAM    STRUC            ;               */ typedef struct {                 /*
    ALLOC_CTX_DMA_hObjectParent dd  ?   ; client handle */ unsigned long    hObjectParent;  /*
    ALLOC_CTX_DMA_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CTX_DMA_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CTX_DMA_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_CTX_DMA_pBase         dd  ?   ;               */ unsigned long    pBase;          /*
                                dd  ?   ;               */ unsigned long    pBase_high;     /*
    ALLOC_CTX_DMA_limit         dd  ?   ;               */ unsigned long    limit;          /*
                                dd  ?   ;               */ unsigned long    limit_high;     /*
    ALLOC_CTX_DMA_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CTX_DMA_PARAM    ENDS             ;               */ } Alloc_Ctx_DMA_Param;           /*

ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR                        equ 00000000h
ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY                    equ 00000001h
ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY                   equ 00000002h

ALLOC_CTX_DMA_FLAGS_CONTIGUOUS_PHYSICALITY              equ 00000000h
ALLOC_CTX_DMA_FLAGS_NONCONTIGUOUS_PHYSICALITY           equ 00000010h

ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS                       equ 00000000h
ALLOC_CTX_DMA_FLAGS_LOCKED_IN_TRANSIT                   equ 00000100h

ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED                  equ 00000000h
ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED                    equ 00001000h

ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED                       equ ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS + ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED

ALLOC_CTX_DMA_STATUS_SUCCESS                            equ 00000000h
ALLOC_CTX_DMA_STATUS_ERR_OPERATING_SYSTEM               equ 00000001h
ALLOC_CTX_DMA_STATUS_ERR_BAD_PARENT_OBJECT              equ 00000002h
ALLOC_CTX_DMA_STATUS_ERR_BAD_NEW_OBJECT                 equ 00000003h
ALLOC_CTX_DMA_STATUS_ERR_BAD_CLASS                      equ 00000004h
ALLOC_CTX_DMA_STATUS_ERR_BAD_FLAGS                      equ 00000005h
ALLOC_CTX_DMA_STATUS_ERR_BAD_BASE                       equ 00000006h
ALLOC_CTX_DMA_STATUS_ERR_BAD_LIMIT                      equ 00000007h
ALLOC_CTX_DMA_STATUS_ERR_PROTECTION_FAULT               equ 00000008h
ALLOC_CTX_DMA_STATUS_ERR_MULTIPLE_MEMORY_TYPES          equ 00000009h
ALLOC_CTX_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES         equ 0000000ah

Nv01AllocContextDma_MAC macro buffer,hObjectParent,hObjectNew,hClass,flags,sel,pBase,limit
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CTX_DMA_hObjectParent,edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CTX_DMA_hObjectNew,edx
        mov     edx, hClass
        mov     [bx].ALLOC_CTX_DMA_hClass,edx
        mov     edx, flags
        mov     [bx].ALLOC_CTX_DMA_flags,edx
        mov     edx, pBase
        mov     [bx].ALLOC_CTX_DMA_pBase,edx
        mov     dx, sel
        mov     word ptr [bx].ALLOC_CTX_DMA_pBase+4, dx
        mov     word ptr [bx].ALLOC_CTX_DMA_pBase+6, 0
        mov     edx, limit
        mov     [bx].ALLOC_CTX_DMA_limit,edx
        mov     dword ptr [bx].ALLOC_CTX_DMA_limit+4, 0
        mov     [bx].ALLOC_CTX_DMA_status,ALLOC_CTX_DMA_STATUS_SUCCESS
        cCall   Nv01AllocContextDma
        pop     edx
endm

comment ~  */

#define ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR                    0x00000000
#define ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY                0x00000001
#define ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY               0x00000002

#define ALLOC_CTX_DMA_FLAGS_CONTIGUOUS_PHYSICALITY          0x00000000
#define ALLOC_CTX_DMA_FLAGS_NONCONTIGUOUS_PHYSICALITY       0x00000010

#define ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS                   0x00000000
#define ALLOC_CTX_DMA_FLAGS_LOCKED_IN_TRANSIT               0x00000100

#define ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED              0x00000000
#define ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED                0x00001000

#define ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED                   ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS + ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED

#define ALLOC_CTX_DMA_STATUS_SUCCESS                        0x00000000
#define ALLOC_CTX_DMA_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_PARENT_OBJECT          0x00000002
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_NEW_OBJECT             0x00000003
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_FLAGS                  0x00000005
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_BASE                   0x00000006
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_LIMIT                  0x00000007
#define ALLOC_CTX_DMA_STATUS_ERR_PROTECTION_FAULT           0x00000008
#define ALLOC_CTX_DMA_STATUS_ERR_MULTIPLE_MEMORY_TYPES      0x00000009
#define ALLOC_CTX_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES     0x0000000a

/* ~

ALLOC_CHL_PIO_PARAM    STRUC            ;               */ typedef struct {                 /*
    ALLOC_CHL_PIO_hClient       dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_CHL_PIO_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_CHL_PIO_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CHL_PIO_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CHL_PIO_hObjectError  dd  ?   ;               */ unsigned long    hObjectError;   /*
    ALLOC_CHL_PIO_pChannel      dd  ?   ;               */ unsigned long    pChannel;       /*
                                dd  ?   ;               */ unsigned long    pChannel_high;  /*
    ALLOC_CHL_PIO_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_CHL_PIO_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CHL_PIO_PARAM    ENDS             ;               */ } Alloc_Chl_PIO_Param;           /*

ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT                  equ 00000000h
ALLOC_CHL_PIO_FLAGS_FIFO_ERROR_RUNOUT                   equ 00000001h

ALLOC_CHL_PIO_STATUS_SUCCESS                            equ 00000000h
ALLOC_CHL_PIO_STATUS_ERR_OPERATING_SYSTEM               equ 00000001h
ALLOC_CHL_PIO_STATUS_ERR_BAD_PARENT_OBJECT              equ 00000002h
ALLOC_CHL_PIO_STATUS_ERR_BAD_NEW_OBJECT                 equ 00000003h
ALLOC_CHL_PIO_STATUS_ERR_BAD_CLASS                      equ 00000004h
ALLOC_CHL_PIO_STATUS_ERR_BAD_OBJECT_ERROR               equ 00000005h
ALLOC_CHL_PIO_STATUS_ERR_BAD_FLAGS                      equ 00000006h
ALLOC_CHL_PIO_STATUS_ERR_INSUFFICIENT_RESOURCES         equ 00000007h

Nv01AllocChannelPio_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass,hObjectError,flags
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClient
        mov     [bx].ALLOC_CHL_PIO_hClient, edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CHL_PIO_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CHL_PIO_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_CHL_PIO_hClass, edx
        mov     edx, hObjectError
        mov     [bx].ALLOC_CHL_PIO_hObjectError, edx
        mov     dword ptr [bx].ALLOC_CHL_PIO_pChannel, 0
        mov     dword ptr [bx].ALLOC_CHL_PIO_pChannel+4, 0
        mov     edx, flags
        mov     [bx].ALLOC_CHL_PIO_flags,edx
        mov     [bx].ALLOC_CHL_PIO_status,ALLOC_CHL_PIO_STATUS_SUCCESS
        cCall   Nv01AllocChannelPio
        pop     edx
endm

comment ~  */

#define ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT              0x00000000
#define ALLOC_CHL_PIO_FLAGS_FIFO_ERROR_RUNOUT               0x00000001

#define ALLOC_CHL_PIO_STATUS_SUCCESS                        0x00000000
#define ALLOC_CHL_PIO_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_PARENT_OBJECT          0x00000002
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_NEW_OBJECT             0x00000003
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_OBJECT_ERROR           0x00000005
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_FLAGS                  0x00000006
#define ALLOC_CHL_PIO_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000007

/* ~
;  funct NV03_ALLOC_CHANNEL_DMA parameters
ALLOC_CHL_DMA_PARAM STRUC                           ;               */ typedef struct {                 /*
    ALLOC_CHL_DMA_hClient       dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_CHL_DMA_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_CHL_DMA_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CHL_DMA_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CHL_DMA_hObjectError  dd  ?   ;               */ unsigned long    hObjectError;   /*
    ALLOC_CHL_DMA_hObjectBuffer dd  ?   ;               */ unsigned long    hObjectBuffer;  /*
    ALLOC_CHL_DMA_offset        dd  ?   ;               */ unsigned long    offset;         /*
    ALLOC_CHL_DMA_pControl      dd  ?   ;               */ unsigned long    pControl;       /*
                                dd  ?   ;               */ unsigned long    pControl_high;  /*
    ALLOC_CHL_DMA_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CHL_DMA_PARAM ENDS                                ;               */ } Alloc_Chl_DMA_Param;           /*

ALLOC_CHL_DMA_STATUS_SUCCESS                         equ        00000000h
ALLOC_CHL_DMA_STATUS_ERR_OPERATING_SYSTEM            equ        00000001h
ALLOC_CHL_DMA_STATUS_ERR_BAD_PARENT_OBJECT           equ        00000002h
ALLOC_CHL_DMA_STATUS_ERR_BAD_NEW_OBJECT              equ        00000003h
ALLOC_CHL_DMA_STATUS_ERR_BAD_CLASS                   equ        00000004h
ALLOC_CHL_DMA_STATUS_ERR_BAD_ERROR_OBJECT            equ        00000005h
ALLOC_CHL_DMA_STATUS_ERR_BAD_BUFFRE_OBJECT           equ        00000006h
ALLOC_CHL_DMA_STATUS_ERR_BAD_OFFSET                  equ        00000007h
ALLOC_CHL_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES      equ        00000008h

Nv03AllocChannelDma_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass,hObjectError,hObjectBuffer,offset
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClient
        mov     [bx].ALLOC_CHL_DMA_hClient, edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CHL_DMA_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CHL_DMA_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_CHL_DMA_hClass, edx
        mov     edx, hObjectError
        mov     [bx].ALLOC_CHL_DMA_hObjectError, edx
        mov     edx, hObjectBuffer
        mov     [bx].ALLOC_CHL_DMA_hObjectBuffer, edx
        mov     edx, offset
        mov     [bx].ALLOC_CHL_DMA_offset, edx
        mov     dword ptr [bx].ALLOC_CHL_DMA_pControl, 0
        mov     dword ptr [bx].ALLOC_CHL_DMA_pControl+4, 0
        mov     [bx].ALLOC_CHL_DMA_status,0
        cCall   Nv03AllocChannelDma
        pop     edx
endm

comment ~  */

#define ALLOC_CHL_DMA_STATUS_SUCCESS                        0x00000000
#define ALLOC_CHL_DMA_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_PARENT          0x00000002
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_NEW             0x00000003
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_ERROR           0x00000005
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_BUFFER          0x00000006
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OFFSET                 0x00000007
#define ALLOC_CHL_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000008

/* ~

NV01FREE_PARAM    STRUC                 ;               */ typedef struct {                 /*
    NV01FREE_hClient            dd  ?   ;               */ unsigned long    hClient;        /*
    NV01FREE_hObjectParent      dd  ?   ;               */ unsigned long    hObjectParent;  /*
    NV01FREE_hObjectOld         dd  ?   ;               */ unsigned long    hObjectOld;     /*
    NV01FREE_status             dd  ?   ;               */ unsigned long    status;         /*
NV01FREE_PARAM    ENDS                  ;               */ } NV01Free_Param;                /*

NV01FREE_STATUS_SUCCESS                                 equ 00000000h
NV01FREE_STATUS_ERR_OPERATING_SYSTEM                    equ 00000001h
NV01FREE_STATUS_ERR_BAD_PARENT_OBJECT                   equ 00000002h
NV01FREE_STATUS_ERR_BAD_OLD_OBJECT                      equ 00000003h
NV01FREE_STATUS_ERR_OBJECT_IN_USE                       equ 00000004h
NV01FREE_STATUS_ERR_OBJECT_HAS_CHILDERN                 equ 00000005h

Nv01Free_MAC macro buffer,hClient,hObjectParent,hObjectOld
          push  edx
          push  ds
          lea   bx, buffer
          push  bx
          mov   edx, hClient
          mov   [bx].NV01FREE_hClient, edx
          mov   edx, hObjectParent
          mov   [bx].NV01FREE_hObjectParent, edx
          mov   edx, hObjectOld
          mov   [bx].NV01FREE_hObjectOld, edx
          mov   [bx].NV01FREE_status, NV01FREE_STATUS_SUCCESS
          cCall Nv01Free
          pop   edx
endm

comment ~  */


#define NV01FREE_STATUS_SUCCESS                             0x00000000
#define NV01FREE_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define NV01FREE_STATUS_ERR_BAD_OBJECT_PARENT               0x00000002
#define NV01FREE_STATUS_ERR_BAD_OBJECT_OLD                  0x00000003
#define NV01FREE_STATUS_ERR_OBJECT_IN_USE                   0x00000004
#define NV01FREE_STATUS_ERR_OBJECT_HAS_CHILDERN             0x00000005

/* ~

ALLOC_OBJECT_PARAM        STRUC            ;               */ typedef struct {                 /*
    ALLOC_OBJECT_hClient           dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_OBJECT_hObjectParent     dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_OBJECT_hObjectNew        dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_OBJECT_hClass            dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_OBJECT_status            dd  ?   ;               */ unsigned long    status;         /*
ALLOC_OBJECT_PARAM        ENDS             ;               */ } AllocObject_Param;        /*

ALLOC_OBJ_STATUS_SUCCESS                                 equ 00000000h
ALLOC_OBJ_STATUS_ERR_OPERATING_SYSTEM                    equ 00000001h
ALLOC_OBJ_STATUS_ERR_BAD_PARENT_OBJECT                   equ 00000002h
ALLOC_OBJ_STATUS_ERR_BAD_NEW_OBJECT                      equ 00000003h
ALLOC_OBJ_STATUS_ERR_BAD_CLASS                           equ 00000004h
ALLOC_OBJ_STATUS_ERR_INSUFFICIENT_RESOURCES              equ 00000005h

Nv01AllocObject_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass
          push  edx
          push  ds
          lea   bx, buffer
          push  bx
          mov   edx, hClient
          mov   [bx].ALLOC_OBJECT_hClient, edx
          mov   edx, hObjectParent
          mov   [bx].ALLOC_OBJECT_hObjectParent, edx
          mov   edx, hObjectNew
          mov   [bx].ALLOC_OBJECT_hObjectNew, edx
          mov   edx, hClass
          mov   [bx].ALLOC_OBJECT_hClass, edx
          mov   [bx].ALLOC_OBJECT_status, ALLOC_OBJ_STATUS_SUCCESS
          cCall Nv01AllocObject
          pop   edx
endm

comment ~  */


#define ALLOC_OBJ_STATUS_SUCCESS                             0x00000000
#define ALLOC_OBJ_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define ALLOC_OBJ_STATUS_ERR_BAD_OBJECT_PARENT               0x00000002
#define ALLOC_OBJ_STATUS_ERR_BAD_OBJECT_OLD                  0x00000003
#define ALLOC_OBJ_STATUS_ERR_BAD_CLASS                       0x00000004
#define ALLOC_OBJ_STATUS_ERR_INSUFFICIENT_RESOURCES          0x00000005

/* ~

NVIOCONTROL_PARAM   STRUC               ;               */ typedef struct {                 /*
    NVIOCONTROL_hRoot           dd  ?   ;               */ unsigned long    hRoot;          /*
    NVIOCONTROL_hObjectParent   dd  ?   ;               */ unsigned long    hObjectParent;  /*
    NVIOCONTROL_function        dd  ?   ;               */ unsigned long    function;       /*
    NVIOCONTROL_owner           dd  ?   ;               */ unsigned long    owner;          /*
    NVIOCONTROL_type            dd  ?   ;               */ unsigned long    type;           /*
    NVIOCONTROL_depth           dd  ?   ;               */ unsigned long    depth;          /*
    NVIOCONTROL_width           dd  ?   ;               */ unsigned long    width;          /*
    NVIOCONTROL_height          dd  ?   ;               */ unsigned long    height;         /*
    NVIOCONTROL_pitch           dd  ?   ;               */ unsigned long    pitch;          /*
    NVIOCONTROL_offset          dd  ?   ;               */ unsigned long    offset;         /*
    NVIOCONTROL_size            dd  ?   ;               */ unsigned long    size;           /*
    NVIOCONTROL_address         dd  ?   ;               */ unsigned long    address;        /*
    NVIOCONTROL_limit           dd  ?   ;               */ unsigned long    limit;          /*
    NVIOCONTROL_total           dd  ?   ;               */ unsigned long    total;          /*
    NVIOCONTROL_free            dd  ?   ;               */ unsigned long    free;           /*
    NVIOCONTROL_status          dd  ?   ;               */ unsigned long    status;         /*
NVIOCONTROL_PARAM   ENDS                ;               */ } NVIOControl_Param;             /*

NVIOCONTROL_ARCH_HEAP                                   equ 0000000Bh

NVIOCONTROL_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT               equ 1
NVIOCONTROL_HEAP_ALLOC_SIZE                             equ 2
NVIOCONTROL_HEAP_FREE                                   equ 3
NVIOCONTROL_HEAP_PURGE                                  equ 4
NVIOCONTROL_HEAP_INFO                                   equ 5
NVIOCONTROL_HEAP_ALLOC_TILED_PITCH_HEIGHT               equ 6
NVIOCONTROL_HEAP_DESTROY                                equ 7
NVIOCONTROL_HEAP_INFO_FREE_BLOCKS                       equ 8
NVIOCONTROL_TYPE_IMAGE                                  equ 0
NVIOCONTROL_TYPE_DEPTH                                  equ 1
NVIOCONTROL_TYPE_TEXTURE                                equ 2
NVIOCONTROL_TYPE_VIDEO_OVERLAY                          equ 3
NVIOCONTROL_TYPE_FONT                                   equ 4
NVIOCONTROL_TYPE_CURSOR                                 equ 5
NVIOCONTROL_TYPE_DMA                                    equ 6
NVIOCONTROL_TYPE_INSTANCE                               equ 7
NVIOCONTROL_TYPE_PRIMARY                                equ 8
NVIOCONTROL_STATUS_SUCCESS                              equ 00000000h
NVIOCONTROL_STATUS_ERR_INSUFFICIENT_RESOURCES           equ 00000001h
NVIOCONTROL_STATUS_ERR_FUNCTION_INVALID                 equ 00000002h
NVIOCONTROL_STATUS_ERR_OWNER_INVALID                    equ 00000003h

comment ~  */

#define NVIOCONTROL_ARCH_HEAP                               (0x0000000B)

#define NVIOCONTROL_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT           1
#define NVIOCONTROL_HEAP_ALLOC_SIZE                         2
#define NVIOCONTROL_HEAP_FREE                               3
#define NVIOCONTROL_HEAP_PURGE                              4
#define NVIOCONTROL_HEAP_INFO                               5
#define NVIOCONTROL_HEAP_ALLOC_TILED_PITCH_HEIGHT           6
#define NVIOCONTROL_TYPE_IMAGE                              0
#define NVIOCONTROL_TYPE_DEPTH                              1
#define NVIOCONTROL_TYPE_TEXTURE                            2
#define NVIOCONTROL_TYPE_VIDEO_OVERLAY                      3
#define NVIOCONTROL_TYPE_FONT                               4
#define NVIOCONTROL_TYPE_CURSOR                             5
#define NVIOCONTROL_TYPE_DMA                                6
#define NVIOCONTROL_TYPE_INSTANCE                           7
#define NVIOCONTROL_TYPE_PRIMARY                            8
#define NVIOCONTROL_STATUS_SUCCESS                          (0x00000000)
#define NVIOCONTROL_STATUS_ERR_INSUFFICIENT_RESOURCES       (0x00000001)
#define NVIOCONTROL_STATUS_ERR_FUNCTION_INVALID             (0x00000002)
#define NVIOCONTROL_STATUS_ERR_OWNER_INVALID                (0x00000003)


/* ~

; This must be identical to what is NVRMWIN.H - 
; it would be nice if we could use this definition only.

_def_rmParams   STRUC                   ;       */      typedef struct _def_rmParams {      /*
    RegEAX              dd      ?       ;       */          unsigned long    RegEAX;        /*
    RegEBX              dd      ?       ;       */          unsigned long    RegEBX;        /*
    RegECX              dd      ?       ;       */          unsigned long    RegECX;        /*
    RegEDX              dd      ?       ;       */          unsigned long    RegEDX;        /*
    RegEDI              dd      ?       ;       */          unsigned long    RegEDI;        /*
    RegESI              dd      ?       ;       */          unsigned long    RegESI;        /*
    RegES               dd      ?       ;       */          unsigned long    RegES;         /*
    RegDS               dd      ?       ;       */          unsigned long    RegDS;         /*
    RegCS               dd      ?       ;       */          unsigned long    RegCS;         /*
_def_rmParams   ENDS                    ;       */      } RMPARAMS, *PRMPARAMS;             /*

RMPARAMS        TYPEDEF         _def_rmParams
PRMPARAMS       TYPEDEF         PTR _def_rmParams

comment ~  */

/* ~
comment ~  */

/* ~
comment ~  */

#endif  // NVRMARCH_INCLUDED
/* ~

endif   ; NVRMARCH_INCLUDED

;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\nvRmApi.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvRmApi.h
 *
 * NVidia resource manager API header file exported to drivers.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#include <nvos.h>

#ifdef NV_ICD_NT
#define NvRmAlloc NvRmAllocNt
#define NvRmAllocRoot NvRmAllocRootNt
#define NvRmAllocDevice NvRmAllocDeviceNt
#define NvRmAllocContextDma NvRmAllocContextDmaNt
#define NvRmAllocChannelPio NvRmAllocChannelPioNt
#define NvRmAllocChannelDma NvRmAllocChannelDmaNt
#define NvRmAllocMemory NvRmAllocMemoryNt
#define NvRmAllocObject NvRmAllocObjectNt
#define NvRmAllocEvent NvRmAllocEventNt
#define NvRmFree NvRmFreeNt
#define NvRmArchHeap NvRmArchHeapNt
#define NvRmConfigGet NvRmConfigGetNt
#define NvRmConfigGetEx NvRmConfigGetExNt
ULONG  NvRmAllocNt(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  NvRmAllocRootNt(ULONG *phClient);
ULONG  NvRmAllocDeviceNt(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  NvRmAllocContextDmaNt(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  NvRmAllocChannelDmaNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  NvRmAllocMemoryNt(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  NvRmAllocObjectNt(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  NvRmAllocEventNt(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, ULONG index, PVOID hEvent);
ULONG  NvRmFreeNt(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG  NvRmArchHeapNt(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type, ULONG height, ULONG size,
ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG  NvRmConfigGetNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NvRmConfigGetExNt(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
#else /* NV_ICD_NT */
#ifndef WINNT
HANDLE NV_APIENTRY NvRmOpen(VOID);
VOID   NV_APIENTRY NvRmClose(VOID);
ULONG  NV_APIENTRY NvRmAlloc(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  NV_APIENTRY NvRmAllocRoot(ULONG *phClient);
ULONG  NV_APIENTRY NvRmAllocDevice(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  NV_APIENTRY NvRmAllocContextDma(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  NV_APIENTRY NvRmAllocChannelPio(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG  NV_APIENTRY NvRmAllocChannelDma(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  NV_APIENTRY NvRmAllocMemory(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  NV_APIENTRY NvRmAllocObject(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  NV_APIENTRY NvRmFree(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG  NV_APIENTRY Nv3RmGetDmaPushInfo(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG  NV_APIENTRY NvRmAllocEvent(ULONG hClient, ULONG hParent, ULONG object, ULONG hClass, ULONG hIndex, PVOID hEvent);
ULONG  NV_APIENTRY NvRmArchHeap(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type, ULONG height, ULONG size,
                              ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG  NV_APIENTRY NvRmConfigVersion(ULONG hClient, ULONG hDevice, ULONG *pVersion);
ULONG  NV_APIENTRY NvRmConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NV_APIENTRY NvRmConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG  NV_APIENTRY NvRmConfigUpdate(ULONG hClient, ULONG hDevice, ULONG flags);
ULONG  NV_APIENTRY NvRmInterrupt(ULONG hClient, ULONG hDevice);
ULONG  NV_APIENTRY NvRmRing0Callback(ULONG hClient, ULONG hDevice, ULONG procAddr, ULONG param1, ULONG param2);
ULONG  NV_APIENTRY NvRmConfigSetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmConfigGetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmI2CAccess(ULONG hClient, ULONG hDevice, VOID * ctrlStructPtr );
ULONG  NV_APIENTRY NvRmPowerManagement(ULONG hRoot, ULONG hDevice, ULONG head, ULONG command, VOID *paramStructPtr);
ULONG  NV_APIENTRY NvRmDebugControl(ULONG hRoot, ULONG command, VOID *pArgs);
ULONG  NV_APIENTRY NvRmIoFlush(VOID);
#ifdef LINUX
ULONG  NV_APIENTRY NvRmAGPInit(ULONG hClient, ULONG hDevice, ULONG agp_config);
ULONG  NV_APIENTRY NvRmAGPTeardown(ULONG hClient, ULONG hDevice);
#endif
ULONG  NV_APIENTRY NvRmAddSwapGroup(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG group_id); 
ULONG  NV_APIENTRY NvRmRemoveSwapGroup(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG grou_id);
ULONG  NV_APIENTRY NvRmAddSwapBarrier(ULONG group_id, ULONG barrier_id);
ULONG  NV_APIENTRY NvRmRemoveSwapBarrier(ULONG barrier_id);
#ifdef MACOS
ULONG  NV_APIENTRY NvRmOsConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NV_APIENTRY NvRmOsConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG  NV_APIENTRY NvRmOsConfigSetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmOsConfigGetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
#endif
#endif // #ifndef WINNT
#endif /* NV_ICD_NT */

/*
** The following was added to the OpenGL win 9x driver to perform client tracking.
** RM client tracking maintains a global list of OpenGL RM clients.  If the process
** that created the RM client is terminated using "stop debugging" then the RM
** client will be free and the resources (channel, video memory, etc) will be freed
** as well.  However, the resources are allocated until the next OpenGL process is
** run.  So they are not aviable for DirectDraw, GDI driver, or Direct3D.
*/
#if defined(__GL_ICD) && defined(_WIN32) && !defined(_WIN64) && !defined(NV_ICD_NT)
#undef NvRmAllocRoot
#undef NvRmFree
#define NvRmAllocRoot win9x_NvRmAllocRoot
#define NvRmFree win9x_NvRmFree
ULONG  NV_APIENTRY win9x_NvRmAllocRoot(ULONG *phClient);
ULONG  NV_APIENTRY win9x_NvRmFree(ULONG hClient, ULONG hParent, ULONG hObject);
#endif /* defined(_WIN32) && !defined(_WIN64) && !defined(NV_ICD_NT) */

#ifdef __cplusplus
}
#endif //__cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\nvRmR0Api.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * NvRmR0Api.h
 *
 * NVidia resource manager API header file exported to drivers which are operating in Ring0
 *
 */

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

// NOTE NOTE NOTE
// Those functions which are commented out are not yet implemented for the Ring0 interface

//HANDLE __stdcall NvRmR0Open(VOID);
//VOID   __stdcall NvRmR0Close(VOID);
ULONG  __stdcall NvRmR0AllocRoot(ULONG *phClient);
ULONG  __stdcall NvRmR0AllocDevice(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  __stdcall NvRmR0AllocContextDma(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  __stdcall NvRmR0AllocChannelPio(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG  __stdcall NvRmR0AllocChannelDma(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  __stdcall NvRmR0AllocMemory(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  __stdcall NvRmR0AllocObject(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  __stdcall NvRmR0Alloc(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  __stdcall NvRmR0Free(ULONG hClient, ULONG hParent, ULONG hObject);
//ULONG  __stdcall Nv3RmR0GetDmaPushInfo(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG  __stdcall NvRmR0AllocEvent(ULONG hClient, ULONG hParent, ULONG object, ULONG hClass, ULONG hIndex, PVOID hEvent);
//ULONG  __stdcall NvRmR0ConfigVersion(ULONG hClient, ULONG hDevice, ULONG *pVersion);
//ULONG  __stdcall NvRmR0ConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
//ULONG  __stdcall NvRmR0ConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
//ULONG  __stdcall NvRmR0ConfigUpdate(ULONG hClient, ULONG hDevice, ULONG flags);
ULONG  __stdcall NvRmR0Interrupt(ULONG hClient, ULONG hDevice);
ULONG  __stdcall NvRmR0I2CAccess(ULONG hClient, ULONG hDevice, VOID* pCtrlStruct );

#ifdef __cplusplus
}
#endif //__cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\nvos.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

 

 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nvos.h>  defines the Operating System function and ioctl interfaces to  *|
|*  NVIDIA's Unified Media Architecture (TM).                                *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NVOS_INCLUDED
#define NVOS_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#include <nvtypes.h>

// local defines here
#define FILE_DEVICE_NV 		0x00008000
#define NV_IOCTL_FCT_BASE 	0x00000800

// Use these defines if you are opening the RM vxd or the minivdd using the
// CreateFile inetrface.
// NV3 Resource Manager VXDs
#define NV3_PRIMARY_MINIVDD     "\\\\.\\NV3.VXD"
#define NV3_SECONDARY_MINIVDD   "\\\\.\\NV3MINI2.VXD"
#define NV3_RESMAN_VXD          "\\\\.\\NV3RM.VXD"
// NV4/NV10 Resource Manager VXDs
#define NVX_PRIMARY_MINIVDD     "\\\\.\\NVMINI.VXD"
#define NVX_SECONDARY_MINIVDD   "\\\\.\\NVMINI2.VXD"
#define NVX_RESMAN_VXD          "\\\\.\\NVCORE.VXD"

// Use this define for the resman vxd name if you use the VXDLDR_LoadDevice
// interface.
#define VXDLDR_NV3_RESMAN_VXD_NAME "NV3RM.VXD"
#define VXDLDR_NVX_RESMAN_VXD_NAME "NVCORE.VXD"
#define VXDLDR_NVA_RESMAN_VXD_NAME "NVACORE.VXD"

#if defined(WIN32)
#if !defined(NV_APIENTRY)
#define NV_APIENTRY __stdcall
#ifndef APIENTRY
#define APIENTRY    NV_APIENTRY          // APIENTRY deprecated; use NV_APIENTRY
#endif
#define CAPI        NV_APIENTRY          // CAPI deprecated; use NV_APIENTRY
#endif
#if !defined(NV_FASTCALL)
#define NV_FASTCALL __fastcall
//#define FASTCALL    NV_FASTCALL          // FASTCALL deprecated; use NV_FASTCALL
#endif
#if !defined(NV_INLINE)
#define NV_INLINE __inline
#define INLINE      NV_INLINE            // INLINE deprecated; use NV_INLINE
#endif
#if !defined(NV_CDECLCALL)
#define NV_CDECLCALL __cdecl
#define CDECLCALL   NV_CDECLCALL         // CDECLCALL deprecated; use NV_CDECLCALL
#endif
#if !defined(NV_STDCALL)
#define NV_STDCALL __stdcall
#define STDCALL     NV_STDCALL           // STDCALL deprecated; use NV_STDCALL
#endif

#else /* ! defined(WIN32) */

#define NV_APIENTRY
#define NV_FASTCALL
#define NV_CDECLCALL
#define NV_STDCALL 
#ifdef __GNUC__
#define NV_INLINE     __inline__
#elif defined (macintosh)
#define NV_INLINE inline
#else
#define NV_INLINE
#endif

#endif  /* ! WIN32 */

#define NV_CAPI	NV_APIENTRY


 /***************************************************************************\
|*                              NV OS Functions                              *|
 \***************************************************************************/

/*
	Note:
		This version of the architecture has been changed to allow the 
		RM to return a client handle that will subsequently used to
		identify the client.  NvAllocRoot() returns the handle.  All
		other functions must specify this client handle. 

*/
/* macro NV01_FREE */
#define  NV01_FREE                                                 (0x00000000)

/* parameter values */
#define NVOS00_STATUS_SUCCESS                                      (0x00000000)
#define NVOS00_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS00_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS00_STATUS_ERROR_BAD_OBJECT_OLD                         (0x00000003)
#define NVOS00_STATUS_ERROR_OBJECT_IN_USE                          (0x00000004)
#define NVOS00_STATUS_ERROR_OBJECT_HAS_CHILDERN                    (0x00000005)


/* NT ioctl data structure */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectOld;
  NvV32 status;
} NVOS00_PARAMETERS;

/* macro NV01_ALLOC_ROOT */
#define  NV01_ALLOC_ROOT                                           (0x00000001)

/* status values */
#define NVOS01_STATUS_SUCCESS                                      (0x00000000)
#define NVOS01_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS01_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS01_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS01_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS01_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 status;
} NVOS01_PARAMETERS;

/* valid hClass values. */
#define  NV01_ROOT                                                 (0x00000000)
#define  NV01_ROOT_USER                                            (0x00000041)

/* macro NV01_ALLOC_MEMORY */
#define  NV01_ALLOC_MEMORY                                         (0x00000002)

/* parameter values */
#define NVOS02_FLAGS_PHYSICALITY                                   7:4
#define NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS                        (0x00000000)
#define NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS                     (0x00000001)
#define NVOS02_FLAGS_LOCATION                                      11:8
#define NVOS02_FLAGS_LOCATION_PCI                                  (0x00000000)
#define NVOS02_FLAGS_LOCATION_AGP                                  (0x00000001)
#define NVOS02_FLAGS_COHERENCY                                     15:12
#define NVOS02_FLAGS_COHERENCY_UNCACHED                            (0x00000000)
#define NVOS02_FLAGS_COHERENCY_CACHED                              (0x00000001)
#define NVOS02_FLAGS_COHERENCY_WRITE_COMBINE                       (0x00000002)
#define NVOS02_FLAGS_COHERENCY_WRITE_THROUGH                       (0x00000003)
#define NVOS02_FLAGS_COHERENCY_WRITE_PROTECT                       (0x00000004)
#define NVOS02_FLAGS_COHERENCY_WRITE_BACK                          (0x00000005)
#define NVOS02_STATUS_SUCCESS                                      (0x00000000)
#define NVOS02_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS02_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS02_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS02_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS02_STATUS_ERROR_BAD_FLAGS                              (0x00000005)
#define NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 flags;
  NvP64 pMemory;
  NvU64 pLimit;
  NvV32 status;
} NVOS02_PARAMETERS;

/* macro NV01_ALLOC_CONTEXT_DMA */
#define  NV01_ALLOC_CONTEXT_DMA                                    (0x00000003)

/* parameter values */
#define NVOS03_FLAGS_ACCESS                                        3:0
#define NVOS03_FLAGS_ACCESS_READ_WRITE                             (0x00000000)
#define NVOS03_FLAGS_ACCESS_READ_ONLY                              (0x00000001)
#define NVOS03_FLAGS_ACCESS_WRITE_ONLY                             (0x00000002)
#define NVOS03_FLAGS_PHYSICALITY                                   7:4
#define NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS                        (0x00000000)
#define NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS                     (0x00000001)
#define NVOS03_FLAGS_LOCKED                                        11:8
#define NVOS03_FLAGS_LOCKED_ALWAYS                                 (0x00000000)
#define NVOS03_FLAGS_LOCKED_IN_TRANSIT                             (0x00000001)
#define NVOS03_FLAGS_COHERENCY                                     31:12
#define NVOS03_FLAGS_COHERENCY_UNCACHED                            (0x00000000)
#define NVOS03_FLAGS_COHERENCY_CACHED                              (0x00000001)
#define NVOS03_STATUS_SUCCESS                                      (0x00000000)
#define NVOS03_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS03_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS03_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS03_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS03_STATUS_ERROR_BAD_FLAGS                              (0x00000005)
#define NVOS03_STATUS_ERROR_BAD_BASE                               (0x00000006)
#define NVOS03_STATUS_ERROR_BAD_LIMIT                              (0x00000007)
#define NVOS03_STATUS_ERROR_PROTECTION_FAULT                       (0x00000008)
#define NVOS03_STATUS_ERROR_MULTIPLE_MEMORY_TYPES                  (0x00000009)
#define NVOS03_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x0000000A)

/* parameters */
typedef struct
{
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 flags;
    NvP64 pBase;
    NvU64 limit;
    NvV32 status;
} NVOS03_PARAMETERS;

/* macro NV01_ALLOC_CHANNEL_PIO */
#define  NV01_ALLOC_CHANNEL_PIO                                    (0x00000004)

/* parameter values */
#define NVOS04_FLAGS_FIFO_RUNOUT_IGNORE                            (0x00000000)
#define NVOS04_FLAGS_FIFO_RUNOUT_ERROR                             (0x00000001)
#define NVOS04_STATUS_SUCCESS                                      (0x00000000)
#define NVOS04_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS04_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR                       (0x00000005)
#define NVOS04_STATUS_ERROR_BAD_FLAGS                              (0x00000006)
#define NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000007)

/* parameters */
typedef struct
{
    NvV32 hRoot;
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 hObjectError;
    NvP64 pChannel;
    NvV32 flags;
    NvV32 status;
} NVOS04_PARAMETERS;

/* macro NV01_ALLOC_OBJECT */
#define  NV01_ALLOC_OBJECT                                         (0x00000005)

/* parameter values */
#define NVOS05_STATUS_SUCCESS                                      (0x00000000)
#define NVOS05_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS05_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS05_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS05_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS05_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 status;
} NVOS05_PARAMETERS;

// ***** this has been changed to allow a device name string to be returned
/* macro NV01_ALLOC_DEVICE */
#define  NV01_ALLOC_DEVICE                                         (0x00000006)

/* parameter values */
#define NVOS06_STATUS_SUCCESS                                      (0x00000000)
#define NVOS06_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS06_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS06_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
#if defined(NVRM_64)
    NvP64 szName;
#else
    NvV32 szName;
#endif
    NvV32 status;
} NVOS06_PARAMETERS;

/* macro NV03_ALLOC_CHANNEL_DMA */
#define  NV03_ALLOC_CHANNEL_DMA                                    (0x00000007)

/* parameter values */
#define NVOS07_STATUS_SUCCESS                                      (0x00000000)
#define NVOS07_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS07_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_ERROR                       (0x00000005)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_BUFFER                      (0x00000006)
#define NVOS07_STATUS_ERROR_BAD_OFFSET                             (0x00000007)
#define NVOS07_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000008)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 hObjectError;
  NvV32 hObjectBuffer;
  NvU32 offset;
  NvP64 pControl;
  NvV32 status;
} NVOS07_PARAMETERS;

/* macro NV03_DMA_FLOW_CONTROL */
#define  NV03_DMA_FLOW_CONTROL                                     (0x00000008)

/* parameter values */
#define NVOS08_FLAGS_PUT                                           3:0
#define NVOS08_FLAGS_PUT_IGNORE                                    (0x00000000)
#define NVOS08_FLAGS_PUT_UPDATE                                    (0x00000001)
#define NVOS08_FLAGS_JUMP                                          31:4
#define NVOS08_FLAGS_JUMP_IGNORE                                   (0x00000000)
#define NVOS08_FLAGS_JUMP_UPDATE                                   (0x00000001)
#define NVOS08_STATUS_SUCCESS                                      (0x00000000)
#define NVOS08_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS08_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS08_STATUS_ERROR_BAD_FLAGS                              (0x00000003)
#define NVOS08_STATUS_ERROR_BAD_PUT                                (0x00000004)

/* parameters */
typedef struct
{
  NvV32 hChannel;
  NvV32 flags;
  NvU32 put;
  NvU32 get;
  NvV32 status;
} NVOS08_PARAMETERS;

/* macro NV01_INTERRUPT */
#define  NV01_INTERRUPT                                            (0x00000009)

/* parameter values */
#define NVOS09_STATUS_SUCCESS                                      (0x00000000)
#define NVOS09_STATUS_ERROR_BAD_CLIENT                             (0x00000001)
#define NVOS09_STATUS_ERROR_BAD_DEVICE                             (0x00000002)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 status;
} NVOS09_PARAMETERS;

/* macro NV01_ALLOC_EVENT */
#define  NV01_ALLOC_EVENT                                          (0x0000000A)

/* parameter values */
#define NVOS10_STATUS_SUCCESS                                      (0x00000000)
#define NVOS10_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS10_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS10_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS10_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS10_STATUS_ERROR_BAD_INDEX                              (0x00000005)
#define NVOS10_STATUS_ERROR_BAD_EVENT                              (0x00000006)
#define NVOS10_STATUS_ERROR_OBJECT_IN_USE                          (0x00000007)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 index;
  NvU64 hEvent;
  NvV32 status;
} NVOS10_PARAMETERS;

/* Valid values for hClass in Nv01AllocEvent */
/* Note that NV01_EVENT_OS_EVENT is same as NV01_EVENT_WIN32_EVENT */
/* TODO: delete the WIN32 name */
#define  NV01_EVENT_KERNEL_CALLBACK                                (0x00000078)
#define  NV01_EVENT_OS_EVENT                                       (0x00000079)
#define  NV01_EVENT_WIN32_EVENT                                    NV01_EVENT_OS_EVENT

//
// There's some definite ugly reuse of args in NV01_ARCH_HEAP for the various
// functions. We'd like to rename field names when adding funcs, so the args
// go in the appropriate places.
//
// For example, adding HEAP_INFO_FREE_BLOCKS, should take offset/offset2 args,
// but because it's not a union and some of the drivers refer to their own typedef
// for the struct, we reuse field names that don't apply to the func.
//

/* funct NV03_HEAP */
#define  NV01_ARCH_HEAP                                            (0x0000000B)
/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvU32 function;
  NvU32 owner;
  NvU32 type;       /* holds 16bits of flags and 16bits of type */
  NvU32 depth;
  NvU32 width;
  NvU32 height;
  NvS32 pitch;
  NvU32 offset;     // for NVOS11_HEAP_INFO_FREE_BLOCKS, offset to be considered freed
  NvU32 size;       // for NVOS11_HEAP_INFO, size of largest free block
#if defined(NVRM_64)
  NvP64 address;    // for NVOS11_HEAP_INFO, base address of heap
#else
  NvU32 address;    // for NVOS11_HEAP_INFO, base address of heap
#endif
  NvU32 limit;      // for NVOS11_HEAP_INFO_FREE_BLOCKS, offset to be considered freed
  NvU32 total;
  NvU32 free;
  NvV32 status;
} NVOS11_PARAMETERS;
/* parameter values */
#define NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define NVOS11_HEAP_ALLOC_SIZE                      2
#define NVOS11_HEAP_FREE                            3
#define NVOS11_HEAP_PURGE                           4
#define NVOS11_HEAP_INFO                            5
#define NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT        6
#define NVOS11_HEAP_DESTROY                         7
#define NVOS11_HEAP_INFO_FREE_BLOCKS                8
#define NVOS11_TYPE_IMAGE                           0
#define NVOS11_TYPE_DEPTH                           1
#define NVOS11_TYPE_TEXTURE                         2
#define NVOS11_TYPE_VIDEO_OVERLAY                   3
#define NVOS11_TYPE_FONT                            4
#define NVOS11_TYPE_CURSOR                          5
#define NVOS11_TYPE_DMA                             6
#define NVOS11_TYPE_INSTANCE                        7
#define NVOS11_TYPE_PRIMARY                         8
#define NVOS11_TYPE_IMAGE_TILED                     9
#define NVOS11_TYPE_DEPTH_COMPR16                   10
#define NVOS11_TYPE_DEPTH_COMPR32                   11
#define NVOS11_TYPE_FLAGS                                31:16
#define NVOS11_TYPE_FLAGS_IGNORE_BANK_PLACEMENT     0x00000001
#define NVOS11_TYPE_FLAGS_FORCE_MEM_GROWS_UP        0x00000002
#define NVOS11_TYPE_FLAGS_FORCE_MEM_GROWS_DOWN      0x00000004
#define NVOS11_INVALID_BLOCK_FREE_OFFSET            0xFFFFFFFF
#define NVOS11_STATUS_SUCCESS                       (0x00000000)
#define NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES  (0x00000001)
#define NVOS11_STATUS_ERROR_INVALID_FUNCTION        (0x00000002)
#define NVOS11_STATUS_ERROR_INVALID_OWNER           (0x00000003)
#define NVOS11_STATUS_ERROR_INVALID_HEAP            (0x00000004)

/* function OS0C */
#define  NV01_CONFIG_VERSION                                       (0x0000000C)

/* parameter values */
#define NVOS12_STATUS_SUCCESS                                      (0x00000000)
#define NVOS12_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS12_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS12_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS12_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 version;
  NvV32 status;
} NVOS12_PARAMETERS;

/* function OS0D */
#define  NV01_CONFIG_GET                                           (0x0000000D)

/* parameter values */
#define NVOS13_STATUS_SUCCESS                                      (0x00000000)
#define NVOS13_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS13_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS13_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS13_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS13_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 value;
  NvV32 status;
} NVOS13_PARAMETERS;

/* function OS0E */
#define  NV01_CONFIG_SET                                           (0x0000000E)

/* parameter values */
#define NVOS14_STATUS_SUCCESS                                      (0x00000000)
#define NVOS14_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS14_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS14_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS14_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS14_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 oldValue;
  NvV32 newValue;
  NvV32 status;
} NVOS14_PARAMETERS;

/* function OS0F */
#define  NV01_CONFIG_UPDATE                                        (0x0000000F)

/* parameter values */
#define NVOS15_STATUS_SUCCESS                                      (0x00000000)
#define NVOS15_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS15_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS15_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS15_STATUS_ERROR_BAD_FLAGS                              (0x00000004)
#define NVOS15_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 flags;
  NvV32 status;
} NVOS15_PARAMETERS;

/* function OS16 */
#define  NV04_RING0_CALLBACK                                        (0x00000010)

/* parameter values */
#define NVOS16_STATUS_SUCCESS                                       (0x00000000)

/* callback function prototype */
typedef NvU32 (*RING0CALLBACKPROC)(NvU32, NvU32);

/* parameters */
typedef struct
{
    NvV32             hClient;
    NvV32             hDevice;
#if defined(NVRM_64)
    NvP64             functionPtr;
#else
    RING0CALLBACKPROC functionPtr;
#endif
    NvU32             param1;
    NvU32             param2;
    NvV32             status;
} NVRM_RING0CALLBACK_PARAMS;

/* function OS17 */
#define  NV04_CONFIG_GET_EX                                        (0x00000011)

/* parameter values */
#define NVOS_CGE_STATUS_SUCCESS                                    (0x00000000)
#define NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM                     (0x00000001)
#define NVOS_CGE_STATUS_ERROR_BAD_CLIENT                           (0x00000002)
#define NVOS_CGE_STATUS_ERROR_BAD_DEVICE                           (0x00000003)
#define NVOS_CGE_STATUS_ERROR_BAD_INDEX                            (0x00000004)
#define NVOS_CGE_STATUS_ERROR_INSUFFICIENT_RESOURCES               (0x00000005)
#define NVOS_CGE_STATUS_ERROR_BAD_PARAM_STRUCT                     (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if defined(NVRM_64)
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_CONFIG_GET_EX_PARAMS;

/* function OS18 */
#define  NV04_CONFIG_SET_EX                                        (0x00000012)

/* parameter values */
#define NVOS_CSE_STATUS_SUCCESS                                    (0x00000000)
#define NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM                     (0x00000001)
#define NVOS_CSE_STATUS_ERROR_BAD_CLIENT                           (0x00000002)
#define NVOS_CSE_STATUS_ERROR_BAD_DEVICE                           (0x00000003)
#define NVOS_CSE_STATUS_ERROR_BAD_INDEX                            (0x00000004)
#define NVOS_CSE_STATUS_ERROR_INSUFFICIENT_RESOURCES               (0x00000005)
#define NVOS_CSE_STATUS_ERROR_BAD_PARAM_STRUCT                     (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if defined(NVRM_64)
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_CONFIG_SET_EX_PARAMS;

/* function OS19 */
#define  NV04_I2C_ACCESS                                           (0x00000013)

/* parameter values */
#define NVOS_I2C_ACCESS_STATUS_SUCCESS                             (0x00000000)
#define NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM              (0x00000001)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT                    (0x00000002)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_DEVICE                    (0x00000003)
#define NVOS_I2C_ACCESS_STATUS_ERROR_INSUFFICIENT_RESOURCES        (0x00000004)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_PARAM_STRUCT              (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
#if defined(NVRM_64)
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_I2C_ACCESS_PARAMS;

/* function OS20 */
#define  NV01_DEBUG_CONTROL                                        (0x000000014)

/* parameter values */
#define NVOS20_STATUS_SUCCESS                                      (0x00000000)
#define NVOS20_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS20_STATUS_ERROR_BAD_DEVICE                             (0x00000002)
#define NVOS20_STATUS_ERROR_BAD_FLAGS                              (0x00000003)
#define NVOS20_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000004)

/* parameters */
typedef struct 
{
    NvV32 hRoot;
    NvV32 command;
    NvP64 pArgs;
    NvV32 status;
} NVOS20_PARAMETERS;

/* current values for command */
#define NVOS20_COMMAND_RM_FAILURE_ENABLE           0x0001
#define NVOS20_COMMAND_RM_FAILURE_DISABLE          0x0002

/* function OS21 */
#define  NV04_ALLOC                                                (0x00000015)

/* parameter values */
#define NVOS21_STATUS_SUCCESS                                      (0x00000000)
#define NVOS21_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS21_STATUS_ERROR_BAD_ROOT                               (0x00000002)
#define NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000003)
#define NVOS21_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000004)
#define NVOS21_STATUS_ERROR_BAD_CLASS                              (0x00000005)
#define NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvP64 pAllocParms;
  NvV32 status;
} NVOS21_PARAMETERS;

/* function OS22 */
#define  NV04_POWER_MANAGEMENT                                     (0x00000016)

/* parameter values */
#define NVOS22_STATUS_SUCCESS                                      (0x00000000)
#define NVOS22_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS22_STATUS_ERROR_BAD_ROOT                               (0x00000002)
#define NVOS22_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000003)
#define NVOS22_STATUS_ERROR_BAD_CLIENT                             (0x00000004)
#define NVOS22_STATUS_ERROR_BAD_CLASS                              (0x00000005)
#define NVOS22_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)
#define NVOS22_STATUS_ERROR_NO_DEVICE                              (0x00000007)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hDevice;
  NvV32 command;
  NvV32 head;
  void *params;
  NvV32 status;
} NVOS22_PARAMETERS;

/* Command values */

#define NVOS22_POWER_SLEEP               0x0001
#define NVOS22_POWER_WAKE                0x0002
#define NVOS22_POWER_WAKE_BIOS_HAS_RUN   0x0003
#define NVOS22_POWER_DOZE                0x0004
#define NVOS22_POWER_WAKE_TO_DOZE        0x0005
#define NVOS22_POWER_GET_LEVEL           0x0008

/* function OS21 */
#define  NV10_AGP_INIT                                             (0x000000015)
#define  NV10_AGP_TEARDOWN                                         (0x000000016)

/* parameters */
typedef struct 
{
  NvV32 hDevice;
  NvV32 config;
  NvV32 status;
} NVOS_AGP_PARAMS;

/* parameter values */
#define NVOS_AGP_CONFIG_DISABLE_AGP                            	        (0x00000000)
#define NVOS_AGP_CONFIG_NVAGP                                           (0x00000001)
#define NVOS_AGP_CONFIG_AGPGART                                         (0x00000002)
#define NVOS_AGP_CONFIG_ANYAGP                                          (0x00000003)

#define NVOS_AGP_STATUS_SUCCESS                             		(0x00000000)
#define NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM              		(0x00000001)
#define NVOS_AGP_STATUS_ERROR_BAD_CLIENT                           	(0x00000002)
#define NVOS_AGP_STATUS_ERROR_BAD_DEVICE                           	(0x00000003)

/* function OS25 */
#define NV04_OSCONFIG_SET                                           (0x00000019)

/* parameter values */
#define NVOS25_STATUS_SUCCESS                                      (0x00000000)
#define NVOS25_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS25_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS25_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS25_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS25_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 oldValue;
  NvV32 newValue;
  NvV32 status;
} NVOS25_PARAMETERS;

/* function OS26 */
#define NV04_OSCONFIG_GET                                           (0x0000001A)

/* parameter values */
#define NVOS26_STATUS_SUCCESS                                      (0x00000000)
#define NVOS26_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS26_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS26_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS26_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS26_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 value;
  NvV32 status;
} NVOS26_PARAMETERS;

/* function OS27 */
#define NV04_OSCONFIG_GET_EX                                        (0x0000001B)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if defined(NVRM_64)
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_OSCONFIG_GET_EX_PARAMS;

/* function OS28 */
#define NV04_OSCONFIG_SET_EX                                        (0x0000001C)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if defined(NVRM_64)
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_OSCONFIG_SET_EX_PARAMS;

/* function OS2A */
#define NV04_SWAP_EXT                                              (0x00000020)

/* parameter values */
#define NVOS2A_FLAGS_SWAP                                          1:0
#define NVOS2A_FLAGS_SWAP_BARRIER                                  (0x00000000)
#define NVOS2A_FLAGS_SWAP_GROUP                                    (0x00000001)
#define NVOS2A_FLAGS_ACTION                                        3:2
#define NVOS2A_FLAGS_ACTION_INIT                                   (0x00000000)
#define NVOS2A_FLAGS_ACTION_ADD                                    (0x00000001)
#define NVOS2A_FLAGS_ACTION_REMOVE                                 (0x00000002)
#define NVOS2A_STATUS_SUCCESS                                      (0x00000000)
#define NVOS2A_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS2A_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS2A_STATUS_ERROR_BAD_GROUP                              (0x00000003)
#define NVOS2A_STATUS_ERROR_BAD_DEVICE                             (0x00000004)
#define NVOS2A_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 hChannel;
  NvV32 flags;
  NvV32 group_id;
  NvV32 barrier_id;
  NvV32 status;
} NVOS2A_PARAMETERS;


/* macro NV04_DIRECT_METHOD_CALL */
#define NV04_DIRECT_METHOD_CALL                                    (0x0000001D)

/* parameter values */
#define NVOS1D_STATUS_SUCCESS                                      (0x00000000)
#define NVOS1D_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS1D_STATUS_ERROR_BAD_OBJECT_OLD                         (0x00000003)
#define NVOS1D_STATUS_ERROR_BAD_METHOD                             (0x00000004)
#define NVOS1D_STATUS_ERROR_BAD_DATA                               (0x00000005)

/* NT ioctl data structure */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectOld;
  NvV32 method;
  NvV32 data;
  NvV32 status;
} NVOS1D_PARAMETERS;

#define NV04_UNIFIED_FREE											(0x0000001E)

#define NVOS1E_STATUS_SUCCESS										(0x00000000)
#define NVOS1E_STATUS_ERROR_OPERATING_SYSTEM						(0x00000001)
#define NVOS1E_STATUS_ERROR_OBJECT_IN_USE							(0x00000004)

/* NT ioctl data structure */
typedef struct
{
	NvV32	hClient;
	NvV32	hClass;
	NvU32	uDeviceRef;
	NvP64	pParam;
	NvV32	status;
} NV_UNIFIED_FREE;


#ifdef __cplusplus
};
#endif
#endif /* NVOS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\nvmisc.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvmisc.h
 */
#ifndef __NV_MISC_H
#define __NV_MISC_H

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

// 
// control struct and defines for NvRmI2CAccess()
//
typedef struct
{
    unsigned long	token;
    unsigned long	cmd;
    unsigned long	port;
    unsigned long	flags;
    unsigned long	data;
    unsigned long	status;
} NVRM_I2C_ACCESS_CONTROL;

// commands
#define	NVRM_I2C_ACCESS_CMD_ACQUIRE     1
#define	NVRM_I2C_ACCESS_CMD_RELEASE     2
#define	NVRM_I2C_ACCESS_CMD_WRITE_BYTE  3
#define	NVRM_I2C_ACCESS_CMD_READ_BYTE   4
#define	NVRM_I2C_ACCESS_CMD_NULL        5
#define	NVRM_I2C_ACCESS_CMD_RESET       6
#define NVRM_I2C_ACCESS_CMD_READ_SDA    7
#define NVRM_I2C_ACCESS_CMD_READ_SCL    8
#define NVRM_I2C_ACCESS_CMD_WRITE_SDA   9
#define NVRM_I2C_ACCESS_CMD_WRITE_SCL   10

// flags
#define NVRM_I2C_ACCESS_FLAG_START	    0x1
#define	NVRM_I2C_ACCESS_FLAG_STOP	    0x2
#define	NVRM_I2C_ACCESS_FLAG_ACK	    0x4

// port
#define	NVRM_I2C_ACCESS_PORT_PRIMARY    1
#define	NVRM_I2C_ACCESS_PORT_SECONDARY  2

// status
#define	NVRM_I2C_ACCESS_STATUS_SUCCESS         0
#define	NVRM_I2C_ACCESS_STATUS_ERROR           1
#define	NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR  2
#define	NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY     3

//
// misc string definitions for registry manipulation
//
#define STR_NVIDIA                  "NVidia"
#define STR_DEV_NODE_RM             "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\System"
#define STR_DEV_NODE_DISPLAY        "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display";
#define STR_DEV_NODE_DISPLAY_NUMBER "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display\\DeviceX";
#define STR_RM_CORE_NAME            "RmCoreName"

#ifdef __cplusplus
}
#endif //__cplusplus

#endif // __NV_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\nvRmStereo.h ===
#ifndef _NVRM_STEREO_H_
#define _NVRM_STEREO_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************** Resource Manager Defines and Structures ******************\
*                                                                           *
* Module: NvRmStereo.h                                                      *
*		Resource Manager stereo interface structure.						*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:																	*
*		Andrei Osnovich  03/17/2000 Created. 								*
*       Martin Schwarzer 10/11/2000 added flags to use interface for NT4/W2K*
*                                   opengl api stereo                       *
*                                                                           *
\***************************************************************************/




//Flag values that can be ORed in the NV_CFG_STEREO_PARAMS.Flags below
#define STEREOCFG_STEREOACTIVATED   0x80000000
#define STEREOCFG_CONNECTIONTYPE    0x00000077
#define STEREOCFG_ELSADDC           0x00000001
#define STEREOCFG_INTERLACED        0x00000002
#define STEREOCFG_GPIO_0            0x00000004
#define STEREOCFG_GPIO_1            0x00000008
#define STEREOCFG_LINECODE          0x00000010
// syncronisation and other special stuff should be added below here
#define STEREOCFG_WS_OGL_API_STEREO 0x00001000 // is used by workstation OpenGL API stereo 
#define STEREOCFG_FREE_MEMORY       0x00002000 // free memory in interrupt routine to avoid race condition
// common settings
#define STEREOCFG_STEREO_INITIALIZE 0x00004000 // used by NT4/W2K displaydriver to switch on  glasses-toggling
#define STEREOCFG_STEREO_DISABLE    0x00008000 // used by NT4/W2K displaydriver to switch oFF glasses-toggling
#define STEREOCFG_ENTER_ADJACENT    0x00010000 // tells resman that from this moment all allocated stereo surfaces have be double pitched.
#define STEREOCFG_EXIT_ADJACENT     0x00020000 // cancelled the state above.

// Param Structure
typedef struct {
	unsigned long	Flags;
	unsigned long	EyeDisplayed;
	unsigned long	FlipOffsets[4][2];
} NV_CFG_STEREO_PARAMS, *LPNV_CFG_STEREO_PARAMS;

#endif	//_NVRM_STEREO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\NvViewer.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: NvViewer.h                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    10/04/2000  Created                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVVIEWER_H_
#define _NVVIEWER_H_

#define NVSTEREO_IMAGE_SIGNATURE 0x4433564e //NV3D
typedef struct  _Nv_Stereo_Image_Header
{
    DWORD   dwSignature;
    DWORD   dwWidth;
    DWORD   dwHeight;
    DWORD   dwBPP;
    DWORD   dwSwapEyes;
} NVSTEREOIMAGEHEADER, *LPNVSTEREOIMAGEHEADER;

//Stereo image viewing mode
#define FULL_SCREEN         0
#define WINDOWED            1
#define WINDOWED_FIT        2

// Mesage handling mode
#define INTERNAL_MESSAGING  0x00000000
#define EXTERNAL_MESSAGING  0x00000001
#define FRAMES_TIMED 0x80000000
#define SECONDS_PER_FRAME(x) (FRAMES_TIMED | ((x & 0x7F) << 24))
#define SECONDS_IN_FLAGS(x) (x & FRAMES_TIMED ? ((x & 0x7f000000) >> 24) : 0)

// Return values from Display(...) and ViewDisplay(...)
#define IV_QUIT 0
#define IV_NEXTIMAGE 1
#define IV_PREVIMAGE 2
#define IV_TRYNEXTIMAGE 3
#define IV_MOVEIMAGE 4

typedef class CStereoImageViewer
{
    /*
     * methods
     */
public:
    virtual DWORD Display (LPVOID pImage, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwViewMode, DWORD dwMessageMode);
    virtual DWORD Display (char * filename, DWORD dwViewMode, DWORD dwMessageMode);
    virtual DWORD WINAPI DestroyStereoImageViewer(void);

		virtual DWORD ViewSetup(HWND hWnd, DWORD dwWidth = 0xFFFFFFFF, DWORD dwHeight = 0xFFFFFFFF, DWORD dwBPP = 2);
		virtual DWORD ViewDisplay(LPVOID pImage, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwViewMode, DWORD dwMessageMode);
		virtual DWORD ViewDisplay(char * filename, DWORD dwViewMode, DWORD dwMessageMode);
		virtual DWORD ViewTakedown();

		virtual void ForceClear(bool bFlag) {m_bForceClear = bFlag;}

    CStereoImageViewer();
    ~CStereoImageViewer();
protected:
		LPDIRECTDRAW7 m_pDD;
		HWND m_hWnd;
		RECT m_rWindowRect;

		DWORD m_dwWidth, m_dwHeight, m_dwBPP;
		bool m_bResetModePerImage, m_bForceClear;

		LPDIRECT3D7 m_pD3D;
    LPDIRECT3DDEVICE7 m_pd3dDevice;
    LPDIRECTDRAWSURFACE7 m_pddsFlipSurface;
    LPDIRECTDRAWSURFACE7 m_pddsBackBuffer;

		HRESULT ISetup(); // Does flip/back buffer setup and connection to d3d
		HRESULT ITakedown();

} CSTEREOIMAGEVIEWER, *LPCSTEREOIMAGEVIEWER;


extern DWORD WINAPI CreateStereoImageViewer(LPCSTEREOIMAGEVIEWER &pStereoImageViewer);

#endif _NVVIEWER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\nvtypes.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nvtypes.h> defines common widths used to access hardware in of NVIDIA's *|
|*  Unified Media Architecture (TM).                                         *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NVTYPES_INCLUDED
#define NVTYPES_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif


/****************************************************************************\
|*    IA64 common defines                                                   *|
\****************************************************************************/

#if defined(H2INC) || ((defined(WIN32) || defined(_WIN32)) && !defined(_WIN32_WINNT)) /* win9x */ || defined(__DJGPP__)
#undef NVRM_64
#else                                             /* all other platforms */
#define NVRM_64 1
#  if defined(_WIN64) || defined(_LINUX64)
#    define NVRM_TRUE64 1
#  endif
#endif

#if defined(linux) || defined(MACOS) || defined(macintosh) || defined(__APPLE_CC__)
#define __int64 long long int
#endif

 /***************************************************************************\
|*                                 Typedefs                                  *|
 \***************************************************************************/

typedef unsigned char      NvV8;  /* "void": enumerated or multiple fields   */
typedef unsigned short     NvV16; /* "void": enumerated or multiple fields   */
typedef unsigned char      NvU8;  /* 0 to 255                                */
typedef unsigned short     NvU16; /* 0 to 65535                              */
typedef signed char        NvS8;  /* -128 to 127                             */
typedef signed short       NvS16; /* -32768 to 32767                         */
typedef float              NvF32; /* IEEE Single Precision (S1E8M23)         */
typedef double             NvF64; /* IEEE Double Precision (S1E11M52)        */

/* mainly for 64-bit linux, where long is 64 bits
 * and win9x, where int is 16 bit.
 */
#if defined(linux)
typedef unsigned int       NvV32; /* "void": enumerated or multiple fields   */
typedef unsigned int       NvU32; /* 0 to 4294967295                         */
typedef signed int         NvS32; /* -2147483648 to 2147483647               */
#else
typedef unsigned long      NvV32; /* "void": enumerated or multiple fields   */
typedef unsigned long      NvU32; /* 0 to 4294967295                         */
typedef signed long        NvS32; /* -2147483648 to 2147483647               */
#endif

 /***************************************************************************\
|*                                                                           *|
|*  64 bit type definitions for use in interface structures.                 *|
|*                                                                           *|
 \***************************************************************************/

#if defined(NVRM_TRUE64)

typedef unsigned __int64   NvV64; /* "void": enumerated or multiple fields   */
typedef unsigned __int64   NvU64; /* 0 to 18446744073709551615               */
typedef __int64            NvS64; /* 2^-63 to 2^63-1                         */
typedef void*              NvP64; /* 64 bit void pointer                     */

typedef NvU64 NvU64_VALUE_T;
typedef NvP64 NvP64_VALUE_T;

#define NvU64_VALUE(n)    (n)
#define NvP64_VALUE(n)    (n)
#define NvP64_SELECTOR(n) (0)

#elif defined(NVRM_64)

typedef unsigned __int64   NvV64; /* "void": enumerated or multiple fields   */
typedef unsigned __int64   NvU64; /* 0 to 18446744073709551615               */
typedef __int64            NvS64; /* 2^-63 to 2^63-1                         */
typedef unsigned __int64   NvP64; /* 64 bit void pointer                     */

typedef NvU64 NvU64_VALUE_T;
typedef NvP64 NvP64_VALUE_T;

#define NvU64_VALUE(n)    (n)
#define NvP64_VALUE(n)    (n)
#define NvP64_SELECTOR(n) (0)

#else

typedef struct {
 NvU32 low;
 NvU32 high;
}                          NvV64; /* "void": enumerated or multiple fields   */
typedef struct {
 NvU32 low;
 NvU32 high;
}                          NvU64; /* 0 to 18446744073709551615               */
typedef struct {
 NvU32 low;
 NvS32 high;
}                          NvS64; /* 2^-63 to 2^63-1                         */
typedef struct {
 NvU32 offset;
 NvU16 selector;
 NvU16 reserved;
}                          NvP64; /* 64 bit void pointer                     */

typedef NvU32 NvP64_VALUE_T;
typedef NvU32 NvU64_VALUE_T;

#define NvU64_VALUE(n)    ((n).low)
#define NvP64_VALUE(n)    ((n).offset)
#define NvP64_SELECTOR(n) ((n).selector)

#endif

 /***************************************************************************\
|*                                                                           *|
|*  64 bit integer definitions for high precision arithmetic.                *|
|*  Ideally, NvU64/NvS64 would be a flat integer on all platforms            *|
|*  but __int64 is not recognized by 16 bit compilers.                       *|
|*                                                                           *|
 \***************************************************************************/

#if (defined(_WIN32) && !defined(H2INC)) || defined(NVRM_64)
typedef unsigned __int64   NvUI64; /* 0 to 18446744073709551615              */
typedef __int64            NvSI64; /* 2^-63 to 2^63-1                        */
#endif

/* obsolete stuff */
typedef NvV8  V008;
typedef NvV16 V016;
typedef NvV32 V032;
typedef NvV64 V064;
typedef NvU8  U008;
typedef NvU16 U016;
typedef NvU32 U032;
typedef NvU64 U064;
typedef NvS8  S008;
typedef NvS16 S016;
typedef NvS32 S032;
typedef NvS64 S064;
typedef NvP64 P064;
typedef NvF32 F032;
typedef NvF64 F064;
#if defined(MACOS) || defined(macintosh) || defined(__APPLE_CC__)
// more obsolete stuff
// need to provide these on macos9 and macosX
typedef unsigned long  ULONG;
typedef unsigned long  DWORD;
typedef unsigned char *PUCHAR;
typedef void           VOID;
typedef void          *PVOID;
typedef void          *HANDLE;
#endif

/* polymorphic 64-bit macros */
#if defined(NVRM_TRUE64)
typedef NvP64 VOID_PTR;
typedef NvU64 NV_UINTPTR_T;
#else
typedef NvU32 VOID_PTR;
typedef NvU32 NV_UINTPTR_T;
#endif

#ifdef __cplusplus
};
#endif
#endif /* NVTYPES_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\nv4\inc\nvntioctl.h ===
// NT client IOCTLs

// NV graphics device driver string
#define NVRM_NAME_STRING L"\\Device\\nvgfx"
#define NVRM_LINK_STRING L"\\DosDevices\\nvgfx"

// device type and base control code
#define FILE_DEVICE_NVRM 	0x00008000
#define NVRM_IOCTL_INDEX 	0x00000800
#define NV_IOCTL_CODE(f)		  	\
	CTL_CODE(                   	\
		FILE_DEVICE_NVRM+(f),   	\
		NVRM_IOCTL_INDEX,     		\
		METHOD_BUFFERED,        	\
		FILE_ANY_ACCESS         	\
	)

// control codes
#define NV1_IOCTL_GET_DEVICE_OS_NAME		NV_IOCTL_CODE(0x0001)
//#define NV1_IOCTL_FREE  					NV_IOCTL_CODE(NV1_FREE)
#define NV1_IOCTL_ALLOC_CONTEXT_DMA  		NV_IOCTL_CODE(0x0002)
#define NV1_IOCTL_FREE_CONTEXT_DMA  		NV_IOCTL_CODE(0x0003)
#define NV3_IOCTL_ALLOC_CHANNEL_PIO  		NV_IOCTL_CODE(0x0008)
#define NV3_IOCTL_FREE_CHANNEL_PIO  		NV_IOCTL_CODE(0x0009)
#define NV3_IOCTL_ALLOC_CHANNEL_DMA  		NV_IOCTL_CODE(0x0007)
//#define NV3_IOCTL_ALLOC_CHANNEL_DMA  		NV_IOCTL_CODE(NV3_ALLOC_CHANNEL_DMA)
#define NV3_IOCTL_FREE_CHANNEL_DMA  		NV_IOCTL_CODE(0x000B)
#define NV3_IOCTL_DMA_FLOW_CONTROL  		NV_IOCTL_CODE(0x00FF)
//#define NV3_IOCTL_DMA_FLOW_CONTROL  		NV_IOCTL_CODE(NV3_DMA_FLOW_CONTROL)
#define NV1_IOCTL_ALLOC_MEMORY  			NV_IOCTL_CODE(0x000E)
#define NV1_IOCTL_FREE_MEMORY  				NV_IOCTL_CODE(0x000F)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\nv4\inc\nvMacros.h ===
#ifndef NVMACROS_INCLUDED
#define NVMACROS_INCLUDED
/*
 ****************************************************************************

 Copyright (C) 1994, 1995, 1996 NVIDIA Corporation

 These are suggested macros for working with the NV architecture.
 You can use these as is or modify them for your own needs.

 Note that you can get faster code by handcrafting inline assembler 
 for the packing macros, but this is compiler-dependent.

 ****************************************************************************
 */

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for V032, U032, etc. typedefs */
#endif

/***** Free Count Macros *****/

/*
 * WAIT_FIFO(psc,nBytes)
 *	The first parameter is a pointer to the subchannel.
 *
 * 	The second parameter is the number of _bytes_ the application 
 *	wants to write. This is 4 times the number of 32-bit writes,
 *	or you can use the sizeof() function to determine the size
 *	of the argument of each method invoked.
 *
 */
#define WAIT_FIFO(psc,nBytes)     while((psc)->control.free<(nBytes))


/*
 * WAIT_FREE(psc,nBytes, localFree)
 *  This stores the free count.
 *
 *  The first parameter is a pointer to the subchannel.
 *
 * 	The second parameter is the number of _bytes_ the application 
 *  wants to write. This is 4 times the number of 32-bit writes,
 *  or you can use the sizeof() function to determine the size
 *  of the argument of each method invoked.
 *
 *	The third parameter is a variable to hold a local saved
 *	copy of the free count.  As the application invokes methods,
 *	it should decrement this by the number of _bytes_ written.
 *
 */
#ifdef DEBUG  
#define WAIT_FREE(psc, nBytes, localFree) \
	assert((nBytes) < NV_GUARANTEED_FIFO_SIZE); \
	assert((psc) != 0); \
	/* keep reading free count until it rises */ \
	while ((localFree) < (nBytes)) { \
		(localFree) = (psc)->control.free; \
	}
#else 
#define WAIT_FREE(psc, nBytes, localFree) \
	/* keep reading free count until it rises */ \
	while ((localFree) < (nBytes)) { \
		(localFree) = (psc)->control.free; \
	}
#endif /* DEBUG */

/***************************************************************************
 *                          Packing Macros                                 *
 ***************************************************************************/


/***** Coordinates *****/

/* Pack two Signed 16-bit coordinates. Mustn't sign-extend */
#define PACK_XY(x,y)    ((V032)((((U032)(y))<<16)|(((U032)(x))&0x0000FFFF)) )

/* Pack two Unsigned 16-bit dimensions */
#define PACK_WH(w,h)    ((V032)((((U032)(h))<<16)|(((U032)(w))&0x0000FFFF)) )

/***** Colors *****/

/* Pack 1-bit Alpha and 5-bit R,G,B values into NV_COLOR_FORMAT_LE_X16A1R5G5B5  */
#define PACK_ARGB15(a,r,g,b) \
            ((V032)((((a)?(1<<15):0))|(((U032)(r)&0x1F)<<10)|\
            (((U032)(g)&0x1F)<<5)|((U032)(b)&0x1F)))

/* Pack 5-bit R,G,B values into NV_COLOR_FORMAT_LE_X17R5G5B5 */
#define PACK_RGB15(r,g,b)   (PACK_ARGB15(0,r,g,b))

/* Pack three 8-bit R,G,B values into NV_COLOR_FORMAT_LE_X8R8G8B8 */
#define PACK_RGB24(r,g,b)   \
            ((V032)((((U032)(r)&0xFF)<<16)|\
            (((U032)(g)&0xFF)<<8)|((U032)(b)&0xFF)))

/* Pack 8-bit Alpha and 8-bit R,G,B values into NV_COLOR_FORMAT_LE_A8R8G8B8 */
#define PACK_ARGB24(a,r,g,b)    \
            ((V032)((((U032)(a))<<24)|(((U032)(r)&0xFF)<<16)|\
            (((U032)(g)&0xFF)<<8)|((U032)(b)&0xFF)))

/* Pack three 10-bit R,G,B values into NV_COLOR_FORMAT_LE_X2R10G10B10 */
#define PACK_RGB30(r,g,b)   \
            ((V032)((((U032)(r)&0x3FF)<<20)|\
            (((U032)(g)&0x3FF)<<10)|((U032)(b)&0x3FF)))

/* Pack 2-bit Alpha and 10-bit R,G,B values into NV_COLOR_FORMAT_LE_A2R10G10B10 */
#define PACK_ARGB30(a,r,g,b)    \
            ((V032)(((U032)(a)<<30)|(((U032)(r)&0x3FF)<<20)|\
            (((U032)(g)&0x3FF)<<10)|((U032)(b)&0x3FF)))

/***** Fractions *****/

/* Make unsigned 16.16 fraction from a whole number (integer or float) */
#define MAKE_FRACT16(num)   ((V032)((num)*(1<<16)))

/* Make unsigned 8.24 fraction from whole number (integer or float) */
#define MAKE_FRACT24(num)   ((V032)((num)*(1<<24)))

#endif /* NVMACROS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\nv10\inc\nvMacros.h ===
#ifndef NVMACROS_INCLUDED
#define NVMACROS_INCLUDED
/*
 ****************************************************************************

 Copyright (C) 1994, 1995, 1996 NVIDIA Corporation

 These are suggested macros for working with the NV architecture.
 You can use these as is or modify them for your own needs.

 Note that you can get faster code by handcrafting inline assembler 
 for the packing macros, but this is compiler-dependent.

 ****************************************************************************
 */

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for V032, U032, etc. typedefs */
#endif

/***** Free Count Macros *****/

/*
 * WAIT_FIFO(psc,nBytes)
 *	The first parameter is a pointer to the subchannel.
 *
 * 	The second parameter is the number of _bytes_ the application 
 *	wants to write. This is 4 times the number of 32-bit writes,
 *	or you can use the sizeof() function to determine the size
 *	of the argument of each method invoked.
 *
 */
#define WAIT_FIFO(psc,nBytes)     while((psc)->control.free<(nBytes))


/*
 * WAIT_FREE(psc,nBytes, localFree)
 *  This stores the free count.
 *
 *  The first parameter is a pointer to the subchannel.
 *
 * 	The second parameter is the number of _bytes_ the application 
 *  wants to write. This is 4 times the number of 32-bit writes,
 *  or you can use the sizeof() function to determine the size
 *  of the argument of each method invoked.
 *
 *	The third parameter is a variable to hold a local saved
 *	copy of the free count.  As the application invokes methods,
 *	it should decrement this by the number of _bytes_ written.
 *
 */
#ifdef DEBUG  
#define WAIT_FREE(psc, nBytes, localFree) \
	assert((nBytes) < NV_GUARANTEED_FIFO_SIZE); \
	assert((psc) != 0); \
	/* keep reading free count until it rises */ \
	while ((localFree) < (nBytes)) { \
		(localFree) = (psc)->control.free; \
	}
#else 
#define WAIT_FREE(psc, nBytes, localFree) \
	/* keep reading free count until it rises */ \
	while ((localFree) < (nBytes)) { \
		(localFree) = (psc)->control.free; \
	}
#endif /* DEBUG */

/***************************************************************************
 *                          Packing Macros                                 *
 ***************************************************************************/


/***** Coordinates *****/

/* Pack two Signed 16-bit coordinates. Mustn't sign-extend */
#define PACK_XY(x,y)    ((V032)((((U032)(y))<<16)|(((U032)(x))&0x0000FFFF)) )

/* Pack two Unsigned 16-bit dimensions */
#define PACK_WH(w,h)    ((V032)((((U032)(h))<<16)|(((U032)(w))&0x0000FFFF)) )

/***** Colors *****/

/* Pack 1-bit Alpha and 5-bit R,G,B values into NV_COLOR_FORMAT_LE_X16A1R5G5B5  */
#define PACK_ARGB15(a,r,g,b) \
            ((V032)((((a)?(1<<15):0))|(((U032)(r)&0x1F)<<10)|\
            (((U032)(g)&0x1F)<<5)|((U032)(b)&0x1F)))

/* Pack 5-bit R,G,B values into NV_COLOR_FORMAT_LE_X17R5G5B5 */
#define PACK_RGB15(r,g,b)   (PACK_ARGB15(0,r,g,b))

/* Pack three 8-bit R,G,B values into NV_COLOR_FORMAT_LE_X8R8G8B8 */
#define PACK_RGB24(r,g,b)   \
            ((V032)((((U032)(r)&0xFF)<<16)|\
            (((U032)(g)&0xFF)<<8)|((U032)(b)&0xFF)))

/* Pack 8-bit Alpha and 8-bit R,G,B values into NV_COLOR_FORMAT_LE_A8R8G8B8 */
#define PACK_ARGB24(a,r,g,b)    \
            ((V032)((((U032)(a))<<24)|(((U032)(r)&0xFF)<<16)|\
            (((U032)(g)&0xFF)<<8)|((U032)(b)&0xFF)))

/* Pack three 10-bit R,G,B values into NV_COLOR_FORMAT_LE_X2R10G10B10 */
#define PACK_RGB30(r,g,b)   \
            ((V032)((((U032)(r)&0x3FF)<<20)|\
            (((U032)(g)&0x3FF)<<10)|((U032)(b)&0x3FF)))

/* Pack 2-bit Alpha and 10-bit R,G,B values into NV_COLOR_FORMAT_LE_A2R10G10B10 */
#define PACK_ARGB30(a,r,g,b)    \
            ((V032)(((U032)(a)<<30)|(((U032)(r)&0x3FF)<<20)|\
            (((U032)(g)&0x3FF)<<10)|((U032)(b)&0x3FF)))

/***** Fractions *****/

/* Make unsigned 16.16 fraction from a whole number (integer or float) */
#define MAKE_FRACT16(num)   ((V032)((num)*(1<<16)))

/* Make unsigned 8.24 fraction from whole number (integer or float) */
#define MAKE_FRACT24(num)   ((V032)((num)*(1<<24)))

#endif /* NVMACROS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\nv4\inc\nvUTypes.h ===
#ifndef NVUTYPES_INCLUDED
#define NVUTYPES_INCLUDED
/*
 * nvutypes.h
 *
 * Copyright (C) 1995,1996 NVIDIA Corporation.
 *
 * This file contains unpacked types corresponding to the packed 32-bit 
 * types in <nv32.h>.  For example, the byte/bit alignment of Nvu1Pt16
 * is the same as required by renderSolidRectangle.Rectangle[0].y_x.
 *
 * If you want to manipulate elements smaller than 32 bits in your code, 
 * use these structures or define similar structures.  But when
 * you make assignments to hardware offsets in the NV Architecture,
 * you must use at least 32-bit wide quantities -- you must perform 
 * 32-bit writes.  You can cast these structures to 32 bits or combine
 * them in a union with pure 32-bit elements.
 *
 * An alternative to using these structures is to store values in your
 * own chosen format, and use the macros in <nvmacros.h> to assemble 
 * them into 32-bit values before writing to the chip.  But such macros 
 * take CPU cycles (except for constant values).
 */

/* Note that in the type names, "u" means unpacked, not "U" for unsigned". */

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for V008, U032, etc. typedefs */
#endif

typedef short	S016;

typedef struct {
	V008                c0;                               /*0000-0000*/
	V008                reserved01[0x003];                /*0001-0003*/
} Nvu1Color08;
typedef struct {
	V008                c0;                               /*0000-0000*/
	V008                c1;                               /*0001-0001*/
	V008                c2;                               /*0002-0002*/
	V008                c3;                               /*0003-0003*/
} Nvu4Color08;
typedef struct {
	V016                c0;                               /*0000-0001*/
	V016                reserved01[0x001];                /*0002-0003*/
} Nvu1Color16;
typedef struct {
	V016                c0;                               /*0000-0001*/
	V016                c1;                               /*0002-0003*/
} Nvu2Color16;
typedef struct {
	V032                c0;                               /*0000-0003*/
} Nvu1Color32;
typedef union {
	Nvu1Color08         v008;                             /*0000-0003*/
	Nvu1Color16         v016;                             /*0000-0003*/
	Nvu1Color32         v032;                             /*0000-0003*/
	V032                p;                                /*0000-0003*/
} Nvu1Color;

typedef union {
	Nvu4Color08         v_4_008;                          /*0000-0003*/
	Nvu2Color16         v_2_016;                          /*0000-0003*/
	Nvu1Color32         v_1_032;                          /*0000-0003*/
	Nvu1Color16         v_1_016;                          /*0000-0003*/
	Nvu1Color08         v_1_008;                          /*0000-0003*/
	V032                p;                                /*0000-0003*/
} NvuColor;

typedef struct {
	U016                fractHertz;                       /*0000-0001*/
	U016                intHertz;                         /*0002-0003*/
} NvuHertz;

typedef struct {
	U016                fractPart;                        /*0000-0001*/
	U016                intPart;                          /*0002-0003*/
} NvuFract;

typedef struct {
	S016                x;                                /*0000-0001*/
	S016                y;                                /*0002-0003*/
	U016                w;                                /*0004-0005*/
	U016                h;                                /*0006-0007*/
} NvuRect16;

typedef struct {
	S016                x;                                /*0000-0001*/
	S016                y;                                /*0002-0003*/
} Nvu1Pt16;

typedef struct {
	U016                w;                                /*0000-0001*/
	U016                h;                                /*0002-0003*/
} NvuDim16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
} Nvu2Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
} Nvu3Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
	S016                x3;                               /*000c-000d*/
	S016                y3;                               /*000e-000f*/
} Nvu4Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
	S016                x3;                               /*000c-000d*/
	S016                y3;                               /*000e-000f*/
	S016                x4;                               /*0010-0011*/
	S016                y4;                               /*0012-0013*/
	S016                x5;                               /*0014-0015*/
	S016                y5;                               /*0016-0017*/
	S016                x6;                               /*0018-0019*/
	S016                y6;                               /*001a-001b*/
	S016                x7;                               /*001c-001d*/
	S016                y7;                               /*001e-001f*/
	S016                x8;                               /*0020-0021*/
	S016                y8;                               /*0022-0023*/
} Nvu9Pt16;


#endif /* NVUTYPES_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\XXXrm_unix.h ===
/*
 * this is a hack repository to deal with issues on resman linux port as
 * it matures.
 * Once this file is emptied it can be deleted.
 */

/* XXXTEB these should be somewhere else; probably nvos.h */
typedef unsigned long ULONG;
typedef unsigned char *PUCHAR;
typedef void VOID;
typedef void *PVOID;
typedef void *HANDLE;
/* XXXTEB end */

int XXX_RM_INIT(void);
void XXX_ISR_POLL(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\inc\rddapi.inc ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         rddapi.inc
;
; Purpose:      This file holds the interface description for both
;               the minivdd and the resman's Register Display Driver
;               API. Register Display Driver is a private API between
;               16bit land and the driver components.
;==============================================================================

; To call the API, set:
; eax = VDD_REGISTER_DISPLAY_DRIVER_INFO  (defined in minivdd.inc)
; ebx = system VM handle
; ecx = one of the equates below
;
; Other register settings depend upon the value in ecx.

; These services are in the RegisterDisplayDriver function in the
; resman. They are services needed by the hardware specific portion
; of the display driver.

MVDD_GET_LOGDEV_SHARED_MEMORY                   EQU     8764FFFFH
MVDD_ALLOC_LINEAR_ADDRESS_SPACE                 EQU     87650000H
MVDD_FREE_LINEAR_ADDRESS_SPACE                  EQU     87650001H
MVDD_COPY_PTES_FOR_LINEAR_RANGE                 EQU     87650002H

; These services are in the RegisterDisplayDriver function in the
; minivdd. They are services needed by the generic portion of the
; display driver.
MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS        EQU     87650003H
MVDD_ALLOC_MEMORY_BLOCK                         EQU     87650004H
MVDD_FREE_MEMORY_BLOCK                          EQU     87650005H
MVDD_REENUMERATE_DEVNODE                        EQU     87650006H
MVDD_SET_POWER_MANAGEMENT_CALLBACKS             EQU     87650007H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\nv4\inc\nvosnt.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

 

 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nvos.h>  defines the Operating System function and ioctl interfaces to  *|
|*  NVIDIA's Unified Media Architecture (TM).                                *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NVOS_INCLUDED
#define NVOS_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#include <nvtypes.h>


 /***************************************************************************\
|*                              NV OS Functions                              *|
 \***************************************************************************/


/* macro NvOpen() */
/* values */
#define NVOPEN_STATUS_SUCCESS                            (0x00000000)
#define NVOPEN_STATUS_ERROR_OPERATING_SYSTEM             (0x00000001)

/* macro for NT Mini-Port driver */
#ifdef NTMINIPORT
#include <ntddk.h>
#include <windef.h>
typedef struct                                                                \
{                                                                              \
    PFILE_OBJECT   pFileObject;                                                \
    PDEVICE_OBJECT pDeviceObject;                                              \
} NVDESCRIPTOR;
#endif


/* function NvClose() */
#define NVCLOSE_ERROR_OK                                 (0x0000)
#define NVCLOSE_ERROR_UNSUCCESSFUL                       (0x0001)



 /***************************************************************************\
|*                               NV OS Ioctls                                *|
 \***************************************************************************/


/* ioctl Nv1GetDeviceOsName() */
#define NV0001_ERROR_OK                                  (0x0000)
#define NV0001_ERROR_NONEXISTENT_DEVICE                  (0x0001)
#define NV0001_ERROR_INSUFFICIENT_RESOURCES              (0x0002)
typedef struct 
{
	U016 devInstance;
	U032 nameBuffer;
	U016 maxNameLength;
	U016 nvStatus;
} NV1_GET_DEVICE_OS_NAME_STRUCT;


/* ioctl Nv1FreeMemory() */
#define NV000F_ERROR_OK                                  (0x0000)
#define NV000F_ERROR_INVALID_ADDRESS                     (0x0001)
typedef struct 
{
	U032 pMemory;
	U016 nvStatus;
} NV1_FREE_MEMORY_STRUCT;

/* ioctl Nv1FreeContextDma() */
#define NV0003_ERROR_OK                                  (0x0000)
#define NV0003_ERROR_INVALID_CONTEXT                     (0x0001)
typedef struct 
{
	U032 id;
	U016 nvStatus;
} NV1_FREE_CONTEXT_DMA_STRUCT;

/* ioctl Nv3FreeChannelPio() */
#define NV0009_ERROR_OK                                  (0x0000)
#define NV0009_ERROR_INVALID_CHANNEL                     (0x0001)
typedef struct 
{
	U016 devInstance;
	U032 pChannel;
	U016 nvStatus;
} NV3_FREE_CHANNEL_PIO_STRUCT;

/* ioctl Nv1FreeObject() */
#define NVFFF1_ERROR_OK                                  (0x0000)
#define NVFFF1_ERROR_INVALID_CONTEXT                     (0x0001)
typedef struct 
{
	U032 id;
	U016 nvStatus;
} NV1_FREE_OBJECT_STRUCT;

/* ioctl Nv4FreeChannelDma() */
typedef struct 
{
	U016 devInstance;
	U032 pChannel;
	U016 nvStatus;
} NV3_FREE_CHANNEL_DMA_STRUCT;

/* ioctl Nv4FreeChannelDma() */
typedef struct 
{
	U016 devInstance;
	U032 pChannel;
	U016 nvStatus;
} NV4_FREE_CHANNEL_DMA_STRUCT;

typedef struct 
{
	U032 hCallback;
	U016 nvStatus;
} NV1_FREE_CALLBACK_STRUCT;

typedef struct 
{
	U032 hMessage;
	U016 nvStatus;
} NV1_FREE_WIN32_MESSAGE_STRUCT;


/* ioctl Nv1AllocMemory() */
#define NV000E_ERROR_OK                                  (0x0000)
#define NV000E_ERROR_UNKNOWN_TYPE                        (0x0001)
#define NV000E_ERROR_UNSUCCESSFUL                        (0x0002)
typedef struct 
{
	U032 name;
	U032 pMemory;
	U032 limit;
	U016 nvStatus;
} NV1_ALLOC_MEMORY_STRUCT;


/* ioctl Nv1AllocContextDma() */
#define NV0002_CONTEXT_DMA_LOCK_DOWN                     (0x0000)
#define NV0002_CONTEXT_DMA_IN_TRANSIT                    (0x0001)
#define NV0002_CONTEXT_DMA_CACHED                        (0x0000)
#define NV0002_CONTEXT_DMA_UNCACHED                      (0x0002)
#define NV0002_CONTEXT_DMA_WRITE_COMBINED                (0x0000)
#define NV0002_CONTEXT_DMA_NOT_WRITE_COMBINED            (0x0004)
#define NV0002_ERROR_OK                                  (0x0000)
#define NV0002_ERROR_CREATE                              (0x0001)
#define NV0002_ERROR_INVALID_CLASS                       (0x0002)
#define NV0002_ERROR_INVALID_ID                          (0x0003)
#define NV0002_ERROR_INVALID_LIMIT                       (0x0004)
typedef struct 
{
	U032 id;
	V032 class;
	U032 base;
	U032 limit;
	U016 flags;
	U016 nvStatus;
} NV1_ALLOC_CONTEXT_DMA_STRUCT;


/* ioctl Nv3AllocChannelPio() */
#define NV0008_ERROR_OK                                  (0x0000)
#define NV0008_ERROR_MAPPING                             (0x0001)
#define NV0008_ERROR_MAX_CHANNELS                        (0x0002)
#define NV0008_ERROR_INVALID_CONTEXT                     (0x0003)
#define NV0008_ERROR_UNUSABLE_CONTEXT                    (0x0004)
#define NV0008_ERROR_CONTEXT_ERROR_IN_USE                (0x0005)
typedef struct 
{
	U016 devInstance;
	U032 idDmaContextErrorToMemory;
	U032 pChannel;
	U016 nvStatus;
} NV3_ALLOC_CHANNEL_PIO_STRUCT;


/* ioctl NV1_ALLOC_OBJECT */
#define  NV1_ALLOC_OBJECT                                (0x00000005)
/* parameters */
typedef struct
{
  V032 hObject;
  V032 hChannel;
  V032 hClass;
  V032 status;
} NVOS05_PARAMETERS;
/* parameter values */
#define NVOS05_STATUS_SUCCESS                            (0x00000000)
#define NVOS05_STATUS_ERROR_OPERATING_SYSTEM             (0x00000001)
#define NVOS05_STATUS_ERROR_BAD_OBJECT                   (0x00000002)
#define NVOS05_STATUS_ERROR_BAD_CHANNEL                  (0x00000003)
#define NVOS05_STATUS_ERROR_BAD_CLASS                    (0x00000004)
#define NVOS05_STATUS_ERROR_INSUFFICIENT_RESOURCES       (0x00000005)

/* macro for NT Mini-Port drivers */
#ifdef NTMINIPORT
#define Nv1AllocObject(descriptor, pParameters)                               \
{                                                                             \
    NTSTATUS ioStatus;                                                        \
    PIRP pIrp;                                                                \
    pIrp = IoBuildDeviceIoControlRequest(                                     \
        (ULONG)NV1_ALLOC_OBJECT,                                              \
        (descriptor).pDeviceObject,                                           \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS05_PARAMETERS),                                     \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS05_PARAMETERS),                                     \
        FALSE,                                                                \
        NULL,                                                                 \
        NULL);                                                                \
    if (pIrp!=NULL)                                                           \
        ioStatus = IoCallDriver(                                              \
            (descriptor).pDeviceObject,                                       \
            pIrp);                                                            \
    if (pIrp==NULL || !NT_SUCCESS(ioStatus))                                  \
        (pParameters)->status = NVOS05_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Win32 drivers */
#ifdef WIN32
#include <winbase.h>
#define Nv1AllocObject(descriptor, pParameters)                               \
{                                                                             \
    BOOL ioStatus;                                                            \
    DWORD bytesReturned;                                                      \
    ioStatus = DeviceIoControl(                                               \
        (HANDLE)(descriptor),                                                 \
        (DWORD)NV1_ALLOC_OBJECT,                                              \
        (LPVOID)(pPararmeters));                                              \
        (DWORD)sizeof(NVOS05_PARAMETERS),                                     \
        (LPVOID)(pParameters),                                                \
        (DWORD)sizeof(NVOS05_PARAMETERS),                                     \
        (LPDWORD)&bytesReturned,                                              \
        NULL);                                                                \
    if (ioStatus == FALSE)                                                    \
        (pParameters)->status = NVOS05_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Sun Solaris 1.0 and 2.0 drivers */
#if defined(SUNOS41) || defined(SYSV)
#ifdef SYSV
#include <unistd.h>
#endif
#include <sys/ioctl.h>
#define Nv1AllocObject(descriptor, pParameters)                               \
{                                                                             \
    int ioStatus;                                                             \
    ioStatus = ioctl(                                                         \
        (descriptor),                                                         \
        _IOWR(F, NV1_ALLOC_OBJECT, NVOS05_PARAMETERS),                        \
        (caddr_t)(pPararmeters));                                             \
    if (ioStatus == -1)                                                       \
        (pParameters)->status = NVOS05_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif


typedef struct 
{
	U032 name;
	U032 hCallback;
	U016 nvStatus;
} NV1_ALLOC_CALLBACK_STRUCT;

typedef struct 
{
	U032 name;
	U032 hMessage;
	U016 nvStatus;
} NV1_ALLOC_WIN32_MESSAGE_STRUCT;


/* ioctl NV3_ALLOC_CHANNEL_DMA */
#define  NV3_ALLOC_CHANNEL_DMA                           (0x00000007)
/* parameters */
typedef struct
{
  V032 hObject;
  V032 hDevice;
  V032 hClass;
  V032 hError;
  V032 hBuffer;
  U032 offset;
  P064 pChannel;
  V032 status;
} NVOS07_PARAMETERS;
/* parameter values */
#define NVOS07_STATUS_SUCCESS                            (0x00000000)
#define NVOS07_STATUS_ERROR_OPERATING_SYSTEM             (0x00000001)
#define NVOS07_STATUS_ERROR_BAD_OBJECT                   (0x00000002)
#define NVOS07_STATUS_ERROR_BAD_DEVICE                   (0x00000003)
#define NVOS07_STATUS_ERROR_BAD_CLASS                    (0x00000004)
#define NVOS07_STATUS_ERROR_BAD_ERROR                    (0x00000005)
#define NVOS07_STATUS_ERROR_BAD_BUFFER                   (0x00000006)
#define NVOS07_STATUS_ERROR_BAD_OFFSET                   (0x00000007)
#define NVOS07_STATUS_ERROR_INSUFFICIENT_RESOURCES       (0x00000008)

/* macro for NT Mini-Port drivers */
#ifdef NTMINIPORT
#define Nv3AllocChannelDma(descriptor, pParameters)                           \
{                                                                             \
    NTSTATUS ioStatus;                                                        \
    PIRP pIrp;                                                                \
    pIrp = IoBuildDeviceIoControlRequest(                                     \
        (ULONG)NV3_IOCTL_ALLOC_CHANNEL_DMA,                                         \
        (descriptor).pDeviceObject,                                           \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS07_PARAMETERS),                                     \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS07_PARAMETERS),                                     \
        FALSE,                                                                \
        NULL,                                                                 \
        NULL);                                                                \
    if (pIrp!=NULL)                                                           \
        ioStatus = IoCallDriver(                                              \
            (descriptor).pDeviceObject,                                       \
            pIrp);                                                            \
    if (pIrp==NULL || !NT_SUCCESS(ioStatus))                                  \
        (pParameters)->status = NVOS07_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Win32 drivers */
#ifdef WIN32
#include <winbase.h>
#define Nv3AllocChannelDma(descriptor, pParameters)                           \
{                                                                             \
    BOOL ioStatus;                                                            \
    DWORD bytesReturned;                                                      \
    ioStatus = DeviceIoControl(                                               \
        (HANDLE)(descriptor),                                                 \
        (DWORD)NV3_ALLOC_CHANNEL_DMA,                                         \
        (LPVOID)(pPararmeters));                                              \
        (DWORD)sizeof(NVOS07_PARAMETERS),                                     \
        (LPVOID)(pParameters),                                                \
        (DWORD)sizeof(NVOS07_PARAMETERS),                                     \
        (LPDWORD)&bytesReturned,                                              \
        NULL);                                                                \
    if (ioStatus == FALSE)                                                    \
        (pParameters)->status = NVOS07_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Sun Solaris 1.0 and 2.0 drivers */
#if defined(SUNOS41) || defined(SYSV)
#ifdef SYSV
#include <unistd.h>
#endif
#include <sys/ioctl.h>
#define Nv3AllocChannelDma(descriptor, pParameters)                           \
{                                                                             \
    int ioStatus;                                                             \
    ioStatus = ioctl(                                                         \
        (descriptor),                                                         \
        _IOWR(F, NV3_ALLOC_CHANNEL_DMA, NVOS07_PARAMETERS),                   \
        (caddr_t)(pPararmeters));                                             \
    if (ioStatus == -1)                                                       \
        (pParameters)->status = NVOS07_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif


/* ioctl NV3_DMA_FLOW_CONTROL */
#define  NV3_DMA_FLOW_CONTROL                            (0x00000008)
/* parameters */
typedef struct
{
  V032 hChannel;
  V032 flags;
  U032 put;
  U032 get;
  V032 status;
} NVOS08_PARAMETERS;
/* parameter values */
#define NVOS08_FLAGS_READ_GET                            (0x00000000)
#define NVOS08_FLAGS_WRITE_PUT_READ_GET                  (0x00000001)
#define NVOS08_FLAGS_SET_JUMP_WRITE_PUT_READ_GET         (0x00000002)
#define NVOS08_STATUS_SUCCESS                            (0x00000000)
#define NVOS08_STATUS_ERROR_OPERATING_SYSTEM             (0x00000001)
#define NVOS08_STATUS_ERROR_BAD_CHANNEL                  (0x00000002)
#define NVOS08_STATUS_ERROR_BAD_FLAGS                    (0x00000003)
#define NVOS08_STATUS_ERROR_BAD_JUMP                     (0x00000004)
#define NVOS08_STATUS_ERROR_BAD_PUT                      (0x00000005)
#define NVOS08_STATUS_ERROR_BAD_GET                      (0x00000006)

/* macro for NT Mini-Port drivers */
#ifdef NTMINIPORT
#define Nv3DmaFlowControl(descriptor, pParameters)                            \
{                                                                             \
    NTSTATUS ioStatus;                                                        \
    PIRP pIrp;                                                                \
    pIrp = IoBuildDeviceIoControlRequest(                                     \
        (ULONG)NV3_IOCTL_DMA_FLOW_CONTROL,                                          \
        (descriptor).pDeviceObject,                                           \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS08_PARAMETERS),                                     \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS08_PARAMETERS),                                     \
        FALSE,                                                                \
        NULL,                                                                 \
        NULL);                                                                \
    if (pIrp!=NULL)                                                           \
        ioStatus = IoCallDriver(                                              \
            (descriptor).pDeviceObject,                                       \
            pIrp);                                                            \
    if (pIrp==NULL || !NT_SUCCESS(ioStatus))                                  \
        (pParameters)->status = NVOS08_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Win32 drivers */
#ifdef WIN32
#include <winbase.h>
#define Nv3DmaFlowControl(descriptor, pParameters)                            \
{                                                                             \
    BOOL ioStatus;                                                            \
    DWORD bytesReturned;                                                      \
    ioStatus = DeviceIoControl(                                               \
        (HANDLE)(descriptor),                                                 \
        (DWORD)NV3_DMA_FLOW_CONTROL,                                          \
        (LPVOID)(pPararmeters));                                              \
        (DWORD)sizeof(NVOS08_PARAMETERS),                                     \
        (LPVOID)(pParameters),                                                \
        (DWORD)sizeof(NVOS08_PARAMETERS),                                     \
        (LPDWORD)&bytesReturned,                                              \
        NULL);                                                                \
    if (ioStatus == FALSE)                                                    \
        (pParameters)->status = NVOS08_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Sun Solaris 1.0 and 2.0 drivers */
#if defined(SUNOS41) || defined(SYSV)
#ifdef SYSV
#include <unistd.h>
#endif
#include <sys/ioctl.h>
#define Nv3DmaFlowControl(descriptor, pParameters)                            \
{                                                                             \
    int ioStatus;                                                             \
    ioStatus = ioctl(                                                         \
        (descriptor),                                                         \
        _IOWR(F, NV3_DMA_FLOW_CONTROL, NVOS08_PARAMETERS),                    \
        (caddr_t)(pPararmeters));                                             \
    if (ioStatus == -1)                                                       \
        (pParameters)->status = NVOS08_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* ioctl NV3_DMA_PUSH_MUTEX_STATE */
#define  NV3_DMA_PUSH_MUTEX_STATE                        (0x00000009)
/* parameters */
typedef struct
{
  U032 mutexState;
  U016 nvStatus;
} NV3_DMA_PUSH_MUTEX_STATE_STRUCT;
/* parameter values */
#define NV3_DMA_PUSH_MUTEX_STATE_FALSE                   (0x00000000)
#define NV3_DMA_PUSH_MUTEX_STATE_TRUE                    (0x00000000)
#define NV3_DMA_PUSH_MUTEX_STATE_STATUS_SUCCESS          (0x00000000)

/* only available from the mini-port driver */
/* macro for NT Mini-Port drivers */
#ifdef NTMINIPORT
#define Nv3DmaPushMutexState(descriptor, pParameters)                         \
{                                                                             \
    NTSTATUS ioStatus;                                                        \
    PIRP pIrp;                                                                \
    pIrp = IoBuildDeviceIoControlRequest(                                     \
        (ULONG)NV3_IOCTL_DMA_PUSH_MUTEX_STATE,                                \
        (descriptor).pDeviceObject,                                           \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NV3_DMA_PUSH_MUTEX_STATE),                              \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NV3_DMA_PUSH_MUTEX_STATE),                              \
        FALSE,                                                                \
        NULL,                                                                 \
        NULL);                                                                \
    if (pIrp!=NULL)                                                           \
        ioStatus = IoCallDriver(                                              \
            (descriptor).pDeviceObject,                                       \
            pIrp);                                                            \
    if (pIrp==NULL || !NT_SUCCESS(ioStatus))                                  \
        (pParameters)->status = NV3_DMA_PUSH_MUTEX_STATE_STATUS_SUCCESS;      \
}
#endif

/* ioctl OS09 */

/* ioctl OS0A */

/* ioctl OS0B */

/* ioctl OS0C */

/* ioctl OS0D */

/* ioctl OS0E */

/* ioctl OS0F */



#ifdef __cplusplus
};
#endif
#endif /* NVOS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Basic Rectangles\render.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: render.c
*
*	Description:
*		This program blasts random rectangles to the frame buffer, using the NV SW architecture.
*
*	Basic NV SW architecture procedure:
*		- register the client
*		- allocate a device
*		- allocate a PIO channel
*		- allocate a DMA context for the frame buffer
*		- allocate and initialize a 2D rendering surface object
*		- allocate and initialize a rectangle rendering object
*		- draw rectangles to the screen
*
**************************************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <time.h>

// NV SDK include files
#include <nvos.h>
#include <nv32.h>
#include <nvrmapi.h>
#include <nvMacros.h>

// NV DDK include files
#include "nvcm.h"

#include "render.h"

int main()
{
	NV_STATUS status;
    ULONG hClient;
	Nv04ChannelPio* pChannel;
    SIZE sScreen;

    // register this client with the architecture
    if (NvRmAllocRoot(&hClient) != NV_STATUS_SUCCESS) 
    {
		return 1;
    }

	// initialize the client and draw rectangles
	if ((status = NvInitialize(hClient, "NV4", &pChannel, &sScreen)) == NV_STATUS_SUCCESS)
	{
		// draw rectangles thru the channel, to the screen
		status = NvDrawRectangles(pChannel, sScreen);
	}
	if (status != NV_STATUS_SUCCESS)
	{
		NvReportError(status);
	}

	// free up the client -- this frees all child objects
    NvRmFree(hClient, NV01_NULL_OBJECT, hClient);

	return 0;

} // end of main()

NV_STATUS NvInitialize(ULONG hClient, PUCHAR szDeviceType, Nv04ChannelPio** pChannel, SIZE* psScreen)
{
    CHAR nameBuffer[32];
	Nv04ChannelPio* channel;
	PUCHAR pFrameBuffer;
	ULONG frameBufferSize;
	SIZE screen;
    ULONG depth, pitch;

	// seed the random number generator for later use
	srand(time(NULL));

    // allocate the specified type of device
    if (
    	NvRmAllocDevice(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			NV01_DEVICE_0,              // device class
			(PUCHAR)nameBuffer          // returned device type
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_DEV;
    }
    if ((strcmp(nameBuffer, szDeviceType) != 0)) 
    { 
        return NV_STATUS_ERROR_DEV_TYPE;
    }

	// allocate a PIO channel to the device
    if (
    	NvRmAllocChannelPio(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			OUR_CHANNEL_ID,				// channel handle
			NV04_CHANNEL_PIO,			// channel class
			NV01_NULL_OBJECT,			// error context
			(PVOID*)pChannel,			// returned channel pointer
			0x00000000					// flags
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_CH_PIO;
    }
	channel = *pChannel;

	// create a DMA context that contains the frame buffer
	pFrameBuffer = NULL;
    if (
    	NvRmAllocMemory(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			OUR_FRAME_BUFFER_ID,		// memory handle
			NV01_MEMORY_LOCAL_USER,		// memory class
			0x00000000,					// flags
			(PVOID*)&pFrameBuffer,		// returned frame buffer pointer
			&frameBufferSize			// limit (size - 1) -- returns the frame buffer size
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_MEM;
    }
    if (
    	NvRmAllocContextDma(
    		hClient,					// client handle
			OUR_FRAME_BUFFER_CTX_ID,	// DMA context handle
			NV01_CONTEXT_DMA,			// DMA context class
			NVOS03_FLAGS_ACCESS_READ_WRITE,	// flags
			pFrameBuffer,				// pointer to DMA buffer
			frameBufferSize - 1			// limit (size - 1) of DMA buffer
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_CTX_DMA;
    }

	// allocate a 2D rendering surface
    if (
    	NvRmConfigGet(
			hClient,					// client handle
			OUR_DEVICE_ID,				// device handle
	    	NV_CFG_SCREEN_WIDTH,		// configuration attribute
			(PULONG)&psScreen->cx		// returned attribute value
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	screen.cx = psScreen->cx;
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_SCREEN_HEIGHT, 
			(PULONG)&psScreen->cy
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	screen.cy = psScreen->cy;
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_PIXEL_DEPTH, 
			&depth
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	if (
    	NvRmAllocObject(
    		hClient,					// client handle
			OUR_CHANNEL_ID,				// channel handle
			OUR_2D_RENDERING_SURFACE_ID,// object handle
			NV04_CONTEXT_SURFACES_2D	// object class
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	pitch = screen.cx * (depth / 8);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(WORKING_SUBCH), 5 * 4);	
	NV_SUBCHANNEL(WORKING_SUBCH).SetObject										= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageSource	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageDestin	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetColorFormat			= NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetPitch					= PACK_PITCH(pitch,pitch);

	// allocate a rectangle rendering object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_RECTANGLE_RENDERER_ID,
			NV04_RENDER_SOLID_RECTANGLE
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).SetObject										= OUR_RECTANGLE_RENDERER_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextSurface		= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetColorFormat		= NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;

	return NV_STATUS_SUCCESS;

} // end of NvInitialize()

// blasts rectangles to the entire screen
NV_STATUS NvDrawRectangles(Nv04ChannelPio* channel, SIZE sScreen)
{
	ULONG i, r, g, b;
	POINT org;
	SIZE ext;

	// render many arbitrary rectangles in the window
	for (i = 0; i < RECTANGLE_QTY; i++)
	{
		// get random rectangle parameters
		NvGetRandomRGB24Color(&r, &g, &b);
		org = NvGetRandomPoint(sScreen);
		ext = NvGetRandomExtent(sScreen);

		// send rendering methods thru the channel -- the size() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Color					= PACK_RGB24(r,g,b);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].point	= PACK_XY(org.x,org.y);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].size		= PACK_WH(ext.cx,ext.cy);
	}

	return NV_STATUS_SUCCESS;

} // end of NvDrawRectangles()

// returns random RGB values that define a color
void NvGetRandomRGB24Color(PULONG pr, PULONG pg, PULONG pb)
{
	*pr = rand() % MAX_8BIT_COLOR + 1;
	*pg = rand() % MAX_8BIT_COLOR + 1;
	*pb = rand() % MAX_8BIT_COLOR + 1;

} // end of NvGetRandomRGB24Color()

// returns a random point within the given limits
POINT NvGetRandomPoint(SIZE limit)
{
	POINT pt;
	pt.x = rand() % limit.cx;
	pt.y = rand() % limit.cy;
	return pt;

} // end of NvGetRandomPoint()

// returns a random size of a rectangle within the given limits
SIZE NvGetRandomExtent(SIZE limit)
{
	SIZE s;
	s.cx = rand() % limit.cx + 1;
	s.cy = rand() % limit.cy + 1;
	return s;

} // end of NvGetRandomExtent()

// displays an error string based on its error code
void NvReportError(ULONG errorCode)
{
	char errorText[80];

	switch(errorCode)
	{
		case NV_STATUS_ERROR:
			strcpy(errorText, "general error");
			break;
		case NV_STATUS_ERROR_ALLOC_DEV:
			strcpy(errorText, "cannot allocate device");
			break;
		case NV_STATUS_ERROR_DEV_TYPE:
			strcpy(errorText, "bad device type");
			break;
		case NV_STATUS_ERROR_ALLOC_CTX_DMA:
			strcpy(errorText, "cannot allocate DMA context");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_PIO:
			strcpy(errorText, "cannot allocate PIO channel");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_DMA:
			strcpy(errorText, "cannot allocate DMA channel");
			break;
		case NV_STATUS_ERROR_ALLOC_MEM:
			strcpy(errorText, "cannot allocate memory");
			break;
		case NV_STATUS_ERROR_ALLOC_OBJ:
			strcpy(errorText, "cannot allocate anobject");
			break;
		case NV_STATUS_ERROR_CONFIG_GET:
			strcpy(errorText, "cannot allocate get specified configuration");
			break;
	}
	printf("render: error: %s\n\n", errorText);

} // end of NvReportError()


// end of render.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\nv4\inc\nvWin32.h ===
#ifndef NVWIN32_INCLUDED
#define NVWIN32_INCLUDED
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for NvChannel typedef */
#endif

/***************************************************************************
 *                   NVIDIA-supplied routines                              *
 ***************************************************************************/

/***** Hardware access *****/

/*
 * NvOpen() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpen(char *);

/*
 * NvOpenDma() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpenDma(char *, int, int, int);

/*
 * NvClose() closes the channel to the chip and attempts to
 * clean up all objects created in that channel.
 */
extern int                  __stdcall NvClose(NvChannel *);

/***** Operating Environment routines *****/
/*
 * NvWait() waits to be "awakened" after requesting notification with
 * the NV_OS_NOTIFY_WILL_SLEEP style.
 * Note that in Windows 3.1 any Windows message will wake up the
 * application.
 */
extern int  __stdcall NvWait(NvChannel *);

/*
 * NvNotifyEvent() specifies a Windows event for NV to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_EVENT style.
 *    first parameter is the NvChannel
 *    second is the Ring0 Win32 event handle
 */
extern int  __stdcall NvNotifyEvent(NvChannel *, int);

/*
 * NvNotifyMsg() specifies a Windows message for NV1 to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_MESSAGE style.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvNotifyMsg(NvChannel *, int, int);

/*
 * NvAllocEvent() specifies a Windows event or callback for NV to send to the
 * application after requesting notifications with the
 * NV_OS_WRITE_THEN_AWAKEN style.
 *    first parameter is the NvChannel
 *    second is the object name
 *    third is the notify index
 *    fourth is the notify event type (NV_OS_EVENT_*)
 *    fifth is the lower 32bits of the 64bit event data
 *    sixth is the upper 32bits of the 64bit event data
 */
extern int  __stdcall NvAllocEvent(NvChannel *, int, int, int, int, int);

/*
 * NvErrorMsg() specifies a Windows message for NV to send to the
 * application upon detecting an error.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvErrorMsg(NvChannel *, int, int);

/*
 * Although Win32 applications have a flat address space, on the X86 
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
extern int  __stdcall NvGetFlatDataSelector(void);
extern int  __stdcall NvGetFlatCodeSelector(void);

/*
 * NvConfigVersion() returns an NV version number indicating the NV version.
 * The format of this is 0x00010206, where
 *  - 0x0001 is the chip architecture
 *  -   0x02 is the software release
 *  -   0x06 is the minor revision
 */
extern int  __stdcall NvConfigVersion(void);

#define NV_CHIP_ARCH(ver)   ((ver) >> 16)
#define NV_SW_RELEASE(ver)  (((ver) >> 8) & 0xFF)
#define NV_MINOR_REV(ver)   ((ver) & 0xFF)

/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** OS-dependent constants *****/

/* This posts a new architecture event */
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

/* This puts the process to sleep awaiting notification */
#define NV_OS_NOTIFY_WILL_SLEEP	   0x00000003

/* This puts a message in the client's message queue upon notification */
#define NV_OS_NOTIFY_MESSAGE	   0x00000002

/* This posts a Win32 event to the client upon notification */
#define NV_OS_NOTIFY_EVENT  	   0x00000004

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_VM_EVENT  	   0x00000005

/* Event Types */
#define NV_OS_EVENT_VXD_CALLBACK   0x00000000
#define NV_OS_EVENT_WIN32_EVENT    0x00000001
#define NV_OS_EVENT_VM_EVENT       0x00000002
#define NV_OS_EVENT_WIN32_MSG      0x00000003
#define NV_OS_EVENT_WIN16          0x00000004
#define NV_OS_EVENT_INVALID        0xFFFFFFFF


/***************************************************************************
 *                     OS Resource Strings                                 *
 ***************************************************************************/

/* Maximum length of an OS string (conservative, actual is about 24) */
#define NV_OS_MAX_NAME_LENGTH      32

/***** OS resource names for sources and sinks of samples *****/

/* for NV_VIDEO_SINK */
#define NV_OS_VIDEO_MONITOR        "CON:"

/* for NV_IMAGE_TO_VIDEO. The HWND window handle should replace %u */
#define NV_OS_CANVAS_WINDOW        "WND%u:"

/* for NV_AUDIO_SINK */
#define NV_OS_LINE_OUT_LEFT        "LIN:\\LEFT"
#define NV_OS_LINE_OUT_RIGHT       "LIN:\\RIGHT"

/* for NV_AUDIO_SOURCE */
#define NV_OS_LINE_IN_LEFT         "LIN:\\LEFT"
#define NV_OS_LINE_IN_RIGHT        "LIN:\\RIGHT"
#define NV_OS_MIC_IN_LEFT          "MIC:\\LEFT"
#define NV_OS_MIC_IN_RIGHT         "MIC:\\RIGHT"


/***** Many devices can provide samples for NV_GAME_PORT_SOURCE *****/

/* Raw potentiometer data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 8 channels (0-7) replaces %d */
/* NOTE: The NV_OS_POT O/S string changed to "POTA%d:". The 2.0 and higher
 * Resource Manager will generate NV_ERROR1_NO_SUCH_OBJECT if there is no 
 * joystick connected. This string means nothing to the 1.20 Resource Manager.
 * For backwards compatibility, use NV_OS_GAME_PORT ("POT%d:"): both the 2.0 
 * and 1.20 Resource Manager will not generate an error if no joystick is
 * connected.
 */
#define NV_OS_POT                      "POTA%d:"
/* XXX Old name preserved for compatibility, use NV_OS_POT */
#define NV_OS_GAME_PORT                "POT%d:"


/* Calibrated joystick data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_JOYSTICK_BUTTONS         "JOY%d:\\BUTTONS"

#define NV_OS_JOYSTICK_BUTTON_TRIGGER  0x0001
#define NV_OS_JOYSTICK_BUTTON_SELECT   0x0002
#define NV_OS_JOYSTICK_BUTTON_A        0x0004
#define NV_OS_JOYSTICK_BUTTON_B        0x0008

#define NV_OS_JOYSTICK_X_AXIS          "JOY%d:\\X_AXIS"
#define NV_OS_JOYSTICK_Y_AXIS          "JOY%d:\\Y_AXIS"


/* Pedal data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_PEDALS                   "PEDALS%d:"


/* Throttle data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_THROTTLE                 "THROTTLE%d:"


/* 8-button game pad data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_PAD_BUTTONS              "PAD%d:"
/* XXX Old name preserved for compatibility, use NV_OS_PAD_BUTTONS */
#define NV_OS_PAD                      "PAD%d:"

#define NV_OS_PAD_BUTTON_START         0x0001
#define NV_OS_PAD_BUTTON_RIGHT         0x0002
#define NV_OS_PAD_BUTTON_LEFT          0x0004
#define NV_OS_PAD_BUTTON_UP            0x0008
#define NV_OS_PAD_BUTTON_DOWN          0x0010
#define NV_OS_PAD_BUTTON_A             0x0020
#define NV_OS_PAD_BUTTON_B             0x0040
#define NV_OS_PAD_BUTTON_C             0x0080
#define NV_OS_PAD_BUTTON_X             0x0100
#define NV_OS_PAD_BUTTON_Y             0x0200
#define NV_OS_PAD_BUTTON_Z             0x0400
#define NV_OS_PAD_BUTTON_TOP_RIGHT     0x0800
#define NV_OS_PAD_BUTTON_TOP_LEFT      0x1000


/* 3-axis yoke data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_YOKE_BUTTONS             "YOKE%d:\\BUTTONS"

#define NV_OS_YOKE_BUTTON_START        0x0001
#define NV_OS_YOKE_BUTTON_RIGHT        0x0002
#define NV_OS_YOKE_BUTTON_LEFT         0x0004
#define NV_OS_YOKE_BUTTON_UP           0x0008
#define NV_OS_YOKE_BUTTON_DOWN         0x0010
#define NV_OS_YOKE_BUTTON_A            0x0020
#define NV_OS_YOKE_BUTTON_B            0x0040
#define NV_OS_YOKE_BUTTON_C            0x0080
#define NV_OS_YOKE_BUTTON_X            0x0100
#define NV_OS_YOKE_BUTTON_Y            0x0200
#define NV_OS_YOKE_BUTTON_Z            0x0400
#define NV_OS_YOKE_BUTTON_TOP_RIGHT    0x0800
#define NV_OS_YOKE_BUTTON_TOP_LEFT     0x1000

#define NV_OS_YOKE_X_AXIS              "YOKE%d:\\X_AXIS"
#define NV_OS_YOKE_Y_AXIS              "YOKE%d:\\Y_AXIS"
#define NV_OS_YOKE_Z_AXIS              "YOKE%d:\\Z_AXIS"

/* 2-axis gun position data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* The HWND window handle should replace %u */
#define NV_OS_GUN_BUTTONS              "GUN%dWND%u:\\BUTTONS"

#define NV_OS_GUN_BUTTON_START         0x0001
#define NV_OS_GUN_BUTTON_TRIGGER	   0x0002

#define NV_OS_GUN_X_POSITION		   "GUN%dWND%u:\\X_POS"
#define NV_OS_GUN_Y_POSITION		   "GUN%dWND%u:\\Y_POS"

/* Value returned if gun is still determing X/Y coordinate */
#define NV_OS_GUN_POSITION_COUNTING    0xFFFE
/* Value returned if gun is off screen or outside canvas) */
#define NV_OS_GUN_POSITION_OFF_SCREEN  0xFFFF

/***** WATCOM special handling *****/
/* WATCOM 10.0 compiler needs special declaration of these functions */
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvOpen "*";
#pragma aux (__stdcall) NvClose "*";
#pragma aux (__stdcall) NvWait "*";
#pragma aux (__stdcall) NvNotifyMsg "*";
#pragma aux (__stdcall) NvErrorMsg "*";
#pragma aux (__stdcall) NvGetFlatDataSelector "*";
#pragma aux (__stdcall) NvGetFlatCodeSelector "*";
#pragma aux (__stdcall) NvVpeExtras "*";
#pragma aux (__stdcall) NvDmaPushOperation "*";
#ifdef VPE_EXTRAS
#pragma aux (__stdcall) NvOverlayExtras "*";
#endif

#ifdef _WIN32  // don't do this for the DOS compile!!
#pragma aux (__stdcall) NvConfigVersion "*";
#endif
#endif /* __WATCOMC__ */

#ifdef __cplusplus
};
#endif
#endif /* NVWIN32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Windowed Rectangles.rc
//
#define IDC_MYICON                      2
#define IDD_WINDOWEDRECTANGLES_DIALOG   102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_WINDOWEDRECTANGLES          107
#define IDI_SMALL                       108
#define IDC_WINDOWEDRECTANGLES          109
#define IDS_RECTANGLE                   111
#define IDR_MAINFRAME                   128
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\nvclient.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: nvclient.c
*
*	Description:
*		This program renders random rectangles to a window, using the NV SW architecture.
*	This is the same as the Basic Rectangles project, except that a clip rectangle object is
*	allocated and attached to the rectangle render object, and the functions are rearranged
*	to fit into the windows programming model.
*
*		functions:
*
*			NvCreate():
*				- allocate a client
*				- allocate a device
*				- allocate a PIO channel
*				- allocate a DMA context for the frame buffer
*				- allocate and initialize a 2D rendering surface object
*				- allocate a clip rectangle object
*				- allocate and initialize the rendering objects
*
*			NvDrawRectangles()
*				- set the clip rectangle of the window
*				- draw rectangles by sending appropriate methods to the rectangle renderer
*
*			NvDestroy()
*				- free the client
*
**************************************************************************************************/

#include "stdafx.h"

// globals 
extern TCHAR szTitle[];
Nv04ChannelPio* channel;
ULONG hClient;
SIZE screen;

// creates the client when the window is created
NV_STATUS NvCreate()
{
    CHAR nameBuffer[32];
	PUCHAR pFrameBuffer;
	ULONG frameBufferSize;
    ULONG depth, pitch;

	// seed the random number generator for later use
	srand(time(NULL));

    // register this client with the architecture -- returns a client handle
    if (NvRmAllocRoot(&hClient) != NV_STATUS_SUCCESS) 
    {
        return NV_STATUS_ERROR_ALLOC_CLIENT;
    }

    // allocate the specified type of device
    if (
    	NvRmAllocDevice(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			NV01_DEVICE_0,              // device class
			(PUCHAR)nameBuffer          // returned device type
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_DEV;
    }
    if ((strcmp(nameBuffer, "NV4") != 0)) 
    { 
        return NV_STATUS_ERROR_DEV_TYPE;
    }

	// allocate a PIO channel to the device
    if (
    	NvRmAllocChannelPio(
    		hClient,                    // client handle
			OUR_DEVICE_ID,              // device handle
			OUR_CHANNEL_ID,				// new channel handle
			NV04_CHANNEL_PIO,			// new channel class
			NV01_NULL_OBJECT,			// new channel error context
			(PVOID*)&channel,			// returned channel pointer
			0x00000000					// flags
        ) != NV_STATUS_SUCCESS
	)
	{
        return NV_STATUS_ERROR_ALLOC_CH_PIO;
    }

	// create a DMA context that contains the frame buffer
	pFrameBuffer = NULL;
    if (
    	NvRmAllocMemory(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			OUR_FRAME_BUFFER_ID,		// memory handle
			NV01_MEMORY_LOCAL_USER,		// memory class
			0x00000000,					// flags
			(PVOID*)&pFrameBuffer,		// returned frame buffer pointer
			&frameBufferSize			// limit (size - 1) -- returns the frame buffer size
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_MEM;
    }
    if (
    	NvRmAllocContextDma(
    		hClient,					// client handle
			OUR_FRAME_BUFFER_CTX_ID,	// DMA context handle
			NV01_CONTEXT_DMA,			// DMA context class
			NVOS03_FLAGS_ACCESS_READ_WRITE,	// flags
			pFrameBuffer,				// pointer to DMA buffer
			frameBufferSize - 1			// limit (size - 1) of DMA buffer
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_CTX_DMA;
    }

	// allocate a 2D rendering surface
    if (
    	NvRmConfigGet(
			hClient,					// client handle
			OUR_DEVICE_ID,				// device handle
	    	NV_CFG_SCREEN_WIDTH,		// configuration attribute
			(PULONG)&screen.cx			// returned attribute value
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_SCREEN_HEIGHT, 
			(PULONG)&screen.cy
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_PIXEL_DEPTH, 
			&depth
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	if (
    	NvRmAllocObject(
    		hClient,					// client handle
			OUR_CHANNEL_ID,				// channel handle
			OUR_2D_RENDERING_SURFACE_ID,// object handle
			NV04_CONTEXT_SURFACES_2D	// object class
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	pitch = screen.cx * (depth / 8);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(WORKING_SUBCH), 5 * 4);	
	NV_SUBCHANNEL(WORKING_SUBCH).SetObject										= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageSource	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageDestin	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetColorFormat			= NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetPitch					= PACK_PITCH(pitch,pitch);

	// allocate and initialize a clip rectangle object
	if (
		NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_CLIP_RECTANGLE_ID,
			NV01_CONTEXT_CLIP_RECTANGLE
        ) != NV_STATUS_SUCCESS
	) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 1 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).SetObject = OUR_CLIP_RECTANGLE_ID;

	// allocate a rectangle rendering object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_RECTANGLE_RENDERER_ID,
			NV04_RENDER_SOLID_RECTANGLE
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 4 * 4);	
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).SetObject											= OUR_RECTANGLE_RENDERER_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextSurface			= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextClipRectangle	= OUR_CLIP_RECTANGLE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetColorFormat			= NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;

    return NV_STATUS_SUCCESS;

} // end of NvCreate()

// renders many arbitrary rectangles to the window
NV_STATUS NvDrawRectangles(HWND hWnd)
{
	// set the current clip rectangle to be the same as the window's client
	NV_RECT rClip = NvGetClientNvRect(hWnd);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 2 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetPoint	= PACK_XY(rClip.org.x, rClip.org.y);
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetSize		= PACK_WH(rClip.ext.cx, rClip.ext.cy);

	// render many arbitrary rectangles in the window
	ULONG r, g, b;
	NV_RECT rect;
	for (int i = 0; i < RECTANGLE_QTY; i++)
	{
		// get random rectangle parameters
		NvGetRandomRGB24Color(&r, &g, &b);
		rect.org = NvGetRandomPoint(screen);
		rect.ext = NvGetRandomExtent(screen);

		// send rendering methods thru the channel -- the size() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Color					= PACK_RGB24(r,g,b);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].point	= PACK_XY(rect.org.x,rect.org.y);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].size		= PACK_WH(rect.ext.cx,rect.ext.cy);
	}

    return NV_STATUS_SUCCESS;

} // end of NvDrawRectangles()

void NvDestroy()
{
	// return the client and all child object resources to the system
    NvRmFree(hClient, NV01_NULL_OBJECT, hClient);

} // end of NvDestroy()

// returns an NV rectangle that describes the screen-relative window's client
NV_RECT NvGetClientNvRect(HWND hWnd)
{
	RECT rClient;
	GetClientRect(hWnd, &rClient);
	NvClientToScreenRect(hWnd, &rClient);
	NV_RECT nvrClient;
	nvrClient.org.x = rClient.left;
	nvrClient.org.y = rClient.top;
	nvrClient.ext.cx = rClient.right - rClient.left;
	nvrClient.ext.cy = rClient.bottom - rClient.top;
	return nvrClient;

} // end of NvGetClientNvRect()

// converts a client-relative rectangle to a screen-relative rectangle 
void NvClientToScreenRect(HWND hWnd, RECT* pRect)
{
	POINT ptUpperLeft, ptLowerRight;

	// convert into points
	ptUpperLeft.x	= pRect->left;
	ptUpperLeft.y	= pRect->top;
	ptLowerRight.x	= pRect->right;
	ptLowerRight.y	= pRect->bottom;

	// call windows API to convert from client coords to screen coords
	ClientToScreen(hWnd, &ptUpperLeft);
	ClientToScreen(hWnd, &ptLowerRight);

	// recreate the transformed rectangle
	pRect->left		= ptUpperLeft.x;
	pRect->top		= ptUpperLeft.y;
	pRect->right	= ptLowerRight.x;
	pRect->bottom	= ptLowerRight.y;

} // end of NvClientToScreenRect()

// returns random RGB values that define a color
void NvGetRandomRGB24Color(PULONG pr, PULONG pg, PULONG pb)
{
	*pr = rand() % MAX_8BIT_COLOR + 1;
	*pg = rand() % MAX_8BIT_COLOR + 1;
	*pb = rand() % MAX_8BIT_COLOR + 1;

} // end of NvGetRandomRGB24Color()

// returns a random point within the given limits
POINT NvGetRandomPoint(SIZE limit)
{
	POINT pt;
	pt.x = rand() % limit.cx;
	pt.y = rand() % limit.cy;
	return pt;

} // end of NvGetRandomPoint()

// returns a random size of a rectangle within the given limits
SIZE NvGetRandomExtent(SIZE limit)
{
	SIZE s;
	s.cx = rand() % limit.cx + 1;
	s.cy = rand() % limit.cy + 1;
	return s;

} // end of NvGetRandomExtent()

// displays an error message box based on its error code
void NvReportError(ULONG errorCode)
{
	char errorText[80];

	switch(errorCode)
	{
		case NV_STATUS_ERROR:
			strcpy(errorText, "Error: general error");
			break;
		case NV_STATUS_ERROR_ALLOC_DEV:
			strcpy(errorText, "Error: cannot allocate device");
			break;
		case NV_STATUS_ERROR_DEV_TYPE:
			strcpy(errorText, "Error: unavailable requested NV device type");
			break;
		case NV_STATUS_ERROR_ALLOC_CTX_DMA:
			strcpy(errorText, "Error: cannot allocate DMA context");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_PIO:
			strcpy(errorText, "Error: cannot allocate PIO channel");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_DMA:
			strcpy(errorText, "Error: cannot allocate DMA channel");
			break;
		case NV_STATUS_ERROR_ALLOC_MEM:
			strcpy(errorText, "Error: cannot allocate memory");
			break;
		case NV_STATUS_ERROR_ALLOC_OBJ:
			strcpy(errorText, "Error: cannot allocate anobject");
			break;
		case NV_STATUS_ERROR_CONFIG_GET:
			strcpy(errorText, "Error: cannot allocate get specified configuration");
			break;
	}
	MessageBox(NULL, errorText, szTitle, MB_OK);

} // end of NvReportError()


// end of nvclient.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Basic Rectangles\render.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: render.h
*
*	Description:
*		Definitions and prototypes for render.c.
*
**************************************************************************************************/

// additional SDK macros
#define NV_SUBCHANNEL(n)				(channel->subchannel[n])
#define WAIT_FOR_SUBCHANNEL(psc,nBytes)	while((psc)->control.Free<(nBytes))
#define PACK_PITCH(s,d)					((V032)((((U032)(d))<<16)|(((U032)(s))&0x0000FFFF)))

// 32bit IDs of our choice to track our allocated objects
enum
{
	OUR_DEVICE_ID = 0xBAAD0000,
	OUR_CHANNEL_ID,
	OUR_FRAME_BUFFER_ID,
	OUR_FRAME_BUFFER_CTX_ID,
	OUR_2D_RENDERING_SURFACE_ID,
	OUR_RECTANGLE_RENDERER_ID
};

// subchannel definitions
enum
{
	WORKING_SUBCH = 0,
	RECT_RENDER_SUBCH
};

// errors
typedef ULONG NV_STATUS;
enum 
{
	NV_STATUS_SUCCESS = 0,
	NV_STATUS_ERROR,
	NV_STATUS_ERROR_ALLOC_DEV,
	NV_STATUS_ERROR_DEV_TYPE,
	NV_STATUS_ERROR_ALLOC_CTX_DMA,
	NV_STATUS_ERROR_ALLOC_CH_PIO,
	NV_STATUS_ERROR_ALLOC_CH_DMA,
	NV_STATUS_ERROR_ALLOC_MEM,
	NV_STATUS_ERROR_ALLOC_OBJ,
	NV_STATUS_ERROR_CONFIG_GET
};

// drawing constants
#define MAX_8BIT_COLOR 0xff
#define RECTANGLE_QTY 5000

// rectangle definition consisting of an origin and an extent
struct NV_RECT
{
	POINT org;
	SIZE ext;
};

// prototypes
NV_STATUS NvInitialize(ULONG, PUCHAR, Nv04ChannelPio**, SIZE*);
NV_STATUS NvDrawRectangles(Nv04ChannelPio*, SIZE);
void NvGetRandomRGB24Color(PULONG, PULONG, PULONG);
POINT NvGetRandomPoint(SIZE);
SIZE NvGetRandomExtent(SIZE);
void NvReportError(ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\DDK32\main.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//
// Sample configuration application.
//
// This simple program is meant to show how to access the NVIDIA configuration interface.
// The NVIDIA configuration interface allows client applications to read and modify select
// operating values within an NV device.
//
// The steps are:
//  1) Open an interface to the resource manager
//  2) Register the calling application by allocating a client
//  3) Find and identify the devices in the system by allocating a device and giving it a name.
//  4) Get and set device attributes, using the device's name.
//
// This program links with a library to provide simple wrapper routines
// for the resource manager's IOCTL interface.  This hides the complexity of 
// the Win32 IOCTL interfaces.
//
// LINKER NOTE:  You must set /nodefaultlib:"LIBC" in the link options, when using VC++.
//
//  NVRMAPI.LIB (SDK Library for Win32 clients)
//
// IMPORTANT: There are currently different libraries and include file versions
// for NV3 and NV4.  Make sure you use the copies meant for the chip you are
// using.
//
#include <windows.h>
#include <stdio.h>
#include <conio.h>

//
// NV SDK include files
//
#include "nvos.h"
#include "nv32.h"
#include "nvrmapi.h"

//
// NV DDK include files
//
#include "nvcm.h"

//
// A 32bit ID of our choice to track our allocated device (SDK)
//
#define OUR_DEVICE_ID	0xBAAD0000

int main()
{

    char            nameBuffer[32];
    unsigned long   hRm, hClient;
    int             val;

    //
    // Open up a connection to the resource manager
    //
    printf("Opening a connection to the resource manager...\n");
    hRm = (unsigned long)NvRmOpen();

    //
    // Register this client with the architecture
    //
    printf("Allocating a client...\n");
    if (NvRmAllocRoot(&hClient) != NVOS01_STATUS_SUCCESS) 
    {
        //
        // oops, an error.  Close it all back down.
        //
        printf("ERROR: Cannot allocate client.\n");
        NvRmClose();
        getch();
        return 1;
    }

    //
    // Allocate a device.  For Microsoft operating systems, the
    // OS notion of a display device is DisplayX, where X is an
    // one-based integer.  Display1 would be considered the
    // primary display in most cases.
    //
    // NV Architecture defines up to 8 devices.  They are defined
    // in the order in which they're initialized by the operating
    // system, starting at zero.  So, DEVICE_0 will usually 
	// correlate to Display1.  And so on.
    //
    // This allocation call is only necessary to determine the
    // exact type of NV device (NV3, NV4, etc).
    //
    // Let's just get the primary device.
    //
    printf("Allocating a device...\n");
    if (
    	NvRmAllocDevice(
    		hClient,                    // client handle
			OUR_DEVICE_ID,              // device name
			NV01_DEVICE_0,              // device class
			(void *)nameBuffer          // returned device type
        ) != NVOS06_STATUS_SUCCESS
    ) 
	{
        //
        // oops, an error.  Close it all back down.
        //
        printf("ERROR: Cannot allocate device.\n");
        NvRmFree(hClient, NV01_NULL_OBJECT, hClient);
        NvRmClose();
        getch();
        return 1;
    }

    //
    // Make sure this is an NV4 device...
    //
    printf("Verifying NV4 device...\n");
    if ((strcmp(nameBuffer, "NV4") != 0)) 
    { 
    	//
    	// oops, an error.  Close it all back down.
    	//
    	printf("ERROR: Not an NV4 device: %s.\n", nameBuffer);
    	NvRmFree(hClient, NV01_NULL_OBJECT, hClient);
        NvRmClose();
    	getch();
        return 1;
    }
    printf("...Found an NV4 device.\n");

    //
    // Config "get" calls are meant to return the current attributes
	// of a specific chip instance.  We've already allocated and named a
	// chip, so we use that name to extract the values.
    //
	// The general form of the NvRmConfigGet() function is as follows:
	//
	// 	NvRmConfigGet(
	// 		client_handle, 
	// 		device_name,   
	// 		attribute_name,
	// 		&returned_value
	// 	);

    //
    // Get some device attributes.
    //
    printf("Getting bus type...\n");
    if (
    	NvRmConfigGet(
			hClient,			  
			OUR_DEVICE_ID,		  
	    	NV_CFG_BUS_TYPE, 	  
			&val				  
	    ) != NVOS13_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not get the bus type.\n");
    }
	else
		printf("Bus Type: %u\n", val);

    printf("Getting current framebuffer size...\n");
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_RAM_SIZE_MB, 
			&val
	    ) != NVOS13_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not get frame buffer size.\n");
    }
	else
		printf("Framebuffer Size: %u MB\n", val);

    printf("Getting current value of CRTC register CR09...\n");
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_CRTC + 0x09, 
			&val
	    ) != NVOS13_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not get current value of CRTC register CR09.\n");
    }
	else
		printf("CR09: %02X\n", val);

    //
    // Config "set" calls are meant to override the current attributes
	// of a specific chip instance.
    //
	// The general form of the NvRmConfigSet() function is as follows:
	//
	// 	NvRmConfigSet(
	// 		client_handle, 
	// 		device_name,   
	// 		attribute_name,
	//		new_value,
	// 		&returned_old_value
	// 	);
	//
    // NvRmConfigSet calls are batched up until a NvRmConfigUpdate() call is made.
    // This allows us to set multiple interdependent values before the
    // override takes place.
    //
    // NvRmConfigUpdate(client_handle, device_name, NV_CFG_PERMANENT);
    //
    // WARNING: Most system settings cannot be overridden.  If a value can
    // be changed, it usually requires coordination with the display
    // driver.  For example, changing the system resolution requires
    // a reenable of the display driver to the new settings.
    //
	
    printf("Setting new refresh rate...\n");
    if (
    	NvRmConfigSet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_VIDEO_REFRESH_RATE, 
			60,
			&val
	    ) != NVOS14_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not set refresh rate.\n");
    }
    printf("Old refresh rate: %d\n", val);
    if (
    	NvRmConfigUpdate(
    		hClient, 
    		OUR_DEVICE_ID, 
    		NV_CFG_PERMANENT
    	) != NVOS15_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not update the device attributes.\n");
    }
	

    //
    // Close everything up
    //
    printf("Freeing the client and device...\n");
    NvRmFree(hClient, NV01_NULL_OBJECT, hClient);
    printf("Disconnecting from the resource manager...\n");
    NvRmClose();

    getch();

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\nvclient.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: nvclient.h
*
*	Description:
*		Definitions and prototypes for nvclient.cpp.
*
**************************************************************************************************/

// additional SDK macros
#define NV_SUBCHANNEL(n)				(channel->subchannel[n])
#define WAIT_FOR_SUBCHANNEL(psc,nBytes)	while((psc)->control.Free<(nBytes))
#define PACK_PITCH(s,d)					((V032)((((U032)(d))<<16)|(((U032)(s))&0x0000FFFF)) )

// 32bit IDS of our choice to track our allocated objects
enum
{
	OUR_DEVICE_ID = 0xBAAD0000,
	OUR_CHANNEL_ID,
	OUR_FRAME_BUFFER_ID,
	OUR_FRAME_BUFFER_CTX_ID,
	OUR_2D_RENDERING_SURFACE_ID,
	OUR_RECTANGLE_RENDERER_ID,
	OUR_CLIP_RECTANGLE_ID
};

// subchannel definitions
enum
{
	WORKING_SUBCH = 0,
	RECT_RENDER_SUBCH,
	CLIP_RECT_SUBCH,
};

// errors
typedef ULONG NV_STATUS;
enum 
{
	NV_STATUS_SUCCESS = 0,
	NV_STATUS_ERROR,
	NV_STATUS_ERROR_ALLOC_DEV,
	NV_STATUS_ERROR_DEV_TYPE,
	NV_STATUS_ERROR_ALLOC_CTX_DMA,
	NV_STATUS_ERROR_ALLOC_CH_PIO,
	NV_STATUS_ERROR_ALLOC_CH_DMA,
	NV_STATUS_ERROR_ALLOC_MEM,
	NV_STATUS_ERROR_ALLOC_OBJ,
	NV_STATUS_ERROR_CONFIG_GET,
	NV_STATUS_ERROR_ALLOC_CLIENT
};

// drawing constants
#define MAX_8BIT_COLOR 0xff
#define RECTANGLE_QTY 5000

// rectangle definition consisting of an origin and an extent
struct NV_RECT
{
	POINT org;
	SIZE ext;
};

// prototypes
NV_STATUS NvCreate();
NV_STATUS NvDrawRectangles(HWND);
void NvDestroy();
NV_RECT NvGetClientNvRect(HWND);
void NvClientToScreenRect(HWND, RECT*);
void NvGetRandomRGB24Color(PULONG, PULONG, PULONG);
POINT NvGetRandomPoint(SIZE);
SIZE NvGetRandomExtent(SIZE);
void NvReportError(ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\StdAfx.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//	Windowed Rectangles.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\nvclient.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: nvclient.c
*
*	Description:
*		This program renders random shapes to a window, using the NV SW architecture.
*	This is the same as the Windows Rectangles project, with the addition of being able to
*	draw lines and BLITs.  Drawing is now controled thru the menu.
*
*		functions:
*
*			NvCreate():
*				- allocate a client
*				- allocate a device
*				- allocate a PIO channel
*				- allocate a DMA context for the frame buffer
*				- allocate and initialize a 2D rendering surface object
*				- allocate a clip rectangle object
*				- allocate and initialize the rendering objects
*
*			NvDraw..()
*				- set the clip rectangle of the window
*				- draw rectangles by sending appropriate methods to the rectangle renderer
*
*			NvDestroy()
*				- free the client
*
**************************************************************************************************/

#include "stdafx.h"
#include "resource.h"

// globals 
extern HINSTANCE hInst;
extern TCHAR szTitle[];
Nv04ChannelPio* channel;
ULONG hClient;
SIZE screen;

// creates the client when the window is created
NV_STATUS NvCreate()
{
    CHAR nameBuffer[32];
	PUCHAR pFrameBuffer;
	ULONG frameBufferSize;
    ULONG depth, pitch;

	// seed the random number generator for later use
	srand(time(NULL));

    // register this client with the architecture -- returns a client handle
    if (NvRmAllocRoot(&hClient) != NV_STATUS_SUCCESS) 
    {
        return NV_STATUS_ERROR_ALLOC_CLIENT;
    }

    // allocate the specified type of device
    if (
    	NvRmAllocDevice(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			NV01_DEVICE_0,              // device class
			(PUCHAR)nameBuffer          // returned device type
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_DEV;
    }
    if ((strcmp(nameBuffer, "NV4") != 0)) 
    { 
        return NV_STATUS_ERROR_DEV_TYPE;
    }

	// allocate a PIO channel to the device
    if (
    	NvRmAllocChannelPio(
    		hClient,                    // client handle
			OUR_DEVICE_ID,              // device handle
			OUR_CHANNEL_ID,				// new channel handle
			NV04_CHANNEL_PIO,			// new channel class
			NV01_NULL_OBJECT,			// new channel error context
			(PVOID*)&channel,			// returned channel pointer
			0x00000000					// flags
        ) != NV_STATUS_SUCCESS
	)
	{
        return NV_STATUS_ERROR_ALLOC_CH_PIO;
    }

	// create a DMA context that contains the frame buffer
	pFrameBuffer = NULL;
    if (
    	NvRmAllocMemory(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			OUR_FRAME_BUFFER_ID,		// memory handle
			NV01_MEMORY_LOCAL_USER,		// memory class
			0x00000000,					// flags
			(PVOID*)&pFrameBuffer,		// returned frame buffer pointer
			&frameBufferSize			// limit (size - 1) -- returns the frame buffer size
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_MEM;
    }
    if (
    	NvRmAllocContextDma(
    		hClient,					// client handle
			OUR_FRAME_BUFFER_CTX_ID,	// DMA context handle
			NV01_CONTEXT_DMA,			// DMA context class
			NVOS03_FLAGS_ACCESS_READ_WRITE,	// flags
			pFrameBuffer,				// pointer to DMA buffer
			frameBufferSize - 1			// limit (size - 1) of DMA buffer
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_CTX_DMA;
    }

	// allocate a 2D rendering surface
    if (
    	NvRmConfigGet(
			hClient,					// client handle
			OUR_DEVICE_ID,				// device handle
	    	NV_CFG_SCREEN_WIDTH,		// configuration attribute
			(PULONG)&screen.cx			// returned attribute value
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_SCREEN_HEIGHT, 
			(PULONG)&screen.cy
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_PIXEL_DEPTH, 
			&depth
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	if (
    	NvRmAllocObject(
    		hClient,					// client handle
			OUR_CHANNEL_ID,				// channel handle
			OUR_2D_RENDERING_SURFACE_ID,// object handle
			NV04_CONTEXT_SURFACES_2D	// object class
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	pitch = screen.cx * (depth / 8);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(WORKING_SUBCH), 5 * 4);	
	NV_SUBCHANNEL(WORKING_SUBCH).SetObject										= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageSource	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageDestin	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetColorFormat			= NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetPitch					= PACK_PITCH(pitch,pitch);

	// allocate and initialize a clip rectangle object
	if (
		NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_CLIP_RECTANGLE_ID,
			NV01_CONTEXT_CLIP_RECTANGLE
        ) != NV_STATUS_SUCCESS
	) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 1 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).SetObject = OUR_CLIP_RECTANGLE_ID;

	// allocate a rectangle rendering object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_RECTANGLE_RENDERER_ID,
			NV04_RENDER_SOLID_RECTANGLE
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 4 * 4);	
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).SetObject											= OUR_RECTANGLE_RENDERER_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextSurface			= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextClipRectangle	= OUR_CLIP_RECTANGLE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetColorFormat			= NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;

	// allocate and initialize a line rendering object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_LINE_RENDERER_ID,
			NV04_RENDER_SOLID_LIN
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(LINE_RENDER_SUBCH), 4 * 4);	
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).SetObject									= OUR_LINE_RENDERER_ID;
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.SetContextSurface		= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.SetContextClipRectangle	= OUR_CLIP_RECTANGLE_ID;
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.SetColorFormat			= NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8;

	// allocate and initialize a BLIT object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_BLIT_ID,
			NV04_IMAGE_BLIT
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(BLIT_SUBCH), 3 * 4);	
	NV_SUBCHANNEL(BLIT_SUBCH).SetObject								= OUR_BLIT_ID;
	NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.SetContextSurfaces		= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.SetContextClipRectangle	= OUR_CLIP_RECTANGLE_ID;

    return NV_STATUS_SUCCESS;

} // end of NvCreate()

// renders many arbitrary lines to the window
NV_STATUS NvDrawLines(HWND hWnd)
{
	// set the current clip rectangle to be the same as the window's client
	NV_RECT rClip = NvGetClientNvRect(hWnd);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 2 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetPoint	= PACK_XY(rClip.org.x, rClip.org.y);
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetSize		= PACK_WH(rClip.ext.cx, rClip.ext.cy);

	// render many arbitrary lines in the window
	ULONG r, g, b;
	POINT start, end;
	for (int i = 0; i < LINE_QTY; i++)
	{
		// get random line parameters
		NvGetRandomRGB24Color(&r, &g, &b);
		start = NvGetRandomPoint(screen);
		end = NvGetRandomPoint(screen);

		// send rendering methods thru the channel -- the point1() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(LINE_RENDER_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Color			= PACK_RGB24(r,g,b);
		NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point0	= PACK_XY(start.x, start.y);
		NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point1	= PACK_XY(end.x, end.y);

		// display a caption
		NvDisplayCaption(hWnd, IDS_LINE, rClip);
	}

    return NV_STATUS_SUCCESS;

} // end of NvDrawLines()

// renders many arbitrary rectangles to the window
NV_STATUS NvDrawRectangles(HWND hWnd)
{
	// set the current clip rectangle to be the same as the window's client
	NV_RECT rClip = NvGetClientNvRect(hWnd);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 2 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetPoint	= PACK_XY(rClip.org.x, rClip.org.y);
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetSize		= PACK_WH(rClip.ext.cx, rClip.ext.cy);

	// render many arbitrary rectangles in the window
	ULONG r, g, b;
	NV_RECT rect;
	for (int i = 0; i < RECTANGLE_QTY; i++)
	{
		// get random rectangle parameters
		NvGetRandomRGB24Color(&r, &g, &b);
		rect.org = NvGetRandomPoint(screen);
		rect.ext = NvGetRandomExtent(screen);

		// send rendering methods thru the channel -- the size() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Color					= PACK_RGB24(r,g,b);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].point	= PACK_XY(rect.org.x,rect.org.y);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].size		= PACK_WH(rect.ext.cx,rect.ext.cy);

		// display a caption
		NvDisplayCaption(hWnd, IDS_RECTANGLE, rClip);
	}

    return NV_STATUS_SUCCESS;

} // end of NvDrawRectangles()

// bounce a rectangular portion of the window client around the window, to demonstrate BLITs
NV_STATUS NvBlits(HWND hWnd)
{
	// set the current clip rectangle to be the same as the window's client
	NV_RECT rClip = NvGetClientNvRect(hWnd);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 2 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetPoint	= PACK_XY(rClip.org.x, rClip.org.y);
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetSize		= PACK_WH(rClip.ext.cx, rClip.ext.cy);

	// init and render the source of the BLIT
	NV_RECT blitSrc = rClip;
	blitSrc.ext.cx /= 2;
	blitSrc.ext.cy = blitSrc.ext.cy * 2 / 10;
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Color					= PACK_RGB24(0xff,0x00,0x00);
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].point	= PACK_XY(blitSrc.org.x + 1,blitSrc.org.y + 1);
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].size		= PACK_WH(blitSrc.ext.cx - 2,blitSrc.ext.cy - 2);
	NvDisplayCaption(hWnd, IDS_BLIT_PATTERN, blitSrc);

	// draw a line around and between the source and the display boundary
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(LINE_RENDER_SUBCH), 6 * 4);	
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Color			= PACK_RGB24(0x00,0x00,0x00);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point0	= PACK_XY(rClip.org.x, rClip.org.y + blitSrc.ext.cy);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point1	= PACK_XY(rClip.org.x + rClip.ext.cx, rClip.org.y + blitSrc.ext.cy);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Color			= PACK_RGB24(0x00,0x00,0x00);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point0	= PACK_XY(rClip.org.x + blitSrc.ext.cx, rClip.org.y);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point1	= PACK_XY(rClip.org.x + blitSrc.ext.cx, rClip.org.y + blitSrc.ext.cy);

	// define the display boundary
	NV_RECT rDisplayBounds = rClip;
	rDisplayBounds.org.y += blitSrc.ext.cy + 1;
	rDisplayBounds.ext.cy -= blitSrc.ext.cy + 1;

	// initialize the destination of the BLIT
	NV_RECT blitDest = rDisplayBounds;
	blitDest.ext = blitSrc.ext;

	// initialize the movement direction vector
	DIRECTION_VECTOR dir;
	dir.horiz = RIGHT;
	dir.vert = DOWN;

	for (int i = 0; i < BLIT_QTY; i++)
	{
		NvMoveBlitDest(&blitDest, &dir, rDisplayBounds);

		// send rendering methods thru the channel -- the Size() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(BLIT_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.ControlPointIn	= PACK_XY(blitSrc.org.x,blitSrc.org.y);
		NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.ControlPointOut	= PACK_XY(blitDest.org.x,blitDest.org.y);
		NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.Size			= PACK_WH(blitDest.ext.cx,blitDest.ext.cy);

		// frame delay
		for (ULONG y = 0; y < NV_DELAY; y++);

		// display a caption
		NvDisplayCaption(hWnd, IDS_BLIT, rDisplayBounds);
	}

    return NV_STATUS_SUCCESS;

} // end of NvBlits()

void NvDestroy()
{
	// return the client and all child object resources to the system
    NvRmFree(hClient, NV01_NULL_OBJECT, hClient);

} // end of NvDestroy()

// returns an NV rectangle that describes the screen-relative window's client
NV_RECT NvGetClientNvRect(HWND hWnd)
{
	RECT rClient;
	GetClientRect(hWnd, &rClient);
	NvClientToScreenRect(hWnd, &rClient);
	NV_RECT nvrClient;
	nvrClient.org.x = rClient.left;
	nvrClient.org.y = rClient.top;
	nvrClient.ext.cx = rClient.right - rClient.left;
	nvrClient.ext.cy = rClient.bottom - rClient.top;
	return nvrClient;

} // end of NvGetClientNvRect()

// converts a client-relative rectangle to a screen-relative rectangle 
void NvClientToScreenRect(HWND hWnd, RECT* pRect)
{
	POINT ptUpperLeft, ptLowerRight;

	// convert into points
	ptUpperLeft.x	= pRect->left;
	ptUpperLeft.y	= pRect->top;
	ptLowerRight.x	= pRect->right;
	ptLowerRight.y	= pRect->bottom;

	// call windows API to convert from client coords to screen coords
	ClientToScreen(hWnd, &ptUpperLeft);
	ClientToScreen(hWnd, &ptLowerRight);

	// recreate the transformed rectangle
	pRect->left		= ptUpperLeft.x;
	pRect->top		= ptUpperLeft.y;
	pRect->right	= ptLowerRight.x;
	pRect->bottom	= ptLowerRight.y;

} // end of NvClientToScreenRect()

// returns random RGB values that define a color
void NvGetRandomRGB24Color(PULONG pr, PULONG pg, PULONG pb)
{
	*pr = rand() % MAX_8BIT_COLOR + 1;
	*pg = rand() % MAX_8BIT_COLOR + 1;
	*pb = rand() % MAX_8BIT_COLOR + 1;

} // end of NvGetRandomRGB24Color()

// returns a random point within the given limits
POINT NvGetRandomPoint(SIZE limit)
{
	POINT pt;
	pt.x = rand() % limit.cx;
	pt.y = rand() % limit.cy;
	return pt;

} // end of NvGetRandomPoint()

// returns a random size of a rectangle within the given limits
SIZE NvGetRandomExtent(SIZE limit)
{
	SIZE s;
	s.cx = rand() % limit.cx + 1;
	s.cy = rand() % limit.cy + 1;
	return s;

} // end of NvGetRandomExtent()

// displays an error message box based on its error code
void NvReportError(ULONG errorCode)
{
	char errorText[80];

	switch(errorCode)
	{
		case NV_STATUS_ERROR:
			strcpy(errorText, "Error: general error");
			break;
		case NV_STATUS_ERROR_ALLOC_DEV:
			strcpy(errorText, "Error: cannot allocate device");
			break;
		case NV_STATUS_ERROR_DEV_TYPE:
			strcpy(errorText, "Error: unavailable requested NV device type");
			break;
		case NV_STATUS_ERROR_ALLOC_CTX_DMA:
			strcpy(errorText, "Error: cannot allocate DMA context");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_PIO:
			strcpy(errorText, "Error: cannot allocate PIO channel");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_DMA:
			strcpy(errorText, "Error: cannot allocate DMA channel");
			break;
		case NV_STATUS_ERROR_ALLOC_MEM:
			strcpy(errorText, "Error: cannot allocate memory");
			break;
		case NV_STATUS_ERROR_ALLOC_OBJ:
			strcpy(errorText, "Error: cannot allocate anobject");
			break;
		case NV_STATUS_ERROR_CONFIG_GET:
			strcpy(errorText, "Error: cannot allocate get specified configuration");
			break;
	}
	MessageBox(NULL, errorText, szTitle, MB_OK);

} // end of NvReportError()

// display a caption centered horizontally and vertically in the give rectangle
void NvDisplayCaption(HWND hWnd, ULONG captionId, NV_RECT nvrText)
{
	HDC hdc = GetDC(hWnd);
	TCHAR szCaption[MAX_LOADSTRING];
	LoadString(hInst, captionId, szCaption, MAX_LOADSTRING);
	RECT rText = NvRectToWinRect(nvrText);
	NvScreenToClientRect(hWnd, &rText);
	DrawText(hdc, szCaption, strlen(szCaption), &rText, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
}

void NvScreenToClientRect(HWND hWnd, RECT* pRect)
{
	POINT ptUpperLeft, ptLowerRight;

	// convert rectangle to a set of points
	ptUpperLeft.x	= pRect->left;
	ptUpperLeft.y	= pRect->top;
	ptLowerRight.x	= pRect->right;
	ptLowerRight.y	= pRect->bottom;

	// call windows API to convert from screen coords to client coords
	ScreenToClient(hWnd, &ptUpperLeft);
	ScreenToClient(hWnd, &ptUpperLeft);

	// recreate the transformed rectangle
	pRect->left		= ptUpperLeft.x;
	pRect->top		= ptUpperLeft.y;
	pRect->right	= ptLowerRight.x;
	pRect->bottom	= ptLowerRight.y;

} // end of NvScreenRectToClientRect()

RECT NvRectToWinRect(NV_RECT nvRect)
{
	RECT r;
	r.left		= nvRect.org.x;
	r.top		= nvRect.org.y;
	r.right		= nvRect.org.x + nvRect.ext.cx;
	r.bottom	= nvRect.org.y + nvRect.ext.cy;
	return r;
}

void NvMoveBlitDest(NV_RECT* pDest, DIRECTION_VECTOR* pDir, NV_RECT nvrBoundary)
{
	RECT rBoundary = NvRectToWinRect(nvrBoundary);

	// determine the horizontal destination of a BLIT
	if (pDir->horiz == RIGHT)
	{
		if (pDest->org.x + pDest->ext.cx + 1 < rBoundary.right)
		{
			pDest->org.x++;
		}
		else
		{
			pDest->org.x--;
			pDir->horiz = LEFT;
		}
	}
	else
	{
		if (pDest->org.x - 1 > rBoundary.left)
		{
			pDest->org.x--;
		}
		else
		{
			pDest->org.x++;
			pDir->horiz = RIGHT;
		}
	}

	// define the vertical destination of the BLIT
	if (pDir->vert == DOWN)
	{
		if (pDest->org.y + pDest->ext.cy + 1 < rBoundary.bottom)
		{
			pDest->org.y++;
		}
		else
		{
			pDest->org.y--;
			pDir->vert = UP;
		}
	}
	else
	{
		if (pDest->org.y - 1 > rBoundary.top)
		{
			pDest->org.y--;
		}
		else
		{
			pDest->org.y++;
			pDir->vert = DOWN;
		}
	}

} // end of NvMoveBlitDest()


// end of nvclient.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\nvclient.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: nvclient.h
*
*	Description:
*		Definitions and prototypes for nvclient.c.
*
**************************************************************************************************/

// additional SDK macros
#define NV_SUBCHANNEL(n)				(channel->subchannel[n])
#define WAIT_FOR_SUBCHANNEL(psc,nBytes)	while((psc)->control.Free<(nBytes))
#define PACK_PITCH(s,d)					((V032)((((U032)(d))<<16)|(((U032)(s))&0x0000FFFF)) )

// 32-bit handles of our choice to track our allocated objects
enum
{
	OUR_DEVICE_ID = 0xBAAD0000,
	OUR_CHANNEL_ID,
	OUR_FRAME_BUFFER_ID,
	OUR_FRAME_BUFFER_CTX_ID,
	OUR_2D_RENDERING_SURFACE_ID,
	OUR_RECTANGLE_RENDERER_ID,
	OUR_CLIP_RECTANGLE_ID,
	OUR_LINE_RENDERER_ID,
	OUR_BLIT_ID
};

// subchannel definitions
enum
{
	WORKING_SUBCH = 0,
	CLIP_RECT_SUBCH,
	RECT_RENDER_SUBCH,
	LINE_RENDER_SUBCH,
	BLIT_SUBCH
};

// errors
typedef ULONG NV_STATUS;
enum 
{
	NV_STATUS_SUCCESS = 0,
	NV_STATUS_ERROR,
	NV_STATUS_ERROR_ALLOC_DEV,
	NV_STATUS_ERROR_DEV_TYPE,
	NV_STATUS_ERROR_ALLOC_CTX_DMA,
	NV_STATUS_ERROR_ALLOC_CH_PIO,
	NV_STATUS_ERROR_ALLOC_CH_DMA,
	NV_STATUS_ERROR_ALLOC_MEM,
	NV_STATUS_ERROR_ALLOC_OBJ,
	NV_STATUS_ERROR_CONFIG_GET,
	NV_STATUS_ERROR_ALLOC_CLIENT
};

// drawing constants
#define MAX_8BIT_COLOR 0xff
#define RECTANGLE_QTY 5000
#define LINE_QTY 1000
#define BLIT_QTY 5000
#define NV_DELAY 75000

// rectangle definition consisting of an origin and an extent
struct NV_RECT
{
	POINT org;
	SIZE ext;
};

// BLIT movement definitions
enum H_DIR {LEFT, RIGHT};
enum V_DIR {UP, DOWN};
struct DIRECTION_VECTOR
{
	H_DIR horiz;
	V_DIR vert;
};

// prototypes
NV_STATUS NvCreate();
NV_STATUS NvDrawLines(HWND);
NV_STATUS NvDrawRectangles(HWND);
NV_STATUS NvBlits(HWND);
void NvDestroy();
NV_RECT NvGetClientNvRect(HWND);
void NvClientToScreenRect(HWND, RECT*);
void NvGetRandomRGB24Color(PULONG, PULONG, PULONG);
POINT NvGetRandomPoint(SIZE);
SIZE NvGetRandomExtent(SIZE);
void NvReportError(ULONG);
void NvDisplayCaption(HWND, ULONG, NV_RECT);
void NvScreenToClientRect(HWND, RECT*);
RECT NvRectToWinRect(NV_RECT);
void NvMoveBlitDest(NV_RECT*, DIRECTION_VECTOR*, NV_RECT);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\Windowed Rectangles.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// Windowed Rectangles.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_WINDOWEDRECTANGLES, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_WINDOWEDRECTANGLES);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}



//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_WINDOWEDRECTANGLES);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_WINDOWEDRECTANGLES;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
	NV_STATUS status;

	switch (message) 
	{
		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;
				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;
		case WM_CREATE:

			// initialize the NV device
			if ((status = NvCreate()) != NV_STATUS_SUCCESS)
			{
				// if there was an error, display it and shut down the app
				NvReportError(status);
				DestroyWindow(hWnd);
			}

			break;
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);

			// draw rectangles any time the window is repainted
			if ((status = NvDrawRectangles(hWnd)) != NV_STATUS_SUCCESS)
			{
				// if there was an error, display it and shut down the app
				NvReportError(status);
				DestroyWindow(hWnd);
			}

			EndPaint(hWnd, &ps);

			break;
		case WM_DESTROY:

			// free up the client when the app's window is destroyed
			NvDestroy();

			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\StdAfx.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//	Windowed Shapes.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\Windowed Rectangles.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


#if !defined(AFX_WINDOWEDRECTANGLES_H__6DEA4A85_77EA_11D3_89A0_00500422D52A__INCLUDED_)
#define AFX_WINDOWEDRECTANGLES_H__6DEA4A85_77EA_11D3_89A0_00500422D52A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_WINDOWEDRECTANGLES_H__6DEA4A85_77EA_11D3_89A0_00500422D52A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\StdAfx.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here
//#include <stdio.h>
//#include <conio.h>
#include <time.h>

//
// NV SDK include files
//
#include <nvos.h>
#include <nv32.h>
#include <nvrmapi.h>
#include <nvMacros.h>

//
// NV DDK include files
//
#include "nvcm.h"

#include "nvclient.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Windowed Shapes.rc
//
#define IDC_MYICON                      2
#define IDD_WINDOWEDSHAPES_DIALOG       102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_WINDOWEDSHAPES              107
#define IDI_SMALL                       108
#define IDC_WINDOWEDSHAPES              109
#define IDS_RECTANGLE                   112
#define IDS_LINE                        113
#define IDS_BLIT                        115
#define IDS_BLIT_PATTERN                116
#define IDR_MAINFRAME                   128
#define IDM_RENDER                      200
#define ID_RENDER_LINES                 32774
#define ID_RENDER_RECTANGLES            32775
#define ID_RENDER_BLITS                 32777
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#define MAX_LOADSTRING 100

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <time.h>

// Local Header Files

//
// NV SDK include files
//
#include <nvos.h>
#include <nv32.h>
#include <nvrmapi.h>
#include <nvMacros.h>

//
// NV DDK include files
//
#include <nvcm.h>

#include "nvclient.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\Windowed Shapes.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


#if !defined(AFX_WINDOWEDSHAPES_H__6912D105_781A_11D3_89A0_00500422D52A__INCLUDED_)
#define AFX_WINDOWEDSHAPES_H__6912D105_781A_11D3_89A0_00500422D52A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_WINDOWEDSHAPES_H__6912D105_781A_11D3_89A0_00500422D52A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\CompileControl.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _COMPILE_CONTROL_H_
#define _COMPILE_CONTROL_H_

// Activate this block to get an idea of what #defs are set if it isn't clear
#if 0
#if defined(_WIN32)
#pragma message("Got _WIN32")
#endif
#if defined(WIN32)
#pragma message("Got WIN32")
#endif
#if defined(WINNT)
#pragma message("Got WINNT")
#else
#pragma message("No WINNT")
#endif
#if defined(_WIN32_WINNT)
#pragma message("Got WIN32 NT version")
#endif
#if (_WIN32_WINNT < 0x0500)
#pragma message("NT VER <500")
#else
#pragma message("NT VER >=500")
#endif
#endif
		
		
#if (defined(WINNT) && (_WIN32_WINNT < 0x0500))
#define IS_WINNT4 1
#else
#undef IS_WINNT4
#endif

#if (defined(WINNT) && (_WIN32_WINNT >= 0x0500))
#define IS_WINNT5 1
#else
#undef IS_WINNT5
#endif

#if (defined (WIN32) && !defined(WINNT))
#define IS_WIN9X 1
#else
#undef IS_WIN9X
#endif

#if 0
#if (IS_WIN9X)
#pragma message("Compiling for OS = WIN9X")
#elif IS_WINNT4
#pragma message("Compiling for OS = WINNT4")
#elif IS_WINNT5
#pragma message("Compiling for OS = WINNT5")
#else
#error Unrecognized OS!
#endif
#endif

#if !(IS_WIN9X || IS_WINNT4 || IS_WINNT5)
#error Unrecognized OS!
#endif

#endif _COMPILE_CONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\Windowed Shapes.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// Windowed Shapes.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text
UINT renderType;
BOOL renderShapes;


// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_WINDOWEDSHAPES, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_WINDOWEDSHAPES);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}



//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_WINDOWEDSHAPES);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_WINDOWEDSHAPES;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
	NV_STATUS status;

	switch (message) 
	{
		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;

				// draw menu selections
				case ID_RENDER_LINES:
				case ID_RENDER_RECTANGLES:
				case ID_RENDER_BLITS:
				{
					// flag which draw function to execute at paint time
					renderType = wmId;
					renderShapes = true;
					RECT rClient;
					GetClientRect(hWnd, &rClient);
					InvalidateRect(hWnd, &rClient, true);
					UpdateWindow(hWnd);
					break;
				}

				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;
		case WM_CREATE:

			// initialize the NV device
			if ((status = NvCreate()) != NV_STATUS_SUCCESS)
			{
				// if there was an error, display it and shut down the app
				NvReportError(status);
				DestroyWindow(hWnd);
			}

			break;
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);

			// execute the drawing function only once after menu selection
			if (renderShapes)
			{
				switch(renderType)
				{
					case ID_RENDER_LINES:
						status = NvDrawLines(hWnd);
						break;
					case ID_RENDER_RECTANGLES:
						status = NvDrawRectangles(hWnd);
						break;
					case ID_RENDER_BLITS:
						status = NvBlits(hWnd);
						break;
				}
				renderShapes = false;

				// if there was an error, display it and shut down the app
				if (status != NV_STATUS_SUCCESS)
				{
					NvReportError(status);
					DestroyWindow(hWnd);
				}
			}

			EndPaint(hWnd, &ps);

			break;
		case WM_DESTROY:

			// free up the client when the app's window is destroyed
			NvDestroy();

			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvBlit.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvBlit.h                                                          *
*    Definition file for:                                                   *
*       Blt832.c, Blt1632.c and Blt3232                                     *
*    Suggested new name for combined file:                                  *
*       nvBlit.c                                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVBLIT_H_
#define _NVBLIT_H_

#ifdef __cplusplus
extern "C" {
#endif

// workspace allocation flags
#define BLTWS_UNINITIALIZED     0x0
#define BLTWS_VIDEO             0x1
#define BLTWS_AGP               0x2
#define BLTWS_SYSTEM            0x4
#define BLTWS_PREFERRED_VIDEO   0x10
#define BLTWS_PREFERRED_AGP     0x20
#define BLTWS_PREFERRED_SYSTEM  0x40
#define BLTWS_REQUIRED_VIDEO    0x100
#define BLTWS_REQUIRED_AGP      0x200
#define BLTWS_REQUIRED_SYSTEM   0x400

// other defines (lore)
#define NV4_BLT_READ_AHEAD_BUFFER_SIZE  4096
#define NV10_BLT_READ_AHEAD_BUFFER_SIZE 8192

// abbreviated surface info
typedef struct tagSurfInfo {
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    LPDDRAWI_DDRAWSURFACE_GBL pGbl;
    CNvObject *pObj;
    DWORD     dwFourCC;
    BOOL      bUseSwizzle;
    BOOL      bIsLocked;
    DWORD     dwCaps;
    DWORD     dwContextDma;
    FLATPTR   fpVidMem;
    DWORD     dwOffset;
    DWORD     dwPitch;
    DWORD     dwWidth;
    DWORD     dwHeight;
    DWORD     dwSubRectX;
    DWORD     dwSubRectY;
    DWORD     dwSubRectWidth;
    DWORD     dwSubRectHeight;
    BOOL      isPotentialFault;
    DWORD     dwBytesPerPixel;
    BOOL      bDefaultBlitChanged;
} SURFINFO, *LPSURFINFO;

// exports
DWORD __stdcall GetBltStatus32(LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus);
DWORD __stdcall Blit32(LPDDHAL_BLTDATA pbd);

// utility functions
void  __stdcall bltInit(void);
DWORD __stdcall bltEarlyErrorCheck(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltUpdateClip(GLOBALDATA *pDriverData);
DWORD __stdcall bltDestroyAllContextDMAs(LPDDRAWI_DIRECTDRAW_GBL lpDD);
DWORD __stdcall bltCreateContextDMA(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf);
DWORD __stdcall bltControlTraffic(LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltAllocWorkSpace(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL lpDD);
DWORD __stdcall bltSetSurfaces2D(LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSetBltState(LPDDHAL_BLTDATA pbd, LPSURFINFO src, LPSURFINFO dst);

// blt functions
DWORD __stdcall bltPotentialFaultHandler(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltTexture(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bStretch);
DWORD __stdcall ScaleZFillDepth(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst);
DWORD __stdcall bltColourFill(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst, DWORD dwFillColour);
DWORD __stdcall blt4CCto4CC(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSimpleCopy(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSlowVtoSBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSlowStoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSimpleVtoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall blt8bppStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bFilter);

// internal use blit functions
DWORD __stdcall bltWriteDword(DWORD dwOffset, DWORD dwIndex, DWORD dwData);
DWORD __stdcall bltFillBlock(GLOBALDATA *pDriverData, DWORD dwColour, DWORD dwOffset, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwBytesPerPel);

// old fallback blt code
DWORD __stdcall Blt8bpp32  (LPDDHAL_BLTDATA pbd);
DWORD __stdcall Blt16bpp32 (LPDDHAL_BLTDATA pbd);
DWORD __stdcall Blt32bpp32 (LPDDHAL_BLTDATA pbd);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVBLIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\ddPriv.h ===
#ifndef _DDPRIV_
#define _DDPRIV_

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       ddpriv.h
 *  Content:    header for ddpriv.cpp
 *
 ***************************************************************************/

typedef struct _MYDCICMD
{
	ULONG	dwCommand;
	ULONG	dwParam1;
	ULONG 	dwParam2;
	ULONG	dwVersion;
	ULONG	dwReserved;
} MYDCICMD;

typedef struct _MYDD32BITDRIVERDATA
{
    UCHAR   szName[260];            // 32-bit driver name
    UCHAR   szEntryPoint[64];       // entry point
    ULONG   dwContext;              // context to pass to entry point
} MYDD32BITDRIVERDATA;

#define DD_VERSION              0x00000200l
#define DDCREATEDRIVEROBJECT    10
#define DDGET32BITDRIVERNAME    11
#define DDNEWCALLBACKFNS        12
#define DDVERSIONINFO           13
#define DDDESTROYDRIVEROBJECT   99

#define MAX_ADAPTERS            9

#ifdef WINNT
#ifndef NV_ESC_DDPRIV_DMABLIT
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88
#endif

#ifndef NV_ESC_DDPRIV_OVERLAYCONTROL
// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89
#endif
#endif // WINNT

// --------------------------------------------------------------------------
// nvOverlayControl
//      Overlay control callback
//
// Command Structure
// -----------------
// NVOCCMD_GETCAPS
//      dwSize
//      dwDevice
//      returns caps
//          dwCaps1
//              NVOCCAPS1_BRIGHTNESS
//              NVOCCAPS1_CONTRAST
//              NVOCCAPS1_HUE
//              NVOCCAPS1_SATURATION
//              NVOCCAPS1_SHARPNESS
//              NVOCCAPS1_GAMMA
//          dwCaps2
//              NVOCCAPS2_HQVUPSCALE
//              NVOCCAPS2_TFILTER
//              NVOCCAPS2_DFILTER
//              NVOCCAPS2_FSMIRROR
//              NVOCCAPS2_OVLZOOM
//          dwCaps3
//              NVOCCAPS3_SUBPICTURE
//              NVOCCAPS3_LATEFLIPSYNC
//              NVOCCAPS3_SPLITVPP
//              NVOCCAPS3_BLTCAPS
//          dwCaps4
//              NVOCCAPS4_SMA
//              NVOCCAPS4_IMB
//              NVOCCAPS4_DEVICEHASOVL
//              NVOCCAPS4_MULTIHEADNUM (number of display heads on this device)
//              NVOCCAPS4_MULTIHEADMODE (0 = single, 1 = span, 2 = clone)
//              NVOCCAPS4_HEAD0_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//              NVOCCAPS4_HEAD1_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//          dwCaps5
//              NVOCCAPS5_BLT_YUV9_2_YUV422
//              NVOCCAPS5_BLT_YUV12_2_YUV422
//              NVOCCAPS5_BLT_YC12_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_RGB8
//              NVOCCAPS5_BLT_YUV422_2_RGB15
//              NVOCCAPS5_BLT_YUV422_2_RGB16
//              NVOCCAPS5_BLT_YUV422_2_RGB32
//              NVOCCAPS5_BLT_SYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2SYUV
//              NVOCCAPS5_BLT_SYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2SRGB
//              NVOCCAPS5_BLT_SRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2SRGB
//              NVOCCAPS5_BLT_2RGBTEX
// NVOCCMD_SETCOLORCONTROL
//      dwSize
//      dwDevice
//      ccData
//          dwEnable (ignored for NV10 and above, always enabled)
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  lBrightness (range is -256 to +255)
//              NVOCCC_CONTRAST
//                  lContrast (range is 0 to 200)
//              NVOCCC_HUE
//                  lHue (range is 0 to 360)
//              NVOCCC_SATURATION
//                  lSaturation (range is 0 to 200)
// NVOCCMD_GETCOLORCONTROL
//      dwSize
//      dwDevice
//      returns ccData
//          returns dwEnable
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          returns dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  returns lBrightness
//              NVOCCC_CONTRAST
//                  returns lContrast
//              NVOCCC_HUE
//                  returns lHue
//              NVOCCC_SATURATION
//                  returns lSaturation
// NVOCCMD_SETFEATURE (enables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE (always enable if enough memory (8M))
//          NVOCF1_TFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[0] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_TF_PRECOPY
//          NVOCF1_DFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[1] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_DF_PRECOPY
//          NVOCF1_FSMIRROR (only enable with dual head and large memory)
//              lCoefficient[4]:
//                  bits 0-3: head number
//                            0 = disable FSVM
//                            1 = display 1
//                            2 = display 2
//                            15 = autoselect display
//                  bits 4-7: aspect ratio
//                            0 = stretch to display full screen
//                            1 = preserve aspect of source (assume square pixels)
//                            3 = force anamorphic 16:9
//                            5 = track overlay aspect
//                            9 = force TV 4:3
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-19: zoom factor, 0 = 1x, 255 = 2x
//                  bit 20: 0 = use current display size
//                          1 = let driver pick the display size
//                  bit 21: 0 = independent FS and overlay zoom
//                          1 = FS zoom tracks overlay zoom controls
//                  bit 22: 0 = disable DVD output to TV
//                          1 = enable DVD output to TV
//          NVOCF1_OVLZOOM
//              lCoefficient[5]:
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-23: zoom factor, 0 = 1x, 255 = 2x
//          NVOCF1_DELIVERYCONTROL
//              lCoefficient[6]: low 32 bits of frame period (in ns)
//              lCoefficient[7]: high 32 bits of frame period (in ns)
//          NVOCF1_LATEFLIPSYNC
//      dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = set to 0, 2, 3, 4, or 6
//              lCoefficient[3] = reserved
// NVOCCMD_RESETFEATURE (disables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//          NVOCF1_DFILTER
//          NVOCF1_FSMIRROR
//          NVOCF1_OVLZOOM
//          NVOCF1_DELIVERYCONTROL
//          NVOCF1_LATEFLIPSYNC
// NVOCCMD_GETFEATURE
//      dwSize
//      dwDevice
//      returns dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//              returns lCoefficient[0]
//          NVOCF1_DFILTER
//              returns lCoefficient[1]
//          NVOCF1_FSMIRROR
//              returns lCoefficient[4]
//          NVOCF1_OVLZOOM
//              returns lCoefficient[5]
//          NVOCF1_DELIVERYCONTROL
//              returns lCoefficient[6]
//                      lCoefficient[7]
//          NVOCF1_LATEFLIPSYNC
//      returns dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = max VPP work surfaces
//              lCoefficient[3] = VPP work surfaces currently allocated
//

#define OVERLAYCONTROLCALLBACK "nvOverlayControl"

typedef enum { 
    NVOCERR_OK              = 0,
    NVOCERR_GENERIC_WARN    = 1,
    NVOCERR_GENERIC_FATAL   = 0x80000001,
    NVOCERR_BAD_COMMAND     = 0x80000002,
    NVOCERR_INVALID_PARMS   = 0x80000003,
    NVOCERR_ALREADY_ACTIVE  = 0x80000004,
    NVOCERR_NOT_SUPPORTED   = 5,
    NVOCERR_BAD_DEVICE      = 0x80000006
} NVOCERROR;

typedef enum {
    NVOCCMD_NOOP            = 0,
    NVOCCMD_GETCAPS         = 1,
    NVOCCMD_SETCOLORCONTROL = 2,
    NVOCCMD_GETCOLORCONTROL = 3,
    NVOCCMD_SETFEATURE      = 4,
    NVOCCMD_RESETFEATURE    = 5,
    NVOCCMD_GETFEATURE      = 6
} NVOCCOMMAND;

typedef struct {
    unsigned long   dwCCFlags;
    unsigned long   dwEnable;
    long            lBrightness;
    long            lContrast;
    long            lHue;
    long            lSaturation;
    long            lSharpness;
    long            lGamma;
} NVOCCCDATA, *LPNVOCCCDATA;

#define NVOCCC_BRIGHTNESS   0x1
#define NVOCCC_CONTRAST     0x2
#define NVOCCC_HUE          0x4
#define NVOCCC_SATURATION   0x8
#define NVOCCC_SHARPNESS    0x10
#define NVOCCC_GAMMA        0x20

typedef struct {
    unsigned long dwCaps1;
    unsigned long dwCaps2;
    unsigned long dwCaps3;
    unsigned long dwCaps4;
    unsigned long dwCaps5;
} NVOCCAPS, *LPNVOCCAPS;

#define NVOCCAPS1_BRIGHTNESS    0x1
#define NVOCCAPS1_CONTRAST      0x2
#define NVOCCAPS1_HUE           0x4
#define NVOCCAPS1_SATURATION    0x8
#define NVOCCAPS1_SHARPNESS     0x10
#define NVOCCAPS1_GAMMA         0x20

#define NVOCCAPS2_HQVUPSCALE    0x1
#define NVOCCAPS2_TFILTER       0x2
#define NVOCCAPS2_DFILTER       0x4
#define NVOCCAPS2_FSMIRROR      0x8
#define NVOCCAPS2_OVLZOOM       0x10

#define NVOCCAPS3_SUBPICTURE        0x1
#define NVOCCAPS3_LATEFLIPSYNC      0x2
#define NVOCCAPS3_SPLITVPP          0x4
#define NVOCCAPS3_DELIVERYCONTROL   0x8
#define NVOCCAPS3_BLTCAPS           0x80000000

#define NVOCCAPS4_IMB           0x1
#define NVOCCAPS4_SMA           0x2
#define NVOCCAPS4_DEVICEHASOVL  0x4
#define NVOCCAPS4_MULTIHEADNUM  0x000F0000
#define NVOCCAPS4_MULTIHEADMODE 0x00F00000
#define NVOCCAPS4_HEAD0_TYPE    0x0F000000
#define NVOCCAPS4_HEAD1_TYPE    0xF0000000

#define NVOCCAPS5_BLT_YUV9_2_YUV422     0x00000001
#define NVOCCAPS5_BLT_YUV12_2_YUV422    0x00000002
#define NVOCCAPS5_BLT_YC12_2_YUV422     0x00000004
#define NVOCCAPS5_BLT_YUV422_2_YUV422   0x00000008
#define NVOCCAPS5_BLT_YUV422_2_RGB8     0x00000100
#define NVOCCAPS5_BLT_YUV422_2_RGB15    0x00000200
#define NVOCCAPS5_BLT_YUV422_2_RGB16    0x00000400
#define NVOCCAPS5_BLT_YUV422_2_RGB32    0x00000800
#define NVOCCAPS5_BLT_SYUV2VYUV         0x00010000
#define NVOCCAPS5_BLT_VYUV2VYUV         0x00020000
#define NVOCCAPS5_BLT_VYUV2SYUV         0x00040000
#define NVOCCAPS5_BLT_SYUV2VRGB         0x00100000
#define NVOCCAPS5_BLT_VYUV2VRGB         0x00200000
#define NVOCCAPS5_BLT_VYUV2SRGB         0x00400000
#define NVOCCAPS5_BLT_SRGB2VRGB         0x01000000
#define NVOCCAPS5_BLT_VRGB2VRGB         0x02000000
#define NVOCCAPS5_BLT_VRGB2SRGB         0x04000000
#define NVOCCAPS5_BLT_2RGBTEX           0x80000000

typedef struct {
    unsigned long dwFeature1;
    unsigned long dwFeature2;
    unsigned long dwFeature3;
    unsigned long dwFeature4;
    long          lCoefficient[16];
} NVOCFEATUREDATA;

#define NVOCF1_HQVUPSCALE       0x1
#define NVOCF1_TFILTER          0x2
#define NVOCF1_LATEFLIPSYNC     0x4
#define NVOCF1_DFILTER          0x8
#define NVOCF1_FSMIRROR         0x10
#define NVOCF1_OVLZOOM          0x20
#define NVOCF1_DELIVERYCONTROL  0x40

#define NVOCF2_VPPMAXSURFACES   0x1

#define NVOCF_TF_PRECOPY   0x00000001
#define NVOCF_DF_PRECOPY   0x00000002

typedef struct {
    unsigned long dwSize;
    unsigned long dwDevice;

    // command
    NVOCCOMMAND cmd;
    unsigned long dwCmdFlags;

    // data
    union {
        NVOCCAPS        caps;
        NVOCCCDATA      ccData;
        NVOCFEATUREDATA featureData;
    };

    unsigned long dwReserved[40];
} NVOCDATATYPE, *LPNVOCDATATYPE;

typedef NVOCERROR (__stdcall *NVOVERLAYCONTROL)(LPNVOCDATATYPE data);


// --------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Obsolete.  Only use with rel3 drivers
//      If lpDDCC is NULL, callback returns caps
//
//      dwDevice            always 1
//      lpDDCC->dwSize      sizeof(DDCOLORCONTROL)
//      lpDDCC->dwFlags     DDCOLOR_CONTRAST | DDCOLOR_BRIGHTNESS | DDCOLOR_HUE | DDCOLOR_SATURATION
//                          determines which members hold valid data
//      lpDDCC->lBrightness range is from -256 to +255
//      lpDDCC->lContrast   range is from 0 to 200
//      lpDDCC->lHue        range is from 0 to 360
//      lpDDCC->lSaturation range is from 0 to 200
//      lpDDCC->dwReserved1 0 = disable colour controls
//                          1 = enable with vertical chroma subsampling
//                          2 = enable with full chroma sampling
#define SETOVERLAYCOLORCONTROLCALLBACK "nvSetOverlayColorControl"

typedef DWORD (__stdcall *NVSETOVERLAYCOLORCONTROL)(DWORD dwDevice, LPDDCOLORCONTROL lpDDCC);


// --------------------------------------------------------------------------
// nvMoComp
//      Backdoor DMA blits and formatting for video
// 
// Command Structure
// -----------------
// NVS2VCMD_INIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV:
//              fpSrc
//          NVS2V_UYVY:
//              fpSrc
//          NVS2V_RGB16:
//              fpSrc
//          NVS2V_RGB32:
//              fpSrc
//          NVS2V_YC12
//              SrcYC12.fpY
//          NVS2V_YUV12
//              SrcYUV12.fpY (points to start of surface)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//      dwDstType (required only if using INDEXED type on BLIT)
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
// NVS2VCMD_RELEASE
//      dwSize
//      dwDevice
//      dwIndex
// NVS2VCMD_BLIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET (only use for V->S blits)
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YC12
//              SrcYC12.fpY
//              SrcYC12.fpC
//          NVS2V_YUV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//          NVS2V_YV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//              dwSrcYV12ChromaPitch
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET (only use for S->V blits)
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//      dwDstType
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
//          NVS2V_INDEXED (uses last YUY2 or UYVY state)
//              dwDstSize
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_QUERY_IDLE
//      dwSize
//      dwDevice
// NVS2VCMD_WAIT_FOR_IDLE
//      dwSize
//      dwDevice
//      dwTimeoutTime
// NVS2VCMD_SET_SUBPICTURE
//      dwSize
//      dwDevice
//      dwSPFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_SP_SUBRECT
//              dwSubRectX
//              dwSubRectY
//              dwSubRectWidth
//              dwSubRectHeight
//      dwSPType
//      dwSPPitch
//      fpSP
// NVS2VCMD_VPP_START
//      dwSize
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//      dwSrcPitch
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_VPP_ODD
//          NVS2VF_VPP_EVEN
//          NVS2VF_VPP_BOB
//          NVS2VF_VPP_INTERLEAVED
// NVS2VCMD_VPP_QUERY
//      dwSize
//      dwDevice
// NVS2VCMD_VPP_FLIP
//      dwSize
//      dwDevice
// NVS2VCMD_4CC_TO_VRGB
//      dwSize
//      dwIndex (0xFFFFFFFF means use video memory)
//      dwCmdFlags (optional)
//          NVS2VF_CRTC_SYNC
//              dwHead
//              dwScanline (blit will not begin until CRTC of specified head reaches this scanline)
//              dwTimeoutTime
//          NVS2VF_USE_DELIVERY_CTL
//              dwTimeoutTime
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_UYVY
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//          NVS2VF_SWIZZLED
//      dwDstType
//          NVS2V_RGB16
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//          NVS2V_RGB32
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_GET_TEXTURE_OFFSET
//      dwSize
//      dwDevice
//      fpTexture
//      returns fpTexture


#define MOCOMPCALLBACK "nvMoComp"

typedef enum {
    NVS2V_YC12      = 1,
    NVS2V_YUV12     = 2,
    NVS2V_YUYV      = 3,
    NVS2V_UYVY      = 4,
    NVS2V_DDSURF    = 5,
    NVS2V_INDEXED   = 6,
    NVS2V_YUVA16    = 7,
    NVS2V_YUVA32    = 8,
    NVS2V_YV12      = 9,
    NVS2V_RGB8      = 0x10,
    NVS2V_RGB16     = 0x11,
    NVS2V_RGB24     = 0x12,
    NVS2V_RGB32     = 0x13
} NVS2VSURFTYPE;

typedef enum {
    NVS2VCMD_NOOP               = 0,
    NVS2VCMD_INIT               = 1,
    NVS2VCMD_RELEASE            = 2,
    NVS2VCMD_BLIT               = 3,
    NVS2VCMD_QUERY_IDLE         = 4,
    NVS2VCMD_WAIT_FOR_IDLE      = 5,
    NVS2VCMD_SET_SUBPICTURE     = 6,
    NVS2VCMD_VPP_START          = 7,
    NVS2VCMD_VPP_QUERY          = 8,
    NVS2VCMD_VPP_FLIP           = 9,
    NVS2VCMD_4CC_TO_VRGB        = 0xA,
    NVS2VCMD_GET_TEXTURE_OFFSET = 0xB
} NVS2VCOMMAND;

typedef enum {
    NVS2VERR_OK             = 0,
    NVS2VERR_GENERIC_WARN   = 1,
    NVS2VERR_GENERIC_FATAL  = 0x80000001,
    NVS2VERR_BAD_COMMAND    = 0x80000002,
    NVS2VERR_INVALID_PARMS  = 0x80000003,
    NVS2VERR_INIT_FAILED    = 0x80000004,
    NVS2VERR_NO_EVENT       = 5,
    NVS2VERR_BUSY           = 6,
    NVS2VERR_TIMEOUT        = 7,
    NVS2VERR_BAD_DEVICE     = 0x80000008
} NVS2VERROR;

#define NVS2VF_OFFSET           0x00000001
#define NVS2VF_SP_SUBRECT       0x00000002
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
#define NVS2VF_VPP_ODD          0x00000010
#define NVS2VF_VPP_EVEN         0x00000020
#define NVS2VF_VPP_BOB          0x00000040
#define NVS2VF_VPP_INTERLEAVED  0x00000080
#define NVS2VF_LOCAL            0x00000100
#define NVS2VF_SYSTEM           0x00000200
#define NVS2VF_SWIZZLED         0x00000400
#define NVS2VF_CRTC_SYNC        0x00000800
#define NVS2VF_USE_DELIVERY_CTL 0x00001000

typedef struct {
    unsigned long dwSize;               // sizeof(NVS2VDATATYPE)
    
    // command data
    NVS2VCOMMAND  dwCmd;
    unsigned long dwCmdFlags;
    BOOL          bWaitForCompletion;
    unsigned long dwTimeoutTime;        // in ms
    unsigned long dwIndex;
    unsigned long dwDevice;
    unsigned long dwHead;
    unsigned long dwScanline;
    unsigned long dwReserved1[55];

    // neutral data
    unsigned long dwWidth;              // in pixels
    unsigned long dwHeight;             // in lines

    // source data
    unsigned long dwSrcFlags;
    NVS2VSURFTYPE dwSrcType;
    unsigned long dwSrcPitch;           // in bytes
    union {
        void  *fpTexture;
        void  *fpSrc;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpSrcDirectDrawSurface;  // used with NVS2V_DDSURF (not implemented)
        unsigned long dwSrcSize;        // used with NVS2V_INDEXED (not implemented)
        struct {
            void  *fpY;
            void  *fpC;
        } SrcYC12;                      // used with NVS2V_YC12 (Y and C must be contiguous)
        struct {
            void  *fpY;
            void  *fpU;
            void  *fpV;
        } SrcYUV12;                     // used with NVS2V_YUV12 (not implemented)
    };

    // destination data
    unsigned long dwDstFlags;
    NVS2VSURFTYPE dwDstType;
    unsigned long dwDstPitch;           // in bytes
    union {
        void  *fpDst;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpDstDirectDrawSurface;  // used with NVS2V_DDSURF
        unsigned long dwDstSize;        // used with NVS2V_INDEXED
        struct {
            void *fpY;
            void *fpC;
        } DstYC12;                      // used with NVS2V_YC12 (not implemented)
        struct {
            void *fpY;
            void *fpU;
            void *fpV;
        } DstYUV12;                     // used with NVS2V_YUV12 (not implemented)
        struct {
            void *fpRGB;
            unsigned long dwDstWidth;
            unsigned long dwDstHeight;
        } DstRGB;                       // used with the RGB surface types
    };

    // subpicture data
    unsigned long dwSPFlags;
    NVS2VSURFTYPE dwSPType;
    unsigned long dwSPPitch;
    unsigned long fpSP;
    unsigned long dwSubRectX;
    unsigned long dwSubRectY;
    unsigned long dwSubRectWidth;
    unsigned long dwSubRectHeight;

    // more source data
    unsigned long dwSrcYV12ChromaPitch;
    unsigned long dwSrcPixelBias;

    // pad
    unsigned long dwReserved2[40];
} NVS2VDATATYPE, *LPNVS2VDATATYPE;

typedef NVS2VERROR (__stdcall *NVMOCOMP)(LPNVS2VDATATYPE data);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\eewinma2.h ===
//*****************************Module*Header******************************
//
// Module Name: eewinman2.h
//
// WINman display propterty page interface version 2
// for board detection, mode set,...
//
// FNicklisch 09/14/2000: 
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1998-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef _EeWINma2_h_
#define _EeWINma2_h_


/*
** $Header$
**
** MODULE:   EeWINma2.h
**
** AUTHOR:   Torsten Horn, Copyright (c) 1999 ELSA AG, Aachen (Germany)
**
** PROJECT:  ELSA Graphics Software
**
** PURPOSE:  ELSA Escape Windows driver functions for WINman
**
** NOTES:    1998-10-01 THorn: First release.
**           1999-05-04 THorn: Only comment extended/modified.
**           1999-08-03 THorn: New WINMAN_MOD_DFP and comments extended.
**           1999-08-18 THorn: New WINMAN_TIM_... flags.
**           1999-11-12 THorn: ET_WINMAN2_DDC_EDID_GET extended for EDID2.
*/


/*-----------------------------------------------------------------
  For the principle architecture of this kind of ELSA escape functions see 
  the header elsa\ElsaEsc.h (which must be included before this header).

  This header EeWINma2.h defines the escape functions:
    SUBESC_ET_WINMAN2_DATA_GET
    SUBESC_ET_WINMAN2_DATA_SET
    SUBESC_ET_WINMAN2_DDC_EDID_GET
  
  Simplyfied example for getting data from the driver (in case of 16 boards):
    ET_QUERY.dwSubEsc  = SUBESC_ET_WINMAN2_DATA_GET;
    ET_QUERY.dwSize    = sizeof(ET_QUERY);
    ET_QUERY.dwOutSize = sizeof(ET_WINMAN2_DATA_GET) +
                         sizeof(ET_WINMAN2_DATA_BRD_R) * 15;  // when 16 boards
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               ET_QUERY.dwSize,    (LPCSTR)&ET_QUERY,
               ET_QUERY.dwOutSize,  (LPSTR)&ET_WINMAN2_DATA_GET );

  Simplyfied example for setting data to the driver (in case of 16 boards):
    ET_WINMAN2_DATA_SET.hdr.dwSubEsc  = SUBESC_ET_WINMAN2_DATA_SET;
    ET_WINMAN2_DATA_SET.hdr.dwSize    = sizeof(ET_WINMAN2_DATA_SET);
    ET_WINMAN2_DATA_SET.hdr.dwOutSize = sizeof(ET_WINMAN2_DATA_GET) +
                                        sizeof(ET_WINMAN2_DATA_BRD_R) * 15;
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               ET_WINMAN2_DATA_SET.hdr.dwSize,    (LPCSTR)&ET_WINMAN2_DATA_SET,
               ET_WINMAN2_DATA_SET.hdr.dwOutSize,  (LPSTR)&ET_WINMAN2_DATA_GET );

  dwOutSize (in ET_QUERY and ET_WINMAN2_DATA_SET.hdr) must match
    sizeof(ET_WINMAN2_DATA_GET) + sizeof(ET_WINMAN2_DATA_BRD_R) * n;
  where n usually is equal to
    ET_WINMAN2_DATA_GET.dwNumBoardsInstalled - 1
  but n may be less eg. with WINMAN_SET_CHECK, see below.

  The first call usually is a SUBESC_ET_WINMAN2_DATA_GET with a return 
  structure size (dwOutSize) fitting for only one board. If
    ExtEscape() > 0  &&
    lResult == WINMAN_RESULT_ERROR_SIZE  &&
    dwNumBoardsInstalled > 1,
  then the next SUBESC_ET_WINMAN2_DATA_GET call has the correct 
  structure size in dwOutSize for getting the data of all boards.

  SUBESC_ET_WINMAN2_DATA_SET may be called for less than all boards 
  (especially with WINMAN_SET_CHECK). In this case the return structure 
  size (dwOutSize) may fit to this reduced number of boards (what should 
  not produce an error code).
  SUBESC_ET_WINMAN2_DATA_SET must always return either with 
  WINMAN_RESULT_ERROR or with valid and complete data in ET_WINMAN2_DATA_GET.

  You must carefully distinguish between the different return values:
    ExtEscape() must return:
      - zero if the escape function or the subescape is not implemented,
      - less than zero if an error in the escape interface occures (may 
        be ET_QUERY.dwSize is too small),
      - greater than zero if the escape interface is successful, even 
        when another error occures. Other error codes (for problems with 
        the data) are returned in lResult.
    ET_WINMAN2_DATA_GET.lResult must return the fitting WINMAN_RESULT_...
      When the size of the output structure was too small for all needed 
      boards, you must return WINMAN_RESULT_ERROR_SIZE.
      When all data send to the driver are ok, but eg. only the pixel 
      clock (may be of only one board) is too high, you either must return 
      WINMAN_RESULT_ERROR, or better would be, you would return 
      WINMAN_RESULT_MODIFIED and reduce the pixel clock to the max. allowed 
      value.
      With WINMAN_RESULT_ERROR the returned ET_WINMAN2_DATA_GET structure 
      may have invalid data. With WINMAN_RESULT_OK or WINMAN_RESULT_MODIFIED 
      the returned ET_WINMAN2_DATA_GET data must be o.k. and complete for 
      both kind of calls (SUBESC_ET_WINMAN2_DATA_GET and 
      SUBESC_ET_WINMAN2_DATA_SET).
    ET_WINMAN2_DATA_BRD_RW.dwFlags has flags for each board.
      With WINMAN_BRD_MODIFIED you can decide, for which board the data 
      were modified.
    ET_WINMAN2_DATA_GET.dwDrvModFlags returns with the WINMAN_MOD_... flag 
      bits some modification possibilities/capabilities (common for all 
      boards).

  -----------------------------------------------------------------*/


/* #include <elsa\ElsaEsc.h> */


/* Defines for driver result value in lResult
   (used eg. in ET_WINMAN2_DATA_GET and ET_WINMAN2_DDC_EDID_GET). */
#define WINMAN_RESULT_OK          0  /* o.k., no modification */
#define WINMAN_RESULT_ERROR      -1  /* error (returned data invalid) */
#define WINMAN_RESULT_ERROR_SIZE -2  /* error: dwOutSize wrong, 
                                        see comment to dwOutSize in header.
                                        Only the following members of 
                                        ET_WINMAN2_DATA_GET are guaranted to 
                                        be valid: dwSize, lResult, 
                                        dwNumBoardsInstalled, dwNumBoardsActive;
                                        other returned data may be invalid */
#define WINMAN_RESULT_MODIFIED    1  /* data modified;
                                        all data are ok, but only eg. the 
                                        pixel clock was too high; pixel 
                                        clock is reduced to max. allowed 
                                        value */

/* Defines for modification possibilities/capabilities flags in dwDrvModFlags
   (used in ET_WINMAN2_DATA_GET). */
#define WINMAN_MOD_BPP            1  /* bpp changable */
#define WINMAN_MOD_HZ             2  /* new Hz values definable */
#define WINMAN_MOD_TIM            4  /* complete timing definable */
#define WINMAN_MOD_PAN_HOR        8  /* horizontal panning possible */
#define WINMAN_MOD_PAN_VER       16  /* vertical panning possible */
#define WINMAN_MOD_MULTI_HOR     32  /* multiscreen hor. possible */
#define WINMAN_MOD_MULTI_VER     64  /* multiscreen ver. possible */
#define WINMAN_MOD_MULTI_H_V    128  /* multiscreen hor.+ver. both */
#define WINMAN_MOD_RES          256  /* new resolution values definable */
#define WINMAN_MOD_DFP          512  /* DFP Digital Flat Panel (different 
                                        resolutions with one fix timing) */

/* Defines for some board flags in dwFlags
   (used in ET_WINMAN2_DATA_BRD_RW). */
#define WINMAN_BRD_MODIFIED       1  /* data of this board modified */

/* Defines for some timing flags (sync polarity, interlace) in dwTimFlags
   (used in ET_WINMAN2_DATA_BRD_RW). */
#define WINMAN_TIM_HSYNC_POS      8  /* same as GFX_HSYNC_POS */
#define WINMAN_TIM_VSYNC_POS      4  /* same as GFX_VSYNC_POS */
#define WINMAN_TIM_ILC            1  /* same as GFX_ILC */
#define WINMAN_TIM_FIXED_TIMING  16  /* same as GFX_FIXED_TIMING */

/* Defines for action in dwCheckAddRemove
   (used in ET_WINMAN2_DATA_SET). */
#define WINMAN_SET_CHECK          1  /* check (may be modify) this mode */
#define WINMAN_SET_ADD            2  /* add this mode to allowed modes */
#define WINMAN_SET_REMOVE         3  /* remove this mode */
/* The following two are not used till now (for future use): */
#define WINMAN_SET_DO_TEST        4  /* switch only for test screen */
#define WINMAN_SET_DO_PERM        5  /* switch graphics mode permanent */


/* Read/write data of each board
   (used in ET_WINMAN2_DATA_GET and ..._DATA_SET). */
typedef struct tagET_WINMAN2_DATA_BRD_RW
{
  /* These values must always be valid: */
  DWORD dwPanOriginX;            /* panning x-origin */
  DWORD dwPanOriginY;            /* panning y-origin */
  DWORD dwVisOriginX;            /* visible x-origin */
  DWORD dwVisOriginY;            /* visible y-origin */
  DWORD dwPanSizeX;              /* panning x-size */
  DWORD dwPanSizeY;              /* panning y-size */
  DWORD dwVisSizeX;              /* visible x-size */
  DWORD dwVisSizeY;              /* visible y-size */
  DWORD dwBpp;                   /* bpp */
  DWORD dwColorsNum;             /* num. of colors */
  DWORD dwHz;                    /* Hz refresh rate */
  /* These values must be zero if not used: */
  DWORD dwFlags;                 /* flag bits, eg. WINMAN_BRD_MODIFIED */
  DWORD dwTimPixFreq;            /* pixel clock frequency in Hz */
  DWORD dwTimHTot;               /* horizontal total number of pixels */
  DWORD dwTimHFp;                /* horizontal frontporch in pixels */
  DWORD dwTimHSw;                /* horizontal sync width in pixels */
  DWORD dwTimHBp;                /* horizontal backporch in pixels */
  DWORD dwTimVTot;               /* vertical total number of lines */
  DWORD dwTimVFp;                /* vertical frontporch in lines */
  DWORD dwTimVSw;                /* vertical sync width in lines */
  DWORD dwTimVBp;                /* vertical backporch in lines */
  DWORD dwTimFlags;              /* tim. flag bits: WINMAN_TIM_... */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
} ET_WINMAN2_DATA_BRD_RW, *PET_WINMAN2_DATA_BRD_RW;


/* Read-only data of each board
   (used in ET_WINMAN2_DATA_GET). */
typedef struct tagET_WINMAN2_DATA_BRD_R
{
  /* Board data used in ET_WINMAN2_DATA_GET and ..._DATA_SET: */
  ET_WINMAN2_DATA_BRD_RW rw;     /* read/write data */
  /* These values must be zero if not used: */
  DWORD dwPixFreqMax08;          /* max. possible pixel clock (in Hz) at  8bpp */
  DWORD dwPixFreqMax16;          /* max. possible pixel clock (in Hz) at 16bpp */
  DWORD dwPixFreqMax24;          /* max. possible pixel clock (in Hz) at 24bpp */
  DWORD dwPixFreqMax32;          /* max. possible pixel clock (in Hz) at 32bpp */
  DWORD dwMemSizePan;            /* RAM usable for visible and virtual screen */
  DWORD dwMemSizeAll;            /* size of all RAM (e.g. VRAM + DRAM) */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
  char  sBoardname[40];          /* board name */
  char  sSerNum[24];             /* serial number */
} ET_WINMAN2_DATA_BRD_R, *PET_WINMAN2_DATA_BRD_R;


/* Data WINman gets from the Windows driver. */
typedef struct tagET_WINMAN2_DATA_GET
{
  DWORD dwSize;                  /* sizeof this struct with correct num of brd */
  LONG  lResult;                 /* WINMAN_RESULT_OK, ...ERROR..., ...MODIFIED */
  DWORD dwDrvModFlags;           /* driver modify flags WINMAN_MOD_... */
  DWORD dwReserved;              /* == 0 (reserved) */
  DWORD dwNumBoardsInstalled;    /* number of all installed boards */
  DWORD dwNumBoardsActive;       /* number of active used boards */
  /* The following struct as often as dwNumBoardsActive: */
  ET_WINMAN2_DATA_BRD_R brd[1];  /* data of all boards */
} ET_WINMAN2_DATA_GET, *PET_WINMAN2_DATA_GET;


/* Data WINman writes to the Windows driver. */
typedef struct tagET_WINMAN2_DATA_SET
{
  ET_QUERY hdr;
  DWORD dwCheckAddRemove;        /* WINMAN_SET_CHECK, ..._ADD, ..._DO_... */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
  DWORD dwSizeX;                 /* x-size of desktop (over all monitors) */
  DWORD dwSizeY;                 /* y-size of desktop (over all monitors) */
  DWORD dwNumBoardsActive;       /* number of active used boards */
  /* The following struct as often as dwNumBoardsActive: */
  ET_WINMAN2_DATA_BRD_RW brd[1]; /* data of all boards */
} ET_WINMAN2_DATA_SET, *PET_WINMAN2_DATA_SET;


/*-----------------------------------------------------------------
  SUBESC_ET_WINMAN2_DDC_EDID_GET
  
  Example (m=0 for EDID1 and m=1 for EDID2):
    ET_QUERY.dwSubEsc  = SUBESC_ET_WINMAN2_DDC_EDID_GET;
    ET_QUERY.dwSize    = sizeof(ET_QUERY);
    ET_QUERY.dwOutSize = sizeof(ET_WINMAN2_DDC_EDID_GET) + m*128;
    ET_QUERY.dwBoard   = n;
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               sizeof(  ET_QUERY ),
               (LPCSTR)&ET_QUERY,
               sizeof(  ET_WINMAN2_DDC_EDID_GET ) + m*128,
               (LPSTR) &ET_WINMAN2_DDC_EDID_GET );
  -----------------------------------------------------------------*/


/* DDC EDID structure WINman gets from the Windows driver.
   This structure  is for EDID 1.x with 128 bytes 
   of data as well as for EDID 2.x with 256 bytes.
   When WINman querries with wrong ET_QUERY.dwOutSize value, 
   the driver has to return WINMAN_RESULT_ERROR_SIZE. 
   Then WINman must try with another ET_QUERY.dwOutSize. */
typedef struct tagET_WINMAN2_DDC_EDID_GET
{
  DWORD dwSize;                   /* sizeof(ET_WINMAN2_DDC_EDID_GET)+m*128 */
  LONG  lResult;                  /* WINMAN_RESULT_OK, WINMAN_RESULT_ERROR... */
  unsigned char ddcEdid[128][1];  /* VESA DDC EDID structure */
} ET_WINMAN2_DDC_EDID_GET, *PET_WINMAN2_DDC_EDID_GET;


#endif  // #ifndef _EeWINma2_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\ddProcMan.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: ddProcMan.h                                                       *
*    Definition file for:                                                   *
*       ddpm.c                                                              *
*    Suggested new name:                                                    *
*       ddProcMan.c                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef __DDPROCMAN_H_
#define __DDPROCMAN_H_

#include "CompileControl.h"

#define EVENTNAME_IDLE                  "NV_Idle"
#define EVENTNAME_OVL_FLIP_EVEN         "NV_OvlFlipEven"
#define EVENTNAME_OVL_FLIP_ODD          "NV_OvlFlipOdd"
#define EVENTNAME_DMA_TO_VID            "NV_DMAToVid"
#define EVENTNAME_CONVERT               "NV_Convert"
#define EVENTNAME_SUBPICTURE            "NV_SubPicture"
#define EVENTNAME_PRESCALE              "NV_PreScale"
#define EVENTNAME_COLOURCONTROL         "NV_ColourControl"
#define EVENTNAME_TFILTER               "NV_TFilter"
#define EVENTNAME_DFILTER               "NV_DFilter"
#define EVENTNAME_DISPATCH_GO           "NV_DispatchGo"
#define EVENTNAME_DISPATCH_DONE         "NV_DispatchDone"
#define EVENTNAME_FSMIRROR              "NV_FSMirror"
#define EVENTNAME_PRIMARY0_FLIP_EVEN    "NV_Primary0FlipEven"
#define EVENTNAME_PRIMARY0_FLIP_ODD     "NV_Primary0FlipOdd"
#define EVENTNAME_PRIMARY1_FLIP_EVEN    "NV_Primary1FlipEven"
#define EVENTNAME_PRIMARY1_FLIP_ODD     "NV_Primary1FlipOdd"
#define EVENTNAME_TIMER                 "NV_Timer"

#if IS_WINNT5

#define CREATE_EVENT(pHandle) EngCreateEvent(pHandle)
#define DELETE_EVENT(handle) EngDeleteEvent(handle)
#define HDRVEVENT PEVENT
#define EVENT_ERROR

#elif IS_WINNT4

// TBD - mlavoie: resolve issues with events on NT4

// VERY unsure as to whether the ddraw portion of the display can call these.
//   the miniport can so we may need to find another way -mlavoie
// Also very unsure as to whether these 2 funcs correspond to create & delete
#define CREATE_EVENT(pHandle) KeInitializeEvent(pHandle,NotificationEvent,FALSE)
#define DELETE_EVENT(handle) KeResetEvent(&(handle))
//KeWaitForSingleObject
#define HDRVEVENT NvU32
#define EVENT_ERROR

#elif IS_WIN9X

#define HDRVEVENT HANDLE
#define EVENT_ERROR {   \
    pmDeleteProcess(lpProcInfo->dwProcessID);   \
    pmAddProcess(pDriverData, GetCurrentProcessId());        }

#else
#error Unhandled OS.
#endif

// process manager structure
typedef struct tagProcessInfo {
    unsigned long dwProcessID;
    HDRVEVENT     hIdleSyncEvent0;
    HDRVEVENT     hIdleSyncEvent3;
    HDRVEVENT     hOvlFlipEvenEvent0;
    HDRVEVENT     hOvlFlipEvenEvent3;
    HDRVEVENT     hOvlFlipOddEvent0;
    HDRVEVENT     hOvlFlipOddEvent3;
    HDRVEVENT     hDMABlitToVid0;
    HDRVEVENT     hDMABlitToVid3;
    HDRVEVENT     hConvert0;
    HDRVEVENT     hConvert3;
    HDRVEVENT     hSubPicture0;
    HDRVEVENT     hSubPicture3;
    HDRVEVENT     hColourControl0;
    HDRVEVENT     hColourControl3;
    HDRVEVENT     hTFilter0;
    HDRVEVENT     hTFilter3;
    HDRVEVENT     hDFilter0;
    HDRVEVENT     hDFilter3;
    HDRVEVENT     hFSMirror0;
    HDRVEVENT     hFSMirror3;
    HDRVEVENT     hPrimary0FlipEven0;
    HDRVEVENT     hPrimary0FlipEven3;
    HDRVEVENT     hPrimary0FlipOdd0;
    HDRVEVENT     hPrimary0FlipOdd3;
    HDRVEVENT     hPrimary1FlipEven0;
    HDRVEVENT     hPrimary1FlipEven3;
    HDRVEVENT     hPrimary1FlipOdd0;
    HDRVEVENT     hPrimary1FlipOdd3;
    HDRVEVENT     hTimer0;
    HDRVEVENT     hTimer3;
    struct tagProcessInfo *lpNext;
} PROCESSINFO, *LPPROCESSINFO;

#ifdef __cplusplus
extern "C" {
#endif

// public
#ifndef WINNT
HANDLE        ConvertRing3EventToRing0 (HDRVEVENT hEventRing3);
BOOL          CloseRing0Handle         (HDRVEVENT hEventRing0);
#endif // WINNT
typedef struct _GLOBALDATA GLOBALDATA;
LPPROCESSINFO pmGetProcess             (GLOBALDATA *pDriverData, DWORD processID);
BOOL          pmAddProcess             (GLOBALDATA *pDriverData, DWORD processID);
BOOL          pmDeleteProcess          (DWORD processID);
BOOL          pmDeleteProcessPDD       (GLOBALDATA *pDriverData, DWORD processID);
void          pmDeleteAllProcesses     (GLOBALDATA *pDriverData);

HRESULT NvResetEvent(HDRVEVENT hEvent);
HRESULT NvSetEvent(HDRVEVENT hEvent);
HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DDPROCMAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\elsaesc.h ===
//*****************************Module*Header******************************
//
// Module Name: elsaesc.h
//
// This file conatins all declarations for the ELSA Escape interface
// used by all tools and applications to access graphic driver data.
//
// FNicklisch 09/14/2000: 
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1998-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef __ELSAESC
#define __ELSAESC

/*
** $Header$
**
** MODULE:   ELSAESC.H
**
** AUTHOR:   Fred Nicklisch
**           Copyright (c) 1991-99 ELSA AG, Aachen (Germany)
**
** PROJECT:  ELSA Graphics Software
**
** PURPOSE:  define Escape interface between Windows 95/NT display driver
**           and tools
**
** DESCR:    All ELSA drivers will provide a escape interface to allow
**           user-applications (tools) to configure the display driver and
**           retrieve information. The application has to use ExtEscape.
**           The implementation depends on one single esc entry and
**           multiple subescapes.
**
**           WARNING: We only allow the basic types
**                    LONG, DWORD and char in all in and out structures!
**                    Don't use Tabs (blanks instead)
**                    Don't use german "Umlaute"
**
** NOTES:    01.12.97 FNicklis: First Release, basic functionality
**           02.12.97 MSuhre  : Added support for Monitor-Key,
**                              changed CHAR to char
**           03.12.97 SKuklik : Added support for DUO Boards
**           03.12.97 SKuklik : Added support for DUO Boards
**           04.12.97 FNicklis: struct packing and basic types
**           04.12.97 MSuhre  : #pragma pack (push/pop,..)
**                              push and pop are not valid for MS-C 1.52
**           06.03.98 tu      : Query and set value for string and dword added
**           06.03.98 FNicklis: Fixed "query and set value" to make it compilable
**           08.03.98 FNicklis: defined ET_SET_VALUE_RET
**           12.03.98 tu      : Added query and set value ID's for WinNT:
**                                HardwareInformation 0x20000500-0x200005ff
**                                Desktop coordinates 0x20000600-0x200006ff
**                                Some Basic/system values 0x20000002-0x20000004
**                              Added dwFlags to ET_VALUE_STRING and ET_VALUE_DWORD;
**                              Added return flags convention
**           12.03.98 THorn   : New grouping of the items in this file,
**                              no compiler relevant change.
**           13.03.98 tu      : Added value ID ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER
**           13.04.98 db      : replaced dwAlign member of ET_QUERY with dwBoard
**                              Somehow we have to know for what board we want to read or write
**           13.04.98 db      : number of dma buffers is not number of subbuffers (used the same ID)
**           12.05.98 THorn   : SUBESC_ET_WINMAN_DDC_EDID_GET added.
**           09.06.98 tu      : Transfer ESCAPE calls from EDDESC.H (SUBESC_ET_EDD_xxx)
**           08.07.98 tu      : Added value ID ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING (0x20000320)
**           14.08.98 FNicklis: Added value IDs ET_VALUE_DW_xx for NT driver
**           16.09.98 THorn   : SUBESC_ET_WINMAN2_... added.
**           25.09.98 tu      : added ET_VALUE_ERROR (0x80000000)
**                              added #pragma warning( disable:4201 ) at struct tagET_VERSION
**           30.09.98 FNicklis: Added version stamp and capabilities to ET_VERSION retrieved with
**                              SUBESC_ET_QUERY_VERSION_INFO
**           21.10.98 FNicklis: Extension to ET_VALUE_xx-interface (ET_VALUE_BLOCKED)
**           23.10.98 FNicklis: NT doesn't know FAR and somtimes doesn't know DWORD
**           25.10.98 FNicklis: Modified ET_VALUE_xx-interface to get reserved bits for OS internals
**           12.11.98 js:       ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER for OpenGL.SupportProDesigner added
**           21.11.98 FNicklis: ET_VALUE_DW_OPENGL_DMAMAXCOUNT, ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT added
**           25.11.98 MPietsch: ET_VALUE_DW_OPENGL_PIXELTUBE added
**                    FNicklis: Added some informational stuff regarding version stamp and version checking
**           02.12.98 FNicklis: New ET_VALUE_TYPE_DWORD_DEFAULT, ...
**           29.01.99 FNicklis: Registry Key-IDs 0x2000032A-0x2000032E
**           29.01.99 SKuklik:  Registry Key-IDs 0x20000069-0x2000006c, 0x20000097, 0x20000129, 0x20000208, 0x20000405 - 406, 0x20000601 - 602
**           03.02.99 CSkopins: Escape-Codes fuer Video-In/-Out hinzugefuegt.
**           11.02.99 SKuklik : Registry Key-ID  0x2000012B (ICDInterface.PFD_SWAP_EXCHANGE)
**           12.02.99 FNicklis: SUBESC_ET_QUERY_ICDCLIENTINFO
**           13.04.99 CSchalle: ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING
**           14.04.99 CSchalle: added ET_VALUE_DW_OPENGL_ALIGNED_SURFACES
**           22.04.99 CSchalle: added ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA
**           11.05.99 JS:       added ET_SUBESC_ET_xxx_VALUE_BINARY, ET_VALUE_BIN_GDI_GAMMARAMP
**                              added SUBESC_ET_EDD_xETGAMMARAMP
**           19.05.99 FNicklis: ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS fixed
**           28.06.99 HHornig : added RES_ESC_ELSA_TOOL call for generic drivers
**           30.06.99 FNicklis: added SUBESC_ET_MULTIBOARDSETUP for internal Display driver vs multiboard driver calls
**           25.08.99 CSkopins: added Capability flags for STEREO and OVERCLOCKING
**           22.09.99 HHornig : added ET_EDD_GETCOLORCAPSLIMITS
**           28.09.99 TU:       added SUBESC_ET_QUERY_TEMPERATURE for temperature and fan status
**           29.09.99 FNicklis: added SUBESC_ET_DPMS and sample code
**           18.10.99 CSkopins: added SUBESC_RMAPI_CONFIGSETGET for ERAZOR X TV-Out
**           20.10.99 CSchalle: added ET_VALUE_BIN_OEM_MODELIST
**           10.02.00 FNicklis: added ET_VALUE_DW_DMA_7DUMMYREADS, ET_VALUE_DW_DMA_DUMMYREADUC, ET_VALUE_DW_DMA_FORCEIOFLUSH
**           10.03.00 HHornig : added SUBESC_GET_OUTPUT_DEVICE_INFO / SUBESC_SET_OUTPUT_DEVICE
**           23.05.00 BSchwall: added ET_VALUE_DW_OPENGL_UNIGRAPHICS_TEXTURE_FIX
*/

// ********************************************************
// ********************************************************
// Basic defines
// -------------

// We need a common alignment for all structures:
// save current packing and switch to 8 byte (64bit)
#ifdef WIN32
#pragma pack (push, fixed_forELSAESC)
#endif
#pragma pack(8)

#define ET_MAX_PATH   260 // MAX_PATH is not available in all environments!
#define ET_MAX_STRING 260


#define ESC_ELSA_TOOLS 0xE15A // Escape for ELSA Tools
// HHORNIG : 28.6.99
// if we build generic drivers some tools are allowed to pop up
// to detect this the tool should use this call combined with
// a special code that is only used for this tool
#define RES_ESC_ELSA_TOOLS 0xE15B // restricted Escape for ELSA Tools

// FNicklis 23.10.98: Need it sometimes ;-)
#ifndef DWORD
typedef unsigned long DWORD;
#endif

// FNicklis 23.10.98: Under NT we don't have FAR and NEAR
#ifndef FAR
#define FAR
#endif

#ifdef NTMINIPORT
// FNicklis 29.01.1999: don't know HWND in NT miniport
#ifndef HWND
#define HWND PVOID
#endif
#endif// NTMINIPORT

// Subescapes: 0x00000000 - 0x0fffffffbasic sub escapes
//             0x10000000 - 0x1fffffff to be defined by Win95
//             0x20000000 - 0x2fffffff to be defined by NT (NTeam)
//             0x30000000 - 0xffffffff unused
// Naming: SUBESC_ET_xxxx, read: Sub escape for ELSA tools
//
// Note: Queries should use the same in structure ET_QUERY but different
//       query subescapes SUBESC_ET_QUERY_yyyy

// ********************************************************
// Sub escapes, common for Windows 95 and Windows NT:
#define SUBESC_ET_QUERY_VERSION_INFO        0x00000000

#define SUBESC_ET_QUERY_VALUE_STRING        0x00000010
#define SUBESC_ET_QUERY_VALUE_DWORD         0x00000011
#define SUBESC_ET_QUERY_VALUE_BINARY        0x00000012

#define SUBESC_ET_SET_VALUE_STRING          0x00000018
#define SUBESC_ET_SET_VALUE_DWORD           0x00000019
#define SUBESC_ET_SET_VALUE_BINARY          0x00000020

// 0x30-0x4F reserved for WINman
#define SUBESC_ET_WINMAN_DATA_GET           0x00000030
#define SUBESC_ET_WINMAN_DATA_SET           0x00000031
#define SUBESC_ET_WINMAN_DDC_EDID_GET       0x00000032
#define SUBESC_ET_WINMAN2_DATA_GET          0x00000035
#define SUBESC_ET_WINMAN2_DATA_SET          0x00000036
#define SUBESC_ET_WINMAN2_DDC_EDID_GET      0x00000037

// 0x50-0x6F reserved for elsa directdraw caps
#define SUBESC_ET_EDD_GETCAPS               0x00000050
#define SUBESC_ET_EDD_GETFEATURES           0x00000051
#define SUBESC_ET_EDD_SETFEATURES           0x00000052
#define SUBESC_ET_EDD_GETVIDMEMINFO         0x00000053
#define SUBESC_ET_EDD_GETCOLORADJUSTMENT    0x00000054
#define SUBESC_ET_EDD_SETCOLORADJUSTMENT    0x00000055
#define SUBESC_ET_EDD_SETGAMMARAMP          0x00000056
#define SUBESC_ET_EDD_GETGAMMARAMP          0x00000057
#define SUBESC_ET_EDD_GETCOLORCAPSLIMITS    0x00000058

// 0x100-0x11F reserved for Video-In / -Out Escapes
//
#define SUBESC_ET_VIDEO_DMACOPYSM           0x00000100
#define SUBESC_ET_VIDEO_OUTCONTROL          0x00000110
#define SUBESC_ET_RMAPI_CONFIGSETGET        0x0000011F

// 0x200-0x21F reserved for all tools to decide if they are
//             allowed to pop up, only to be used in combination
//             with a resctricted call RES_ESC_ELSA_TOOL
//
#define SUBESC_STEREO_TOOL                  0x00000200

// 0x300-0x3FF reserved for hardware status and control
//
#define SUBESC_ET_QUERY_TEMPERATURE         0x00000300

#define SUBESC_ET_GET_OUTPUT_DEVICE_INFO    0x00000310
#define SUBESC_ET_SET_OUTPUT_DEVICE         0x00000311


// ********************************************************
// Windows 95 sub escapes:

#define SUBESC_ET_QUERY_MONITORKEY_REGPATH  0x10000000
#define SUBESC_ET_QUERY_D3DSETTINGS_REGPATH 0x10000001

// ********************************************************
// Windows NT sub escapes:

#define SUBESC_ET_QUERY_OPENGLICD_REGPATH   0x20000000
#define SUBESC_ET_DUO_ESC_GETPANELINFO      0x20000002  //Returns Information on our Panel/PanelCaps
#define SUBESC_ET_DUO_ESC_SETPANELINFO      0x20000004  //Sets Panel Information
#define SUBESC_ET_POWERLIB_START            0x20000008  //Tells driver that one powerlib has started
#define SUBESC_ET_POWERLIB_EXIT             0x20000009  //Tells driver that one powerlib will end

// 0x10-0x2F reserved for driver internal escapes
#define SUBESC_ET_GETREGISTER               0x20000010  // direct hw access
#define SUBESC_ET_SETREGISTER               0x20000011
#define SUBESC_ET_MODIFYREGISTER            0x20000012
#define SUBESC_ET_SCROLL                    0x20000013
#define SUBESC_ET_GFXOPTIONQUERY            0x20000014

#define SUBESC_ET_NOTIFYDRIVER              0x20000015  // special support for video capture driver
#define SUBESC_ET_SAA                       0x20000016
#define SUBESC_ET_DDSURFOVERRIDE            0x20000017

#define SUBESC_ET_MULTIBOARDSETUP           0x20000018 // FNicklis: setup singleboard client with information from multiboard wrapper.
                                                       // IO structures ET_MULTIBOARDSETUP_IN and ET_MULTIBOARDSETUP_OUT are defined in driver code!
#define SUBESC_ET_DPMS                      0x20000019 // FNicklis: set DPMS power save mode; uses ET_DPMS_IN and ET_DPMS_OUT

// 0x30- ... Common driver Escapes
#define SUBESC_ET_SETWINDOW_STEREOMODE      0x20000030 // set the stereo mode of an OpenGL window
#define SUBESC_ET_QUERY_ICDCLIENTINFO       0x20000031 // receive information about OpenGL-Clients


// ********************************************************
// ********************************************************
// In structure (Tool -> driver):
// Input Query structure, common part of all subescape input structures
// --------------------------------------------------------------------
typedef struct tagET_QUERY
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_QUERY)
  DWORD dwSubEsc;  // has to be (SUBESC_ET_QUERY_VERSION_INFO, SUBESC_ET_QUERY_OPENGLICD_REGPATH, ...)
  DWORD dwOutSize; // size of output data structure (if there is such data)
  DWORD dwBoard;   // for registry issues we need to know for what board we have to read/write @@db 130498
                   // Calls that affect all boards use ET_ALL_BOARDS to initialize dwBoard
                   // 0 -> board 0, 1 -> board 1, ET_ALL_BOARDS -> all boards
} ET_QUERY;

#define ET_ALL_BOARDS 0xFFFFFFFF   // FNicklis, 11.03.99 reserved key for all boards

// driver get's PVOIDs but needs a fast access to members
#define ET_QUERY_GET_SUBESC(pv)    (((ET_QUERY*)pv)->dwSubEsc)
#define ET_QUERY_GET_BOARD(pv)     (((ET_QUERY*)pv)->dwBoard)

// ********************************************************
// ********************************************************
// Version info and some other data from driver
// --------------------------------------------

#define MAX_ET_VERSION 64

#define ET_VER_RELEASE_DRIVER    0x0
#define ET_VER_WHQL_DRIVER       0x1 // Release driver for WHQL
#define ET_VER_BETA_DRIVER       0x2 // Beta driver neither release nor WHQL

// Out structure (Driver -> Tool):
// Version information used in ET_VERSION_INFO, retrieved by SUBESC_ET_QUERY_VERSION_INFO

#ifdef WIN32
#pragma warning( disable:4201 ) // nonstandard extension used : nameless struct/union
#endif

// Usage of ET_VERSION_STAMP:
//
// Allowes to check which bits of the capabilities fields are defined.
// You may only test the bits defined in the version matching the version
// stamp.
//
// NOTE: The version stamp is only valid for the ET_VERSION structure!
//   Don't validate other structures with this!
//
// NOTE: A tool may only test the capabilities defined for the version
//   matching the version stamp.
//
// NOTE: Newer versions must support the capabilites of older versions!
//
// NOTE: A tool must check for an equal version stamp as older drivers
//   didn't touch the reserved flags, and leaved them initialized!
//   It isn't allowed to do a greater equal test on the verstion stamp!
//
// example:
/*
// FNicklis 25.11.98 15:30:15: example program
BOOL bIsCVBoard(
  IN const ET_VERSION_INFO *pVersionInfo)  // pointer to version info (read outside)
{
  const ET_VERSION *pVersion;
  BOOL              bRet     = FALSE; // default is no CV board

  assert(NULL!=pVersionInfo);

  pVersion = &(pVersionInfo->Version);

  // as it is a union it must be the same!
  assert(pVersion->dwNTVersionStamp ==pVersion->dwW95VersionStamp);
  assert(pVersion->dwW95Capabilities==pVersion->dwNTCapabilities);

  //Not allowed! if ( pVersion->dwNTVersionStamp>ET_VERSION_STAMP10 )

  // ET_VERSION_STAMP10 was the first version that supported
  // this extenstion

  if ( ET_VERSION_STAMP10==pVersion->dwNTVersionStamp )
  {
    // it's a version 1.0, supported by our app

    // we may test 1.0 features: ET_VERSION_CAPS_CV_PRODUCT and ET_VERSION_CAPS_2D_BOARD_ONLY
    if ( pVersion->dwNTCapabilities & ET_VERSION_CAPS_CV_PRODUCT )
    {
      bRet = TRUE;
    }
  }
  else
  {
    // error, interface not valid
    // older board -> fallback
    // unknown board -> exit

    // .... add code here
  }

  return (bRet);
}
*/
// History:
// ???????? uninitialized and any other value than defined VERSION_STAMPS are
//          invalid and don't support the interface!
// 00000010: First version 1.0 valid and testableET_VERSION_CAPS_xx:
//     xx_CV_PRODUKT
//     xx_2D_BOARD
#define ET_VERSION_STAMP10 0x00000010         // FNicklis 30.09.1998 first version

// please don't use ET_VERSION_STAMP any longer!
#define ET_VERSION_STAMP  ET_VERSION_STAMP10  // Current version stamp is highest available, but better is
                                              // to use the stamp you know you support!
// capabilities
// defined in 1.0:
//                      CH == !CV product
#define ET_VERSION_CAPS_CV_PRODUCT     0x01 // The board is a CV product (GLoria, Synergy, ...)
                                            // GLoria Settings, POWERlib, ... must run
//                      3D == !2D
#define ET_VERSION_CAPS_2D_BOARD_ONLY  0x02 // The board has only 2D and no hardware 3D capabilities (Trio, S3 986,..)

//
#define ET_VERSION_CAPS_DIRECT3DSTEREO 0x04 // Driver supports REVELATOR type Stereo for Direct3D
#define ET_VERSION_CAPS_OPENGLSTEREO   0x08 // Driver supports REVELTAOR type Stereo for OpenGL
#define ET_VERSION_CAPS_OVERCLOCKING   0x10 // Driver supports overclocking
#define ET_VERSION_CAPS_TEMPERATURE    0x20 // Driver supports temperature control

// ... to be continued


// used with SUBESC_ET_QUERY_VERSION_INFO
typedef struct tagET_VERSION
{
  DWORD dwFlags;                     // Flags to define WHQL, BETA, ... driver
  DWORD dwAlign1;                    // needed to align on 8 byte boundaries

  // NT and Win95 version data is different, so use a union to match all
  union
  {
    struct // Windows 95 version information
    {
      DWORD dwW95Major;        //
      DWORD dwW95Minor;        //
      DWORD dwW95BuildMajor;   //
      DWORD dwW95BuildMinor;   //
      DWORD dwW95BuildPrivate; //
      DWORD dwW95Reserved1;    // unused
      DWORD dwW95Capabilities; // bitfield containing capabilities (ET_VERSION_CAPS_xx)
      DWORD dwW95VersionStamp; // == ET_VERSION_STAMP (read comment above!) Has to be verified before reading dwW95Capabilities!
    };
    struct // Windows NT version information
    {           // e.g 5.12.00.345
      DWORD dwNTMajor;      //   5
      DWORD dwNTMinor;      //  12
      DWORD dwNTBuildMajor; //  00
      DWORD dwNTBuildMinor; // 345
      DWORD dwNTReserved0;
      DWORD dwNTReserved1;
      DWORD dwNTCapabilities; // bitfield containing capabilities (ET_VERSION_CAPS_xx)
      DWORD dwNTVersionStamp; // == ET_VERSION_STAMP (read comment above!). Has to be verified before reading dwNTCapabilities!
    };
  };

  char  szVersion[MAX_ET_VERSION]; // Version string (ANSI/ASCCI)

} ET_VERSION;

#ifdef WIN32
#pragma warning( default:4201 ) // nonstandard extension used : nameless struct/union
#endif

// Out structure (Driver -> Tool):
// Structure to retrieve driver version and registry data
typedef struct tagET_VERSION_INFO
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_VERSION_INFO)

  // Driver version information (system dependent!)
  ET_VERSION Version;

  // Complete path to drivers registry (be sure it is defined long enough!)
  char  szRegDriverKey[ET_MAX_PATH]; // e.g. NT:    "\Registry\Machine\System\CurrentControlSet\Services\EGLXLM"
                                 // e.g. Win95: "\Registry\Machine\System\CurrentControlSet\Services\Class\Display\0000"

} ET_VERSION_INFO;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to key where the monitor is defined
typedef struct tagET_MONITORKEY_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_MONITORKEY_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegMonitorKey[ET_MAX_PATH];  // e.g. Win95: "\Registry\Machine\System\CurrentControlSet\Services\Class\Monitor\0000"

} ET_MONITORKEY_REGPATH;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to key where D3DSettings store its settings
typedef struct tagET_D3DSETTINGS_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_D3DSETTINGS_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegD3DSettingsKey[ET_MAX_PATH];  // e.g. Win95: "\Registry\Machine\Software\ELSA\Erazor"

} ET_D3DSETTINGS_REGPATH;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to Key where the ICD is defined
typedef struct tagET_OPENGLICD_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_OPENGLICD_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegICDKey[ET_MAX_PATH];  // e.g. NT: "\Registry\Machine\Software\Microsoft\WindowsNT\OpenGLDrivers\ELSA EGLXLM driver"
  char  szRegICDName[ET_MAX_PATH]; // e.g. NT: "EOGLXL"

} ET_OPENGLICD_REGPATH;




// ET_EDD_GETVIDMEMINFO
// get surface counts
typedef struct tagET_EDD_GETVIDMEMINFODATA
{
  DWORD   dwSize;
  DWORD   dwPrimaryCount;
  DWORD   dwOffscreenCount;
  DWORD   dwOverlayCount;
} ET_EDD_GETVIDMEMINFODATA, FAR* LPET_EDD_GETVIDMEMINFODATA;


#define ET_COLOR_CAPS_CONTRAST    0x01    // driver supports contrast settings and limitations are valid
#define ET_COLOR_CAPS_BRIGHTNESS  0x02    // driver supports brightness settings and limitations are valid
#define ET_COLOR_CAPS_SATURATION  0x04    // driver supports saturation settings and limitations are valid
#define ET_COLOR_CAPS_HUE         0x08    // driver supports hue settings and limitations are valid

// ET_EDD_GETCOLORCAPSLIMITS
// get capability of contrast, brightness saturation and hue
// and their limits. The limits are only valid if the capability
// is set.
typedef struct tagET_EDD_GETCOLORCAPSLIMITS
{
  DWORD   dwSize;
  DWORD   dwColorCaps;
  long    lContrastMin;
  long    lContrastMax;
  long    lBrightnessMin;
  long    lBrightnessMax;
  long    lSaturationMin;
  long    lSaturationMax;
  long    lHueMin;
  long    lHueMax;
  long    reserved[20];     // some spare left for future
} ET_EDD_GETCOLORCAPSLIMITS, FAR* LPET_EDD_GETCOLORCAPSLIMITS;


// ET_EDD_SETCOLORADJUSTMENT
// set contrast, brightness saturation and hue
// values for each item is 0..9999
typedef struct tagET_EDD_SETCOLORADJUSTMENTDATA
{
  ET_QUERY hdr;				// size and subescape SUBESC_ET_EDD_SETCOLORADJUSTMENT
  long   dwContrast;
  long   dwBrightness;
  long   dwSaturation;
  long   dwHue;
} ET_EDD_SETCOLORADJUSTMENTDATA, FAR* LPET_EDD_SETCOLORADJUSTMENTDATA;


// ET_EDD_GETCOLORADJUSTMENT
// get contrast, brightness saturation and hue
// values for each item is 0..9999
typedef struct tagET_EDD_GETCOLORADJUSTMENTDATA
{
  DWORD   dwSize;
  long    dwContrast;
  long    dwBrightness;
  long    dwSaturation;
  long    dwHue;
  DWORD   dwYUVOverlayVisibleCount;
} ET_EDD_GETCOLORADJUSTMENTDATA, FAR* LPET_EDD_GETCOLORADJUSTMENTDATA;


// ET_EDD_SETFEATURES  set ELSA DirectDraw features
typedef struct tagET_EDD_SETFEATURESDATA
{
  ET_QUERY hdr;				// size and subescape SUBESC_ET_EDD_SETFEATURES
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_SETFEATURESDATA, FAR* LPET_EDD_SETFEATURESDATA;


// ET_EDD_GETFEATURES get ELSA DirectDraw features
typedef struct tagET_EDD_GETFEATURESDATA
{
  DWORD   dwSize;
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_GETFEATURESDATA, FAR* LPET_EDD_GETFEATURESDATA;


// ET_EDD_GETCAPS
//   retrieves capabilitie of ELSA DirectDraw features
//   capabilities depends on hardware, resolution and pixel depth
typedef struct tagET_EDD_GETCAPSDATA
{
  DWORD   dwSize;
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_GETCAPSDATA, FAR* LPET_EDD_GETCAPSDATA;

// ET_GAMMA_SET
//   _TEMPORARY_ set a gamma table.
//   This escape immediately sets the gamma table to the device. The table
//   is not stored permanently by the device. Means, after reboot, the
//   original 1:1 (or what ever else) table is reloaded by hardware.
//   To store the table, use the ELSA Subescape:
//      SUBESC_ET_SET_VALUE_BINARY::ET_VALUE_BIN_GDI_GAMMARAMP
//
//   Information about the success of the SET call is provided
//   via a ET_SET_VALUE_RET structure
//   If the hardware generally supports gamma ramps, but not in the current
//   mode (256 colors), the flags field in the output structure contains
//   ET_VALUE_BLOCKED.

typedef struct tagET_EDD_SETGAMMARAMP
{
  ET_QUERY hdr;       // size and subescape SUBESC_ET_EDD_SETGAMMARAMP
  WORD     red[256];
  WORD     green[256];
  WORD     blue[256];
} ET_EDD_SETGAMMARAMP, FAR* LPET_EDD_SETGAMMARAMP, * PET_EDD_SETGAMMARAMP;

typedef struct tagET_EDD_GETGAMMARAMP
{
  DWORD   dwSize;
  DWORD   dwResult;		// ET_VALUE_OK if succeeded and ET_VALUE_BLOCKED if Gamma not supported yet
  WORD    red[256];
  WORD    green[256];
  WORD    blue[256];
} ET_EDD_GETGAMMARAMP, FAR* LPET_EDD_GETGAMMARAMP, * PET_EDD_GETGAMMARAMP;

// ET_VIDEO_DMACOPYSM
//   copies video memory to system memory by DMA
typedef struct tagET_VIDEO_DMACOPYSMDATA
{
  ET_QUERY  hdr;

  DWORD     dwDstSel;       // Selector of destination memory (16Bit) / NULL (32Bit)
  DWORD     dwDstOfs;       // Offset of destination memory (16Bit) / Linear Address (32Bit)
  DWORD     dwDstStride;    //

  DWORD     dwSrcSel;       // Selector of source video memory (16Bit) / NULL (32Bit)
                            // The base of the selector points to the start of the video memory
  DWORD     dwSrcOfs;       // Offset of source video memory (16Bit) / Linear Address (32Bit)
                            // This is the offset relative to the beginning of video memory
  DWORD     dwSrcStride;    //

  DWORD     dwWidthBytes;   // Amount of bytes to transfer in one line (must be aligned to 4)
  DWORD     dwHeight;       // Anount of lines to transfer
} ET_VIDEO_DMACOPYSMDATA, FAR* LPET_VIDEO_DMACOPYSMDATA;

// ET_VIDEO_OUTCONTROL
//   controls video-out
typedef struct tagET_VIDEO_OUTCONTROL
{
  ET_QUERY  hdr;

  DWORD     dwEnable;
  DWORD     dwControl;
  DWORD     dwParam1;
  DWORD     dwParam2;
} ET_VIDEO_OUTCONTROL, FAR* LPET_VIDEO_OUTCONTROL, * PET_VIDEO_OUTCONTROL;

// ET_RMAPI_CONFIGSETGET
//   allows escape access to stateConfigGet [...] routines.
typedef struct tagET_RMAPI_CONFIGSETGET
{
  ET_QUERY  hdr;
  DWORD     dwSetGetCommand;
  DWORD     dwIndex;
  DWORD     dwlpParamStruct;
  DWORD     dwParamSize;
  DWORD     dwValue;
  DWORD     dwParam0;
  DWORD     dwParam1;
  DWORD     dwParam2;
} ET_RMAPI_CONFIGSETGET, FAR* LPET_RMAPI_CONFIGSETGET, * PET_RMAPI_CONFIGSETGET;

// Constants for ELSA DirectDraw features:
//
// dwEddCaps0:
#define EDDCAPS_DITHER              0x00000001
#define EDDCAPS_FILTERX             0x00000002
#define EDDCAPS_FILTERY             0x00000004
#define EDDCAPS_FILTERX_LIN02420    0x00000008
#define EDDCAPS_FILTERX_BILINEAR    0x00000010
#define EDDCAPS_FILTERX_LIN12221    0x00000020
#define EDDCAPS_OFFSCREENINHIBIT    0x00000040
#define EDDCAPS_OFFSCREENLINEAR     0x00000080
#define EDDCAPS_COLORADJUSTYUV_CB   0x00000100
#define EDDCAPS_COLORADJUSTYUV_HS   0x00000200
#define EDDCAPS_FILTERXY_BILINEAR   0x00000400
#define EDDCAPS_DITHER_ALWAYS_ON    0x00000800
#define EDDCAPS_ENABLE_332_TEXTURE  0x00001000

// 3D-Features
#define EDDCAPS_INHIBIT_ZBUFFER     0x00010000
#define EDDCAPS_INHIBIT_PERSCORRECT 0x00020000
#define EDDCAPS_INHIBIT_TEXTURE     0x00040000
#define EDDCAPS_INHIBIT_FOG         0x00080000
#define EDDCAPS_INHIBIT_FILTER      0x00100000
#define EDDCAPS_INHIBIT_ALPHA       0x00200000
// ViRGE/DX has a fast bilinear algorithm
#define EDDCAPS_FASTBILINEAR        0x00400000
// emuliere Colorkey for a Texture using texture alpha blending
#define EDDCAPS_EMULATE_TEX_CKEY    0x00800000
#define EDDCAPS_SIMULATE_MIPMAP     0x01000000

// Commands
#define EDDCMD_ALLOCFILTERYBUF      0x80000001

// Bedeutung der einzelnen Bits in dwEddCaps0 beim Aufruf von
// EDDESC_SETFEATURES:
//
// Achtung: Ein Bit darf nur gesetzt werden, wenn das entsprechende Bit
//          vorher bei einem Aufruf von EDD_GETCAPS als gueltig gemeldet
//          wurde.
//
// EDDCAPS_DITHER  : 1=Dithering ein. 0=Dithering aus.
//
// EDDCAPS_FILTERX : 1=Schalte einen Filter ein. Ggf. kann mit anderen
//                   Konstanten eine spezieller Filter definiert werden.
//                   Wird kein spezieller Filter ausgewaehlt (obwohl
//                   es moeglich waere) so sucht der Treiber einen adequaten
//                   Filter aus.
//                   0=Alle Filter aus.
//
// EDDCAPS_FILTERX_xxxxx : Schalte diesen speziellen Filter ein, wenn auch
//                         EDDCAPS_FILTERX gesetzt ist.
//
// EDDCAPS_OFFSCREENLINEAR: Weist den DirectDraw-Treiber an, linearen
//                          Offscreen falls moeglich (!) zu benutzen, um z.B.
//                          eine bessere Speicherausnutzung zu erreichen, oder
//                          die Erzeugung von Offscreen-Surfaces zu ermoeglichen,
//                          deren Breite (in Bytes) groesser ist als die Breite
//                          des Primary-Surface.
//                          Wenn dieses Bit beim Zuruecklesen gesetzt ist,
//                          ist der Offscreen tatsaechlich linear, ansonsten
//                          nicht.
//
//
// EDDCAPS_COLORADJUSTYUV_CB : 0=Kontrast/Helligkeit-Werte ohne Wirkung
//                             1=Kontrast/Helligkeit wird gemaess der per
//                               EDDESC_SETCOLORADJUSTMENT gewaehlten Werte
//                               eingestellt.
//
// EDDCAPS_COLORADJUSTYUV_HS : 0=Phase/Saettigungs-Werte ohne Wirkung
//                             1=Phase/Saettigung wird gemaess der per
//                               EDDESC_SETCOLORADJUSTMENT gewaehlten Werte
//                               eingestellt.

// Bedeutung der einzelnen Bits in dwEddCaps0 beim Aufruf von EDDESC_GETCAPS:
// -------------------------------------------------------------------------
//
// EDDCAPS_DITHER  : Der Treiber beherrscht Dithering zur Verbesserung der
//                   Bildqualitaet.
//
// EDDCAPS_FILTERX : Der Treiber beherrscht eine allgemeine Methode zum
//                   Filtern in X-Richtung. Ueber andere Bits
//                   EDDCAPS_FILTERX_xxxxx KANN der Treiber angeben, welche
//                   speziellen Filterfaehigkeiten er kennt.
//
// EDDCAPS_FILTERY : Der Treiber beherrscht eine allgemeine Methode zum
//                   Filtern in Y-Richtung.
//
// EDDCAPS_FILTERX_LIN02420
// EDDCAPS_FILTERX_BILINEAR
// EDDCAPS_FILTERX_LIN12221 : Der Treiber beherrscht diesen Filter in X-
//                            Richtung. Wenn diese Bit gesetzt ist, wird
//                            auch EDDCAPS_FILTERX gesetzt.
//
// EDDCAPS_OFFSCREENINHIBIT : Der Treiber bietet die Moeglichkeit, die
//                            Erzeugung von Offscreen-Surfaces zu
//                            unterbinden.
//
// EDDCAPS_OFFSCREENLINEAR : Der Treiber bietet die Moeglichkeit, lineare
//                           Offscreenverwaltung zu erwuenschen.
//                           Diesen Wunsch kann der Treiber erfuellen, er
//                           muss es aber nicht.
//
// EDDCAPS_COLORADJUSTYUV_CB : Der Treiber bietet die Moeglichkeit Kontrast
//                             und Helligkeit eines YUV-Videos einzustellen.
//
// EDDCAPS_COLORADJUSTYUV_HS : Der Treiber bietet die Moeglichkeit "Hue" und
//                             Saettigung eines YUV-Videos einzustellen.





// ********************************************************
// ********************************************************
// New *_VALUE_* Interface to replace registry accesses for driver data by escapes
// -------------------------------------------------------------------------------

// In structure (Tool -> driver):
// Input Structure to set a registry string
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_STRING
{
  ET_QUERY hdr;   // size and subescape SUBESC_ET_SET_VALUE_STRING
                  // dwSize parameter of ET_QUERY holds length of this structure
                  //    i.e. hdr.dwSize >= sizeof(ET_SET_VALUE_STRING)
                  //   ET_MAX_STRING is the minimal length of the string!

  DWORD dwID;     // ID of string to set (ET_VALUE_SZ_...)
  char  szValue[ET_MAX_STRING];

} ET_SET_VALUE_STRING, *PET_SET_VALUE_STRING;

// In structure (Tool -> driver):
// Input Structure to set a registry DWORD
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_DWORD
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SET_VALUE_DWORD

  DWORD    dwID;    // ID of dword to set (ET_VALUE_DW_...)
  DWORD    dwValue; // value to set

} ET_SET_VALUE_DWORD, *PET_SET_VALUE_DWORD;

// In structure (Tool -> driver):
// Input Structure to set binary data to registry
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_BINARY
{
  ET_QUERY hdr;       // size and subescape SUBESC_ET_SET_VALUE_DWORD

  DWORD    dwID;      // ID of dword to set (ET_VALUE_DW_...)
  char     ajData[1]; // array of binary data
  // The true size of this array can be re-calculated from hdr.dwSize

} ET_SET_VALUE_BINARY, *PET_SET_VALUE_BINARY;
// Size of the structure without the data array
#define ET_SET_VALUE_BINARY_HDR_SIZE (sizeof(ET_SET_VALUE_BINARY)-sizeof(DWORD))

// use in struct ET_QUERY_VALUE.dwType
#define ET_VALUE_TYPE_DWORD           0x00  // subesc SUBESC_ET_QUERY_VALUE_DWORD
#define ET_VALUE_TYPE_STRING          0x01  // subesc SUBESC_ET_VALUE_TYPE_STRING
#define ET_VALUE_TYPE_BINARY          0x02  // subesc SUBESC_ET_VALUE_TYPE_BINARY

// Query defaults: Same as ET_VALUE_TYPE_xx but driver allways returns the values default.
// If an ESC-error is returned, the driver doesn't support the default query!
#define ET_VALUE_DEFAULT_FLAG         0x80
#define ET_VALUE_TYPE_DEFAULT_DWORD   (ET_VALUE_DEFAULT_FLAG|ET_VALUE_TYPE_DWORD)   // subesc SUBESC_ET_QUERY_VALUE_DWORD
#define ET_VALUE_TYPE_DEFAULT_STRING  (ET_VALUE_DEFAULT_FLAG|ET_VALUE_TYPE_STRING)  // subesc SUBESC_ET_VALUE_TYPE_STRING

// In structure (Tool -> driver):
// Input Structure to query a registry DWORD
// Output data is returned in ET_VALUE_STRING or ET_VALUE_DWORD
typedef struct tagET_QUERY_VALUE
{
  ET_QUERY hdr;    // size and subescapes SUBESC_ET_QUERY_VALUE_STRING or SUBESC_ET_QUERY_VALUE_DWORD
                   // if outsize for strings > sizeof(ET_VALUE_STRING) the buffer can take longer than the
                   // default strings! Only check if the out buffer is to small to fit the data. The bigger
                   // the better!

  DWORD dwID;      // ID of dword to query (ET_VALUE_DW_..., ET_VALUE_SZ_...)
  DWORD dwType;    // This identifies what kind of data is requested (type of output structure) (ET_VALUE_TYPE_DWORD,...)
                   // Allways assign this value and be sure to set all necessary bits too!
} ET_QUERY_VALUE, *PET_QUERY_VALUE;


// Out structure (Driver -> Tool):
// Output Structure used to return a string from the driver in subesc SUBESC_ET_QUERY_VALUE_STRING
// used by input structure ET_QUERY_VALUE and dwType ET_VALUE_TYPE_STRING
typedef struct tagET_VALUE_STRING
{
  DWORD dwSize;    // Length of this structure (should be the same as ET_QUERY_VALUE's outbuffer size)
  DWORD dwID;      // identifier of string to query (additional and as alignment) (ET_VALUE_SZ_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags
  char  szValue[ET_MAX_STRING]; // zero terminated ASCII/ANSI string (no UNICODE!)

} ET_VALUE_STRING, *PET_VALUE_STRING;


// Out structure (Driver -> Tool):
// Structure used to return a DWORD from the driver in subesc SUBESC_ET_QUERY_VALUE_DWORD
// used by input structure ET_QUERY_VALUE and dwType ET_VALUE_TYPE_DWORD
typedef struct tagET_VALUE_DWORD
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_VALUE_DWORD)
                   // (should be the same as ET_QUERY_VALUE's outbuffer size)

  DWORD dwID;      // identifier of queried dword to query (additional and as alignment) (ET_VALUE_DW_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags
  DWORD dwValue;   // return value

} ET_VALUE_DWORD, *PET_VALUE_DWORD;

// Out structure (Driver -> Tool):
// Structure used to return binary data from the driver in subesc
// SUBESC_ET_QUERY_VALUE_BINARY used by input structure ET_QUERY_VALUE
// and dwType ET_VALUE_TYPE_BINARY
typedef struct tagET_VALUE_BINARY
{
  DWORD dwSize;    // Length of this structure, at least ET_QUERY_VALUE_BINARY_HDR_SIZE
                   // (should be the same as ET_QUERY_VALUE's outbuffer size)
  DWORD dwID;      // identifier of binary to query (additional and as alignment) (ET_VALUE_DW_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value,
                   // ET_VALUE_OK=value set and all is OK,
                   // ET_VALUE_ERROR_SIZE=structure is too short for all the data,
                   //                     see dwSizeData for the required size
                   // others are error codes or additional information flags
  DWORD dwSizeData; // size of binary data, especially the required size, when
                    // dwFlags return ET_VALUE_ERROR_SIZE

  char  ajData[1]; // dwSizeData bytes of data

} ET_VALUE_BINARY, *PET_VALUE_BINARY;
// Size of the structure without the data array
#define ET_QUERY_VALUE_BINARY_HDR_SIZE (sizeof(ET_VALUE_BINARY)-sizeof(DWORD))


// Flags used in ET_SET_VALUE_RET or ET_VALUE_XXX as return values
//   bit 31 (higest bit) == 0: function was successfull and additional information for values != 0
//   bit 31 (higest bit) == 1: error
#define IsError(Value)      ((Value & 0x80000000)!=0)
#define IsOK(Value)         ((Value & 0x80000000)==0)


//  ET_VALUE_xx return codes used in dwFlags are 32 bit values layed out as follows:

//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-----------------------------------------------------------+
//  |0 r|                                       Bitfield            | success
//  +---+-----------------------------------------------------------+
//  |1 r|                                       ErrorCode           | error
//  +---+-----------------------------------------------------------+
//  r = reserved
//                            bitfield
#define ET_VALUE_OK         0x00000000 // Value function is successfull
#define ET_VALUE_REBOOT     0x00000001 // a reboot is necessary to acivate after value set
#define ET_VALUE_DEFAULT    0x00000002 // Value function had problems and returned defaults
#define ET_VALUE_BLOCKED    0x00000004 // Value is blocked by running application and not set in driver! (e.g. ask user to close application)

//                          Bit   Code
#define ET_VALUE_ERROR		  0x80000000 // application reserved value for ESCAPE failed (not used in driver!)
#define ET_VALUE_UNKNOWN    0x80000001 // Value to get/set is unknown or not supported (e.g. grey button)
#define ET_VALUE_ERROR_SIZE 0x80000002 // returnbuffer is smaller than the value to get

// Out structure (Driver -> Tool):
// structure passed back to caller
typedef struct tagET_SET_VALUE_RET
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_SET_VALUE_RET)

  DWORD dwID;      // identifier of set value (additional and as alignment) (ET_VALUE_DW_...)

  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags

  DWORD dwAlign;   // unused
} ET_SET_VALUE_RET, *PET_SET_VALUE_RET;


// ********************************************************
// query/set values identifier:
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-------+-------+-----------------------------------------------+
//  |o o o o|r r r r|                                          code |
//  +-------+-------+-----------------------------------------------+
//
//  o = bitfield defining OS dependencies
//    0       = no specific OS
//    0x1     = Win9x
//    0x2     = Win NT
//    0x4,0x8 = unused
//  r = bitfield reserved for driver internal stuff.
//    This field must be 0 in all IDs-codes called via ExtEscape!
//
//    Use this code to check Esc-IDs validity:
//
//    DrvEscape (...)
//    {
//      // check if the caller gives us a valid dwID,
//      // All reserved bits have to be 0!
//      ASSERT( 0==(pEtValue->dwID & ET_VALUE_OS_RESERVED) ); // check the tool which called!
//      ...
//    }
//
//  code = number of identifer, no bitfield.
//    valid range: 0x000000 - 0xffffff (3 Byte)
//    New ID code increments by one.
//
//  Resulting ranges:
//    0x00000000 - 0x00ffffff basic values, common to all operating systems
//    0x10000000 - 0x10ffffff to be defined by Win95
//    0x20000000 - 0x20ffffff to be defined by NT (NTeam)
//    0x40000000 - 0x40ffffff unused
//    0x80000000 - 0x80ffffff unused
// Naming: ET_VALUE_DW_xxxx, read: ELSA tools value dword
//         ET_VALUE_SZ_xxxx, read: ELSA tools value zero terminated string (single byte char)
//

#define ET_VALUE_OS_WIN9x                                   0x10000000 // Bit defining IDs known by Windows 9x driver
#define ET_VALUE_OS_WINNT                                   0x20000000 // Bit defining IDs known by Windows NT driver
#define ET_VALUE_OS_unused0                                 0x40000000 //
#define ET_VALUE_OS_unused1                                 0x80000000 //

#define ET_VALUE_OS_RESERVED                                0x0F000000 // Bits that are reserved for the driver internaly

// Windows 9x
//
#define ET_VALUE_DW_D3DOGL_MCLK                             ( ET_VALUE_OS_WIN9x | 0x00CA0001 )
#define ET_VALUE_DW_D3DOGL_NVCLK                            ( ET_VALUE_OS_WIN9x | 0x00CA0002 )
#define ET_VALUE_DW_D3DOGL_OVERCLOCK_ENABLE                 ( ET_VALUE_OS_WIN9x | 0x00CA0003 )
#define ET_VALUE_DW_D3DOGL_OVERCLOCK_CRASHSTATUS            ( ET_VALUE_OS_WIN9x | 0x00CA0004 )
#define ET_VALUE_DW_D3DOGL_DEFAULT_MCLK                     ( ET_VALUE_OS_WIN9x | 0x00CA0005 )
#define ET_VALUE_DW_D3DOGL_DEFAULT_NVCLK                    ( ET_VALUE_OS_WIN9x | 0x00CA0006 )

// Windows NT
//
// Basic/system 0x20000000-0x200000ff
//#define ET_VALUE_SZ_IMAGEPATH                               0x20000000
//#define ET_VALUE_SZ_INSTALLEDDISPLAYDRIVERS                 0x20000001

#define ET_VALUE_DW_GDI_DESKTOPONMAXIMIZE                   0x20000050 // DesktopOnMaximize
#define ET_VALUE_DW_GDI_ENABLEDEVICEBITMAPS                 0x20000051 // EnableDeviceBitmaps
#define ET_VALUE_DW_GDI_ENABLEPCIDISCONNECT                 0x20000052 // PCIDisconnect
#define ET_VALUE_DW_GDI_EXPORTONLYDOUBLEBUFFERMODES         0x20000053 // ExportOnlyDoubleBufferModes
#define ET_VALUE_DW_GDI_NTEAMPRIVATEKEY                     0x20000054
#define ET_VALUE_DW_GDI_P6ENABLEUSWC                        0x20000055 // DRV_PPRO_ENABLE_WCB
#define ET_VALUE_DW_GDI_REVERSESCREENORDER                  0x20000056 // ReverseScreenOrder
#define ET_VALUE_DW_GDI_USEGETACCESSRANGES                  0x20000057 // UseGetAccessRanges
#define ET_VALUE_DW_GDI_USELCDPANEL                         0x20000058 // UseLCDPanel
#define ET_VALUE_DW_GDI_VERTICALSCREENORDER                 0x20000059 // VerticalScreenOrder
#define ET_VALUE_DW_GDI_WAITFORFIFOS                        0x2000005a // EngineSynchronization
#define ET_VALUE_DW_GDI_DEVICEORIGINX                       0x2000005b
#define ET_VALUE_DW_GDI_DEVICEORIGINY                       0x2000005c
#define ET_VALUE_DW_GDI_DEVICESIZEX                         0x2000005d
#define ET_VALUE_DW_GDI_DEVICESIZEY                         0x2000005e
#define ET_VALUE_DW_GDI_VISUALORIGINX                       0x2000005f
#define ET_VALUE_DW_GDI_VISUALORIGINY                       0x20000060
#define ET_VALUE_DW_GDI_VISUALSIZEX                         0x20000061
#define ET_VALUE_DW_GDI_VISUALSIZEY                         0x20000062
#define ET_VALUE_DW_GDI_DELLXXL                             0x20000063 // DELLXXL
#define ET_VALUE_DW_GDI_PERMEDIACLOCKSPEED                  0x20000064 // PermediaClockSpeed
#define ET_VALUE_DW_GDI_GLINTCLOCKSPEED                     0x20000065 // GlintClockSpeed
#define ET_VALUE_DW_GDI_GLINTGAMMACLOCKSPEED                0x20000066 // GlintGammaClockSpeed
#define ET_VALUE_DW_GDI_GLINTDELTACLOCKSPEED                0x20000067 // GlintDeltaClockSpeed
#define ET_VALUE_DW_GDI_HWLINES                             0x20000068 // TNT: interface to enable nonconformant but faster lines
#define ET_VALUE_DW_GDI_FIFOEXTRA_P2                        0x20000069 // GDI.FifoExtra
#define ET_VALUE_DW_GDI_FIFOEXTRA                           0x2000006a // GDI.FifoExtra
#define ET_VALUE_DW_GDI_FIFOUSAGE                           0x2000006b // GDI.FifoUsage
#define ET_VALUE_DW_GDI_EXPORTMULTIBOARDMODES               0x2000006c // ExportMultiboardModes
#define ET_VALUE_DW_GDI_SURFACESONBANKBOUNDARIES            0x2000006d // boolean
#define ET_VALUE_DW_GDI_DMABUFFERSIZE                       0x2000006e // ulong ( > 8kB)
#define ET_VALUE_DW_GDI_DMAPADDING                          0x2000006f // ulong (ET_VALUE_DW_GDI_DMAPADDING < ET_VALUE_DW_GDI_DMABUFFERSIZE)
#define ET_VALUE_DW_GDI_BOARD_PATTERN                       0x20000070 // binary: defines boards used for the mode (00 01 02,...)
#define ET_VALUE_DW_GDI_AGP_DMA                             0x20000071 // bool: 1=use AGP for display driver DMA, 0=don't use AGP
#define ET_VALUE_DW_GDI_FRAMEBUFFER_DMA                     0x20000072 // bool: 1=use framebuffer DMA for display driver

#define ET_VALUE_DW_MAP_FRAMEBUFFER                         0x20000090 // Map.FrameBuffer
#define ET_VALUE_DW_MAP_GLINTMMIO                           0x20000091 // Map.GLintMmio
#define ET_VALUE_DW_MAP_DELTAMMIO                           0x20000092 // Map.DeltaMmio
#define ET_VALUE_DW_MAP_LOCALBUFFER                         0x20000093 // Map.LocalBuffer

#define ET_VALUE_DW_PPRO_ENABLEWCB                          0x20000095 // PPro.EnableWCB
#define ET_VALUE_DW_ALPHA_MIATA                             0x20000096 // Alpha.Miata
#define ET_VALUE_DW_PRINTANDCHECKRENDERSTATE                0x20000097 //

#define ET_VALUE_BIN_GDI_GAMMARAMP                          0x200000A0 // Gammatable in the same format as in GDI::SetGammaRamp
#define ET_VALUE_BIN_OEM_MODELIST                           0x200000A1 // mode list override string: "bpp#1 width#1 height#1 refresh1#1 refresh2#1... 0 bpp#2 width#2 height#2 refresh1#2 refresh2#2... 0";

// ICDInterface.* 0x20000100-0x200001ff
#define ET_VALUE_DW_ICDINTERFACE_DISABLE                    0x20000100 // ICDInterface.Disable
//#define ET_VALUE_DW_ICDINTERFACE_DOUBLEBUFFER               0x20000101
//#define ET_VALUE_DW_ICDINTERFACE_MAXDOUBLEBUFFER            0x20000102
#define ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS     0x20000101 // ICDInterface.NumberOfDisplayBuffers
#define ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS  0x20000102 // ICDInterface.MaxNumberOfDisplayBuffers
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTSINGLEBUFFEREDGDI   0x20000103 // ICDInterface.SupportSingleBufferedGDI
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTDOUBLEBUFFEREDGDI   0x20000104 // ICDInterface.SupportDoubleBufferedGDI
#define ET_VALUE_DW_ICDINTERFACE_EXPORTALPHA                0x20000105 // ICDInterface.ExportAlpha
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES       0x20000106 // ICDInterface.SupportOverlayPlanes
#define ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT                 0x20000107 // ICDInterface.VBlankWait
#define ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING               0x20000108 // ICDInterface.PageFlipping
#define ET_VALUE_DW_ICDINTERFACE_LBWIDTH                    0x20000109 // ICDInterface.LBWidth
#define ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER               0x2000010A // ICDInterface.SizeOfBuffer

#define ET_VALUE_DW_ICDINTERFACE_DUALTXLBMOVES              0x2000010B // ICDInterface.DualTXLBMoves
#define ET_VALUE_DW_ICDINTERFACE_EXTENDEDPAGEFLIP           0x2000010C // ICDInterface.ExtendedPageFlip
#define ET_VALUE_DW_ICDINTERFACE_FNSENDDATATST              0x2000010D // ICDInterface.FNSendDataTst
#define ET_VALUE_DW_ICDINTERFACE_FULLSCNTOPBORDER           0x2000010E // DoubleBuffer.FullScnTopBorder
#define ET_VALUE_DW_ICDINTERFACE_LBSIZE                     0x2000010F // ICDInterface.LBSize
#define ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSDMA          0x20000110 // ICDInterface.P2EnableBypassDma
#define ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSPATCH        0x20000111 // ICDInterface.P2EnableBypassPatch
#define ET_VALUE_DW_ICDINTERFACE_PAGEFLIPFORCESYNC          0x20000112 // ICDInterface.PageFlipForceSync
#define ET_VALUE_DW_ICDINTERFACE_TEXTURESIZE                0x20000113 // ICDInterface.MaxTextureSize
#define ET_VALUE_DW_ICDINTERFACE_USESOFTWAREWRITEMASK       0x20000114 // ICDInterface.UseSoftwareWriteMask
#define ET_VALUE_DW_ICDINTERFACE_USESINGLETX                0x20000115 // ICDInterface.UseSingleTX

#define ET_VALUE_DW_ICDINTERFACE_EXPORTCOLORINDEX           0x20000116
#define ET_VALUE_DW_ICDINTERFACE_OPENGLICDNAME              0x20000117
#define ET_VALUE_DW_ICDINTERFACE_OPENGLICDELSAOGLNAME       0x20000118
#define ET_VALUE_DW_ICDINTERFACE_PFDREDUCTION               0x20000119 // ICDInterface.PFDReduction
#define ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS         0x2000011A // ICDInterface.StereoForceBuffers
#define ET_VALUE_DW_ICDINTERFACE_STEREOLEFTEYETOP           0x2000011B // ICDInterface.StereoLeftEyeTop
#define ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT              0x2000011C // ICDInterface.StereoSupport
#define ET_VALUE_DW_ICDINTERFACE_TEXTURESMARTCACHE          0x2000011D // ICDInterface.TextureSmartCache
#define ET_VALUE_DW_ICDINTERFACE_TEXTURETRANSIENTONLY       0x2000011E // ICDInterface.TextureTransientOnly

#define ET_VALUE_DW_ICDINTERFACE_MAXTEXTURESIZE             0x2000011F // ICDInterface.MaxTextureSize
#define ET_VALUE_DW_ICDINTERFACE_PFD_TYPE_COLORINDEX        0x20000120 // ICDInterface.PFD_TYPE_COLORINDEX
#define ET_VALUE_DW_ICDINTERFACE_LBPATCHED                  0x20000121 // ICDInterface.LBPatched
#define ET_VALUE_DW_ICDINTERFACE_DUALGLINTWINDOWMOVES       0x20000122 // ICDInterface.DualGlintWindowMoves
#define ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS 0x20000123 // ICDInterface.ForceGdiBroadCastingInOglViews
#define ET_VALUE_DW_ICDINTERFACE_PFD_STEREO                 0x20000124 // ICDInterface.PFD_STEREO
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS     0x20000125 // ICDInterface.PFD_SWAP_LAYER_BUFFERS
#define ET_VALUE_DW_ICDINTERFACE_PFD_SUPPORT_GDI            0x20000126 // ICDInterface.PFD_SUPPORT_GDI

#define ET_VALUE_DW_ICDINTERFACE_FORCE_STENCIL              0x20000127 // ICDInterface.ForceStencil
#define ET_VALUE_DW_ICDINTERFACE_FORCE_MORETHAN16BITZ       0x20000128 // 0=default, else force to this value!
#define ET_VALUE_DW_ICDINTERFACE_TEXTURE_REDUCE_FACTOR      0x20000129 // ICDInterface.TextureReduceFactor
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY              0x2000012A // ICDInterface.PFD_SWAP_COPY
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE          0x2000012B // ICDInterface.PFD_SWAP_EXCHANGE

// GLintDMA.* 0x20000200-0x2000024f
#define ET_VALUE_DW_GLINTDMA_NUMBEROFBUFFERS                0x20000200 // GLintDMA.NumberOfBuffers
#define ET_VALUE_DW_GLINTDMA_NUMBEROFSUBBUFFERS             0x20000201 // GLintDMA.NumberOfSubBuffers
#define ET_VALUE_DW_GLINTDMA_SIZEOFBUFFERS                  0x20000202 // GLintDMA.SizeOfBuffer
#define ET_VALUE_DW_GLINTDMA_CACHEDBUFFERS                  0x20000203 // GLintDMA.CachedBuffers

#define ET_VALUE_DW_GLINTDMA_USEAGP                         0x20000204 // GLintDMA.UseAGP
#define ET_VALUE_DW_GLINTDMA_SUPPORTAGPONBX                 0x20000205 // GLintDMA.SupportAGPonBX

#define ET_VALUE_DW_AGP_ENABLE                              ET_VALUE_DW_GLINTDMA_USEAGP // AGP.Enable:  0, 1
#define ET_VALUE_DW_AGP_RATE                                0x20000206                  // AGP.Rate:    1, 2, 4
#define ET_VALUE_DW_AGP_SIDEBANDADDRESSING                  0x20000207                  // AGP.SBA:     0, 1
#define ET_VALUE_DW_AGP_REQUEST_DEPTH                       0x20000208                  // AGP.RQDepth: 1...255
#define ET_VALUE_DW_AGP_FAST_WRITES                         0x20000209                  // AGP.FW:      0, 1

#define ET_VALUE_DW_DMAWAITFORPOLL                          0x2000020A // DMAWaitForPoll

#define ET_VALUE_DW_AGP_CACHING                             0x2000020B // 0=No, 1=Yes (as used in AgpReservePhysical)
#define ET_VALUE_DW_AGP_MSWORKAROUND                        0x2000020C // 0=No, 1=Yes (to enable workaround for bug in MS W2K videoport.sys AGP mapping)

#define ET_VALUE_DW_DMA_7DUMMYREADS                         0x2000020D // 0=No, 1=Yes (7 dummy reads in dma buffer to flush writecombined caches)
#define ET_VALUE_DW_DMA_DUMMYREADUC                         0x2000020E // 0=No, 1=Yes (Perform a dummy read to the UC system memory but not WC to flush writecombined caches)

#define ET_VALUE_DW_DMA_FORCEIOFLUSH                        0x2000020F // 0=No, 1=Yes (Perform inp and outp to flush io buffers)

// GLintIRQ.* 0x20000250-0x200002ff
#define ET_VALUE_DW_GLINTIRQ_ENABLE                         0x20000250 // GLintIRQ.Enable

// OpenGL.* 0x20000300-0x200003ff
#define ET_VALUE_DW_OPENGL_USEHIQUALITYTEXTURE              0x20000300
#define ET_VALUE_DW_OPENGL_UNIXCONFORM                      0x20000301
#define ET_VALUE_DW_OPENGL_DOUBLEWRITE                      0x20000302
#define ET_VALUE_DW_OPENGL_DISABLEFASTCLEAR                 0x20000303 // OpenGL.DisableFastClear
#define ET_VALUE_DW_OPENGL_DISABLEMIPMAPS                   0x20000304
#define ET_VALUE_DW_OPENGL_TEXTURECOMPRESSION               0x20000305
#define ET_VALUE_DW_OPENGL_ENABLEP2ANTIALIAS                0x20000306
#define ET_VALUE_DW_OPENGL_SUPPORTOPENGLVERSION11           0x20000307
#define ET_VALUE_DW_OPENGL_FORCETRUECOLOR16BIT              0x20000308 // OpenGL.ForceTrueColorTexturesTo16bit
#define ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE                 0x20000309 // OpenGL.SupportSoftimage
#define ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE_351             0x2000030A // OpenGL.SupportSoftimage351

#define ET_VALUE_DW_OPENGL_DRAWLINEENDS                     0x2000030B
#define ET_VALUE_DW_OPENGL_ENABLEFIFOACCESS                 0x2000030C
#define ET_VALUE_DW_OPENGL_DISABLEDELTA                     0x2000030D
#define ET_VALUE_DW_OPENGL_MXDISABLEMIPMAPS                 0x2000030E
#define ET_VALUE_DW_OPENGL_FORCENNTEXFILTER                 0x2000030F
#define ET_VALUE_DW_OPENGL_DISABLEDMAFLUSHES                0x20000310
#define ET_VALUE_DW_OPENGL_DISABLEGXCULL                    0x20000311
#define ET_VALUE_DW_OPENGL_INVERTGXCFORMAT                  0x20000312
#define ET_VALUE_DW_OPENGL_PERSPECTIVECORRECTION            0x20000313
#define ET_VALUE_DW_OPENGL_REALLOCBLOCKSIZE                 0x20000314
#define ET_VALUE_DW_OPENGL_DISABLEDLISTTEXTURES             0x20000315
#define ET_VALUE_DW_OPENGL_DELTANODRAW                      0x20000316
#define ET_VALUE_DW_OPENGL_ENABLEBYPASSPATCH                0x20000317
#define ET_VALUE_DW_OPENGL_ENABLEBYPASSDMA                  0x20000318
#define ET_VALUE_DW_OPENGL_FORCENESTEDDMA                   0x20000319
#define ET_VALUE_DW_OPENGL_DISABLETRIANGLEPACKET            0x2000031A
#define ET_VALUE_DW_OPENGL_PRESERVETRUECOLORTEXTURES        0x2000031B // OpenGL.PreserveTrueColorTextures
#define ET_VALUE_DW_OPENGL_DUALTXPRO                        0x2000031C
#define ET_VALUE_DW_OPENGL_VERTEXCOOPTMAX                   0x2000031D
#define ET_VALUE_DW_OPENGL_NVVVOPTIMIZATION                 0x2000031E
#define ET_VALUE_DW_OPENGL_MIPMAPCONTROL                    0x2000031F
#define ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING           0x20000320 // OpenGL.DisableTexturePatching

#define ET_VALUE_DW_OPENGL_USEGIDCLIPPING                   0x20000321 // OpenGL.UseGidClipping
#define ET_VALUE_DW_OPENGL_PLACEMIPMAPSINALTERNATEBANKS     0x20000322 // OpenGL.PlaceMipMapsInAlternateBanks
#define ET_VALUE_DW_OPENGL_DISABLETEXTUREMANAGERLRU         0x20000323 // OpenGL.DisableTextureManagerLRU
#define ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER               0x20000324 // OpenGL.SupportProDesigner

#define ET_VALUE_DW_OPENGL_DMAMAXCOUNT                      0x20000325 // TNT: OpenGL.DMAMaxCount (size of DMA buffer)
#define ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT                  0x20000326 // TNT: OpenGL.DMAMinPushCount (fill grade of buffer to force flush)
#define ET_VALUE_DW_OPENGL_MAXTEXTURESIZE                   0x20000327
#define ET_VALUE_DW_OPENGL_MINVIDMEMTEXWIDTH                0x20000328
#define ET_VALUE_DW_OPENGL_MAXTEXHEAPSIZE                   0x20000329
#define ET_VALUE_DW_OPENGL_LIGHTINGANALYSIS                 0x2000032A  // BITFIELD
#define ET_VALUE_DW_OPENGL_LIGHTPICKINGOVERRIDE             0x2000032B  // BITFIELD
#define ET_VALUE_DW_OPENGL_STATISTICS                       0x2000032C  // BITFIELD
#define ET_VALUE_DW_OPENGL_BENCHING                         0x2000032D  // OpenGL.Benching
#define ET_VALUE_DW_OPENGL_USEKATMAI                        0x2000032E // BOOLEAN
#define ET_VALUE_DW_OPENGL_VERTEXCACHESIZE                  0x2000032F // DWORD
#define ET_VALUE_DW_OPENGL_PIXELTUBE                        0x20000330 // DWORD

// OpenGL AGP settings
#define ET_VALUE_DW_OPENGL_AGP_DMA                          0x20000331  // OpenGL.AGP.DMA
#define ET_VALUE_DW_OPENGL_AGP_TEXTURES                     0x20000332  // OpenGL.AGP.Textures
#define ET_VALUE_DW_OPENGL_FORCE_AGP_TEXTURES               0x20000333  // OpenGL.ForceAGPTextures

#define ET_VALUE_DW_OPENGL_FORCE_CLIPPING                   0x20000334  // OpenGL.ForceClipping
#define ET_VALUE_DW_OPENGL_ERRORLOG                         0x20000335  // OpenGL.ErrorLog
#define ET_VALUE_DW_OPENGL_DUMPLOG                          0x20000336  // OpenGL.DumpLog
#define ET_VALUE_DW_OPENGL_MCAD_MODE                        0x20000337  // OpenGL.MCAD
#define ET_VALUE_DW_OPENGL_SUPPORT_P2_CI4TEXTURES           0x20000338  // OpenGL.SupportP2CI4Textures
#define ET_VALUE_DW_OPENGL_FORCE_SINGLEBUFFERED             0x20000339  // BOOLEAN
#define ET_VALUE_DW_OPENGL_ALIGNED_SURFACES                 0x2000033A  // ULONG
#define ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA                  0x2000033B  // OpenGL.FramebufferDMA
#define ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS               0x2000033C  // Bitfield enabling Autocad 2000 opengl extensions
#define ET_VALUE_DW_OPENGL_USESENDDATAESCAPE                0x2000033D  // ULONG (0:ICD accesses HW, 1:automatic (ICD or Escape), 2: ICD uses Escape to fire DMA), FNicklis 07.05.1999
#define ET_VALUE_DW_OPENGL_DISABLE_STENCIL                  0x2000033E  // BOOLEAN (0: default, export stencil, 1: remove stencil formats), FNicklis 11.06.199
#define ET_VALUE_DW_OPENGL_DISABLE_ALPHA                    0x2000033F  // BOOLEAN (0: default, export alpha,   1: remove alpha formats), FNicklis 11.06.199
#define ET_VALUE_DW_OPENGL_PREFER_AGP_TEXTURES              0x20000340  // BOOL ('OpenGL.PreferAGPTextures, 0=default)
#define ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT_SENDDATA         0x20000341  // TNT: OpenGL.DMAMinPushCountSendData (fill grade of buffer to force flush)
#define ET_VALUE_DW_OPENGL_MULTIBOARD                       0x20000342  // BOOLEAN (1:default, allow OpenGL; 0:OpenGl not in mulitboard) OpenGL.MultiBoard
#define ET_VALUE_DW_OPENGL_UNIGRAPHICS_TEXTURE_FIX          0x20000343  // Enable bug fix for Unigraphics 15, 16 (border color for texture)
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITCONCEPT          0x20000344  // ULONG  (0:default do not wait 1:allways use DPCs 2:do wait until VBlank occured
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITLINESBEFORE      0x20000345  // ULONG  ( default: 2 ) amount of rasterlines before VBlank until to loop and wait for VBlank 
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITLINESAFTER       0x20000346  // ULONG  ( default: 1 ) amount of rasterlines after VBlank when to trigger stereo glasses + offsets 

                                                          //0x20000347  ...

// Heidi/Kinetix.* 0x20000400-0x200004ff
#define ET_VALUE_DW_HEIDI_USEEXCLUSIVE                      0x20000400
#define ET_VALUE_DW_HEIDI_USELINEARTEXTUREFILTER            0x20000401
#define ET_VALUE_DW_KTX_BUFFERREGIONS                       0x20000402 // e.g. KTX.BufferRegions
#define ET_VALUE_DW_KTX_SWAPHINTS                           0x20000403 // e.g. KTX.SwapHints
#define ET_VALUE_DW_KTX_ELSABUFFERREGIONS                   0x20000404 // e.g. KTX.ElsaBufferRegions
#define ET_VALUE_DW_KTX_BUFFER_REGIONS_FULL                 0x20000405 // e.g. KTX.BufferRegionsFull
#define ET_VALUE_DW_KTX_BUFFER_REGIONS_FIX                  0x20000406 // e.g. KTX.BufferRegionsFix

// HardwareInformation.* 0x20000500-0x200005ff
#define ET_VALUE_SZ_HARDWAREINFORMATION_ADAPTERSTRING       0x20000500
#define ET_VALUE_SZ_HARDWAREINFORMATION_CHIPTYPE            0x20000501
#define ET_VALUE_SZ_HARDWAREINFORMATION_DACTYPE             0x20000502
#define ET_VALUE_DW_HARDWAREINFORMATION_MEMORYSIZE          0x20000503
#define ET_VALUE_SZ_BOARDNAME                               0x20000504
#define ET_VALUE_SZ_DESCRIPTION                             0x20000505
#define ET_VALUE_SZ_SERNUM                                  0x20000506
#define ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING          0x20000507

// DDraw ids    0x20000600-0x200006ff
#define ET_VALUE_DW_DDRAWMULTIBOARDPRIMARY                  0x20000600 // DirectDraw.MultiboardPrimary
#define ET_VALUE_DW_DDRAWENABLEVIDEOIO                      0x20000601 // EnableVideoIO
#define ET_VALUE_DW_DDRAWMULTIBOARDHW_ENABLE                0x20000602 // DirectDraw.MultiboardEnabled
#define ET_VALUE_DW_DDRAWSUPPORT_OVERLAYSHRINK              0x20000603 // DirectDraw.SupportOverlayshrink

// LCD Panel    0x20000700-0x200007ff
#define ET_VALUE_DW_LCDPANELBORDERLEFTRIGHT                 0x20000700 // DUO.PanningBorderLeftRight
#define ET_VALUE_DW_LCDPANELBORDERTOPBOTTOM                 0x20000701 // DUO.PanningBorderTopBottom
#define ET_VALUE_DW_LCDPANELSTEPLEFTRIGHT                   0x20000702 // DUO.PanningStepLeftRight
#define ET_VALUE_DW_LCDPANELSTEPTOPBOTTOM                   0x20000703 // DUO.PanningStepTopBottom
#define ET_VALUE_DW_LCDPANELPANSTARTXRES                    0x20000704 // DUO.PanningStartXResolution
#define ET_VALUE_DW_LCDPANELSTRETCHXRES                     0x20000705 // DUO.LcdExpand
#define ET_VALUE_DW_LCDPANELSINGLEMODE                      0x20000706 // DUO.SingleControllerMode
#define ET_VALUE_DW_LCDPANELENABLECRT                       0x20000707 // DUO.CrtEnable
#define ET_VALUE_DW_LCDPANELENABLELCD                       0x20000708 // DUO.LcdEnable
#define ET_VALUE_DW_LCDPANELENABLETV                        0x20000709 // DUO.TvEnable
#define ET_VALUE_DW_LCDPANELTRUECOLORDITHER                 0x2000070A // DUO.LcdTruecolorDither
#define ET_VALUE_DW_LCDPANELTVFLICKERFILTER                 0x2000070B // DUO.TvFlickerFilter

// ********************************************************
// ********************************************************
// NV10 / NV 15 boards
// -----------------------------
// #define SUBESC_ET_GET_OUTPUT_DEVICE_INFO    0x00000310
// #define SUBESC_ET_SET_OUTPUT_DEVICE         0x00000311

#define PANEL_RESOLUTION_STRETCHED	0x0001
#define PANEL_RESOLUTION_CENTERED	0x0002
#define PANEL_RESOLUTION_NATIVE	0x0004

#define DEVICE_TYPE_INVALID   0x0000
#define DEVICE_TYPE_CRT       0x0001
#define DEVICE_TYPE_LCD       0x0002
#define DEVICE_TYPE_TV        0x0004

typedef struct tagET_COMMON_OUTPUT_DEVICE_INFO
{
  DWORD   dwDeviceType;         // holds the type of the device (CRT/LCD/TV)
  DWORD   dwDeviceConnected;    // is this device connected to graphics board
  DWORD   dwDeviceOn;           // is the device switched on
  DWORD   dwHorSize;            // horizontal size of the device in pixel
  DWORD   dwVertSize;           // vertical size of the device in pixel
  DWORD   dwDisplayMode;        // display mode of device ( stretched, native, centered )
  DWORD   dwSupportedDisplayModes;   // supported display modes of device ( stretched, native, centered )
}ET_COMMON_OUTPUT_DEVICE_INFO, *PET_COMMON_OUTPUT_DEVICE_INFO;

typedef struct tagET_OUTPUT_DEVICE_INFO
{
  DWORD   dwSize;                   // size of structure
  DWORD   dwDevicesSupported;       // bitfield containing type of supported devices
  DWORD   dwSimultaniousDevices;      // bitfield containing type of devices supported at the same time
  ET_COMMON_OUTPUT_DEVICE_INFO  crt;  // information on the CRT
  ET_COMMON_OUTPUT_DEVICE_INFO  lcd;  // information on the LCD
  ET_COMMON_OUTPUT_DEVICE_INFO  tv;   // information on the tv set
  DWORD   dwNumAdditionalDevices;   // number of additional ET_COMMON_OUTPUT_DEVICE_INFO structures needed
  ET_COMMON_OUTPUT_DEVICE_INFO  *pAdditionalInformation;
} ET_OUTPUT_DEVICE_INFO, *PET_OUTPUT_DEVICE_INFO;

// Structure to set output device
typedef struct tagET_SET_OUTPUT_DEVICE
{
  ET_QUERY                    hdr;

  DWORD                       dwParam1;             //1 saves to registry, 0 for testing
  ET_OUTPUT_DEVICE_INFO       deviceInfo;
} ET_SET_OUTPUT_DEVICE, *PET_SET_OUTPUT_DEVICE;

//Structure to retrieve complete information on the output devices
typedef struct tagET_GET_OUTPUT_DEVICE_INFO
{
  DWORD                       dwSize;
  ET_OUTPUT_DEVICE_INFO       deviceInfo;
} ET_GET_OUTPUT_DEVICE_INFO,*PET_GET_OUTPUT_DEVICE_INFO;


// ********************************************************
// ********************************************************
// LCD panel with WINNER 1000DUO
// -----------------------------

// Common information on actual PANEL settings (used in Get and Set info)
typedef struct tagET_COMMON_PANEL_INFO
{
  LONG        lPanStepLR;           //Panning stepsize right/left panning
  LONG        lPanStepTB;           //Panning stepsize up/down panning
  LONG        lPanBorderLR;         //Area where panning begins before cursor hits panel end left/right
  LONG        lPanBorderTB;         //Area where panning begins before cursor hits panel end top/bottom
  LONG        lPanStartResX;        //We start panning if our Resolution exceeds this value
  LONG        lStretchEndXRes;      //Bitfield to describe the resolutions at which we want to stretch/expand
  DWORD       dwEnablePanel;        //We enable the LCD
  DWORD       dwEnableCrt;          //We enable the CRT
  DWORD       dwEnableTV;           //We enable the TV
  DWORD       dwPanelSingleMode;    //One Controller for both displays
  LONG        lTVFlickerFilter;     //1(disabled),2 or 3 line Flickerfilter
  DWORD       dwLCDTrueColorDither; //True Color dithering or reducing to 18bit
} ET_COMMON_PANEL_INFO, *PET_COMMON_PANEL_INFO;


// In structure (Tool -> driver):
// Structure to set the new Panel settings
typedef struct tagET_SET_PANEL_INFO
{
  ET_QUERY              hdr;

  DWORD                 dwParam1;             //1 saves to registry, 0 for testing
  ET_COMMON_PANEL_INFO  CommonPanelInfo;
} ET_SET_PANEL_INFO, *PET_SET_PANEL_INFO;


// Out structure (Driver -> Tool):
//Structure to retrieve complete information on the actual Panel
typedef struct tagET_GET_PANEL_INFO
{
  DWORD                 dwSize;

  DWORD                 dwPanelSupport;       //Does the Board support a LCD Panel
  LONG                  lXResPanel;           //X-Res of our Panel
  LONG                  lYResPanel;           //Y-Res of our Panel

  ET_COMMON_PANEL_INFO  CommonPanelInfo;

} ET_GET_PANEL_INFO, *PET_GET_PANEL_INFO;

// ********************************************************
// ********************************************************
//NEW: SK 13011999
//Interface for Maxtreme to enable/disable stereo for a given window

//In structure (Tool -> driver )
//Structure to set the Stereomode of a oglwindow. (for Maxtreme)
typedef struct tagET_SET_WINDOW_STEREOMODE
{
  ET_QUERY  hdr;

  PVOID     hwnd;   //Windowhandle // ELSA-FNicklis 27.04.00: not all of our code knows a HWND
  DWORD     dwMode; //STEREOMODE_ENABLE or STEREOMODE_DISABLE
} ET_SET_WINDOW_STEREOMODE, *PET_SET_WINDOW_STEREOMODE;

#define STEREOMODE_DISABLE  0x00000000
#define STEREOMODE_ENABLE   0x00000001

// ********************************************************


//
// NT direct hw access support - development only
//

// SUBESC_ET_GETREGISTER
typedef struct tagET_GETREG
{
  DWORD dwSize;
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
}ET_GETREG, *PET_GETREG, FAR *LPET_GETREG;

// SUBESC_ET_SETREGISTER
typedef struct tagET_SETREG
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SETREGISTER
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
}ET_SETREG, *PET_SETREG, FAR *LPET_SETREG;

// SUBESC_ET_MODIFYREGISTER
typedef struct tagET_MODIFYREG
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_MODIFYREGISTER
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
  DWORD dwMask; // (all bits to modify set to 1)
}ET_MODIFYREG, *PET_MODIFYREG, FAR *LPET_MODIFYREG;

//
// dwFlags values
//
#define MMIO_ACCESS             0x00 << 16  // default: mmio, sync + vblankwait
#define PIO_ACCESS              0x01 << 16
#define NO_SYNC                 0x02 << 16
#define NO_VBLANKWAIT           0x04 << 16
#define NO_FIFOWAIT             0x08 << 16

#define ACCESS_DWORD 0x01 << 0
#define ACCESS_WORD  0x02 << 0
#define ACCESS_BYTE  0x04 << 0



// SUBESC_ET_NOTIFYDRIVER
typedef struct tagET_NOTIFYDRIVER
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_NOTIFYDRIVER
  DWORD dwNotification;
}ET_NOTIFYDRIVER, *PET_NOTIFYDRIVER, FAR *LPET_NOTIFYDRIVER;

// notifications: video capture driver to display driver
#define EDDESC_VIO2DRVNOTIFY_TVOUTON   0x01
#define EDDESC_VIO2DRVNOTIFY_TVOUTOFF  0x02



// SUBESC_ET_SCROLL
// scrolling into offscreen (debug purposes)
typedef struct tagET_SCROLL_DATA
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SCROLL
  LONG  cyLines;            // # of lines vertical panning
}ET_SCROLL_DATA, FAR *LPET_SCROLL_DATA;



// SUBESC_ET_GFXOPTIONQUERY
// GfxOptionQuery support
typedef struct tagET_GFXOPTIONQUERY
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_GFXOPTIONQUERY
  DWORD dwGfxOption;        // in/out parameter
}ET_GFXOPTIONQUERY_DATA, FAR *LPET_GFXOPTIONQUERY_DATA;

// SUBESC_ET_SAA
// video in/out related stuff, used by Windows NT video capture driver for hw access
typedef struct tagET_SAA_DATA
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SAA
  DWORD dwSAACommand;       // = defines below
  DWORD dwData;
  DWORD dwRegister;
  DWORD dwReturn;
}ET_SAA_DATA, FAR *LPET_SAA_DATA;

#define I2COPEN                   1000
#define I2CCLOSE                  1001

#define CHECKSAA7111              1
#define WRITESAA7111              2
#define READSAA7111               3

#define CHECKSAA7125              101
#define WRITESAA7125              102
#define READSAA7125               103

// ********************************************************
// code for SUBESC_ET_QUERY_ICDCLIENTINFO:
// 12.02.1999 FNicklis

// input structure app -> driver
typedef struct tagET_QUERY_ICDCLIENTINFO_IN
{
  ET_QUERY hdr;  // size and subescape ET_QUERY_ICDCLIENTINFO
} ET_QUERY_ICDCLIENTINFO_IN;

typedef struct tagET_ICDCLIENTINFO
{
  DWORD  dwClientID;     // 1 per window
  DWORD  dwContextCount; // n per window > 0; 0==invalid
  DWORD  dwProcessID;    // 0==invalid/unused/unkown
  HANDLE hWnd;           // window handle
  LONG   lPixelFormat;   // used pixelformat number
} ET_ICDCLIENTINFO;

// output structure driver -> app
typedef struct tagET_QUERY_ICDCLIENTINFO_OUT
{
  DWORD  dwSize;          // Length of this out buffer
  DWORD  dwTotalClients;  // Total count of running OpenGL clients
  DWORD  dwReturnClients; // Count of information units returned to app

  ET_ICDCLIENTINFO aClientInfo[1]; // array of 1, ...
} ET_QUERY_ICDCLIENTINFO_OUT;


// ********************************************************
// code for SUBESC_ET_QUERY_TEMPERATURE:
// 28.09.1999 Thorsten Schumann

// bits used as caps and as status
#define ET_TEMPERATURE_FANSLOW     0x00000001   // fan slow or stop
#define ET_TEMPERATURE_FANSHORTVCC 0x00000002   // fan short VCC (only on boot phase available)
#define ET_TEMPERATURE_OVERTEMP    0x00000004   // over temperature
#define ET_TEMPERATURE_VALUE       0x00000008   // for future release, not yet used
                                                //    entry dwTemperatureValue is used

// output structure driver -> app
typedef struct tagET_QUERY_TEMPERATURE
{
  DWORD  dwSize;              // Length of this out buffer
  DWORD  dwTemperatureCaps;    // caps of valid record entries / hardware caps
  DWORD  dwTemperatureStatus; // status of flags
  DWORD  dwTemperatureValue;  // for future release, not yet used
  DWORD  dwReserved1;
  DWORD  dwReserved2;
} ET_QUERY_TEMPERATURE, FAR *LPET_QUERY_TEMPERATURE;


// ********************************************************
// begin of code for SUBESC_ET_DPMS:
//
// Set or query DPMS power save mode. Send ET_DPMS_IN structure
// with wanted DPMS mode to driver and always receive selected
// mode. If Escape fails, the DPMS mode was not set!
//
// FNicklis 29.09.1999: added SUBESC_ET_DPMS and sample code
//
// Sample code to set powersave mode:
//   taken from PowerSaver.scr Screen saver
//
  /*
//
// bSetDPMSMode
//
// enables ELSAESC-ET_DPMS power save mode via Escape call to driver.
//
// return: TRUE  - mode set successfully
//         FALSE - failed to set powersave mode
//
// FNicklis 29.09.1999: New
//
static BOOL bSetDPMSMode(
  IN ET_DPMS_MODE lMode)      // Power save mode to set
{
  BOOL        bRet=FALSE;     // pessimistic
  LONG        lResult;        // return value of extescape
  ET_DPMS_IN  etPowersaveIn;  // App -> Driver
  ET_DPMS_OUT etPowersaveOut; // Driver -> App
  HDC         hDC;            // Desktops HDC (to reach the display driver)

  ZeroMemory(&etPowersaveIn, sizeof(etPowersaveIn));

  etPowersaveIn.hdr.dwSize    = sizeof(etPowersaveIn);
  etPowersaveIn.hdr.dwSubEsc  = SUBESC_ET_DPMS;
  etPowersaveIn.hdr.dwOutSize = sizeof(etPowersaveOut);
  etPowersaveIn.hdr.dwBoard   = 0;
  etPowersaveIn.lMode         = lMode;

  hDC = GetDC(0);

  lResult = ExtEscape(hDC,
    ESC_ELSA_TOOLS,
    sizeof(etPowersaveIn),
    (PVOID)&etPowersaveIn,
    sizeof(etPowersaveOut),
    (PVOID)&etPowersaveOut);

  if (lResult>0)
  {
    assert(sizeof(etPowersaveOut)==etPowersaveOut.dwSize);
    assert((lMode==ET_DPMS_QUERY) || (etPowersaveIn.lMode==etPowersaveOut.lMode));
    bRet=TRUE;
  }
  else
  {
    // error: failed for call SUBESC_ET_DPMS");
  }

  return(bRet);
}
  */

// defines for DPMS-Power save modes
typedef enum tagET_DPMS_MODE
{
  ET_DPMS_ON,      // in/out: default mode, turn on monitor
                // Powersave modes:
  ET_DPMS_STANDBY, // in/out:
  ET_DPMS_SUSPEND, // in/out:
  ET_DPMS_OFF,     // in/out:

  ET_DPMS_QUERY    // in: return current mode in ET_DPMS_OUT. Only used in ET_DPMS_IN.ulMode!
} ET_DPMS_MODE;

// input structure app -> driver
typedef struct tagET_DPMS_IN
{
  ET_QUERY     hdr;    // size and subescape ET_DPMS_IN
  ET_DPMS_MODE lMode;  // type of mode to set or query
} ET_DPMS_IN;

// output structure driver -> app
typedef struct tagET_DPMS_OUT
{
  DWORD        dwSize; // Length of this out buffer
  ET_DPMS_MODE lMode;  // return current mode which is POWERSAVE_DISABLE or POWERSAVE_ENABLE
} ET_DPMS_OUT;

// end of code for SUBESC_ET_DPMS:
// ********************************************************

#ifdef WIN32
#pragma pack (pop, fixed_forELSAESC)
#else
#pragma pack ()
#endif

#endif //__ELSAESC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvioctl.h ===
#ifndef _nvioctl_h_
#define _nvioctl_h_

/*
** Copyright 1991-1999, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Header$
*/

#include <sys/ioctl.h>

/*
** IOCTLs defines and structures common between the kernel and the GL
*/

/* ---  first the defines --- */
#define IOCTL_NV_OPENGL                         1

#define IOCTL_NV_OPENGL_GET_SINGLE_BACK_1       1
#define IOCTL_NV_OPENGL_GET_SINGLE_DEPTH        2
#define IOCTL_NV_OPENGL_FREE_SINGLE_BACK_DEPTH  3

/* --- now the structure definitions --- */

typedef struct NvOpenGLCommandRec {
    int 	command;
    void *      ret;
} NvOpenGLCommand;

#endif /* _nvioctl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvOverlay.h ===
#ifndef __gl_nvOverlay_h_
#define __gl_nvOverlay_h_

/*
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

// RBiermann: add global definitions for OpenGL Overlay Planes here:

// the number of palette entries
#define ICD_PALETTE_ENTRIES 256

// layer palette transparent index
#define ICD_PALETTE_TRANSPARENT_INDEX 0

// the transparent color is black
#define ICD_PALETTE_TRANSPARENT_COLOR 0

#endif  /* __gl_nvOverlay_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvDMAC.h ===
// (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDMAC.H                                                          *
*   Define various macros used to interact with the hardware                *
*   Please put other more general D3D macros in nvd3dmac or elsewhere!      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       1/26/98 - Created                       *
*                                                                           *
\***************************************************************************/

#ifndef _NV4DMAC_H_
#define _NV4DMAC_H_

#ifdef __cplusplus
extern "C" {
#endif

// NV Reference Manual register access definitions.
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//-------------------------------------------------------------------------
//                 GENERIC DMA PUSH BUFFER OPERATIONS
//-------------------------------------------------------------------------

#define sizeSetObject                       2
#define nvglSetObject(ch, obj)                                              \
{                                                                           \
    nvPushData (0, (0x00040000 | ((ch) << 13)));                            \
    nvPushData (1, obj);                                                    \
    nvPusherAdjust (sizeSetObject);                                         \
}

#define sizeSetStartMethod                  1
#define nvglSetStartMethod(index, ch, method, methodcount)                  \
{                                                                           \
    nvPushData (index, ((((methodcount) << 2) << 16) | ((ch) << 13) | (method))); \
}

#define sizeSetData                         1
#define nvglSetData(index, data)                                            \
{                                                                           \
    nvPushData (index, (data));                                             \
}

#define nvglAdjust(size)                                                    \
{                                                                           \
    nvPusherAdjust (size);                                                  \
}

#define sizeDmaJump         1
#define nvglDmaJump(offset)                                                 \
{                                                                           \
    nvPushData (0, (0x20000000 | (offset)));                                \
    nvPusherAdjust (sizeDmaJump);                                           \
}

//-------------------------------------------------------------------------
//                              NV 002
//                   NV01_CONTEXT_DMA_FROM_MEMORY
//-------------------------------------------------------------------------

#define sizeSetDmaFromMemoryMthdCnt                 3
#define sizeSetDmaFromMemory                        4
#define nvglSetDmaFromMemory(ch, base, selector, limit)                     \
{                                                                           \
    nvPushData (0, (((sizeSetDmaFromMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300)); \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (limit));                                                \
    nvPusherAdjust (sizeSetDmaFromMemory);                                  \
}

#define sizeSetDmaFromMemoryContextNotifyMthdCnt    1
#define sizeSetDmaFromMemoryContextNotify           2
#define nvglSetDmaFromMemoryContextNotify(ch, ctxdmanotify)                 \
{                                                                           \
    nvPushData (0, (((sizeSetDmaFromMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetDmaFromMemoryContextNotify);                     \
}

#define sizeSetDmaFromMemoryNotify                  7
#define nvglSetDmaFromMemoryNotify(ch, base, selector, limit, notify)       \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | 0x300));              \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (((1 << 2) << 16) | ((ch) << 13) | 0x104));              \
    nvPushData (4, (notify));                                               \
    nvPushData (5, (((1 << 2) << 16) | ((ch) << 13) | 0x308));              \
    nvPushData (6, (limit));                                                \
    nvPusherAdjust (sizeSetDmaFromMemoryNotify);                            \
}

//-------------------------------------------------------------------------
//                              NV 003
//                    NV01_CONTEXT_DMA_TO_MEMORY
//-------------------------------------------------------------------------

#define sizeSetDmaToMemoryMthdCnt                 3
#define sizeSetDmaToMemory                        4
#define nvglSetDmaToMemory(ch, base, selector, limit)                       \
{                                                                           \
    nvPushData (0, (((sizeSetDmaToMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300)); \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (limit));                                                \
    nvPusherAdjust (sizeSetDmaToMemory);                                    \
}

#define sizeSetDmaToMemoryContextNotifyMthdCnt    1
#define sizeSetDmaToMemoryContextNotify           2
#define nvglSetDmaToMemoryContextNotify(ch, ctxdmanotify)                   \
{                                                                           \
    nvPushData (0, (((sizeSetDmaToMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetDmaToMemoryContextNotify);                       \
}

#define sizeSetDmaToMemoryNotify                  7
#define nvglSetDmaToMemoryNotify(ch, base, selector, limit, notify)         \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | 0x300));              \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (((1 << 2) << 16) | ((ch) << 13) | 0x104));              \
    nvPushData (4, (notify));                                               \
    nvPushData (5, (((1 << 2) << 16) | ((ch) << 13) | 0x308));              \
    nvPushData (6, (limit));                                                \
    nvPusherAdjust (sizeSetDmaToMemoryNotify);                              \
}

//-------------------------------------------------------------------------
//                              NV 019
//                    NV01_CONTEXT_CLIP_RECTANGLE
//-------------------------------------------------------------------------

#define sizeSetClipMthdCnt                          2
#define sizeSetClip                                 3
#define nvglSetClip(ch, x, y, w, h)                                         \
{                                                                           \
    nvPushData (0, (((sizeSetClipMthdCnt << 2) << 16) | ((ch) << 13) | NV019_SET_POINT)); \
    nvPushData (1, ((DWORD)y << 16) | (DWORD)x);                            \
    nvPushData (2, ((DWORD)h << 16) | (DWORD)w);                            \
    nvPusherAdjust (sizeSetClip);                                           \
}

//-------------------------------------------------------------------------
//                              NV 042
//                     NV04_CONTEXT_SURFACES_2D
//-------------------------------------------------------------------------

#define sizeSet2DSurfacesNoOpMthdCnt    1
#define sizeSet2DSurfacesNoOp           2
#define nvglSet2DSurfacesNoOp(ch)                                           \
{                                                                           \
    nvPushData (0, (((sizeSet2DSurfacesNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV042_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSet2DSurfacesNoOp);                                 \
}

#define sizeSet2DSurfacesContextsMthdCnt            2
#define sizeSet2DSurfacesContexts                   3
#define nvglSet2DSurfacesContexts(ch, ctxsrc, ctxdest)                      \
{                                                                           \
    nvPushData (0, (((sizeSet2DSurfacesContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_CONTEXT_DMA_IMAGE_SOURCE)); \
    nvPushData (1, (ctxsrc));                                               \
    nvPushData (2, (ctxdest));                                              \
    nvPusherAdjust (sizeSet2DSurfacesContexts);                             \
}

#define sizeSet2DSurfacesColorFormatMthdCnt         1
#define sizeSet2DSurfacesColorFormat                2
#define nvglSet2DSurfacesColorFormat(ch, format)                            \
{                                                                           \
    if (pDriverData->bltData.dwLastColourFormat != format) {                \
        nvPushData (0, (((sizeSet2DSurfacesColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_COLOR_FORMAT)); \
        nvPushData (1, (format));                                           \
        nvPusherAdjust (sizeSet2DSurfacesColorFormat);                      \
        pDriverData->bltData.dwLastColourFormat = format;                   \
    }                                                                       \
}

#define sizeSet2DSurfacesPitchMthdCnt               1
#define sizeSet2DSurfacesPitch                      2
#define nvglSet2DSurfacesPitch(ch, srcpitch, dstpitch)                      \
{                                                                           \
DWORD dwCombinedPitch = ((((dstpitch) & 0x0000FFFF) << 16) | ((srcpitch) & 0x0000FFFF));   \
    if (pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch) {      \
        nvPushData (0, (((sizeSet2DSurfacesPitchMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_PITCH)); \
        nvPushData (1, dwCombinedPitch);                                    \
        nvPusherAdjust (sizeSet2DSurfacesPitch);                            \
        pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;         \
    }                                                                       \
}

#define sizeSet2DSurfacesDestinationMthdCnt         1
#define sizeSet2DSurfacesDestination                2
#define nvglSet2DSurfacesDestination(ch, offset)                            \
{                                                                           \
    if (pDriverData->bltData.dwLastDstOffset != offset) {                   \
        nvPushData (0, (((sizeSet2DSurfacesDestinationMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_OFFSET_DESTIN)); \
        nvPushData (1, (offset));                                           \
        nvPusherAdjust (sizeSet2DSurfacesDestination);                      \
        pDriverData->bltData.dwLastDstOffset = offset;                      \
    }                                                                       \
}

//-------------------------------------------------------------------------
//                              NV 043
//                         NV03_CONTEXT_ROP
//-------------------------------------------------------------------------

#define sizeSetRop5MthdCnt                          1
#define sizeSetRop5                                 2
#define nvglSetRop5(ch, rop5)                                               \
{                                                                           \
    if (pDriverData->bltData.dwLastRop != rop5) {                           \
        nvPushData (0, (((sizeSetRop5MthdCnt << 2) << 16) | ((ch) << 13) | NV043_SET_ROP5)); \
        nvPushData (1, (rop5));                                             \
        nvPusherAdjust (sizeSetRop5);                                       \
        pDriverData->bltData.dwLastRop = rop5;                              \
    }                                                                       \
}

//-------------------------------------------------------------------------
//                              NV 044
//                       NV04_CONTEXT_PATTERN
//-------------------------------------------------------------------------

// 0x00000304
#define sizeSetNv4ContextPatternMonochromeFormatMthdCnt  1
#define sizeSetNv4ContextPatternMonochromeFormat         2
#define nvglSetNv4ContextPatternMonochromeFormat(ch, format)                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHROME_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeFormat);              \
}
// 0x00000308
#define sizeSetNv4ContextPatternMonochromeShapeMthdCnt  1
#define sizeSetNv4ContextPatternMonochromeShape         2
#define nvglSetNv4ContextPatternMonochromeShape(ch, shape)                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeShapeMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHROME_SHAPE)); \
    nvPushData (1, (shape));                                                \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeShape);               \
}
// 0x0000030c
#define sizeSetNv4ContextPatternPatternSelectMthdCnt  1
#define sizeSetNv4ContextPatternPatternSelect         2
#define nvglSetNv4ContextPatternPatternSelect(ch, select)                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternPatternSelectMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_PATTERN_SELECT)); \
    nvPushData (1, (select));                                               \
    nvPusherAdjust (sizeSetNv4ContextPatternPatternSelect);                 \
}
// 0x00000310
#define sizeSetNv4ContextPatternMonochromeColorsMthdCnt  2
#define sizeSetNv4ContextPatternMonochromeColors         3
#define nvglSetNv4ContextPatternMonochromeColors(ch, c0, c1)                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeColorsMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHORME_COLOR0)); \
    nvPushData (1, (c0));                                                   \
    nvPushData (2, (c1));                                                   \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeColors);              \
}
// 0x00000318
#define sizeSetNv4ContextPatternMonochromePatternsMthdCnt  2
#define sizeSetNv4ContextPatternMonochromePatterns         3
#define nvglSetNv4ContextPatternMonochromePatterns(ch, pattern0, pattern1)  \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromePatternsMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHORME_PATTERN0)); \
    nvPushData (1, (pattern0));                                             \
    nvPushData (2, (pattern1));                                             \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromePatterns);            \
}

//-------------------------------------------------------------------------
//                              NV 04A
//                     NV04_GDI_RECTANGLE_TEXT
//-------------------------------------------------------------------------

//0x00000300
#define sizeDrawRopRectAndTextSetColorFormatMthdCnt 1
#define sizeDrawRopRectAndTextSetColorFormat        2
#define nvglDrawRopRectAndTextSetColorFormat(ch, format)                    \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_COLOR_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeDrawRopRectAndTextSetColorFormat);                  \
}

//0x0000018C
#define sizeDrawRopRectAndTextSetROPMthdCnt 1
#define sizeDrawRopRectAndTextSetROP        2
#define nvglDrawRopRectAndTextSetROP(ch, rop)                               \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetROPMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeDrawRopRectAndTextSetROP);                          \
}

//0x00000188
#define sizeDrawPatternRectAndTextSetPatternMthdCnt 1
#define sizeDrawPatternRectAndTextSetPattern        2
#define nvglDrawPatternRectAndTextSetPattern(ch, pattern)                   \
{                                                                           \
    nvPushData (0, (((sizeDrawPatternRectAndTextSetPatternMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeDrawPatternRectAndTextSetPattern);                  \
}

//0x00000198
#define sizeDrawRopRectAndTextSetSurfaceMthdCnt 1
#define sizeDrawRopRectAndTextSetSurface        2
#define nvglDrawRopRectAndTextSetSurface(ch, surface)                       \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeDrawRopRectAndTextSetSurface);                      \
}

//0x000002FC
#define sizeDrawRopRectAndTextSetOperatioonMthdCnt 1
#define sizeDrawRopRectAndTextSetOperation         2
#define nvglDrawRopRectAndTextSetOperation(ch, operation)                   \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetOperatioonMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeDrawRopRectAndTextSetOperation);                    \
}

#define sizeDrawRopRectAndTextColor1AMthdCnt        1
#define sizeDrawRopRectAndTextColor1A               2
#define nvglDrawRopRectAndTextColor1A(ch, color)                            \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextColor1AMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_COLOR1_A)); \
    nvPushData (1, (color));                                                \
    nvPusherAdjust (sizeDrawRopRectAndTextColor1A);                         \
}

#define sizeDrawRopRectAndTextPointSizeMthdCnt      2
#define sizeDrawRopRectAndTextPointSize             3
#define nvglDrawRopRectAndTextPointSize(ch, x, y, width, height)            \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextPointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_UNCLIPPED_RECTANGLE_POINT(0))); \
    nvPushData (1, ((((x) & 0x0000FFFF) << 16) | ((y) & 0x0000FFFF)));      \
    nvPushData (2, ((((width) & 0x0000FFFF) << 16) | ((height) & 0x0000FFFF))); \
    nvPusherAdjust (sizeDrawRopRectAndTextPointSize);                       \
}

//-------------------------------------------------------------------------
//                              NV 052
//                   NV04_CONTEXT_SURFACE_SWIZZLED
//-------------------------------------------------------------------------

#define sizeSetSwizzledSurfaceContextImageMthdCnt   1
#define sizeSetSwizzledSurfaceContextImage          2
#define nvglSetSwizzledSurfaceContextImage(ch, ctxdmaimage)                 \
{                                                                           \
    nvPushData (0, (((sizeSetSwizzledSurfaceContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_CONTEXT_DMA_IMAGE)); \
    nvPushData (1, (ctxdmaimage));                                          \
    nvPusherAdjust (sizeSetSwizzledSurfaceContextImage);                    \
}

#define sizeSetSwizzledSurfaceMthdCnt        2
#define sizeSetSwizzledSurface               3
#define nvglSetSwizzledSurface(ch, format, offset)                          \
{                                                                           \
    nvPushData (0, (((sizeSetSwizzledSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPushData (2, (offset));                                               \
    nvPusherAdjust (sizeSetSwizzledSurface);                                \
}

//-------------------------------------------------------------------------
//                              NV 053
//                     NV04_CONTEXT_SURFACES_3D
//-------------------------------------------------------------------------

#define sizeSetRenderTargetContextsMthdCnt  2
#define sizeSetRenderTargetContexts         3
#define nvglSetRenderTargetContexts(ch, ctxdmacolor, ctxdmazeta)            \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTargetContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CONTEXT_DMA_COLOR)); \
    nvPushData (1, (ctxdmacolor));                                          \
    nvPushData (2, (ctxdmazeta));                                           \
    nvPusherAdjust (sizeSetRenderTargetContexts);                           \
}

#define sizeSetRenderTarget                 8
#define nvglSetRenderTarget(ch, cliphorizontal, clipvertical, format,       \
                            pitch, coloroffset, zetaoffset)                 \
{                                                                           \
    nvPushData (0, (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL)); \
    nvPushData (1, (cliphorizontal));                                       \
    nvPushData (2, (clipvertical));                                         \
    nvPushData (3, (format));                                               \
    nvPushData (4, (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_PITCH));    \
    nvPushData (5, (pitch));                                                \
    nvPushData (6, (coloroffset));                                          \
    nvPushData (7, (zetaoffset));                                           \
    nvPusherAdjust (sizeSetRenderTarget);                                   \
}

#define sizeSetRenderTarget2MthdCnt         5
#define sizeSetRenderTarget2                6
#define nvglSetRenderTarget2(ch, format, clipsize, pitch,                   \
                             coloroffset, zetaoffset)                       \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTarget2MthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPushData (2, (clipsize));                                             \
    nvPushData (3, (pitch));                                                \
    nvPushData (4, (coloroffset));                                          \
    nvPushData (5, (zetaoffset));                                           \
    nvPusherAdjust (sizeSetRenderTarget2);                                  \
}

#define sizeSetRenderTargetViewportMthdCnt  2
#define sizeSetRenderTargetViewport         3
#define nvglSetRenderTargetViewport(ch, cliphorizontal, clipvertical)       \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTargetViewportMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL)); \
    nvPushData (1, (cliphorizontal));                                       \
    nvPushData (2, (clipvertical));                                         \
    nvPusherAdjust (sizeSetRenderTargetViewport);                           \
}

//-------------------------------------------------------------------------
//                              NV 054
//                     NV04_DX5_TEXTURED_TRIANGLE
//-------------------------------------------------------------------------

#define sizeSetDx5TriangleContextsMthdCnt   2
#define sizeSetDx5TriangleContexts          3
#define nvglSetDx5TriangleContexts(ch, ctxa, ctxb)                          \
{                                                                           \
    nvPushData (0, (((sizeSetDx5TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (ctxa));                                                 \
    nvPushData (2, (ctxb));                                                 \
    nvPusherAdjust (sizeSetDx5TriangleContexts);                            \
}

#define sizeSetDx5TriangleSurfaceMthdCnt    1
#define sizeSetDx5TriangleSurface           2
#define nvglSetDx5TriangleSurface(ch, ctxs)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetDx5TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (ctxs));                                                 \
    nvPusherAdjust (sizeSetDx5TriangleSurface);                             \
}

#define sizeDx5TriangleStateMthdCnt         7
#define sizeDx5TriangleState                8
#define nvglDx5TriangleState(ch, ckey, offset, format, filter,              \
                             blend, control, fogcolor)                      \
{                                                                           \
    nvPushData (0, (((sizeDx5TriangleStateMthdCnt << 2) << 16) | ((ch) << 13) | NV054_COLOR_KEY)); \
    nvPushData (1, (ckey));                                                 \
    nvPushData (2, (offset));                                               \
    nvPushData (3, (format));                                               \
    nvPushData (4, (filter));                                               \
    nvPushData (5, (blend));                                                \
    nvPushData (6, (control));                                              \
    nvPushData (7, (fogcolor));                                             \
    nvPusherAdjust (sizeDx5TriangleState);                                  \
}

#define sizeDx5TriangleDrawPrimitiveMthdCnt 1
#define sizeDx5TriangleDrawPrimitive        2
#define nvglDx5TriangleDrawPrimitive(ch, alias, vertices)                   \
{                                                                           \
    nvPushData (0, (((sizeDx5TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV054_DRAW_PRIMITIVE((alias)))); \
    nvPushData (1, (vertices));                                             \
    nvPusherAdjust (sizeDx5TriangleDrawPrimitive);                          \
}

#define sizeDx5TriangleNotify               4
#define nvglDx5TriangleNotify(ch)                                           \
{                                                                           \
    nvPushData (0, (((1 << 2) << 16) | ((ch) << 13) | NV054_NOTIFY));       \
    nvPushData (1, NV054_NOTIFY_WRITE_ONLY);                                \
    nvPushData (2, (((1 << 2) << 16) | ((ch) << 13) | NV054_NO_OPERATION)); \
    nvPushData (3, 0x00000000);                                             \
    nvPusherAdjust (sizeDx5TriangleNotify);                                 \
}

//-------------------------------------------------------------------------
//                              NV 055
//                   NV04_DX6_MULTI_TEXTURE_TRIANGLE
//-------------------------------------------------------------------------

#define sizeSetDx6TriangleContextsMthdCnt   2
#define sizeSetDx6TriangleContexts          3
#define nvglSetDx6TriangleContexts(ch, ctxa, ctxb)                          \
{                                                                           \
    nvPushData (0, (((sizeSetDx6TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (ctxa));                                                 \
    nvPushData (2, (ctxb));                                                 \
    nvPusherAdjust (sizeSetDx6TriangleContexts);                            \
}

#define sizeSetDx6TriangleSurfaceMthdCnt    1
#define sizeSetDx6TriangleSurface           2
#define nvglSetDx6TriangleSurface(ch, ctxs)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetDx6TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (ctxs));                                                 \
    nvPusherAdjust (sizeSetDx6TriangleSurface);                             \
}

#define sizeDx6TriangleOffsetMthdCnt        1
#define sizeDx6TriangleOffset               2
#define nvglDx6TriangleOffset(ch, offset, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV055_OFFSET(buffer))); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeDx6TriangleOffset);                                 \
}

#define sizeDx6TriangleFormatMthdCnt        1
#define sizeDx6TriangleFormat               2
#define nvglDx6TriangleFormat(ch, format, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FORMAT(buffer))); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeDx6TriangleFormat);                                 \
}

#define sizeDx6TriangleFilterMthdCnt        1
#define sizeDx6TriangleFilter               2
#define nvglDx6TriangleFilter(ch, filter, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleFilterMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FILTER(buffer))); \
    nvPushData (1, (filter));                                               \
    nvPusherAdjust (sizeDx6TriangleFilter);                                 \
}

#define sizeDx6TriangleStageState           12
#define nvglDx6TriangleStageState(ch, c0alpha, c0color, c1alpha, c1color,   \
                                  factor, blend,                            \
                                  control0, control1, control2,             \
                                  fogcolor)                                 \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_0_ALPHA)); \
    nvPushData (1, (c0alpha));                                              \
    nvPushData (2, (c0color));                                              \
    nvPushData (3, (((8 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_1_ALPHA)); \
    nvPushData (4, (c1alpha));                                              \
    nvPushData (5, (c1color));                                              \
    nvPushData (6, (factor));                                               \
    nvPushData (7, (blend));                                                \
    nvPushData (8, (control0));                                             \
    nvPushData (9, (control1));                                             \
    nvPushData (10, (control2));                                            \
    nvPushData (11, (fogcolor));                                            \
    nvPusherAdjust (sizeDx6TriangleStageState);                             \
}

#define sizeDX6TriangleState    (((sizeDx6TriangleOffset + sizeDx6TriangleFormat + sizeDx6TriangleFilter) * 2) + sizeDx6TriangleStageState)

#define sizeDx6TriangleTLVertexMthdCnt      10
#define sizeDx6TriangleTLVertex1            11
#define nvglDx6TriangleTLVertex(ch, alias, vd)                              \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV055_TLMTVERTEX((alias)))); \
    nvPushData (1, *(U032 *)&(vd.sx));                                      \
    nvPushData (2, *(U032 *)&(vd.sy));                                      \
    nvPushData (3, *(U032 *)&(vd.sz));                                      \
    nvPushData (4, *(U032 *)&(vd.rhw));                                     \
    nvPushData (5, (vd.color));                                             \
    nvPushData (6, (vd.specular));                                          \
    nvPushData (7, *(U032 *)&(vd.tu));                                      \
    nvPushData (8, *(U032 *)&(vd.tv));                                      \
    nvPushData (9, 0);                                                      \
    nvPushData (10, 0);                                                     \
    nvPusherAdjust (sizeDx6TriangleTLVertex1);                              \
    dbgDisplayVertexData(FALSE, (DWORD *)&(vd.sx));                         \
}

#define sizeDx6TriangleDrawPrimitiveMthdCnt 1
#define sizeDx6TriangleDrawPrimitive        2
#define nvglDx6TriangleDrawPrimitive(ch, alias, vertices)                   \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV055_DRAW_PRIMITIVE((alias)))); \
    nvPushData (1, (vertices));                                             \
    nvPusherAdjust (sizeDx6TriangleDrawPrimitive);                          \
}

//-------------------------------------------------------------------------
//                              NV 056
//                      NV10_CELSIUS_PRIMITIVE
//-------------------------------------------------------------------------
#if (NVARCH >= 0x010)
#define NV056_SET_VERTEX_FORMAT_SHADOW      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15)

// 0x00000100
#define sizeSetNv10CelsiusNoOpMthdCnt    1
#define sizeSetNv10CelsiusNoOp           2
#define nvglSetNv10CelsiusNoOp(ch)                                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV056_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv10CelsiusNoOp);                                \
}
// 0x00000104
#define sizeSetNv10CelsiusNotifyMthdCnt    1
#define sizeSetNv10CelsiusNotify           2
#define nvglSetNv10CelsiusNotify(ch, type)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNotifyMthdCnt << 2) << 16) | ((ch) << 13) | NV056_NOTIFY)); \
    nvPushData (1, (type));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusNotify);                              \
}
// 0x00000180
#define sizeSetNv10CelsiusContextDMAsMthdCnt    7
#define sizeSetNv10CelsiusContextDMAs           8
#define nvglSetNv10CelsiusContextDMAs(ch, notifies, dmaa, dmab, vertex, state, color, zeta) \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPushData (2, (dmaa));                                                 \
    nvPushData (3, (dmab));                                                 \
    nvPushData (4, (vertex));                                               \
    nvPushData (5, (state));                                                \
    nvPushData (6, (color));                                                \
    nvPushData (7, (zeta));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusContextDMAs);                         \
}
// 0x00000180
#define sizeSetNv10CelsiusNotifierContextDMAMthdCnt    1
#define sizeSetNv10CelsiusNotifierContextDMA           2
#define nvglSetNv10CelsiusNotifierContextDMA(ch, notifies)                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNotifierContextDMAMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPusherAdjust (sizeSetNv10CelsiusNotifierContextDMA);                  \
}
// 0x00000184
#define sizeSetNv10CelsiusTextureAndVertexContextDMAsMthdCnt    3
#define sizeSetNv10CelsiusTextureAndVertexContextDMAs           4
#define nvglSetNv10CelsiusTextureAndVertexContextDMAs(ch, dmaa, dmab, vertex) \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusTextureAndVertexContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (dmaa));                                                 \
    nvPushData (2, (dmab));                                                 \
    nvPushData (3, (vertex));                                               \
    nvPusherAdjust (sizeSetNv10CelsiusTextureAndVertexContextDMAs);         \
}
// 0x0000072c
#define sizeSetNv10CelsiusEyeDirectionMthdCnt                   3
#define sizeSetNv10CelsiusEyeDirection                          4
#define nvglSetNv10CelsiusEyeDirection(ch, x, y, z)                         \
{                                                                           \
    float x1 = x, y1 = y, z1 = z;                                           \
    nvPushData (0, (((sizeSetNv10CelsiusEyeDirectionMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_EYE_DIRECTION_SW(0))); \
    nvPushData (1, *(DWORD*)&x1);                                           \
    nvPushData (2, *(DWORD*)&y1);                                           \
    nvPushData (3, *(DWORD*)&z1);                                           \
    nvPusherAdjust (sizeSetNv10CelsiusEyeDirection);                        \
}
// 0x00000cf0
#define sizeSetNv10CelsiusInvalidateVertexCacheMthdCnt    1
#define sizeSetNv10CelsiusInvalidateVertexCache           2
#define nvglSetNv10CelsiusInvalidateVertexCache(ch)                         \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusInvalidateVertexCacheMthdCnt << 2) << 16) | ((ch) << 13) | NV056_INVALIDATE_VERTEX_CACHE_FILE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv10CelsiusInvalidateVertexCache);               \
}
// 0x000010fc
#define sizeSetNv10CelsiusBeginEnd2MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd2           2
#define nvglSetNv10CelsiusBeginEnd2(ch, op)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd2MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END2)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd2);                            \
}
// 0x000013fc
#define sizeSetNv10CelsiusBeginEnd3MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd3           2
#define nvglSetNv10CelsiusBeginEnd3(ch, op)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END3)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd3);                           \
}
// 0x000017fc
#define sizeSetNv10CelsiusBeginEnd4MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd4           2
#define nvglSetNv10CelsiusBeginEnd4(ch, op)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END4)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd4);                           \
}
// 0x00001400
#define sizeSetNv10CelsiusDrawArraysMthdCnt    1
#define sizeSetNv10CelsiusDrawArrays           2
#define nvglSetNv10CelsiusDrawArrays(ch, data)                              \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusDrawArraysMthdCnt << 2) << 16) | ((ch) << 13) | NV056_DRAW_ARRAYS(0))); \
    nvPushData (1, (data));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusDrawArrays);                          \
}
#endif  // NVARCH >= 0x010

//-------------------------------------------------------------------------
//                              NV 097
//                       NV20_KELVIN_PRIMITIVE
//-------------------------------------------------------------------------
#if (NVARCH >= 0x020)
// 0x00000100
#define sizeSetNv20KelvinNoOpMthdCnt    1
#define sizeSetNv20KelvinNoOp           2
#define nvglSetNv20KelvinNoOp(ch)                                           \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV097_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv20KelvinNoOp);                                 \
}
// 0x00000104
#define sizeSetNv20KelvinNotifyMthdCnt    1
#define sizeSetNv20KelvinNotify           2
#define nvglSetNv20KelvinNotify(ch, type)                                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNotifyMthdCnt << 2) << 16) | ((ch) << 13) | NV097_NOTIFY)); \
    nvPushData (1, (type));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinNotify);                               \
}
// 0x00000180
#define sizeSetNv20KelvinNotifierContextDMAMthdCnt    1
#define sizeSetNv20KelvinNotifierContextDMA           2
#define nvglSetNv20KelvinNotifierContextDMA(ch, notifies)                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNotifierContextDMAMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPusherAdjust (sizeSetNv20KelvinNotifierContextDMA);                   \
}
// 0x00000180
#define sizeSetNv20KelvinContextDMAsMthdCnt1    3
#define sizeSetNv20KelvinContextDMAs1           4
#define sizeSetNv20KelvinContextDMAsMthdCnt2    7
#define sizeSetNv20KelvinContextDMAs2           8
#define nvglSetNv20KelvinContextDMAs(ch, notifies, dmaa, dmab, state, color, zeta, vertexa, vertexb, semaphore, report) \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinContextDMAsMthdCnt1 << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPushData (2, (dmaa));                                                 \
    nvPushData (3, (dmab));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinContextDMAs1);                         \
    nvPushData (0, (((sizeSetNv20KelvinContextDMAsMthdCnt2 << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_STATE)); \
    nvPushData (1, (state));                                                \
    nvPushData (2, (color));                                                \
    nvPushData (3, (zeta));                                                 \
    nvPushData (4, (vertexa));                                              \
    nvPushData (5, (vertexb));                                              \
    nvPushData (6, (semaphore));                                            \
    nvPushData (7, (report));                                               \
    nvPusherAdjust (sizeSetNv20KelvinContextDMAs2);                         \
}
// 0x00000184
#define sizeSetNv20KelvinTextureContextDMAsMthdCnt    2
#define sizeSetNv20KelvinTextureContextDMAs           3
#define nvglSetNv20KelvinTextureContextDMAs(ch, dmaa, dmab)                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinTextureContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (dmaa));                                                 \
    nvPushData (2, (dmab));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinTextureContextDMAs);                   \
}
// 0x0000019c
#define sizeSetNv20KelvinVertexContextDMAsMthdCnt    2
#define sizeSetNv20KelvinVertexContextDMAs           3
#define nvglSetNv20KelvinVertexContextDMAs(ch, vertexa, vertexb)            \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinVertexContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_VERTEX_A)); \
    nvPushData (1, (vertexa));                                              \
    nvPushData (2, (vertexb));                                              \
    nvPusherAdjust (sizeSetNv20KelvinVertexContextDMAs);                    \
}
// 0x00001710
#define sizeSetNv20KelvinInvalidateVertexCacheMthdCnt    1
#define sizeSetNv20KelvinInvalidateVertexCache           2
#define nvglSetNv20KelvinInvalidateVertexCache(ch)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinInvalidateVertexCacheMthdCnt << 2) << 16) | ((ch) << 13) | NV097_INVALIDATE_VERTEX_CACHE_FILE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv20KelvinInvalidateVertexCache);                \
}
// 0x000017fc
#define sizeSetNv20KelvinBeginEndMthdCnt    1
#define sizeSetNv20KelvinBeginEnd           2
#define nvglSetNv20KelvinBeginEnd(ch, op)                                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_BEGIN_END)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv20KelvinBeginEnd);                             \
}
// 0x00001810
#define sizeSetNv20KelvinDrawArraysMthdCnt    1
#define sizeSetNv20KelvinDrawArrays           2
#define nvglSetNv20KelvinDrawArrays(ch, data)                               \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinDrawArraysMthdCnt << 2) << 16) | ((ch) << 13) | NONINC_METHOD(NV097_DRAW_ARRAYS))); \
    nvPushData (1, (data));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinDrawArrays);                           \
}

#endif // (NVARCH >= 0x020)

//-------------------------------------------------------------------------
//                              NV 05E
//                    NV04_RENDER_SOLID_RECTANGLE
//-------------------------------------------------------------------------

// 0x00000100
#define sizeSetNv4SolidRectangleNoOpMthdCnt    1
#define sizeSetNv4SolidRectangleNoOp           2
#define nvglSetNv4SolidRectangleNoOp(ch)                                    \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv4SolidRectangleNoOp);                          \
}
// 0x00000184
#define sizeSetNv4SolidRectangleClipRectangleMthdCnt  1
#define sizeSetNv4SolidRectangleClipRectangle         2
#define nvglSetNv4SolidRectangleClipRectangle(ch, rect)                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleClipRectangleMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_CLIP_RECTANGLE)); \
    nvPushData (1, (rect));                                                 \
    nvPusherAdjust (sizeSetNv4SolidRectangleClipRectangle);                 \
}
// 0x00000188
#define sizeSetNv4SolidRectanglePatternMthdCnt  1
#define sizeSetNv4SolidRectanglePattern         2
#define nvglSetNv4SolidRectanglePattern(ch, pattern)                        \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectanglePatternMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeSetNv4SolidRectanglePattern);                       \
}
// 0x0000018c
#define sizeSetNv4SolidRectangleRopMthdCnt  1
#define sizeSetNv4SolidRectangleRop         2
#define nvglSetNv4SolidRectangleRop(ch, rop)                                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleRopMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeSetNv4SolidRectangleRop);                           \
}
// 0x00000198
#define sizeSetNv4SolidRectangleSurfaceMthdCnt  1
#define sizeSetNv4SolidRectangleSurface         2
#define nvglSetNv4SolidRectangleSurface(ch, surface)                        \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetNv4SolidRectangleSurface);                       \
}
// 0x000002fc
#define sizeSetNv4SolidRectangleOperationMthdCnt    1
#define sizeSetNv4SolidRectangleOperation           2
#define nvglSetNv4SolidRectangleOperation(ch, op)                           \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_OPERATION)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv4SolidRectangleOperation);                     \
}
// 0x00000300
#define sizeSetNv4SolidRectangleColorFormatMthdCnt  1
#define sizeSetNv4SolidRectangleColorFormat         2
#define nvglSetNv4SolidRectangleColorFormat(ch, cfmt)                       \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_COLOR_FORMAT)); \
    nvPushData (1, (cfmt));                                                 \
    nvPusherAdjust (sizeSetNv4SolidRectangleColorFormat);                   \
}
// 0x00000304
#define sizeNv4SolidRectangleColorMthdCnt           1
#define sizeNv4SolidRectangleColor                  2
#define nvglNv4SolidRectangleColor(ch, color)                               \
{                                                                           \
    nvPushData (0, (((sizeNv4SolidRectangleColorMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_COLOR)); \
    nvPushData (1, (color));                                                \
    nvPusherAdjust (sizeNv4SolidRectangleColor);                            \
}
// 0x00000400
#define sizeNv4SolidRectanglePointSizeMthdCnt       2
#define sizeNv4SolidRectanglePointSize              3
#define nvglNv4SolidRectanglePointSize(ch, x, y, width, height)             \
{                                                                           \
    nvPushData (0, (((sizeNv4SolidRectanglePointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_RECTANGLE(0))); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeNv4SolidRectanglePointSize);                        \
}

//-------------------------------------------------------------------------
//                              NV 05F
//                         NV04_IMAGE_BLIT
//-------------------------------------------------------------------------

// 0x00000188
#define sizeSetNv4ImageBlitClipRectangleMthdCnt     1
#define sizeSetNv4ImageBlitClipRectangle            2
#define nvglSetNv4ImageBlitClipRectangle(ch, rect)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitClipRectangleMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_CLIP_RECTANGLE)); \
    nvPushData (1, (rect));                                                 \
    nvPusherAdjust (sizeSetNv4ImageBlitClipRectangle);                      \
}
// 0x0000018c
#define sizeSetNv4ImageBlitContextPatternMthdCnt     1
#define sizeSetNv4ImageBlitContextPattern            2
#define nvglSetNv4ImageBlitContextPattern(ch, pattern)                      \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextPatternMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeSetNv4ImageBlitContextPattern);                     \
}
// 0x00000190
#define sizeSetNv4ImageBlitContextRopMthdCnt     1
#define sizeSetNv4ImageBlitContextRop            2
#define nvglSetNv4ImageBlitContextRop(ch, rop)                              \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextRopMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeSetNv4ImageBlitContextRop);                         \
}
// 0x0000019c
#define sizeSetNv4ImageBlitContextSurfacesMthdCnt     1
#define sizeSetNv4ImageBlitContextSurfaces            2
#define nvglSetNv4ImageBlitContextSurfaces(ch, surface)                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextSurfacesMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetNv4ImageBlitContextSurfaces);                    \
}
// 0x000002fc
#define sizeSetNv4ImageBlitOperationMthdCnt     1
#define sizeSetNv4ImageBlitOperation            2
#define nvglSetNv4ImageBlitOperation(ch, op)                                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_OPERATION)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv4ImageBlitOperation);                          \
}
// 0x00000300
#define sizeSetNv4ImageBlitControlPointsMthdCnt     2
#define sizeSetNv4ImageBlitControlPoints            3
#define nvglSetNv4ImageBlitControlPoints(ch, xin, yin, xout, yout)          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitControlPointsMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_CONTROL_POINT_IN)); \
    nvPushData (1, (((xin)  & 0xffff) | ((yin)  << 16)));                   \
    nvPushData (2, (((xout) & 0xffff) | ((yout) << 16)));                   \
    nvPusherAdjust (sizeSetNv4ImageBlitControlPoints);                      \
}
// 0x00000308
#define sizeSetNv4ImageBlitSizeMthdCnt     1
#define sizeSetNv4ImageBlitSize            2
#define nvglSetNv4ImageBlitSize(ch, width, height)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SIZE)); \
    nvPushData (1, (((width)  & 0xffff) | ((height)  << 16)));              \
    nvPusherAdjust (sizeSetNv4ImageBlitSize);                               \
}

//-------------------------------------------------------------------------
//                              NV 060
//                    NV04_INDEXED_IMAGE_FROM_CPU
//-------------------------------------------------------------------------

#define sizeSetIndexedImageDmaNotifiesMthdCnt           1
#define sizeSetIndexedImageDmaNotifies                  2
#define nvglSetIndexedImageDmaNotifies(ch, ctxdmanotify)                    \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageDmaNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetIndexedImageDmaNotifies);                        \
}

#define sizeSetIndexedImageContextDmaLUTMthdCnt           1
#define sizeSetIndexedImageContextDmaLUT                  2
#define nvglSetIndexedImageContextDmaLUT(ch, handle)                        \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageContextDmaLUTMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_LUT)); \
    nvPushData (1, (handle));                                               \
    nvPusherAdjust (sizeSetIndexedImageContextDmaLUT);                      \
}

#define sizeSetIndexedImageContextSurfaceMthdCnt        1
#define sizeSetIndexedImageContextSurface               2
#define nvglSetIndexedImageContextSurface(ch, surface)                      \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetIndexedImageContextSurface);                     \
}

#define sizeSetIndexedImageOperationMthdCnt     1
#define sizeSetIndexedImageOperation            2
#define nvglSetIndexedImageOperation(ch, operation)                         \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeSetIndexedImageOperation);                          \
}

#define sizeSetIndexedImageColorFormatMthdCnt   1
#define sizeSetIndexedImageColorFormat          2
#define nvglSetIndexedImageColorFormat(ch, colorformat)                     \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_COLOR_FORMAT)); \
    nvPushData (1, (colorformat));                                          \
    nvPusherAdjust (sizeSetIndexedImageColorFormat);                        \
}

#define sizeSetIndexedImageIndexFormatMthdCnt   1
#define sizeSetIndexedImageIndexFormat          2
#define nvglSetIndexedImageIndexFormat(ch, indexformat)                     \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageIndexFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_INDEX_FORMAT)); \
    nvPushData (1, (indexformat));                                          \
    nvPusherAdjust (sizeSetIndexedImageIndexFormat);                        \
}

#define sizeSetIndexedImageLUTOffsetMthdCnt     1
#define sizeSetIndexedImageLUTOffset            2
#define nvglSetIndexedImageLUTOffset(ch, offset)                            \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageLUTOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV060_LUT_OFFSET)); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeSetIndexedImageLUTOffset);                          \
}

//-------------------------------------------------------------------------
//                              NV 077
//                   NV04_SCALED_IMAGE_FROM_MEMORY
//-------------------------------------------------------------------------

#define sizeSetScaledImageContextNotifiesMthdCnt    1
#define sizeSetScaledImageContextNotifies           2
#define nvglSetScaledImageContextNotifies(ch, ctxdmanotify)                 \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetScaledImageContextNotifies);                     \
}

#define sizeSetScaledImageContextImageMthdCnt       1
#define sizeSetScaledImageContextImage              2
#define nvglSetScaledImageContextImage(ch, ctxdmaimage)                     \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_IMAGE)); \
    nvPushData (1, (ctxdmaimage));                                          \
    nvPusherAdjust (sizeSetScaledImageContextImage);                        \
}

#define sizeSetScaledImageContextSurfaceMthdCnt     1
#define sizeSetScaledImageContextSurface            2
#define nvglSetScaledImageContextSurface(ch, ctxdmasurface)                 \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (ctxdmasurface));                                        \
    nvPusherAdjust (sizeSetScaledImageContextSurface);                      \
}

#define sizeSetScaledImageFormatMthdCnt             1
#define sizeSetScaledImageFormat                    2
#define nvglSetScaledImageFormat(ch, format)                                \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_COLOR_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeSetScaledImageFormat);                              \
}

#define sizeSetScaledImageOperationMthdCnt          1
#define sizeSetScaledImageOperation                 2
#define nvglSetScaledImageOperation(ch, operation)                          \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeSetScaledImageOperation);                           \
}

#define sizeScaledImageClipMthdCnt                  2
#define sizeScaledImageClip                         3
#define nvglScaledImageClip(ch, x, y, width, height)                        \
{                                                                           \
    nvPushData (0, (((sizeScaledImageClipMthdCnt << 2) << 16) | ((ch) << 13) | NV077_CLIP_POINT)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageClip);                                   \
}

#define sizeScaledImageOutMthdCnt                   2
#define sizeScaledImageOut                          3
#define nvglScaledImageOut(ch, x, y, width, height)                         \
{                                                                           \
    nvPushData (0, (((sizeScaledImageOutMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_OUT_POINT)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageOut);                                    \
}

#define sizeScaledImageDeltaDuDxDvDyMthdCnt         2
#define sizeScaledImageDeltaDuDxDvDy                3
#define nvglScaledImageDeltaDuDxDvDy(ch, dudx, dvdy)                        \
{                                                                           \
    nvPushData (0, (((sizeScaledImageDeltaDuDxDvDyMthdCnt << 2) << 16) | ((ch) << 13) | NV077_DELTA_DU_DX)); \
    nvPushData (1, (dudx));                                                 \
    nvPushData (2, (dvdy));                                                 \
    nvPusherAdjust (sizeScaledImageDeltaDuDxDvDy);                          \
}

#define sizeScaledImageInSizeMthdCnt                1
#define sizeScaledImageInSize                       2
#define nvglScaledImageInSize(ch, width, height)                            \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_SIZE)); \
    nvPushData (1, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageInSize);                                 \
}

#define sizeScaledImageInFormatMthdCnt              1
#define sizeScaledImageInFormat                     2
#define nvglScaledImageInFormat(ch, format)                                 \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeScaledImageInFormat);                               \
}

#define sizeScaledImageInOffsetMthdCnt              1
#define sizeScaledImageInOffset                     2
#define nvglScaledImageInOffset(ch, offset)                                 \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_OFFSET)); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeScaledImageInOffset);                               \
}

#define sizeScaledImageInPointMthdCnt               1
#define sizeScaledImageInPoint                      2
#define nvglScaledImageInPoint(ch, x, y)                                    \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInPointMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageInPoint); \
}

#define sizeScaledImageNotify                       4
#define nvglScaledImageNotify(ch)                                           \
{                                                                           \
    nvPushData (0, (((1 << 2) << 16) | ((ch) << 13) | NV077_NOTIFY));       \
    nvPushData (1, NV077_NOTIFY_WRITE_ONLY);                                \
    nvPushData (2, (((1 << 2) << 16) | ((ch) << 13) | NV077_NO_OPERATION)); \
    nvPushData (3, 0);                                                      \
    nvPusherAdjust (sizeScaledImageNotify);                                 \
}

//-------------------------------------------------------------------------
//                              NV 07C
//                     NV15_VIDEO_LUT_CURSOR_DAC
//-------------------------------------------------------------------------

// 0x00000300
#define sizeSetNv15VideoLUTCursorDACImageDataMthdCnt   2
#define sizeSetNv15VideoLUTCursorDACImageData          3
#define nvglSetNv15VideoLUTCursorDACImageData(ch, index, offset, format)    \
{                                                                           \
    nvPushData (0, (((sizeSetNv15VideoLUTCursorDACImageDataMthdCnt << 2) << 16) | ((ch) << 13) | NV07C_SET_IMAGE_OFFSET(index))); \
    nvPushData (1, offset);                                                 \
    nvPushData (2, format);                                                 \
    nvPusherAdjust (sizeSetNv15VideoLUTCursorDACImageData);                 \
}

//-------------------------------------------------------------------------
//                              NV 096
//                      NV15_CELSIUS_PRIMITIVE
//-------------------------------------------------------------------------

// 0x00000120
#define sizeSetNv15CelsiusSyncSetRWMMthdCnt        3
#define sizeSetNv15CelsiusSyncSetRWM               4
#define nvglSetNv15CelsiusSyncSetRWM(ch, read, write, modulo)               \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncSetRWMMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_SET_READ)); \
    nvPushData (1, (read));                                                 \
    nvPushData (2, (write));                                                \
    nvPushData (3, (modulo));                                               \
    nvPusherAdjust (sizeSetNv15CelsiusSyncSetRWM);                          \
}
// 0x0000012c
#define sizeSetNv15CelsiusSyncIncWriteMthdCnt      1
#define sizeSetNv15CelsiusSyncIncWrite             2
#define nvglSetNv15CelsiusSyncIncWrite(ch)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncIncWriteMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_INCREMENT_WRITE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv15CelsiusSyncIncWrite);                        \
}
// 0x00000130
#define sizeSetNv15CelsiusSyncStallMthdCnt         1
#define sizeSetNv15CelsiusSyncStall                2
#define nvglSetNv15CelsiusSyncStall(ch)                                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncStallMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_STALL)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv15CelsiusSyncStall);                           \
}

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NV4DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvFile.h ===
//======================================================================
// Module:		nvFile.cpp
// Description:	Generic file routines that are neutral to the calling OS
// 
//  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
//======================================================================

#ifndef NVFILE_H
#define NVFILE_H

#include <nvprecomp.h>

bool NvReadFile(HANDLE hFile,                // handle to file
                LPVOID lpBuffer,             // data buffer
                DWORD nNumberOfBytesToRead,  // number of bytes to read
                LPDWORD lpNumberOfBytesRead, // number of bytes read
                LPOVERLAPPED lpOverlapped    // overlapped buffer
                );

bool NvWriteFile( HANDLE hFile,                    // handle to file
                LPCVOID lpBuffer,                // data buffer
                DWORD nNumberOfBytesToWrite,     // number of bytes to write
                LPDWORD lpNumberOfBytesWritten,  // number of bytes written
                LPOVERLAPPED lpOverlapped        // overlapped buffer
                );

bool NvCloseHandle(HANDLE h);

HANDLE NvCreateFile(LPCTSTR lpFileName,                         // file name
                   DWORD dwDesiredAccess,                      // access mode
                   DWORD dwShareMode,                          // share mode
                   LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
                   DWORD dwCreationDisposition,                // how to create
                   DWORD dwFlagsAndAttributes,                 // file attributes
                   HANDLE hTemplateFile                        // handle to template file
                   );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvcom.h ===
#ifndef __NV_COM_H
#define __NV_COM_H

#include "nvOverlay.h"

// XXX Having to define this here sucks.  This is in mtexport.h but
// mtexport.h needs NVstate stuff :(   -paul
#ifndef WQ_MAX_THREAD
#define WQ_MAX_THREAD 2
#endif

typedef struct  __GLNVtagInfoRec {
    unsigned int  type;
    void          *address;
} __GLNVtagInfo;    

// Basic element of the pushbuffer
typedef union __GLNVdataRec {
    NvF32 f;
    NvS32 i;
    NvU32 u;
} __GLNVdata;

// Flags passed into the display driver when allocating or requesting
// info regarding the unified buffers.

enum  {
    SBD_BACK_1_OFFSET = 0,
    SBD_BACK_1_PITCH,
    SBD_BACK_2_OFFSET,
    SBD_BACK_2_PITCH,
    SBD_DEPTH_OFFSET,
    SBD_DEPTH_PITCH,
    SBD_FRONT_MAIN_OFFSET,
    SBD_FRONT_MAIN_PITCH,
    SBD_BACK_1_MAIN_OFFSET,
    SBD_BACK_1_MAIN_PITCH,
    SBD_FRONT_OVERLAY_OFFSET,
    SBD_FRONT_OVERLAY_PITCH,
    SBD_BACK_1_OVERLAY_OFFSET,
    SBD_BACK_1_OVERLAY_PITCH
};

typedef struct __GLNVsbdFlagsRec {
    int windowFlipping;  // Enable window flipping
    int overlaySupport;  // Allocate overlay buffers
    int surfaceInfoType;
} __GLNVsbdFlags;


typedef struct __GLNVpaletteDataRec {
  void         *windowHandle;
  unsigned int  entries[ICD_PALETTE_ENTRIES];
  unsigned int  crTransparent;
} __GLNVpaletteData;

typedef struct __GLMergeBlitDataRec
{
    NvU32 PrimaryFrontOffset; // offset of primary buffer (where DAC is working)
    NvU32 PrimaryFrontPitch ;
    NvU32 ScratchOffset     ; // offset of scratch buffer for mergeblit
    NvU32 ScratchPitch      ;

    NvU32 MainFrontOffset   ; // offset of main front plane (where overlay app has its main)
    NvU32 MainFrontPitch    ;
    NvU32 MainBackOffset    ; // offset of main back plane (where overlay app has its main)
    NvU32 MainBackPitch     ;

    NvU32 OverlayFrontOffset; // offset of overlay front plane (where overlay app has its overlay)
    NvU32 OverlayFrontPitch ;
    NvU32 OverlayBackOffset ; // offset of overlay back plane (where overlay app has its overlay)
    NvU32 OverlayBackPitch  ;

    int   colordepth        ; // 16 or 32, color depth of above buffers (UBB)

    NvU32 colorref          ; // colorkey for transparent color

    unsigned int   dwAction ; // NV_OVERLAY_xxx

    __GLregionRect *prclClip; // pointer to list of clip rects
    unsigned int    cClip;    // count of valid rects inside prclClip

    __GLregionRect rclUser  ; // single user clip rect 
} __GLMergeBlitData;


typedef struct __GLNVcmdInfoRec {

    void *state;  // __GLNVstate opaque ptr in case we need it.

    // Channel information for syncing in NTx display driver
    NvU32        maskOtherChannels;
    unsigned int ourChannelId;
    void         *ntOther; // PDEV pointer 
    void         *ntDrawable; // clientDrawableInfo pointer 

    // Number of hardware window clipping rectangles available.
    // Should be 8 for NV10GL and 1 for NV10 geForce.
    int numHWClipRects;

    // Client size view of windowChangedCount at time of kickoff; this is
    // compared with the latest count inside the display driver.  If they
    // are out of sync and flushBetween2D is TRUE then fail the kick off
    // in the display driver.
    int windowChangedCount;
    int flushedBetween2D;

    unsigned char isClipped;
    int serverSwapNT4;

    int nvDebugLevel;
    int nvDebugOptions;
    int nvDebugMask;
    int nvControlOptions;

    int temp0;
    int temp1;
    int temp2;
    int temp3;
    int temp4;
} __GLNVcmdInfo;

//
// NV10 flush information structure
//
typedef struct __GLNVflushInfoRec {
    // flush type, client handle and window handle
//    ULONG        type;
    ULONG        hClient;
#if defined(_WIN32)
    HWND         hWnd;
    HDC          hDC;
#endif

    // clip and mode switch info
    ULONG        localModeSwitchCount;

    __GLNVcmdInfo *cmdInfo;
    
    // Core Clip rectangle computed by wgl in screen coordinates
    __GLregionRect coreClipRect;

    // Tells Display driver that scissor has changed.
    ULONG wndClipRectChanged;
    
    // Clip Changed Count 
    ULONG clipChangedCount;

    // TRUE if rendering to the back buffer
    ULONG backBufferIsEnabled;

    // return status from flush command
    unsigned int retStatus;   // status of flush in display driver
} __GLNVflushInfo;

typedef struct __GLNVswapInfoRec {
    ULONG        hClient;
#if defined(_WIN32)
    HWND         hWnd;
    HDC          hDC;
#endif
    // window info
    __GLNVcmdInfo *cmdInfo;

    // clip and mode switch info
    ULONG        localModeSwitchCount;
    PVOID        drawable;

    // SwapHintRect info
    unsigned int        numSwapHintRects;
    __GLregionRect*     pSwapHintRects;

    // return status
    ULONG        retStatus;
} __GLNVswapInfo;


// probably needs to be removed to better place
// bits used in __glNVOverlayMergeFastLock - dwAction
#define NV_OVERLAY_MERGE_BLIT        0x00000001 // do front overlay + front main -> scratch -> primary
#define NV_OVERLAY_UPDATE_OVERLAY    0x00000010 // overlay back -> overlay front (prior to merge)
#define NV_OVERLAY_UPDATE_MAIN       0x00000020 // main back -> overlay front (prior to merge)
#define NV_OVERLAY_USE_CLIPRECT      0x00000100 // only do mergeblit on given rect (else entire window)
#define NV_OVERLAY_DEFERRED          0x00001000 // defer merge blit (do update later)
#define NV_OVERLAY_RUN_IN_DD         0x00002000 // do mergeblit in display driver
#define NV_OVERLAY_NO_OVERLAY_PLANE  0x00010000 // there is no overlay plane, front main -> primary (will overwrite NV_OVERLAY_MERGE_BLIT)


//
// Derived from __GLNVswapInfo to support overlay merge blit through DD.
// Used with the ESC_NV_OPENGL_OVERLAY_MERGEBLIT escape 
// in __glNVOverlayMergeFastLock.
//
typedef struct __GLNVoverlayMergeBlitInfoRec {
    unsigned int hClient;
#if defined(_WIN32)
    HWND         windowHandle;
    HDC          deviceContext;
#endif
    
    // window info
    __GLNVcmdInfo *cmdInfo;

    // clip and mode switch info
    unsigned int localModeSwitchCount;

    // return status
    unsigned int retStatus;

    unsigned int dwAction; // NV_OVERLAY_xxx

    int          x;        // bounding rectangle if NV_OVERLAY_USE_CLIPRECT is set 
    int          y;
    int          width;
    int          height;

    // SwapHintRect info
    unsigned int numSwapHintRects;
    void *       pSwapHintRects;

} __GLNVoverlayMergeBlitInfo;

//
// These routines live in the shared lib and are called from both the ICD
// and from the display driver side of OGL escape calls.  -paul
//

// nvsharedpushbuf.c
extern void STDCALL __glNVMakeJumpSpaceInPushBuffer(__GLNVcmdInfo *cmdInfo);
extern void STDCALL __glNVSetupAndKickoff(__GLNVcmdInfo *cmdInfo,
                                          unsigned int numInclusiveRects,__GLregionRect *inclusiveRects,
                                          unsigned int numExclusiveRects,__GLregionRect *exclusiveRects);
// nvsharedutils.c
extern void STDCALL __glNVInitSharedFnPtrs(__GLNVcmdInfo *cmdInfo);

// nvsharedswap.c
extern GLboolean STDCALL __glNVSetupSwap (__GLNVcmdInfo *cmdInfo, void * drawable,
                                          unsigned int numRects, __GLregionRect *rects,
                                          int screenWidth, int screenHeight);
extern GLboolean STDCALL __glNVSetupMergeBlit (__GLNVcmdInfo *cmdInfo, 
                                          struct __GLMergeBlitDataRec *pMergeBlitData);

// nv4sharedpushbuf.c
extern void STDCALL __glNV4SetupAndKickoff(__GLNVcmdInfo *cmdInfo,
                                           unsigned int numRects,
                                           __GLregionRect *rects);
#endif  // __NV_COM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvEscDef.h ===
/*
 * nvEscDef.h
 *
 * Provides definitions for nVidia ExtEscape calls into display driver.
 *
 * Copyright (c) 1998, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#ifndef NV_ESC_DEF_INCLUDED
#define NV_ESC_DEF_INCLUDED


////////////////////////////////////////////////////////////////////////
// nVidia private escapes

#ifdef UNIX
#define NV_ESC_RM_BASE                  0x0000
#else
#define NV_ESC_RM_BASE                  0x7000
#endif

#define NV_ESC_RM_OPEN                  (NV_ESC_RM_BASE + 0x20)
#define NV_ESC_RM_CLOSE                 (NV_ESC_RM_BASE + 0x21)
#define NV_ESC_RM_ALLOC_ROOT            (NV_ESC_RM_BASE + 0x22)
#define NV_ESC_RM_ALLOC_DEVICE          (NV_ESC_RM_BASE + 0x23)
#define NV_ESC_RM_ALLOC_CONTEXT_DMA     (NV_ESC_RM_BASE + 0x24)
#define NV_ESC_RM_ALLOC_CHANNEL_PIO     (NV_ESC_RM_BASE + 0x25)
#define NV_ESC_RM_ALLOC_CHANNEL_DMA     (NV_ESC_RM_BASE + 0x26)
#define NV_ESC_RM_ALLOC_MEMORY          (NV_ESC_RM_BASE + 0x27)
#define NV_ESC_RM_ALLOC_OBJECT          (NV_ESC_RM_BASE + 0x28)
#define NV_ESC_RM_FREE                  (NV_ESC_RM_BASE + 0x29)
#define NV_ESC_RM_DMA_PUSH_INFO         (NV_ESC_RM_BASE + 0x2A)
#define NV_ESC_RM_ALLOC                 (NV_ESC_RM_BASE + 0x2B)
#define NV_ESC_RM_CONFIG_VERSION        (NV_ESC_RM_BASE + 0x31)
#define NV_ESC_RM_CONFIG_GET            (NV_ESC_RM_BASE + 0x32)
#define NV_ESC_RM_CONFIG_SET            (NV_ESC_RM_BASE + 0x33)
#define NV_ESC_RM_CONFIG_UPDATE         (NV_ESC_RM_BASE + 0x34)
#define NV_ESC_RM_ARCH_HEAP             (NV_ESC_RM_BASE + 0x35)
#define NV_ESC_RM_DEBUG_CONTROL         (NV_ESC_RM_BASE + 0x36)
#define NV_ESC_RM_CONFIG_GET_EX         (NV_ESC_RM_BASE + 0x37)
#define NV_ESC_RM_CONFIG_SET_EX         (NV_ESC_RM_BASE + 0x38)
#define NV_ESC_RM_I2C_ACCESS            (NV_ESC_RM_BASE + 0x39)
#define NV_ESC_RM_POWER_MANAGEMENT      (NV_ESC_RM_BASE + 0x3A)
#define NV_ESC_RM_INTERRUPT             (NV_ESC_RM_BASE + 0x3B)
#define NV_ESC_RM_OS_CONFIG_GET         (NV_ESC_RM_BASE + 0x3C)
#define NV_ESC_RM_OS_CONFIG_SET         (NV_ESC_RM_BASE + 0x3D)
#define NV_ESC_RM_OS_CONFIG_GET_EX      (NV_ESC_RM_BASE + 0x3E)
#define NV_ESC_RM_OS_CONFIG_SET_EX      (NV_ESC_RM_BASE + 0x3F)
#define NV_ESC_RM_NVWATCH               (NV_ESC_RM_BASE + 0x40)

#ifdef UNIX
#define NV_ESC_RM_ALLOC_EVENT           (NV_ESC_RM_BASE + 0x44)
#define NV_ESC_RM_AGP_INIT              (NV_ESC_RM_BASE + 0x45)
#define NV_ESC_RM_AGP_TEARDOWN          (NV_ESC_RM_BASE + 0x46)
#define NV_ESC_RM_IO_FLUSH              (NV_ESC_RM_BASE + 0x47)
#endif

////////////////////////////////////////////////////////////////////////
// Nvidia OpenGL client information.

//
// NOTE: WNDOBJ_SETUP and ESC_NV_OPENGL_CREATE_DRAWABLE perform
// the same function except that the I/O manager in NT responds
// to WNDOBJ_SETUP by calling our DrvClipChanged during the actual
// escape call.  This doesn't happen with ESC_NV_OPENGL_CREATE_DRAWABLE
// so the shared clip list area isn't initialized properly.
//
#define WNDOBJ_SETUP                            4354

#define ESC_NV_OPENGL_DMA_PUSH_GO               0x7001

#define ESC_NV_OPENGL_ESCAPE                    0x7101 // nVidia OpenGL escape
//#define ESC_NV_OPENGL_CREATE_DRAWABLE           0x0001 // create drawable client information
#define ESC_NV_OPENGL_DESTROY_DRAWABLE          0x0002 // destroy drawable client information
#define ESC_NV_OPENGL_CREATE_CONTEXT            0x0003 // create context client information
#define ESC_NV_OPENGL_DESTROY_CONTEXT           0x0004 // destroy context client information
#define ESC_NV_OPENGL_DMA_PUSH_GO_CMD           0x0005 // NV3 DMA push go command
#define ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY     0x0006 // memory to screen copy
#define ESC_NV_OPENGL_SCREEN_TO_SCREEN_SRCCOPY  0x0007 // screen to screen copy
#define ESC_NV_OPENGL_SUPPORT_ENABLED           0x0008 // OpenGL ICD enabled or NOT!
#define ESC_NV_OPENGL_ALLOC_SHARED_MEMORY       0x0009 // create shared memory area
#define ESC_NV_OPENGL_FREE_SHARED_MEMORY        0x000A // free shared memory area
#define ESC_NV_OPENGL_GET_DISPLAY_PITCH         0x000B // return pitch of display
#define ESC_NV4_OPENGL_SWAP_BUFFERS             0x000C // NV4 swap buffers...
#define ESC_NV4_OPENGL_FLUSH                    0x000D // NV4 flush...
#define ESC_NV_OPENGL_PURGE_DEVICE_BITMAP       0x000E // purge GDI device bitmaps...
#define ESC_NV_OPENGL_FLUSH                     0x000F // NV10 and up style flush...
#define ESC_NV_OPENGL_SWAP_BUFFERS              0x0010 // NV10 and up style swap buffers...
#define ESC_NV_OPENGL_CPUBLIT                   0x0011 // Generic CPU blit. Currently used for buffer region Ext.
#define ESC_NV_OPENGL_INIT_STATE                0x0012 // Initialize HW state from the display driver side
#define ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES    0x0021 // alloc single back/depth in GDI display driver
#define ESC_NV_OPENGL_FREE_UNIFIED_SURFACES     0x0022 // free single back/depth in GDI display driver
#define ESC_NV_OPENGL_GET_SURFACE_INFO          0x0023 // get offset for single back
#define ESC_NV_OPENGL_DID_STATUS_CHANGE         0x0029 // clip list status call
#define ESC_NV_OPENGL_GET_CLIP_LIST_COUNT       0x002A // return count of rectangles in clip list
#define ESC_NV_OPENGL_GET_CLIP_LIST             0x002B // return list of rectangles for window clip
#define ESC_NV_OPENGL_SUPPORT                   0x002C // return TRUE if OpenGL supported...
#define ESC_NV_OPENGL_REGISTER_RM_CLIENT        0x002D // register RM client with display driver
#define ESC_NV_OPENGL_UNREGISTER_RM_CLIENT      0x002E // unregister RM client with display driver
#define ESC_NV_OPENGL_SET_DAC_BASE              0x002F // set the display base offset
#define ESC_NV_OPENGL_SYNC_CHANNEL              0x0030 // wait for FIFO and graphics engine to be !busy
#define ESC_NV_OPENGL_SET_LAYER_PALETTE         0x0031 // Overlay specific: set palette entries in the DD
#define ESC_NV_OPENGL_GET_LAYER_PALETTE         0x0032 // Overlay specific: get palette entries from the DD
#define ESC_NV_OPENGL_OVERLAY_MERGEBLIT         0x0033 // Overlay specific: do the merge blit fm+fo->scratch->primary
#define ESC_NV_OPENGL_OVERLAY_ALLOWED           0x0034 // W2K: DrvDescribePixelformat needs to know is overlay is possible
#define ESC_NV_OPENGL_STEREO_ALLOWED            0x0035 // W2K: DrvDescribePixelformat needs to know is stereo is possible
#define ESC_NV_OPENGL_SHARED_LIBRARY_SIZES      0x0036 // check __GLNVstate and __GLdrawablePrivate sizes

#undef ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY // uses a separate escape...
#define ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY     0x7102


#define ESC_NV_QUERYSET_REGISTRY_KEY              0x7103
#define NV_QUERY_REGISTRY_KEY                     0x0001
#define NV_SET_REGISTRY_KEY                       0x0002
#define NV_QUERY_REGISTRY_BINARY_KEY              0x0004


#define ESC_NV_MAP_USER					0x9000
#define ESC_NV_UNMAP_USER				0x9001

#ifndef NV_SIGNATURE
// This value also is defined in driver.h of display driver
#define NV_SIGNATURE 0x11223344
#endif

#define ESC_NV_QUERY_PCI_SLOT                   0x7105
#define ESC_NV_QUERY_HEAD_REFRESH_RATE          0x7106

#ifndef NV_ESC_PRIMARY_INFO
#define NV_ESC_PRIMARY_INFO 0x7104
typedef struct _NV_PRIMARY_INFO
{
    ULONG  ulNVSignature;   // IN
    ULONG  ulNumDevices;    // IN
    ULONG  ulHeadNum;       // IN
    ULONG  ulReturnCode;    // IN
    ULONG  ulWidth;         // OUT from display driver
    ULONG  ulHeight;        // OUT from display driver
    ULONG  ulDepth;         // OUT from display driver
    ULONG  ulPitch;         // OUT from display driver
    ULONG  ulPrimaryOffset; // OUT from display driver
    ULONG  ulNumDACs;       // OUT from display driver (NT only)
    ULONG  ulNumActiveDACs; // OUT from display driver
    ULONG  ulActiveDACs;    // OUT from display driver (NT only)
    ULONG *ulPanningPtr;    // OUT from display driver (9x only)
    ULONG *ulFullscreenPtr; // OUT from display driver (9x only)
} NV_PRIMARY_INFO;
#endif

#ifdef _WIN32 // rest of this file only needed for win32 interfaces

typedef struct _NV_OPENGL_COMMAND
{
    ULONG       NVSignature;
    ULONG       command;             // Handle to resource manager client used in NvFree
    ULONG       numDevices;          // Number of devices in the system
    HWND        hWnd;                // Window handle
    HDC         hDC;                 // GDI device context handle
    ULONG       hClient;             // Handle to resource manager client
    ULONG       processHandle;       // Process handle from client associated with globalData
    PVOID       globalData;          // Pointer to global shared data for destroy
    PVOID       other;               // Pointer to whatever
} NV_OPENGL_COMMAND;

typedef struct _NV_OPENGL_CLIP_LIST_DATA
{
    int  clipChangedCount;
    int  rgnDataSize;
    void *rgnData;
    void *rect;
} NV_OPENGL_CLIP_LIST_DATA;

typedef struct _NV_OPENGL_GLOBAL_DATA
{
    ULONG oglMutex;
    ULONG oglModeSwitch;
    ULONG oglPFifoAddress;
    ULONG oglSystemMutex;
} NV_OPENGL_GLOBAL_DATA;

typedef struct _NV_WNDOBJ_SETUP
{
    ULONG       NVSignature;
    HWND        hWnd;       /* Handle to window */
    HDC         hDC;        /* handle to GDI device context */
    ULONG       numDevices; /* Number of devices in the system */
    int         overlayMember; // TRUE if part of an overlay
} NV_WNDOBJ_SETUP;

#define NV_CLIP_MUTEX_WAIT_IN_SECONDS       10 // 10 milliseconds
#define NV_WINDOW_CLIP_FULLYVISIBLE         0x0001
#define NV_WINDOW_CLIP_OCCLUDED             0x0002
#define NV_WINDOW_CLIP_SINGLERECTANGLE      0x0004
#define NV_WINDOW_CLIP_COMPLEX              0x0008
#define NV_WINDOW_CLIP_FULLSCREEN           0x0010
#define MAX_OGL_CLIP_RECTS                  250
#define MAX_OGL_CLIENTS                     512

#define NV_CLIP_LIST_FLUSH                  0x0001
#define NV_CLIP_LIST_SWAP                   0x0002
#define NV_CLIP_LIST_DIRTY                  0x0004

typedef struct _NV_OPENGL_DRAWABLE_INFO
{
    ULONG       oglMutexPtr;            // Handle to resource manager client used in NvFree
    PVOID       oglGlobalPagePtr;       // Pointer to shared memory
    ULONG       mutexLock;              // Lock on this data structure
    PVOID       pClientInfoMdl;         // MDL for lock down pages
    PVOID       userVirtualAddress;     // user virtual address for clientInfo
    ULONG       hClient;                // handle to resource manager
    HANDLE      hWnd;                   // Handle to window tracked in DrvClipChanged
    HANDLE      hDC;                    // Handle to GDI device context
    LONG        iPixelFormat;           // pixel format associated with this client
    RECT        rect;                   // rectangle of window on screen
    ULONG       clipChangedCount;       // Number of times clip has changed since client registered
    ULONG       clipFlags;              // Clip status for last clip
    ULONG       numClipRects;           // Number of clip rectangles
    RECTL       windowRect[MAX_OGL_CLIP_RECTS];
                                        // Clip region for client window
    PVOID       origClientDrawableInfoPtr; 
                                        // Original Ptr remembered to free memory

    RECTL       *cachedClipRectList;    // Cache the clip list so that we do not have to merge it
    ULONG       cachedNumClipRects;     // Number of rectangles.
    ULONG       cachedClipListSize;     // Currently allocated size of the clip list.
	ULONG       cachedClipListFlag;     // Flag to determine whether to recompute clip list.
                                        // Values: NV_CLIP_LIST_FLUSH, NV_CLIP_LIST_SWAP, NV_CLIP_LIST_DIRTY
    RECTL       *cachedExclusiveRectList;    // Cache the clip list so that we do not have to merge it
    ULONG       cachedNumExclusiveRects;     // Number of rectangles.
    RECTL       *copyWindowRect;           // Actual clip rectangle pointer used everywhere in NV4+ driver
    ULONG       sizeCopyWindowRectList;    // Size of clip rectangle pointer above.

    RECTL       *translateWindowRectList; // cache for translated clip list
    ULONG       translateNumWindowRects;  // cache count for translate clip list

    ULONG       cxScreen, cyScreen;     // width and height of display
    ULONG       cxcyChanged;

    //
    // The following flag is used when UBB is ON, window flipping is OFF and there are no OGL windows
    // occluding the window this drawable structure references.  This is an optimization for window
    // clipping created for 3D Studio Max.  When 3D Studio Max is in No redraw on expose mode, an expose
    // event will not cause a re-render of the scene.  Compaq workstation did not like this and complained
    // that the image is wrong in comparison to other CAD graphics products.  Since the 3D pixels are 
    // clipped to a GDI window that is occluding our OGL window, it is possible to render those pixels
    // with UBB on without causing scribble.  But for this to work, the occluding window must NOT be a
    // OGL window and window flipping must be off.
    //
    // This flag is computed as part of the DrvClipChanged function.
    //
    ULONG       ubbWindowClipFlag;      // TRUE means use window bounds for clip; otherwise use copyWindowRect list
    ULONG       refCount;               // mainplane+overlay track the same window!, so we need a refCount, to securely destroy the drawable
    // **attention**: - currently sizeof(NV_OPENGL_DRAWABLE_INFO)> 1 page
    //                - only the first page(4096) of NV_OPENGL_DRAWABLE_INFO is visible in the ICD!
    //                - do not place icd-visible members at the end! [and vice versa]
    int         overlayMember;
    } NV_OPENGL_DRAWABLE_INFO;

typedef struct _NV_OPENGL_CONTEXT_INFO
    {
    PVOID       oglGlobalPagePtr;       // Pointer to shared memory
    PVOID       clientPFifoAddress;     // Address of FIFO in client address space
    HWND        hWnd;                   // Window/drawable associated with context
    HDC         hDC;                    // GDI device context
    ULONG       hClient;                // Handle to resource manager client
    PVOID       pClientInfoMdl;         // MDL for lock down pages
    PVOID       userVirtualAddress;     // user virtual address for clientInfo
    PVOID       origClientContextInfoPtr; 

                                        // Original Ptr remembered to free memory
    } NV_OPENGL_CONTEXT_INFO;

// WARNING! This structure is shared with NT display driver in driver.h
#define OGL_ERROR_NO_ERROR             0x0000
#define OGL_ERROR_MODE_SWITCH          0x0001
#define OGL_ERROR_CLIENT_NOT_FOUND     0x0002
#define OGL_ERROR_CLIP_MUTEX_TIMEOUT   0x0003
#define OGL_ERROR_CLIP_LIST_BAD        0x0004
#define OGL_ERROR_LOAD_BUFFER_INFO     0x0005
#define OGL_ERROR_SIMPLE_TO_COMPLEX    0x0006
#define OGL_ERROR_COMPLEX_TO_SIMPLE    0x0007
#define OGL_ERROR_REALLOC_FAILURE      0x0008
#define OGL_ERROR_NO_SWAP              0x0009
#define OGL_ERROR_WINDOW_CHANGED_COUNT 0x000A
#define OGL_ERROR_SURFACE_INVALID      0x000B

typedef struct __GLNVClientSwapHintInfoRec {
    ULONG swapHintRectCount;
    // Swap Hint Rectangle List
    LPRECT swapHintRectList;
} __GLNVClientSwapHintInfo;

typedef struct __GLNVWindowInfoRec {
    // window info
    ULONG left;
    ULONG top;
    ULONG offsetX;
    ULONG offsetY;
    int   winLeft; // window left relative to desktop
    int   winTop;  // window top relative to desktop
    int   devLeft; // device left relative to desktop
    int   devTop;  // device top relative to desktop
    int   clipX;   // drawable clip left value
    int   clipY;   // drawable clip top value
    int   clipW;   // drawable clip width
    int   clipH;   // drawable clip height
} __GLNVWindowInfo;

typedef struct __GLNV4ScissorClipHWInfoRec {
    // scissor clip info
    ULONG set3DSurfaceClipControlWord;
    ULONG size3DSurfacesClip;
} __GLNV4ScissorClipHWInfo;

typedef struct __GLNV4BlitHWInfoRec {
    // BLIT info
    ULONG bltControlWord;
    ULONG bltSizeSet;
} __GLNV4BlitHWInfo;

typedef struct __GLNV4PushBufferHWInfoRec {

    // push buffer info
    ULONG *pClipStart;  // start of clip NOOPs
    ULONG *pBufCur;
    ULONG  dwCmdBufFreeCount;
    PVOID  dmaChannel;
    ULONG *pushBufferBase;
    ULONG *pushBufferEnd;
    ULONG  maskOtherChannels;
    ULONG  ourChannelId;
    ULONG  dwCachedGet;
    ULONG  dwCachedPut;
    ULONG *lastJump;
} __GLNV4PushBufferHWInfo;

typedef struct __GLNV4ClipBufferHWInfoRec {

    // clip buffer info
    void  *tagTable;
    ULONG  tagEnd;
    ULONG *pClipBufBase;
} __GLNV4ClipBufferHWInfo;


typedef struct __GLNV4swapInfoRec {
    ULONG hClient;
    HWND  hWnd;
    HDC   hDC;

    // window info
    __GLNVWindowInfo winInfo;

    // BLIT info
    __GLNV4BlitHWInfo blitInfo;

    // push buffer info
    __GLNV4PushBufferHWInfo pushBufferInfo;

    // clip buffer info
    __GLNV4ClipBufferHWInfo clipBufferInfo;

    // clip and mode switch info
    ULONG localModeSwitchCount;

    __GLNVClientSwapHintInfo clientSwapInfo;

    // swap interval
    ULONG swapInterval;
    ULONG swapCounter;

    // Window Changed Count 
    ULONG windowChangedCount;

    // return status
    ULONG retStatus;
} __GLNV4swapInfo;

#define NV_BLIT_MEM_TO_SCR 1
#define NV_BLIT_SCR_TO_MEM 2
typedef struct {
    HWND        hWnd;
    HDC         hDC;
    ULONG       blitType;
    ULONG       useClipList;
    PVOID       pSrcBase; 
    ULONG       dwSrcByteWidth; 
    ULONG       dwSrcElementSize;
    ULONG       dstOffset; // offset in frame buffer
    PVOID       pDstBase; 
    ULONG       dwDstByteWidth; 
    ULONG       dwDstElementSize;
    ULONG       dwSrcLeft; 
    ULONG       dwSrcTop;
    ULONG       dwDstLeft; 
    ULONG       dwDstTop;
    ULONG       dwWidth; 
    ULONG       dwHeight;
    ULONG       retStatus;
} __GLNvCpuBltData;

typedef struct {
    ULONG       type;
    PCHAR       keyName;
    PVOID       keyVal;
    ULONG       keyValSize;
    ULONG       keyValMaxSize;
    ULONG       retStatus;
} *__PNVRegKeyInfo, __NVRegKeyInfo;


// Desktop Manager private escapes
#define ESC_NV_DESKMGR_ZOOMBLIT         0x7107

#define NVDM_ESC_BLIT_VIDMEM            0x00000000
#define NVDM_ESC_BLIT_SYSMEM            0x00000001
#define NVDM_ESC_BLIT_SMOOTH            0x00000002

typedef struct {
    ULONG flags;
    int scale;
    union {
        RECTL srcRect;
        struct {
            ULONG format;
            int stride;
            PVOID bits;
        } srcMem;
    };
    RECTL dstRect;
    int clips;
    RECTL clipRects[1];
} __NVDMEscapeParams;

#endif // _WIN32

#endif // NV_ESC_DEF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvFourCC.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//  Content:    FOURCC codes used in the nVidia drivers
//
//  Note that this file is meant to be used across ALL operating systems.
//  Do not create any dependency on non-nVidia code.
//
// **************************************************************************
#ifndef _NVFOURCC_H_
#define _NVFOURCC_H_

#include "nvTypes.h"

/* MMIO macros */
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (NvU32)(NvU8)(ch0) | ( (NvU32)(NvU8)(ch1) << 8 ) |    \
                ( (NvU32)(NvU8)(ch2) << 16 ) | ( (NvU32)(NvU8)(ch3) << 24 ) )
#endif // mmioFOURCC

/* FOURCC video formats we support */
#ifndef FOURCC_UYVY
#define FOURCC_UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef FOURCC_YUY2
#define FOURCC_YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef FOURCC_UYNV
#define FOURCC_UYNV                        mmioFOURCC('U','Y','N','V')
#endif
#ifndef FOURCC_YUNV
#define FOURCC_YUNV                        mmioFOURCC('Y','U','N','V')
#endif
#ifndef FOURCC_YV12
#define FOURCC_YV12                        mmioFOURCC('Y','V','1','2')
#endif
#ifndef FOURCC_NVDS
#define FOURCC_NVDS                        mmioFOURCC('N','V','D','S')
#endif
#ifndef FOURCC_NVMC
#define FOURCC_NVMC                        mmioFOURCC('N','V','M','C')
#endif
#ifndef FOURCC_NV12
#define FOURCC_NV12                        mmioFOURCC('N','V','1','2')
#endif
#ifndef FOURCC_NVID
#define FOURCC_NVID                        mmioFOURCC('N','V','I','D')
#endif
#ifndef FOURCC_NVSP
#define FOURCC_NVSP                        mmioFOURCC('N','V','S','P')
#endif
#ifndef FOURCC_420i
#define FOURCC_420i                        mmioFOURCC('4','2','0','i')
#endif
#ifndef FOURCC_IF09
#define FOURCC_IF09                        mmioFOURCC('I','F','0','9')
#endif
#ifndef FOURCC_YVU9
#define FOURCC_YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef FOURCC_IV32
#define FOURCC_IV32                        mmioFOURCC('I','V','3','2')
#endif
#ifndef FOURCC_IV31
#define FOURCC_IV31                        mmioFOURCC('I','V','3','1')
#endif
#ifndef FOURCC_RAW8
#define FOURCC_RAW8                        mmioFOURCC('R','A','W','8')
#endif
#ifndef FOURCC_RGB0
#define FOURCC_RGB0                        0 // ?? @mjl@
#endif
#ifndef FOURCC_UBAD
#define FOURCC_UBAD                        mmioFOURCC('U','B','A','D')
#endif

/* FOURCC formats we support for 3d textures */
#ifndef FOURCC_NVT0
#define FOURCC_NVT0                        mmioFOURCC('N','V','T','0')
#endif
#ifndef FOURCC_NVT1
#define FOURCC_NVT1                        mmioFOURCC('N','V','T','1')
#endif
#ifndef FOURCC_NVT2
#define FOURCC_NVT2                        mmioFOURCC('N','V','T','2')
#endif
#ifndef FOURCC_NVT3
#define FOURCC_NVT3                        mmioFOURCC('N','V','T','3')
#endif
#ifndef FOURCC_NVT4
#define FOURCC_NVT4                        mmioFOURCC('N','V','T','4')
#endif
#ifndef FOURCC_NVT5
#define FOURCC_NVT5                        mmioFOURCC('N','V','T','5')
#endif
#ifndef FOURCC_NVT6
#define FOURCC_NVT6                        mmioFOURCC('N','V','T','6')
#endif
#ifndef FOURCC_NVT7
#define FOURCC_NVT7                        mmioFOURCC('N','V','T','7')
#endif
#ifndef FOURCC_NVT8
#define FOURCC_NVT8                        mmioFOURCC('N','V','T','8')
#endif
#ifndef FOURCC_NVT9
#define FOURCC_NVT9                        mmioFOURCC('N','V','T','9')
#endif
#ifndef FOURCC_NVS0
#define FOURCC_NVS0                        mmioFOURCC('N','V','S','0')
#endif
#ifndef FOURCC_NVS1
#define FOURCC_NVS1                        mmioFOURCC('N','V','S','1')
#endif
#ifndef FOURCC_NVS2
#define FOURCC_NVS2                        mmioFOURCC('N','V','S','2')
#endif
#ifndef FOURCC_NVS3
#define FOURCC_NVS3                        mmioFOURCC('N','V','S','3')
#endif
#ifndef FOURCC_NVS4
#define FOURCC_NVS4                        mmioFOURCC('N','V','S','4')
#endif
#ifndef FOURCC_NVS5
#define FOURCC_NVS5                        mmioFOURCC('N','V','S','5')
#endif
#ifndef FOURCC_NVS6
#define FOURCC_NVS6                        mmioFOURCC('N','V','S','6')
#endif
#ifndef FOURCC_NVS7
#define FOURCC_NVS7                        mmioFOURCC('N','V','S','7')
#endif
#ifndef FOURCC_NVS8
#define FOURCC_NVS8                        mmioFOURCC('N','V','S','8')
#endif
#ifndef FOURCC_NVS9
#define FOURCC_NVS9                        mmioFOURCC('N','V','S','9')
#endif
#ifndef FOURCC_NVHU
#define FOURCC_NVHU                        mmioFOURCC('N','V','H','U')
#endif
#ifndef FOURCC_NVHS
#define FOURCC_NVHS                        mmioFOURCC('N','V','H','S')
#endif
#ifndef FOURCC_DXT1
#define FOURCC_DXT1                        mmioFOURCC('D','X','T','1') // Compressed Texture
#endif
#ifndef FOURCC_DXT2
#define FOURCC_DXT2                        mmioFOURCC('D','X','T','2')
#endif
#ifndef FOURCC_DXT3
#define FOURCC_DXT3                        mmioFOURCC('D','X','T','3')
#endif
#ifndef FOURCC_DXT4
#define FOURCC_DXT4                        mmioFOURCC('D','X','T','4')
#endif
#ifndef FOURCC_DXT5
#define FOURCC_DXT5                        mmioFOURCC('D','X','T','5')
#endif


// Note!! The number below is UNRELATED to the number of fourcc's defined above.  
// This is the number that will be USED by the driver. This should be redone! @mjl@

/* total number of fourcc formats we support */
#define NV_MAX_FOURCC_REGULAR (10 + 12)     // 10 ddraw/video, 12 texture

#ifdef DXT_SUPPORT
#define NV_MAX_FOURCC_COMPRESSED 5          // 5 compressed texture
#else
#define NV_MAX_FOURCC_COMPRESSED 0
#endif

#define NV_MAX_FOURCC                       (NV_MAX_FOURCC_REGULAR+NV_MAX_FOURCC_COMPRESSED)

#endif // _NVFOURCC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvCapture.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//////////////////////////////////////////////////////////////////////////////
// schema history
// 1. original version
// 2. adds CAPTURE_OBJECT_FREE, ANNOTATION, CAPTURE_CONFIG settings
// 3. adds CAPTURE_SYNC3 and obsoletes CAPTURE_SYNC
// 4. adds CAPTURE_LOCK
//////////////////////////////////////////////////////////////////////////////

#ifndef _nvCapture_h
#define _nvCapture_h

#ifdef __cplusplus
extern "C"
{
#endif
#pragma pack(push,1)

//////////////////////////////////////////////////////////////////////////////
// constants
//
#define CAPTURE_JMP_COMMAND             0x20ffffff
#define CAPTURE_EXT_SIGNATURE           0x420352ec

#define CAPTURE_CTXDMA_TYPE_PCI         0x49435920
#define CAPTURE_CTXDMA_TYPE_AGP         0x50474120
#define CAPTURE_CTXDMA_TYPE_VID         0x44495620

#define CAPTURE_SURFACE_TYPE_NORMAL     0x4d524f4e  // 'NORM'  surface goes into normal space (tiled)
#define CAPTURE_SURFACE_TYPE_ZETA       0x4154455a  // 'ZETA'  surface goes into zeta space (tiled)
#define CAPTURE_SURFACE_TYPE_TEXTURE    0x54584554  // 'TEXT'  surface goes into texture space

#define CAPTURE_SURFACE_KIND_TARGET     0x54475254  // 'TRGT'  surface will be used as a render target
#define CAPTURE_SURFACE_KIND_ZETA       0x4154455a  // 'ZETA'  surface will be used as a z buffer
#define CAPTURE_SURFACE_KIND_TEXTURE    0x54584554  // 'TEXT'  surface will be used as a texture
#define CAPTURE_SURFACE_KIND_VERTEX     0x54524556  // 'VERT'  surface will be used as a vertex buffer
#define CAPTURE_SURFACE_KIND_PUSHER     0x48535550  // 'PUSH'  surface will be used as a push buffer
#define CAPTURE_SURFACE_KIND_UNKNOWN    0x4e4b4e55  // 'UNKN'  surface will be used as a push buffer
#define CAPTURE_SURFACE_KIND_COMMAND    0x4d4d4f43  // 'COMM'  surface will be used as a command buffer
#define CAPTURE_SURFACE_KIND_PALETTE    0x434c4150  // 'PALE'  surface will be used as a palette

#define CAPTURE_SURFACE_FORMAT_Y8                0
#define CAPTURE_SURFACE_FORMAT_AY8               1
#define CAPTURE_SURFACE_FORMAT_A1R5G5B5          2
#define CAPTURE_SURFACE_FORMAT_X1R5G5B5          3
#define CAPTURE_SURFACE_FORMAT_A4R4G4B4          4
#define CAPTURE_SURFACE_FORMAT_R5G6B5            5
#define CAPTURE_SURFACE_FORMAT_A8R8G8B8          6
#define CAPTURE_SURFACE_FORMAT_unknown1          7
#define CAPTURE_SURFACE_FORMAT_X8R8G8B8          8
#define CAPTURE_SURFACE_FORMAT_I8_A1R5G5B5       9
#define CAPTURE_SURFACE_FORMAT_I8_R5G6B5        10
#define CAPTURE_SURFACE_FORMAT_I8_A4R4G4B4      11
#define CAPTURE_SURFACE_FORMAT_I8_A8R8G8B8      12
#define CAPTURE_SURFACE_FORMAT_DXT1_A1R5G5B5    13
#define CAPTURE_SURFACE_FORMAT_DXT23_A8R8G8B8   14
#define CAPTURE_SURFACE_FORMAT_DXT45_A8R8G8B8   15
#define CAPTURE_SURFACE_FORMAT_IMAGE_A1R5G5B5   16
#define CAPTURE_SURFACE_FORMAT_IMAGE_R5G6B5     17
#define CAPTURE_SURFACE_FORMAT_IMAGE_A8R8G8B8   18
#define CAPTURE_SURFACE_FORMAT_IMAGE_Y8         19
#define CAPTURE_SURFACE_FORMAT_IMAGE_SY8        20
#define CAPTURE_SURFACE_FORMAT_IMAGE_X7SY9      21
#define CAPTURE_SURFACE_FORMAT_IMAGE_R8B8       22
#define CAPTURE_SURFACE_FORMAT_IMAGE_G8B8       23
#define CAPTURE_SURFACE_FORMAT_IMAGE_SG8SB8     24
#define CAPTURE_SURFACE_FORMAT_unknown2         25
#define CAPTURE_SURFACE_FORMAT_unknown3         26
#define CAPTURE_SURFACE_FORMAT_unknown4         27

#define CAPTURE_LOCK_TYPE_LOCK                   1
#define CAPTURE_LOCK_TYPE_UNLOCK                 2

#define CAPTURE_ANNOTATION_ALLOC4X               0

#define CAPTURE_SYNC_SPECIAL            0xffffffff
#define CAPTURE_SYNC_WAIT_ZEROCOMMANDS  0x00000001  // wait for command buffer to empty (put==get)
#define CAPTURE_SYNC_WAIT_CHIPIDLE      0x00000002  // wait fot call engines to go idle
#define CAPTURE_SYNC_WAIT_CHANNELS      0x00000003  // wait for other channels to complete

#define CAPTURE_SYNC3_TYPE_ZEROCOMMANDS 0x00000001  // wait for command buffer to empty (put==get)
#define CAPTURE_SYNC3_TYPE_CHIPIDLE     0x00000002  // wait fot call engines to go idle
#define CAPTURE_SYNC3_TYPE_CHANNELS     0x00000003  // wait for other channels to complete
#define CAPTURE_SYNC3_TYPE_NOTIFIER     0x00000004  // wait for a notifier
#define CAPTURE_SYNC3_TYPE_REFCOUNT     0x00000005  // wait for a refcount
#define CAPTURE_SYNC3_TYPE_SEMAPHORE    0x00000006  // wait for a semaphore

#define CAPTURE_SCHEMA_1                0x00000001
#define CAPTURE_SCHEMA_2                0x00000002
#define CAPTURE_SCHEMA_3                0x00000003
#define CAPTURE_SCHEMA_4                0x00000004

#ifdef DANIEL
#define CAPTURE_CURRENT_SCHEMA          CAPTURE_SCHEMA_1
#else
#define CAPTURE_CURRENT_SCHEMA          CAPTURE_SCHEMA_4
#endif

//
// INFORMATION
//
#define CAPTURE_XID_INFORMATION             0x4f464e49  // 'INFO'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_INFORMATION
    DWORD dwSchema;                 // file version (CAPTURE_CURRENT_SCHEMA)
    char  szInformation[256];       // creation info
} CAPTURE_INFORMATION;

//
// CTXDMA_CREATE
//
#define CAPTURE_XID_CTXDMA_CREATE           0x52435843  // 'CXCR'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_CTXDMA_CREATE
    DWORD dwHandle;                 // you figure it out, Tex
    DWORD dwType;                   // CAPTURE_CTXDMA_TYPE_xxx
    DWORD dwSize;                   // [bytes]
    DWORD dwBaseAddress;            // application base address
} CAPTURE_CTXDMA_CREATE;

//
// SURFACE_ALLOC
//
#define CAPTURE_XID_SURFACE_ALLOC           0x41465253  // 'SRFA'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SURFACE_ALLOC
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
    DWORD dwSize;                   // size of surface (in bytes)
    DWORD dwAlignment;              // alignment (if known, 0 - let interpreter infer from CTXDMA)
    DWORD dwType;                   // CAPTURE_SURFACE_TYPE_xxx
    DWORD dwKind;                   // usage hint - CAPTURE_SURFACE_KIND_xxx
    DWORD dwSurfaceType;            // CAPTURE_SURFACE_FORMAT_xxx
    DWORD dwIntendedPitch;          // pitch we think we will apply on this surface
    DWORD dwIntendedHeight;         // height we think we will apply on this surface
} CAPTURE_SURFACE_ALLOC;

//
// SURFACE_FREE
//
#define CAPTURE_XID_SURFACE_FREE            0x46465253  // 'SRFF'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SURFACE_FREE
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
} CAPTURE_SURFACE_FREE;

//
// MEMORY_WRITE
//
#define CAPTURE_XID_MEMORY_WRITE            0x574d454d  // 'MEMW'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_MEMORY_WRITE
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
    DWORD dwSize;                   // number of bytes (multiple of 4)
    // [ data goes here ]
} CAPTURE_MEMORY_WRITE;

//
// SYNC - obsoleted in schema 3
//
#define CAPTURE_XID_SYNC                    0x434e5953  // 'SYNC'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SYNC
    DWORD dwCtxDMAHandle;           //                  [ if special, undefined                              ]
    DWORD dwOffset;                 // offset in CTXDMA [ special case when dwOffset == CAPTURE_SYNC_SPECIAL ]
    DWORD dwValue;                  // value to match   [ if special, one of CAPTURE_SYNC_WAIT_xxx           ]
} CAPTURE_SYNC;

//
// SYNC3
//
#define CAPTURE_XID_SYNC3                   0x334e5953  // 'SYN3'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SYNC3
    DWORD dwType;                   // CAPTURE_SYNC3_TYPE_xxx
    DWORD dwCtxDMAHandle;           // valid for type semaphore, else irrelevant
    DWORD dwOffset;                 // offset in CTXDMA, valid for type semaphore, else irrelevant
    DWORD dwValue;                  // value to match
} CAPTURE_SYNC3;

//
// OBJECT_CREATE
//
#define CAPTURE_XID_OBJECT_CREATE           0x5243424f  // 'OBCR'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_OBJECT_CREATE
    DWORD dwClassID;                // actual class this handle maps to
    DWORD dwHandle;                 // handle of the class
} CAPTURE_OBJECT_CREATE;

//
// OBJECT_FREE
//
#define CAPTURE_XID_OBJECT_FREE             0x5246424f  // 'OBFR'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_OBJECT_FREE
    DWORD dwHandle;                 // you figure it out, Tex
} CAPTURE_OBJECT_FREE;

//
// SCENE
//
#define CAPTURE_XID_SCENE                   0x454e4353  // 'SCNE'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SCENE
} CAPTURE_SCENE;

//
// LOCK / UNLOCK
//
#define CAPTURE_XID_LOCK                    0x4b434f4c  // 'LOCK'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_LOCK
    DWORD dwType;                   // CAPTURE_LOCK_TYPE_xxx
    DWORD dwCtxDMAHandle;
    DWORD dwOffset;
} CAPTURE_LOCK;

//
// ANNOTATION
//
#define CAPTURE_XID_ANNOTATION              0x4f4e4e41  // 'ANNO'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_ANNOTATION
    DWORD dwValue;                  // CAPTURE_ANNOTATION_xxx
} CAPTURE_ANNOTATION;


//////////////////////////////////////////////////////////////////////////////
// procedures
//
int captureStartup   (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int captureShutdown  (void);
int captureSetParams (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int captureLog       (void *pBuffer, unsigned uCount);
int captureFileInc   (void);

int capturePlayStartup   (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int capturePlayShutdown  (void);
int capturePlaySetParams (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int capturePlay          (void *pRenderTarget, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight);
int capturePlayFileInc   (void);

#pragma pack(pop)
#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvMultiMon.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvMultiMon_h
#define _nvMultiMon_h

//
// This file contains constants shared between the display and miniport drivers for NT40 and Win2K.
// These are used for the MultiMon modes for NV11 dual head cards.
// This file also contains the TwinView definitions (previously in win9x\inc\escape.h) used by Win9x driver and 
// the NT40/Win2K drivers.
//

#ifdef __cplusplus
extern "C"
{
#endif

// maximum number of heads this driver supports
#define NV_MAX_HEADS   2

// Uncomment this line to enable the new API for assigning devices to heads.
// #define ENABLE_HEAD_API
// Some special bitmask definitions for the new head API of resman.
#define BITMASK_CRT0    0x1
#define BITMASK_INVALID_DEVICE 0x0
#define BITMASK_ALL_CRT 0xff
#define BITMASK_ALL_TV 0xff00
#define BITMASK_ALL_DFP 0xff0000

    
//
// The table entries were taken from the GTF table in the miniport in vesadata.c
// Returns true if the resolution specified by (modeWidth, modeHeight) is a horizontally doubled resolution.
//
#define HORIZONTAL_MODE(modeWidth, modeHeight) \
        (\
            (modeWidth == 2048 * 2 && modeHeight == 1536 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1440 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1200 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1080 * 1) ||\
            (modeWidth == 1856 * 2 && modeHeight == 1392 * 1) ||\
            (modeWidth == 1800 * 2 && modeHeight == 1440 * 1) ||\
            (modeWidth == 1792 * 2 && modeHeight == 1344 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1200 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1024 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 900 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 880 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 1024 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 960 * 1) ||\
            (modeWidth == 1152 * 2 && modeHeight == 864 * 1) ||\
            (modeWidth == 1024 * 2 && modeHeight == 768 * 1) ||\
            (modeWidth == 960 * 2 && modeHeight == 720 * 1) ||\
            (modeWidth == 864 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 856 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 852 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 848 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 800 * 2 && modeHeight == 600 * 1) ||\
            (modeWidth == 720 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 640 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 640 * 2 && modeHeight == 400 * 1) ||\
            (modeWidth == 512 * 2 && modeHeight == 384 * 1) ||\
            (modeWidth == 480 * 2 && modeHeight == 360 * 1) ||\
            (modeWidth == 400 * 2 && modeHeight == 300 * 1) ||\
            (modeWidth == 320 * 2 && modeHeight == 240 * 1) ||\
            (modeWidth == 320 * 2 && modeHeight == 200 * 1)\
        )

//
// The table entries were taken from the GTF table in the miniport in vesata.c
// Returns true if the resolution specified by (modeWidth, modeHeight) is a vertically doubled resolution.
//
#define VERTICAL_MODE(modeWidth, modeHeight) \
        (\
            (modeWidth == 2048 * 1 && modeHeight == 1536 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1440 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1200 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1080 * 2) ||\
            (modeWidth == 1856 * 1 && modeHeight == 1392 * 2) ||\
            (modeWidth == 1800 * 1 && modeHeight == 1440 * 2) ||\
            (modeWidth == 1792 * 1 && modeHeight == 1344 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1200 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1024 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 900 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 880 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 1024 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 960 * 2) ||\
            (modeWidth == 1152 * 1 && modeHeight == 864 * 2) ||\
            (modeWidth == 1024 * 1 && modeHeight == 768 * 2) ||\
            (modeWidth == 960 * 1 && modeHeight == 720 * 2) ||\
            (modeWidth == 864 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 856 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 852 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 848 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 800 * 1 && modeHeight == 600 * 2) ||\
            (modeWidth == 720 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 640 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 640 * 1 && modeHeight == 400 * 2) ||\
            (modeWidth == 512 * 1 && modeHeight == 384 * 2) ||\
            (modeWidth == 480 * 1 && modeHeight == 360 * 2) ||\
            (modeWidth == 400 * 1 && modeHeight == 300 * 2) ||\
            (modeWidth == 320 * 1 && modeHeight == 240 * 2) ||\
            (modeWidth == 320 * 1 && modeHeight == 200 * 2)\
        )

//
// Returns TRUE if the mode is a dual screen multi mon mode. It can beeither horizontal or vertical.
//
#define MULTIMON_MODE(modeWidth, modeHeight)\
        (HORIZONTAL_MODE(modeWidth, modeHeight) || VERTICAL_MODE(modeWidth, modeHeight))

//
// Fills in a nvRECTL structure (which is the same structure as RECTL).
//
#define SET_RECT(nvRECTLPtr, leftVal, topVal, rightVal, bottomVal)\
{\
    (nvRECTLPtr)->left = (leftVal);\
    (nvRECTLPtr)->top =  (topVal);\
    (nvRECTLPtr)->right =  (rightVal);\
    (nvRECTLPtr)->bottom =  (bottomVal);\
}



//******************************************************************************
// Bitmask flag for support desktop
// NOTE: These definitions must match those in the NV miniport's 'NV.h'!
//******************************************************************************
//
// 31            24 23           16                               0
// .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-.
// |  Secondary        Primary             Master Flag             |
// `-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-'
//
// Master Flag            : bit 0 - bit 15
// Primary Display Flag   : bit 16 - bit 23
// Secondary Display Flag : bit 24 - bit 31
//
//******************************************************************************
#define NV_VIRTUAL_DESKTOP_1        0x00010000
#define NV_VIRTUAL_DESKTOP_2        0x01000000

// NV_SPANNING_MODE is virtual desktop (cxScreen, cyScreen) enabled.
// ie, ppdev->ulMode to mode table resolution does not match to (cxScreen, cyScreen)
// additional information for set mode is passed from IOCTL_VIDEO_SET_DESKTOP_INFO_MODE 
// to miniport driver.

#define NV_TWO_DACS                 0x01
#define NV_CLONE_DESKTOP            0x02
#define NV_SPANNING_MODE            0x04
#define NV_ENABLE_CLASS_SET_MODE    0x08

#define NV_ENABLE_VIRTUAL_DESKTOP   (NV_VIRTUAL_DESKTOP_1 | NV_VIRTUAL_DESKTOP_2)
//
// Values for the ppdev->ulDACStatus[NV_NO_DACS]
//
#define DAC_STATUS_ON_BOARD      1   // The DAC is onboard.
#define DAC_STATUS_CONNECTED    2   // The DAC is connected to a device (CRT/DFP/TV).
#define DAC_STATUS_ACTIVE       4   // The DAC is active. For example, in spanning mode and clone mode, both dacs are active.
                                    // In normal mode, only one head is active.



//*****************************************************************************
//
// NV11 TwiNView definitions for controlling dual CRTC functionality
// (previously in Win9x\inc\escape.h).
//
typedef struct  _nvRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
}   nvRECTL;
#define NV_NO_DACS  2

//
// The device scan bit flags. Used in Win2K/NT4.0 only.
// These are used for the "ulHeadDeviceOptions" field in the GET_DEVICE_SCAN_DATA escape call.
//
#define HEAD_DEVICE_OPTION_CRT 0x1
#define HEAD_DEVICE_OPTION_DFP 0x2
#define HEAD_DEVICE_OPTION_TV  0x4

//
// This indicates that nothing is connected on this head
//
#define INVALID_DEVICE_TYPE 0x9999

// - Added escapes for the control panel to Get the deviceOptions matrix and to initiate the device scan. And
// - to set the timing mode override.
// - This is for TwinView for Win2K/NT4.0 only.
#define NV_ESC_GET_DEVICE_SCAN_DATA                 0x6992
#define NV_ESC_INDUCE_DEVICE_SCAN                   0x6993

typedef struct _GET_DEVICE_SCAN_DATA_TYPE {
    unsigned long ulNumberDacsOnBoard;
    unsigned long ulNumberDacsConnected;
    unsigned long ulNumberDacsActive;
    unsigned long ulHeadDeviceOptions[NV_NO_DACS];
} GET_DEVICE_SCAN_DATA_TYPE;




// use these values for the "dwFlag" member of NVTWINVIEWDATA
#define NVTWINVIEW_FLAG_GET                      0
#define NVTWINVIEW_FLAG_SET                      1
// use these values for the "dwAction" member of NVTWINVIEWDATA
#define NVTWINVIEW_ACTION_SETGET_STATE           1
#define NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE     2
#define NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP  3
#define NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN   4
#define NVTWINVIEW_ACTION_SETGET_PRIMARY_CRTC    5
#define NVTWINVIEW_ACTION_SETGET_VIRTUAL_MODE    6
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE   7

// The following actions are applicable only for NT40 and Win2K. Win9X can ignore this.
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODELIST   8
#define NVTWINVIEW_ACTION_SETGET_GDI_MODELIST    9
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODE     11

#define NVTWINVIEW_ACTION_VALIDATE_VIRTUAL_MODE  20
#define NVTWINVIEW_ACTION_VALIDATE_PHYSICAL_MODE 21
#define NVTWINVIEW_ACTION_SETGET_TIMING_OVERRIDE 22

// These escapes are to support DVD ZOOM under Win9X. (and maybe NT?)
#define NVTWINVIEW_ACTION_LOCK_HWCRTC                       30
#define NVTWINVIEW_ACTION_UNLOCK_HWCRTC                     31
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE    32

// The following is for Win9X. Win2K/NT4.0 can ignore this.
#define NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD   40

#define NVTWINVIEW_ACTION_SETGET_CLONE_GAMMA    41

// use these values for the "dwState" member of NVTWINVIEWDATA
#define NVTWINVIEW_STATE_NORMAL                  0
#define NVTWINVIEW_STATE_MULTIMON                1
#define NVTWINVIEW_STATE_CLONE                   2

// When the NVTWINVIEW_ACTION_SETGET_STATE escape is issued,
// a return of the following values in dwSuccess of NVTINWVIEWDATA
// indicates what is needed to make the state change happen.
#define NVTWINVIEW_STATE_CHANGE_FAILED          0
#define NVTWINVIEW_STATE_CHANGE_DONE            1
#define NVTWINVIEW_STATE_CHANGE_NEEDS_REBOOT    2

// use these values for the "dwAutoPan" member of NVTWINVIEW_AUTOPAN_DATA
#define NVTWINVIEW_VIRTUALDESKTOP_OFF            0
#define NVTWINVIEW_VIRTUALDESKTOP_ON             1

// use these values for the "dwState" member of NVTWINVIEWDATA
#define NVTWINVIEW_STATE_AUTO                    0
#define NVTWINVIEW_STATE_DMT                     1
#define NVTWINVIEW_STATE_GTF                     2

// use these values for the "ulTimingOverRide" field of NVTWINVIEW_DEVICE_TYPE_DATA. Used only in Win2K and NT4.0
#define TIMING_OVERRIDE_AUTO                    0
#define TIMING_OVERRIDE_DMT                     1
#define TIMING_OVERRIDE_GTF                     2

typedef struct {
unsigned long dwDeviceMask;        // A unique bitmask in a 32 bit Dword identifying
                                    // this specific output device. (as defined in NVCM.H)

   unsigned long dwDeviceType;      // Monitor, DFP, TV (as defined in NVCM.H)
   unsigned long dwTVFormat;        // Format for TV    (as defined in NVCM.H)
   unsigned long dwXRes;            // Horizontal resolution of secondary device in clone mode (in pixels). Used only by Win9X.
   unsigned long dwYRes;            // Vertical resolution of secondary device in clone mode (in Pixels). Used only by Win9X.
   unsigned long dwBpp;             // For Win9X: color depth of secondary device in clone mode (in Bits per pixel)
                                    // For Win2K/NT40: color depth of this head. The color depths of both heads will be the same.
   unsigned long dwRefresh;         // For Win9X: refresh rate of secondary device in clone mode (actual rate in Hz or 1 for "optimal" or 0 for "default")
                                    // For Win2K/NT40: refresh rate of this head (actual rate in Hz or 1 for "optimal" or 0 for "default"), the
                                    // refresh rates can be different for each head.

   // The following fields are applicable only for NT40 and Win2K. Win9X can ignore this.
   unsigned long dwNumPhysModes;    // The number of physical modes supported by the device. This list is obtained after
                                    // an intersection of EDID and the registry modes. If the device has no EDID, then this
                                    // list simply equals the registry modelist.
   unsigned long dwNumVirtualModes; // The number of virtual modes supported by the device. This list is obtained after
                                    // an intersection of registry modes and the board frame buffer size. 
   nvRECTL    PhysicalRectl;        // Physical coordinates of the device.
   nvRECTL    VirtualRectl;         // Virtual coordinates of the device.
   unsigned long dwEnableDDC; 
   unsigned long dwEnablePanScan;   // Enables the virtual desktop to let the physical resolution
                                    // to be less than the virtual resolution.
   unsigned long dwFreezePanScan;   // Freeze the pan-scan
   unsigned long dwFreezeOriginX;   // The user specified upper left corner for freezing the pan-scan.
   unsigned long dwFreezeOriginY;   // The user specified upper left corner for freezing the pan-scan.
   unsigned long dwTimingOverRide;  // GTF or DMT preference by the user.


} NVTWINVIEW_DEVICE_TYPE_DATA;

typedef struct {
   unsigned long dwVirtualDesktop;  // Virtual Desktop On/Off (clone mode only)
   unsigned long dwPad;
}  NVTWINVIEW_VIRTUALDESKTOP_DATA;

typedef struct {
   unsigned long dwFreezeOrigin;    // Freeze Origin On/Off (clone mode only)
   unsigned long dwOriginX;         // freeze mode x origin (clone mode only)
   unsigned long dwOriginY;         // freeze mode y origin (clone mode only)
}  NVTWINVIEW_FREEZE_ORIGIN_DATA;

typedef struct {
   unsigned long pHWCrtcCX;
   unsigned long pGNLogdevCX;
   unsigned long dwLogicalCrtcIndex;
   unsigned long dwPad;
}  NVTWINVIEW_LOCK_UNLOCK_HWCRTC_DATA;

typedef struct {
   unsigned long pHWCrtcCX;
   unsigned long pGNLogdevCX;
   unsigned long dwLogicalCrtcIndex;
   unsigned long dwPad;
}  NVTWINVIEW_SETGET_PHYSICAL_MODE_IMMEDIATE;




// The mode_entry structure is copied from miniport\nv_mini\nv.h. Anychanges in one file should be reflected
// in the other.
struct Mode_Entry
   {
   unsigned short  ValidMode;
   unsigned short  Width;
   unsigned short  Height;
   unsigned short  Depth;
   unsigned short  RefreshRate;
#ifndef WINNT
   unsigned short  wPad;
   unsigned long   dwPad;
#endif
   };
typedef struct Mode_Entry *PMODE_ENTRY, MODE_ENTRY;

// This is per head information
typedef struct {
   MODE_ENTRY * PhysModeEntries;         // Pointer to alloced memory for the physical mode list.
   unsigned long dwNumPhysModeEntries;   // The number of mode entries in the alloced memory for the physical mode list.
   MODE_ENTRY * VirtualModeEntries;         // Pointer to alloced memory for the physical mode list.
   unsigned long dwNumVirtualModeEntries;   // The number of mode entries in the alloced memory for the physical mode list.

   unsigned long dwDeviceMask;  // Return the modelist info for this deviceMask

   unsigned long dwDeviceType;  // Return the modelist info for this deviceType on this head
   unsigned long dwTVFormat;    // Return the modelist info for this TV format on this head
}  NVTWINVIEW_MODELIST_DATA;

// Values for the dwOrientation field
#define HORIZONTAL_ORIENTATION  1
#define VERTICAL_ORIENTATION    2


typedef struct {
   unsigned long dwFlag;            // flag indicating GET or SET
   unsigned long dwAction;          // indicates action to be performed
   unsigned long dwState;           // normal, multi-mon, clone
   unsigned long dwCrtc;            // indicates CRT number for which action is performed. Used only by Win9X.
                                    // The actions apply to all the heads in Win2K and NT40.
   unsigned long dwSuccess;         // indicates success of call. Driver should return non-zero in this member
                                    // if the escape is successfully handled, or zero for failure
   nvRECTL    DeskTopRectl;           // The overall desktop rectangle. The (left,top) is always (0, 0).
                                    // Applicable only for Win2K and NT40. Win9X can ignore it.
   unsigned long dwBoard;           // The board number in a multi-adapter system.
                                    // Applicable only for NT40. Win9X and Win2K can ignore it.
   unsigned long dwOrientation;     // Horizontal or vertical. For multi-mon mode only.
                                    // Applicable only for NT4.0 and Win2K. Win9x can ignore this.
   unsigned long dwDeviceDisplay[NV_NO_DACS]; // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
                                    // Applicable only for NT4.0 and Win2K. Win9x can ignore this.

   unsigned long dwAllDeviceMask;  // Bitmask for all the output device connectors in the board. NT4.0/Win2K only.
   unsigned long dwConnectedDeviceMask;  // Bitmask for all the output device connectors in the board. NT4.0/Win2K only.
                                    


   union {
       NVTWINVIEW_DEVICE_TYPE_DATA nvtwdevdata[NV_NO_DACS]; // use with action NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE and NVTWINVIEW_ACTION_SETGET_STATE (if
                                    // dwState == NVTWINVIEW_STATE_CLONE)

       NVTWINVIEW_VIRTUALDESKTOP_DATA    nvtwvirtualdesktopdata;  // use with action NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP

       NVTWINVIEW_FREEZE_ORIGIN_DATA nvtwfreezedata; // use with action NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN
                                      // Note: union is ignored for  and NVTWINVIEW_ACTION_SETGET_PRIMARY_CRTC and
                                      // NVTWINVIEW_ACTION_SETGET_STATE (if dwState != NVTWINVIEW_STATE_CLONE)

       NVTWINVIEW_MODELIST_DATA   nvtwModeListData[NV_NO_DACS]; // Applicable only for Win2K and NT40. Win9X can ignore it.
                                                    // Use with actions NVTWINVIEW_ACTION_SETGET_PHYS_MODELIST and
                                                    // NVTWINVIEW_ACTION_SETGET_GDI_MODELIST.
#ifndef WINNT
        unsigned long adwGammaTable[256];
#endif
   } NVTWINVIEWUNION;

   NVTWINVIEW_LOCK_UNLOCK_HWCRTC_DATA nvtwLockUnlockHwcrtc;
   NVTWINVIEW_SETGET_PHYSICAL_MODE_IMMEDIATE nvtwPhysicalModeImmediate;
} NVTWINVIEWDATA;


#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvOverlaySurf.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifndef _NVOVERLAYSURF_H_
#define _NVOVERLAYSURF_H_

#ifdef DEBUG
#define NV_DBG_SHOW_FOURCC()                                                    \
    char fourCCStr[5];                                                          \
    fourCCStr[0] = (char)pSurf->lpGbl->ddpfSurface.dwFourCC & 0xFF;             \
    fourCCStr[1] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 8) & 0xFF;      \
    fourCCStr[2] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 16) & 0xFF;     \
    fourCCStr[3] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 24) & 0xFF;     \
    fourCCStr[4] = 0;                                                           \
    DPF_LEVEL(NVDBG_LEVEL_SURFACE,                                              \
        "FOURCC %s allocation: size=%u bytes", &fourCCStr, dwBlockSize );
#else // NOT DEBUG
#define NV_DBG_SHOW_FOURCC()
#endif // DEBUG

// external functions

extern DWORD VppCreateFourCCSurface(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight);
extern void VppCalcExtraSurfaceSpace(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, DWORD dwRequestedSurfaces, DWORD *dwExtraSize, DWORD *dwExtraNumSurfaces, DWORD *dwBlockHeight);
#endif // _DDSURF4CC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvPixelFmt.h ===
#ifndef __gl_nvPixelFmt_h_
#define __gl_nvPixelFmt_h_

/*
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

int STDCALL __wglNVDescribePixelFormat(int bpp, int iPixelFormat, UINT nBytes,
                                       PIXELFORMATDESCRIPTOR *ppfd,
                                       int flags);

#define NUM_PIXELFORMATS_16 6
#define NUM_PIXELFORMATS_16_OVERLAY 12
#define NUM_PIXELFORMATS_32 10
#define NUM_PIXELFORMATS_32_OVERLAY 20
#define NUM_NV11_PIXELFORMATS_32 15

extern PIXELFORMATDESCRIPTOR *NV4PixelFormats16[NUM_PIXELFORMATS_16];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32[NUM_PIXELFORMATS_32];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32Overlay[NUM_PIXELFORMATS_32_OVERLAY];
extern PIXELFORMATDESCRIPTOR *NV11PixelFormats32[NUM_NV11_PIXELFORMATS_32];

#define NV_PFD_SUPPORTS_COLOR32_DEPTH16 0x00000001 /* nv11 */
#define NV_PFD_SUPPORTS_COLOR16_DEPTH32 0x00000002 /* hopefully, some day */
#define NV_PFD_SUPPORTS_OVERLAYS        0x00000004
#define NV_PFD_SUPPORTS_SWAPCOPYONLY    0x00000008

#endif  /* __gl_nvPixelFmt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvPM.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvPM_h
#define _nvPM_h

#ifdef __cplusplus
extern "C"
{
#endif

/*
 * constants
 */

// registry related
#define PM_REGISTRY_SUBKEY          "PerformanceMonitor"

#define PM_REG_LOGFILENAME          "logFileName"
#define PM_REG_CONNECTCOUNT         "connectCount"
#define PM_REG_PMTRIGGER            "trigger"
#define PM_REG_TRIGGERCOUNT         "triggerCount"
#define PM_REG_PROGRAM_SETUP        "programSetup"
#define PM_REG_PROGRAM_START        "programStart"
#define PM_REG_PROGRAM_SAMPLE       "programSample"

#define PM_REG_PMTRIGGER_DISABLED   0                   // disabled
#define PM_REG_PMTRIGGER_ENDSCENE   1                   // emit trigger at end of frame
#define PM_REG_PMTRIGGER_1MS        2                   // emit trigger at 1ms intervals (not exact)
#define PM_REG_PMTRIGGER_RESV00     3
#define PM_REG_PMTRIGGER_CUSTOM0    4
#define PM_REG_PMTRIGGER_CUSTOM1    5
#define PM_REG_PMTRIGGER_CUSTOM2    6
#define PM_REG_PMTRIGGER_CUSTOM3    7
#define PM_REG_PMTRIGGER_MAX        7

#define PM_LOG_ID                   "events \0"
#define PM_PGM_ID                   "program\0"

#define PM_LOG_VERSION              0x00000001
#define PM_PGM_VERSION              0x00000001

#define PM_PGM_MASK_SIZE            0x0000000f
#define PM_PGM_VAL_SIZE_8               0x00000000
#define PM_PGM_VAL_SIZE_16              0x00000001
#define PM_PGM_VAL_SIZE_32              0x00000002
#define PM_PGM_VAL_SIZE_40              0x00000003
#define PM_PGM_FLAG_READ            0x80000000

#define PM_LOG_EVENT_BUFFER_SIZE    (65536 / 8)

/*
 * macros
 */
#define PM_SIGNAL(match)            if (g_dwPMTrigger == (match)) { if (!(--g_dwPMTriggerValue)) { pmSignal(); g_dwPMTriggerValue = g_dwPMTriggerCount; } }

/*
 * structures
 */
#pragma pack(push,1)

//////
// log event
typedef struct
{
    DWORD dwValueLo;
    DWORD dwValueHi;
} PM_LOG_EVENT;

// log header
typedef struct
{
    char         szID[8];
    DWORD        dwVersion;
    PM_LOG_EVENT Event[1];
} PM_LOG_HEADER;

//////
// program entry
typedef struct
{
    DWORD dwFlags;
    DWORD dwOffset;
    DWORD dwValueLo;
    DWORD dwValueHi;
} PM_PGM_ENTRY;

// program header
typedef struct
{
    char         szID[8];
    DWORD        dwVersion;
    DWORD        dwEntryCount;
    PM_PGM_ENTRY Entry[1];
} PM_PGM_HEADER;

#pragma pack(pop)

/*
 * exported globals
 */
extern DWORD g_dwPMTrigger;
extern DWORD g_dwPMTriggerCount;
extern DWORD g_dwPMTriggerValue;

/*
 * public functions
 */
BOOL pmConnect    (HDC hEscapeDC,DWORD dwHWLinearBase,DWORD dwArch);    // arch: nv4 -> 0x04, nv10 -> 0x10
BOOL pmDisconnect (void);
BOOL pmSignal     (void);

#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvPriv.h ===
#ifndef _DDPRIV_
#define _DDPRIV_

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       nvPriv.h
 *  Content:    header for nvPriv.cpp
 *
 ***************************************************************************/

typedef struct _MYDCICMD
{
	ULONG	dwCommand;
	ULONG	dwParam1;
	ULONG 	dwParam2;
	ULONG	dwVersion;
	ULONG	dwReserved;
} MYDCICMD;

typedef struct _MYDD32BITDRIVERDATA
{
    UCHAR   szName[260];            // 32-bit driver name
    UCHAR   szEntryPoint[64];       // entry point
    ULONG   dwContext;              // context to pass to entry point
} MYDD32BITDRIVERDATA;

#define DD_VERSION              0x00000200l
#define DDCREATEDRIVEROBJECT    10
#define DDGET32BITDRIVERNAME    11
#define DDNEWCALLBACKFNS        12
#define DDVERSIONINFO           13
#define DDDESTROYDRIVEROBJECT   99

#define MAX_ADAPTERS            9

#ifdef WINNT
#ifndef NV_ESC_DDPRIV_DMABLIT
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88
#endif

#ifndef NV_ESC_DDPRIV_OVERLAYCONTROL
// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89
#endif
#endif // WINNT

// --------------------------------------------------------------------------
// nvOverlayControl
//      Overlay control callback
//
// Command Structure
// -----------------
// NVOCCMD_GETCAPS
//      dwSize
//      dwDevice
//      returns caps
//          dwCaps1
//              NVOCCAPS1_BRIGHTNESS
//              NVOCCAPS1_CONTRAST
//              NVOCCAPS1_HUE
//              NVOCCAPS1_SATURATION
//              NVOCCAPS1_SHARPNESS
//              NVOCCAPS1_GAMMA
//          dwCaps2
//              NVOCCAPS2_HQVUPSCALE
//              NVOCCAPS2_TFILTER
//              NVOCCAPS2_DFILTER
//              NVOCCAPS2_FSMIRROR
//              NVOCCAPS2_OVLZOOM
//          dwCaps3
//              NVOCCAPS3_SUBPICTURE
//              NVOCCAPS3_LATEFLIPSYNC
//              NVOCCAPS3_SPLITVPP
//              NVOCCAPS3_BLTCAPS
//          dwCaps4
//              NVOCCAPS4_SMA
//              NVOCCAPS4_IMB
//              NVOCCAPS4_DEVICEHASOVL
//              NVOCCAPS4_MULTIHEADNUM (number of display heads on this device)
//              NVOCCAPS4_MULTIHEADMODE (0 = single, 1 = span, 2 = clone)
//              NVOCCAPS4_HEAD0_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//              NVOCCAPS4_HEAD1_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//          dwCaps5
//              NVOCCAPS5_BLT_YUV9_2_YUV422
//              NVOCCAPS5_BLT_YUV12_2_YUV422
//              NVOCCAPS5_BLT_YC12_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_RGB8
//              NVOCCAPS5_BLT_YUV422_2_RGB15
//              NVOCCAPS5_BLT_YUV422_2_RGB16
//              NVOCCAPS5_BLT_YUV422_2_RGB32
//              NVOCCAPS5_BLT_SYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2SYUV
//              NVOCCAPS5_BLT_SYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2SRGB
//              NVOCCAPS5_BLT_SRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2SRGB
//              NVOCCAPS5_BLT_2RGBTEX
// NVOCCMD_SETCOLORCONTROL
//      dwSize
//      dwDevice
//      ccData
//          dwEnable (ignored for NV10 and above, always enabled)
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  lBrightness (range is -256 to +255)
//              NVOCCC_CONTRAST
//                  lContrast (range is 0 to 200)
//              NVOCCC_HUE
//                  lHue (range is 0 to 360)
//              NVOCCC_SATURATION
//                  lSaturation (range is 0 to 200)
// NVOCCMD_GETCOLORCONTROL
//      dwSize
//      dwDevice
//      returns ccData
//          returns dwEnable
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          returns dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  returns lBrightness
//              NVOCCC_CONTRAST
//                  returns lContrast
//              NVOCCC_HUE
//                  returns lHue
//              NVOCCC_SATURATION
//                  returns lSaturation
// NVOCCMD_SETFEATURE (enables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE (always enable if enough memory (8M))
//          NVOCF1_TFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[0] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_TF_PRECOPY
//          NVOCF1_DFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[1] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_DF_PRECOPY
//          NVOCF1_FSMIRROR (only enable with dual head and large memory)
//              lCoefficient[4]:
//                  bits 0-3: head number
//                            0 = disable FSVM
//                            1 = display 1
//                            2 = display 2
//                            15 = autoselect display
//                  bits 4-7: aspect ratio
//                            0 = stretch to display full screen
//                            1 = preserve aspect of source (assume square pixels)
//                            3 = force anamorphic 16:9
//                            5 = track overlay aspect
//                            9 = force TV 4:3
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-19: zoom factor, 0 = 1x, 255 = 2x
//                  bit 20: 0 = use current display size
//                          1 = let driver pick the display size
//                  bit 21: 0 = independent FS and overlay zoom
//                          1 = FS zoom tracks overlay zoom controls
//                  bit 22: 0 = disable DVD output to TV
//                          1 = enable DVD output to TV
//          NVOCF1_OVLZOOM
//              lCoefficient[5]:
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-23: zoom factor, 0 = 1x, 255 = 2x
//          NVOCF1_DELIVERYCONTROL
//              lCoefficient[6]: low 32 bits of frame period (in ns)
//              lCoefficient[7]: high 32 bits of frame period (in ns)
//          NVOCF1_LATEFLIPSYNC
//      dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = set to 0, 2, 3, 4, or 6
//              lCoefficient[3] = reserved
// NVOCCMD_RESETFEATURE (disables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//          NVOCF1_DFILTER
//          NVOCF1_FSMIRROR
//          NVOCF1_OVLZOOM
//          NVOCF1_DELIVERYCONTROL
//          NVOCF1_LATEFLIPSYNC
// NVOCCMD_GETFEATURE
//      dwSize
//      dwDevice
//      returns dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//              returns lCoefficient[0]
//          NVOCF1_DFILTER
//              returns lCoefficient[1]
//          NVOCF1_FSMIRROR
//              returns lCoefficient[4]
//          NVOCF1_OVLZOOM
//              returns lCoefficient[5]
//          NVOCF1_DELIVERYCONTROL
//              returns lCoefficient[6]
//                      lCoefficient[7]
//          NVOCF1_LATEFLIPSYNC
//      returns dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = max VPP work surfaces
//              lCoefficient[3] = VPP work surfaces currently allocated
//

#define OVERLAYCONTROLCALLBACK "nvOverlayControl"

typedef enum { 
    NVOCERR_OK              = 0,
    NVOCERR_GENERIC_WARN    = 1,
    NVOCERR_GENERIC_FATAL   = 0x80000001,
    NVOCERR_BAD_COMMAND     = 0x80000002,
    NVOCERR_INVALID_PARMS   = 0x80000003,
    NVOCERR_ALREADY_ACTIVE  = 0x80000004,
    NVOCERR_NOT_SUPPORTED   = 5,
    NVOCERR_BAD_DEVICE      = 0x80000006
} NVOCERROR;

typedef enum {
    NVOCCMD_NOOP            = 0,
    NVOCCMD_GETCAPS         = 1,
    NVOCCMD_SETCOLORCONTROL = 2,
    NVOCCMD_GETCOLORCONTROL = 3,
    NVOCCMD_SETFEATURE      = 4,
    NVOCCMD_RESETFEATURE    = 5,
    NVOCCMD_GETFEATURE      = 6
} NVOCCOMMAND;

typedef struct {
    unsigned long   dwCCFlags;
    unsigned long   dwEnable;
    long            lBrightness;
    long            lContrast;
    long            lHue;
    long            lSaturation;
    long            lSharpness;
    long            lGamma;
} NVOCCCDATA, *LPNVOCCCDATA;

#define NVOCCC_BRIGHTNESS   0x1
#define NVOCCC_CONTRAST     0x2
#define NVOCCC_HUE          0x4
#define NVOCCC_SATURATION   0x8
#define NVOCCC_SHARPNESS    0x10
#define NVOCCC_GAMMA        0x20

typedef struct {
    unsigned long dwCaps1;
    unsigned long dwCaps2;
    unsigned long dwCaps3;
    unsigned long dwCaps4;
    unsigned long dwCaps5;
} NVOCCAPS, *LPNVOCCAPS;

#define NVOCCAPS1_BRIGHTNESS    0x1
#define NVOCCAPS1_CONTRAST      0x2
#define NVOCCAPS1_HUE           0x4
#define NVOCCAPS1_SATURATION    0x8
#define NVOCCAPS1_SHARPNESS     0x10
#define NVOCCAPS1_GAMMA         0x20

#define NVOCCAPS2_HQVUPSCALE    0x1
#define NVOCCAPS2_TFILTER       0x2
#define NVOCCAPS2_DFILTER       0x4
#define NVOCCAPS2_FSMIRROR      0x8
#define NVOCCAPS2_OVLZOOM       0x10

#define NVOCCAPS3_SUBPICTURE        0x1
#define NVOCCAPS3_LATEFLIPSYNC      0x2
#define NVOCCAPS3_SPLITVPP          0x4
#define NVOCCAPS3_DELIVERYCONTROL   0x8
#define NVOCCAPS3_BLTCAPS           0x80000000

#define NVOCCAPS4_IMB           0x1
#define NVOCCAPS4_SMA           0x2
#define NVOCCAPS4_DEVICEHASOVL  0x4
#define NVOCCAPS4_MULTIHEADNUM  0x000F0000
#define NVOCCAPS4_MULTIHEADMODE 0x00F00000
#define NVOCCAPS4_HEAD0_TYPE    0x0F000000
#define NVOCCAPS4_HEAD1_TYPE    0xF0000000

#define NVOCCAPS5_BLT_YUV9_2_YUV422     0x00000001
#define NVOCCAPS5_BLT_YUV12_2_YUV422    0x00000002
#define NVOCCAPS5_BLT_YC12_2_YUV422     0x00000004
#define NVOCCAPS5_BLT_YUV422_2_YUV422   0x00000008
#define NVOCCAPS5_BLT_YUV422_2_RGB8     0x00000100
#define NVOCCAPS5_BLT_YUV422_2_RGB15    0x00000200
#define NVOCCAPS5_BLT_YUV422_2_RGB16    0x00000400
#define NVOCCAPS5_BLT_YUV422_2_RGB32    0x00000800
#define NVOCCAPS5_BLT_SYUV2VYUV         0x00010000
#define NVOCCAPS5_BLT_VYUV2VYUV         0x00020000
#define NVOCCAPS5_BLT_VYUV2SYUV         0x00040000
#define NVOCCAPS5_BLT_SYUV2VRGB         0x00100000
#define NVOCCAPS5_BLT_VYUV2VRGB         0x00200000
#define NVOCCAPS5_BLT_VYUV2SRGB         0x00400000
#define NVOCCAPS5_BLT_SRGB2VRGB         0x01000000
#define NVOCCAPS5_BLT_VRGB2VRGB         0x02000000
#define NVOCCAPS5_BLT_VRGB2SRGB         0x04000000
#define NVOCCAPS5_BLT_2RGBTEX           0x80000000

typedef struct {
    unsigned long dwFeature1;
    unsigned long dwFeature2;
    unsigned long dwFeature3;
    unsigned long dwFeature4;
    long          lCoefficient[16];
} NVOCFEATUREDATA;

#define NVOCF1_HQVUPSCALE       0x1
#define NVOCF1_TFILTER          0x2
#define NVOCF1_LATEFLIPSYNC     0x4
#define NVOCF1_DFILTER          0x8
#define NVOCF1_FSMIRROR         0x10
#define NVOCF1_OVLZOOM          0x20
#define NVOCF1_DELIVERYCONTROL  0x40

#define NVOCF2_VPPMAXSURFACES   0x1

#define NVOCF_TF_PRECOPY   0x00000001
#define NVOCF_DF_PRECOPY   0x00000002

typedef struct {
    unsigned long dwSize;
    unsigned long dwDevice;

    // command
    NVOCCOMMAND cmd;
    unsigned long dwCmdFlags;

    // data
    union {
        NVOCCAPS        caps;
        NVOCCCDATA      ccData;
        NVOCFEATUREDATA featureData;
    };

    unsigned long dwReserved[40];
} NVOCDATATYPE, *LPNVOCDATATYPE;

typedef NVOCERROR (__stdcall *NVOVERLAYCONTROL)(LPNVOCDATATYPE data);


// --------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Obsolete.  Only use with rel3 drivers
//      If lpDDCC is NULL, callback returns caps
//
//      dwDevice            always 1
//      lpDDCC->dwSize      sizeof(DDCOLORCONTROL)
//      lpDDCC->dwFlags     DDCOLOR_CONTRAST | DDCOLOR_BRIGHTNESS | DDCOLOR_HUE | DDCOLOR_SATURATION
//                          determines which members hold valid data
//      lpDDCC->lBrightness range is from -256 to +255
//      lpDDCC->lContrast   range is from 0 to 200
//      lpDDCC->lHue        range is from 0 to 360
//      lpDDCC->lSaturation range is from 0 to 200
//      lpDDCC->dwReserved1 0 = disable colour controls
//                          1 = enable with vertical chroma subsampling
//                          2 = enable with full chroma sampling
#define SETOVERLAYCOLORCONTROLCALLBACK "nvSetOverlayColorControl"

typedef DWORD (__stdcall *NVSETOVERLAYCOLORCONTROL)(DWORD dwDevice, LPDDCOLORCONTROL lpDDCC);


// --------------------------------------------------------------------------
// nvMoComp
//      Backdoor DMA blits and formatting for video
// 
// Command Structure
// -----------------
// NVS2VCMD_INIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV:
//              fpSrc
//          NVS2V_UYVY:
//              fpSrc
//          NVS2V_RGB16:
//              fpSrc
//          NVS2V_RGB32:
//              fpSrc
//          NVS2V_YC12
//              SrcYC12.fpY
//          NVS2V_YUV12
//              SrcYUV12.fpY (points to start of surface)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//      dwDstType (required only if using INDEXED type on BLIT)
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
// NVS2VCMD_RELEASE
//      dwSize
//      dwDevice
//      dwIndex
// NVS2VCMD_BLIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET (only use for V->S blits)
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YC12
//              SrcYC12.fpY
//              SrcYC12.fpC
//          NVS2V_YUV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//          NVS2V_YV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//              dwSrcYV12ChromaPitch
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET (only use for S->V blits)
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//      dwDstType
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
//          NVS2V_INDEXED (uses last YUY2 or UYVY state)
//              dwDstSize
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_QUERY_IDLE
//      dwSize
//      dwDevice
// NVS2VCMD_WAIT_FOR_IDLE
//      dwSize
//      dwDevice
//      dwTimeoutTime
// NVS2VCMD_SET_SUBPICTURE
//      dwSize
//      dwDevice
//      dwSPFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_SP_SUBRECT
//              dwSubRectX
//              dwSubRectY
//              dwSubRectWidth
//              dwSubRectHeight
//      dwSPType
//      dwSPPitch
//      fpSP
// NVS2VCMD_VPP_START
//      dwSize
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//      dwSrcPitch
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_VPP_ODD
//          NVS2VF_VPP_EVEN
//          NVS2VF_VPP_BOB
//          NVS2VF_VPP_INTERLEAVED
// NVS2VCMD_VPP_QUERY
//      dwSize
//      dwDevice
// NVS2VCMD_VPP_FLIP
//      dwSize
//      dwDevice
// NVS2VCMD_4CC_TO_VRGB
//      dwSize
//      dwIndex (0xFFFFFFFF means use video memory)
//      dwCmdFlags (optional)
//          NVS2VF_CRTC_SYNC
//              dwHead
//              dwScanline (blit will not begin until CRTC of specified head reaches this scanline)
//              dwTimeoutTime
//          NVS2VF_USE_DELIVERY_CTL
//              dwTimeoutTime
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_UYVY
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//          NVS2VF_SWIZZLED
//      dwDstType
//          NVS2V_RGB16
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//          NVS2V_RGB32
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_GET_TEXTURE_OFFSET
//      dwSize
//      dwDevice
//      fpTexture
//      returns fpTexture


#define MOCOMPCALLBACK "nvMoComp"

typedef enum {
    NVS2V_YC12      = 1,
    NVS2V_YUV12     = 2,
    NVS2V_YUYV      = 3,
    NVS2V_UYVY      = 4,
    NVS2V_DDSURF    = 5,
    NVS2V_INDEXED   = 6,
    NVS2V_YUVA16    = 7,
    NVS2V_YUVA32    = 8,
    NVS2V_YV12      = 9,
    NVS2V_RGB8      = 0x10,
    NVS2V_RGB16     = 0x11,
    NVS2V_RGB24     = 0x12,
    NVS2V_RGB32     = 0x13
} NVS2VSURFTYPE;

typedef enum {
    NVS2VCMD_NOOP               = 0,
    NVS2VCMD_INIT               = 1,
    NVS2VCMD_RELEASE            = 2,
    NVS2VCMD_BLIT               = 3,
    NVS2VCMD_QUERY_IDLE         = 4,
    NVS2VCMD_WAIT_FOR_IDLE      = 5,
    NVS2VCMD_SET_SUBPICTURE     = 6,
    NVS2VCMD_VPP_START          = 7,
    NVS2VCMD_VPP_QUERY          = 8,
    NVS2VCMD_VPP_FLIP           = 9,
    NVS2VCMD_4CC_TO_VRGB        = 0xA,
    NVS2VCMD_GET_TEXTURE_OFFSET = 0xB
} NVS2VCOMMAND;

typedef enum {
    NVS2VERR_OK             = 0,
    NVS2VERR_GENERIC_WARN   = 1,
    NVS2VERR_GENERIC_FATAL  = 0x80000001,
    NVS2VERR_BAD_COMMAND    = 0x80000002,
    NVS2VERR_INVALID_PARMS  = 0x80000003,
    NVS2VERR_INIT_FAILED    = 0x80000004,
    NVS2VERR_NO_EVENT       = 5,
    NVS2VERR_BUSY           = 6,
    NVS2VERR_TIMEOUT        = 7,
    NVS2VERR_BAD_DEVICE     = 0x80000008
} NVS2VERROR;

#define NVS2VF_OFFSET           0x00000001
#define NVS2VF_SP_SUBRECT       0x00000002
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
#define NVS2VF_VPP_ODD          0x00000010
#define NVS2VF_VPP_EVEN         0x00000020
#define NVS2VF_VPP_BOB          0x00000040
#define NVS2VF_VPP_INTERLEAVED  0x00000080
#define NVS2VF_LOCAL            0x00000100
#define NVS2VF_SYSTEM           0x00000200
#define NVS2VF_SWIZZLED         0x00000400
#define NVS2VF_CRTC_SYNC        0x00000800
#define NVS2VF_USE_DELIVERY_CTL 0x00001000

typedef struct {
    unsigned long dwSize;               // sizeof(NVS2VDATATYPE)
    
    // command data
    NVS2VCOMMAND  dwCmd;
    unsigned long dwCmdFlags;
    BOOL          bWaitForCompletion;
    unsigned long dwTimeoutTime;        // in ms
    unsigned long dwIndex;
    unsigned long dwDevice;
    unsigned long dwHead;
    unsigned long dwScanline;
    unsigned long dwReserved1[55];

    // neutral data
    unsigned long dwWidth;              // in pixels
    unsigned long dwHeight;             // in lines

    // source data
    unsigned long dwSrcFlags;
    NVS2VSURFTYPE dwSrcType;
    unsigned long dwSrcPitch;           // in bytes
    union {
        void  *fpTexture;
        void  *fpSrc;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpSrcDirectDrawSurface;  // used with NVS2V_DDSURF (not implemented)
        unsigned long dwSrcSize;        // used with NVS2V_INDEXED (not implemented)
        struct {
            void  *fpY;
            void  *fpC;
        } SrcYC12;                      // used with NVS2V_YC12 (Y and C must be contiguous)
        struct {
            void  *fpY;
            void  *fpU;
            void  *fpV;
        } SrcYUV12;                     // used with NVS2V_YUV12 (not implemented)
    };

    // destination data
    unsigned long dwDstFlags;
    NVS2VSURFTYPE dwDstType;
    unsigned long dwDstPitch;           // in bytes
    union {
        void  *fpDst;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpDstDirectDrawSurface;  // used with NVS2V_DDSURF
        unsigned long dwDstSize;        // used with NVS2V_INDEXED
        struct {
            void *fpY;
            void *fpC;
        } DstYC12;                      // used with NVS2V_YC12 (not implemented)
        struct {
            void *fpY;
            void *fpU;
            void *fpV;
        } DstYUV12;                     // used with NVS2V_YUV12 (not implemented)
        struct {
            void *fpRGB;
            unsigned long dwDstWidth;
            unsigned long dwDstHeight;
        } DstRGB;                       // used with the RGB surface types
    };

    // subpicture data
    unsigned long dwSPFlags;
    NVS2VSURFTYPE dwSPType;
    unsigned long dwSPPitch;
    unsigned long fpSP;
    unsigned long dwSubRectX;
    unsigned long dwSubRectY;
    unsigned long dwSubRectWidth;
    unsigned long dwSubRectHeight;

    // more source data
    unsigned long dwSrcYV12ChromaPitch;
    unsigned long dwSrcPixelBias;

    // pad
    unsigned long dwReserved2[40];
} NVS2VDATATYPE, *LPNVS2VDATATYPE;

typedef NVS2VERROR (__stdcall *NVMOCOMP)(LPNVS2VDATATYPE data);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvPusher.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPusher.h
//      routines for creating, destroying, and interacting with a push buffer
//
// **************************************************************************
//
//  History:
//      Ben DeWaal              07Apr1999         original code
//      Craig Duttweiler        05Apr2000         cleanup, consolidation,
//                                                and C++'ification
//
// **************************************************************************

#ifndef _NVPUSHER_H
#define _NVPUSHER_H

#include "nvUniversal.h"
#include "nv32.h"

// Having lots of problems finding a version of assert.h in all builds... so we do this for now. -mlavoie
#ifdef _DEBUG
#define nvAssert(expr) if (expr) _asm {int 3};
#else
#define nvAssert(expr)
#endif

#if (NVARCH < 0x04)

typedef void CPushBuffer;   // Not avail on NV3, but let's compile go through easier

#else // (NVARCH >= 0x04)

//---------------------------------------------------------------------------

// pusher debugging switches (available in retail builds too)

//#define _PC_PRINTPUT                      // print kick-offs (slow)
//#define _PC_PRINT                         // print important pusher transactions
//#define _PC_CHECK                         // check for push buffer problems
//#define _PC_BREAK                         // break at specific class (define CHECK also)
//#define _PC_FLUSH_ON_ADJUST               // force flush on every call to nvPusherAdjust
//#define _PC_CAPTURE_METHOD_DATA           // captures method data and allows you to view it (good to check object state)
//#define _PC_CAPTURE                       // writes contents of the the push buffer to a file

// debug switch logic

// for now we enable push buffer validation for all debug builds
#if defined(DEBUG) || defined(_PC_CAPTURE_METHOD_DATA) || defined(_PC_CAPTURE)
#define _PC_CHECK
#endif

// don't allow inline functions if we have certain other debug bits enabled
#undef _NO_INLINE
#if defined(DEBUG) || defined(_PC_PRINTPUT) || defined(_PC_PRINT) || defined(_PC_CHECK) || defined(_PC_BREAK)
#define _NO_INLINE
#endif
#if defined(_PC_FLUSH_ON_ADJUST) || defined(_PC_CAPTURE_METHOD_DATA) || defined(_PC_CAPTURE)
#define _NO_INLINE
#endif

//---------------------------------------------------------------------------

// pusher constants and macros

#define NVPUSHER_THRESHOLD_SIZE     128     // words of data always available (4 triangles)
#define NVPUSHER_MINIMUM            1024    // bytes of data for option kick-off

#define NVPUSHER_JUMP(offset)       (0x20000000 | (offset))
#define NVPUSHER_NOINC(method)      (0x40000000 | (method))
#define NVPUSHER_CALL(offset)       (0x00000002 | (offset))
#define NVPUSHER_RETURN()           (0x00020000)

//---------------------------------------------------------------------------

#ifdef _PC_CAPTURE

extern HANDLE hPusherFileBinary;
extern HANDLE hPusherFileAscii;
extern BOOL   bPusherCapture;

#define NV_PC_CAPTURE_BEGIN(filename)                                               \
{                                                                                   \
    char fullname[64];                                                              \
    nvSprintf (fullname, "%s.bin", filename);                                       \
    hPusherFileBinary = CreateFile (fullname,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);    \
    if (hPusherFileBinary == INVALID_HANDLE_VALUE) {                                \
        DPF ("NV_PC_CAPTURE_BEGIN: Binary file open failed");                       \
        nvAssert(0);                                                                  \
    }                                                                               \
    SetFilePointer (hPusherFileBinary, 0,0, FILE_END);                              \
    nvSprintf (fullname, "%s.txt", filename);                                       \
    hPusherFileAscii = CreateFile (fullname,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);     \
    if (hPusherFileAscii == INVALID_HANDLE_VALUE) {                                 \
        DPF ("NV_PC_CAPTURE_BEGIN: Ascii file open failed");                        \
        nvAssert(0);                                                                  \
    }                                                                               \
    SetFilePointer (hPusherFileAscii, 0,0, FILE_END);                               \
    bPusherCapture = TRUE;                                                          \
}

#define NV_PC_CAPTURE_END                                                           \
{                                                                                   \
    if (bPusherCapture) {                                                           \
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);              \
        FlushFileBuffers (hPusherFileBinary);                                       \
        FlushFileBuffers(hPusherFileAscii);                                         \
        CloseHandle (hPusherFileBinary);                                            \
        CloseHandle (hPusherFileAscii);                                             \
        bPusherCapture = FALSE;                                                     \
    }                                                                               \
}

#endif

//---------------------------------------------------------------------------

// pusher aliases
// alias these to point to appropriate data for your particular implementation

// hw get
#define _pdwHWGet       ((volatile DWORD)(((Nv4ControlDma*)m_dwControlDMA)->Get))

// hw put
#define _pdwHWPut       ((volatile DWORD)(((Nv4ControlDma*)m_dwControlDMA)->Put))

// hw reference count
#define _pdwHWRef       ((volatile DWORD)(((Nv10ControlDma*)m_dwControlDMA)->Reference))

// true when HW is busy
#define _pbHWBusy       (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x400700))

// cache1 ownership: bits 0:4 give the channel that currently owns the cache
#define _ffCache1Push1  (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x003204))

// cache1 status: bit 4 is set when the cache is empty
#define _ffCache1Status (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x003214))

// true if we have KNI support
#define _hasKNI         (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)

// true if we have 3DNOW support
#define _has3DNOW       (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_3DNOW)

// true if we have SFENCE support
#define _hasSFENCE      (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_SFENCE)

//---------------------------------------------------------------------------

// pusher-related macros

// the if is to allow for a string of Function such as Flip(A->B), Clear(A), Blit(C), such that the Blit to C
// does not destroy the pending waitforflip on Clear(A).  We only wait on surfaces that are just becoming a
// target and not an arbitrary surface
#define nvPusherSignalWaitForFlip(fpVidMem, dwDDSFlags)          \
{                                                                \
    if (getDC()->flipPrimaryRecord.fpFlipFrom == (fpVidMem)) {   \
        getDC()->nvPusher.setSyncFlipFlag();                     \
        getDC()->nvPusher.setFlipSurface(fpVidMem);              \
        getDC()->nvPusher.setFlipSurfaceFlags(dwDDSFlags);       \
    }                                                            \
}

// i'd really rather see these eventually just be substituted, but i'll make that mess later
#define nvPushData(a,b)    getDC()->nvPusher.push(a,b)
#define nvPusherAdjust(a)  getDC()->nvPusher.adjust(a)
#define nvPusherStart(a)   getDC()->nvPusher.start(a)
#define nvPusherFlush(a)   getDC()->nvPusher.flush(a,0)     // 0 = FLUSH_WITH_DELAY

//---------------------------------------------------------------------------

#ifdef __cplusplus

// forward definitions

struct  _def_nv_d3d_context;
typedef _def_nv_d3d_context *PNVD3DCONTEXT;


//---------------------------------------------------------------------------


class CPushBuffer
{

private:

    // pusher flags
    const enum {
        PB_FLAG_VALID          = (1 << ( 0)),  // push buffer is allocated, context DMA is allocated, and channel is open
        PB_FLAG_CHANNEL_SYNC   = (1 << ( 1)),  // signal to sync other channels b4 put
        PB_FLAG_FLIP_SYNC      = (1 << ( 2))   // will wait for flip before writing put
    };

public:

    // flush modes
    const enum {
        FLUSH_WITH_DELAY       = 0,            // flush with a delays when polling    (detrimental to CPU performance)
        FLUSH_HEAVY_POLLING    = 1             // flush & poll hw as fast as possible (detrimental to HW performance)
    };

private:

    // members
    DWORD m_dwChannel;          // handle for channel used by this push buffer
    DWORD m_dwContextDMA;       // handle for context DMA
    DWORD m_dwContextDMASize;   // size of context dma allocated for this push buffer
    DWORD m_dwControlDMA;       // controlDMA structure for this channel
    DWORD m_dwPCIHeapHandle;    // pci heap handle (if any)
    DWORD m_dwPCIHeapBase;      // pci heap base (if any)
    DWORD m_dwDDGbl;            // the DDGbl with which allocated AGP memory is associated
    DWORD m_dwHeap;             // heap from which push buffer is allocated
    // bank
    DWORD m_dwBase;             // base of push buffer
    DWORD m_dwSize;             // size of push buffer
    DWORD m_dwPut;              // current put pointer
    DWORD m_dwPutLast;          // last put wrote to HW
    DWORD m_dwGet;              // cached get pointer
    DWORD m_dwThreshold;        // threshold value
    DWORD m_dwWrapCount;        // # of wrap arounds
    DWORD m_dwPad01[1];
    // bank
    DWORD m_dwFlipSurfaceAddr;  // what surface to wait on during getFrameStatus
    DWORD m_dwFlipSurfaceFlags; // DDS caps flags, identifying the type of surface
    DWORD m_dwFlags;            // pusher flags
    DWORD m_dwPad02[5];

public:

    inline DWORD getChannel           (void)            {   return (m_dwChannel);      }
    inline DWORD getContextDMA        (void)            {   return (m_dwContextDMA);   }

    inline DWORD getHeap              (void)            {   return (m_dwHeap);   }
    inline DWORD getBase              (void)            {   return (m_dwBase);   }
    inline DWORD getSize              (void)            {   return (m_dwSize);   }

    inline void  setPut               (DWORD dwPut)     {   m_dwPut = dwPut;    }
    inline DWORD getPut               (void)            {   return (m_dwPut);   }

    inline DWORD getThreshold         (void)            {   return (m_dwThreshold);   }
    inline DWORD getWrapCount         (void)            {   return (m_dwWrapCount);   }
    inline DWORD getRefCount          (void)            {   return (_pdwHWRef);       }

    inline void  setSyncFlipFlag      (void)            {   m_dwFlags |=  PB_FLAG_FLIP_SYNC;    }
    inline void  clearSyncFlipFlag    (void)            {   m_dwFlags &= ~PB_FLAG_FLIP_SYNC;    }
    inline void  setSyncChannelFlag   (void)            {   m_dwFlags |=  PB_FLAG_CHANNEL_SYNC; }
    inline void  clearSyncChannelFlag (void)            {   m_dwFlags &= ~PB_FLAG_CHANNEL_SYNC; }

    inline void  setFlipSurface       (DWORD dwAddr)    {   m_dwFlipSurfaceAddr = dwAddr;   }
    inline void  setFlipSurfaceFlags  (DWORD dwFlags)   {   m_dwFlipSurfaceFlags = dwFlags;   }

    inline BOOL  isValid              (void)            {   return ((m_dwFlags & PB_FLAG_VALID) ? TRUE : FALSE);   }
    inline void  invalidate           (void)            {   m_dwFlags &= ~PB_FLAG_VALID;   }

    // prototypes for functions in nvPusher.cpp

           BOOL  allocate             (DWORD dwChannel, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
           BOOL  free                 (void);

           void  start                (BOOL bRequired);                     // kick off
           void  flush                (BOOL bWaitForHWIdle, DWORD dwMode);  // kick off & wait for idle
           void  resetPut             (void);                               // set put to base & read get
           BOOL  isIdle               (BOOL bCheckHWAlso);                  // check if idle
           void  waitForOtherChannels (void);                               // idle other channels
           void  makeSpace            (DWORD dwCount);                      // makes space for large transfers (use inc instead of adjust)

    #ifdef _NO_INLINE

           void  push                 (DWORD dwOffset, DWORD dwData);
           BOOL  adjust               (DWORD dwCount);
           void  inc                  (DWORD dwCount);

    #else  // !_NO_INLINE

    FORCE_INLINE void  push           (DWORD dwOffset, DWORD dwData)
                {
                    ((DWORD*)m_dwPut)[dwOffset] = dwData;
                };

    FORCE_INLINE BOOL  adjust         (DWORD dwCount)
                {   m_dwPut += ((dwCount) << 2);
                    if (m_dwPut >= m_dwThreshold) {
                        return getSpace();
                    }
                    return FALSE;
                }
    FORCE_INLINE void  inc            (DWORD dwCount)
                {
                    m_dwPut += ((dwCount) << 2);
                }

    #endif  // !_NO_INLINE

    inline void setObject(NvU32 subChannel,NvU32 objId)
    {
        nvAssert((subChannel >= 0) && (subChannel<=7));
        nvAssert(objId != 0);
        push(0, (subChannel << 13) | 0x40000);
        push(1, objId);
        adjust(2);
    }
private:

    // prototypes for functions in nvPusher.cpp

    inline void    setChannel         (DWORD dwChannel)                 {   m_dwChannel    = dwChannel;
                                                                            m_dwContextDMA = dwChannel+1;   }

           void    setBase            (DWORD dwBase);   // set buffer base
           void    setSize            (DWORD dwSize);   // set buffer size

           BOOL    allocateMemory     (LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
           BOOL    freeMemory         (void);
           BOOL    allocateContextDMA (void);
           BOOL    freeContextDMA     (void);
           BOOL    openChannel        (void);
           BOOL    closeChannel       (void);

           FLATPTR getfpVidMem        (void);           // FLATPTR of pusher base

    inline void    syncAndFlushWC     (void);
           void    kickOff            (void);

           BOOL    getSpace           (void);
           BOOL    calcThreshold      (void);           // read get
           void    wrapAround         (void);

    #ifdef _PC_CHECK
           BOOL    validate           (DWORD dwStart, DWORD dwEnd);
    #endif
    #ifdef _PC_CAPTURE_METHOD_DATA
           DWORD   parseMethod        (DWORD dwAddress);
           void    captureState       (DWORD dwSubChannel);
    #endif

public:

    // creation and destruction

    inline         CPushBuffer        (void)            {   memset (this, 0, sizeof(*this));  }
    inline        ~CPushBuffer        (void)            {}

    // friends

    friend void    nvCelsiusILCompile_beginEnd        (DWORD dwPrimType);
    friend DWORD   nvCelsiusILCompile_inline_prim     (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_inline_tri_list (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_super_tri_list  (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_vb_prim         (PNVD3DCONTEXT pContext, DWORD dwFlags);

    //friend void    nvKelvinILCompile_beginEnd         (DWORD dwPrimType);
    friend DWORD   nvKelvinILCompile_inline_prim      (PNVD3DCONTEXT pContext, DWORD dwFlags);
    //friend DWORD   nvKelvinILCompile_inline_tri_list  (PNVD3DCONTEXT pContext, DWORD dwFlags);
    //friend DWORD   nvKelvinILCompile_super_tri_list   (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvKelvinILCompile_vb_prim          (PNVD3DCONTEXT pContext, DWORD dwFlags);

};

#else  // !cplusplus

typedef struct _CPushBuffer
{
    // members
    DWORD m_dwChannel;          // handle for channel used by this push buffer
    DWORD m_dwContextDMA;       // handle for context DMA
    DWORD m_dwContextDMASize;   // size of context dma allocated for this push buffer
    DWORD m_dwControlDMA;       // controlDMA structure for this channel
    DWORD m_dwPCIHeapHandle;    // pci heap handle (if any)
    DWORD m_dwPCIHeapBase;      // pci heap base (if any)
    DWORD m_dwDDGbl;            // the DDGbl with which allocated AGP memory is associated
    DWORD m_dwHeap;             // heap from which push buffer is allocated
    // bank
    DWORD m_dwBase;             // base of push buffer
    DWORD m_dwSize;             // size of push buffer
    DWORD m_dwPut;              // current put pointer
    DWORD m_dwPutLast;          // last put wrote to HW
    DWORD m_dwGet;              // cached get pointer
    DWORD m_dwThreshold;        // threshold value
    DWORD m_dwWrapCount;        // # of wrap arounds
    DWORD m_dwPad01[1];
    // bank
    DWORD m_dwFlipSurfaceAddr;  // what surface to wait on during getFrameStatus
    DWORD m_dwFlipSurfaceFlags; // DDS caps flags, identifying the type of surface
    DWORD m_dwFlags;            // pusher flags
    DWORD m_dwPad02[5];
} CPushBuffer;

#endif  // !cplusplus

#endif  // (NVARCH >= 0x04)

#undef nvAssert

#endif  //!_NVPUSHER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvPatchInterface.h ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPatchInterface.h
//        nvPatchInterface specification to allow for shared ogl/d3d access
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************

// using generic C structs for shared library compatability with OGL.

#ifndef __NV_PATCH_INTERFACE_H
#define __NV_PATCH_INTERFACE_H

/*
** Standard polymorphic data types that are not present in older header files.
*/
#if defined(_WIN32) && (_MSC_VER < 1300)

typedef int            intptr_t;
typedef unsigned int   uintptr_t;

#endif

/*** Global constants ***/

//return codes for EvalPatch
#define NV_PATCH_EVAL_OK                 0x1
#define NV_PATCH_EVAL_ERR_OUT_OF_MEMORY  0x10
#define NV_PATCH_EVAL_ERR_NOT_HANDLED    0x20

// D3D, OGL, and Kelvin all use 16 separate vertex attributes.
#define NV_PATCH_NUMBER_OF_ATTRIBS      16

// D3D supports up to 5, OGL supports up to 8, and Kelvin supports up to 16.
// Note that when computing normal patches, an 8th-order nonrational patch
// becomes a 14th-order rational patch, and an 8th-order rational patch
// exceeds the Kelvin limit easily.
#define NV_PATCH_MAX_ORDER              16

// The maximum size of a swatch is determined by the size of the vertex
// file.   Henry says this is the magic number.  16 might work better, but
// it's not clear.
#define NV_PATCH_KELVIN_SWATCH_SIZE     17


#define NV_PATCH_MAX_TOTAL_STEP 1000    // total steps allowed
#define NV_PATCH_MAX_EVAL_STEP 40       // max steps within a sub-patch

// Matrix structure for matrix math
typedef struct {
    int rows, columns;
    float data[NV_PATCH_MAX_ORDER][NV_PATCH_MAX_ORDER][4]; // [row][col][xyzw]
} FDMatrix;

// For swathing, an array of ptrs to FDMatrices is used to 
// find a pointer to a particular FDMatrix given an attribute number
typedef FDMatrix *FDMatrixAttrSet[NV_PATCH_NUMBER_OF_ATTRIBS];

// Evaluated vertex attributes
typedef struct {
    float vertexAttribs[NV_PATCH_MAX_EVAL_STEP][NV_PATCH_NUMBER_OF_ATTRIBS][4];
} NV_PATCH_EVAL_OUTPUT;


// This is given to beginPrimitive to indicate what type of primitive to draw.
typedef enum {
    NV_PATCH_PRIMITIVE_TSTRIP = 1,
    NV_PATCH_PRIMITIVE_TFAN   = 2,
} NV_PATCH_PRIMITIVE_TYPE;

// Information for forward differencing one curve
typedef float NV_PATCH_CURVE_COEFFS[NV_PATCH_MAX_ORDER][4];
typedef struct {
    int order;
    //fffloat coeffs[NV_PATCH_MAX_ORDER][4];
    NV_PATCH_CURVE_COEFFS coeffs;
} NV_PATCH_CURVE_INFO;

// For swathing, an array of ptrs to NV_PATCH_CURVE_INFOs is used to 
// find a pointer to a particular guard curve given an attribute number
typedef NV_PATCH_CURVE_INFO *FDCurveAttrSet[NV_PATCH_NUMBER_OF_ATTRIBS];

// Enumerant for what basis the patch is defined on
typedef enum {
    NV_PATCH_BASIS_BEZIER      = 0,
    NV_PATCH_BASIS_BSPLINE     = 1,
    NV_PATCH_BASIS_CATMULL_ROM = 2,
} NV_PATCH_BASIS_TYPE;

// Enumerant for the format of the control points
typedef enum {
    NV_PATCH_VERTEX_FORMAT_FLOAT_1 = 0, // Expand to (value,   0.0,   0.0, 1.0) 
    NV_PATCH_VERTEX_FORMAT_FLOAT_2 = 1, // Expand to (value, value,   0.0, 1.0);
    NV_PATCH_VERTEX_FORMAT_FLOAT_3 = 2, // Expand to (value, value, value, 1.0);
    NV_PATCH_VERTEX_FORMAT_FLOAT_4 = 3, // No expansion required                
    NV_PATCH_VERTEX_FORMAT_UBYTE   = 4, // Unpack bytes and remap to [0,1.0]    
} NV_PATCH_VERTEX_FORMAT_TYPE;

// Dirty flags for each map
#define NV_PATCH_DIRTY_NONE             0x00000000
#define NV_PATCH_DIRTY_CONTROL_POINTS   0x00000001
#define NV_PATCH_DIRTY_TESSELLATION     0x00000002

// Enumerant for the type of backend
typedef enum {
    NV_PATCH_BACKEND_IMMEDIATE = 1, // call immediately into a NV_PATCH_BACKEND
    NV_PATCH_BACKEND_CELSIUS   = 2, // write a Celsius pushbuffer
    NV_PATCH_BACKEND_KELVIN    = 3, // write a Kelvin pushbuffer
    NV_PATCH_BACKEND_DP2       = 4, // write a DP2 command stream
} NV_PATCH_BACKEND_TYPE;

#define NV_PATCH_ATTRIB_POSITION            0
#define NV_PATCH_ATTRIB_VERTEX_WEIGHT       1
#define NV_PATCH_ATTRIB_NORMAL              2
#define NV_PATCH_ATTRIB_COLOR               3
#define NV_PATCH_ATTRIB_SECONDARY_COLOR     4
#define NV_PATCH_ATTRIB_FOG_COORD           5
#define NV_PATCH_ATTRIB_UNUSED0             6
#define NV_PATCH_ATTRIB_UNUSED1             7
#define NV_PATCH_ATTRIB_TEXCOORD0           8
#define NV_PATCH_ATTRIB_TEXCOORD1           9
#define NV_PATCH_ATTRIB_TEXCOORD2           10
#define NV_PATCH_ATTRIB_TEXCOORD3           11
#define NV_PATCH_ATTRIB_TEXCOORD4           12
#define NV_PATCH_ATTRIB_TEXCOORD5           13
#define NV_PATCH_ATTRIB_TEXCOORD6           14
#define NV_PATCH_ATTRIB_TEXCOORD7           15

// Guard information for a single subquad within a fractional tesselation                                                
typedef struct {                                //     |              |
    NV_PATCH_CURVE_INFO *guardU0;               //     |              |center
    NV_PATCH_CURVE_INFO *guardV0;               // Vmid*---UCenter----*-----
    NV_PATCH_CURVE_INFO *guardUCenter;          //     |              |
    NV_PATCH_CURVE_INFO *guardVCenter;          //     |    _         |
    float *uMid;                                //     |   _/|      VCenter
    float *vMid;                                //    V0 _/           |
    float *center;                              //     |/             |
} NV_PATCH_FRAC_GUARD_INFO;                     //     +------U0------*------
                                                //                  Umid    

// Guard information for a single attribute for a fractionally tesselated
// tensor product patch
typedef struct {                            //                    u1Mid
    NV_PATCH_CURVE_INFO guardU00;           //       *------U01-----*------U11-----*
    NV_PATCH_CURVE_INFO guardU01;           //       |\_            |            _/|
    NV_PATCH_CURVE_INFO guardU10;           //       |  \_          |          _/  |
    NV_PATCH_CURVE_INFO guardU11;           //      V01  _\| 01    VC1    11 |/_  V11
    NV_PATCH_CURVE_INFO guardV00;           //       |              |              |
    NV_PATCH_CURVE_INFO guardV01;           //       |              |center        |
    NV_PATCH_CURVE_INFO guardV10;           //  v0Mid*------UC0-----*------UC1-----* v1Mid
    NV_PATCH_CURVE_INFO guardV11;           //       |              |              |
    NV_PATCH_CURVE_INFO guardUCenter0;      //       |    _         |         _    |
    NV_PATCH_CURVE_INFO guardUCenter1;      //      V00  _/|  00   VC0    10 |\_  V10
    NV_PATCH_CURVE_INFO guardVCenter0;      //       | _/           |           \_ |
    NV_PATCH_CURVE_INFO guardVCenter1;      //       |/             |             \|
    float u0Mid[4], v0Mid[4], u1Mid[4];     //       *------U00-----*------U10-----*
    float v1Mid[4], center[4];              //                    u0Mid
} NV_PATCH_FRAC_QUAD_GUARD_INFO;


// Guard information for a single attribute for a fractionally tesselated
// triangular patch
typedef struct {                            //                +                -                           
    NV_PATCH_CURVE_INFO guard[3][2];        //               / \               -
    NV_PATCH_CURVE_INFO guardCenter[3];     //              /   \              -   
    float mid[3][4];                        //             /     \             -
    float center[4];                        //           g20     g11           -        
} NV_PATCH_FRAC_TRI_GUARD_INFO;             //           /         \           -
                                            //          /           \          -
                                            //    mid? +             + mid?    -
                                            //        / \_         _/ \        -
                                            //       /    gc?    gc?   \       -
                                            //      /       \_ _/       \      -
                                            //    g21         + center  g10    -
                                            //    /           |           \    -
                                            //   /           gc?           \   -
                                            //  /             |             \  -                             
                                            // +------g00-----+------g01-----+ -
                                            //               mid?


// Guard information for a single attribute for an integrally tesselated
// tensor product patch
typedef struct {                                                //          
    NV_PATCH_CURVE_INFO guardU0;                                //     c01                     c11 
    NV_PATCH_CURVE_INFO guardU1;                                //      *--------gU1------------*     
    NV_PATCH_CURVE_INFO guardV0;                                //      |                     _/|
    NV_PATCH_CURVE_INFO guardV1;                                //      |                   /   |               
    NV_PATCH_CURVE_INFO guardUInner;                            //      +------UInner-------+   |               
    NV_PATCH_CURVE_INFO guardVInner;                            //      |                   |   |               
    // *Begin/End point to guard curves at                      //      |                   |   |               
    //  begin/end of regular grid                               //      |                   |   |               
    NV_PATCH_CURVE_INFO *pGuardUBegin;                          //     gV0              VInner gV1               
    NV_PATCH_CURVE_INFO *pGuardUEnd; // row: U0, U1, UInner     //      |                   |   |               
    NV_PATCH_CURVE_INFO *pGuardVBegin;                          //      |                   |   |               
    NV_PATCH_CURVE_INFO *pGuardVEnd; // col: V0, V1, VInner     //      |                   |   |               
    // corners of the original control points                   //      |                   |   |               
    float corners[2][2][4]; // [v][u][xyzw]                     //      |                   |   |               
    // these cached here to use when dirtyFlags not set         //      +--------gU0--------+---*
    int u0Dir, u1Dir, v0Dir, v1Dir;                             //     c00                 pVB c10

    // *Begin/End point to guard curves at begin/end of regular grid

    // the corners[] are from the original control points
} NV_PATCH_INT_QUAD_GUARD_INFO;


// Information for an integrally tesselated tensor product patch
typedef struct {
    NV_PATCH_INT_QUAD_GUARD_INFO **guard;   // from guardQI or swathing
    int nu0, nv0, nu1, nv1; // actual number of segments along each edge
    int uMaxSegs, vMaxSegs, uMinSegs, vMinSegs; // MIN and MAX comparing nu0:nu1 and nv0:nv1

    // flags for transitions required.
    // Names refer to original LRTB, not flipped versions or anything
    int stitchLeft, stitchRight, stitchTop, stitchBottom;

    // these begin/end's mean in the direction of U (L/R) and V (B/T)
    // XXX FBF I find this confusing, since it doesn't correspond to U0, U1
    // XXX in other words, stitchVBegin means U0/UInner create a stitch (in cononical view)
    // XXX will soon change to make these match
    int stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd;

    int u0Dir, v0Dir, u1Dir, v1Dir; // '1' means normal direction (For u this is L-->R, for v this is B-->T)

    // MaxDir are directions of regular grid
    // XXX REMOVE? MinDir are opposite of MaxDir's. Doesn't appear to be used any more.
    int uMaxDir, vMaxDir, uMinDir, vMinDir;

    float du0, du1, dv0, dv1, duMax, dvMax; // small step size along edges, and for regular grid

    // temp storage allocated in DrawIntPatch() and used by lower routines
    // uGuard and vGuard are for the ending curves in regular grid
    NV_PATCH_CURVE_INFO **uGuard, **vGuard, *tempCurve;
    FDMatrix **ppMatrixSetSS0; // FD matrix for reg grid, small steps in V and U
    FDCurveAttrSet *pCurvesTop, *pCurvesBot;
    NV_PATCH_EVAL_OUTPUT *pOut1, *pOut2;
} NV_PATCH_INT_QUAD_INFO;

// for quadInfo->setGridCorner
#define NV_PATCH_SET_GRID_CORNER00      0x1
#define NV_PATCH_SET_GRID_CORNER10      0x2
#define NV_PATCH_SET_GRID_CORNER01      0x4
#define NV_PATCH_SET_GRID_CORNER11      0x8
#define NV_PATCH_SET_GRID_CORNER_ALL    0xf

// Information for one map within the current patch
typedef struct {
    unsigned int uorder, vorder;
    float *rawData;
    int stride;                       // OGL: stride == type*sizeof(float)
    int pitch;                        // OGL: pitch == uorder
    NV_PATCH_VERTEX_FORMAT_TYPE type; 
    NV_PATCH_VERTEX_FORMAT_TYPE Originaltype; 
    unsigned int dirtyFlags;          // Currently ignored
} NV_PATCH_MAP_INFO;

// Declaration of an immediate-mode-style backend
typedef struct {
    void (*InitBackend)(void *info);
    void (*DestroyBackend)(void *info);
    void (*beginPrimitive)(void *info, NV_PATCH_PRIMITIVE_TYPE primType);
    void (*endPrimitive)(void *info);
    void (*sendVertex)(void *info, NV_PATCH_EVAL_OUTPUT *pData, int index);
    void (*setFrontFace)(void *info, int reversed);
} NV_PATCH_BACKEND;

// These are the callbacks that the shared code needs access to.  It is NOT SAFE
// to call C standard library or Windows API functions from the shared code!
typedef struct {
    void *(*malloc)(void *context, size_t bytes);
    void (*free)(void *context, void *ptr);    
    void (*memcpy)(void *dst, const void *src, size_t bytes);
    void (*flushOutput)(void *context, unsigned int bytesWritten);
} NV_PATCH_DRIVER_CALLBACKS;

/*****************************************************************************/
// eval memory allocation. Avoid seperate malloc for each section of memory.
// allocate a big chunk with EV_ALLOC_INIT 
// and dole it out efficiently with EV_ALLOC
// free it with EV_FREE
// Only one DECL per routine.
// Use EV_ALLOC_INIT to init locally.
// Use EV_ALLOC_RESET to use memory chunk allocated by higher level routine.

typedef struct {
        void *pBase;
        int callerAlloc;    // non-zero if caller does alloc/free
        void *pAvail;
        void *context;
        int bytesAlloc;
        int bytesUsed;
} NV_PATCH_ALLOC_CONTROL;

#define EV_ALLOC_DECL() NV_PATCH_ALLOC_CONTROL evMemory = {NULL, 0}

#define EV_ALLOC_RESET(EVMEMORY, CONTEXT, TOTALBYTES, errorLabel) do { \
        if (&(EVMEMORY) != &evMemory) { \
            evMemory = EVMEMORY; \
        } \
        nvAssert(CONTEXT == evMemory.context); \
        evMemory.pAvail = evMemory.pBase; \
        evMemory.bytesUsed = 0; \
        nvAssert((TOTALBYTES) <= evMemory.bytesAlloc); \
        if (!evMemory.pBase) { \
            retVal |= NV_PATCH_EVAL_ERR_OUT_OF_MEMORY; \
            evMemory.bytesAlloc = 0; \
        } \
        break; \
evAllocError: \
        retVal |= NV_PATCH_EVAL_ERR_OUT_OF_MEMORY; \
        goto errorLabel; \
    } while (0);\

        //ffPrintInt(evMemory.bytesAlloc); \

#define EV_ALLOC_INIT(CONTEXT, TOTALBYTES, errorLabel) { \
        nvAssert(!evMemory.pBase); \
        evMemory.bytesAlloc = (TOTALBYTES); /* assign first to eval expr */ \
        evMemory.pBase = info->callbacks->malloc(CONTEXT, evMemory.bytesAlloc);\
        evMemory.context = CONTEXT; \
        EV_ALLOC_RESET(evMemory, CONTEXT, evMemory.bytesAlloc, errorLabel); \
    }

#define EV_ALLOC(VAR, CONTEXT, BYTES) { \
        int __nBytes; \
        nvAssert(CONTEXT == evMemory.context); \
        evMemory.bytesUsed += (__nBytes = (BYTES)); \
        nvAssert(evMemory.bytesUsed <= evMemory.bytesAlloc); \
        if (evMemory.bytesUsed <= evMemory.bytesAlloc) { \
            *(void **)(&(VAR)) = evMemory.pAvail; \
            evMemory.pAvail = (char *)evMemory.pAvail + __nBytes; \
            nvAssert(!((uintptr_t)evMemory.pAvail & 0x3)); \
        } else { \
            VAR = NULL; \
        } \
        if (!VAR) goto evAllocError; \
    }

#define EV_FREE(VAR, CONTEXT) { \
        nvAssert(CONTEXT == evMemory.context); \
        if (evMemory.pBase && (VAR) && !evMemory.callerAlloc) { \
            info->callbacks->free(CONTEXT, evMemory.pBase); \
            evMemory.pBase = NULL; \
        } \
        VAR = NULL; \
    }

#define EV_ALLOC_FULL(CONTEXT) \
        /* expect equal if pre-calc was accurate */ \
        nvAssert(evMemory.bytesUsed == evMemory.bytesAlloc);

// The above alloc macro's could be redefined to use normal malloc/free,
// with appropriate macro's being null.
// The notion of a global evMemory is more specific to the eval code.
#define EV_ALLOC_GLOBAL(EVMEMORY, CONTEXT, TOTALBYTES, errorLabel) { \
        nvAssert(!EVMEMORY.pBase); \
        EVMEMORY.callerAlloc = 1; \
        EVMEMORY.bytesAlloc = (TOTALBYTES); /* assign first to eval expr */ \
        EVMEMORY.pBase = info->callbacks->malloc(CONTEXT, TOTALBYTES); \
        EVMEMORY.context = CONTEXT; \
        if (EVMEMORY.pBase == NULL) { \
            goto errorLabel; \
        } \
    } 

#define EV_FREE_GLOBAL(EVMEMORY, CONTEXT) { \
        if (EVMEMORY.pBase) info->callbacks->free(CONTEXT, EVMEMORY.pBase); \
        EVMEMORY.pBase = NULL; \
    }


// ***** bits for info->swatchFlags
#define NV_PATCH_SWATCH                 0x00000001      // set when swathing

#define NV_PATCH_SWATCH_FIRST_ROW       0x00000100
#define NV_PATCH_SWATCH_LAST_ROW        0x00000200
#define NV_PATCH_SWATCH_FIRST_COL       0x00000400
#define NV_PATCH_SWATCH_LAST_COL        0x00000800

#define NV_PATCH_SWATCH_SAVE_FIRST_ROW  0x00001000
#define NV_PATCH_SWATCH_SAVE_LAST_ROW   0x00002000
#define NV_PATCH_SWATCH_SAVE_FIRST_COL  0x00004000
#define NV_PATCH_SWATCH_SAVE_LAST_COL   0x00008000

#define NV_PATCH_HAS_NORMAL             0x00010000      // indicates to emit normal guard curves
//#define NV_PATCH_NEW_SWATH              0x00020000    // indicates this is the first swatch in a swath
//#define NV_PATCH_BEGIN_PATCH            0x00040000    // indicates this is the first swatch in a patch     
//#define NV_PATCH_END_PATCH              0x00080000    // indicates this is the last swatch in a patch


/*****************************************************************************/
// Flags for info->flags 
#define NV_PATCH_FLAG_TYPE_MASK         0x00000001
#define NV_PATCH_FLAG_TYPE_TRIANGULAR   0x00000001
#define NV_PATCH_FLAG_TYPE_PATCH        0x00000000

#define NV_PATCH_FLAG_TESS_MASK         0x00000002
#define NV_PATCH_FLAG_TESS_FRACTIONAL   0x00000002
#define NV_PATCH_FLAG_TESS_INTEGER      0x00000000

#define NV_PATCH_FLAG_AUTO_MASK         0x0000000C
#define NV_PATCH_FLAG_AUTO_NORMAL       0x00000004
#define NV_PATCH_FLAG_AUTO_UV           0x00000008
#define NV_PATCH_FLAG_AUTO_NONE         0x00000000

#define NV_PATCH_FLAG_CACHE_MASK        0x00000010
#define NV_PATCH_FLAG_DO_NOT_CACHE      0x00000010

// Information about the current patch
typedef struct {
    // Bitmask of which attributes to evaluate (bits 0..15)
    unsigned int evalEnables;
    int nAttr;                  // number of active attrs
    int maxAttr;                // max attributes required for malloc's
    unsigned int maxOrder;      // max order of all enabled attributes
    int maxSwatch;              // set according to HW or SW swathing
    int nSwatchU, nSwatchV;     // swatches in patch, including Begin/End stitch

    int swatchFlags;            // control during swathing using NV_PATCH_SWATCH_*

    // Evaluation flags
    unsigned int flags;         // NV_PATCH_FLAG_*

    // Description of tesselation factors
    union {
        struct {
            float nu0, nu1, nv0, nv1;
        } tensor;
        struct {
            float n1, n2, n3;
        } tri;
    } tess, originaltess;

    // The basis for the patch
    NV_PATCH_BASIS_TYPE basis;

    // Source and destination of AUTO_NORMAL calculations
    int srcNormal, dstNormal;
    int rational;
    float startu, endu, startv, endv;
    // Destination of AUTO_UV calculations
    int srcUV[8], dstUV[8];         //can have up to 8 sets??

    // Information for each map
    NV_PATCH_MAP_INFO maps[NV_PATCH_NUMBER_OF_ATTRIBS];

    // What type of backend we are writing to or calling to
    NV_PATCH_BACKEND_TYPE backendType;

    // Function pointers for shared code to call into
    NV_PATCH_BACKEND *backend;
    NV_PATCH_DRIVER_CALLBACKS *callbacks;

    // Output buffer (pushbuffer, DP2 stream, ...)
    unsigned char *buffer;
    unsigned int bufferLength; // in bytes
    int vertexSize;            // expected # of dwords to output per vertex

    // Opaque context pointer
    void *context;

    // info for EV_ALLOC in lower level routines
    // for ComputeFDMatrix and ComputeFDCurveCoeffs()
    NV_PATCH_ALLOC_CONTROL evAllocComputeFD;

    // These point to the guard corners of the regular grid. They are in this 
    // top-level structure to be used by all patch types.
    // Instead of fancy attribute arrays, they are simply enumerated for
    // the two attributes which require guard corners: vertex, normal
    // Think of drawing the regular grid from lower-left to upper-right.
    // These names match that orientation so the regular grid routine doesn't
    // need to worry about various orientation flipping and swatching cases.
    // Perhaps LL and LR are not needed for HW, but they're set up for now.
    // Generally these points are the corners of the regular grid,
    // except for LL and LR on the bottom row with a bottom stitch.
    // In this case, they correspond to the swatch corners, and must be stepped
    // up if you want the regular grid.
    //  UL=[0][1]   UR=[1][1]
    //  LL=[0][0]   LR=[0][1]
    float *pSwatchCornerVertex[2][2]; // [v][u]
    float *pSwatchCornerNormal[2][2]; // [v][u]

    // These are available storage for the corners of the regular grid on
    // the outside of all swatches.  
    // Whereas, pSwatchCornerVertex and pSwatchCornerNormal will be 
    // correct per sub-patch, these need only be fully valid
    // after all swatches are done
    // Here, the indices are "absolute" because the stitch code was written
    // to draw stitches on the Left, Right, Bot, Top, not relative to the
    // regular grid.
    float gridCornerVertex[2][2][4]; // [v][u][xyzw]
    float gridCornerNormal[2][2][4]; // [v][u][xyzw]
    int setGridCorner;  // mask indicating which gridCorner to assign

    // CACHED DATA
    // the driver should allocate memory for these data members BEFORE 
    // calling into the shared code.  Shared code should not be responsible 
    // for the life time of these data members.
    FDMatrix *m00[NV_PATCH_NUMBER_OF_ATTRIBS], *m01[NV_PATCH_NUMBER_OF_ATTRIBS],
             *m10[NV_PATCH_NUMBER_OF_ATTRIBS], *m11[NV_PATCH_NUMBER_OF_ATTRIBS];    //[attribute]  (sub-patch index = 0 for bezier types)

    //we should probably union these....
    NV_PATCH_FRAC_QUAD_GUARD_INFO *guardQF[NV_PATCH_NUMBER_OF_ATTRIBS];             //[attribute]  (sub-patch index = 0 bezier types)
    NV_PATCH_FRAC_TRI_GUARD_INFO  *guardTF[NV_PATCH_NUMBER_OF_ATTRIBS];
    NV_PATCH_INT_QUAD_GUARD_INFO  *guardQI[NV_PATCH_NUMBER_OF_ATTRIBS];   

} NV_PATCH_INFO;

unsigned int nvEvalPatch(NV_PATCH_INFO *info);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvtracecom.h ===
#ifndef __NV_TRACECOM_H
#define __NV_TRACECOM_H
// This struct is used for debug code.

typedef struct nvFunRec {
    char *uname;
    char *name;
    int class;
    int level;
    struct nvFunRec *next;
    int count;
    struct {
        int msh, lsh;
    } time;
} nvFunRec;

extern int nvDebugOptions;
extern int nvDebugMask;
extern int nvDebugLevel;
extern int nvControlOptions;

#endif __NV_TRACECOM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\StereoDDK.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: StereoDDK.h                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/02/00  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef _STEREO_DDK_H_
#define _STEREO_DDK_H_

/*
 * Bit flags defining supported stereo viewing formats.
 */
#define SVF_NONE                0
#define SVF_OVERANDUNDER        0x00000001
#define SVF_FRAMESEQUENTIAL     0x00000002
#define SVF_MULTIMONITOR        0x00000004
#define SVF_LEFTANDRIGHT        0x00000008
#define SVF_LINEINTERLEAVE      0x00000010

/*
 * Activation Methods.
 */
#define SAM_VRAMPATTERN         0x00000001
#define SAM_DDC                 0x00000002
#define SAM_MANUAL              0x00000004

typedef DWORD   (WINAPI *LPDEACTIVATESTEREO)(void);

typedef struct _GraphicsServices_s
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDEACTIVATESTEREO  DeactivateStereo;
} GRAPHICSSERVICES, *LPGRAPHICSSERVICES;

typedef DWORD   (FAR PASCAL *LPONFLIP)(void);

typedef struct _StereoViewerServices_s
{
    DWORD            dwSize;
    DWORD            dwFlags;
    LPONFLIP         OnFlip;
} STEREOVIEWERSERVICES, *LPSTEREOVIEWERSERVICES;

/*
 * Bits defining valid fields in the StereoCaps structure.
 */
#define STEREOCAPS_SUPPORTEDFORMATS     0x00000001
#define STEREOCAPS_PREFERREDFORMAT      0x00000002
#define STEREOCAPS_MINREFRESHRATE       0x00000004
#define STEREOCAPS_MAXREFRESHRATE       0x00000008
#define STEREOCAPS_ACTIVATIONMETHOD     0x00000010
#define STEREOCAPS_SERVICECALLBACKS     0x00000020

typedef struct StereoCaps
{
    DWORD dwSize;               //Indicates the version both ways.
    DWORD dwFlags;              //Indicates the valid fields both ways.
    DWORD dwSupportedFormats;
    DWORD dwPreferredFormat;
    WORD  dwMinRefreshRate;
    WORD  dwMaxRefreshRate;
    DWORD dwActivationMethod;
    union 
    {
        LPGRAPHICSSERVICES       pGraphicsServices;    
        LPSTEREOVIEWERSERVICES   pStereoViewerServices;
    };
} STEREOCAPS, *LPSTEREOCAPS;

#ifdef __cplusplus

typedef class CStereoViewer
{
    /*
     * methods
     */
public:
    virtual DWORD WINAPI DestroyStereoViewer(void);
	virtual DWORD WINAPI GetCaps(LPSTEREOCAPS);
    virtual DWORD WINAPI ActivateStereo(LPDDHALMODEINFO pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
    virtual DWORD WINAPI DeactivateStereo(LPDDHALMODEINFO pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
} STEREOVIEWER, *LPSTEREOVIEWER;

#else   //__cplusplus==0

typedef struct CStereoViewer
{
    struct  CStereoViewerVtbl FAR *lpVtbl;
} STEREOVIEWER, *LPSTEREOVIEWER;

struct  CStereoViewerVtbl {
    DWORD (WINAPI *DestroyStereoViewer)(LPSTEREOVIEWER);
	DWORD (WINAPI *GetCaps)(LPSTEREOVIEWER, LPSTEREOCAPS);
    DWORD (WINAPI *ActivateStereo)(LPSTEREOVIEWER, LPVOID pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
    DWORD (WINAPI *DeactivateStereo)(LPSTEREOVIEWER, LPVOID pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
};

#endif  //__cplusplus==0


typedef DWORD (WINAPI *LPCREATESTEREOVIEWER)(LPSTEREOVIEWER *);

#define _FACSTEREO  (*(WORD *)"NV")
#define MAKE_STEREOHRESULT( code )  MAKE_HRESULT( 1, _FACSTEREO, code )

/*
 * Error codes
 */
#define STEREO_OK                               0
#define STEREO_UNSUPPORTED_STEREO_FORMAT        MAKE_STEREOHRESULT(1)
#define STEREO_UNSUPPORTED_VIDEO_MODE           MAKE_STEREOHRESULT(2)
#define STEREO_UNSUPPORTED_REFRESHRATE          MAKE_STEREOHRESULT(3)
#define STEREO_INVALID_PARAMETERS               MAKE_STEREOHRESULT(4)
#define STEREO_HARDWARE_NOT_FOUND               MAKE_STEREOHRESULT(5)
#define STEREO_UNKNOWN_ERROR                    MAKE_STEREOHRESULT(6)

#endif  //_STEREO_DDK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvUniversal.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _NVUNIVERSAL_H_
#define _NVUNIVERSAL_H_

/*==========================================================================;
 *
 *  File:       NvUniversal.h
 *
 *  Content:    Defines, constants, macros, and miscellaneous constructs that
 *              are commonly needed across all operating system platforms.
 *              
 *              If the code is specific to Windows, or Mac, or Linux it doesn't
 *              go here.
 *              
 ***************************************************************************/

#ifndef NVARCH
#error NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

// TBD: have everyone use this from here... -mlavoie
#if 0
#if (NVARCH >= 0x04)
#define NV_IN_PROGRESS          0x8000
#else
#define NV_IN_PROGRESS          0xFF
#endif
#endif

// TBD: combine this with PERFDATA from D3D -mlavoie
// TBD: move device version (and other appropos stuff) into this
typedef struct NV_SystemInfo_s
{
    // 32 byte bank
    NvU32 dwCPUFeatureSet;
    NvU32 dwProcessorSpeed;         // In MHz
    NvU32 dwSystemMemory;           // MB of system memory, rounded to the nearest 8
    NvU32 dwNVClasses;
    NvU32 dwNVClasses1;
    NvU32 dwPad_0[3];
} NV_SystemInfo_t;

// nvD3DPerfData.dwCPUFeatureSet
#define CPU_FS_MMX              0x00000001      // ) do not change - some code
#define CPU_FS_KATMAI           0x00000002      //  )          relies on the macros to match these numbers
#define CPU_FS_3DNOW            0x00000004      // )
#define CPU_FS_HALFFASTWRITE    0x00000008      // camino with agp4x and 1/2 nv fast writes
#define CPU_FS_FULLFASTWRITE    0x00000010      // camino with agp4x and 1/1 nv fast writes
#define CPU_FS_WILLAMETTE       0x00000020      //  Pentium 4 support
#define CPU_FS_ATHLON           0x00000040      // AMD Athlon
#define CPU_FS_PREFETCH         0x00000080      // supports prefetchNTA, prefetchT0, movntq
#define CPU_FS_SFENCE           0x00001000      // has sfence support
#define CPU_FS_64BIT            0x00008000      // 64-bit back end (VANTA)

/* Shared Celsius class usage flags */
#define CELSIUSUSER_NONE                0  // celsius object is untouched and (almost) fully uninitialized
#define CELSIUSUSER_D3D                 1
#define CELSIUSUSER_DDRAW               2
#define CELSIUSUSER_DDRAW_VPP           3

/* Shared Kelvin class usage flags */
#define KELVINUSER_NONE                 0  // kelvin object is untouched and (almost) fully uninitialized
#define KELVINUSER_D3D                  1
#define KELVINUSER_DDRAW                2
#define KELVINUSER_DDRAW_VPP            3

// NV_SYSTEM_INFO.dwNVClasses
// ordered from "worst" to "best" within each class
#define NVCLASS_0055_DX6TRI     0x00000001
#define NVCLASS_0095_DX6TRI     0x00000002

#define NVCLASS_0054_DX5TRI     0x00000004
#define NVCLASS_0094_DX5TRI     0x00000008

#define NVCLASS_0056_CELSIUS    0x00000010
#define NVCLASS_0096_CELSIUS    0x00000020
#define NVCLASS_1196_CELSIUS    0x00000040

#define NVCLASS_0097_KELVIN     0x00000080

#define NVCLASS_0046_DAC        0x00000100
#define NVCLASS_0049_DAC        0x00000200
#define NVCLASS_0067_DAC        0x00000400
#define NVCLASS_007C_DAC        0x00000800

#define NVCLASS_0042_CTXSURF2D  0x00001000
#define NVCLASS_0062_CTXSURF2D  0x00002000

#define NVCLASS_0060_IDXIMAGE   0x00004000
#define NVCLASS_0064_IDXIMAGE   0x00008000

#define NVCLASS_0077_SCALEDIMG  0x00010000
#define NVCLASS_0063_SCALEDIMG  0x00020000
#define NVCLASS_0089_SCALEDIMG  0x00040000

#define NVCLASS_0038_DVDPICT    0x00100000
#define NVCLASS_0088_DVDPICT    0x00200000

#define NVCLASS_007A_OVERLAY    0x00400000

#define NVCLASS_0053_CTXSURF3D  0x01000000
#define NVCLASS_0093_CTXSURF3D  0x02000000

#define NVCLASS_004A_GDIRECT    0x04000000
#define NVCLASS_005E_SOLIDRECT  0x08000000

#define NVCLASS_0052_CTXSURFSWZ 0x10000000
#define NVCLASS_009E_CTXSURFSWZ 0x20000000

// class 0 collectives
#define NVCLASS_FAMILY_DXTRI    (NVCLASS_0094_DX5TRI  | NVCLASS_0054_DX5TRI  | NVCLASS_0095_DX6TRI | NVCLASS_0055_DX6TRI)
#define NVCLASS_FAMILY_CELSIUS  (NVCLASS_0056_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS)
#define NVCLASS_FAMILY_KELVIN   (NVCLASS_0097_KELVIN)

// NV_SYSTEM_INFO.dwNVClasses1
// ordered from "worst" to "best" within each class
#define NVCLASS1_006C_CHANNELDMA 0x00000001
#define NVCLASS1_006E_CHANNELDMA 0x00000002
#define NVCLASS1_206E_CHANNELDMA 0x00000004

// class 1 collectives
// none yet

#define SUB_CHANNEL(I) (I * 0x00002000) // Computes subchannel offset given a simple ndx 0-7

// Convert Microsoft Specific modifier (not available on all MS compilers either)
#if defined(__forceinline)
#define FORCE_INLINE __forceinline
#else
#define FORCE_INLINE inline
#endif

#endif // _NVUNIVERSAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\targa.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: targa.h
//      header files for targa.c
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Jun00         filched from architects
//
// **************************************************************************

#ifndef __TARGA_H
#define __TARGA_H

typedef char int8;
typedef int int16;
typedef int int32;
typedef unsigned char uint8;
typedef unsigned int uint16;
typedef unsigned int uint32;

/* Header definition. */
typedef struct TGA_Header_  {
    unsigned char ImageIDLength;        /* length of Identifier String. */
    unsigned char CoMapType;            /* 0 = no map */
    unsigned char ImgType;              /* image type (see below for values) */
    unsigned char Index_lo, Index_hi;   /* index of first color map entry */
    unsigned char Length_lo, Length_hi; /* number of entries in color map */
    unsigned char CoSize;               /* size of color map entry (15,16,24,32) */
    unsigned char X_org_lo, X_org_hi;   /* x origin of image */
    unsigned char Y_org_lo, Y_org_hi;   /* y origin of image */
    unsigned char Width_lo, Width_hi;   /* width of image */
    unsigned char Height_lo, Height_hi; /* height of image */
    unsigned char PixelSize;            /* pixel size (8,16,24,32) */
    unsigned char Desc;         /* 4 bits, number of attribute bits per pixel */
} TGA_Header;

/* if we create the tga file, we will put the following in the ImageID field */
typedef struct TGA_ImageId_ {
        unsigned char Magic;            /* must be a specific magic value */
        unsigned char ImageFmt;         /* encodes special raster formats */
} TGA_ImageId;

/* Definitions for image types. */
#define TGA_NULL 0
#define TGA_MAP 1
#define TGA_RGB 2
#define TGA_MONO 3
#define TGA_RLEMAP 9
#define TGA_RLERGB 10
#define TGA_RLEMONO 11

#define TGA_DESC_ALPHA_MASK     ((unsigned char)0xF)    /* number of alpha channel bits */
#define TGA_DESC_ORG_MASK       ((unsigned char)0x30)   /* origin mask */
#define TGA_ORG_BOTTOM_LEFT     0x00
#define TGA_ORG_BOTTOM_RIGHT    0x10
#define TGA_ORG_TOP_LEFT        0x20
#define TGA_ORG_TOP_RIGHT       0x30har)0x30)   /* origin mask */
#define TGA_ORG_BOTTOM_LEFT     0x00
#define TGA_ORG_BOTTOM_RIGHT    0x10

#define TGA_NVIDIA_MAGIC        0xAF            /* not an ascii char so unlikely... */

typedef enum RasterFormat_ {
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 * **** The RasterFormat defs _must_ be identical to the defs in vmodels/rasterDefs.vh ***
 * **** Do not change this enum without also updating rasterDefs.vh!                   ***
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */
        RASTER_A1R5G5B5 = 0,
        RASTER_X1R5G5B5 = 1,
        RASTER_A4R4G4B4 = 2,
        RASTER_R5G6B5 = 3,
        RASTER_A8R8G8B8 = 4,
        RASTER_X8R8G8B8 = 5,
        RASTER_Y8 = 6,
        RASTER_V8YB8U8YA8 = 7,
        RASTER_YB8V8YA8U8 = 8,
        RASTER_A8V8U8Y8 = 9,                    // A8Y8U8V8 was incorrect channel ordering, name changed
        RASTER_A4V6YB6A4U6YA6 = 10,
        RASTER_AY8 = 11,
        RASTER_Z16 = 12,                                // 16 bit Z/W buffer
        RASTER_Z24S8 = 13,                              // 24 bit Z/W plus 8 bit stencil in low 8 bits
// additional non-Nvidia formats for ease of use with tga
        RASTER_VOID32 = 100,                    // generic 32 bits/pixel format
        RASTER_R8G8B8 = 101,                    // 24 bits/pixel
        RASTER_VOID16 = 102,                    // generic 16 bits/pixel format
        RASTER_FORCELONG = 0x7FFFFFFFL  // force this enum to be a long
} RasterFormat;

// Read targa file "filename"
// Put pixels into **xbgr, and set *width and *height
// Pixels are xbgr words on the PC
// This routine copes with raw RGB and run-length encoded RGB targa files only

int read_targa_file(char *filename, unsigned char **xrgb, int *width, int *height);

#endif  // __TARGA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvVer.h ===
// nvver.h
//      Versions of NV drivers
//
// Copyright (C) Microsoft Corporation 1993.
// Portions Copyright 1993,1996 NVidia Corporation. All Rights Reserved.
//

// The following version numbers are owned by Microsoft.  We have permission
// to change the last 3 digits of each version string but no other digits
// until the next major Microsoft release.
//
// NOTE: This release must be bumped up to 4.10... (0x040A...) when starting
// to build Win98 drivers
//
//
// The following #defines are used for the driver version number. They should be
// updated for each build and they should agree with each other.
//
// Also, because NV_DRIVER_VERSION has a leading 0, it can't be used as a number
// in drivers (it'll be interpretted as octal). And since it does contain non-octal
// values drivers should use NV_DRIVER_VERSION_NUMBER instead.
//
#ifndef WIN31
#define NV_DRIVER_VERSION              0716
#endif
#define NV_DRIVER_VERSION_NUMBER       716
#define NV_VERSION_NUMBER               4,12,01,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_NT4           4,00,1381,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_NT5           5,12,01,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_DW            (0x0412010 | NV_DRIVER_VERSION)
#define NV_VERSION_STRING              "7.16"
#define NV_VERSION_MS_STRING           "4.12.01.0716\0"
#define NV_VERSION_MS_STRING_NT4       "4.00.1381.0716\0"
#define NV_VERSION_MS_STRING_NT5       "5.12.01.0716\0"

#define NV_COMPANY_NAME_STRING_SHORT    "NVIDIA"
#define NV_COMPANY_NAME_STRING_FULL     "NVIDIA Corporation"
#define NV_COMPANY_NAME_STRING          NV_COMPANY_NAME_STRING_FULL

#define NV04_PART_NAME_STRING           "RIVA TNT"
#define NV05_PART_NAME_STRING           "RIVA TNT2"
#define NV10_PART_NAME_STRING           "GeForce 256"
#define NV10GL_PART_NAME_STRING         "Quadro"
#define NV11_PART_NAME_STRING           "GeForce2 MX"
#define NV11GL_PART_NAME_STRING         "Quadro2 MXR"
#define NV15_PART_NAME_STRING           "GeForce2 GTS"
#define NV15GL_PART_NAME_STRING         "Quadro2 Pro"
#define NV20_PART_NAME_STRING           "NV20"
#define NV04_COMPAT_PART_NAME_STRING    NV_COMPANY_NAME_STRING_SHORT " Compatible"

#define NV_PART_NAME_STRING             NV04_COMPAT_PART_NAME_STRING



// #define MSBLD               // Defined for MS source builds only
                               // comment out for NVidia builds.
#ifndef MSBLD
#ifndef WIN32
#define VERSION                     NV_VERSION_MS_STRING
#endif


#ifndef _WIN32_WINNT
//
// Use NVidia standard version numbers for Win9x builds.
//
#define VER_PRODUCTVERSION_STR      NV_VERSION_MS_STRING
#define VER_PRODUCTVERSION          NV_VERSION_NUMBER
#define VER_PRODUCTVERSION_DW       NV_VERSION_NUMBER_DW
#else

//
// Use "standard" NT version numbers.
//
#include "ntverp.h"
#endif // #ifdef _WIN32_WINNT
#endif // #ifdef MSBLD




//
// NVDISP.drv NVidia Display Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Display driver, Version X.XX\0"
//
#define NV_NVDISPVER95  NV_PART_NAME_STRING " Windows 95/98 Display driver, Version " NV_VERSION_STRING " \0"

//
//

//
// NV.vxd NVidia Display MiniVDD
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Display MiniVDD, Version X.XX\0"
//
#define NV_NVVDDVER     NV_PART_NAME_STRING " Display MiniVDD, Version " NV_VERSION_STRING " \0"
//
//


//
// NVDD32.DLL NVidia Direct Draw Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVDD32VER    NV_PART_NAME_STRING " Direct Draw Driver, Version " NV_VERSION_STRING " \0"
//
//
//
// NVCPL.DLL NVidia Control Panel Extension
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVCPLVER    NV_COMPANY_NAME_STRING_SHORT " Display Properties Extension\0"


// NVQTWK.DLL NVidia Taskbar Utility Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVTASKBARVER   NV_COMPANY_NAME_STRING_SHORT " Taskbar Utility Library\0"


// NVDESK32.DLL NVidia Desktop Manager Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVDESKMGRVER   NV_COMPANY_NAME_STRING_SHORT " Desktop Manager Hook Library\0"


//
// NVDCI.drv NVidia DCI Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia DCI driver, Version X.XX\0"
//
#define NV_NVDCIVER     NV_PART_NAME_STRING " DCI driver, Version " NV_VERSION_STRING " \0"
//
//

//
//
//
// NVINST32.DLL NVidia Driver Installation Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Driver Insatllation Library, Version X.XX\0"
//
#define NV_NVINST32VER      NV_PART_NAME_STRING " Driver Install Library, Version " NV_VERSION_STRING " \0"

//
//
//
// NVINSTNT.DLL NVidia Driver Installation Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Driver Insatllation Library, Version X.XX\0"
//
#define NV_NVINSTNTVER      NV_PART_NAME_STRING " Driver Install Library, Version " NV_VERSION_STRING " \0"

//
// NVRM NVidia Resource Manager
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Resource Manager DLL, Version X.XX\0"
//
#define NV_NVRMVER      NV_PART_NAME_STRING " Resource Manager, Version " NV_VERSION_STRING " \0"
//
//


//
//
//
// NVDD32.DLL NVidia Direct Draw/Direct 3D Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw 2.x Driver, Version X.XX\0"
//
//#define NV_D3D32VER     NV_PART_NAME_STRING " Direct Draw/Direct 3D Driver, Version " NV_VERSION_STRING " \0"
#define NV_DD32VER      NV_PART_NAME_STRING " Direct Draw/Direct 3D Driver, Version " NV_VERSION_STRING " \0"

//
//
//
// NV4_MINI.SYS NVidia Windows NT Miniport Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Windows NT Miniport Driver, Version X.XX\0"
//
#ifdef _WIN32_WINNT
#if (_WIN32_WINNT < 0x0500)
#define NV_NTMINIVER    NV_PART_NAME_STRING " Windows NT 4.0 Miniport Driver, Version " NV_VERSION_STRING " \0"
#else
#define NV_NTMINIVER    NV_PART_NAME_STRING " Windows 2000 Miniport Driver, Version " NV_VERSION_STRING " \0"
#endif // #else
#endif // #ifdef _WIN32_WINNT

//
//
//
// NV4_DISP.DLL NVidia Windows NT Display Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Windows NT Display Driver, Version X.XX\0"
//
#ifdef _WIN32_WINNT
#if (_WIN32_WINNT < 0x0500)
#define NV_NTDISPVER    NV_PART_NAME_STRING " Windows NT 4.0 Display driver, Version " NV_VERSION_STRING " \0"
#else
#define NV_NTDISPVER    NV_PART_NAME_STRING " Windows 2000 Display driver, Version " NV_VERSION_STRING " \0"
#endif // #else
#endif // #ifdef _WIN32_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvUtil.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _NVUTIL_H_
#define _NVUTIL_H_

#include "nvTypes.h"

// returns the index of the least significant bit = log2(x) if x=2^n
#define ASM_LOG2(x)     __asm mov eax,[x]   __asm bsf ecx,eax   __asm mov [x],ecx
// returns the index of the most significant bit = log2(x) if x=2^n
#define ASM_LOG2_R(x)   __asm mov eax,[x]   __asm bsr ecx,eax   __asm mov [x],ecx

 /***************************************************************************\
|*                                                                           *|
|*                       General nVidia Utilties                             *|
|*                                                                           *|
|*  These are functions like nvAssert, nvStrLen.                             *|
|*                                                                           *|
|*  Various OSes do not provide these functions (or don't provide them in    *|
|*  the environment in which the driver must run), so we define out own.     *|
|*                                                                           *|
|*  This file is OS independant.  Use ONLY nVidia types and names.           *|
|*                                 [eg. No DWORD, use NvU32]                 *|
|*                                                                           *|
 \***************************************************************************/
NvU32 nvStrLen(char *szStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvReg.h ===
/*
 * nvReg.h
 *
 * Registry keys and functions for the NVIDIA drivers
 *
 * Copyright (c) 1997-1999, NVIDIA Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/* Note to OEMs:
   Please leave these strings intact.  There are utilities published on the
   net which let users edit these registry keys, and the utils expect the
   values to be in this location.  It will also allow us to occasionally post
   messages in RIVA-related web sites discussing how these values can affect
   performance and quality.  Thanks!
*/

//*****************************************************************************
// ----------------------------  NOTE  ----------------------------------------
//
// Only #define constants belong in this file.  This file is used for other
// operating systems besides Windows and should be kept clean of Windows
// specific types.
//
// ----------------------------------------------------------------------------
//*****************************************************************************


//-----------------------------------------------------------------------------
// Base
//-----------------------------------------------------------------------------

#define NV_MAX_REG_KEYNAME_LEN 256

#define NV04_REG_PRODUCT_NAME                   "RIVA TNT"
#define NV10_REG_PRODUCT_NAME                   "GeForce 256"
#define NV10GL_REG_PRODUCT_NAME                 "Quadro"

//  There are keys which are global and apply to all NVidia boards in a
//  system and those keys which are board specific. The global keys all
//  use the following path as a base:
#define NV4_REG_GLOBAL_BASE_KEY     HKEY_LOCAL_MACHINE
#define NV4_REG_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global"

//  For each sub-system, the following key should be tacked onto the
//  GLOBAL_BASE_PATH given above and specific registry values for that
// sub-system placed inside the resulting key.
#define NV4_REG_SUBKEY                  "NVidia"
#define NV4_REG_DISPLAY_DRIVER_SUBKEY   "Display"
#define NV4_REG_DIRECT_DRAW_SUBKEY      "DirectDraw"
#define NV4_REG_DIRECT3D_SUBKEY         "Direct3D"
#define NV4_REG_RESOURCE_MANAGER_SUBKEY "System"
#define NV4_REG_OGL_SUBKEY              "OpenGL"
#define NV4_REG_OGL_DEBUG_SUBKEY        "OpenGL\\Debug"
#define NV4_REG_CONTROL_PANEL_SUBKEY    "NVTweak"
#define NV4_REG_DESKTOP_MANAGER_SUBKEY  "NVDesk"
#define NV4_REG_MEDIA_PORT_SUBKEY       "MediaPort"
#define NV4_REG_STEREO_SUBKEY           "Stereo3D"

// For the board specific keys (also called "local" keys), the registry
// path must be run-time determined. An escape has been added to the
// display driver to return a registry path string. Each instance of the
// display driver in a multi-mon system will return a different
// registry path that is specific to the board/slot/device, etc. You
// should use this as the base path for local keys and, as with the
// global keys, tack on one of the above sub-system strings and then
// place your registry values in the resulting key. The escape to
// return the local base path is defined in
// ...drivers\common\win9x\inc\escape.h

//-----------------------------------------------------------------------------
// Display Driver
//-----------------------------------------------------------------------------

// These may be used by many labels
#define NV4_REG_DRV_TRUE                         "1"
#define NV4_REG_DRV_FALSE                        "0"

// This is for QA, so that any mode can be set.
#define NV4_REG_DRV_ALLOW_ALL_MODES             "AllowAllModes"

// This tells what the boot device will be.
#define NV4_REG_DRV_BOOT_DEVICE_TYPE            "ForcedBootDeviceType"

// This tells us whether to use the RM or the reg for getting a
// forced boot device type.
#define NV4_REG_DRV_USE_HW_SELECTED_DEVICE      "UseHwSelectedDevice"

// The physical device attachments are given as PhysicalDevice0,
// PhysicalDevice1, etc. This is the base string.
#define NV4_REG_DRV_PHYSICAL_DEVICE             "PhysicalDevice"

// The following reg keys are string values which always look like
// "xres,yres,bpp"  e.g. "1024,768,16"
#define NV4_REG_DRV_FORCED_DESKTOP_MODE         "ForcedDesktopMode"
#define NV4_REG_DRV_LAST_DESKTOP_MODE           "LastDesktopMode"


// This keeps track of the last tv format
#define NV4_REG_DRV_LAST_TV_FORMAT              "LastTVFormat"

// These are possible values for the LastTVFormat
#define NV4_REG_DRV_NTSCM_TVFORMAT              "NTSCM"
#define NV4_REG_DRV_NTSCJ_TVFORMAT              "NTSCJ"
#define NV4_REG_DRV_PALM_TVFORMAT               "PALM"
#define NV4_REG_DRV_PALA_TVFORMAT               "PALA"
#define NV4_REG_DRV_PALN_TVFORMAT               "PALN"
#define NV4_REG_DRV_PALNC_TVFORMAT              "PALNC"

// The following reg keys are string values which always look like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// These are local keys.
#define NV4_REG_DRV_LAST_CRT_MODE               "LastCRTMode"
#define NV4_REG_DRV_LAST_DFP_MODE               "LastDFPMode"
#define NV4_REG_DRV_LAST_NTSCM_MODE             "LastNTSCMMode"
#define NV4_REG_DRV_LAST_NTSCJ_MODE             "LastNTSCJMode"
#define NV4_REG_DRV_LAST_PALM_MODE              "LastPALMMode"
#define NV4_REG_DRV_LAST_PALA_MODE              "LastPALAMode"
#define NV4_REG_DRV_LAST_PALN_MODE              "LastPALNMode"
#define NV4_REG_DRV_LAST_PALNC_MODE             "LastPALNCMode"

// The following reg keys are string values which always look like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// These are local keys.
#define NV4_REG_DRV_FORCED_MODE                 "ForcedMode"
#define NV4_REG_DRV_LAST_MODE                   "LastMode"

// The following registry values are used when the user requests adapter
// default refresh rate. They are all string values which look like:
// "60" or "75" etc. If the keys do not exist, the adapter default value
// is obtained in another way.
// These are local keys.
#define NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE   "DefaultCRTRefreshRate"
#define NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE   "DefaultDFPRefreshRate"

// The following registry values are used when the user requests optimal
// refresh rate. They are all string values which look like:
// "60" or "75" etc. If the keys do not exist, the optimal refresh value
// is obtained in another way.
// These are local keys.
#define NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE   "OptimalCRTRefreshRate"
#define NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE   "OptimalDFPRefreshRate"

// This registry value is used to override the timing standard used
// for the monitor.
#define NV4_REG_DRV_MONITOR_TIMING                  "MonitorTiming"
#define NV4_REG_DRV_MONITOR_TIMING_DMT              "DMT"
#define NV4_REG_DRV_MONITOR_TIMING_GTF              "GTF"

// This is used for the cursor alpha amount
#define NV4_REG_DRV_CURSOR_ALPHA                    "CursorAlpha"

// The following key is used to indicate that the driver should
// read the EDID and use it. It is a string value and the
// possible options are "0" and "1".
#define NV4_REG_DRV_FORCE_EDID_READ                 "ForceEdidRead"

// The following reg key ius a string value which always looks like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// It is a local key. It gives the highest permissable mode when
// their is no EDID and no INF installed for the monitor.
#define NV4_REG_DRV_MONITOR_LIMIT_MODE              "NoEdidNoInfLimitMode"

// The RestrictOptimal key causes the modeset DLL to look for an
// exact Xres,Yres match with an EDID mode. If one exists, then
// that refresh rate will be the one used. If not, then other
// logic determines the refresh rate. The possible values are
// NV4_REG_DRV_TRUE or NV4_REG_DRV_FALSE
#define NV4_REG_DRV_USE_REFRESH_RATE_OF_XYRES_EDID_MODE_MATCH   "RestrictOptimal"

// These are erased by the driver at boot time.
#define POWERUPFLAGS                                "PowerUpFlags"

// These are used by the driver for dual-head support
#define NV4_REG_DRV_VIRTUALDESKTOP                  "VirtualDesktop"
#define NV4_REG_DRV_AUTOPANMODE                     "AutoPanMode"

// This key is read to indicate whether we should run single monitor,
// multimon or clone mode.
#define NV4_REG_DRV_DESKTOPSTATE                    "DesktopState"
#define NV4_REG_DRV_DESKTOP_STATE_NORMAL            "Single"
#define NV4_REG_DRV_DESKTOP_STATE_MULTI_MON         "Multi"
#define NV4_REG_DRV_DESKTOP_STATE_CLONE             "Clone"


//-----------------------------------------------------------------------------
// DirectDraw
//-----------------------------------------------------------------------------

// default is enabled, define and set to zero to disable
#define NV4_REG_VPE_ENABLE              "VPEENABLE"

// EnumDDRefresh (default = 0)
//      0 = do not enumerate refresh rates
//      1 = only enumerate refresh rates of modes above 640x480
//      2 = enumerate all refresh rates
#define NV4_REG_ENUM_REFRESH                "EnumDDRefresh"
#define   NV4_REG_ENUM_REFRESH_DISABLE      0
#define   NV4_REG_ENUM_REFRESH_ENABLEBIG    1
#define   NV4_REG_ENUM_REFRESH_ENABLEALL    2

// all the overlay settings are local

// OverlayMode (default = 0)
//      0 = always use overlay upscale
//      1 = use vertical blt upscale if sufficient resources
//      2 = use temporal filter
//      3 = this is not the first frame (gets autoset after 1 frame)
//      8-15 = temporal filter factor
#define NV4_REG_OVL_MODE                "OverlayMode"
#define   NV4_REG_OVL_MODE_VUPSCALE     0x1
#define   NV4_REG_OVL_MODE_TFILTER      0x2
#define   NV4_REG_OVL_MODE_NOTFIRST     0x4
#define   NV4_REG_OVL_MODE_TF_PRECOPY   0x8
#define   NV4_REG_OVL_MODE_LATEFLIPSYNC 0x10
#define   NV4_REG_OVL_MODE_DFILTER      0x20
#define   NV4_REG_OVL_MODE_DF_PRECOPY   0x40
#define   NV4_REG_OVL_MODE_TFACTOR      15:8
#define   NV4_REG_OVL_MODE_DFACTOR      23:16

// OverlayMode2 (default = 0)
//   bits 0-3 = Full screen mirror device number (1 based, zero means disable)
//      bit 4 = Preserve aspect in full screen mirror mode
//      bit 5 = Fix aspect ratio to 16:9, bit 4 must be set also
//      bit 6 = Track aspect ratio of overlay, bit 4 must be set also
//      bit 7 = Fix aspect ratio to 4:3, bit 4 must also be set
//      bits 8-11 = Video zoom quadrant
//                  0: zoom disabled
//                  1: top left quadrant
//                  2: top right quadrant
//                  3: bottom left quadrant
//                  4: bottom right quadrant
//                  5: center
//      bits 12-23 = Video zoom factor, 0 = 1x, 255 = 2x
//      bit 24 = Let the driver pick the full screen display mode
//      bit 25 = Track overlay zoom
//      bit 26 = Enable TV devices
#define NV4_REG_OVL_MODE2                       "OverlayMode2"
#define     NV4_REG_OVL_MODE2_FSMASK            0x007FFFFF
#define     NV4_REG_OVL_MODE2_FSDEVICEMASK      0x0000000F
#define     NV4_REG_OVL_MODE2_FSASPECTMASK      0x000000F0
#define     NV4_REG_OVL_MODE2_FSZOOMQUADMASK    0x00000F00
#define     NV4_REG_OVL_MODE2_FSZOOMFACTORMASK  0x000FF000
#define     NV4_REG_OVL_MODE2_FSDEVICE          0:3
#define     NV4_REG_OVL_MODE2_FSASPECT          0x00000010
#define     NV4_REG_OVL_MODE2_FSFIXEDANIMORPHIC 0x00000020
#define     NV4_REG_OVL_MODE2_FSTRACKOVLASPECT  0x00000040
#define     NV4_REG_OVL_MODE2_FSFIXEDTV         0x00000080
#define     NV4_REG_OVL_MODE2_FSZOOMQUAD        8:11
#define     NV4_REG_OVL_MODE2_FSZOOMFACTOR      12:23
#define     NV4_REG_OVL_MODE2_FSSETMODE         0x00100000
#define     NV4_REG_OVL_MODE2_FSTRACKOVLZOOM    0x00200000
#define     NV4_REG_OVL_MODE2_FSENABLETV        0x00400000

// OverlayMode3 (default = 0);
//   bits 8-11 = Overlay zoom quadrant
//               0: zoom disabled
//               1: top left quadrant
//               2: top right quadrant
//               3: bottom left quadrant
//               4: bottom right quadrant
//               5: center
//   bits 12-23: Overlay zoom factor, 0 = 1x, 255 = 2x
#define NV4_REG_OVL_MODE3                       "OverlayMode3"
#define     NV4_REG_OVL_MODE3_OVLZOOMMASK       0x000FFF00
#define     NV4_REG_OVL_MODE3_OVLZOOMQUADMASK   0x00000F00
#define     NV4_REG_OVL_MODE3_OVLZOOMFACTORMASK 0x000FF000
#define     NV4_REG_OVL_MODE3_OVLZOOMQUAD       8:11
#define     NV4_REG_OVL_MODE3_OVLZOOMFACTOR     12:23

// VPPInvMask (default = 0)
//      Inverse mask for all VPP function enables.  Should exactly match
//      command flags defined in ddVPP.h
#define NV4_REG_VPP_INV_MASK                "VPPInvMask"
#define   NV4_REG_VPP_INV_MASK_ODD          0x1
#define   NV4_REG_VPP_INV_MASK_EVEN         0x2
#define   NV4_REG_VPP_INV_MASK_BOB          0x4
#define   NV4_REG_VPP_INV_MASK_INTERLEAVED  0x8
#define   NV4_REG_VPP_INV_MASK_VIDEOPORT    0x10
#define   NV4_REG_VPP_INV_MASK_WAIT         0x20
#define   NV4_REG_VPP_SAVE_STATE_DISABLE    0x40
#define   NV4_REG_VPP_RESTORE_STATE_DISABLE 0x80
#define   NV4_REG_VPP_CONVERT_DISABLE       0x100
#define   NV4_REG_VPP_SUBPICTURE_DISABLE    0x200
#define   NV4_REG_VPP_PRESCALE_DISABLE      0x400
#define   NV4_REG_VPP_COLOURCONTROL_DISABLE 0x800
#define   NV4_REG_VPP_TEMPORAL_DISABLE      0x1000
#define   NV4_REG_VPP_OPTIMIZEFLIP_DISABLE  0x2000
#define   NV4_REG_VPP_DEINTERLACE_DISABLE   0x4000
#define   NV4_REG_VPP_FSMIRROR_DISABLE      0x8000
#define   NV4_REG_VPP_DMABLIT_DISABLE       0x10000
#define   NV4_REG_VPP_MASTER_DISABLE        0x80000000

// VPPMaxSurfaces
//      Determines the maximum number of work surfaces VPP is allowed to use.
//      Legal values are:
//          6 - Full functionality and performance
//          4 - Full functionality, no superpipelining
//          3 - One stage allowed, superpipelined
//          2 - One stage allowed, no superpipelining
//          0 - VPP disabled
#define NV4_REG_VPP_MAX_SURFACES            "VPPMaxSurfaces"

// OverlayColorControlEnable (default = 0)
//      0 = disable
//      1 = enable with vertical chroma subsampling enabled (use this one)
//      2 = enable with vertical chroma subsampling disabled
// OverlayBrightness (default = 0)
// OverlayContrast (default = 100)
// OverlayHue (default = 0)
// OverlaySaturation (default = 100)
// OverlayGamma (not implemented)
// OverlaySharpness (not implemented)
#define NV4_REG_OVLCC_ENABLE            "OverlayColorControlEnable"
#define NV4_REG_OVLCC_BRIGHTNESS        "OverlayBrightness"
#define NV4_REG_OVLCC_CONTRAST          "OverlayContrast"
#define NV4_REG_OVLCC_HUE               "OverlayHue"
#define NV4_REG_OVLCC_SATURATION        "OverlaySaturation"
#define NV4_REG_OVLCC_GAMMA             "OverlayGamma"
#define NV4_REG_OVLCC_SHARPNESS         "OverlaySharpness"

#define NV4_REG_OVLCC_BRIGHTNESS_DEFAULT  0
#define NV4_REG_OVLCC_CONTRAST_DEFAULT    100
#define NV4_REG_OVLCC_HUE_DEFAULT         0
#define NV4_REG_OVLCC_SATURATION_DEFAULT  100


// VideoBusMasterMode (default = 0)
//      Determine which hacks to implement for bus mastering TV tuners (will not work on WINNT)
//      0 = No special hacks
//      1 = If no flips detected and 1 overlay surface, force into autoflip mode
//      2 = If 1 overlay surface, force autoflip
//      3 = Force autoflip
#define NV4_REG_VIDEO_BUS_MASTER_MODE   "VideoBusMasterMode"
#define   NV4_REG_VBMM_NOHACK           0
#define   NV4_REG_VBMM_DETECT           1
#define   NV4_REG_VBMM_SINGLEOVL        2
#define   NV4_REG_VBMM_FORCE            3

//-----------------------------------------------------------------------------
// Direct3D
//-----------------------------------------------------------------------------

// To add registry settings:
// 1. choose a category:
//    boolean, enumerated non-boolean, non-enumerated non-boolean, or string
// 2. add definitions as required for that category. make sure to include a definition
//    for the default value (and PLEASE ALPHABETIZE and use the same ordering for ALL
//    OF WHAT FOLLOWS!)
// 3. add a reg_entry to the definition of reg_struc in global.h
// 4. add the string to the initialization of reg_struc in global.cpp
// 5. add the default value to the initializations at the top of D3DReadRegistry()
// 6. add a routine to actually read and cache the registry value in D3DReadRegistry()

// ------------ Boolean enables / disables ------------------------------------

// Each boolean enable gets one bit in a control word.
#define D3D_REG_BIT_ALTERNATEZENABLE                    0
#define D3D_REG_BIT_ANTIALIASENABLE                     1
#define D3D_REG_BIT_ANTIALIASDYNAMICENABLE              2
#define D3D_REG_BIT_ANTIALIASFORCEENABLE                3
#define D3D_REG_BIT_CKCOMPATABILITYENABLE               5
#define D3D_REG_BIT_CONTROLTRAFFICENABLE                6
#define D3D_REG_BIT_DIRECTMAPENABLE                     8
#define D3D_REG_BIT_ENFORCESTRICTTRILINEAR              10
#define D3D_REG_BIT_FLUSHAFTERBLITENABLE                12
#define D3D_REG_BIT_FOGTABLEENABLE                      13
#define D3D_REG_BIT_FORCEBLITWAITFLAGENABLE             14
#define D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE            15
#define D3D_REG_BIT_LOGOENABLE                          17
#define D3D_REG_BIT_PALETTEENABLE                       18
#define D3D_REG_BIT_SQUASHWENABLE                       19
#define D3D_REG_BIT_SSYNCENABLE                         20
#define D3D_REG_BIT_TEXTURECOMPRESSIONENABLE            21
#define D3D_REG_BIT_TEXTUREMANAGEMENTENABLE             23
#define D3D_REG_BIT_TILINGENABLE                        24
#define D3D_REG_BIT_USERMIPMAPENABLE                    26
#define D3D_REG_BIT_VIDEOTEXTUREENABLE                  27
#define D3D_REG_BIT_WBUFFERENABLE                       28
#define D3D_REG_BIT_Z24ENABLE                           30
#define D3D_REG_BIT_ZCOMPRESSENABLE                     31

// ALTERNATEZENABLE
#define D3D_REG_ALTERNATEZENABLE_STRING                 "ALTERNATEZENABLE"
#define D3D_REG_ALTERNATEZENABLE_MASK                   (1 << D3D_REG_BIT_ALTERNATEZENABLE)
#define D3D_REG_ALTERNATEZENABLE_DISABLE                (0 << D3D_REG_BIT_ALTERNATEZENABLE)
#define D3D_REG_ALTERNATEZENABLE_ENABLE                 (1 << D3D_REG_BIT_ALTERNATEZENABLE)

// ANTIALIASENABLE
#define D3D_REG_ANTIALIASENABLE_STRING                  "ANTIALIASENABLE"
#define D3D_REG_ANTIALIASENABLE_MASK                    (1 << D3D_REG_BIT_ANTIALIASENABLE)         // Enable Anti-Aliasing support.
#define D3D_REG_ANTIALIASENABLE_DISABLE                 (0 << D3D_REG_BIT_ANTIALIASENABLE)         // Disable Anti-Aliasing support.
#define D3D_REG_ANTIALIASENABLE_ENABLE                  (1 << D3D_REG_BIT_ANTIALIASENABLE)         // Enable Anti-Aliasing support.

// ANTIALIASDYNAMICENABLE
#define D3D_REG_ANTIALIASDYNAMICENABLE_STRING           "ANTIALIASDYNAMICENABLE"
#define D3D_REG_ANTIALIASDYNAMICENABLE_MASK             (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Enable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE          (0 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Disable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE           (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Enable Dynamic Anti-Aliasing support.

// ANTIALIASFORCEENABLE
#define D3D_REG_ANTIALIASFORCEENABLE_STRING             "ANTIALIASFORCEENABLE"
#define D3D_REG_ANTIALIASFORCEENABLE_MASK               (1 << D3D_REG_BIT_ANTIALIASFORCEENABLE)
#define D3D_REG_ANTIALIASFORCEENABLE_DISABLE            (0 << D3D_REG_BIT_ANTIALIASFORCEENABLE)
#define D3D_REG_ANTIALIASFORCEENABLE_ENABLE             (1 << D3D_REG_BIT_ANTIALIASFORCEENABLE)

// COLORKEYCOMPATIBILITYENABLE
#define D3D_REG_CKCOMPATABILITYENABLE_STRING            "COLORKEYCOMPATABILITYENABLE"
#define D3D_REG_CKCOMPATABILITYENABLE_MASK              (1 << D3D_REG_BIT_CKCOMPATABILITYENABLE)
#define D3D_REG_CKCOMPATABILITYENABLE_DISABLE           (0 << D3D_REG_BIT_CKCOMPATABILITYENABLE)
#define D3D_REG_CKCOMPATABILITYENABLE_ENABLE            (1 << D3D_REG_BIT_CKCOMPATABILITYENABLE)

// CONTROLTRAFFIC
#define D3D_REG_CONTROLTRAFFICENABLE_STRING             "CONTROLTRAFFIC"
#define D3D_REG_CONTROLTRAFFICENABLE_MASK               (1 << D3D_REG_BIT_CONTROLTRAFFICENABLE)
#define D3D_REG_CONTROLTRAFFICENABLE_DISABLE            (0 << D3D_REG_BIT_CONTROLTRAFFICENABLE)
#define D3D_REG_CONTROLTRAFFICENABLE_ENABLE             (1 << D3D_REG_BIT_CONTROLTRAFFICENABLE)

// DIRECTMAPENABLE
#define D3D_REG_DIRECTMAPENABLE_STRING                  "DIRECTMAPENABLE"
#define D3D_REG_DIRECTMAPENABLE_MASK                    (1 << D3D_REG_BIT_DIRECTMAPENABLE)
#define D3D_REG_DIRECTMAPENABLE_DISABLE                 (0 << D3D_REG_BIT_DIRECTMAPENABLE)
#define D3D_REG_DIRECTMAPENABLE_ENABLE                  (1 << D3D_REG_BIT_DIRECTMAPENABLE)

// ENFORCESTRICTTRILINEAR
#define D3D_REG_ENFORCESTRICTTRILINEAR_STRING           "ENFORCESTRICTTRILINEAR"
#define D3D_REG_ENFORCESTRICTTRILINEAR_MASK             (1 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)
#define D3D_REG_ENFORCESTRICTTRILINEAR_DISABLE          (0 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)
#define D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE           (1 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)

// FLUSHAFTERBLITENABLE
#define D3D_REG_FLUSHAFTERBLITENABLE_STRING              "FLUSHAFTERBLITENABLE"
#define D3D_REG_FLUSHAFTERBLITENABLE_MASK                (1 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)
#define D3D_REG_FLUSHAFTERBLITENABLE_DISABLE             (0 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)
#define D3D_REG_FLUSHAFTERBLITENABLE_ENABLE              (1 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)

// FOGTABLEENABLE
#define D3D_REG_FOGTABLEENABLE_STRING                   "FOGTABLEENABLE"
#define D3D_REG_FOGTABLEENABLE_MASK                     (1 << D3D_REG_BIT_FOGTABLEENABLE)       // Enable Fog Table support
#define D3D_REG_FOGTABLEENABLE_DISABLE                  (0 << D3D_REG_BIT_FOGTABLEENABLE)       // Disable Fog Table support.
#define D3D_REG_FOGTABLEENABLE_ENABLE                   (1 << D3D_REG_BIT_FOGTABLEENABLE)       // Enable Fog Table support

// FORCEBLITWAITFLAGENABLE
#define D3D_REG_FORCEBLITWAITFLAGENABLE_STRING          "FORCEBLITWAITFLAGENABLE"
#define D3D_REG_FORCEBLITWAITFLAGENABLE_MASK            (1 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)
#define D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE         (0 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)
#define D3D_REG_FORCEBLITWAITFLAGENABLE_ENABLE          (1 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)

// LIMITQUEUEDFBBLITSENABLE
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_STRING         "LIMITQUEUEDFBBLITSENABLE"
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_MASK           (1 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE        (0 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_ENABLE         (1 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)

// LOGOENABLE
#define D3D_REG_LOGOENABLE_STRING                       "LOGOENABLE"
#define D3D_REG_LOGOENABLE_MASK                         (1 << D3D_REG_BIT_LOGOENABLE)            // Enable NVIDIA logo
#define D3D_REG_LOGOENABLE_DISABLE                      (0 << D3D_REG_BIT_LOGOENABLE)            // Disable NVIDIA logo
#define D3D_REG_LOGOENABLE_ENABLE                       (1 << D3D_REG_BIT_LOGOENABLE)            // Enable NVIDIA logo

// PALETTEENABLE
#define D3D_REG_PALETTEENABLE_STRING                    "PALETTEENABLE"
#define D3D_REG_PALETTEENABLE_MASK                      (1 << D3D_REG_BIT_PALETTEENABLE)
#define D3D_REG_PALETTEENABLE_DISABLE                   (0 << D3D_REG_BIT_PALETTEENABLE)
#define D3D_REG_PALETTEENABLE_ENABLE                    (1 << D3D_REG_BIT_PALETTEENABLE)

// SQUASHW
#define D3D_REG_SQUASHW_STRING                          "SQUASHW"
#define D3D_REG_SQUASHW_MASK                            (1 << D3D_REG_BIT_SQUASHWENABLE)
#define D3D_REG_SQUASHW_DISABLE                         (0 << D3D_REG_BIT_SQUASHWENABLE)
#define D3D_REG_SQUASHW_ENABLE                          (1 << D3D_REG_BIT_SQUASHWENABLE)

// SSYNCENABLE
// This is a major hack to work around input lag in stupid applications that
// want to use blits instead of flips to do there screen updates but then don't
// make any getblitstatus calls to see if the blit has completed before beginning
// to render the next frame.
// This is not something that you want to have enabled unless you absolutely need
// to have it enabled.
#define D3D_REG_SSYNCENABLE_STRING                      "SCENESYNCENABLE"
#define D3D_REG_SSYNCENABLE_MASK                        (1 << D3D_REG_BIT_SSYNCENABLE)
#define D3D_REG_SSYNCENABLE_DISABLE                     (0 << D3D_REG_BIT_SSYNCENABLE)
#define D3D_REG_SSYNCENABLE_ENABLE                      (1 << D3D_REG_BIT_SSYNCENABLE)

// TEXTURECOMPRESSIONENABLE
#define D3D_REG_TEXTURECOMPRESSIONENABLE_STRING         "TEXTURECOMPRESSIONENABLE"
#define D3D_REG_TEXTURECOMPRESSIONENABLE_MASK           (1 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#define D3D_REG_TEXTURECOMPRESSIONENABLE_DISABLE        (0 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#define D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE         (1 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)

// TEXTUREMANAGEMENTENABLE
#define D3D_REG_TEXTUREMANAGEMENTENABLE_STRING          "TEXTUREMANAGEMENTENABLE"
#define D3D_REG_TEXTUREMANAGEMENTENABLE_MASK            (1 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)
#define D3D_REG_TEXTUREMANAGEMENTENABLE_DISABLE         (0 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)
#define D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE          (1 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)

// TILINGENABLE
#define D3D_REG_TILINGENABLE_STRING                     "TILINGENABLE"
#define D3D_REG_TILINGENABLE_MASK                       (1 << D3D_REG_BIT_TILINGENABLE)
#define D3D_REG_TILINGENABLE_DISABLE                    (0 << D3D_REG_BIT_TILINGENABLE)
#define D3D_REG_TILINGENABLE_ENABLE                     (1 << D3D_REG_BIT_TILINGENABLE)

// USERMIPMAPENABLE - enable User supplied mipmaps
#define D3D_REG_USERMIPMAPENABLE_STRING                 "USERMIPMAPENABLE"
#define D3D_REG_USERMIPMAPENABLE_MASK                   (1 << D3D_REG_BIT_USERMIPMAPENABLE)
#define D3D_REG_USERMIPMAPENABLE_DISABLE                (0 << D3D_REG_BIT_USERMIPMAPENABLE)
#define D3D_REG_USERMIPMAPENABLE_ENABLE                 (1 << D3D_REG_BIT_USERMIPMAPENABLE)

// VIDEOTEXTUREENABLE - enable texturing from video memory
#define D3D_REG_VIDEOTEXTUREENABLE_STRING               "VIDEOTEXTUREENABLE"
#define D3D_REG_VIDEOTEXTUREENABLE_MASK                 (1 << D3D_REG_BIT_VIDEOTEXTUREENABLE)
#define D3D_REG_VIDEOTEXTUREENABLE_DISABLE              (0 << D3D_REG_BIT_VIDEOTEXTUREENABLE)
#define D3D_REG_VIDEOTEXTUREENABLE_ENABLE               (1 << D3D_REG_BIT_VIDEOTEXTUREENABLE)

// WBUFFERING
#define D3D_REG_WBUFFERENABLE_STRING                    "WENABLE"
#define D3D_REG_WBUFFERENABLE_MASK                      (1 << D3D_REG_BIT_WBUFFERENABLE)
#define D3D_REG_WBUFFERENABLE_DISABLE                   (0 << D3D_REG_BIT_WBUFFERENABLE)
#define D3D_REG_WBUFFERENABLE_ENABLE                    (1 << D3D_REG_BIT_WBUFFERENABLE)

// Z24ENABLE
#define D3D_REG_Z24ENABLE_STRING                        "Z24ENABLE"
#define D3D_REG_Z24ENABLE_MASK                          (1 << D3D_REG_BIT_Z24ENABLE)
#define D3D_REG_Z24ENABLE_DISABLE                       (0 << D3D_REG_BIT_Z24ENABLE)
#define D3D_REG_Z24ENABLE_ENABLE                        (1 << D3D_REG_BIT_Z24ENABLE)

// ZCOMPRESSENABLE
#define D3D_REG_ZCOMPRESSENABLE_STRING                  "ZCOMPRESSENABLE"
#define D3D_REG_ZCOMPRESSENABLE_MASK                    (1 << D3D_REG_BIT_ZCOMPRESSENABLE)
#define D3D_REG_ZCOMPRESSENABLE_DISABLE                 (0 << D3D_REG_BIT_ZCOMPRESSENABLE)
#define D3D_REG_ZCOMPRESSENABLE_ENABLE                  (1 << D3D_REG_BIT_ZCOMPRESSENABLE)

//// not currently in use - rel6 maybe?
// ANTIALIASENABLE
#define D3D_REG_ANTIALIASDYNAMICENABLE_STRING           "ANTIALIASDYNAMICENABLE"
#define D3D_REG_ANTIALIASDYNAMICENABLE_MASK             (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Enable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE          (0 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Disable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE           (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Enable Dynamic Anti-Aliasing support.

// Default values for registry configurable driver settings.
#define D3D_REG_DEFAULT_ALTERNATEZENABLE                D3D_REG_ALTERNATEZENABLE_DISABLE
#define D3D_REG_DEFAULT_ANTIALIASENABLE                 D3D_REG_ANTIALIASENABLE_ENABLE            // enable Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASDYNAMICENABLE          D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE     // enable dynamic Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASFORCEENABLE            D3D_REG_ANTIALIASFORCEENABLE_DISABLE      // Disable forced Anti Aliasing.
#define D3D_REG_DEFAULT_CKCOMPATABILITYENABLE           D3D_REG_CKCOMPATABILITYENABLE_ENABLE      // Perform application colorkey fixups.
#define D3D_REG_DEFAULT_CONTROLTRAFFICENABLE            D3D_REG_CONTROLTRAFFICENABLE_ENABLE
#define D3D_REG_DEFAULT_DIRECTMAPENABLE                 D3D_REG_DIRECTMAPENABLE_ENABLE            // Enable Direct Mapping of Texture Combiners by default.
#define D3D_REG_DEFAULT_ENFORCESTRICTTRILINEAR          D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE     // Enforces multitexture-trilinear ot NOT use dithering approximation
#define D3D_REG_DEFAULT_FLUSHAFTERBLITENABLE            D3D_REG_FLUSHAFTERBLITENABLE_DISABLE      // Disable flush after blit on wait flag
#define D3D_REG_DEFAULT_FOGTABLEENABLE                  D3D_REG_FOGTABLEENABLE_ENABLE             // Enable software implemented fog table support.
#define D3D_REG_DEFAULT_FORCEBLITWAITFLAGENABLE         D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE   // Disable force the BLT_WAIT flag
#define D3D_REG_DEFAULT_LIMITQUEUEDFBBLITSENABLE        D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE  // Disable limiting the max number of queued FB blits
#define D3D_REG_DEFAULT_LOGOENABLE                      D3D_REG_LOGOENABLE_DISABLE
#define D3D_REG_DEFAULT_PALETTEENABLE                   D3D_REG_PALETTEENABLE_ENABLE              // Enable 8-bit textures (relevant only >=DX8. always disabled for <=DX7)
#define D3D_REG_DEFAULT_SQUASHW                         D3D_REG_SQUASHW_DISABLE
#define D3D_REG_DEFAULT_SSYNCENABLE                     D3D_REG_SSYNCENABLE_DISABLE               // MAJOR APP HACK should never be enbled by default!!
#define D3D_REG_DEFAULT_TEXTURECOMPRESSIONENABLE        D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE   // Enable Texture compression so we can 'disable' for badly behaving apps
#define D3D_REG_DEFAULT_TEXTUREMANAGEMENTENABLE         D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE    // enable driver-based texture management
#define D3D_REG_DEFAULT_TILINGENABLE                    D3D_REG_TILINGENABLE_ENABLE
#define D3D_REG_DEFAULT_USERMIPMAPENABLE                D3D_REG_USERMIPMAPENABLE_ENABLE           // Enable use of user supplied mip maps
#define D3D_REG_DEFAULT_VIDEOTEXTUREENABLE              D3D_REG_VIDEOTEXTUREENABLE_ENABLE         // Enable texturing from video memory
#define D3D_REG_DEFAULT_WBUFFERENABLE                   D3D_REG_WBUFFERENABLE_ENABLE
#define D3D_REG_DEFAULT_Z24ENABLE                       D3D_REG_Z24ENABLE_ENABLE                  // Enable 24bit z-exports by default
#define D3D_REG_DEFAULT_ZCOMPRESSENABLE                 D3D_REG_ZCOMPRESSENABLE_ENABLE            // Enable z compression by default (applicable to nv20 ff.)

// ----------- Non-boolean settings with enumerated values ------------------

// AntiAliasQuality definitions.
#define D3D_REG_ANTIALIASQUALITY_STRING                 "ANTIALIASQUALITY"
#define D3D_REG_ANTIALIASQUALITY_MIN                    0
#define D3D_REG_ANTIALIASQUALITY_MAX                    7

//// not currently in use - rel6 maybe?
// AntiAliasDynamicFPS definitions.
#define D3D_REG_ANTIALIASDYNAMICFPS_STRING              "ANTIALIASDYNAMICFPS"
#define D3D_REG_ANTIALIASDYNAMICFPS_MIN                 10
#define D3D_REG_ANTIALIASDYNAMICFPS_MAX                 500

// CAPTURE CONFIG
#define D3D_REG_CAPTURECONFIG_STRING                    "CAPTURECONFIG"
#define D3D_REG_CAPTURECONFIG_ALLOC4X                   0x01
#define D3D_REG_CAPTURECONFIG_FORCEPCI                  0x02

// CAPTUREENABLE
#define D3D_REG_CAPTUREENABLE_STRING                    "CAPTUREENABLE"
#define D3D_REG_CAPTUREENABLE_DISABLE                   0x00
#define D3D_REG_CAPTUREENABLE_RECORD                    0x01
#define D3D_REG_CAPTUREENABLE_PLAY                      0x02

// Colorkey Reference Values range.
#define D3D_REG_CKREF_STRING                            "CKREF"
#define D3D_REG_CKREF_MIN                               0x00
#define D3D_REG_CKREF_MAX                               0x7F

// MipMapDitherEnable definitions.
#define D3D_REG_MIPMAPDITHERMODE_STRING                 "ANISOTROPIC4TAP"
#define D3D_REG_MIPMAPDITHERMODE_DISABLE                0           // Disable mipmap dithering (true trilinear)
#define D3D_REG_MIPMAPDITHERMODE_ENABLE                 1           // Enable mipmap dithering (fake trilinear)
#define D3D_REG_MIPMAPDITHERMODE_SMART                  2           // smart dithering (enabled at higher resolutions)
#define D3D_REG_MIPMAPDITHERMODE_MAX                    2

// TexelAlignment definitions.
// Bit flags (bit 0 = ZOH, bit 1 = FOH, bit 2 = Texel Origin)
#define D3D_REG_TEXELALIGNMENT_STRING                  "TEXELALIGNMENT"
#define D3D_REG_TEXELALIGNMENT_ZOH_CENTER               0x00
#define D3D_REG_TEXELALIGNMENT_ZOH_CORNER               0x01
#define D3D_REG_TEXELALIGNMENT_ZOH_MASK                 0x01
#define D3D_REG_TEXELALIGNMENT_FOH_CENTER               0x00
#define D3D_REG_TEXELALIGNMENT_FOH_CORNER               0x02
#define D3D_REG_TEXELALIGNMENT_FOH_MASK                 0x02
#define D3D_REG_TEXELALIGNMENT_TEXEL_CENTER             0x00
#define D3D_REG_TEXELALIGNMENT_TEXEL_CORNER             0x04
#define D3D_REG_TEXELALIGNMENT_TEXEL_MASK               0x04
#define D3D_REG_TEXELALIGNMENT_MAX                      0x07

#define D3D_REG_TEXTUREMANAGESTRATEGY_STRING            "TEXTUREMANAGESTRATEGY"
#define D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE        0x1
#define D3D_REG_TEXTUREMANAGESTRATEGY_LAZY              0x0

// ValidateZMethod definitions.
#define D3D_REG_VALIDATEZMETHOD_STRING                  "VALIDATEZMETHOD"
#define D3D_REG_VALIDATEZMETHOD_FLEXIBLE                0           // Driver will match z-buffer to rendering depth.
#define D3D_REG_VALIDATEZMETHOD_SRTRETURNNOTHANDLED     1           // Same as FLEXIBLE but returns NOTHANDLED from Set Render Target.
#define D3D_REG_VALIDATEZMETHOD_STRICT                  2           // Z-Buffer must always match rendering depth.
#define D3D_REG_VALIDATEZMETHOD_MIXED                   3           // DX6 applications = STRICT, DX5 applications = flexible
#define D3D_REG_VALIDATEZMETHOD_MAX                     3

// V-Sync modes
#define D3D_REG_VSYNCMODE_STRING                        "VSYNCMODE"
#define D3D_REG_VSYNCMODE_PASSIVE                       0           // just do what the app tells us to do
#define D3D_REG_VSYNCMODE_FORCEOFF                      1           // override app and don't vsync
#define D3D_REG_VSYNCMODE_FORCEON                       2           // override app and vsync
#define D3D_REG_VSYNCMODE_MAX                           2

// WFormat definitions.
#define D3D_REG_WFORMAT16_STRING                        "W16FORMAT"
#define D3D_REG_WFORMAT32_STRING                        "W32FORMAT"
#define D3D_REG_WFORMAT_FIXED                           0x1
#define D3D_REG_WFORMAT_FLOAT                           0x2
#define D3D_REG_WFORMAT_MIN                             0x1
#define D3D_REG_WFORMAT_MAX                             0x2

// defaults for the non-boolean enumerated values
#define D3D_REG_DEFAULT_CAPTURCONFIG                    (D3D_REG_CAPTURECONFIG_ALLOC4X | D3D_REG_CAPTURECONFIG_FORCEPCI)
#define D3D_REG_DEFAULT_CAPTURENABLE                    D3D_REG_CAPTUREENABLE_RECORD
#define D3D_REG_DEFAULT_MIPMAPDITHERMODE                D3D_REG_MIPMAPDITHERMODE_SMART          // use true trilinear sometimes
#define D3D_REG_DEFAULT_TEXELALIGNMENT                  (D3D_REG_TEXELALIGNMENT_ZOH_CORNER | D3D_REG_TEXELALIGNMENT_FOH_CORNER | D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
#define D3D_REG_DEFAULT_TEXTUREMANAGESTRATEGY           D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE
#define D3D_REG_DEFAULT_VALIDATEZMETHOD                 D3D_REG_VALIDATEZMETHOD_FLEXIBLE        // D3D_REG_VALIDATEZMETHOD_MIXED
#define D3D_REG_DEFAULT_VSYNCMODE                       D3D_REG_VSYNCMODE_PASSIVE
#define D3D_REG_DEFAULT_W16FORMAT                       D3D_REG_WFORMAT_FIXED
#define D3D_REG_DEFAULT_W32FORMAT                       D3D_REG_WFORMAT_FLOAT

// ------- Non-boolean settings with non-enumerated values ------------------

// Reads nvCelsiusAACompatibility.h
#define D3D_REG_AAREADCOMPATIBILITYFILE_STRING          "AAREADCOMPATIBILITYFILE"

// AntiAliasQuality definitions.
#define D3D_REG_ANTIALIASQUALITY_STRING                 "ANTIALIASQUALITY"
#define D3D_REG_ANTIALIASQUALITY_MIN                    0
#define D3D_REG_ANTIALIASQUALITY_MAX                    7

// AntiAliasDynamicFPS definitions.
#define D3D_REG_ANTIALIASDYNAMICFPS_STRING              "ANTIALIASDYNAMICFPS"
#define D3D_REG_ANTIALIASDYNAMICFPS_MIN                 10
#define D3D_REG_ANTIALIASDYNAMICFPS_MAX                 500

// AGP texture cutoff
#define D3D_REG_AGPTEXCUTOFF_STRING                     "AGPTEXCUTOFF"

// starting number for played capture files
#define D3D_REG_CAPTUREPLAYFILENUM_STRING               "CAPTUREPLAYFILENUM"

// starting number for recorded capture files
#define D3D_REG_CAPTURERECORDFILENUM_STRING             "CAPTURERECORDFILENUM"

// Colorkey Reference Values range.
#define D3D_REG_CKREF_STRING                            "CKREF"
#define D3D_REG_CKREF_MIN                               0x00
#define D3D_REG_CKREF_MAX                               0x7F

// D3D contexts
#define D3D_REG_D3DCONTEXTMAX_STRING                    "D3DCONTEXTMAX"

// D3D contexts
#define D3D_REG_D3DTEXTUREMAX_STRING                    "D3DTEXTUREMAX"

// DPF debug level
#define D3D_REG_DEBUGLEVEL_STRING                       "DEBUGLEVEL"

// LOD bias adjust
#define D3D_REG_LODBIAS_STRING                          "LODBIASADJUST"

// minimum video texture size
#define D3D_REG_MINVIDTEXSIZE_STRING                    "MINVIDEOTEXSIZE"

// size of the pci texture heap. non-zero value will override value determined by the driver
#define D3D_REG_PCITEXHEAPSIZE_STRING                   "PCITEXHEAPSIZE"

// performance strategy
#define D3D_REG_PERFSTRATEGYOR_STRING                   "PSOR"
#define D3D_REG_PERFSTRATEGYAND_STRING                  "PSAND"

// Prerender limits
#define D3D_REG_PRERENDERLIMIT_STRING                   "PRERENDERLIMIT"
#define D3D_REG_PRERENDERLIMIT_MIN                      1
#define D3D_REG_PRERENDERLIMIT_MAX                      1000

// maximum push buffer size
#define D3D_REG_PUSHBUFFERSIZEMAX_STRING                "DMAPUSHBUFFERSIZEMAX"

// WScale 16/24 definitions.
#define D3D_REG_WSCALE16_STRING                         "WSCALE16"
#define D3D_REG_WSCALE24_STRING                         "WSCALE24"
#define D3D_REG_WSCALE16_MAX                            0x00010000
#define D3D_REG_WSCALE24_MAX                            0x01000000

// positively shift z to accomodate apps that give us slightly negtive z
#define D3D_REG_ZBIAS_STRING                            "ZBIAS"

// defaults for the non-boolean, non-enumerated values
#define D3D_REG_DEFAULT_AAREADCOMPATIBILITYFILE         0
#define D3D_REG_DEFAULT_ANTIALIASQUALITY                1
#define D3D_REG_DEFAULT_ANTIALIASDYNAMICFPS             (1000 / 30)
#define D3D_REG_DEFAULT_AGPTEXCUTOFF                    1024
#define D3D_REG_DEFAULT_CAPTUREPLAYFILENUM              0
#define D3D_REG_DEFAULT_CAPTURERECORDFILENUM            0
#define D3D_REG_DEFAULT_CKREF                           D3D_REG_CKREF_MIN
#define D3D_REG_DEFAULT_D3DCONTEXTMAX                   64                  // D3D Context heap allocation max.
#define D3D_REG_DEFAULT_D3DTEXTUREMAX                   1024                // D3D Texture heap allocation max.
#define D3D_REG_DEFAULT_DEBUGLEVEL                      0                   // no debug output
#define D3D_REG_DEFAULT_LODBIASADJUST                   0
#define D3D_REG_DEFAULT_MINVIDEOTEXSIZE                 1                   // minimum texture size to be placed in video memory.
#define D3D_REG_DEFAULT_PCITEXHEAPSIZE                  0                   // size of PCI texture heap. (0 => driver-determined value)
#define D3D_REG_DEFAULT_PRERENDERLIMIT                  3
#define D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX               0x40000             // maximum push buffer size.
#define D3D_REG_DEFAULT_WSCALE16                        D3D_REG_WSCALE16_MAX
#define D3D_REG_DEFAULT_WSCALE24                        D3D_REG_WSCALE24_MAX
#define D3D_REG_DEFAULT_ZBIAS                           0.f

// ------------------------------- Strings ----------------------------------

#define D3D_REG_STRING_LENGTH                           64                  // maximum allowed string length

// push-buffer capture playback file name
#define D3D_REG_CAPTUREPLAYFILENAME_STRING              "CAPTUREPLAYFILENAME"

// push-buffer capture playback path
#define D3D_REG_CAPTUREPLAYPATH_STRING                  "CAPTUREPLAYPATH"

// push-buffer capture recording path
#define D3D_REG_CAPTURERECORDFILENAME_STRING            "CAPTURERECORDFILENAME"

// push-buffer capture recording path
#define D3D_REG_CAPTURERECORDPATH_STRING                "CAPTURERECORDPATH"

// string defaults
#define D3D_REG_DEFAULT_CAPTUREPLAYFILENAME             "capture"
#define D3D_REG_DEFAULT_CAPTUREPLAYPATH                 "c:\\"
#define D3D_REG_DEFAULT_CAPTURERECORDFILENAME           "capture"
#define D3D_REG_DEFAULT_CAPTURERECORDPATH               "c:\\"


//-----------------------------------------------------------------------------
// OpenGL
//-----------------------------------------------------------------------------

#define NV4_REG_OGL_BUFFER_FLIPPING_CONTROL             "FlippingControl"
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_BLIT      0
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_FLIP      1
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_AUTO      2
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_DEFAULT   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_AUTO

#define NV_REG_OGL_BUFFER_REGION_EXT                    "BufferRegionExt"
#define   NV_REG_OGL_BUFFER_REGION_EXT_OFF              0
#define   NV_REG_OGL_BUFFER_REGION_EXT_ON               1
#define   NV_REG_OGL_BUFFER_REGION_EXT_DEFAULT          NV_REG_OGL_BUFFER_REGION_EXT_ON

#define NV_REG_OGL_BUFFER_REGION_USE_VIDMEM             "BufferRegionUseVidMem"
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_OFF       0
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_ON        1
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_DEFAULT   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_ON

#define NV_REG_OGL_DEBUG_RENDERER                       "Renderer"
#define   NV_REG_OGL_DEBUG_RENDERER_NVIDIA              0
#define   NV_REG_OGL_DEBUG_RENDERER_SOFTWARE            1
#define   NV_REG_OGL_DEBUG_RENDERER_MICROSOFT           2

#define NV_REG_OGL_DEBUG_PMENABLE                       "PMEnable"
#define   NV_REG_OGL_DEBUG_PMENABLE_ENABLED             1
#define   NV_REG_OGL_DEBUG_PMENABLE_DISABLED            0

#define NV_REG_OGL_DEFAULT_SWAP_INTERVAL                "DefaultSwapInterval"
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_TEAR         0
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_VSYNC        1
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_DISABLE      0xffffffff
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_DEFAULT      NV_REG_OGL_DEFAULT_SWAP_INTERVAL_VSYNC

#define NV_REG_OGL_FORCE_GEFORCE                        "ForceGeForce"
#define NV_REG_OGL_MAX_NVACCEL                          "MaxNVACCEL"

#define NV_REG_OGL_NV15_ALINES                          "NV15Alines"
#define   NV_REG_OGL_NV15_ALINES_ACTUAL                 0
#define   NV_REG_OGL_NV15_ALINES_FORCE                  1
#define   NV_REG_OGL_NV15_ALINES_DISABLE                2

#define NV_REG_OGL_VERTEX_PROGRAM                       "VertexProgram"
#define   NV_REG_OGL_VERTEX_PROGRAM_OPTIMIZE            0
#define   NV_REG_OGL_VERTEX_PROGRAM_NO_LIVEDEAD         1

#define NV_REG_OGL_TRIPLE_BUFFER                        "EnableTripleBuffer"
#define   NV_REG_OGL_TRIPLE_BUFFER_DISABLE              0
#define   NV_REG_OGL_TRIPLE_BUFFER_ENABLE               1
#define   NV_REG_OGL_TRIPLE_BUFFER_DEFAULT              NV_REG_OGL_TRIPLE_BUFFER_DISABLE

#define NV_REG_OGL_WINDOW_FLIPPING                      "EnableWindowFlipping"
#define   NV_REG_OGL_WINDOW_FLIPPING_ENABLE             1
#define   NV_REG_OGL_WINDOW_FLIPPING_DISABLE            0
#define   NV_REG_OGL_WINDOW_FLIPPING_DEFAULT            NV_REG_OGL_WINDOW_FLIPPING_DISABLE

#define NV_REG_OGL_OVERLAY_SUPPORT                      "EnableOverlaySupport"
#define NV_REG_OGL_OVERLAY_SUPPORT_OFF                  0
#define NV_REG_OGL_OVERLAY_SUPPORT_ON                   1
#define NV_REG_OGL_OVERLAY_SUPPORT_DEFAULT              NV_REG_OGL_OVERLAY_SUPPORT_OFF

#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS           "OverlayMergeBlitTimerMs"
#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS_DEFAULT   40 //ms
#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS_OFF       0  //0ms => off

// MSchwarzer 9/28/00 these keys are used to enable bundles of bugfixes for special applications
#define NV_REG_OGL_APPLICATION_KEY                      "ApplicationKey"
#define NV_REG_OGL_APPLICATION_KEY_NONE                 0
#define NV_REG_OGL_APPLICATION_KEY_STANDARD             1
#define NV_REG_OGL_APPLICATION_KEY_SOFTIMAGE3D          2
#define NV_REG_OGL_APPLICATION_KEY_3DSMAX               3
#define NV_REG_OGL_APPLICATION_KEY_3DPAINT              4
#define NV_REG_OGL_APPLICATION_KEY_MAYA                 5
#define NV_REG_OGL_APPLICATION_KEY_LIGHTSCAPE           6
#define NV_REG_OGL_APPLICATION_KEY_DEFAULT              NV_REG_OGL_APPLICATION_KEY_NONE

#define NV_REG_OGL_FORCE_16BIT_Z                        "EnableForce16BitZ"
#define NV_REG_OGL_FORCE_16BIT_Z_DISABLE                0
#define NV_REG_OGL_FORCE_16BIT_Z_ENABLE                 1
#define NV_REG_OGL_FORCE_16BIT_Z_DEFAULT                NV_REG_OGL_FORCE_16BIT_Z_DISABLE

#define NV_REG_OGL_ZTRICK                               "EnableZEnhancement"
#define NV_REG_OGL_ZTRICK_DISABLE                       0
#define NV_REG_OGL_ZTRICK_ENABLE                        1
#define NV_REG_OGL_ZTRICK_DEFAULT                       NV_REG_OGL_ZTRICK_ENABLE

#define NV_REG_OGL_DISPLAY_DRIVER                       "EnableDisplayDriver"

#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER              "EnableSingleBackDepthBuffer"
#define NV_REG_OGL_SINGLE_BACKDEPTH_DISABLE             0
#define NV_REG_OGL_SINGLE_BACKDEPTH_ENABLE              1
#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER_DEFAULT      NV_REG_OGL_SINGLE_BACKDEPTH_DISABLE

#define NV_REG_OGL_DMAPUSH_BUFSIZE_WORDS                "CmdBufSizeWords"

#define NV_REG_OGL_DMAPUSH_MIN_PUSH_COUNT               "CmdBufMinWords"

#define NV_REG_OGL_DL_STAGING_BUFFER_SIZE_WORDS         "DLStagingBufferSizeWords"
#define NV_REG_OGL_DL_STAGING_BUFFER_SIZE_WORDS_DEFAULT ((9*1024*1024)/4)

#define NV_REG_OGL_TARGET_FLUSHCOUNT                    "TargetFlushCount"

#define NV_REG_OGL_FAST_COPY_PIXELS                     "EnableFastCopyPixels"

#define NV_REG_OGL_FORCE_MULTITEX                       "ForceMultiTexture"

#define NV_REG_OGL_MAX_FRAMES_ALLOWED                   "MaxFramesAllowed"

#define NV_REG_OGL_MAX_TEX_SIZE                         "MaxTexSize"

#define NV_REG_OGL_MIN_VIDMEM_TEX_WIDTH                 "VidMemMinTexWidth"

#define NV_REG_OGL_PCI_TEXHEAP_SIZE                     "MaxPCITexHeapSize"
#define NV_REG_OGL_PCI_TEXHEAP_SIZE_DEFAULT             (5*1024*1024)
#define NV_REG_OGL_PCI_TEXHEAP_SIZE_MAX_NT              (16*1024*1024)

#define NV_REG_MULTI_MONITOR_ADVANCED_ENABLE            "MultiMonAdvEnable"
#define NV_OGL_DEFAULT_MULTI_MONITOR_ADVANCED_ENABLE    0

#define NV_REG_OGL_RENDER_QUALITY_FLAGS                 "RenderQualityFlags"
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_MMDITHER        0x00000001
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_ANISOENABLE     0x00000002

/* Default texel size */
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_MASK     0x0000000c
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_AUTO     0x00000000
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_16       0x00000004
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_32       0x00000008
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_RESERVED 0x0000000c

/* One Minus Depth Buffering */
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_ONE_MINUS_Z     0x00000010

#define NV_REG_OGL_RENDER_QUALITY_FLAGS_DEFAULT         (0)

#define NV4_REG_OGL_TEX_MEMORY_SPACE_ENABLES            "TexMemorySpaceEnables"

#define NV4_REG_OGL_PALETTED_TEX_IN_VID_MEM             "PalettedTexInVidMem"

#define NV4_REG_OGL_TEX_PRECACHE                        "TexturePrecache"

#define NV4_REG_OGL_TEX_STAGING_BUFFER_SIZE             "TexStagingBufferSize"
#define NV4_REG_OGL_TEX_STAGING_BUFFER_SIZE_DEFAULT     (512*1024)

#define NV4_REG_OGL_TEX_STAGING_BUFFER_MULT_SIZE        "TexStagingBufferMultSize"
#define NV4_REG_OGL_STAGING_BUFFER_MULT_SIZE_DEFAULT    (256*1024)

#define NV_REG_OGL_TEXTURE_QUALITY                      "TextureQuality"

#define NV_REG_OGL_FULLSCENE_ANTIALIASING               "EnableFSAA"
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_ENABLED       1
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_DISABLED      0
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_DEFAULT       NV_REG_OGL_FULLSCENE_ANTIALIASING_DISABLED

#define NV_REG_OGL_FSAA_QUALITY                         "FSAAQuality"
#define NV_REG_OGL_FSAA_QUALITY_15x15                   0 // 1.5x1.5
#define NV_REG_OGL_FSAA_QUALITY_2x2_LODBIAS             1
#define NV_REG_OGL_FSAA_QUALITY_2x2                     2
#define NV_REG_OGL_FSAA_QUALITY_DEFAULT                 NV_REG_OGL_FSAA_QUALITY_15x15
#define NV_REG_OGL_FSAA_QUALITY_MAXIMUM                 2 // clamp to [0,this]

#define NV_REG_OGL_S3TC_QUALITY                         "S3TCQuality"
#define NV_REG_OGL_S3TC_QUALITY_FORCE_DXT3              1
#define NV_REG_OGL_S3TC_QUALITY_Q3_LIGHTMAPS_HACK       2
#define NV_REG_OGL_S3TC_QUALITY_DEFAULT                 0

#define NV_REG_OGL_FORCE_GENERIC_CPU                    "ForceGenericCPU"
#define NV_REG_OGL_FORCE_GENERIC_CPU_ON                 1
#define NV_REG_OGL_FORCE_GENERIC_CPU_OFF                0
#define NV_REG_OGL_FORCE_GENERIC_CPU_DEFAULT            NV_REG_OGL_FORCE_GENERIC_CPU_OFF

#define NV_REG_OGL_APP_SOFTIMAGE                        "App_SoftImage"
#define NV_REG_OGL_APP_SOFTIMAGE_DEFAULT                0
#define NV_REG_OGL_APP_SOFTIMAGE_38                     38
#define NV_REG_OGL_APP_SOFTIMAGE_39                     39

#define NV_REG_OGL_APP_SUPPORTBITS                      "App_SupportBits"
#define NV_REG_OGL_APP_SUPPORTBITS_DEFAULT              0
#define NV_REG_OGL_APP_SUPPORTBITS_SYNCGDI              0x00000001
#define NV_REG_OGL_APP_SUPPORTBITS_PROE_2000I2          0x00000002

#define NV_REG_OGL_NV20_EMULATE                         "NV20Emulate"
#define NV_REG_OGL_NV20_EMULATE_ON                      1
#define NV_REG_OGL_NV20_EMULATE_OFF                     0
#define NV_REG_OGL_NV20_EMULATE_DEFAULT                 NV_REG_OGL_FORCE_GENERIC_CPU_OFF

#define NV_REG_OGL_SERVER_SWAP_NT4                      "ServerSwapNT4"
#define NV_REG_OGL_SERVER_SWAP_NT4_DEFAULT              0

/* OGL Capture file */
#define NV_REG_OGL_CAPTURE_ENABLE                       "CaptureEnable"
#define NV_REG_OGL_CAPTURE_ENABLE_DISABLE               0x00
#define NV_REG_OGL_CAPTURE_ENABLE_RECORD                0x01
#define NV_REG_OGL_CAPTURE_ENABLE_PLAY                  0x02
#define NV_REG_OGL_CAPTURE_ENABLE_DEFAULT               NV_REG_OGL_CAPTURE_ENABLE_RECORD

#define NV_REG_OGL_CAPTURE_RECORD_PATH                  "CaptureRecordPath"
#define NV_REG_OGL_CAPTURE_RECORD_PATH_DEFAULT          "c:\\"
#define NV_REG_OGL_CAPTURE_RECORD_FILENAME              "CaptureRecordFilename"
#define NV_REG_OGL_CAPTURE_RECORD_FILENAME_DEFAULT      "capture"

#define NV_REG_OGL_CAPTURE_PLAY_PATH                    "CapturePlayPath"
#define NV_REG_OGL_CAPTURE_PLAY_PATH_DEFAULT            "c:\\"
#define NV_REG_OGL_CAPTURE_PLAY_FILENAME                "CapturePlayFilename"
#define NV_REG_OGL_CAPTURE_PLAY_FILENAME_DEFAULT        "capture"

#define NV_REG_OGL_CAPTURE_WHEN_FLIP                    1
#define NV_REG_OGL_CAPTURE_WHEN_READPIXELS              2

#define NV_REG_OGL_CAPTURE_RECORD_WHEN                  "CaptureRecordWhen"
#define NV_REG_OGL_CAPTURE_RECORD_WHEN_DEFAULT          NV_REG_OGL_CAPTURE_WHEN_FLIP

#define NV_REG_OGL_CAPTURE_PLAY_WHEN                    "CapturePlayWhen"
#define NV_REG_OGL_CAPTURE_PLAY_WHEN_DEFAULT            NV_REG_OGL_CAPTURE_WHEN_FLIP

#define NV_REG_OGL_CAPTURE_PLAY_WHERE                   "CapturePlayWhere"
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_FRONT             0
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_BACK              1
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_DEFAULT           NV_REG_OGL_CAPTURE_PLAY_WHERE_FRONT



//-----------------------------------------------------------------------------
// ResMan
//-----------------------------------------------------------------------------

#define NV_REG_SYS_SUPER7_COMPATIBILITY                 "Super7Compat"
#define PERSISTENT_AGP_SIZE                             "PersistAGPSize"
#define NV_MAX_AGP_SIZE                                 "MaxAGPSize"
#define NV5_REG_SYS_HSYNC_FLIP                          "FlipOnHSync"
#define MAXREFRESHRATE                                  "MaxRefreshRate"
#define MAXOPTIMALREFRESHRATE                           "MaxOptimalRefreshRate"
#define OPTIMALREFRESHNOTFROMEDID                       "OptimalRefreshNotFromEDID"
#define DMTOVERRIDE                                     "DMTOVERRIDE"
#define MONITORTIMING                                   "MonitorTiming"
#define CURSORCACHE                                     "CursorCache"
#define DISPLAY_TYPE                                    "Display Type"
#define DISPLAY2_TYPE                                   "Display2 Type"
#define TV_TYPE                                         "TV Type"
#define POWERUPFLAGS                                    "PowerUpFlags"
#define TV_OUT                                          "TV Out"
#define NEWSTYLEMODESET                                 "NewStyleModeSet"
#define FLATPANELMODE                                   "FlatPanelMode"
#define RESOURCE_MANAGER_SUBKEY_ADDITION                "NVIDIA"


// Forces the push buffer to reside in a particular location.  Used by ddraw
// and OGL.  This is a local key.  Setting this will override the Super7Compat key
#define NV_REG_SYS_PB_LOCATION                          "PushBufferLocale"
#define   NV_REG_SYS_PB_LOCATION_DEFAULT                0
#define   NV_REG_SYS_PB_LOCATION_SYSTEM                 1
#define   NV_REG_SYS_PB_LOCATION_AGP                    2
#define   NV_REG_SYS_PB_LOCATION_VIDEO                  3

//-----------------------------------------------------------------------------
// Control Panel
//-----------------------------------------------------------------------------

#define NV_REG_CPL_D3D_SETTINGS_SUBKEY                   NV4_REG_DIRECT3D_SUBKEY
#define NV_REG_CPL_OGL_SETTINGS_SUBKEY                   NV4_REG_OGL_SUBKEY

#define NV_REG_CPL_COLOR_SUBKEY                          "Color"
#define NV_REG_CPL_COLOR_VALUE_CURRENT                   "Current"

#define NV_REG_CPL_COLOR_SCHEMES_SUBKEY                  "Schemes"

#define NV_REG_CPL_TV_OUT_SUBKEY                         "TVOut"

#define NV_REG_CPL_OEM_DEFAULTS_SUBKEY                   "Defaults"

#define NV_REG_CPL_DISPLAY_MODES_SUBKEY                  "DisplayModes"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_MONITOR           "Analog Monitor"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_DFP               "Digital Flat Panel"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_TV                "TV"

#define NV_REG_CPL_OVL_SETTINGS_SUBKEY                   "Overlay"

#define NV_REG_CPL_VALUE_UNLOCK_GOODIES                  "CoolBits"
#define NV_REG_CPL_DATA_UNLOCK_GOODIES_VSYNC             0x00000001
#define NV_REG_CPL_DATA_UNLOCK_GOODIES_HWCLOCK           0x00000002

#define NV_REG_HARDWARE_SUBKEY                           "Hardware"
#define NV_REG_HARDWARE_CLOCK_ENABLE                     "Marge"    // overclocking enable
#define NV_REG_HARDWARE_CLOCK_CONTROL_USER               "Krusty"   // user defined clock speeds
#define NV_REG_HARDWARE_CLOCK_CONTROL_DEFAULT            "Bart"     // BIOS default clock speeds
#define NV_REG_HARDWARE_CLOCK_ENCRYPT_FLAGS              "Homer"    // encryption flags
#define NV_REG_HARDWARE_CLOCK_NO_WARN_DLG                "Lisa"     // turn off warning dialog
#define NV_REG_HARDWARE_CLOCK_DETECT_VALUE               "NvHardwareControl"
#define NV_REG_HARDWARE_CLOCK_DETECT_CMD_LINE            "RUNDLL32.EXE NVQTWK.DLL,NvHWCtl"
#define NV_REG_HARDWARE_CLOCK_INIT_VALUE                 "NvInitialize"
#define NV_REG_HARDWARE_CLOCK_INIT_CMD_LINE              "RUNDLL32.EXE NVQTWK.DLL,NvXTInit"

#define NV_REG_DESK_MANAGER_VALUE_NAME                   "DesktopManager"   //XXX deprecated!
#define NV_REG_DESK_MANAGER_HOTKEY_SUBKEY                "HotKeys"  //XXX deprecated!
#define NV_REG_DESK_MANAGER_APPASSOC_SUBKEY              "Apps"
#define NV_REG_DESK_MANAGER_APPASSOC_DESKTOP             "Desktop"
#define NV_REG_DESK_MANAGER_APPASSOC_MONITOR             "StartingMonitor"
#define NV_REG_DESK_MANAGER_APPASSOC_FLAGS               "Flags"
#define NV_REG_DESK_MANAGER_APPASSOC_PLACEMENT           "Placement"
#define NV_REG_DESK_MANAGER_APPASSOC_CLASS               "Class"
#define NV_REG_DESK_MANAGER_GLOBALS_SUBKEY               "Globals"
#define NV_REG_DESK_MANAGER_GLOBALS_FLAGS                "Flags"
#define NV_REG_DESK_MANAGER_GLOBALS_TLSCREEN             "TLScreen"
#define NV_REG_DESK_MANAGER_GLOBALS_HKMOVE               "HKMove"
#define NV_REG_DESK_MANAGER_GLOBALS_HKMOVEALL            "HKMoveAll"
#define NV_REG_DESK_MANAGER_GLOBALS_HKSWITCH             "HKSwitch"
#define NV_REG_DESK_MANAGER_GLOBALS_HKGATHER             "HKGather"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOM               "HKZoom"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOMIN             "HKZoomIn"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOMOUT            "HKZoomOut"
#define NV_REG_DESK_MANAGER_GLOBALS_ALTTABMON            "CoolSwitchMon"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMLEVEL            "DefaultZoomLevel"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMREFRESH          "ZoomRefreshRate"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMWKEYS            "ZoomWheelKeys"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMDELAY            "ZoomSwitchDelay"
#define NV_REG_DESK_MANAGER_CPLPOS                       "PanelPos"

/////////////////////////////////////
// bit flags for the QuickTweak properties settings

#define NV_REG_CPL_GLOBAL_VALUE_QUICKTWEAK_FLAGS         "QuickTweak"

#define NV_REG_CPL_GLOBAL_DATA_QUICKTWEAK_DEFAULT        0x00010020

#define NV_REG_FLAGS_NOCONFIRM                           0x00000001
#define NV_REG_FLAGS_LBUTTON                             0x00000010
#define NV_REG_FLAGS_RBUTTON                             0x00000020
#define NV_REG_FLAGS_BOTHBUTTONS                         0x00000030
#define NV_REG_FLAGS_COOLMENUS                           0x00000100
#define NV_REG_FLAGS_TASKBAR_LOGO                        0x00010000
#define NV_REG_FLAGS_TASKBAR_BLUE                        0x00020000
#define NV_REG_FLAGS_TASKBAR_RED                         0x00040000
#define NV_REG_FLAGS_DEFAULT                             (NV_REG_FLAGS_RBUTTON | NV_REG_FLAGS_TASKBAR_LOGO)


/////////////////////////////////////
// bit flags for hiding particular property pages or dialogs
#define NV_REG_CPL_HIDE_PROPPAGES          "NoPages"

#define NVCPL_HIDE_COLOR_PAGE              0x00000001
#define NVCPL_HIDE_D3D_PAGE                0x00000002
#define NVCPL_HIDE_OGL_PAGE                0x00000004
#define NVCPL_HIDE_OVERLAY_PAGE            0x00000008
#define NVCPL_HIDE_OPTIONS_PAGE            0x00000010
#define NVCPL_HIDE_TASKBAR_PAGE            NVCPL_HIDE_OPTIONS_PAGE
#define NVCPL_HIDE_OUTPUT_DEVICE_PAGE      0x00000020
#define NVCPL_HIDE_CRT_POSITIONING_DLG     0x00000040
#define NVCPL_HIDE_DFP_POSITIONING_DLG     0x00000080
#define NVCPL_HIDE_TV_POSITIONING_DLG      0x00000100
#define NVCPL_HIDE_INTERNET_OPTIONS        0x00000200
#define NVCPL_HIDE_CRT_TIMING_DLG          0x00000400
#define NVCPL_HIDE_ALL_CRT_SETTINGS        (NVCPL_HIDE_CRT_POSITIONING_DLG | NVCPL_HIDE_CRT_TIMING_DLG)
#define NVCPL_HIDE_SHOW_COMBO_AA_PAGE      0x00000800

#ifdef  STEREO_SUPPORT
//-----------------------------------------------------------------------------
// Registry settings for stereo support. For now are sitting in the Global section.
//-----------------------------------------------------------------------------
#define NV_REG_STEREO_ENABLED                            "StereoEnable"                //Stereo can be potentially activated.
#define NV_REG_STEREO_STEREOVIEWER                       "StereoViewer"                //Defines the name of the stereo viewer driver.
#define NV_REG_STEREO_ADJUSTENABLED                      "StereoAdjustEnable"          //Allow stereo adjustments by hot keys.
#define NV_REG_STEREO_DISABLE_TnL                        "StereoDisableTnL"            //Disables hardware T&L. Allowes to reach more stereo effect.
#define NV_REG_STEREO_SEPARATION                         "StereoSeparation"            //Pre-transformed separation (ProjectMatrix.31).
#define NV_REG_STEREO_CONVERGENCE                        "StereoConvergence"           //Pre-transformed convergence (ProjectMatrix.41).
#define NV_REG_STEREO_CONVERGENCEMULTIPLIER              "StereoConvergenceMultiplier" //Defines correlation between pre and post-transformed convergence.
#define NV_REG_STEREO_RHW2DDETECTIONMIN                  "RHW2DDetectionMin"           //RHW far limit for 2D object detection.
#define NV_REG_STEREO_RHWGREATERATSCREEN                 "RHWGreaterAtScreen"          //Objects closer than this boundary are 2D.
#define NV_REG_STEREO_RHWEQUALATSCREEN                   "RHWEqualAtScreen"            //All objects parallel to screen are 2D.
#define NV_REG_STEREO_RHWLESSATSCREEN                    "RHWLessAtScreen"             //All objects parallel to screen are 2D.
#define NV_REG_STEREO_AUTOCONVERGENCE                    "AutoConvergence"             //Automatically focus on the closest object.
#define NV_REG_STEREO_CONVERGENCEADJUSTPACE              "AutoConvergenceAdjustPace"   //Per frame Convergence adjust pace in AutoConvergence mode.
#define NV_REG_STEREO_HOTKEY_TOGGLE                      "StereoToggle"                //The hot key to toggle stereo.
#define NV_REG_STEREO_HOTKEY_VERTICALADJUST_MORE         "StereoVerticalAdjustMore"    //The hot key to increase the vertical separation.
#define NV_REG_STEREO_HOTKEY_VERTICALADJUST_LESS         "StereoVerticalAdjustLess"    //The hot key to reduce the vertical separation.
#define NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_MORE       "StereoHorizontalAdjustMore"  //The hot key to increase the horizontal separation.
#define NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_LESS       "StereoHorizontalAdjustLess"  //The hot key to reduce the horizontal separation.
#define NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_MORE      "StereoConvergenceAdjustMore" //The hot key to increase the convergence degree.
#define NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_LESS      "StereoConvergenceAdjustLess" //The hot key to reduce the convergence degree.
#define NV_REG_STEREO_FAVORSZ                            "FavorSZ"                     //Rather use SZ in stereo calculations than RHW
#define NV_REG_STEREO_LASERSIGHT                         "LaserSight"                  //Use Nvidia proprietary laser sight.
#define NV_REG_STEREO_DEFAULTON                          "StereoDefaultOn"             //Turn stereo on when the game starts
#define NV_REG_STEREO_FRUSTUMADJUSTMODE                  "FrustumAdjustMode"           //0 - do nothing, 1 - stretch in X, 2 - clear corresponding edges for each eye.

#endif  //STEREO_SUPPORT

//----------------End of file NVREG.H----(do not edit below this line or remove this line) -----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\vesa\vesadata.h ===
#ifndef _VESADATA_H_
#define _VESADATA_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/


//*****************************************************************************
//
// Definition of display timing terms:
//
//
//  <------------------><--------><-------><------><-------><--------><--------
//
//     Active Display     Border    Porch    Sync    Porch    Border    Active
//
//
//  <---------------------------------------------------------------->
//  Total
//
//  <------------------>
//  Visible
//
//  <---------------------------->
//  Blank Start
//
//  <------------------------------------->
//  Sync Start
//
//  <--------------------------------------------->
//  Sync End
//
//  <------------------------------------------------------>
//  Blank End
//
//*****************************************************************************

#ifndef BUFFER_HSYNC_NEGATIVE
// nvrm.h also defines these. So check if it is already defined.
#define BUFFER_HSYNC_NEGATIVE           1
#define BUFFER_HSYNC_POSITIVE           0
#define BUFFER_VSYNC_NEGATIVE           1
#define BUFFER_VSYNC_POSITIVE           0

#endif

typedef struct _mode_timing_values
{  
    unsigned int HorizontalVisible; 
    unsigned int VerticalVisible;
    unsigned int Refresh;
    unsigned int HorizontalTotal; 
    unsigned int HorizontalBlankStart; 
    unsigned int HorizontalRetraceStart; 
    unsigned int HorizontalRetraceEnd; 
    unsigned int HorizontalBlankEnd;
    unsigned int VerticalTotal; 
    unsigned int VerticalBlankStart; 
    unsigned int VerticalRetraceStart; 
    unsigned int VerticalRetraceEnd; 
    unsigned int VerticalBlankEnd;
    unsigned int PixelClock;
    unsigned int HSyncpolarity; 
    unsigned int VSyncpolarity; 
} MODE_TIMING_VALUES;

unsigned int vesaGetGTFTimings (unsigned int hRes, 
                                unsigned int vRes, 
                                unsigned int refreshRate, 
                                MODE_TIMING_VALUES * timingInfo);
unsigned int vesaGetDMTTimings (unsigned int hRes, 
                                unsigned int vRes, 
                                unsigned int refreshRate, 
                                MODE_TIMING_VALUES * timingInfo);

unsigned int vesaGetNumGTFEntries(void);


#endif // _VESADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv4\nv10.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV10.C
//
// Abstract:
//
//     This is code specific to NV10
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"
#include "vesadata.h"

#include "nvos.h"
#include "rm.h"

#include "nvreg.h"
#include "nvcm.h"

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV10ChipFBPowerSave(PHW_DEVICE_EXTENSION);
VOID NV10ChipFBPowerRestore(PHW_DEVICE_EXTENSION);

//******************************************************************************
// External Declarations
//******************************************************************************

//******************************************************************************
// Hack -> Eventually, we want to include the official
//         NVREF.H file, located in \kernel\resman\inc.
//         However, since this miniport already has an nvref.h file,
//         we'll have to pick and choose.  This will all get
//         overhauled when the miniport is re-architected.
//******************************************************************************

#define NV_PGRAPH_TILE(i)                       (0x00400b00+(i)*16) /* RW-4A */
#define NV_PGRAPH_TLIMIT(i)                     (0x00400b04+(i)*16) /* RW-4A */
#define NV_PGRAPH_TSIZE(i)                      (0x00400b08+(i)*16) /* RW-4A */
#define NV_PBUS_DEBUG_1                                  0x00001084

#define NV_PRAMIN_DATA032(i)                     (0x00700000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                            524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                31:0 /* RWXVF */


#define NV_PFB_TIMING2                                   0x00100228 /* RW-4R */
#define NV_PFB_TIMING2_REFRESH                                 15:5 /* RW-VF */
#define NV_PFB_CFG                                       0x00100200 /* RW-4R */
#define NV_PFB_CSTATUS                                   0x0010020C /* R--4R */
#define NV_PFB_REFCTRL                                   0x00100210 /* RW-4R */
#define NV_PFB_MRS                                       0x001002C0 /* RW-4R */
#define NV_PFB_EMRS                                      0x001002C4 /* RW-4R */
#define NV_PFB_REF                                       0x001002D0 /* -W-4R */

//******************************************************************************
//
// Function:    NV10ChipFBPowerSave()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV10ChipFBPowerSave (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    // power down mode - max out memory refresh value
    HwDeviceExtension->Power_refresh = REG_RD32(NV_PFB_TIMING2);   // refresh
    FLD_WR_DRF_NUM(_PFB, _TIMING2, _REFRESH, 0xFFFFFFFF);       // max refresh
    // Chip has been init'd with the BIOS init tables, unless the BIOS
    // has an incompatible structure and the table was not found, in which case
    // we used a default table, which may not have the correct RAM config, so
    // we save away the current config for restoration above.
    HwDeviceExtension->Power_PfbBoot0     = REG_RD32(NV_PFB_CFG);           // RAM config
    HwDeviceExtension->Power_PfbConfig0   = REG_RD32(NV_PFB_CSTATUS);       // RAM config
    HwDeviceExtension->Power_PfbConfig1   = REG_RD32(NV_PFB_REFCTRL);       // RAM config
    HwDeviceExtension->Power_PfbMrs       = REG_RD32(NV_PFB_MRS);           // RAM config
    HwDeviceExtension->Power_PfbEmrs      = REG_RD32(NV_PFB_EMRS);          // RAM config
    HwDeviceExtension->Power_PfbRef       = REG_RD32(NV_PFB_REF);           // RAM config
    HwDeviceExtension->Power_PbusDebug1   = REG_RD32(NV_PBUS_DEBUG_1);      // RAM config
    HwDeviceExtension->Power_PextdevBoot0 = REG_RD32(NV_PEXTDEV_BOOT_0);    // READ STRAPS
    HwDeviceExtension->Power_PfifoRamHT   = REG_RD32(NV_PFIFO_RAMHT);
    HwDeviceExtension->Power_PfifoRamRO   = REG_RD32(NV_PFIFO_RAMRO);
    HwDeviceExtension->Power_PfifoRamFC   = REG_RD32(NV_PFIFO_RAMFC);

    }



//******************************************************************************
//
// Function:    NV10ChipFBPowerRestore()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV10ChipFBPowerRestore (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 D0_DELAY_RETRIES = 10; 
    U032 retry = 0;             
    U032 i;                     

    // power up mode - restore previous memory config
    REG_WR32(NV_PBUS_DEBUG_1, HwDeviceExtension->Power_PbusDebug1);   // must set FBI differential
    REG_WR32(NV_PFB_TIMING2, HwDeviceExtension->Power_refresh);       // refresh
    REG_WR32(NV_PFB_CFG, HwDeviceExtension->Power_PfbBoot0);          // RAM config
    REG_WR32(NV_PFB_CSTATUS, HwDeviceExtension->Power_PfbConfig0);    // RAM config
    REG_WR32(NV_PFB_REFCTRL, HwDeviceExtension->Power_PfbConfig1);    // RAM config
    REG_WR32(NV_PFB_MRS, HwDeviceExtension->Power_PfbMrs);    		 // RAM config
//  REG_WR32(NV_PFB_EMRS, HwDeviceExtension->Power_PfbEmrs);    		 // RAM config - reset
    REG_WR32(NV_PFB_REF, HwDeviceExtension->Power_PfbRef);    		 // RAM config

//  A delay seems to be necessary for i820 for win9x.
//  Couldn't demonstrate a problem with W2K, so its here for safety.
//  Reading NV_PMC_ENABLE is simply a convenient delay    
    while (REG_RD32(NV_PEXTDEV_BOOT_0) != HwDeviceExtension->Power_PextdevBoot0)
        {
        for (i=0; i<2000; i++)
            {
            REG_RD32(NV_PMC_ENABLE);
            }
        REG_WR32(NV_PEXTDEV_BOOT_0, HwDeviceExtension->Power_PextdevBoot0);    // WRITE STRAP REG
        retry++;
        if (retry == D0_DELAY_RETRIES)
            break;
        }
    REG_WR32(NV_PFIFO_RAMHT, HwDeviceExtension->Power_PfifoRamHT);      
    REG_WR32(NV_PFIFO_RAMRO, HwDeviceExtension->Power_PfifoRamRO);      
    REG_WR32(NV_PFIFO_RAMFC, HwDeviceExtension->Power_PfifoRamFC);      

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nvVPP.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  File:       nvVPP.h
 *  Content:    Video Post Processing
 *
 ***************************************************************************/

#ifndef _NVVPP_H_
#define _NVVPP_H_

#include "CompileControl.h"

#include "nvTypes.h"
#include "ddProcMan.h"
#include "nvPusher.h"
#include "nvUniversal.h"
#include "nvMultiMon.h" // Need twinview definition

// {BFD51181-16C4-11d4-8E67-00104B9D3738}
static const GUID GUID_NV_OVERLAY_INFO = { 0xbfd51181, 0x16c4, 0x11d4, { 0x8e, 0x67, 0x0, 0x10, 0x4b, 0x9d, 0x37, 0x38 } };

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Objects created and destroyed by the VPP code
//  Note: IID = instance ID
// TBD: lots of the code in ddraw common assumes these objects exist and interact with them
//   directly.  They should be changed to access them only through VPP routines. -mlavoie
#define NV_VPP_SWIZZLE_BLIT_IID                     0xDD00B000
#define NV_VPP_OVERLAY_IID                          0xDD00B010
#define NV_VPP_V2V_FORMAT_Y_IID                     0xDD00B020
#define NV_VPP_ALPHA_BLIT_IID                       0xDD00B030
#define NV_VPP_TIMER_IID                            0xDD00B040


#define NV_VPP_VIDEO_MEMORY_TO_OVERLAY_SHADOW_FORMAT_IID   0xDD003FE4
#define NV_VPP_OVERLAY_SHADOW_TO_VIDEO_MEMORY_FORMAT_IID   0xDD003FE5

#define NV_VPP_MAX_OVERLAY_SURFACES  10
#define NV_VPP_MAX_EXTRA_SURFACES    6
#define NV_VPP_MAX_EXTRA_FS_SURFACES 4


// vppVPPandFlip flags
#define VPP_ODD             NV4_REG_VPP_INV_MASK_ODD
#define VPP_EVEN            NV4_REG_VPP_INV_MASK_EVEN
#define VPP_BOB             NV4_REG_VPP_INV_MASK_BOB
#define VPP_INTERLEAVED     NV4_REG_VPP_INV_MASK_INTERLEAVED
#define VPP_VIDEOPORT       NV4_REG_VPP_INV_MASK_VIDEOPORT
#define VPP_WAIT            NV4_REG_VPP_INV_MASK_WAIT
#define VPP_SAVE_STATE      NV4_REG_VPP_SAVE_STATE_DISABLE
#define VPP_RESTORE_STATE   NV4_REG_VPP_RESTORE_STATE_DISABLE
#define VPP_CONVERT         NV4_REG_VPP_CONVERT_DISABLE
#define VPP_SUBPICTURE      NV4_REG_VPP_SUBPICTURE_DISABLE
#define VPP_PRESCALE        NV4_REG_VPP_PRESCALE_DISABLE
#define VPP_COLOURCONTROL   NV4_REG_VPP_COLOURCONTROL_DISABLE
#define VPP_TEMPORAL        NV4_REG_VPP_TEMPORAL_DISABLE
#define VPP_OPTIMIZEFLIP    NV4_REG_VPP_OPTIMIZEFLIP_DISABLE
#define VPP_DEINTERLACE     NV4_REG_VPP_DEINTERLACE_DISABLE
#define VPP_FSMIRROR        NV4_REG_VPP_FSMIRROR_DISABLE
#define VPP_DMABLIT_DISABLE NV4_REG_VPP_DMABLIT_DISABLE
#define VPP_MASTER_DISABLE  NV4_REG_VPP_MASTER_DISABLE
// TBD: why redefine these?  Note that master disable WAS being used directly anyway. - mlavoie

#define VPP_ALL             (VPP_CONVERT | VPP_SUBPICTURE | VPP_PRESCALE | VPP_COLOURCONTROL | VPP_DEINTERLACE | VPP_TEMPORAL | VPP_FSMIRROR)
#define VPP_STATIC          (VPP_CONVERT | VPP_SUBPICTURE | VPP_PRESCALE | VPP_COLOURCONTROL | VPP_FSMIRROR)
#define VPP_MOCOMP          (VPP_PRESCALE | VPP_FSMIRROR)

#define IS_OVERLAY(caps,fourcc) ((caps & DDSCAPS_OVERLAY) && (fourcc != FOURCC_NVDS) && (fourcc != FOURCC_NVMC))
#define IS_FIELD(f) ((f & (VPP_INTERLEAVED | VPP_BOB)) && (f & (VPP_ODD | VPP_EVEN)))

#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.

// dispatcher commands
#define VPPDISPATCH_NOOP            0x0
#define VPPDISPATCH_DISPATCH        0x1
#define VPPDISPATCH_SETPRIORITY     0x2
#define VPPDISPATCH_RESTOREPRIORITY 0x4
#define VPPDISPATCH_EXIT            0xFFFFFFFF

// dispatcher state
#define VPPDSTATE_WAITING           0x1
#define VPPDSTATE_BUSY              0x2
#define VPPDSTATE_INITERROR         0x10000
#define VPPDSTATE_CMDERROR          0x20000
#define VPPDSTATE_TERMINATED        0x80000000

#endif

#ifdef DEBUG
    // so we know when something is drastically wrong
    #define VPP_TIMEOUT_TIME    250
    // snooping automatically enabled unless we're on NT where it doesn't work
    #ifndef WINNT
    #define VPP_SNOOP           1
    #endif
#else  // !DEBUG
    // maximum time we can spend on a frame
    #define VPP_TIMEOUT_TIME    42
    #ifdef DEVELOP
        #ifndef WINNT
        #define VPP_SNOOP       1
        #endif
    #endif  // DEVELOP
#endif  // !DEBUG

typedef struct {
  NvF32 sx;
  NvF32 sy;
  NvF32 sz;
  NvF32 rhw;
  NvV32 color;
  NvV32 specular;
  NvF32 tu0;
  NvF32 tv0;
  NvF32 tu1;
  NvF32 tv1;
} Tlmtvertex;

typedef struct Vpp_s Vpp_t;

void VppConstructor(GLOBALDATA *pDriverData,Vpp_t *pVpp);
void VppDestructor(Vpp_t *pVpp);

BOOL VppReadRegistry(Vpp_t *pVpp);


// Exported Functions
NvU8 VppPrepareResources(
    Vpp_t           *pVpp,
    CPushBuffer     *pPusher,
    NV_SystemInfo_t *pSysInfo,
    NvU32            hChannel,
    NvU32            hThreeDClass,
    NvU32            threeDClassSubCh,
    NvU8             threeDClassType,
    NvU32            hInVideoMemContextDma,
    NvU32            hFromVideoMemContextDma,
    NvU32            hToVideoMemContextDma,
    NvU32            hLutCursorDac,
    NvU32            hOverlayDmaToMemNotifier,
    NvU32            hOverlayFlipNotifier,
    NvU32            hMiscEventNotifier,
    NvU32            hContextSurfaceSwizzled,
    NvU32            hContextBeta4,
    NvU32            hSurfaces2D,
    NvU32            surfaces2DSubCh,
    NvU32            hVideoMemUtoVideoMemFormat,    // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat,    // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat,    // UV-conversion object
    NvU32            hDvdSubpicture,
    NvU32            hContextPattern,
    NvU32            hContextColorKey,
    NvU32            hGenericScaledImage,
    NvU32            hFloatingContextDmaInOverlayShadow,
    NvNotification  *pFlipOverlayNotifier,  // The above hOverlayFlipNotifier MUST be really wrong! -mlavoie
    NvNotification  *pFlipPrimaryNotifier,  
    NvNotification  *pPusherSyncNotifier,
    NvNotification  *pColorControlNotifier,

    NvU32            hContextSurfacesARGB_ZS,
    NvU32            hDX6MultiTextureTriangle,
    NvU32            hTimer,

    NvU32            ropRectTextSubCh,
    NvU32            ropSubCh,
    NvU32            spareSubCh);


NvU8 VppSetOverlayColourControl(Vpp_t *pVpp);

BOOL VppEnable(Vpp_t *pVpp);
void VppDisable(Vpp_t *pVpp);
BOOL VppEnableFSMirror(Vpp_t *pVpp, DWORD dwWidth, DWORD dwHeight);
void VppDisableFSMirror(Vpp_t *pVpp);
BOOL VppDoFlip(Vpp_t *pVpp,DWORD dwOffset, DWORD dwPitch, DWORD dwWidth,
                   DWORD dwHeight, DWORD dwFourCC, DWORD dwFlags);

#if (IS_WINNT5 | IS_WIN9X)
#define NV_GET_VIDEO_HEAP_FREE() (DWORD)vpp.pDriverData->VideoHeapFree

#elif (IS_WINNT4)
#define NV_GET_VIDEO_HEAP_FREE() (DWORD)vpp.pDriverData->ppdev->VideoHeapFree

#else
#error Unsupported OS.
#endif

/*
 * NV_ColorControl_t
 *    'Derived' from DDCOLORCONTROL for multi-OS compatibility
 */
#define NV_VPP_COLOR_BRIGHTNESS		0x00000001l // Field validity flags
#define NV_VPP_COLOR_CONTRAST		0x00000002l
#define NV_VPP_COLOR_HUE			0x00000004l
#define NV_VPP_COLOR_SATURATION		0x00000008l
#define NV_VPP_COLOR_SHARPNESS		0x00000010l
#define NV_VPP_COLOR_GAMMA			0x00000020l
#define NV_VPP_COLOR_COLORENABLE	0x00000040l

typedef struct {
    NvU32               dwLastFlags;
    NvU32               dwLastExec;
    NvU32               dwMarker1;
    NvU32               dwReserved1;

    LONGLONG            qwCount;    // TBD: what to do with LONGLONG? -mlavoie
    
    LONGLONG            qwInterFrameTime;
    LONGLONG            qwInterFrameAcc;
    LONGLONG            qwInterFramePeak;
    LONGLONG            qwInterFrameDelta;
    LONGLONG            qwInterFrameJitterAcc;
    LONGLONG            qwInterFrameJitterPeak;

    LONGLONG            qwIntraFrameAcc;
    LONGLONG            qwIntraFramePeak;
    LONGLONG            qwIntraFrameDelta;
    LONGLONG            qwIntraFrameJitterAcc;
    LONGLONG            qwIntraFrameJitterPeak;

    LONGLONG            qwMarker2;
    LONGLONG            qwReserved2;
} Vpp_snoop_t;


typedef struct NV_ColorControl_s
{
    NvU32 		dwSize;
    NvU32		dwFlags;
    NvS32		lBrightness;
    NvS32		lContrast;
    NvS32		lHue;
    NvS32 		lSaturation;
    NvS32		lSharpness;
    NvS32		lGamma;
    NvS32		lColorEnable;
    NvU32		dwReserved1;
} Nv_ColorControl_t;

// Experimental struct (may replace overlay corresponding vars with this as well)
typedef struct Nv_Surface_s
{
    NvU32       format; // TBD: enumerate - mlavoie
    NvU32       originX;
    NvU32       originY;
    NvU32       pitch;
    NvU32       width;
    NvU32       height;
    NvU32       offset; // General offset?  Unsure -mlavoie
} Nv_Surface_t;


#define NV_MAX_EXTRA_FS_SURFACES 4

// Copied from DDMINI.H - mlavoie

/* Shared Celsius class usage flags */
#define CELSIUSUSER_NONE                0  // celsius object is untouched and (almost) fully uninitialized
#define CELSIUSUSER_D3D                 1
#define CELSIUSUSER_DDRAW               2
#define CELSIUSUSER_DDRAW_VPP           3

#define VPP_3D_CLASS_IS_UNDEFINED 0
#define VPP_3D_CLASS_IS_CELSIUS   1
#define VPP_3D_CLASS_IS_KELVIN    2

#define VPP_FLAG_CONSTRUCTED    0x00000001 // VPP class has been initialized
#define VPP_FLAG_READY          0x00000002 // Resources have been assigned, and VPP is ready to be enabled
#define VPP_FLAG_ENABLED        0x00000004 // VPP has been enabled and is running
#define VPP_FLAG_CELSIUS_3D     0x00000008 // VPP is using a celsius class as it's 3D object
#define VPP_FLAG_KELVIN_3D      0x00000010 // VPP is using a kelvin class as it's 3D object

typedef struct {
    NvU32               dwOpCount;
    HDRVEVENT           hLastStage;
    NvU8                doLateFlipSync;
    NvU32               dwIndex;
    NvU32               dwSrcOffset;
    NvU32               dwSrcPitch;
    NvU32               dwWidth;
    NvU32               dwHeight;
    NvU32               dwFourCC;
    NvU32               dwFlags;
    NvU32               dwWorkSurfaces;
    NvU32               vppExec;
    LONGLONG            qwTime1;
    LONGLONG            qwTime2;
    LONGLONG            qwDelta;
    LONGLONG            qwJitter;
} Vpp_pipeline_state_t;

// Note: The 3D class object is used for "advanced" blts that are not possible
//  using the normal bltter.  Surfaces are treated as textures and texture ops
//  are applied to get the desired results.
//
// TBD: turn this into a proper class (if we can get away from C enough) - mlavoie
//
typedef struct Vpp_s
{
    NvU32             dwFlags; // General flags detailing state of the VPP object (see VPP_FLAG_*)

    DWORD             dwOverlayEventsAllocated;        // used to keep track of overlay event allocation

    GLOBALDATA      *pDriverData;          // Hope to eliminate this some day. -mlavoie

    CPushBuffer      *pPusher;             // A cmd pusher class attached to a DMA push buffer
    NV_SystemInfo_t  *pSysInfo;  // System Information
    
    NvU32            hChannel;
    NvU32            hThreeDClass;        // Unique object ID for the 3D object to be used
    NvU32            threeDClassSubCh;    // Subchannel that _always_ holds the 3D class object
    NvU32            hInVideoMemContextDma;      // DMA context for V2V 
    NvU32            hFromVideoMemContextDma;    // DMA context for V2S
    NvU32            hToVideoMemContextDma;      // DMA context for S2V
    NvU32            hOverlayDmaToMemNotifier; // must be context DMA to memory type
    NvU32            hOverlayFlipNotifier;       // This appears to be a dma notifier too?!?! -mlavoie

    NvU32            hLutCursorDacBase;   // Base object ID for DACs (1 per head)
    NvU32            hMiscEventNotifier;   // Used as the notifier in many cases
    NvU32            hContextSurfaceSwizzled;
    NvU32            hContextBeta4;
    NvU32            hSurfaces2D;
    NvU32            surfaces2DSubCh;       // May be able to just use spare? -mlavoie

    NvU32            hVideoMemUtoVideoMemFormat;    // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat;    // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat;    // UV-conversion object

    NvU32            hContextPattern;
    NvU32            hContextColorKey;


    NvU32            hDvdSubpicture;
    NvU32            hGenericScaledImage;
    NvU32            hFloatingContextDmaInOverlayShadow;

    NvNotification  *pFlipOverlayNotifier;  // The above hOverlayFlipNotifier MUST be really wrong! -mlavoie
    NvNotification  *pFlipPrimaryNotifier;
    NvNotification  *pPusherSyncNotifier;
    NvNotification  *pColorControlNotifier; // This isn't really for color control! -mlavoie rename

    NvU32            hContextSurfacesARGB_ZS;
    NvU32            hDX6MultiTextureTriangle;
    NvU32            hTimer;

    NvU32            ropRectTextSubCh;
    NvU32            ropSubCh;
    NvU32            spareSubCh;          // General use subchannel (SetObject always done first)

    // TBD:hMiscEventNotifier was using NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER which IS NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER -mlavoie

    NvU32            dwOverlayFSNumSurfaces;
    NvU32            dwOverlayFSHead;    //what head is overlay on over is head on
    NvU32            dwOverlayFSOvlHead; // where mirror is
    NvU32            dwOverlayFSOvlHeadSaved;
    NvU32            dwOverlayFSOvlLost;

    NvU32            dwOverlayFSOldOffset;
    NvU32            dwOverlayFSWidth;
    NvU32            dwOverlayFSHeight;
    NvU32            dwOverlayFSPitch;
    NvU32            dwOverlayFSFormat;
    NvU32            dwOverlayFSOffset[NV_VPP_MAX_EXTRA_FS_SURFACES];

    NvU32   dwOverlayFSIndex;
    NvU32   dwOverlayFSDeltaX;
    NvU32   dwOverlayFSDeltaY;

    // Size & offset of each of the extra surfaces used to run the VPP engine
    NvU32   extraOverlayOffset[NV_VPP_MAX_EXTRA_SURFACES];   // can be up to n "chunks" longer original surface
    NvU32   extraPitch;
    NvU32   extraNumSurfaces;
    NvU32   extraIndex; // Next 'extra' surface to be used

    NvU32   dwOverlaySurfaces;
    NvU32   dwOverlayOwner;
    NvU32   dwOverlaySurfaceLCL[NV_VPP_MAX_OVERLAY_SURFACES];
    NvU32   dwOverlaySrcWidth;
    NvU32   dwOverlaySrcHeight;
    NvU32   dwOverlayDstWidth;
    NvU32   dwOverlayDstHeight;
    NvU32   dwOverlayDeltaX;
    NvU32   dwOverlayDeltaY;

    NvU32   dwOverlaySrcX;          // overlay source starting point
    NvU32   dwOverlaySrcY;
    NvU32   dwOverlayDstX;        // overlay Dst starting point
    NvU32   dwOverlayDstY;
    NvU32   dwOverlaySrcOffset;
    NvU32   dwOverlayFormat;      // current overlay format - used so VDD knows what's up!
    NvU32   dwOverlaySrcPitch;    // current overlay pitch   - used so VDD knows what's up!
///
    NvU32   dwOverlayLastVisibleSurfaceLCL;
    NvU32   dwOverlayLastVisibleFpVidMem;
    NvU32   dwOverlayLastVisiblePitch;
    NvU32   dwOverlayLastVisiblePixelFormat;
    NvU32   dwOverlayFlipCount;
    NvU16   overlayBufferIndex;
    NvU16   overlayRelaxOwnerCheck;
    NvU32   dwOverlaySrcSize;
    NvU32   dwOverlayColorKey;

    NvU32                       dwOverlayCachedFlags;
    NvU32                       dwOverlayFSSrcWidth;
    NvU32                       dwOverlayFSSrcHeight;
    NvU32                       dwOverlayFSSrcMinX;
    NvU32                       dwOverlayFSSrcMinY;
    NVTWINVIEWDATA              dwOverlayFSTwinData;
    NvU32                       fpOverlayShadow;
    NvU32                       dwOverlayMaxDownScale;
    NvU32                       dwOverlayMaxDownScaleX;
    NvU32                       dwOverlayMaxDownScaleY;
    NvU32                       regOverlayColourControlEnable;
    NvU32                       dwOverlayByteAlignmentPad;
    NvU32                       regOverlayMode;
    NvU32                       regOverlayMode2;
    NvU32                       regOverlayMode3;
    NvU32                       regVPPInvMask;
    NvU32                       regVPPMaxSurfaces;

    NvU32                       regRing0ColourCtlInterlockFlags;    // bit0 = 1 -> ring0 should run; bit2 = 1 ring0 in progress
   


    NvU32                       dwOverlayMode;            // used to tell if we're doing interleaved or what...
//    VPPDISPATCH                 vppDispatch;          No longer used.
///

    NvU32                       dwPrevFrameOffset;

    __int64                     llDeliveryPeriod;    // in ns
    __int64                     llDeliveryTime;      // in ns
    __int64                     llDeliveryStart;     // in ns

    Nv_ColorControl_t    colorCtrl;

    Nv_Surface_t         subPicture; // Dvd Subpicture

    Vpp_pipeline_state_t pipeState;

    Vpp_snoop_t          snoop;

} Vpp_t;


#define DEFAULT_FINAL_CW0   (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0 << 24) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0 << 16) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0 << 8) |     \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |    \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |      \
                             NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C

#define DEFAULT_KELVIN_FINAL_CW0   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0 << 24) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0 << 16) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0 << 8) |     \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |    \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |      \
                                    NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C

// TBD: add CELSIUS to the following - mlavoie
#define DEFAULT_FINAL_CW1   (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |      \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C << 8) |     \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) | \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) | \
                             NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE

#define DEFAULT_KELVIN_FINAL_CW1   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |      \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C << 8) |     \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) | \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) | \
                                    NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE

#ifdef __cplusplus
}
#endif // __cplusplus

#endif _NVVPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\vtxpgmconsts.h ===
/*
** vtxpgmconsts.h
**
** Vertex Program Constant Declarations.
**
** Copyright 2000 NVIDIA, Corporation.  All rights reserved.
** 
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/

#ifndef __gl_vtxpgmconsts_h_
#define __gl_vtxpgmconsts_h_

#pragma warning (disable:4244)  /* Disable bogus VC++ 4.2 conversion warnings. */
#pragma warning (disable:4305)  /* VC++ 5.0 version of above warning. */

/*
** This file is shared between OpenGL and D3D so don't mess with it!
*/

/*
** Constants used for programs:
*/

#define __GL_NUMBER_OF_VERTEX_ATTRIBS       16
#define __GL_NUMBER_OF_PROGRAM_MATRICES     8
#define __GL_NUMBER_OF_TEMPORARY_REGISTERS  12
#define __GL_NUMBER_OF_RESULT_REGISTERS     16
#define __GL_NUMBER_OF_CONSTANT_REGISTERS   96
#define __GL_NUMBER_OF_PADDING_REGISTERS    128
#define __GL_MAX_NUMBER_OF_INSTRUCTIONS     128

#define __GL_KELVIN_FIRST_USER_CONSTANT_REGISTER    96


/*
** Names for each of the vertex attributes
*/

#define __GL_ATTRIB_POSITION            0
#define __GL_ATTRIB_VERTEX_WEIGHT       1
#define __GL_ATTRIB_NORMAL              2
#define __GL_ATTRIB_COLOR               3
#define __GL_ATTRIB_SECONDARY_COLOR     4
#define __GL_ATTRIB_FOG_COORD           5
#define __GL_ATTRIB_UNUSED0             6
#define __GL_ATTRIB_UNUSED1             7
#define __GL_ATTRIB_TEXCOORD0           8
#define __GL_ATTRIB_TEXCOORD1           9
#define __GL_ATTRIB_TEXCOORD2           10
#define __GL_ATTRIB_TEXCOORD3           11
#define __GL_ATTRIB_TEXCOORD4           12
#define __GL_ATTRIB_TEXCOORD5           13
#define __GL_ATTRIB_TEXCOORD6           14
#define __GL_ATTRIB_TEXCOORD7           15

/*
** Names for the output components:
*/

#define __GL_ATTRIB_OUTPUT_HPOS         0
#define __GL_ATTRIB_OUTPUT_COL0         3
#define __GL_ATTRIB_OUTPUT_COL1         4
#define __GL_ATTRIB_OUTPUT_BFC0         7
#define __GL_ATTRIB_OUTPUT_BFC1         8
#define __GL_ATTRIB_OUTPUT_FOGC         5
#define __GL_ATTRIB_OUTPUT_PSIZ         6
#define __GL_ATTRIB_OUTPUT_TEX0         9
#define __GL_ATTRIB_OUTPUT_TEX1         10
#define __GL_ATTRIB_OUTPUT_TEX2         11
#define __GL_ATTRIB_OUTPUT_TEX3         12
#define __GL_ATTRIB_OUTPUT_TEX4         13
#define __GL_ATTRIB_OUTPUT_TEX5         14
#define __GL_ATTRIB_OUTPUT_TEX6         15
#define __GL_ATTRIB_OUTPUT_TEX7         15

/*
** Enable bits tested by compiled x886 code:
*/

#define __GL_PROGRAM_ENABLE_TEXTURE0    1
#define __GL_PROGRAM_ENABLE_TEXTURE1    2

#endif /* __gl_vtxpgmconsts_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\vtxpgmcomp.h ===
/*
** vtxpgmcomp.h
**
** Vertex Program Declarations.
**
** Copyright 2000 NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/

/*
** This file is shared between OpenGL and D3D so don't mess with it!
**
** In particular, don't use any OpenGL or D3D specific types.  There are
** plenty of perfectly good types in the C language itself.
**
*/

#ifndef __gl_vtxpgmcomp_h_
#define __gl_vtxpgmcomp_h_

#include "vtxpgmconsts.h"

#define NV_INTERNAL_OPCODES 1

/*
** Optimization flags:
*/

#define OPT_LIVE_DEAD 1
#define OPT_ALL       1

/*
** Structures for instruction description.
*/

typedef enum OpcodeClasses_Enum {
    CLASS_ARL = 0,
    CLASS_VECTOR,
    CLASS_SCALAR,
    CLASS_BIN,
    CLASS_TRI,
    CLASS_END,
} OpcodeClasses;

typedef enum Opcodes_Enum {

    // END op:

    OP_END = 0,
#if defined(NV_INTERNAL_OPCODES)
    OP_NOP,
#endif

    // ARL op:

    OP_ARL,

    // VECTOR ops:

    OP_LIT, OP_MOV,
#if defined(NV_INTERNAL_OPCODES)
    OP_IMV,
#endif

    // SCALAR ops:

    OP_EXP, OP_LOG, OP_RCP, OP_RSQ,
#if defined(NV_INTERNAL_OPCODES)
    OP_RCC,
#endif

    // BIN ops:

    OP_ADD, OP_DP3, OP_DP4, OP_DST, OP_MAX, OP_MIN, OP_MUL, OP_SGE, OP_SLT,
#if defined(NV_INTERNAL_OPCODES)
    OP_DPH,
#endif

    // TRI op:

    OP_MAD,
} Opcodes;

#define VERTEX_PROGRAM_OPCODE_NAMES                                         \
    "END", "NOP",                                                           \
    "ARL",                                                                  \
    "LIT", "MOV", "IMV",                                                    \
    "EXP", "LOG", "RCP", "RSQ", "RCC",                                      \
    "ADD", "DP3", "DP4", "DST", "MAX", "MIN", "MUL", "SGE", "SLT", "DPH",   \
    "MAD",

typedef enum Component_Enum {
    XX = 0, YY, ZZ, WW,
} Component_t;

typedef enum Component4_Enum {
    XYZW = (XX | YY << 2 | ZZ << 4 | WW << 6),
} Component4;

typedef enum DestMaskBits_Enum {
    DST_NONE_BITS = 0,
    DST_X_BIT = 1, DST_Y_BIT = 2, DST_Z_BIT = 4, DST_W_BIT = 8,
    DST_YZ_BITS = 6,
    DST_XYZ_BITS = 7,
    DST_XYW_BITS = 11,
    DST_XYZW_BITS = 15,
} DestMaskBits;

typedef enum Register_Enum {

    VA_0 = 0,   VA_OPOS = 0,  VA_1 = 1,   VA_WGHT = 1,
    VA_2 = 2,   VA_NRML = 2,  VA_3 = 3,   VA_COL0 = 3,
    VA_4 = 4,   VA_COL1 = 4,  VA_5 = 5,   VA_FOGC = 5,
    VA_6 = 6,                 VA_7 = 7,
    VA_8 = 8,   VA_TEX0 = 8,  VA_9 = 9,   VA_TEX1 = 9,
    VA_10 = 10, VA_TEX2 = 10, VA_11 = 11, VA_TEX3 = 11,
    VA_12 = 12, VA_TEX4 = 12, VA_13 = 13, VA_TEX5 = 13,
    VA_14 = 14, VA_TEX6 = 14, VA_15 = 15, VA_TEX7 = 15,

    VR_0 = 16,  VR_HPOS = VR_0,
    VR_1 = 17,  
    VR_2 = 18,  
    VR_3 = 19,  VR_COL0 = VR_3,
    VR_4 = 20,  VR_COL1 = VR_4,
    VR_5 = 21,  VR_FOGC = VR_5,
    VR_6 = 22,  VR_PSIZ = VR_6,
    VR_7 = 23,  VR_BFC0 = VR_7,
    VR_8 = 24,  VR_BFC1 = VR_8,
    VR_9 = 25,  VR_TEX0 = VR_9,
    VR_10 = 26, VR_TEX1 = VR_10,
    VR_11 = 27, VR_TEX2 = VR_11,
    VR_12 = 28, VR_TEX3 = VR_12,
    VR_13 = 29, VR_TEX4 = VR_13,
    VR_14 = 30, VR_TEX5 = VR_14,
    VR_15 = 31, VR_TEX6 = VR_15, VR_TEX7 = VR_15,

    PR_0 = 32,   PR_1 = 33,   PR_2 = 34,   PR_3 = 35,
    PR_4 = 36,   PR_5 = 37,   PR_6 = 38,   PR_7 = 39,
    PR_8 = 40,   PR_9 = 41,   PR_10 = 42,  PR_11 = 43,
    PR_12 = 44,  PR_13 = 45,  PR_14 = 46,  PR_15 = 47,
    PR_16 = 48,  PR_17 = 49,  PR_18 = 50,  PR_19 = 51,
    PR_20 = 52,  PR_21 = 53,  PR_22 = 54,  PR_23 = 55,
    PR_24 = 56,  PR_25 = 57,  PR_26 = 58,  PR_27 = 59,
    PR_28 = 60,  PR_29 = 61,  PR_30 = 62,  PR_31 = 63,
    PR_32 = 64,  PR_33 = 65,  PR_34 = 66,  PR_35 = 67,
    PR_36 = 68,  PR_37 = 69,  PR_38 = 70,  PR_39 = 71,
    PR_40 = 72,  PR_41 = 73,  PR_42 = 74,  PR_43 = 75,
    PR_44 = 76,  PR_45 = 77,  PR_46 = 78,  PR_47 = 79,
    PR_48 = 80,  PR_49 = 81,  PR_50 = 82,  PR_51 = 83,
    PR_52 = 84,  PR_53 = 85,  PR_54 = 86,  PR_55 = 87,
    PR_56 = 88,  PR_57 = 89,  PR_58 = 90,  PR_59 = 91,
    PR_60 = 92,  PR_61 = 93,  PR_62 = 94,  PR_63 = 95,
    PR_64 = 96,  PR_65 = 97,  PR_66 = 98,  PR_67 = 99,
    PR_68 = 100, PR_69 = 101, PR_70 = 102, PR_71 = 103,
    PR_72 = 104, PR_73 = 105, PR_74 = 106, PR_75 = 107,
    PR_76 = 108, PR_77 = 109, PR_78 = 110, PR_79 = 111,
    PR_80 = 112, PR_81 = 113, PR_82 = 114, PR_83 = 115,
    PR_84 = 116, PR_85 = 117, PR_86 = 118, PR_87 = 119,
    PR_88 = 120, PR_89 = 121, PR_90 = 122, PR_91 = 123,
    PR_92 = 124, PR_93 = 125, PR_94 = 126, PR_95 = 127,

    TR_0 = 128,  TR_1 = 129,  TR_2 = 130,  TR_3 = 131,
    TR_4 = 132,  TR_5 = 133,  TR_6 = 134,  TR_7 = 135,
    TR_8 = 136,  TR_9 = 137,  TR_10 = 138, TR_11 = 139,
    TR_12 = 140, TR_13 = 141, TR_14 = 142, TR_15 = 143,

    ARL = 144,

    ZER = 145,

} Register_t;

typedef struct SrcReg_Rec {
    Register_t reg;
    unsigned char AddrReg;
    int addrRegOffset;
} SrcReg;

typedef struct ScalarSrcReg_Rec {
    SrcReg reg;
    Component_t com;
    unsigned char Signed;
} ScalarSrcReg;

typedef struct SwizzleSrcReg_Rec {
    SrcReg reg;
    unsigned char com4;
    unsigned char Signed;
} SwizzleSrcReg;

typedef struct MaskedDstReg_Rec {
    Register_t reg;
    unsigned char mask;
} MaskedDstReg;

typedef struct Arl_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    ScalarSrcReg src;
} Arl_Instruction;

typedef struct Vector_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg src;
} Vector_Instruction;

typedef struct Scalar_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    ScalarSrcReg src;
} Scalar_Instruction;

typedef struct Bin_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg srcA;
    SwizzleSrcReg srcB;
} Bin_Instruction;

typedef struct Tri_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg srcA;
    SwizzleSrcReg srcB;
    SwizzleSrcReg srcC;
} Tri_Instruction;

typedef struct End_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;
} End_Instruction;

typedef union Instruction_Rec {
    Arl_Instruction arl_op;
    Vector_Instruction vector_op;
    Scalar_Instruction scalar_op;
    Bin_Instruction bin_op;
    Tri_Instruction tri_op;
    End_Instruction end_op;
} Instruction;

typedef struct ParsedProgram_Rec {
    Instruction *firstInstruction;  // Pointer to array of instructions
    unsigned int liveOnEntry;       // Mask of "live" temp registers upon entry
    unsigned char resultRegsWritten[__GL_NUMBER_OF_RESULT_REGISTERS];
                                    // Mask of result registers written
    int IsStateProgram;             // True if this is a state program
    Instruction instArray[1];
} ParsedProgram;

void vp_Optimize(ParsedProgram *parsed, int numInstructions, int optimizeMask);

/*
** Common structure for X86 compilation of vertex programs
*/

#define CALLER_ID_D3D    0xD3D
#define CALLER_ID_OPENGL 0xD4D

typedef struct VtxProgCompileX86_Rec {
    void *(* malloc)(void *tag, size_t size);
    void (* free)(void *tag, void *address);
    void *(* exec_malloc)(void *tag, size_t size);
    void *mallocArg;
    float (* expf)(float f);
    float (* logf)(float f);
    int caller_id;
    int attrib_offset;
    int temp_offset;
    int result_offset;
    int param_offset;
    int float_zero_offset;
    int float_one_offset;
    // Used to compile code to fill pushbuffer directly:
    int channel_number;
    int enables_offset;
} VtxProgCompileX86;

typedef struct VertexProgramOutput_Rec {
    void *residentProgram;
    size_t residentSize;
    int residentNumInstructions;
} VertexProgramOutput;

int vp_CompileX86(VtxProgCompileX86 *, ParsedProgram *, int numInstructions,
                  VertexProgramOutput *);
int vp_OutputCelsiusX86(VtxProgCompileX86 *, ParsedProgram *, int numInstructions,
                  VertexProgramOutput *);

/*
** Common structure for Kelvin compilation of vertex programs
*/

typedef struct vtxpgmInstPacked_Rec {
    unsigned int x, y, z, w;
} vtxpgmInstPacked;

typedef struct VtxProgCompileKelvin_Rec {
    void *(* malloc)(void *tag, size_t size);
    void (* free)(void *tag, void *address);
    void *mallocArg;
    int caller_id;
} VtxProgCompileKelvin;

int vp_CompileKelvin(VtxProgCompileKelvin *, ParsedProgram *, int numInstructions,
                     VertexProgramOutput *);

/*
** Static global data used in shared code to call imported functions:
**
** TEMPORARY!!!!!!!
*/


struct VtxProgImports_Rec {
    float (* expf)(float f);
    float (* logf)(float f);
};


extern struct VtxProgImports_Rec VtxProgImports;

#endif /* __gl_vtxpgmcomp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\nv_name.h ===
typedef struct _CHIP_INFO
{
	ULONG   ulDevID;
	PWSTR   pwszChip;
	PWSTR   pwszAdapterString;
} CHIP_INFO;

CHIP_INFO   sChipInfo[] =
{
 // DEVICE ID  Chip ID name              Adapter ID Name
{0x0020,	L"RIVA TNT",		L"RIVA TNT"		},
{0x0028,	L"RIVA TNT2",		L"RIVA TNT2"		},
{0x002C,	L"Vanta",		L"Vanta"		},
{0x0029,	L"RIVA TNT2 Ultra",	L"RIVA TNT2 Ultra"	},
{0x002D,	L"RIVA TNT2 Model 64",	L"RIVA TNT2 Model 64"	},
{0x00A0,	L"Aladdin TNT2",	L"Aladdin TNT2"		},
{0x0100,	L"GeForce 256",		L"GeForce 256"		},
{0x0101,	L"GeForce DDR",		L"GeForce DDR"		},
{0x0103,	L"Quadro",		L"Quadro"		},
{0x0110,	L"GeForce2 MX",		L"GeForce2 MX"		},
{0x0111,	L"GeForce2 MX",		L"GeForce2 MX"		},
{0x0113,	L"Quadro2 MXR",		L"Quadro2 MXR"		},
{0x0150,	L"GeForce2 GTS",	L"GeForce2 GTS"		},
{0x0151,	L"GeForce2 GTS",	L"GeForce2 GTS"		},
{0x0152,	L"GeForce2 Ultra",	L"GeForce2 Ultra"	},
{0x0153,	L"Quadro2 Pro",		L"Quadro2 Pro"		},
{0x0200,	L"NV20",		L"NV20"		}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\inc\x86.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: x86.h                                                             *
*   x86 architexture specific macros - used mainly to generate assembly     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 02/10/98 - wrote it.                    *
*                                                                           *
\***************************************************************************/

/*****************************************************************************
 * constants
 *****************************************************************************/

#ifndef _x86_h
#define _x86_h

#ifdef __cplusplus
extern "C" {
#endif

/*
 * registers
 */
#define rEAX            0
#define rECX            1
#define rEDX            2
#define rEBX            3
#define rESP            4
#define rEBP            5
#define rESI            6
#define rEDI            7

#define rAX             0
#define rCX             1
#define rDX             2
#define rBX             3
#define rSP             4
#define rBP             5
#define rSI             6
#define rDI             7

#define rAL             0
#define rCL             1
#define rDL             2
#define rBL             3
#define rAH             4
#define rCH             5
#define rDH             6
#define rBH             7

#define rMM0            0
#define rMM1            1
#define rMM2            2
#define rMM3            3
#define rMM4            4
#define rMM5            5
#define rMM6            6
#define rMM7            7

#define rXMM0           0
#define rXMM1           1
#define rXMM2           2
#define rXMM3           3
#define rXMM4           4
#define rXMM5           5
#define rXMM6           6
#define rXMM7           7

#define rST0            0
#define rST1            1
#define rST2            2
#define rST3            3
#define rST4            4
#define rST5            5
#define rST6            6
#define rST7            7

/*
 * op codes
 *  alphabetically sorted
 */
#define xADC_rEAX_imm(i)        x86s(5) x86b(0x15) x86d(i)
#define xADD_r_rm(r,rm)         x86s(2) x86b(0x03) x86b(mREG(r) | (rm))
#define xADD_r_i32(r,a)         x86s(6) x86b(0x03) x86b(mREG(r) | mOFS32) x86d(a)
#define xADD_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(0) | (rm)) x86b(i)
#define xADD_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(0) | (rm)) x86d(i)
#define xADD_rm_r(rm,r)         x86s(2) x86b(0x01) x86b(mREG(r) | (rm))
#define xADD_i32_r(a,r)         x86s(6) x86b(0x01) x86b(mREG(r) | mOFS32) x86d(a)

#define xAND_r_rm(r,rm)         x86s(2) x86b(0x23) x86b(mREG(r) | (rm))
#define xAND_r_i32(r,a)         x86s(6) x86b(0x23) x86b(mREG(r) | mOFS32) x86d(a)
#define xAND_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(4) | (rm)) x86b(i)
#define xAND_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(4) | (rm)) x86d(i)

#define xCALL_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(2) | (rm))

#define xCMOVA_r_i32(r,a)       x86s(7) x86b(0x0f) x86b(0x47) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMOVA_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x47) x86b(mREG(r) | (rm))
#define xCMOVB_r_i32(r,a)       x86s(7) x86b(0x0f) x86b(0x42) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMOVB_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x42) x86b(mREG(r) | (rm))
#define xCMOVG_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x4f) x86b(mREG(r) | (rm))
#define xCMOVL_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x4c) x86b(mREG(r) | (rm))

#define xCMP_r_rm(r,rm)         x86s(2) x86b(0x3b) x86b(mREG(r) | (rm))
#define xCMP_r_i32(r,a)         x86s(6) x86b(0x3b) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMP_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(7) | (rm)) x86d(i)

#define xDEC_r(r)               x86s(1) x86b(0x48 | (r))
#define xDEC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(1) | (rm))
#define xDEC_i32(a)             x86s(6) x86b(0xff) x86b(mREG(1) | mOFS32) x86d(a)

#define xDIV_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(6) | (rm))

#define xFABS()                 x86s(2) x86b(0xd9) x86b(0xe1)

#define xFADD_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(0) | (rm))
#define xFADD_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(0) | mOFS32) x86d(a)
#define xFADD_st(r)             x86s(2) x86b(0xd8) x86b(0xc0 + (r))
#define xFADDP_st(r)            x86s(2) x86b(0xde) x86b(0xc0 + (r))

#define xFDECSTP                x86s(2) x86b(0xd9) x86b(0xf6)

#define xFCHS                   x86s(2) x86b(0xd9) x86b(0xe0)

#define xFCOM_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(2) | (rm))
#define xFCOM_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(2) | mOFS32) x86d(a)
#define xFCOM_st(r)             x86s(2) x86b(0xd8) x86b(0xd0 + (r))
#define xFCOMI_st(r)            x86s(2) x86b(0xdb) x86b(0xf0 + (r))
#define xFCOMIP_st(r)           x86s(2) x86b(0xdf) x86b(0xf0 + (r))
#define xFCOMP_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(3) | (rm))
#define xFCOMPP()               x86s(2) x86b(0xde) x86b(0xd9)

#define xFDIV_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(6) | (rm))
#define xFDIVR_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(7) | (rm))

#define xFFREE_st(r)            x86s(2) x86b(0xdd) x86b(0xc0 + (r))

#define xFILD_rm(rm)            x86s(2) x86b(0xdb) x86b(mREG(0) | (rm))
#define xFILD_rm16(rm)          x86s(2) x86b(0xdf) x86b(mREG(0) | (rm))
#define xFILD_rm64(rm)          x86s(2) x86b(0xdf) x86b(mREG(5) | (rm))

#define xFINCSTP                x86s(2) x86b(0xd9) x86b(0xf7)

#define xFIST_rm(rm)            x86s(2) x86b(0xdb) x86b(mREG(2) | (rm))
#define xFISTP_rm(rm)           x86s(2) x86b(0xdb) x86b(mREG(3) | (rm))
#define xFISTP_i32(a)           x86s(6) x86b(0xdb) x86b(mREG(3) | mOFS32) x86d(a)

#define xFLD_rm(rm)             x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_rm32(rm)           x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_rm64(rm)           x86s(2) x86b(0xdd) x86b(mREG(0) | (rm))
#define xFLD_i32(a)             x86s(6) x86b(0xd9) x86b(mREG(0) | mOFS32) x86d(a)
#define xFLD_st(r)              x86s(2) x86b(0xd9) x86b(0xc0 + (r))
#define xFLD1                   x86s(2) x86b(0xd9) x86b(0xe8)
#define xFLDZ                   x86s(2) x86b(0xd9) x86b(0xee)

#define xFMUL_st(r)             x86s(2) x86b(0xd8) x86b(0xc8 + (r))
#define xFMUL_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(1) | (rm))
#define xFMUL_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(1) | mOFS32) x86d(a)
#define xFMULP_st(r)            x86s(2) x86b(0xde) x86b(0xc8 + (r))
#define xFNSTSW                 x86s(2) x86b(0xdf) x86b(0xe0)

#define xFSQRT()                x86s(2) x86b(0xd9) x86b(0xfa)

#define xFSUB_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(4) | (rm))
#define xFSUBP_st(r)            x86s(2) x86b(0xde) x86b(0xe8 + (r))
#define xFSUBR_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(5) | (rm))
#define xFSUBRP_st(r)           x86s(2) x86b(0xde) x86b(0xe0 + (r))

#define xFST_rm(rm)             x86s(2) x86b(0xd9) x86b(mREG(2) | (rm))
#define xFSTP_rm(rm)            x86s(2) x86b(0xd9) x86b(mREG(3) | (rm))
#define xFSTP_i32(a)            x86s(6) x86b(0xd9) x86b(mREG(3) | mOFS32) x86d(a)
#define xFSTP_st(r)             x86s(2) x86b(0xdd) x86b(0xd8 + (r))

#define xFLDCW_rm(rm)           x86s(2) x86b(0xd9) x86b(mREG(5) | (rm))
#define xFSTCW_rm(rm)           x86s(2) x86b(0xd9) x86b(mREG(7) | (rm))


#define xFXCH_st(r)             x86s(2) x86b(0xd9) x86b(0xc8 + (r))

#define xFYL2X()                x86s(2) x86b(0xd9) x86b(0xf1)
#define xF2XM1()                x86s(2) x86b(0xd9) x86b(0xf0)

#define xINC_r(r)               x86s(1) x86b(0x40 | (r))
#define xINC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(0) | (rm))

#define xIMUL_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | (rm))
#define xIMUL_r_i32(r,a)        x86s(7) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | mOFS32) x86d(a)
#define xIMUL_r_r_imm(r1,r2,i)  x86s(6) x86b(0x69) x86b(0xc0 | ((r1) << 3) | (r2)) x86d(i)

#define xINT3                   x86s(1) x86b(0xcc)

#define xJA(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x77) x86b(_x) }
#define xJA32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x87) x86d(_x) }
#define xJAE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x73) x86b(_x) }
#define xJAE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x83) x86d(_x) }
#define xJB(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x72) x86b(_x) }
#define xJB32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x82) x86d(_x) }
#define xJBE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x76) x86b(_x) }
#define xJBE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x86) x86d(_x) }
#define xJG(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7f) x86b(_x) }
#define xJG32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8f) x86d(_x) }
#define xJGE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7d) x86b(_x) }
#define xJGE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8d) x86d(_x) }
#define xJL(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7c) x86b(_x) }
#define xJL32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8c) x86d(_x) }
#define xJLE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7e) x86b(_x) }
#define xJLE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8e) x86d(_x) }
#define xJNZ(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x75) x86b(_x) }
#define xJNZ32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x85) x86d(_x) }
#define xJZ(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x74) x86b(_x) }
#define xJZ32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x84) x86d(_x) }


#define xJMP8(disp)             { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0xeb) x86b(_x) }
#define xJMP(disp)              { unsigned int _x = (disp)-(ilcCount+5); x86s(5) x86b(0xe9) x86d(_x) }

#define xLEA_r_rm(r,rm)         x86s(2) x86b(0x8d) x86b(mREG(r) | (rm))

#define xMOV_r_rm(r,rm)         x86s(2) x86b(0x8b) x86b(mREG(r) | (rm))                     // mov eax,[ebx]
#define xMOV_r_i32(r,a)         x86s(6) x86b(0x8b) x86b(mREG(r) | mOFS32) x86d(a)           // mov eax,[1234h]
#define xMOV_rm_imm(rm,i)       x86s(6) x86b(0xc7) x86b(mREG(0) | (rm)) x86d(i)             // mov ebp,12345678
#define xMOV_rm_r(rm,r)         x86s(2) x86b(0x89) x86b(mREG(r) | (rm))                     // mov [ebx],eax
#define xMOV_i32_r(a,r)         x86s(6) x86b(0x89) x86b(mREG(r) | mOFS32) x86d(a)           // mov [1234h],eax
#define xMOV_r_rm8(r,rm)        x86s(2) x86b(0x8a) x86b(mREG(r) | (rm))                     // mov al,[ebx]
#define xMOV_rm8_r(rm,r)        x86s(2) x86b(0x88) x86b(mREG(r) | (rm))                     // mov [ebx],al
#define xMOVSB                  x86s(1) x86b(0xa4)
#define xMOVSD                  x86s(1) x86b(0xa5)
#define xMOVSX_r_rm8(r,rm)      x86s(3) x86b(0x0f) x86b(0xbe) x86b(mREG(r) | (rm))
#define xMOVSX_r_rm16(r,rm)     x86s(3) x86b(0x0f) x86b(0xbf) x86b(mREG(r) | (rm))
#define xMOVZX_r_rm8(r,rm)      x86s(3) x86b(0x0f) x86b(0xb6) x86b(mREG(r) | (rm))
#define xMOVZX_r_rm16(r,rm)     x86s(3) x86b(0x0f) x86b(0xb7) x86b(mREG(r) | (rm))

#define xNEG_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(3) | (rm))

#define xNOP                    x86s(1) x86b(0x90)

#define xNOT_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(2) | (rm))

#define xOR_r_rm(r,rm)          x86s(2) x86b(0x0b) x86b(mREG(r) | (rm))
#define xOR_r_i32(r,a)          x86s(6) x86b(0x0b) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_r(rm,r)          x86s(2) x86b(0x09) x86b(mREG(r) | (rm))
#define xOR_i32_r(a,r)          x86s(6) x86b(0x09) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_imm(rm,i)        x86s(6) x86b(0x81) x86b(mREG(1) | (rm)) x86d(i)

#define xPOP_r(r)               x86s(1) x86b(0x58 | (r))
#define xPOP_rm(rm)             x86s(2) x86b(0xff) x86b(0x30 | (rm))
#define xPOPAD                  x86s(1) x86b(0x61)

#define xPUSH_r(r)              x86s(1) x86b(0x50 | (r))
#define xPUSH_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(6) | (rm))
#define xPUSH_i32(a)            x86s(6) x86b(0xff) x86b(mREG(6) | mOFS32) x86d(a)
#define xPUSH_imm(i)            x86s(5) x86b(0x68) x86d(i)
#define xPUSHAD                 x86s(1) x86b(0x60)

#define xREP                    x86s(1) x86b(0xf3)
#define xRET                    x86s(1) x86b(0xc3)

#define xSAHF                   x86s(1) x86b(0x9e)

#define xSAL_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)
#define xSAR_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(7) | (rm)) x86b(i)

#define xSBB_r_rm(r,rm)         x86s(2) x86b(0x1b) x86b(mREG(r) | (rm))
#define xSBB_r_i32(r,a)         x86s(6) x86b(0x1b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSBB_rm_r(rm,r)         x86s(2) x86b(0x19) x86b(mREG(r) | (rm))

#define xSETAE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x93) x86b(rm)
#define xSETG_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9f) x86b(rm)
#define xSETGE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9d) x86b(rm)
#define xSETL_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9c) x86b(rm)
#define xSETLE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9e) x86b(rm)
#define xSETNZ_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x95) x86b(rm)
#define xSETZ_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x94) x86b(rm)

#define xSHL_rm_1(rm)           x86s(2) x86b(0xd1) x86b(mREG(4) | (rm))
#define xSHL_rm_CL(rm)          x86s(2) x86b(0xd3) x86b(mREG(4) | (rm))
#define xSHL_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)
#define xSHR_rm_1(rm)           x86s(2) x86b(0xd1) x86b(mREG(5) | (rm))
#define xSHR_rm_CL(rm)          x86s(2) x86b(0xd3) x86b(mREG(5) | (rm))
#define xSHR_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(5) | (rm)) x86b(i)

#define xSTOSD                 x86s(1) x86b(0xab)

#define xSUB_r_rm(r,rm)         x86s(2) x86b(0x2b) x86b(mREG(r) | (rm))
#define xSUB_r_i32(r,a)         x86s(6) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_r(rm,r)         x86s(2) x86b(0x29) x86b(mREG(r) | (rm))
#define xSUB_i32_r(a,r)         x86s(6) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(5) | (rm)) x86b(i)
#define xSUB_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(5) | (rm)) x86d(i)

#define xTEST_rm_r(rm,r)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_r_rm(r,rm)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_i32_r(a,r)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_r_i32(r,a)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_rm_imm8(rm,i)     x86s(3) x86b(0xf6) x86b(mREG(0) | (rm)) x86b(i)
#define xTEST_rm_imm(rm,i)      x86s(6) x86b(0xf7) x86b(mREG(0) | (rm)) x86d(i)

#define xXOR_r_rm(r,rm)         x86s(2) x86b(0x33) x86b(mREG(r) | (rm))
#define xXOR_r_i32(r,a)         x86s(6) x86b(0x33) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_r(rm,r)         x86s(2) x86b(0x31) x86b(mREG(r) | (rm))
#define xXOR_i32_r(a,r)         x86s(6) x86b(0x31) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(6) | (rm)) x86d(i)

/*
 * mmx opcodes
 */
#define xMOVD_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | (rm))
#define xMOVD_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | (rm))
#define xMOVNTQ_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0xe7) x86b(mREG(r) | (rm))
#define xMOVQ_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | (rm))
#define xMOVQ_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | (rm))
#define xMOVQ_i64_r(a,r)        x86s(7) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVQ_r_i64(r,a)        x86s(7) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | mOFS32) x86d(a)
#define xPMOVMSKB_r_r(r1, r2)   x86s(3) x86b(0x0f) x86b(0xd7) x86b(mREG(r1) | rmREG(r2))

#define xEMMS                   x86s(2) x86b(0x0f) x86b(0x77)

/*
 * katmai opcodes
 */
#define xADDPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x58) x86b(mREG(r) | (rm))
#define xADDSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x58) x86b(mREG(r) | (rm))

#define xCOMISS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x2f) x86b(mREG(r) | (rm))
#define xCMPPSZ_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(0)
#define xCMPPSL_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(1)
#define xCMPPSLE_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(2)
#define xCMPPSNZ_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(4)
#define xCMPPSGE_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(5)
#define xCMPPSG_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(6)

#define xCVTPS2PI_r_rm(r,rm)    x86s(3) x86b(0x0f) x86b(0x2c) x86b(mREG(r) | (rm))

#define xDIVPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5e) x86b(mREG(r) | (rm))

#define xMAXPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5f) x86b(mREG(r) | (rm))
#define xMAXPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x5f) x86b(mREG(r) | mOFS32) x86d(a)

#define xMINPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5d) x86b(mREG(r) | (rm))
#define xMINPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x5d) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVAPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x28) x86b(mREG(r) | (rm))
#define xMOVAPS_r_i128(r,a)     x86s(7) x86b(0x0f) x86b(0x28) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVAPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x29) x86b(mREG(r) | (rm))
#define xMOVAPS_i128_r(a,r)     x86s(7) x86b(0x0f) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVHLPS_r_r(r1,r2)     x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r1) | rmREG(r2)) // special movlps
#define xMOVLHPS_r_r(r1,r2)     x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r1) | rmREG(r2)) // special movhps

#define xMOVHPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r) | (rm))
#define xMOVHPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x16) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_i64_r(a,r)      x86s(7) x86b(0x0f) x86b(0x17) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x17) x86b(mREG(r) | (rm))

#define xMOVLPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r) | (rm))
#define xMOVLPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x12) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_i64_r(a,r)      x86s(7) x86b(0x0f) x86b(0x13) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x13) x86b(mREG(r) | (rm))

#define xMOVMSKPS_r_r(r1,r2)    x86s(3) x86b(0x0f) x86b(0x50) x86b(mREG(r1) | rmREG(r2))

#define xMOVNTPS_i128_r(a,r)    x86s(7) x86b(0x0f) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVNTPS_rm_r(rm,r)     x86s(3) x86b(0x0f) x86b(0x2b) x86b(mREG(r) | (rm))

#define xMOVUPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVUPS_r_i128(r,a)     x86s(7) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVUPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))
#define xMOVUPS_i128_r(a,r)     x86s(7) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVSS_r_i32(r,a)       x86s(8) x86b(0xf3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSS_i32_r(a,r)       x86s(8) x86b(0xf3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

#define xMULPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x59) x86b(mREG(r) | (rm))
#define xMULPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x59) x86b(mREG(r) | mOFS32) x86d(a)

#define xMULSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x59) x86b(mREG(r) | (rm))

#define xRCPPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x53) x86b(mREG(r) | (rm))

#define xPREFETCH_rm8(h,rm,ofs) x86s(4) x86b(0x0f) x86b(0x18) x86b(mREG(h) | (rm)) x86b(ofs)

#define xSHUFPS_r_i64_imm(r,a,i) x86s(8) x86b(0x0f) x86b(0xc6) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xSHUFPS_r_rm_imm(r,rm,i) x86s(4) x86b(0x0f) x86b(0xc6) x86b(mREG(r) | (rm)) x86b(i)

#define xSUBPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5c) x86b(mREG(r) | (rm))
#define xSUBSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x5c) x86b(mREG(r) | (rm))
#define xXORPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x57) x86b(mREG(r) | (rm))

 /*
 * Pentium 4 opcodes
 */

#define xMOVSD_r_rm(r,rm)      x86s(4) x86b(0xf2) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVSD_r_i128(r,a)     x86s(8) x86b(0xf2) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSD_rm_r(rm,r)      x86s(4) x86b(0xf2) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))
#define xMOVSD_i128_r(a,r)     x86s(8) x86b(0xf2) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

 /*
 * 3dnow opcodes
 */
#define xFEMMS                  x86s(2) x86b(0x0f) x86b(0x0e)
#define xPFMUL_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xb4)
#define xPFSUB_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x9a)
#define xPFADD_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x9e)
#define xPUNPCKHDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x6a) x86b(mREG(r) | (rm))
#define xPUNPCKLDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x62) x86b(mREG(r) | (rm))
#define xPFRCP_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x96)
#define xPFRCPIT1_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xa6)
#define xPFRCPIT2_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xb6)
#define xPSWAPD_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xbb)
#define xPFNACC_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x8a)

/*****************************************************************************
 * macros
 *****************************************************************************/

#if defined(IS_OPENGL)

#define ILC_GROW_TO(x) assert(!"can't grow ilcCount")

#else

/*****************************************************************************
 * externals
 *****************************************************************************/
void ILCGrowTo(unsigned long dwNeed);

#define ILC_GROW_TO(x) ILCGrowTo(x)

#endif

/*
 * emission
 */
#define x86s(x)                 if ((ilcCount+(x)) > ilcMax) ILC_GROW_TO(ilcCount+(x));
#define x86b(x)                 ilcData[ilcCount]=(unsigned char) (x); ilcCount++;
#define x86d(x)                 *(unsigned int *) (ilcData+ilcCount) = (unsigned int) (x); ilcCount+=4;

/*
 * mod r/m
 */
#define mOFS32                  rmIND(rEBP)
#define mREG(x)                 ((x) << 3)

#define rmIND(x)                (0x00 | (x))
#define rmIND8(x)               (0x40 | (x))
#define rmIND32(x)              (0x80 | (x))
#define rmREG(x)                (0xc0 | (x))
#define rmSIB                   rmIND(rESP)
#define rmSIB8                  rmIND8(rESP)
#define rmSIB32                 rmIND32(rESP)

#define times1                  0
#define times2                  1
#define times4                  2
#define times8                  3

#if !defined(IS_OPENGL)
////// Don't use these macro names!  They are used everywhere as vars and members!
#define x1                      times1
#define x2                      times2
#define x4                      times4
#define x8                      times8
#else
////// Don't use these macro names!  They are used everywhere as vars and members!
#endif // !defined(IS_OPENGL)

#define xSIB(r1,r2,s)           x86s(1) x86b((r1) | ((r2)<<3) | ((s)<<6))
#define xSIB32(r1,r2,e)         x86s(1) x86b((r1) | ((r2)<<3) | ((times1)<<6)) xOFS32(e)
#define xSIB_esp                xSIB(rESP, rESP, times1)
#define xSIB8_esp(e)            xSIB_esp xOFS8(e)
#define xSIB32_esp(e)           xSIB_esp xOFS32(e)

#define x16r                    x86s(1) x86b(0x66)
#define x16m                    x86s(1) x86b(0x67)

#define xDS                     x86s(1) x86b(0x3e)

#define xOFS8(e)                x86s(1) x86b(e)
#define xOFS32(e)               x86s(4) x86d(e)

#define mMEM8(x)               ((unsigned int) &(x))
#define mMEM32(x)              ((unsigned int) &(x))
#define mMEM64(x)              ((unsigned int) &(x))
#define mMEM128(x)             ((unsigned int) &(x))

/*
 * jumps * branches
 */
#define xLABEL(x)               (x) = ilcCount;
#define xTARGET_b8(x)           *(unsigned char *) (ilcData + (x) + 1) = (unsigned char) (ilcCount - ((x) + 2));
#define xTARGET_b32(x)          *(unsigned int *) (ilcData + (x) + 2) = (unsigned int) (ilcCount - ((x) + 6));
#define xTARGET_jmp(x)          *(unsigned int *) (ilcData + (x) + 1) = (unsigned int) (ilcCount - ((x) + 5));

/*
 * inline instructions not supported by built-in asm
 */
#define rdtsc  __asm _emit 0x0f __asm _emit 0x31
#define sfence __asm _emit 0x0f __asm _emit 0xae __asm _emit 0xf8

#ifdef __cplusplus
}
#endif

#endif // x86.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\memstruc.h ===
//****************************Module*Header***********************************
//
// Module Name: memstruc.h
//
//****************************************************************************

/*****************************************************************************
 *                                                                           *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.             *
 *                                                                           *
 ****************************************************************************/

//----------------------------------------------------------------------------
// WARNING:  For now, make sure this structure agrees with the one defined in MCD.H
//           We'll eventually move over to exclusively using THIS file,
//           so that the display driver can also use the memory_t structure.
//----------------------------------------------------------------------------

typedef struct _memory_t
{
    struct _memory_t    *prev;
    struct _memory_t    *next;
    struct _memory_t    *nextEmpty;
    ULONG               blkSize;
    ULONG               memBase;
} memory_t;

#define EMPTY               0x1
#define ALIGN_SIZE          64

#define IS_EMPTY(pBlk)      (((ULONG_PTR)(pBlk)->prev) & EMPTY )
#define SET_EMPTY(pBlk)     (pBlk)->prev = (memory_t *)(((BYTE *)(pBlk)->prev) + EMPTY)
#define SET_BUSY(pBlk)      (pBlk)->prev = (memory_t *)(((BYTE *)(pBlk)->prev) - EMPTY)
#define EMPTY_VALUE(pBlk)   ((memory_t *) (((BYTE *)(pBlk)) + EMPTY))
#define BUSY_VALUE(pBlk)    ((memory_t *) (((BYTE *)(pBlk)) - EMPTY))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv4\ddc.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     DDC.C
//
// Abstract:
//
//     This is code specific to NV4
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"

// MP/RM merge
#include "nvos.h"
#include "rm.h"

extern VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );


//******************************************************************************
// DDC support is only available for NT5 or later
//******************************************************************************


#if (_WIN32_WINNT >= 0x0500)


//******************************************************************************
// Forward Function Declarations
//******************************************************************************

VOID    WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension);
ULONG GetCurrentScanLine(PHW_DEVICE_EXTENSION);

BOOLEAN
GetDdcInformation (
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetDdcInformation)
#endif

//******************************************************************************
//
//  Register Description:
//
//
//        6.24 CR3E DDC Status Register                 0x3X5 Index 3E (R-)
//      
//      #define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
//      
//         Bit 3    SDA pin.  This is the current value of the SDA pin.
//         Bit 2    SCL pin.  This is the current value of the SCL pin.
//      
//      
//        6.23 CR3F DDC Write Register                   0x3X5 Index 3F (RW)
//      #define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
//      
//         Bits 7-6 Reserved
//      
//         Bits 5   Write SCL pin. If 1, this will tri-state the SCL bus.  This will allow
//      	    the value of the SCL pin to reach a 1 since the SCL pin is connected
//      	    to a external pull-up.  A 0 will enable the SCL pin and force
//      	    a 0 onto the SCL signal.
//      
//         Bits 4   Write SDA pin. If 1, this will tri-state the SDA bus.  This will allow
//      	    the value of the SDA pin to reach a 1 since the SDA pin is connected
//      	    to a external pull-up.  A 0 will enable the SDA pin and force
//      	    a 0 onto the SDA signal.
//      
//         Bits 3-2   Reserved. 
//      
//         Bit  1   DDC Write release.  When a 0 is written, it will release the SCL pin
//      	    and allow it to float high.  When a 1 is written, it will latch the 
//      	    SDA value at the next falling edge of SCL and hold the SCL pin low
//      	    until a 0 is written.
//      
//         Bit  0   DDC enable pin.  Enables writes onto the DDC pins.  
//      	    1 indicates writes are enabled. 
//      
//         This register defaults to 0x30 after reset.
//         
//         The DDC is really a I2C interface.  This interface is designed to allow easy
//         software controllability.  
//      
//      None.
//
//******************************************************************************


//******************************************************************************
//
//  Function:   WriteClockLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)

    {
    UCHAR ucPortData;

    //**************************************************************************
    // Read current value then update
    //**************************************************************************
        
    CRTC_RD(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);

    if (ucData)
        ucPortData |= 0x20;
    else        
        ucPortData &= (~0x20);  

    //**************************************************************************
    // Set new value
    //**************************************************************************

    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);   

    }

//******************************************************************************
//
//  Function:   WriteDataLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)

    {
    UCHAR ucPortData;

    //**************************************************************************
    // Read current value then update
    //**************************************************************************
        
    CRTC_RD(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);

    if (ucData)
        ucPortData |= 0x10;
    else        
        ucPortData &= (~0x10);  

    //**************************************************************************
    // Set new value
    //**************************************************************************

    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);   

    }

//******************************************************************************
//
//  Function:   ReadClockLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    UCHAR ucPortData;
    
    //**************************************************************************
    //  Bit 2    SCL pin (current value of the SCL pin)
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX , ucPortData);

    return((BOOLEAN)(ucPortData&4) >> 2);
    }


//******************************************************************************
//
//  Function:   ReadDataLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    UCHAR ucPortData;
    
    //**************************************************************************
    //  Bit 3    SDA pin (current value of the SCL pin)
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX , ucPortData);

    return((BOOLEAN)(ucPortData&8) >> 3);
    }

//******************************************************************************
//
//  Function:   WaitForVsyncActive
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    //**************************************************************************
    // Wait while in vblank
    //**************************************************************************

    while (GetCurrentScanLine(HwDeviceExtension) ==0);

    //**************************************************************************
    // Wait while display is active
    //**************************************************************************

    while (GetCurrentScanLine(HwDeviceExtension) !=0);

    //**************************************************************************
    // Now we're in vblank
    //**************************************************************************

    }


//******************************************************************************
//
//  Function: GetCurrentScanLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG GetCurrentScanLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    ULONG   LoByte, HiByte;
    ULONG   Value;
    
    //**************************************************************************
    // Get current scanline by reading both registers
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_RL1__INDEX , HiByte);
    HiByte <<=8;
    
    CRTC_RD(NV_CIO_CRE_RL0__INDEX , LoByte);
    LoByte &=0xff;
        
    Value = ( (HiByte << 8) | (LoByte&0xff) );
    Value &= 0x7FF;
        
    if (Value == 0)
        {
        //**********************************************************************
        // Double check to fix hw bug. (for NV3)
        //**********************************************************************

        CRTC_RD(NV_CIO_CRE_RL1__INDEX , HiByte);
        HiByte <<=8;
    
        CRTC_RD(NV_CIO_CRE_RL0__INDEX , LoByte);
        LoByte &=0xff;
        
        Value = ( (HiByte << 8) | (LoByte&0xff) );
        Value &= 0x7FF;
        }


    return(Value);
    }


//******************************************************************************
//
//  Function:   GetDdcInformation
//
//  Routine Description:
//
//      Reads the basic EDID structure from the monitor using DDC2.
//
//  Arguments:
//
//      HwDeviceExtension - Points to per-adapter device extension.
//  
//      QueryBuffer       - Buffer where information will be stored.
//  
//      BufferSize        - Size of the buffer to fill.
//
//  Return Value:
//
//      Whether the call succeeded or not.
//
//******************************************************************************


BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize)

    {
    ULONG         i;
    ULONG ulHead;
    NVTWINVIEWDATA TwinViewData;
    VP_STATUS status;


    // This function will be called only for the case of a board with a single head.
    // So we reference the EDID info of the Head 0.
    ulHead = 0;

    //
    // Enable this code once Terry finishes the control panel work of automoatically disabling the system EDID for
    // spanning modes.
    //
#ifdef ENABLE_EXPORTING_EDID_TO_WIN2K

    status = VideoPortGetRegistryParameters(
                                       HwDeviceExtension,
                                       L"TwinviewInfo",
                                       FALSE,
                                       NVReadRegistryTwinViewInfoCallback,
                                       &TwinViewData);
    if (status == NO_ERROR)
    {
        // Extract the primary head. For standard/clone/span modes, we will let the OS manage the properties
        // (refresh rate, color depth, EDID flag) of the primary head.
        // Note: Dependency: The control panel needs to automatically disable the OS EDID if the user wants to switch
        // to spanning mode, otherwise the 'faked' doubled modes will be disallowed by the OS.
        ulHead = TwinViewData.dwDeviceDisplay[0];
        VideoDebugPrint((0,"Exporting EDID of head: 0x%x as the primary head from the TwinViewInfo structure\n", ulHead));
    }
    else
    {
       // BUGBUG: what happens if the display driver uses head1 for normal mode. We don't know yet what head
       // the display driver is going to use since we are still in the very early part of booting before any
       // modeset has happened.
       ulHead = 0;
       VideoDebugPrint((0," TwinViewInfo is absent: Exporting EDID of head: 0x%x as the default primary head\n", ulHead));
    }
#endif


    //**************************************************************************
    // If a flat panel was connected, then just return the EDID buffer
    // (which was obtained in the RM). Do the same for a CRT also.
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

        //**********************************************************************
        // Win2k (as of build 2195) does NOT seem to understand version 2.0 EDIDs.
        // Returning a version 2.0 EDID will cause Win2k to come up in VGA.
        // So for now, if we detect version 2.0, then just return FAILURE, and
        // don't bother returning the EDID.  (Fixes Gateway FPD1500 flat panel)
        //**********************************************************************

    	if (! ((HwDeviceExtension->EDIDBuffer[ulHead][0] == 0)    && 
               (HwDeviceExtension->EDIDBuffer[ulHead][1] == 0xFF) && 
               (HwDeviceExtension->EDIDBuffer[ulHead][7] == 0)) )
            return(FALSE);
        }

    //
    // Return failure if this is a non-DDC device. The whole EDID structure would have been zeroed out in this case.
    // Let us check a few random fields to verify.
    // (18)    EDID Version Number
    // (19)    Revision number
    //
    if (HwDeviceExtension->EDIDBuffer[ulHead][0] == 0    && 
        HwDeviceExtension->EDIDBuffer[ulHead][1] == 0    && 
        HwDeviceExtension->EDIDBuffer[ulHead][7] == 0    && 
        HwDeviceExtension->EDIDBuffer[ulHead][18] == 0   && 
        HwDeviceExtension->EDIDBuffer[ulHead][19] == 0)
        {
            VideoDebugPrint((0,"This is a non-DDC monitor. So not returning any EDID\n"));     
            return(FALSE);
        }

    if (!HwDeviceExtension->EDIDBufferValid[ulHead])
    {
        VideoDebugPrint((0,"This is a non-DDC monitor. So not returning any EDID\n"));     
        return(FALSE);
    }
    

    //**********************************************************************
    // Go ahead and return the EDID
    //**********************************************************************

    for (i=0;i<BufferSize;i++)
        *(QueryBuffer+i) = HwDeviceExtension->EDIDBuffer[ulHead][i];

    //**********************************************************************
    // Return Success.
    //**********************************************************************

    return(TRUE);

    }



#endif // _WIN32_WINNT >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\common\vesa\vesadata.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

#include "vesadata.h"
#include "nvMultiMon.h"

//*****************************************************************************
//
// This file contains the display timing tables required for all supported
// VESA (DMT, GTF) modes.
//
// Definition of display timing terms:
//
//
//  <------------------><--------><-------><------><-------><--------><--------
//
//     Active Display     Border    Porch    Sync    Porch    Border    Active
//
//
//  <---------------------------------------------------------------->
//  Total
//
//  <------------------>
//  Visible
//
//  <---------------------------->
//  Blank Start
//
//  <------------------------------------->
//  Sync Start
//
//  <--------------------------------------------->
//  Sync End
//
//  <------------------------------------------------------>
//  Blank End
//
//*****************************************************************************

//*****************************************************************************
//
// GTF Timings 
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use pure floating point).
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Sync Start, Sync End
// Vertical Total, Sync Start, Sync End
// DotClock (MHz * 100)
// HSync polarity 
// VSync polarity 
//
// NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
// Blank End == Total.
//
unsigned int GTFTimingTable[][12] =
{
    // Settings for 2048x1536:
    {2048,1536,6000, 2800,2200,2424,1589,1537,1540,26695,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7000, 2816,2208,2432,1599,1537,1540,31519,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7200, 2816,2208,2432,1600,1537,1540,32440,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7500, 2832,2216,2440,1603,1537,1540,34048,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,8500, 2832,2216,2440,1612,1537,1540,38804,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1920x1440:
    {1920,1440,6000, 2624,2064,2272,1490,1441,1444,23459,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7000, 2640,2072,2280,1499,1441,1444,27702,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7200, 2640,2072,2280,1500,1441,1444,28512,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7500, 2640,2072,2280,1503,1441,1444,29759,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,8500, 2656,2072,2288,1512,1441,1444,34135,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 1920x1200:
    {1920,1200,6000, 2592,2048,2256,1242,1201,1204,19316,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7000, 2608,2056,2264,1249,1201,1204,22802,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7200, 2624,2064,2272,1251,1201,1204,23635,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7500, 2624,2064,2272,1253,1201,1204,24659,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7600, 2624,2064,2272,1253,1201,1204,24988,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,8500, 2640,2072,2280,1260,1201,1204,28274,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,10000,2656,2072,2288,1271,1201,1204,33758,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,12000,2672,2080,2296,1286,1201,1204,41234,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1920x1080:
    {1920,1080,6000, 2576,2040,2248,1118,1081,1084,17280,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7000, 2608,2056,2264,1124,1081,1084,20520,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7200, 2608,2056,2264,1126,1081,1084,21144,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7500, 2608,2056,2264,1128,1081,1084,22064,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,8500, 2624,2064,2272,1134,1081,1084,25293,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,10000,2640,2072,2280,1144,1081,1084,30202,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,12000,2656,2072,2288,1157,1081,1084,36876,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1800x1440:
    {1800,1440,6000, 2456,1928,2128,1490,1441,1444,21957,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7000, 2472,1936,2136,1499,1441,1444,25939,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7200, 2472,1936,2136,1500,1441,1444,26698,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7500, 2472,1936,2136,1503,1441,1444,27866,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,8500, 2488,1944,2144,1512,1441,1444,31976,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,10000,2504,1952,2152,1525,1441,1444,38186,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1600x1200:
    {1600,1200,6000, 2160,1704,1880,1242,1201,1204,16096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7000, 2176,1712,1888,1249,1201,1204,19025,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7200, 2176,1712,1888,1251,1201,1204,19600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7500, 2192,1720,1896,1253,1201,1204,20599,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,8500, 2192,1720,1896,1260,1201,1204,23476,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,10000,2208,1728,1904,1272,1201,1204,28064,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,12000,2224,1736,1912,1286,1201,1204,34321,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,14000,2240,1744,1920,1301,1201,1204,40799,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x1024:
    {1600,1024,6000, 2144,1704,1872,1060,1025,1028,13636,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7000, 2160,1704,1880,1066,1025,1028,16118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7200, 2160,1704,1880,1067,1025,1028,16594,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7500, 2176,1712,1888,1069,1025,1028,17446,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7600, 2176,1712,1888,1070,1025,1028,17695,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,8500, 2176,1712,1888,1075,1025,1028,19883,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,10000,2192,1720,1896,1085,1025,1028,23783,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,12000,2208,1728,1904,1097,1025,1028,29066,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x900:
    {1600,900,6000, 2128,1696,1864,932,901,904,11900,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7000, 2144,1704,1872,937,901,904,14062,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7200, 2144,1704,1872,938,901,904,14480,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7500, 2160,1704,1880,940,901,904,15228,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,8500, 2176,1712,1888,945,901,904,17479,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,10000,2192,1720,1896,953,901,904,20890,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,12000,2208,1728,1904,965,901,904,25569,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,14000,2224,1736,1912,976,901,904,30389,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,14400,2224,1736,1912,978,901,904,31321,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,15000,2224,1736,1912,982,901,904,32760,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,17000,2224,1736,1912,994,901,904,37581,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x880:
    {1600,880,6000, 2112,1688,1856,911,881,884,11544,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7000, 2144,1704,1872,916,881,884,13747,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7200, 2144,1704,1872,917,881,884,14156,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7500, 2144,1704,1872,919,881,884,14778,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,8500, 2160,1704,1880,924,881,884,16965,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,10000,2192,1720,1896,932,881,884,20429,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,12000,2208,1728,1904,943,881,884,24986,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,14000,2208,1728,1904,954,881,884,29490,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,14400,2224,1736,1912,957,881,884,30648,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,15000,2224,1736,1912,960,881,884,32026,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,17000,2224,1736,1912,972,881,884,36749,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1400x1050:
    {1400,1050,6000, 1880,1488,1640,1087,1051,1054,12261,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7000, 1896,1496,1648,1093,1051,1054,14506,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7200, 1896,1496,1648,1094,1051,1054,14934,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7500, 1896,1496,1648,1096,1051,1054,15585,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,8500, 1912,1504,1656,1103,1051,1054,17926,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,10000,1928,1512,1664,1112,1051,1054,21439,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,12000,1944,1520,1672,1125,1051,1054,26244,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,14000,1944,1520,1672,1139,1051,1054,30999,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,14400,1944,1520,1672,1141,1051,1054,31941,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,15000,1944,1520,1572,1146,1051,1054,33417,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    
    // Settings for 1280x1024:
    {1280,1024,6000, 1712,1360,1496,1060,1025,1028,10888,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7000, 1728,1368,1504,1066,1025,1028,12894,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7200, 1728,1368,1504,1067,1025,1028,13275,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7500, 0x6B0,0x550,0x5d8,0x424,0x401,0x404,0x2a88,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,8500, 1744,1376,1512,1075,1025,1028,15936,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,10000,1760,1376,1520,1085,1025,1028,19096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,12000,1776,1384,1528,1097,1025,1028,23379,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,14000,1776,1384,1528,1111,1025,1028,27624,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,14400,1776,1384,1528,1113,1025,1028,28464,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,15000,1776,1384,1528,1117,1025,1028,29757,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,17000,1792,1392,1536,1131,1025,1028,34455,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,20000,1729,1392,1536,1152,1025,1028,41288,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1280x960:
    {1280,960,6000, 1712,1360,1496,994, 961,964,10210,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7000, 1728,1368,1504,999, 961,964,12084,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7200, 1728,1368,1504,1001,961,964,12454,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7500, 1728,1368,1504,1002,961,964,12986,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,8500, 1744,1376,1512,1008,961,964,14943,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,10000,1760,1376,1520,1017,961,964,17899,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,12000,1760,1376,1520,1029,961,964,21732,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,14000,1776,1384,1528,1041,961,964,25883,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,14400,1776,1384,1528,1044,961,964,26700,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,15000,1776,1384,1528,1047,961,964,27892,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,17000,1792,1392,1536,1060,961,964,32292,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,20000,1792,1392,1536,1080,961,964,38707,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1152x864:
    {1152,864,6000, 1520,1216,1336,895,865,868,8162,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7000, 1536,1224,1344,900,865,868,9677,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7200, 1536,1224,1344,901,865,868,9964,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7500, 1552,1224,1352,902,865,868,10499,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,8500, 1552,1224,1352,907,865,868,11965,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,10000,1568,1232,1360,915,865,868,14347,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,12000,1584,1240,1368,926,865,868,17601,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,14000,1600,1248,1376,937,865,868,20989,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,14400,1600,1248,1376,939,865,868,21635,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,15000,1600,1248,1376,943,865,868,22632,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,17000,1600,1248,1376,954,865,868,25949,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,20000,1616,1256,1384,972,865,868,31415,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,24000,1616,1256,1384,997,865,868,38668,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1024x768:
    //Use DMT for 60Hz: 1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {1024,768,6000, 1344,1048,1184,806,771,777,6500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
    {1024,768,7000, 1360,1080,1192,800,769,772,7616,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,7200, 1360,1080,1192,801,769,772,7843,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,7500, 1360,1080,1192,802,769,772,8180,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,8500, 1376,1088,1200,807,769,772,9439,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    //Adjust 100Hz due to DAC feedback
    //1392,1096,1208,814,769,772,11331,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {1024,768,10000,1392,1096,1208,814,769,772,11370,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,12000,1408,1104,1216,823,769,772,13905,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,14000,1408,1104,1216,833,769,772,16420,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,14400,1408,1104,1216,835,769,772,16930,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,15000,1408,1104,1216,838,769,772,17699,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,17000,1424,1112,1224,848,769,772,20528,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,20000,1424,1112,1224,864,769,772,24607,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,24000,1440,1120,1232,886,769,772,30620,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 960x720:
    {960,720,6000, 1248,1008,1104,746,721,724,5586,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7000, 1264,1008,1112,750,721,724,6636,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7200, 1264,1008,1112,751,721,724,6835,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7500, 1280,1016,1120,752,721,724,7219,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,8500, 1280,1016,1120,756,721,724,8225,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,10000,1296,1024,1128,763,721,724,9888,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,12000,1312,1032,1136,772,721,724,12154,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,14000,1312,1032,1136,781,721,724,14345,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,14400,1328,1040,1144,783,721,724,14973,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,15000,1328,1040,1144,786,721,724,15657,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,17000,1328,1040,1144,795,721,724,17948,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,20000,1344,1048,1152,810,721,724,21773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,24000,1344,1048,1152,831,721,724,26805,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 864x480:
    {864,480,6000, 1072,880,968,497,481,484,3197,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7000, 1104,896,984,500,481,484,3864,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7200, 1104,896,984,501,481,484,3982,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7500, 1104,896,984,502,481,484,4157,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,8500, 1120,904,992,505,481,484,4808,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,10000,1136,912,1000,509,481,484,5782,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,12000,1152,912,1008,515,481,484,7119,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,14000,1168,920,1016,521,481,484,8519,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,14400,1168,920,1016,522,481,484,8780,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,15000,1168,920,1016,524,481,484,9180,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,17000,1184,928,1024,531,481,484,10688,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,20000,1184,928,1024,540,481,484,12787,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,24000,1200,936,1032,554,481,484,15955,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 856x480:
    {856,480,6000, 1064,872,960,497,481,484,3173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7000, 1096,888,976,500,481,484,3836,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7200, 1096,888,976,501,481,484,3953,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7500, 1096,888,976,502,481,484,4126,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,8500, 1112,896,984,505,481,484,4773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,10000,1128,904,992,509,481,484,5742,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,12000,1144,912,1000,515,481,484,7070,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,14000,1160,912,1008,521,481,484,8461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,14400,1160,912,1008,522,481,484,8719,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,15000,1160,912,1008,524,481,484,9118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,17000,1160,912,1008,531,481,484,10471,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,20000,1176,920,1016,540,481,484,12701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,24000,1192,928,1024,554,481,484,15849,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 852x480:
    {852,480,6000, 1046,872,960,497,481,484,3173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7000, 1096,888,976,500,481,484,3836,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7200, 1096,888,976,501,481,484,3953,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7500, 1096,888,976,502,481,484,4126,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,8500, 1112,896,984,505,481,484,4773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,10000,1128,904,992,509,481,484,5742,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,12000,1144,912,1000,515,481,484,7070,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,14000,1160,912,1008,521,481,484,8461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,14400,1160,912,1008,522,481,484,8719,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,15000,1160,912,1008,524,481,484,9118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,17000,1160,912,1008,531,481,484,10471,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,20000,1176,920,1016,540,481,484,12701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,24000,1192,928,1024,554,481,484,15849,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 848x480:
    {848,480,6000, 1056,864,952,497,481,484,3149,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7000, 1072,872,960,500,481,484,3752,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7200, 1088,880,968,501,481,484,3925,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7500, 1088,880,968,502,481,484,4096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,8500, 1104,888,976,505,481,484,4739,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,10000,1120,896,984,509,481,484,5701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,12000,1136,904,992,515,481,484,7020,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,14000,1152,904,1000,521,481,484,8403,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,14400,1152,904,1000,522,481,484,8659,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,15000,1152,904,1000,524,481,484,9055,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,17000,1152,904,1000,531,481,484,10399,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,20000,1168,912,1008,540,481,484,12614,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,24000,1168,912,1008,554,481,484,15530,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 800x600:
    // Use DMT for 60: 1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {800,600,6000, 1056,840,968,628,601,605,4000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7000, 1040,840,920,625,601,604,4550,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7200, 1040,840,920,626,601,604,4687,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7500, 1040,840,920,627,601,604,4891,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,8500, 1056,840,928,630,601,604,5655,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,10000,1072,848,936,636,601,604,6818,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,12000,1088,856,944,643,601,604,8395,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,14000,1088,856,944,651,601,604,9916,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,14400,1088,856,944,653,601,604,10231,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,15000,1088,856,944,655,601,604,10690,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,17000,1104,864,952,663,601,604,12443,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,20000,1104,864,952,675,601,604,14904,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,24000,1120,872,960,692,601,604,18601,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 720x480:
    {720,480,6000, 896,736,808,497,481,484,2672,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7000, 912,744,816,500,481,484,3192,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7200, 912,744,816,501,481,484,3290,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7500, 928,752,824,502,481,484,3494,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,8500, 928,752,824,505,481,484,3983,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,10000,944,760,832,509,481,484,4805,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,12000,960,760,840,515,481,484,5933,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,14000,976,768,848,521,481,484,7119,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,14400,976,768,848,522,481,484,7336,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,15000,976,768,848,524,481,484,7671,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,17000,976,768,848,531,481,484,8810,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,20000,992,776,856,540,481,484,10714,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,24000,992,776,856,554,481,484,13190,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 640x480:
    // Use DMT for 60: 800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,480,6000, 800,656,752,525,490,492,2518,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
    {640,480,7000, 816,664,728,500,481,484,2856,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,7200, 816,664,728,501,481,484,2943,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,7500, 816,664,728,502,481,484,3072,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,8500, 832,672,736,505,481,484,3571,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,10000,848,680,744,509,481,484,4316,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,12000,848,680,744,515,481,484,5241,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,14000,864,680,752,521,481,484,6302,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,14400,864,680,752,522,481,484,6495,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,15000,864,680,752,524,481,484,6791,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,17000,880,688,760,531,481,484,7944,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,20000,880,688,760,540,481,484,9504,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,24000,880,688,760,554,481,484,11700,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 640x400:
    //
    // The GTF timings for 640x400 at 70Hz and 72Hz are drastically different than
    // the original VGA timings (which officially only list 85Hz as a support rate
    // at this resolution).  Therefore, when we attempt to set the GTF rates the
    // monitors just aren't happy.
    //
    // Remember that IBM VGA 640x400 starts at 70Hz, not 60Hz.  There is no 60Hz 
    // timings for 640x400 as defined by IBM VGA.
    //
    // Use GTF 75: 784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,6000, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    // Use GTF 75: 800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,7000, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    // Use GTF 75: 800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,7200, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,7500, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,8500, 816,664,728,421,401,404,2920,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,10000,832,672,736,424,401,404,3528,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,12000,848,680,744,429,401,404,4366,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,14000,848,680,744,434,401,404,5152,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,14400,848,680,744,435,401,404,5312,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,15000,864,680,752,437,401,404,5664,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,17000,864,680,752,442,401,404,6492,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,20000,880,688,760,451,401,404,7938,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,24000,880,688,760,462,401,404,9757,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    {512,384,6000, 672,536,592,795,769,772,3205,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {512,384,7000, 672,536,592,800,769,772,3763,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,7200, 688,544,600,801,769,772,3968,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,7500, 688,544,600,802,769,772,4138,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,8500, 688,544,600,807,769,772,4719,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,10000,688,544,600,814,769,772,5600,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,12000,704,552,608,823,769,772,6953,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,14000,704,552,608,833,769,772,8210,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,14400,704,552,608,835,769,772,8465,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,15000,704,552,608,838,769,772,8849,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,17000,704,552,608,848,769,772,10149,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,20000,720,560,616,864,769,772,12442,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,24000,720,560,616,886,769,772,15310,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    {480,360,6000, 624,504,552,746,721,724,2793,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7000, 640,512,560,750,721,724,3360,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7200, 640,512,560,751,721,724,3461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7500, 640,512,560,752,721,724,3610,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,8500, 640,512,560,756,721,724,4113,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,10000,656,512,568,763,721,724,5005,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,12000,656,512,568,772,721,724,6077,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,14000,656,512,568,781,721,724,7173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,14400,656,512,568,783,721,724,7397,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,15000,656,512,568,786,721,724,7734,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,17000,672,520,576,795,721,724,9082,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,20000,672,520,576,810,721,724,10886,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,24000,672,520,576,831,721,724,13402,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    {400,300,6000, 512,416,456,622,601,604,1911,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7000, 528,424,464,625,601,604,2310,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7200, 528,424,464,626,601,604,2380,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7500, 528,424,464,627,601,604,2483,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,8500, 528,424,464,630,601,604,2827,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,10000,528,424,464,636,601,604,3358,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,12000,544,432,472,643,601,604,4198,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,14000,544,432,472,651,601,604,4958,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,14400,544,432,472,653,601,604,5115,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,15000,544,432,472,655,601,604,5345,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,17000,544,432,472,663,601,604,6131,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,20000,560,432,480,675,601,604,7560,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,24000,560,432,480,692,601,604,9300,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    {320,240,6000, 400,328,360,497,481,484,1193,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7000, 400,328,360,500,481,484,1400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7200, 416,336,368,501,481,484,1501,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7500, 416,336,368,502,481,484,1566,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,8500, 416,336,368,505,481,484,1786,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,10000,416,336,368,509,481,484,2117,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,12000,432,344,376,515,481,484,2670,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,14000,432,344,376,521,481,484,3151,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,14400,432,344,376,522,481,484,3247,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,15000,432,344,376,524,481,484,3396,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,17000,432,344,376,531,481,484,3900,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,20000,432,344,376,540,481,484,4666,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,24000,448,352,384,554,481,484,5957,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {320,200,6000, 400,328,360,417,401,404,1168,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7000, 400,328,360,417,401,404,1168,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7200, 400,328,360,418,401,404,1204,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7500, 400,328,360,418,401,404,1254,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,8500, 416,336,368,421,401,404,1489,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,10000,416,336,368,424,401,404,1764,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,12000,416,336,368,429,401,404,2142,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,14000,432,344,376,434,401,404,2625,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,14400,432,344,376,435,401,404,2706,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,15000,432,344,376,437,401,404,2832,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,17000,432,344,376,442,401,404,3246,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,20000,432,344,376,451,401,404,3897,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,24000,448,352,384,462,401,404,4967,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE}
};

//*****************************************************************************
//
// VESA 1.0 rev 0.7 DMT timings
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7 
// Monitor Timing Specifications.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity 
// VSync polarity 
//
// NOTE: Unlike GTF timings, DMT does not dictate zero border widths.
// Therefore we must include blank start and end positions. 
//
unsigned int DMTTimingTableNT[][16] =
{

    // Settings for 320x200 (mode doubled 640x400):
    //  NOTE: There is no 60Hz 320x200, so use 70Hz if anyone wants 60Hz
    {320,200,6000,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {320,200,7000,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {320,200,8500,832/2,640/2,672/2,736/2,832/2,445,400,401,404,445,3150/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 320x240 (mode doubled 640x480):
	{320,240,6000,800/2,648/2,656/2,752/2,792/2,525,488,490,492,517,2518/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,7200,832/2,648/2,664/2,704/2,824/2,520,488,489,492,512,3150/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,7500,840/2,640/2,656/2,720/2,840/2,500,480,481,484,500,3150/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,8500,832/2,640/2,696/2,752/2,832/2,509,480,481,484,509,3600/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 400x300 (mode doubled 800x600):
	{400,300,6000,1056/2,800/2,840/2,968/2,1056/2,628,600,601,605,628,4000/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,7200,1040/2,800/2,856/2,976/2,1040/2,666,600,637,643,666,5000/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,7500,1056/2,800/2,816/2,896/2,1056/2,625,600,601,604,625,4950/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,8500,1048/2,800/2,832/2,896/2,1048/2,631,600,601,604,631,5625/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 512x384 (mode doubled 1024x768):
	{512,384,6000,1344/2,1024/2,1048/2,1184/2,1344/2,806,768,771,777,806,6500/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{512,384,7000,1328/2,1024/2,1048/2,1184/2,1328/2,806,768,771,777,806,7500/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{512,384,7500,1312/2,1024/2,1040/2,1136/2,1312/2,800,768,769,772,800,7875/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{512,384,8500,1376/2,1024/2,1072/2,1168/2,1376/2,808,768,769,772,808,9450/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 640x400:
    //  NOTE: There is no 60Hz 640x400, so use 70Hz if anyone wants 60Hz
    {640,400,6000,800,640,656,752,288,449,400,412,414,449,2518,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {640,400,7000,800,640,656,752,288,449,400,412,414,449,2518,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {640,400,8500,832,640,672,736,832,445,400,401,404,445,3150,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 640x480:
	{640,480,6000,800,648,656,752,792,525,488,490,492,517,2518,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,7200,832,648,664,704,824,520,488,489,492,512,3150,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,7500,840,640,656,720,840,500,480,481,484,500,3150,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,8500,832,640,696,752,832,509,480,481,484,509,3600,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 800x600:
	{800,600,6000,1056,800,840,968,1056,628,600,601,605,628,4000,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,7200,1040,800,856,976,1040,666,600,637,643,666,5000,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,7500,1056,800,816,896,1056,625,600,601,604,625,4950,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,8500,1048,800,832,896,1048,631,600,601,604,631,5625,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1024x768:
	{1024,768,6000,1344,1024,1048,1184,1344,806,768,771,777,806,6500,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{1024,768,7000,1328,1024,1048,1184,1328,806,768,771,777,806,7500,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{1024,768,7500,1312,1024,1040,1136,1312,800,768,769,772,800,7875,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1024,768,8500,1376,1024,1072,1168,1376,808,768,769,772,808,9450,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1152x864:
	{1152,864,7500,1600,1152,1216,1344,1600,900,864,865,868,900,10800,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1280x1024:
	{1280,1024,6000,1688,1280,1328,1440,1688,1066,1024,1025,1028,1066,10800,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1280,1024,7500,1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1280,1024,8500,1728,1280,1344,1504,1728,1072,1024,1025,1028,1072,15750,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1600x1024 (OEM requested version of 76Hz)
    {1600,1024,7600,2096,1600,1632,1792,2096,1070,1024,1027,1030,1070,17045,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 1600x1200:
	{1600,1200,6000,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,16200,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,6500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,17550,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,7000,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,18900,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,7500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,20250,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,8500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,22950,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1920x1200 (OEM requested version of 76Hz)
    {1920,1200,7600,2584,1920,1984,2240,2584,1250,1200,1203,1206,2584,24548,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE}
};

// This function scans the GTF table for the requested resolution/refresh rate
// and returns the timing values for it.
unsigned int vesaGetGTFTimings
(
    unsigned int hRes,
    unsigned int vRes,
    unsigned int refreshRate,
    MODE_TIMING_VALUES * timingInfo
)
{
    unsigned int numEntries;
    unsigned int i;

    // Check for the multi-mon modes.
    if (MULTIMON_MODE(hRes, vRes)) 
       {
       if (HORIZONTAL_MODE(hRes, vRes))
          {
          hRes /= 2;
          }
       else
          {
          if (VERTICAL_MODE(hRes, vRes))
             {
             vRes /= 2;
             }
          }
       }


    // For each mode, there are 12 (unsigned int) timing values
    numEntries = sizeof(GTFTimingTable) / (sizeof(unsigned int) * 12);

    // refresh rate is in terms of Hz * 100 in the table.
    refreshRate *= 100;

    for (i = 0; i < numEntries; i++)
    {
        if (GTFTimingTable[i][0] == hRes &&
            GTFTimingTable[i][1] == vRes &&
            GTFTimingTable[i][2] == refreshRate)
        {
            // Found the mode we want.
            // Copy the timing values.
            // NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
            // Blank End == Total.
            timingInfo->HorizontalVisible       = GTFTimingTable[i][0]; 
            timingInfo->VerticalVisible         = GTFTimingTable[i][1];
            timingInfo->Refresh                 = GTFTimingTable[i][2];
            timingInfo->HorizontalTotal         = GTFTimingTable[i][3]; 
            timingInfo->HorizontalBlankStart    = timingInfo->HorizontalVisible; 
            timingInfo->HorizontalRetraceStart  = GTFTimingTable[i][4]; 
            timingInfo->HorizontalRetraceEnd    = GTFTimingTable[i][5]; 
            timingInfo->HorizontalBlankEnd      = timingInfo->HorizontalTotal;
            timingInfo->VerticalTotal           = GTFTimingTable[i][6]; 
            timingInfo->VerticalBlankStart      = timingInfo->VerticalVisible; 
            timingInfo->VerticalRetraceStart    = GTFTimingTable[i][7]; 
            timingInfo->VerticalRetraceEnd      = GTFTimingTable[i][8]; 
            timingInfo->VerticalBlankEnd        = timingInfo->VerticalTotal;
            timingInfo->PixelClock              = GTFTimingTable[i][9];
            timingInfo->HSyncpolarity           = GTFTimingTable[i][10]; 
            timingInfo->VSyncpolarity           = GTFTimingTable[i][11]; 

            // return success.
            return 0;
        } // found the matching mode
    } // loop over all the modes in the table

    // Did not find the specifed resolution/refresh rate conbination.
    return 1;
} // end of vesaGetGTFTimings

// This function scans the DMT table for the requested resolution/refresh rate
// and returns the timing values for it.
unsigned int vesaGetDMTTimings
(
    unsigned int hRes,
    unsigned int vRes,
    unsigned int refreshRate,
    MODE_TIMING_VALUES * timingInfo
)
{
    unsigned int numEntries;
    unsigned int i;

    // Check for the multi-mon modes.
    if (MULTIMON_MODE(hRes, vRes)) 
       {
       if (HORIZONTAL_MODE(hRes, vRes))
          {
          hRes /= 2;
          }
       else
          {
          if (VERTICAL_MODE(hRes, vRes))
             {
             vRes /= 2;
             }
          }
       }

    // For each mode, there are 16 (unsigned int) timing values
    numEntries = sizeof(DMTTimingTableNT) / (sizeof(unsigned int) * 16);

    // refresh rate is in terms of Hz * 100 in the table.
    refreshRate *= 100;

    for (i = 0; i < numEntries; i++)
    {
        if (DMTTimingTableNT[i][0] == hRes &&
            DMTTimingTableNT[i][1] == vRes &&
            DMTTimingTableNT[i][2] == refreshRate)
        {
            // Found the mode we want.
            // Copy the timing values.
            timingInfo->HorizontalVisible       = DMTTimingTableNT[i][0]; 
            timingInfo->VerticalVisible         = DMTTimingTableNT[i][1];
            timingInfo->Refresh                 = DMTTimingTableNT[i][2];
            timingInfo->HorizontalTotal         = DMTTimingTableNT[i][3]; 
            // timingInfo->HorizontalBlankStart    = DMTTimingTableNT[i][4]; 
            timingInfo->HorizontalBlankStart    = timingInfo->HorizontalVisible; 
            timingInfo->HorizontalRetraceStart  = DMTTimingTableNT[i][5]; 
            timingInfo->HorizontalRetraceEnd    = DMTTimingTableNT[i][6]; 
            // timingInfo->HorizontalBlankEnd      = DMTTimingTableNT[i][7];
            timingInfo->HorizontalBlankEnd      = timingInfo->HorizontalBlankStart
                            + (timingInfo->HorizontalTotal - DMTTimingTableNT[i][7]);
            timingInfo->VerticalTotal           = DMTTimingTableNT[i][8]; 
            // timingInfo->VerticalBlankStart      = DMTTimingTableNT[i][9]; 
            timingInfo->VerticalBlankStart      = timingInfo->VerticalVisible; 
            timingInfo->VerticalRetraceStart    = DMTTimingTableNT[i][10]; 
            timingInfo->VerticalRetraceEnd      = DMTTimingTableNT[i][11]; 
            // timingInfo->VerticalBlankEnd        = DMTTimingTableNT[i][12];
            timingInfo->VerticalBlankEnd        = timingInfo->VerticalBlankStart 
                            + (timingInfo->VerticalTotal - DMTTimingTableNT[i][12]);
            timingInfo->PixelClock              = DMTTimingTableNT[i][13];
            timingInfo->HSyncpolarity           = DMTTimingTableNT[i][14]; 
            timingInfo->VSyncpolarity           = DMTTimingTableNT[i][15]; 

            // success.
            return 0;
        } // found the matching mode
    } // loop over all the modes in the table

    // Did not find the specifed resolution/refresh rate conbination.
    return 1;
} // end of vesaGetDMTTimings


// This function simply returns the number of entries in the GTF table
// 

unsigned int vesaGetNumGTFEntries
(
void
)
{
    unsigned int numEntries;

    // For each mode, there are 12 (unsigned int) timing values
    numEntries = sizeof(GTFTimingTable) / (sizeof(unsigned int) * 12);

    return(numEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv4\nvdat.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVDAT.C
//
// Abstract:
//
//     This module contains all the global data used by the NV driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "cmdcnst.h"
#include "modes.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//***************************************************************************************
//
// NV4 supported modes,
//
// 8bpp - all modes, all refresh rates supported
// 16bpp - all modes, all refresh rates supported
// 32bpp - 1280x1024 max at 100Hz, 1600x1200 max at 75Hz, 1920x1080 max at 72Hz, 1920x1200 max at 60Hz
//
//***************************************************************************************

U016 fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS][NUM_REFRESHES][NUM_ELEMENTS] =
{
    //**************************************************************************************
    // 640x480 at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 640,480,8, 60},
    {FALSE, 640,480,8, 70},
    {FALSE, 640,480,8, 72},
    {FALSE, 640,480,8, 75},
    {FALSE, 640,480,8, 85},
    {FALSE, 640,480,8, 100},
    {FALSE, 640,480,8, 120}
    },
    {
    {FALSE, 640,480,15, 60},
    {FALSE, 640,480,15, 70},
    {FALSE, 640,480,15, 72},
    {FALSE, 640,480,15, 75},
    {FALSE, 640,480,15, 85},
    {FALSE, 640,480,15, 100},
    {FALSE, 640,480,15, 120}
    },
    {
    {FALSE, 640,480,16, 60},
    {FALSE, 640,480,16, 70},
    {FALSE, 640,480,16, 72},
    {FALSE, 640,480,16, 75},
    {FALSE, 640,480,16, 85},
    {FALSE, 640,480,16, 100},
    {FALSE, 640,480,16, 120}
    },
    {
    {FALSE, 640,480,24, 60},
    {FALSE, 640,480,24, 70},
    {FALSE, 640,480,24, 72},
    {FALSE, 640,480,24, 75},
    {FALSE, 640,480,24, 85},
    {FALSE, 640,480,24, 100},
    {FALSE, 640,480,24, 120}
    },
    {
    {FALSE, 640,480,32, 60},
    {FALSE, 640,480,32, 70},
    {FALSE, 640,480,32, 72},
    {FALSE, 640,480,32, 75},
    {FALSE, 640,480,32, 85},
    {FALSE, 640,480,32, 100},
    {FALSE, 640,480,32, 120}
    },

    //***********************************************************************************
    // 320x240 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,240,8, 60},
    {FALSE, 320,240,8, 70},
    {FALSE, 320,240,8, 72},
    {FALSE, 320,240,8, 75},
    {FALSE, 320,240,8, 85},
    {FALSE, 320,240,8, 100},
    {FALSE, 320,240,8, 120}
    },
    {
    {FALSE, 320,240,15, 60},
    {FALSE, 320,240,15, 70},
    {FALSE, 320,240,15, 72},
    {FALSE, 320,240,15, 75},
    {FALSE, 320,240,15, 85},
    {FALSE, 320,240,15, 100},
    {FALSE, 320,240,15, 120}
    },
    {
    {FALSE, 320,240,16, 60},
    {FALSE, 320,240,16, 70},
    {FALSE, 320,240,16, 72},
    {FALSE, 320,240,16, 75},
    {FALSE, 320,240,16, 85},
    {FALSE, 320,240,16, 100},
    {FALSE, 320,240,16, 120}
    },
    {
    {FALSE, 320,240,24, 60},
    {FALSE, 320,240,24, 70},
    {FALSE, 320,240,24, 72},
    {FALSE, 320,240,24, 75},
    {FALSE, 320,240,24, 85},
    {FALSE, 320,240,24, 100},
    {FALSE, 320,240,24, 120}
    },
    {
    {FALSE, 320,240,32, 60},
    {FALSE, 320,240,32, 70},
    {FALSE, 320,240,32, 72},
    {FALSE, 320,240,32, 75},
    {FALSE, 320,240,32, 85},
    {FALSE, 320,240,32, 100},
    {FALSE, 320,240,32, 120}
    },
    //***********************************************************************************
    // 320x400 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,400,8, 70},
    {FALSE, 320,400,8, 70},
    {FALSE, 320,400,8, 72},
    {FALSE, 320,400,8, 75},
    {FALSE, 320,400,8, 85},
    {FALSE, 320,400,8, 100},
    {FALSE, 320,400,8, 120}
    },
    {
    {FALSE, 320,400,15, 70},
    {FALSE, 320,400,15, 70},
    {FALSE, 320,400,15, 72},
    {FALSE, 320,400,15, 75},
    {FALSE, 320,400,15, 85},
    {FALSE, 320,400,15, 100},
    {FALSE, 320,400,15, 120}
    },
    {
    {FALSE, 320,400,16, 70},
    {FALSE, 320,400,16, 70},
    {FALSE, 320,400,16, 72},
    {FALSE, 320,400,16, 75},
    {FALSE, 320,400,16, 85},
    {FALSE, 320,400,16, 100},
    {FALSE, 320,400,16, 120}
    },
    {
    {FALSE, 320,400,24, 70},
    {FALSE, 320,400,24, 70},
    {FALSE, 320,400,24, 72},
    {FALSE, 320,400,24, 75},
    {FALSE, 320,400,24, 85},
    {FALSE, 320,400,24, 100},
    {FALSE, 320,400,24, 120}
    },
    {
    {FALSE, 320,400,32, 70},
    {FALSE, 320,400,32, 70},
    {FALSE, 320,400,32, 72},
    {FALSE, 320,400,32, 75},
    {FALSE, 320,400,32, 85},
    {FALSE, 320,400,32, 100},
    {FALSE, 320,400,32, 120}
    },
    //***********************************************************************************
    // 400x300 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 400,300,8, 60},
    {FALSE, 400,300,8, 70},
    {FALSE, 400,300,8, 72},
    {FALSE, 400,300,8, 75},
    {FALSE, 400,300,8, 85},
    {FALSE, 400,300,8, 100},
    {FALSE, 400,300,8, 120}
    },
    {
    {FALSE, 400,300,15, 60},
    {FALSE, 400,300,15, 70},
    {FALSE, 400,300,15, 72},
    {FALSE, 400,300,15, 75},
    {FALSE, 400,300,15, 85},
    {FALSE, 400,300,15, 100},
    {FALSE, 400,300,15, 120}
    },
    {
    {FALSE, 400,300,16, 60},
    {FALSE, 400,300,16, 70},
    {FALSE, 400,300,16, 72},
    {FALSE, 400,300,16, 75},
    {FALSE, 400,300,16, 85},
    {FALSE, 400,300,16, 100},
    {FALSE, 400,300,16, 120}
    },
    {
    {FALSE, 400,300,24, 60},
    {FALSE, 400,300,24, 70},
    {FALSE, 400,300,24, 72},
    {FALSE, 400,300,24, 75},
    {FALSE, 400,300,24, 85},
    {FALSE, 400,300,24, 100},
    {FALSE, 400,300,24, 120}
    },
    {
    {FALSE, 400,300,32, 60},
    {FALSE, 400,300,32, 70},
    {FALSE, 400,300,32, 72},
    {FALSE, 400,300,32, 75},
    {FALSE, 400,300,32, 85},
    {FALSE, 400,300,32, 100},
    {FALSE, 400,300,32, 120}
    },
    //***********************************************************************************
    // 480x360 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 480,360,8, 60},
    {FALSE, 480,360,8, 70},
    {FALSE, 480,360,8, 72},
    {FALSE, 480,360,8, 75},
    {FALSE, 480,360,8, 85},
    {FALSE, 480,360,8, 100},
    {FALSE, 480,360,8, 120}
    },
    {
    {FALSE, 480,360,15, 60},
    {FALSE, 480,360,15, 70},
    {FALSE, 480,360,15, 72},
    {FALSE, 480,360,15, 75},
    {FALSE, 480,360,15, 85},
    {FALSE, 480,360,15, 100},
    {FALSE, 480,360,15, 120}
    },
    {
    {FALSE, 480,360,16, 60},
    {FALSE, 480,360,16, 70},
    {FALSE, 480,360,16, 72},
    {FALSE, 480,360,16, 75},
    {FALSE, 480,360,16, 85},
    {FALSE, 480,360,16, 100},
    {FALSE, 480,360,16, 120}
    },
    {
    {FALSE, 480,360,24, 60},
    {FALSE, 480,360,24, 70},
    {FALSE, 480,360,24, 72},
    {FALSE, 480,360,24, 75},
    {FALSE, 480,360,24, 85},
    {FALSE, 480,360,24, 100},
    {FALSE, 480,360,24, 120}
    },
    {
    {FALSE, 480,360,32, 60},
    {FALSE, 480,360,32, 70},
    {FALSE, 480,360,32, 72},
    {FALSE, 480,360,32, 75},
    {FALSE, 480,360,32, 85},
    {FALSE, 480,360,32, 100},
    {FALSE, 480,360,32, 120}
    },

    //***********************************************************************************
    // 512x384. at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 512,384,8, 60},
    {FALSE, 512,384,8, 70},
    {FALSE, 512,384,8, 72},
    {FALSE, 512,384,8, 75},
    {FALSE, 512,384,8, 85},
    {FALSE, 512,384,8, 100},
    {FALSE, 512,384,8, 120},
    },
    {
    {FALSE, 512,384,15, 60},
    {FALSE, 512,384,15, 70},
    {FALSE, 512,384,15, 72},
    {FALSE, 512,384,15, 75},
    {FALSE, 512,384,15, 85},
    {FALSE, 512,384,15, 100},
    {FALSE, 512,384,15, 120},
    },
    {
    {FALSE, 512,384,16, 60},
    {FALSE, 512,384,16, 70},
    {FALSE, 512,384,16, 72},
    {FALSE, 512,384,16, 75},
    {FALSE, 512,384,16, 85},
    {FALSE, 512,384,16, 100},
    {FALSE, 512,384,16, 120},
    },
    {
    {FALSE, 512,384,24, 60},
    {FALSE, 512,384,24, 70},
    {FALSE, 512,384,24, 72},
    {FALSE, 512,384,24, 75},
    {FALSE, 512,384,24, 85},
    {FALSE, 512,384,24, 100},
    {FALSE, 512,384,24, 120},
    },
    {
    {FALSE, 512,384,32, 60},
    {FALSE, 512,384,32, 70},
    {FALSE, 512,384,32, 72},
    {FALSE, 512,384,32, 75},
    {FALSE, 512,384,32, 85},
    {FALSE, 512,384,32, 100},
    {FALSE, 512,384,32, 120},
    },
    //*************************************************************************************
    // 640x400.  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 640,400,8, 70},
    {FALSE, 640,400,8, 70},
    {FALSE, 640,400,8, 72},
    {FALSE, 640,400,8, 75},
    {FALSE, 640,400,8, 85},
    {FALSE, 640,400,8, 100},
    {FALSE, 640,400,8, 120}
    },
    {
    {FALSE, 640,400,15, 70},
    {FALSE, 640,400,15, 70},
    {FALSE, 640,400,15, 72},
    {FALSE, 640,400,15, 75},
    {FALSE, 640,400,15, 85},
    {FALSE, 640,400,15, 100},
    {FALSE, 640,400,15, 120}
    },
    {
    {FALSE, 640,400,16, 70},
    {FALSE, 640,400,16, 70},
    {FALSE, 640,400,16, 72},
    {FALSE, 640,400,16, 75},
    {FALSE, 640,400,16, 85},
    {FALSE, 640,400,16, 100},
    {FALSE, 640,400,16, 120}
    },
    {
    {FALSE, 640,400,24, 70},
    {FALSE, 640,400,24, 70},
    {FALSE, 640,400,24, 72},
    {FALSE, 640,400,24, 75},
    {FALSE, 640,400,24, 85},
    {FALSE, 640,400,24, 100},
    {FALSE, 640,400,24, 120}
    },
    {
    {FALSE, 640,400,32, 70},
    {FALSE, 640,400,32, 70},
    {FALSE, 640,400,32, 72},
    {FALSE, 640,400,32, 75},
    {FALSE, 640,400,32, 85},
    {FALSE, 640,400,32, 100},
    {FALSE, 640,400,32, 120}
    },

    //***********************************************************************************
    // 320x200  at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,200,8, 70},
    {FALSE, 320,200,8, 70},
    {FALSE, 320,200,8, 72},
    {FALSE, 320,200,8, 75},
    {FALSE, 320,200,8, 85},
    {FALSE, 320,200,8, 100},
    {FALSE, 320,200,8, 120}
    },
    {
    {FALSE, 320,200,15, 70},
    {FALSE, 320,200,15, 70},
    {FALSE, 320,200,15, 72},
    {FALSE, 320,200,15, 75},
    {FALSE, 320,200,15, 85},
    {FALSE, 320,200,15, 100},
    {FALSE, 320,200,15, 120}
    },
    {
    {FALSE, 320,200,16, 70},
    {FALSE, 320,200,16, 70},
    {FALSE, 320,200,16, 72},
    {FALSE, 320,200,16, 75},
    {FALSE, 320,200,16, 85},
    {FALSE, 320,200,16, 100},
    {FALSE, 320,200,16, 120}
    },
    {
    {FALSE, 320,200,24, 70},
    {FALSE, 320,200,24, 70},
    {FALSE, 320,200,24, 72},
    {FALSE, 320,200,24, 75},
    {FALSE, 320,200,24, 85},
    {FALSE, 320,200,24, 100},
    {FALSE, 320,200,24, 120}
    },
    {
    {FALSE, 320,200,32, 70},
    {FALSE, 320,200,32, 70},
    {FALSE, 320,200,32, 72},
    {FALSE, 320,200,32, 75},
    {FALSE, 320,200,32, 85},
    {FALSE, 320,200,32, 100},
    {FALSE, 320,200,32, 120}
    },

    //**************************************************************************************
    // 800x600.  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 800,600,8, 60},
    {FALSE, 800,600,8, 70},
    {FALSE, 800,600,8, 72},
    {FALSE, 800,600,8, 75},
    {FALSE, 800,600,8, 85},
    {FALSE, 800,600,8, 100},
    {FALSE, 800,600,8, 120}
    },
    {
    {FALSE, 800,600,15, 60},
    {FALSE, 800,600,15, 70},
    {FALSE, 800,600,15, 72},
    {FALSE, 800,600,15, 75},
    {FALSE, 800,600,15, 85},
    {FALSE, 800,600,15, 100},
    {FALSE, 800,600,15, 120}
    },
    {
    {FALSE, 800,600,16, 60},
    {FALSE, 800,600,16, 70},
    {FALSE, 800,600,16, 72},
    {FALSE, 800,600,16, 75},
    {FALSE, 800,600,16, 85},
    {FALSE, 800,600,16, 100},
    {FALSE, 800,600,16, 120}
    },
    {
    {FALSE, 800,600,24, 60},
    {FALSE, 800,600,24, 70},
    {FALSE, 800,600,24, 72},
    {FALSE, 800,600,24, 75},
    {FALSE, 800,600,24, 85},
    {FALSE, 800,600,24, 100},
    {FALSE, 800,600,24, 120}
    },
    {
    {FALSE, 800,600,32, 60},
    {FALSE, 800,600,32, 70},
    {FALSE, 800,600,32, 72},
    {FALSE, 800,600,32, 75},
    {FALSE, 800,600,32, 85},
    {FALSE, 800,600,32, 100},
    {FALSE, 800,600,32, 120}
    },
    //**************************************************************************************
    // 960x720  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 960,720,8, 60},
    {FALSE, 960,720,8, 70},
    {FALSE, 960,720,8, 72},
    {FALSE, 960,720,8, 75},
    {FALSE, 960,720,8, 85},
    {FALSE, 960,720,8, 100},
    {FALSE, 960,720,8, 120}
    },
    {
    {FALSE, 960,720,15, 60},
    {FALSE, 960,720,15, 70},
    {FALSE, 960,720,15, 72},
    {FALSE, 960,720,15, 75},
    {FALSE, 960,720,15, 85},
    {FALSE, 960,720,15, 100},
    {FALSE, 960,720,15, 120}
    },
    {
    {FALSE, 960,720,16, 60},
    {FALSE, 960,720,16, 70},
    {FALSE, 960,720,16, 72},
    {FALSE, 960,720,16, 75},
    {FALSE, 960,720,16, 85},
    {FALSE, 960,720,16, 100},
    {FALSE, 960,720,16, 120}
    },
    {
    {FALSE, 960,720,24, 60},
    {FALSE, 960,720,24, 70},
    {FALSE, 960,720,24, 72},
    {FALSE, 960,720,24, 75},
    {FALSE, 960,720,24, 85},
    {FALSE, 960,720,24, 100},
    {FALSE, 960,720,24, 120}
    },
    {
    {FALSE, 960,720,32, 60},
    {FALSE, 960,720,32, 70},
    {FALSE, 960,720,32, 72},
    {FALSE, 960,720,32, 75},
    {FALSE, 960,720,32, 85},
    {FALSE, 960,720,32, 100},
    {FALSE, 960,720,32, 120}
    },
    //**************************************************************************************
    // 1024x768  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1024,768,8, 60},
    {FALSE, 1024,768,8, 70},
    {FALSE, 1024,768,8, 72},
    {FALSE, 1024,768,8, 75},
    {FALSE, 1024,768,8, 85},
    {FALSE, 1024,768,8, 100},
    {FALSE, 1024,768,8, 120}
    },
    {
    {FALSE, 1024,768,15, 60},
    {FALSE, 1024,768,15, 70},
    {FALSE, 1024,768,15, 72},
    {FALSE, 1024,768,15, 75},
    {FALSE, 1024,768,15, 85},
    {FALSE, 1024,768,15, 100},
    {FALSE, 1024,768,15, 120}
    },
    {
    {FALSE, 1024,768,16, 60},
    {FALSE, 1024,768,16, 70},
    {FALSE, 1024,768,16, 72},
    {FALSE, 1024,768,16, 75},
    {FALSE, 1024,768,16, 85},
    {FALSE, 1024,768,16, 100},
    {FALSE, 1024,768,16, 120}
    },
    {
    {FALSE, 1024,768,24, 60},
    {FALSE, 1024,768,24, 70},
    {FALSE, 1024,768,24, 72},
    {FALSE, 1024,768,24, 75},
    {FALSE, 1024,768,24, 85},
    {FALSE, 1024,768,24, 100},
    {FALSE, 1024,768,24, 120}
    },
    {
    {FALSE, 1024,768,32, 60},
    {FALSE, 1024,768,32, 70},
    {FALSE, 1024,768,32, 72},
    {FALSE, 1024,768,32, 75},
    {FALSE, 1024,768,32, 85},
    {FALSE, 1024,768,32, 100},
    {FALSE, 1024,768,32, 120}
    },
    //*************************************************************************************
    // 1152x864  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 1152,864,8, 60},
    {FALSE, 1152,864,8, 70},
    {FALSE, 1152,864,8, 72},
    {FALSE, 1152,864,8, 75},
    {FALSE, 1152,864,8, 85},
    {FALSE, 1152,864,8, 100},
    {FALSE, 1152,864,8, 120}
    },
    {
    {FALSE, 1152,864,15, 60},
    {FALSE, 1152,864,15, 70},
    {FALSE, 1152,864,15, 72},
    {FALSE, 1152,864,15, 75},
    {FALSE, 1152,864,15, 85},
    {FALSE, 1152,864,15, 100},
    {FALSE, 1152,864,15, 120}
    },
    {
    {FALSE, 1152,864,16, 60},
    {FALSE, 1152,864,16, 70},
    {FALSE, 1152,864,16, 72},
    {FALSE, 1152,864,16, 75},
    {FALSE, 1152,864,16, 85},
    {FALSE, 1152,864,16, 100},
    {FALSE, 1152,864,16, 120}
    },
    {
    {FALSE, 1152,864,24, 60},
    {FALSE, 1152,864,24, 70},
    {FALSE, 1152,864,24, 72},
    {FALSE, 1152,864,24, 75},
    {FALSE, 1152,864,24, 85},
    {FALSE, 1152,864,24, 100},
    {FALSE, 1152,864,24, 120}
    },
    {
    {FALSE, 1152,864,32, 60},
    {FALSE, 1152,864,32, 70},
    {FALSE, 1152,864,32, 72},
    {FALSE, 1152,864,32, 75},
    {FALSE, 1152,864,32, 85},
    {FALSE, 1152,864,32, 100},
    {FALSE, 1152,864,32, 120}
    },
    //*************************************************************************************
    // 1280x1024  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 1280,1024,8, 60},
    {FALSE, 1280,1024,8, 70},
    {FALSE, 1280,1024,8, 72},
    {FALSE, 1280,1024,8, 75},
    {FALSE, 1280,1024,8, 85},
    {FALSE, 1280,1024,8, 100},
    {FALSE, 1280,1024,8, 120}
    },
    {
    {FALSE, 1280,1024,15, 60},
    {FALSE, 1280,1024,15, 70},
    {FALSE, 1280,1024,15, 72},
    {FALSE, 1280,1024,15, 75},
    {FALSE, 1280,1024,15, 85},
    {FALSE, 1280,1024,15, 100},
    {FALSE, 1280,1024,15, 120}
    },
    {
    {FALSE, 1280,1024,16, 60},
    {FALSE, 1280,1024,16, 70},
    {FALSE, 1280,1024,16, 72},
    {FALSE, 1280,1024,16, 75},
    {FALSE, 1280,1024,16, 85},
    {FALSE, 1280,1024,16, 100},
    {FALSE, 1280,1024,16, 120}
    },
    {
    {FALSE, 1280,1024,24, 60},
    {FALSE, 1280,1024,24, 70},
    {FALSE, 1280,1024,24, 72},
    {FALSE, 1280,1024,24, 75},
    {FALSE, 1280,1024,24, 85},
    {FALSE, 1280,1024,24, 100},
    {FALSE, 1280,1024,24, 100}
    },
    {
    {FALSE, 1280,1024,32, 60},
    {FALSE, 1280,1024,32, 70},
    {FALSE, 1280,1024,32, 72},
    {FALSE, 1280,1024,32, 75},
    {FALSE, 1280,1024,32, 85},
    {FALSE, 1280,1024,32, 100},
    {FALSE, 1280,1024,32, 100}
    },
    //**************************************************************************************
    // 1600x1024  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1600,1024,8, 60},
    {FALSE, 1600,1024,8, 70},
    {FALSE, 1600,1024,8, 72},
    {FALSE, 1600,1024,8, 76},
    {FALSE, 1600,1024,8, 85},
    {FALSE, 1600,1024,8, 85},
    {FALSE, 1600,1024,8, 85}
     },
    {
    {FALSE, 1600,1024,15, 60},
    {FALSE, 1600,1024,15, 70},
    {FALSE, 1600,1024,15, 72},
    {FALSE, 1600,1024,15, 76},
    {FALSE, 1600,1024,15, 85},
    {FALSE, 1600,1024,15, 85},
    {FALSE, 1600,1024,15, 85}
     },
    {
    {FALSE, 1600,1024,16, 60},
    {FALSE, 1600,1024,16, 70},
    {FALSE, 1600,1024,16, 72},
    {FALSE, 1600,1024,16, 76},
    {FALSE, 1600,1024,16, 85},
    {FALSE, 1600,1024,16, 85},
    {FALSE, 1600,1024,16, 85}
     },
    {
    {FALSE, 1600,1024,24, 60},
    {FALSE, 1600,1024,24, 70},
    {FALSE, 1600,1024,24, 72},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76}
     },
    {
    {FALSE, 1600,1024,32, 60},
    {FALSE, 1600,1024,32, 70},
    {FALSE, 1600,1024,32, 72},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76}
     },
    //**************************************************************************************
    // 1600x1200  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1600,1200,8, 60},
    {FALSE, 1600,1200,8, 70},
    {FALSE, 1600,1200,8, 72},
    {FALSE, 1600,1200,8, 75},
    {FALSE, 1600,1200,8, 85},
    {FALSE, 1600,1200,8, 85},
    {FALSE, 1600,1200,8, 85}
     },
    {
    {FALSE, 1600,1200,15, 60},
    {FALSE, 1600,1200,15, 70},
    {FALSE, 1600,1200,15, 72},
    {FALSE, 1600,1200,15, 75},
    {FALSE, 1600,1200,15, 85},
    {FALSE, 1600,1200,15, 85},
    {FALSE, 1600,1200,15, 85}
     },
    {
    {FALSE, 1600,1200,16, 60},
    {FALSE, 1600,1200,16, 70},
    {FALSE, 1600,1200,16, 72},
    {FALSE, 1600,1200,16, 75},
    {FALSE, 1600,1200,16, 85},
    {FALSE, 1600,1200,16, 85},
    {FALSE, 1600,1200,16, 85}
     },
    {
    {FALSE, 1600,1200,24, 60},
    {FALSE, 1600,1200,24, 70},
    {FALSE, 1600,1200,24, 72},
    {FALSE, 1600,1200,24, 75},
    {FALSE, 1600,1200,24, 85},
    {FALSE, 1600,1200,24, 85},
    {FALSE, 1600,1200,24, 85}
     },
    {
    {FALSE, 1600,1200,32, 60},
    {FALSE, 1600,1200,32, 70},
    {FALSE, 1600,1200,32, 72},
    {FALSE, 1600,1200,32, 75},
    {FALSE, 1600,1200,32, 85},
    {FALSE, 1600,1200,32, 85},
    {FALSE, 1600,1200,32, 85}
     },
     //**************************************************************************************
     // 1800x1440  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60}
      },
     {
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60}
      },
     {
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60}
      },
     {
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60}
      },
     {
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60}
      },
     //**************************************************************************************
     // 1920x1080  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1920,1080,8, 60},
     {FALSE, 1920,1080,8, 70},
     {FALSE, 1920,1080,8, 72},
     {FALSE, 1920,1080,8, 75},
     {FALSE, 1920,1080,8, 85},
     {FALSE, 1920,1080,8, 85},
     {FALSE, 1920,1080,8, 85}
      },
     {
     {FALSE, 1920,1080,15, 60},
     {FALSE, 1920,1080,15, 70},
     {FALSE, 1920,1080,15, 72},
     {FALSE, 1920,1080,15, 75},
     {FALSE, 1920,1080,15, 85},
     {FALSE, 1920,1080,15, 85},
     {FALSE, 1920,1080,15, 85}
      },
     {
     {FALSE, 1920,1080,16, 60},
     {FALSE, 1920,1080,16, 70},
     {FALSE, 1920,1080,16, 72},
     {FALSE, 1920,1080,16, 75},
     {FALSE, 1920,1080,16, 85},
     {FALSE, 1920,1080,16, 85},
     {FALSE, 1920,1080,16, 85}
      },
     {
     {FALSE, 1920,1080,24, 60},
     {FALSE, 1920,1080,24, 70},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72}
      },
     {
     {FALSE, 1920,1080,32, 60},
     {FALSE, 1920,1080,32, 70},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72}
      },
     //**************************************************************************************
     // 1920x1200  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1920,1200,8, 60},
     {FALSE, 1920,1200,8, 70},
     {FALSE, 1920,1200,8, 72},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75}
      },
     {
     {FALSE, 1920,1200,15, 60},
     {FALSE, 1920,1200,15, 70},
     {FALSE, 1920,1200,15, 72},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75}
      },
     {
     {FALSE, 1920,1200,16, 60},
     {FALSE, 1920,1200,16, 70},
     {FALSE, 1920,1200,16, 72},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75}
      },
     {
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60}
      },
     {
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60}
      }
};
//******************************************************************************
// Use a slightly different mode table for NV4
//******************************************************************************


MODEDESC mib[] =             // Our Mode List
{
//    +------- vmode                                max DCLK     ------+
//    |      +----- imode                           row offset   -----+|
//    |      |      +----- std_modetbl              y resolution ----+||
//    |      |      |      +----- ext_modetbl       x resolution ---+|||
//    |      |      |      |     +----- tv_modetbl                  ||||
//    |      |      |      |     |     +----- crtc_override         ||||
//    |      |      |      |     |     |     +----- bits per pixel  ||||
//    |      |      |      |     |     |     |    +-----------------+|||
//    |      |      |      |     |     |     |    |     +------------+||
//    |      |      |      |     |     |     |    |     |     +-------+|
//    |      |      |      |     |     |     |    |     |     |    +---+
//    V      V      V      V     V     V     V    V     V     V    V
    {0x100, 0x5B, PACKED, 0x11, 0x05, 0x06,  8,  640,  400,  640, MAX_DCLK},  // Mode 100 - 640x400    8bpp
    {0x101, 0x5F, PACKED, 0x01, 0x06, 0xFF,  8,  640,  480,  640, MAX_DCLK},  // Mode 101 - 640x480    8bpp
    {0x102, 0x58, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode 102 - 800x600    4bpp
    {0x102, 0x6A, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode  6A - 800x600    4bpp
    {0x103, 0x5C, PACKED, 0x03, 0x07, 0x08,  8,  800,  600,  800, MAX_DCLK},  // Mode 103 - 800x600    8bpp
    {0x104, 0x5D, PLANAR, 0x04, 0x03, 0x0A,  4, 1024,  768, 1024, MAX_ATC },  // Mode 104 - 1024x768   4bpp
    {0x105, 0x5E, PACKED, 0x05, 0xff, 0x0B,  8, 1024,  768, 1024, MAX_DCLK},  // Mode 105 - 1024x768   8bpp
    {0x106, 0x5A, PLANAR, 0x06, 0x03, 0x0D,  4, 1280, 1024,  160, MAX_ATC },  // Mode 106 - 1280x1024  4bpp
    {0x107, 0x6B, PACKED, 0x07, 0xff, 0x0E,  8, 1280, 1024, 1280, MAX_DCLK},  // Mode 107 - 1280x1024  8bpp
    {0x10E, 0x78, PACKED, 0x0D, 0x00, 0x00, 16,  320,  200,  640, MAX_DCLK},  // Mode 10E - 320x200   16bpp
    {0x10F, 0x20, PACKED, 0x12, 0x00, 0x00, 32,  320,  200, 1280, MAX_DCLK},  // Mode 10F - 320x200 32bpp
    {0x111, 0x6E, PACKED, 0x0E, 0x06, 0xFF, 16,  640,  480, 1280, MAX_DCLK},  // Mode 111 - 640x480 16bpp
    {0x112, 0x21, PACKED, 0x19, 0x06, 0xFF, 32,  640,  480, 2560, MAX_DCLK},  // Mode 112 - 640x480 32bpp
    {0x114, 0x6F, PACKED, 0x0F, 0x07, 0x08, 16,  800,  600, 1600, MAX_DCLK},  // Mode 114 - 800x600 16bpp
    {0x115, 0x22, PACKED, 0x1A, 0x07, 0x08, 32,  800,  600, 3200, MAX_DCLK},  // Mode 115 - 800x600 32bpp
    {0x117, 0x72, PACKED, 0x10, 0xff, 0x0B, 16, 1024,  768, 2048, MAX_DCLK},  // Mode 117 - 1024x768 16bpp
    {0x118, 0x3F, PACKED, 0x1C, 0xff, 0x0B, 32, 1024,  768, 4096, MAX_DCLK},  // Mode 118 - 1024x768 32bpp
    {0x11A, 0x44, PACKED, 0x2F, 0xff, 0x0E, 16, 1280, 1024, 2560, MAX_DCLK},  // Mode 11A - 1280x1024 16bbp
    {0x130, 0x30, PACKED, 0x1E, 0x00, 0x00,  8,  320,  200,  320, MAX_DCLK},  // Mode 130 - 320x200  8bbp
    {0x131, 0x31, PACKED, 0x1F, 0x02, 0x02,  8,  320,  400,  320, MAX_DCLK},  // Mode 131 - 320x400 8bpp
    {0x132, 0x32, PACKED, 0x27, 0x02, 0x02, 16,  320,  400,  640, MAX_DCLK},  // Mode 132 - 320x400 16bpp
    {0x133, 0x33, PACKED, 0x13, 0x02, 0x02, 32,  320,  400, 1280, MAX_DCLK},  // Mode 133 - 320x400 32bpp
    {0x134, 0x34, PACKED, 0x20, 0x01, 0x01,  8,  320,  240,  320, MAX_DCLK},  // Mode 134 - 320x240 8bpp
    {0x135, 0x35, PACKED, 0x28, 0x01, 0x01, 16,  320,  240,  640, MAX_DCLK},  // Mode 135 - 320x240 16
    {0x136, 0x36, PACKED, 0x14, 0x01, 0x01, 32,  320,  240, 1280, MAX_DCLK},  // Mode 136 - 320x240 32
    {0x137, 0x37, PACKED, 0x21, 0x03, 0x03,  8,  400,  300,  400, MAX_DCLK},  // Mode 137 - 400x300 8
    {0x138, 0x38, PACKED, 0x29, 0x03, 0x03, 16,  400,  300,  800, MAX_DCLK},  // Mode 138 - 400x300 16
    {0x139, 0x39, PACKED, 0x15, 0x03, 0x03, 32,  400,  300, 1600, MAX_DCLK},  // Mode 139 - 400x300 32
    {0x13A, 0x3A, PACKED, 0x23, 0x04, 0x05,  8,  512,  384,  512, MAX_DCLK},  // Mode 13A - 512x384 8
    {0x13B, 0x3B, PACKED, 0x2B, 0x04, 0x05, 16,  512,  384, 1024, MAX_DCLK},  // Mode 13B - 512x384 16
    {0x13C, 0x3C, PACKED, 0x17, 0x04, 0x05, 32,  512,  384, 2048, MAX_DCLK},  // Mode 13C - 512x384 32
    {0x13D, 0x3D, PACKED, 0x2C, 0x05, 0x06, 16,  640,  400, 1280, MAX_DCLK},  // Mode 13D - 640x400 16
    {0x13E, 0x3E, PACKED, 0x18, 0x05, 0x06, 32,  640,  400, 2560, MAX_DCLK},  // Mode 13E - 640x400 32
    {0x141, 0x41, PACKED, 0x25, 0xff, 0x0C,  8, 1152,  864, 1152, MAX_DCLK},  // Mode 141 - 1152x864 8
    {0x142, 0x42, PACKED, 0x2E, 0xff, 0x0C, 16, 1152,  864, 2304, MAX_DCLK},  // Mode 142 - 1152x864 16
    {0x143, 0x43, PACKED, 0x1D, 0xff, 0x0C, 32, 1152,  864, 4608, MAX_DCLK},  // Mode 143 - 1152x864 32
    {0x145, 0x45, PACKED, 0x26, 0xFF, 0x0F,  8, 1600, 1200, 1600, MAX_DCLK},  // Mode 145 - 1600x1200 8
    {0x146, 0x46, PACKED, 0x30, 0xFF, 0x0F, 16, 1600, 1200, 3200, MAX_DCLK},  // Mode 146 - 1600x1200 16
    // more TV modes?
    {0x147, 0x47, PACKED, 0x22, 0xFF, 0x04,  8,  480,  360,  480, MAX_DCLK},  // Mode 147 - 480x360 8
    {0x148, 0x48, PACKED, 0x2A, 0xFF, 0x04, 16,  480,  360,  960, MAX_DCLK},  // Mode 148 - 480x360 16
    {0x149, 0x49, PACKED, 0x16, 0xFF, 0x04, 32,  480,  360, 1920, MAX_DCLK},  // Mode 149 - 480x360 32
    {0x14A, 0x4A, PACKED, 0x24, 0xff, 0x09,  8,  960,  720,  960, MAX_DCLK},  // Mode 14A - 960x720 8
    {0x14B, 0x4B, PACKED, 0x2D, 0xff, 0x09, 16,  960,  720, 1920, MAX_DCLK},  // Mode 14B - 960x720 16
    {0x14C, 0x4C, PACKED, 0x1B, 0xff, 0x09, 32,  960,  720, 3840, MAX_DCLK},  // Mode 14C - 960x720 32
    {0x14D, 0x4D, PACKED, 0x31, 0xff, 0x0E, 32, 1280, 1024, 5120, MAX_DCLK},  // Mode 14D - 1280x1024 32
    {0x14E, 0x4E, PACKED, 0x32, 0xFF, 0x0F, 32, 1600, 1200, 6400, MAX_DCLK},  // Mode 14E - 1600x1200 32

    // JJV - New Modes
    {0x14F, 0x80, PACKED, 0x33, 0xFF, 0x10,  8, 1800, 1440, 1800, MAX_DCLK},    // Mode 14F - 1800x1440 8
    {0x150, 0x81, PACKED, 0x34, 0xFF, 0x11, 16, 1800, 1440, 3600, MAX_DCLK},    // Mode 150 - 1800x1440 16
    {0x151, 0x82, PACKED, 0x35, 0xFF, 0x12,  8, 1920, 1080, 1920, MAX_DCLK},    // Mode 151 - 1920x1080 8
    {0x152, 0x83, PACKED, 0x36, 0xFF, 0x13, 16, 1920, 1080, 3840, MAX_DCLK},    // Mode 152 - 1920x1080 16
    {0x153, 0x84, PACKED, 0x37, 0xFF, 0x14, 32, 1920, 1080, 7680, MAX_DCLK},    // Mode 153 - 1920x1080 32
    {0x154, 0x85, PACKED, 0x38, 0xFF, 0x15,  8, 1920, 1200, 1920, MAX_DCLK},    // Mode 154 - 1920x1200 8
    {0x155, 0x86, PACKED, 0x39, 0xFF, 0x16, 16, 1920, 1200, 3840, MAX_DCLK},    // Mode 155 - 1920x1200 16
    {0x156, 0x87, PACKED, 0x3A, 0xFF, 0x17, 32, 1920, 1200, 7680, MAX_DCLK},    // Mode 156 - 1920x1200 32
    // JJV - New Modes

    // VEL - New Dell Specific Modes
    {0x157, 0x88, PACKED, 0x3B, 0xFF, 0x18,  8, 1600, 1024, 1600, MAX_DCLK},  // Mode 157 - 1600x1024 8
    {0x158, 0x89, PACKED, 0x3C, 0xFF, 0x19, 16, 1600, 1024, 3200, MAX_DCLK},  // Mode 158 - 1600x1024 16
    {0x159, 0x8A, PACKED, 0x3D, 0xFF, 0x1A, 32, 1600, 1024, 6400, MAX_DCLK},  // Mode 159 - 1600x1024 32
    // VEL - New Dell Specific Modes

    {0xFFFF,0xFF, 0xFF,   0xFF, 0xFF, 0xFF,  0,    0,    0,    0, 0}          // List Terminator
};


CRTC_OVERRIDE crt_override[] =       // Mode overide table for CRTC
{
    // 0. Mode 20h, 78h / VESA Mode 10Eh, 10Fh
    //    320x200 16-bit/32-bit color graphics
    { 0x28, 0x18, 0x08, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0xC0, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 1. Mode 34h,35h,36h / VESA Mode 134h,135h,136h
    //       320x240 16-bit Color Graphics (8x8 font, 40x30 "Text")
    { 0x28, 0x1D, 0x08, 0xE3, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0x0B, 0x3E, 0xC0, 0xEA, 0x0C, 0xDF, 0xDF, 0x0C },

    // 2. Mode 31h,32h,33h / VESA Mode 131h,132h,133h
    //    320x400 16-bit Color Graphics (8x16 font, 40x25 "Text")
    { 0x28, 0x18, 0x10, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 3. Mode 37h,38h,39h / VESA Mode 137h,138h,139h
    //       400x300 16-bit Color Graphics (8x8 font, 50x37 "Text")
    { 0x32, 0x24, 0x08, 0x2B, 0x01, 0x3D, 0x31, 0x31, 0x81, 0x35, 0x1D,
      0x72, 0xF0, 0xE0, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 4. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       480x360 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x3C, 0x2C, 0x08, 0xEB, 0x01, 0x49, 0x3B, 0x3B, 0x8D, 0x40, 0x08,
      0xE8, 0xF0, 0xE0, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },

    // 5. Mode 3Ah,3Bh,3Ch / VESA Mode 13Ah,13Bh,13Ch
    //       512x384 16-bit Color Graphics (8x8 font, 64x48 "Text")
    { 0x40, 0x2F, 0x08, 0xEB, 0x01, 0x4F, 0x3F, 0x3F, 0x93, 0x43, 0x0B,
      0x24, 0xF5, 0xE0, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // 6. Mode 5Bh / VESA Mode 100h / Internal Mode 26h
    //       640x400 8-bit Color Graphics (8x16 font, 80x25 "Text")
    { 0x50, 0x18, 0x10, 0x63, 0x01, 0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 7. Internal Mode 9
    // Mode 58 / VESA Mode 6A / VESA Mode 102 800x600x4
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6B, 0x1B,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 8. Mode 6F / VESA Mode 114h / Internal Mode 24h
    //       800x600 16-bit Color Graphics (8x16 font, 100x37 "Text")
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6A, 0x1A,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 9. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       960x720 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x78, 0x2C, 0x10, 0xEB, 0x01, 0x97, 0x77, 0x77, 0x9B, 0x7F, 0x0B,
      0xE8, 0xF0, 0x60, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },

    // A. Mode B
    // Mode 5D / VESA Mode 104 1024x768x4
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x85, 0x96,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // B. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       1024x768 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x84, 0x95,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // C. Mode 41h/42h/43h / VESA Mode 141,142,143
    // 1152x864x16
    { 0x90, 0x35, 0x10, 0x2B, 0x01, 0xB9, 0x8F, 0x8F, 0x9D, 0x9A, 0x89,
      0x7D, 0xFF, 0x60, 0x61, 0x04, 0x5F, 0x5F, 0x7E },

    // D. Internal Mode F
    // Mode 5A / VESA Mode 106 1280x1024x4
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xAA, 0x1A,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },

    // E. Internal Mode 10
    // Mode 6B / VESA Mode 107 1280x1024x8
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xA9, 0x19,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },

    // F. Mode 45h/46h / VESA Mode 145,146
    // 1600x1200x16
    { 0xC8, 0x4A, 0x10, 0x2B, 0x01, 0x03, 0xC7, 0xC7, 0x87, 0xD1, 0x09,
      0xE0, 0x10, 0x40, 0xB1, 0x04, 0xAF, 0xAF, 0xE1 },

    // JJV - Start
    // 10. Mode ?
    // 1880x1440x8
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },

    // 11. Mode ?
    // 1880x1440x16
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },

    // 12. Mode ?
    // 1920x1080x8
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 13. Mode ?
    // 1920x1080x16
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 14. Mode ?
    // 1920x1080x32
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 15. Mode ?
    // 1920x1200x8
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },

    // 16. Mode ?
    // 1920x1200x16
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },

    // 17. Mode ?
    // 1920x1200x32
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
    // JJV - End

    // 18. Mode ?
    // 1600x1024x8
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 },

    // 19. Mode ?
    // 1600x1024x16
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 },

    // 1A. Mode ?
    // 1600x1024x32
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 }
    // VEL - End



};

//******************************************************************************
// NV4 specific data
//******************************************************************************
//
// NV4 Fifo/Watermark settings (100MHz/100MHz operation)
//
MODESET_FIFO DACFifoTable[] =
{
    { 440, 0x20, 0x03, 0x20, 0x04 },
    { 460, 0x21, 0x03, 0x21, 0x04 },
    { 480, 0x23, 0x03, 0x23, 0x04 },
    { 500, 0x26, 0x03, 0x26, 0x04 },
    { 520, 0x27, 0x03, 0x27, 0x04 },
    { 540, 0x27, 0x03, 0x27, 0x04 },
    { 560, 0x29, 0x03, 0x29, 0x04 },
    { 580, 0x2b, 0x03, 0x2b, 0x04 },
    { 600, 0x2e, 0x03, 0x2e, 0x04 },
    { 620, 0x31, 0x03, 0x31, 0x04 },
    { 640, 0x32, 0x02, 0x32, 0x04 },
    { 660, 0x32, 0x02, 0x32, 0x04 },
    { 680, 0x33, 0x02, 0x33, 0x04 },
    { 700, 0x34, 0x02, 0x34, 0x04 },
    { 720, 0x36, 0x02, 0x36, 0x04 },
    { 740, 0x3a, 0x01, 0x3a, 0x04 },
    {0xFFFF, 0x3f, 0x01, 0x3f, 0x04}    // max marker
};


#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv4\nv4.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV4.C
//
// Abstract:
//
//     This is code specific to NV4
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvMultiMon.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"
#include "vesadata.h"

#include "nvos.h"
#include "rm.h"

#include "nvreg.h"
#include "nvcm.h"
#include "nv_name.h"

VOID FlatPanelCrtc(U016);
VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID NV_ReadAndCopyRegistryData(PHW_DEVICE_EXTENSION,WCHAR *,U016 *);
VOID LoadDefaultRegistrySwitchValues(PHW_DEVICE_EXTENSION);
VOID BubbleSort(PHW_DEVICE_EXTENSION,PMODE_ENTRY,ULONG);
VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
VOID NV4ChipFBPowerSave(PHW_DEVICE_EXTENSION);
VOID NV4ChipFBPowerRestore(PHW_DEVICE_EXTENSION);
VOID NV4SaveInstanceMemory(PHW_DEVICE_EXTENSION);
VOID NV4RestoreInstanceMemory(PHW_DEVICE_EXTENSION);
VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension);

//******************************************************************************
// External Declarations
//******************************************************************************

extern U016 ModeSetTable[];
extern U016 DMTOverrideTable[][13];
extern CRTC_OVERRIDE crt_override[];
extern EXTREGS eregs[];
extern U016 tblClockFreq[];
extern U016 VBESetModeEx(PHW_DEVICE_EXTENSION, U016, PGTF_TIMINGS, PDMT_OVERRIDES, U016);
extern VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION pHwDevExt);
extern MODESET_FIFO DACFifoTable[];
extern unsigned int GTFTimingTable[][12];
extern U016 ValidModeTable[];
extern U016 registry_data[];

extern ULONG my_strcmp(PUCHAR ,PUCHAR);
extern VOID my_strupr(PUCHAR);
extern VOID my_strcpy(PUCHAR , PUCHAR);

extern VOID NV10ChipFBPowerSave(PHW_DEVICE_EXTENSION);
extern VOID NV10ChipFBPowerRestore(PHW_DEVICE_EXTENSION);
extern VOID NV10SaveInstanceMemory(PHW_DEVICE_EXTENSION);
extern VOID NV10RestoreInstanceMemory(PHW_DEVICE_EXTENSION);

extern ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);


//******************************************************************************
// Global tables default registry settings
// (Type, ValueName, SwitchIsPresent, Offset of structure member)
//******************************************************************************

NT_NV_REGISTRY_SWITCH_OFFSET Nv_Registry_Switch_Offset_Table[] =
    {


// STUB OUT FOR NOW SINCE \common\NVREG.H is constantly changing 
// and breaking the NT build.  When NVREG.H settles down, then
// we can put this function back in

    { IS_DWORD , "PLACEHOLDER" ,                                offsetof(NT_NV_REGISTRY, Display.DisplayType)                   }

//    //**************************************************************************
//    // Display Registry Switch Names
//    //**************************************************************************
//
//    { IS_STRING , NV4_REG_DRV_LAST_DEVICE ,                   offsetof(NT_NV_REGISTRY, Display.LastDisplayDevice[0])          },
//    { IS_STRING , NV4_REG_DRV_LAST_CRT_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastCRTMode[0])                },
//    { IS_STRING , NV4_REG_DRV_LAST_DFP_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastDFPMode[0])                },
//    { IS_STRING , NV4_REG_DRV_LAST_NTSC_MODE ,                offsetof(NT_NV_REGISTRY, Display.LastNTSCMode[0])               },
//    { IS_STRING , NV4_REG_DRV_LAST_PAL_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastPALMode[0])                },
//    { IS_STRING , NV4_REG_DRV_CRT_MODE ,                      offsetof(NT_NV_REGISTRY, Display.CRTMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_DFP_MODE ,                      offsetof(NT_NV_REGISTRY, Display.DFPMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_NTSC_MODE ,                     offsetof(NT_NV_REGISTRY, Display.NTSCMode[0])                   },
//    { IS_STRING , NV4_REG_DRV_PAL_MODE ,                      offsetof(NT_NV_REGISTRY, Display.PALMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.DefaultCRTRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.DefaultDFPRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.OptimalCRTRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.OptimalDFPRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_DISPLAY_DEVICE_TYPE ,           offsetof(NT_NV_REGISTRY, Display.DisplayDeviceType[0])          },
//    { IS_DWORD , "Display Type" ,                             offsetof(NT_NV_REGISTRY, Display.DisplayType)                   },
//    { IS_DWORD , "TV Type" ,                                  offsetof(NT_NV_REGISTRY, Display.TVType)                        },
//    { IS_DWORD  , NV4_REG_DRV_MONITOR_TIMING ,                offsetof(NT_NV_REGISTRY, Display.MonitorTiming)                 },
//    { IS_DWORD  , NV4_REG_DRV_CURSOR_ALPHA ,                  offsetof(NT_NV_REGISTRY, Display.CursorAlpha)                   },
//
//
//    //**************************************************************************
//    // DirectDraw Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , NV4_REG_VPE_ENABLE ,                         offsetof(NT_NV_REGISTRY, DirectDraw.VPENABLE)                   },
//    { IS_DWORD , NV4_REG_OVL_MODE ,                           offsetof(NT_NV_REGISTRY, DirectDraw.OverlayMode)                },
//    { IS_DWORD , NV4_REG_OVLCC_ENABLE ,                       offsetof(NT_NV_REGISTRY, DirectDraw.OverlayColorControlEnable)  },
//    { IS_DWORD , NV4_REG_OVLCC_BRIGHTNESS ,                   offsetof(NT_NV_REGISTRY, DirectDraw.OverlayBrightness)          },
//    { IS_DWORD , NV4_REG_OVLCC_CONTRAST ,                     offsetof(NT_NV_REGISTRY, DirectDraw.OverlayContrast)            },
//    { IS_DWORD , NV4_REG_OVLCC_HUE ,                          offsetof(NT_NV_REGISTRY, DirectDraw.OverlayHue)                 },
//    { IS_DWORD , NV4_REG_OVLCC_SATURATION ,                   offsetof(NT_NV_REGISTRY, DirectDraw.OverlaySaturation)          },
//    { IS_DWORD , NV4_REG_OVLCC_GAMMA ,                        offsetof(NT_NV_REGISTRY, DirectDraw.OverlayGamma)               },
//    { IS_DWORD , NV4_REG_OVLCC_SHARPNESS ,                    offsetof(NT_NV_REGISTRY, DirectDraw.OverlaySharpness)           },
//
//    //**************************************************************************
//    // Direct3d Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , D3D_REG_ANTIALIASENABLE_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.ANTIALIASENABLE)              },
//    { IS_DWORD , D3D_REG_CKCOMPATABILITYENABLE_STRING ,       offsetof(NT_NV_REGISTRY, Direct3D.COLORKEYCOMPATABILITYENABLE)  },
//    { IS_DWORD , "CONTROLTRAFFIC"                    ,        offsetof(NT_NV_REGISTRY, Direct3D.CONTROLTRAFFIC)               },
//    { IS_DWORD , D3D_REG_DIRECTMAPENABLE_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.DIRECTMAPENABLE)              },
//    { IS_DWORD , D3D_REG_FOGTABLEENABLE_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.FOGTABLENABLE)                },
//    { IS_DWORD , D3D_REG_LOGOENABLE_STRING ,                  offsetof(NT_NV_REGISTRY, Direct3D.LOGOENABLE)                   },
//    { IS_DWORD , D3D_REG_SSYNCENABLE_STRING ,                 offsetof(NT_NV_REGISTRY, Direct3D.SCENESYNCENABLE)              },
//    { IS_DWORD , D3D_REG_TILINGENABLE_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.TILINGENABLE)                 },
//    { IS_DWORD , D3D_REG_USERMIPMAPENABLE_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.USERMIPMAPENABLE)             },
//    { IS_DWORD , D3D_REG_VIDEOTEXTUREENABLE_STRING ,          offsetof(NT_NV_REGISTRY, Direct3D.VIDEOTEXTUREENABLEENABLE)     },
//    { IS_DWORD , D3D_REG_VSYNCENABLE_STRING ,                 offsetof(NT_NV_REGISTRY, Direct3D.VSYNCENABLE)                  },
//    { IS_DWORD , D3D_REG_WBUFFERENABLE_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.WENABLE)                      },
//    { IS_DWORD , D3D_REG_Z24ENABLE_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.Z24ENABLE)                    },
//    { IS_DWORD , D3D_REG_AAMETHOD_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.AAMETHOD)                     },
//    { IS_DWORD , D3D_REG_AUTOMIPMAPMETHOD_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.AUTOMIPMAPMETHOD)             },
//    { IS_DWORD , D3D_REG_CKREF_STRING ,                       offsetof(NT_NV_REGISTRY, Direct3D.CKREF)                        },
//    { IS_DWORD , "DX6ENABLE" ,                                offsetof(NT_NV_REGISTRY, Direct3D.DX6ENABLE)                    },
//    { IS_DWORD , D3D_REG_MIPMAPDITHERMODE_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.ANISOTOPIC4TAP)               },
//    { IS_DWORD , D3D_REG_PAL8TEXCONVERT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.PAL8TEXTURECONVERT)           },
//    { IS_DWORD , "PMTRIGGER" ,                                offsetof(NT_NV_REGISTRY, Direct3D.PMTRIGGER)                    },
//    { IS_DWORD , D3D_REG_TEXELALIGNMENT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.TEXELALIGNMENT)               },
//    { IS_DWORD , D3D_REG_VALIDATEZMETHOD_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.VALIDATEZMETHOD)              },
//    { IS_DWORD , D3D_REG_WFORMAT16_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.W16FORMAT)                    },
//    { IS_DWORD , D3D_REG_WFORMAT32_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.W32FORMAT)                    },
//    { IS_DWORD , D3D_REG_AGPTEXCUTOFF_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.AGPTEXCUTOFF)                 },
//    { IS_DWORD , D3D_REG_D3DCONTEXTMAX_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.D3DCONTEXTMAX)                },
//    { IS_DWORD , D3D_REG_D3DTEXTUREMAX_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.D3DTEXTUREMAX)                },
//    { IS_DWORD , D3D_REG_DMAMINPUSHCOUNT_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.DMAMINPUSHCOUNT)              },
//    { IS_DWORD , D3D_REG_LODBIAS_STRING ,                     offsetof(NT_NV_REGISTRY, Direct3D.LODBIASADJUST)                },
//    { IS_DWORD , D3D_REG_MINVIDTEXSIZE_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.MINVIDEOTEXSIZE)              },
//    { IS_DWORD , D3D_REG_AUTOMIPMAPLEVELS_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.MIPMAPLEVELS)                 },
//    { IS_DWORD , D3D_REG_PERFSTRATEGY_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.PERFSTRATEGY)                 },
//    { IS_DWORD , D3D_REG_PRERENDERLIMIT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.NOVSYNCPREREDNERLIMIT)        },
//    { IS_DWORD , D3D_REG_PUSHBUFFERSIZEMAX_STRING ,           offsetof(NT_NV_REGISTRY, Direct3D.DMAPUSHBUFFERSIZEMAX)         },
//    { IS_DWORD , D3D_REG_TEXHEAPSIZEMAX_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.TEXHEAP)                      },
//    { IS_DWORD , D3D_REG_WSCALE16_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.WSCALE16)                     },
//    { IS_DWORD , D3D_REG_WSCALE24_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.WSCALE24)                     },
//
//    //**************************************************************************
//    // System Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , "Reserved1" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved2" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved3" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved4" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved5" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved6" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved7" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved8" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved9" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved10" ,                               offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved11" ,                               offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },

    };
    

//******************************************************************************
// Global tables for registry mode table data
//******************************************************************************

U016 NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5M64_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5ULTRA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11M_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15BR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_1_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_2_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_3_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];


//******************************************************************************
// Global tables for Monitor restriction mode list data
//******************************************************************************
U016 MonitorRestrictionModeList0_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];  // For head0
U016 MonitorRestrictionModeList1_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];  // For head1

// global device extension pointer - We need it to distinguish between NV3/NV4..
extern PHW_DEVICE_EXTENSION HwDeviceExtension;

extern VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );


extern VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

__inline static size_t cbStrLenW(
    IN UNALIGNED const WCHAR *wsz)
{
    size_t cbWsz = 0;

    for(; *wsz; wsz++)
        cbWsz += sizeof( WCHAR);

    return( cbWsz + sizeof( WCHAR));
}

#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
// Tables used by DPMS_SetPowerState (NT5 only)
//******************************************************************************

UCHAR tblDPMSStates[4]      = { 0, 2, 1, 4 }                    ;   //on, stdby, suspend, off
UCHAR tblDPMSSettings[4]    = { 0x000, 0x080, 0x040, 0x0C0 }    ;

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV_ATCOff(PHW_DEVICE_EXTENSION);
VOID NV_ATCOn(PHW_DEVICE_EXTENSION);
VOID NV_ResetATCFlipFlop(PHW_DEVICE_EXTENSION);

#endif


//******************************************************************************
// Use a slightly different mode timing table for NV4
//******************************************************************************


//
// CRTC Timings modes for 60Hz, 70Hz, 72Hz, 75Hz, 85Hz, 100Hz, 120Hz
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use floating point).
//
// Horizontal Total, Start, End
// Vertical Total, Start, End
// DotClock, Refresh
// HSync polarity
// VSync polarity
//
// Max out all the modes above our pixclk (~250).
//
U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10] =
{
    //0:
    // Settings for 1600x1200:
    2160,1704,1880,1242,1201,1204,16096,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1249,1201,1204,19025,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1251,1201,1204,19600,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1253,1201,1204,20599,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //1:
    // Settings for 1280x1024:
    1712,1360,1496,1060,1025,1028,10888,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1066,1025,1028,12894,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1067,1025,1028,13275,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1069,1025,1028,13854,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1744,1376,1512,1075,1025,1028,15936,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1760,1376,1520,1085,1025,1028,19096,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //2:
    // Settings for 1152x864:
    1520,1216,1336,895,865,868,8162 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,900,865,868,9677 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,901,865,868,9964 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,902,865,868,10499,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,907,865,868,11965,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1568,1232,1360,915,865,868,14347,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1584,1240,1368,926,865,868,17601,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //3:
    // Settings for 1024x768:
    1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,800,769,772,7616 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,801,769,772,7843 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,802,769,772,8180 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1376,1088,1200,807,769,772,9439 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //1392,1096,1208,814,769,772,11331,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1392,1096,1208,814,769,772,11370,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,823,769,772,13905,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //4:
    // Settings for 960x720:
    1248,1008,1104,746,721,724,5586 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,750,721,724,6636 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,751,721,724,6835 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,752,721,724,7219 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,756,721,724,8225 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1296,1024,1128,763,721,724,9888 ,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1312,1032,1136,772,721,724,12154,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //5:
    // Settings for 800x600:
    1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,625,601,604,4550,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,626,601,604,4687,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,627,601,604,4891,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1056,840,928,630,601,604,5655,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1072,848,936,636,601,604,6818,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,643,601,604,8395,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //6:
    // Settings for 640x480:
    800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,500,481,484,2856,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,501,481,484,2943,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,502,481,484,3072,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,505,481,484,3571,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,509,481,484,4316,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,515,481,484,5241,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //7:
    // Settings for 640x400:
    //There is no 60Hz timings for 640x400 as defined by IBM VGA
    //784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2508,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,421,401,404,2920,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,424,401,404,3528,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //8:
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    672,536,592,795,769,772,3205,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    672,536,592,800,769,772,3763,7000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,801,769,772,3968,7200,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,802,769,772,4138,7500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,807,769,772,4719,8500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,814,769,772,5600,10000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,

    //9:
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    624,504,552,746,721,724,2793,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,750,721,724,3360,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,751,721,724,3461,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,752,721,724,3610,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,756,721,724,4113,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,763,721,724,5005,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //10:
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    512,416,456,622,601,604,1911,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,625,601,604,2310,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,626,601,604,2380,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,627,601,604,2483,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,630,601,604,2827,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,636,601,604,3358,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //11:
    // Settings for 320x400:
    //
    // !!! This mode should never be set !!! since DDraw doesn't support it yet
    //
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //12:
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    400,328,360,497,481,484,1193,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,500,481,484,1400,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,501,481,484,1501,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,502,481,484,1566,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,505,481,484,1786,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,509,481,484,2117,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //13:
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //14:
    // Settings for 1920x1200:
    2592,2048,2256,1242,1201,1204,19316,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1249,1201,1204,22802,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1251,1201,1204,23635,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1253,1201,1204,24659,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //15:
    // Settings for 1920x1080:
    2576,2040,2248,1118,1081,1084,17280,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1124,1081,1084,20520,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1126,1081,1084,21144,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1128,1081,1084,22064,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //16:
    // Settings for 1800x1440:
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

//17:
    // Settings for 1600x1024:
    2144,1704,1872,1060,1025,1028,13636,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2160,1704,1880,1066,1025,1028,16118,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2160,1704,1880,1067,1025,1028,16594,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

// An OEM Customer wants a SPECIFIC timing...which is NOT GTF or DMT compliant ...so we'll accomodate them...
// (They're using a widescreen Sony monitor)

// Standard GTF
//    2176,1712,1888,1070,1025,1028,17695,7600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

// OEM requested
    2096,1632,1792,1070,1027,1030,17045,7600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,


    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,


};

//******************************************************************************
// Forward Function Declarations
//******************************************************************************
VP_STATUS
NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

BOOLEAN
NVGetNVInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


VOID NV4_UpdateArbitrationSettings(PHW_DEVICE_EXTENSION);

BOOL NV4SetMode(PHW_DEVICE_EXTENSION,PMODE_ENTRY);
VOID NV_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NV4_InitPalette(PHW_DEVICE_EXTENSION);
ULONG NVMapMemoryRanges(PVOID HwDeviceExtension);
ULONG NVMapFrameBuffer(PVOID HwDeviceExtension);
//BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PULONG);
VOID NV4EnableCursor(PHW_DEVICE_EXTENSION);
ULONG NVMapVgaPaletteRegisters(PHW_DEVICE_EXTENSION);
VOID NV4_ProgramTV( U008 );

//******************************************************************************
//
//  Function: NVSetMode()
//
//  Routine Description:
//
//      This routine sets the adapter into the requested mode.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      Mode - Pointer to the structure containing the information about the
//          font to be set.
//
//      ModeSize - Length of the input buffer supplied by the user.
//
//  Return Value:
//
//      ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
//          for the input data.
//
//      ERROR_INVALID_PARAMETER if the mode number is invalid.
//
//      NO_ERROR if the operation completed successfully.
//
//******************************************************************************

VP_STATUS NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )


    {

    PMODE_ENTRY pRequestedMode;             // NV specific
    VP_STATUS status;
    USHORT usDataSet, usTemp, usDataClr;
    PUSHORT  pBios = NULL;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    ULONG OutData;
    LONG x_inc,y_inc;
    ULONG x,y;
    ULONG i;
    ULONG Data;
    PMODE_ENTRY ModeEntry;

    PHWINFO NVInfo;

    VideoDebugPrint((1, "NVSetMode - entry\n"));

    //**************************************************************************
    // Check if the size of the data in the input buffer is large enough.
    //**************************************************************************

    if (ModeSize < sizeof(VIDEO_MODE))
    {

        VideoDebugPrint((1, "SetMode - ERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //**************************************************************************
    // Init pointer to Mode data (NV3 or NV4)
    //**************************************************************************

    ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);


    //**************************************************************************
    // Check to see if we are requesting a valid mode
    //**************************************************************************

    if ( (Mode->RequestedMode >= HwDeviceExtension->NumRegistryModes)   ||
         (!ModeEntry[Mode->RequestedMode].ValidMode)  )
        {

        VideoDebugPrint((1, "SetMode - ERROR_INVALID_PARAMETER\n"));
        return ERROR_INVALID_PARAMETER;

        }


    //**************************************************************************
    // Our driver maps video memory first, and then sets the mode.
    // However, the Dumb Frame Buffer drivers sets the mode FIRST, and
    // then maps the video memory.  So first check to see if we've
    // got a valid frame buffer ptr, before we clear memory.
    //**************************************************************************

    if (HwDeviceExtension->FrameBufferPtr !=NULL)
        {
        //**********************************************************************
        // Clear the framebuffer prior to setting the video mode.
        // This is for aesthetics only.
        // Back up 1Mb to make absolutely sure we don't walk over any instance memory
        //**********************************************************************
        for (i = 0; i < ( (HwDeviceExtension->AdapterMemorySize-0x100000) >> 2); i++)
            {
            ((PULONG) HwDeviceExtension->FrameBufferPtr)[i] = 0;
            }
        }

    //**************************************************************************
    // Get pointer to the requested mode
    //**************************************************************************
    if(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_VIRTUAL_DESKTOP)
    {
        PMODE_ENTRY pDesktopMode; 
        ULONG ulDac;
        ULONG ulWidth;
        ULONG ulHeight;
        ULONG ulRefresh;
        ULONG ulPixelDepth;

        pDesktopMode = &(ModeEntry[Mode->RequestedMode]);

        // Display driver is setting mode through class for both DAC.
        // Miniport driver set to the primary dac by default;
        ulDac = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[0];
        ulWidth = HwDeviceExtension->DeskTopInfo.ulDisplayWidth[ulDac];
        ulHeight = HwDeviceExtension->DeskTopInfo.ulDisplayHeight[ulDac];
        ulRefresh = HwDeviceExtension->DeskTopInfo.ulDisplayRefresh[ulDac];
        ulPixelDepth = HwDeviceExtension->DeskTopInfo.ulDisplayPixelDepth[ulDac];

        for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)   
        {
            if(!ModeEntry[i].ValidMode)
                continue;

            if( (ModeEntry[i].Depth == ulPixelDepth) &&
                (ModeEntry[i].RefreshRate == ulRefresh) &&
                (ModeEntry[i].Width == ulWidth) &&
                (ModeEntry[i].Height == ulHeight) )
            {
                Mode->RequestedMode = i;
                break;
            }
        }
        if(i == HwDeviceExtension->NumRegistryModes)
            return (ERROR_INVALID_PARAMETER);
    }

    pRequestedMode = &(ModeEntry[Mode->RequestedMode]);

    //**************************************************************************
    // Initialize the Graphics Mode and Engine.
    //**************************************************************************

    if (NV4SetMode(HwDeviceExtension, pRequestedMode) == FALSE)
        return(ERROR_NOT_ENOUGH_MEMORY);

    //**************************************************************************
    // Store the new mode value.
    //**************************************************************************

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    VideoDebugPrint((1, "NVSetMode - exit\n"));
    return NO_ERROR;

    } //end NVSetMode()


//******************************************************************************
//
//  Function:   NVGetNVInfo()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN NVGetNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    PHWINFO NVInfo;
    ULONG refresh;
    ULONG i,j;
    ULONG Size;
    BOOLEAN status=TRUE;
    PWSTR   pwszChip, pwszAdapterString;
    ULONG   cbChip, cbAdapterString;
    ULONG   FullChipId,ChipId;
    U016   rc;

    //**************************************************************************
    // Get ptr to NVInfo structure and clear it out.
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    VideoPortZeroMemory(NVInfo, sizeof(HWINFO));


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // WIN2K:   We need to determine what chip we're running on for Win2K!
    //          This was NOT obtained in NVIsPresent, so we need to
    //          determine it HERE, because we now have access to the
    //          the hardware registers !!
    //**************************************************************************

    ChipId = REG_RD32(NV_PBUS_PCI_NV_0);
    ChipId >>= 16;                              // Get top 16 bits (bits 16 thru 31)
    ChipId &= 0xffff;                           // Just look at 16 bits

    FullChipId = ChipId;                        // Save complete id
    ChipId &= 0xfffc;                           // Ignore Sub Revisions 1 thru 3

    switch (ChipId)
        {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:

            //******************************************************************
            // NV4 (original TNT)
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV4_DEVICE_NV4_ID;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:

            //******************************************************************
            // NV5 (TNT2)   ID = 28
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV5_DEVICE_NV5_ID;

            //******************************************************************
            // NV5 (TNT2 ULTRA)  ID = 29
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1)
                HwDeviceExtension->ulChipID     = NV5ULTRA_DEVICE_NV5ULTRA_ID;


            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0:

            //******************************************************************
            // VANTA (ID = 2C)
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV5VANTA_DEVICE_NV5VANTA_ID;

            //******************************************************************
            // (TNT2 Model 64) (ID = 2D)
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1)
                HwDeviceExtension->ulChipID     = NV5MODEL64_DEVICE_NV5MODEL64_ID;

            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:

            //******************************************************************
            // NV0A
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV0A_DEVICE_NV0A_ID;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:

            //******************************************************************
            // NV10
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV10_DEVICE_NV10_ID;

            //******************************************************************
            // NV10DDR (NV10 DDR)  ID = 101
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1)
                HwDeviceExtension->ulChipID     = NV10DDR_DEVICE_NV10DDR_ID;

            //******************************************************************
            // NV10GL (NV10 GL)  ID = 103
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3)
                HwDeviceExtension->ulChipID     = NV10GL_DEVICE_NV10GL_ID;


            break;


        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID0:

            //******************************************************************
            // NV11 ID = 110
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV11_DEVICE_NV11_ID;

            //******************************************************************
            // NV11DDR (NV11 DDR)  ID = 111
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID1)
                HwDeviceExtension->ulChipID     = NV11DDR_DEVICE_NV11DDR_ID;

            //******************************************************************
            // NV11M (NV11 Mobile)  ID = 112
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID2)
                HwDeviceExtension->ulChipID     = NV11M_DEVICE_NV11M_ID;

            //******************************************************************
            // NV11GL (NV11 GL)  ID = 113
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID3)
                HwDeviceExtension->ulChipID     = NV11GL_DEVICE_NV11GL_ID;

            break;


        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:

            //******************************************************************
            // NV15 ID = 150
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV15_DEVICE_NV15_ID;

            //******************************************************************
            // NV15DDR (NV15 DDR)  ID = 151
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1)
                HwDeviceExtension->ulChipID     = NV15DDR_DEVICE_NV15DDR_ID;

            //******************************************************************
            // NV15BR (NV15 BR)  ID = 152
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2)
                HwDeviceExtension->ulChipID     = NV15BR_DEVICE_NV15BR_ID;


            //******************************************************************
            // NV15GL (NV15 GL)  ID = 153
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3)
                HwDeviceExtension->ulChipID     = NV15GL_DEVICE_NV15GL_ID;


            break;

        
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID0:

            //******************************************************************
            // NV20 ID = 200
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_ID;

            //******************************************************************
            // NV20 ID = 201
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID1)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_1_ID;

            //******************************************************************
            // NV20 ID = 202
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID2)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_2_ID;

            //******************************************************************
            // NV20 ID = 203
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID3)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_3_ID;

            break;


        default:

            //******************************************************************
            // Unsupported Chip
            //******************************************************************
            status=FALSE;
            return(status);
        }
#endif


    //**************************************************************************
    // Now that we're using a Resource Manager, the majority of the
    // NVInfo structure fields are no longer used (These values were used
    // in the older 1.00 driver).  Since they're no longer used, just
    // zero them out.
    //**************************************************************************

    NVInfo->Pram.CurrentSize        = 0;
    NVInfo->Pram.HashTableAddr      = 0;
    NVInfo->Pram.HashDepth          = 0;
    NVInfo->Pram.FifoRunoutAddr     = 0;
    NVInfo->Pram.RunOutMask         = 0;
    NVInfo->Pram.FifoContextAddr    = 0;
    NVInfo->Pram.FreeInstSize       = 0;
    NVInfo->Pram.FreeInstBase       = 0;
    NVInfo->Dac.CursorImageInstance = 0;


    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID))
    {
        switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_CFG,_BUS))
        {
            case NV_PFB_CFG_BUS_64:
                NVInfo->Dac.InputWidth = 64;
                break;
            case NV_PFB_CFG_BUS_128:
                NVInfo->Dac.InputWidth = 128;
                break;
            case NV_PFB_CFG_BUS_32:
                NVInfo->Dac.InputWidth = 32;
                break;
        }
    }
    else if ((HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
    {
        NVInfo->Dac.InputWidth = 128;
    }
    else
    {
        switch (PFB_REG_RD_DRF(PFB_Base, _PFB, _BOOT_0, _RAM_WIDTH_128))
        {
            case NV_PFB_BOOT_0_RAM_WIDTH_128_OFF:
                NVInfo->Dac.InputWidth = 64;
                break;
            case NV_PFB_BOOT_0_RAM_WIDTH_128_ON:
                NVInfo->Dac.InputWidth = 128;
                break;
        }
    }

    //**************************************************************************
    // Get Chip revision and implementation
    //**************************************************************************

//    NVInfo->Chip.Implementation = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_IMPLEMENTATION);
//    NVInfo->Chip.Revision = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_FIB_REVISION);
//    NVInfo->Chip.Architecture = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_ARCHITECTURE);
//    NVInfo->Chip.Manufacturer = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_MANUFACTURER);

    //**************************************************************************
    // Get memory type
    //**************************************************************************

//    NVInfo->Framebuffer.RamType = PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV,_BOOT_0,_STRAP_RAM_TYPE) ==
//                            NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO ? BUFFER_DRAM : BUFFER_VRAM;

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)         ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)         ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)       ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)         ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)     ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)         ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))

    {
        NVInfo->Framebuffer.RamSize = PFB_REG_RD32(PFB_Base,NV_PFB_CSTATUS);
        NVInfo->Framebuffer.RamSizeMb = NVInfo->Framebuffer.RamSize >> 20;
    }
    else
    {
        //**************************************************************************
        // Get amount of VRAM
        // NOTE: These values are DIFFERENT from those defined in NV3 !!
        //**************************************************************************

        switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0, _RAM_AMOUNT))
            {
            case NV_PFB_BOOT_0_RAM_AMOUNT_32MB:
                NVInfo->Framebuffer.RamSizeMb = 32;
                NVInfo->Framebuffer.RamSize   = 0x02000000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
                NVInfo->Framebuffer.RamSizeMb = 4;
                NVInfo->Framebuffer.RamSize   = 0x00400000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
                NVInfo->Framebuffer.RamSizeMb = 8;
                NVInfo->Framebuffer.RamSize   = 0x00800000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
                NVInfo->Framebuffer.RamSizeMb = 16;
                NVInfo->Framebuffer.RamSize   = 0x01000000;
                break;
            default:
                //******************************************************************
                // Invalid memory configuration
                //******************************************************************
                status=FALSE;
                return(status);
            }


        //**************************************************************************
        // Check for UMA usage
        //
        // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
        // bit fields to zero.
        //**************************************************************************

        if (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
            switch (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA_SIZE))
            {
                case NV_PFB_BOOT_0_UMA_SIZE_2M:
                    NVInfo->Framebuffer.RamSizeMb = 2;
                    NVInfo->Framebuffer.RamSize   = 0x00200000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_4M:
                    NVInfo->Framebuffer.RamSizeMb = 4;
                    NVInfo->Framebuffer.RamSize   = 0x00400000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_6M:
                    NVInfo->Framebuffer.RamSizeMb = 6;
                    NVInfo->Framebuffer.RamSize   = 0x00600000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_8M:
                    NVInfo->Framebuffer.RamSizeMb = 8;
                    NVInfo->Framebuffer.RamSize   = 0x00800000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_10M:
                    NVInfo->Framebuffer.RamSizeMb = 10;
                    NVInfo->Framebuffer.RamSize   = 0x00A00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_12M:
                    NVInfo->Framebuffer.RamSizeMb = 12;
                    NVInfo->Framebuffer.RamSize   = 0x00C00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_14M:
                    NVInfo->Framebuffer.RamSizeMb = 14;
                    NVInfo->Framebuffer.RamSize   = 0x00E00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_16M:
                    NVInfo->Framebuffer.RamSizeMb = 16;
                    NVInfo->Framebuffer.RamSize   = 0x01000000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_18M:
                    NVInfo->Framebuffer.RamSizeMb = 18;
                    NVInfo->Framebuffer.RamSize   = 0x01200000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_20M:
                    NVInfo->Framebuffer.RamSizeMb = 20;
                    NVInfo->Framebuffer.RamSize   = 0x01400000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_22M:
                    NVInfo->Framebuffer.RamSizeMb = 22;
                    NVInfo->Framebuffer.RamSize   = 0x01600000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_24M:
                    NVInfo->Framebuffer.RamSizeMb = 24;
                    NVInfo->Framebuffer.RamSize   = 0x01800000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_26M:
                    NVInfo->Framebuffer.RamSizeMb = 26;
                    NVInfo->Framebuffer.RamSize   = 0x01A00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_28M:
                    NVInfo->Framebuffer.RamSizeMb = 28;
                    NVInfo->Framebuffer.RamSize   = 0x01C00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_30M:
                    NVInfo->Framebuffer.RamSizeMb = 30;
                    NVInfo->Framebuffer.RamSize   = 0x01E00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_32M:
                    NVInfo->Framebuffer.RamSizeMb = 32;
                    NVInfo->Framebuffer.RamSize   = 0x02000000;
                    break;
                default:
                    //******************************************************************
                    // Invalid memory configuration
                    //******************************************************************
                    status=FALSE;
                    return(status);
            }
    }

    pwszChip = L"NVxx";
    cbChip = sizeof(L"NVxx");
    pwszAdapterString = L"NVxx";
    cbAdapterString = sizeof(L"NVxx");

    for(i = 0; i < sizeof(sChipInfo) / sizeof(CHIP_INFO); i++)
    {
        if (HwDeviceExtension->ulChipID == sChipInfo[i].ulDevID)
        {
            pwszChip = sChipInfo[i].pwszChip;
            cbChip = cbStrLenW(pwszChip);
            pwszAdapterString = sChipInfo[i].pwszAdapterString; 
            cbAdapterString = cbStrLenW(pwszAdapterString);
            break;
        }
    }

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                               L"HardwareInformation.DacType",
                               L"Integrated RAMDAC",
                               sizeof(L"Integrated RAMDAC") );


    //**************************************************************************
    // Default to 640x480x16x1 framebuffer with VGA timing
    //**************************************************************************

    NVInfo->Framebuffer.DpmLevel          = 0;
    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.Depth             = 16;
    NVInfo->Framebuffer.RefreshRate       = 60;
    NVInfo->Framebuffer.Count             = 1;
    NVInfo->Framebuffer.ActiveCount       = 1;
    NVInfo->Framebuffer.ActiveMask        = 1;
    NVInfo->Framebuffer.Current           = 0;
    NVInfo->Framebuffer.FlipUsageCount    = 0;
    NVInfo->Framebuffer.FlipTo            = 0;
    NVInfo->Framebuffer.FlipFrom          = 0;
    NVInfo->Framebuffer.UpdateFlags       = 0;
    NVInfo->Framebuffer.HorizFrontPorch   = 0;
    NVInfo->Framebuffer.HorizSyncWidth    = 0;
    NVInfo->Framebuffer.HorizBackPorch    = 0;
    NVInfo->Framebuffer.HorizDisplayWidth = 0;
    NVInfo->Framebuffer.VertFrontPorch    = 0;
    NVInfo->Framebuffer.VertSyncWidth     = 0;
    NVInfo->Framebuffer.VertBackPorch     = 0;
    NVInfo->Framebuffer.VertDisplayWidth  = 0;
    NVInfo->Framebuffer.HSyncPolarity     = 0;
    NVInfo->Framebuffer.VSyncPolarity     = 0;
    NVInfo->Framebuffer.CSync             = 0;
    NVInfo->Framebuffer.ConfigPageHeight  = 0;
    NVInfo->Pram.CurrentSize              = 0;
    NVInfo->Pram.AvailableSize[0]         =  NV_PRAM_DEVICE_SIZE_5_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[1]         =  NV_PRAM_DEVICE_SIZE_9_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[2]         =  NV_PRAM_DEVICE_SIZE_17_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[3]         =  NV_PRAM_DEVICE_SIZE_33_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;

    //**************************************************************************
    // Default Refresh Rate
    //**************************************************************************

    NVInfo->Framebuffer.RefreshRate = 60;
    NVInfo->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    NVInfo->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;

    //**************************************************************************
    // Default resolution
    //**************************************************************************

    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.HorizDisplayWidth = 640;
    NVInfo->Framebuffer.VertDisplayWidth  = 480;
    NVInfo->Framebuffer.Depth             = 16;

    //**************************************************************************
    // Determine refresh rate
    //**************************************************************************

    if (NVInfo->Framebuffer.RefreshRate < 70)
       refresh = 0;
    if (NVInfo->Framebuffer.RefreshRate < 72)
        refresh = 1;
    else if (NVInfo->Framebuffer.RefreshRate < 75)
        refresh = 2;
    else if (NVInfo->Framebuffer.RefreshRate < 85)
        refresh = 3;
    else if (NVInfo->Framebuffer.RefreshRate < 100)
        refresh = 4;
    else if (NVInfo->Framebuffer.RefreshRate < 120)
        refresh = 5;
    else
        refresh = 6;

    //**************************************************************************
    // Update the DAC flags and types
    //**************************************************************************

    NVInfo->Dac.UpdateFlags = 0;
    NVInfo->Dac.FinishFlags = 0;

    //**************************************************************************
    // Initialize the cursor data (transparent)
    //**************************************************************************

//    NVInfo->Dac.CursorType = DAC_CURSOR_TWO_COLOR_XOR;
    NVInfo->Dac.CursorEmulation = FALSE;
    NVInfo->Dac.CursorExclude= FALSE;
    NVInfo->Dac.CursorColor1 = 0x00000000;
    NVInfo->Dac.CursorColor2 = 0x00ffffff;
    NVInfo->Dac.CursorColor3 = 0x00000000;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[0][i] = 0x00;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[1][i] = 0xff;

    for (i=0;i<32;i++)
        for (j=0;j<32;j++)
            NVInfo->Dac.CursorColorImage[i][j]= 0x00000000;

    //**************************************************************************
    // Initialize palette to gray scale
    //**************************************************************************

    for (i=0;i<256;i++)
        NVInfo->Dac.Palette[i] = (i<<16) | (i<<8) | i;

    //**************************************************************************
    // Initialize Power Management state
    //**************************************************************************

    NVInfo->Dac.DpmLevel = 0;

    //**************************************************************************
    // Initialize Video Clock
    //**************************************************************************

    NVInfo->Dac.VClk= 0;

    //**************************************************************************
    // return success
    //**************************************************************************

    return(status);
    }



//******************************************************************************
//
//  Function:   NV4SetMode
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************

BOOL NV4SetMode(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        PMODE_ENTRY RequestedMode  )
    {
    PHWINFO NVInfo;
    PUCHAR crtc;
    ULONG OffScreenMemory;
    ULONG OnScreenMemory;
    UCHAR  mode, bitdepth, doubled;
    USHORT vesaMode;
    VIDEO_REQUEST_PACKET requestPacket;
    STATUS_BLOCK statusblock;
    PDMT_OVERRIDES pDMTOverrides;
    U016   UseDMTFlag;
    ULONG CurrentValue;
    BOOLEAN bRefreshRateDefault;
    MODE_TIMING_VALUES timingInfo;
    GTF_TIMINGS vbe_timings;
    unsigned int vesaStatus;
    ULONG result;
    
    //**************************************************************************
    //    Current Issues with New Style Modeset Code:
    //
    //    1) NT 3.51 will no longer work with new style modeset code, because
    //       RmSetMode calls RmUnloadState and RmLoadState.
    //       (NT 3.51 does not work with a Resource Manager to my knowledge).
    //
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    NVInfo->Framebuffer.HorizDisplayWidth   = RequestedMode->Width;
    NVInfo->Framebuffer.VertDisplayWidth    = RequestedMode->Height;
    NVInfo->Framebuffer.Depth               = RequestedMode->Depth;
    NVInfo->Framebuffer.RefreshRate         = RequestedMode->RefreshRate;

    if ( !(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
    {

        // Added to support GTF or DMT method selection under WinNT4 and Win2K
        if (HwDeviceExtension->bUseGTF)
        {

            //**********************************************************************
            // Here we use GTF timings as requested by the user
            //**********************************************************************

            vesaStatus = vesaGetGTFTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                           NVInfo->Framebuffer.VertDisplayWidth,    
                                           NVInfo->Framebuffer.RefreshRate,
                                           &timingInfo);

            if (vesaStatus)
            {
                // Could not find a GTF timing for this mode
                return(FALSE);
            }

        }
        else
        {

            //**************************************************************************
            // Here we use DMT timings  (instead of GTF timings)
            //**************************************************************************

            vesaStatus = vesaGetDMTTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                           NVInfo->Framebuffer.VertDisplayWidth,    
                                           NVInfo->Framebuffer.RefreshRate,
                                           &timingInfo);

            //**************************************************************************
            // If DMT timings don't exist for this mode, use the GTF timings
            //**************************************************************************

            if (vesaStatus)
            {

                //**********************************************************************
                // Set mode using GTF timings if DMT timings don't exist
                //**********************************************************************

                vesaStatus = vesaGetGTFTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                               NVInfo->Framebuffer.VertDisplayWidth,    
                                               NVInfo->Framebuffer.RefreshRate,
                                               &timingInfo);

                if (vesaStatus)
                {
                    // Could not find a DMT / GTF timing for this mode
                    return(FALSE);
                }
            }
        }
    }




    //**************************************************************************
    // Still need to make sure the 'global' hwdevice variable is in sync.
    // (We need to eventually get rid of this global hwdev variable !!!)
    //**************************************************************************

    SetGlobalHwDev(HwDeviceExtension);

    //**************************************************************************
    // Unlock the registers
    //**************************************************************************

    NV_OEMEnableExtensions(HwDeviceExtension);          

    //**************************************************************************
    // Determine which modes are 'doubled'
    //**************************************************************************

    doubled = 0;  

    if ((NVInfo->Framebuffer.VertDisplayWidth == 384 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 360 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 300 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 240 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 200 ))   
        {
        doubled = 1;
        }
        
    if( !(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
    {
        //**************************************************************************
        // Pass the timings to the RM and let it set the mode (via DacProgramCRTC)
        // as well as fixup the modeset arbitration.
        //**************************************************************************


        if (RmSetMode(HwDeviceExtension->DeviceReference,
                  timingInfo.HorizontalVisible,
                  timingInfo.HorizontalBlankStart,
                  timingInfo.HorizontalRetraceStart,
                  timingInfo.HorizontalRetraceEnd,
                  timingInfo.HorizontalBlankEnd,
                  timingInfo.HorizontalTotal,
                  timingInfo.VerticalVisible,
                  timingInfo.VerticalBlankStart,
                  timingInfo.VerticalRetraceStart,
                  timingInfo.VerticalRetraceEnd,
                  timingInfo.VerticalBlankEnd,
                  timingInfo.VerticalTotal,
                  NVInfo->Framebuffer.Depth,
                  NVInfo->Framebuffer.RefreshRate,
                  NVInfo->Framebuffer.HorizDisplayWidth ,
                  NVInfo->Framebuffer.VertDisplayWidth,  
                  timingInfo.PixelClock,
                  timingInfo.HSyncpolarity,
                  timingInfo.VSyncpolarity,
                  doubled) != TRUE)
        {
        return(FALSE);
        }
    }
    //**************************************************************************
    // Save these values off so when we come back from hibernation,
    // we'll know what values to restore
    //**************************************************************************

    HwDeviceExtension->LastWidth        = NVInfo->Framebuffer.HorizDisplayWidth; 
    HwDeviceExtension->LastHeight       = NVInfo->Framebuffer.VertDisplayWidth;
    HwDeviceExtension->LastDepth        = NVInfo->Framebuffer.Depth;
    HwDeviceExtension->LastRefreshRate  = NVInfo->Framebuffer.RefreshRate;


    //**************************************************************************
    // Ask the RM if overlay is allowed at this resolution
    //**************************************************************************

    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_OVERLAY_ALLOWED,&result) ;

    if (result)
        HwDeviceExtension->bHwVidOvl = TRUE;
    else        
        HwDeviceExtension->bHwVidOvl = FALSE;

    //**************************************************************************
    // TV cursor adjust code
    //**************************************************************************

    if (HwDeviceExtension->TvIsPresent)
        {
        U008  ht,hrs,hbs,tvhbe,tvhbs;

        //**********************************************************************
        // Unlock the registers
        //**********************************************************************

        NV_OEMEnableExtensions(HwDeviceExtension);          

        //**********************************************************************
        // Calculate cursor min and max values (in pixels) for TV.
        //**********************************************************************

        CRTC_RD(NV_CIO_CR_HDT_INDEX, ht);   // h total
        CRTC_RD(NV_CIO_CR_HRS_INDEX, hrs);  // h retrace start
        CRTC_RD(NV_CIO_CR_HBS_INDEX, hbs);  // h blank start
        tvhbe = (U008) PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_TV_HBLANK_END);
        tvhbs = (U008) PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_TV_HBLANK_START);

        NVInfo->Dac.TVCursorMin = (ht+5-(hrs-2))*8 - tvhbe;
        NVInfo->Dac.TVCursorMax = (ht+5-((hrs-2)+hbs+1))*8 - tvhbs;
//        NVInfo->Dac.TVCursorMin += 20; // What should these values actually be?
//        NVInfo->Dac.TVCursorMax += 20; // What should these values actually be?
        NVInfo->Dac.TVCursorMin = 0;     // Set to zero for now   
        NVInfo->Dac.TVCursorMax = 0;     // Set to zero for now


        }
        

    //**************************************************************************
    // WHQL fixup code:
    //
    // The following code should probably be removed, and is leftover
    // code from the OLD style modeset code.  But we NEED to check
    // that the NEW style modeset code (ie RmSetMode) does indeed set
    // the following registers correctly.  Otherwise, this could cause
    // various WHQL tests to fail.  So for now, leave this code INTACT!
    //**************************************************************************

    {
    //**************************************************************************
    // Specify 5:5:5 or 5:6:5 format
    // ModeSet code currently defaults to 5:6:5 (in OEMSetRegs)
    //**************************************************************************

    if (RequestedMode->Depth == 16)
        {
        //**********************************************************************
        // Currently the display driver only handles 5:5:5 format...
        // So for now, just specify 5:5:5 always until we add the 5:6:5 specific modes
        //**********************************************************************
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,
            (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _16)) |
               (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)));
        }

    else if (RequestedMode->Depth == 8)
        {
        // if 8 bit mode, make sure we're using an 8bit palette
        //if (pDev.Framebuffer.Depth == 8)
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,
                (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)) );
        }

    //**************************************************************************
    // Make sure Bit 20 is always set for 32bpp modes
    //**************************************************************************

    if (RequestedMode->Depth == 32)
        {
        CurrentValue = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_GENERAL_CONTROL);
        CurrentValue |= (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)) ;
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,CurrentValue);
        }


    //**************************************************************************
    // Make sure to turn off 2D dithering.  Otherwise, HCT tests will fail!
    //**************************************************************************

    CurrentValue = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_DEBUG_3);

    //**************************************************************************
    // Mask off the 2d dither bits
    //**************************************************************************

    CurrentValue &= (~ ( (DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_2D, _ENABLED )) |
                         (DRF_DEF(_PGRAPH, _DEBUG_3, _PREDITHER_2D, _ENABLED )) ));


    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_3,CurrentValue);

    }
    

    //**************************************************************************
    // If flat panel is present, make sure to clear out the following registers
    // because video bios's after 09/02/99 may touch these registers.
    // These registers should probably get cleared in dacSetFlatPanelMode in the RM
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {
        REG_WR32(NV_PRAMDAC_FP_DEBUG_1, 0x00000000);
        REG_WR32(NV_PRAMDAC_FP_DEBUG_2, 0x00000000);
        }


    //**************************************************************************
    // Another ALI 1541 workaround fix
    //**************************************************************************


    if (HwDeviceExtension->AliChipset_Problem_Found==TRUE)
    
        {

        //**********************************************************************
        //
        // This chipset has another bug, confirmed by ALI, where it cannot
        // accept fast DEVSEL# at 100MHz bus speeds.  We cannot adjust our
        // DEVSEL# speeds, but we can delay our TRDY by one clock cycle, which
        // should have the same effect.
        //
        // Note that we (NV) have seen no improvement in any of the ALI1541
        // issues with this change, but ALI is adament there is a bug in the 1541
        // having to do with this logic.  Better safe than sorry.
        //
        // This bit is present in NV4, NV5, and NV10.
        //
        //**********************************************************************

        CurrentValue = REG_RD32(NV_PBUS_DEBUG_1);
        CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_DEBUG_1_PCIS_WRITE));
        REG_WR32(NV_PBUS_DEBUG_1,  CurrentValue);

        }
               

    return(TRUE);
    } // end NVSetMode()

//******************************************************************************
//
// Function: NV_SetColorLookup()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )
    {
    ULONG i;

    //**************************************************************************
    // wait for vblank
    //**************************************************************************
    if(HwDeviceExtension->curPowerState == VideoPowerOn)
    {
        while (!(PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08));
    }

    //**************************************************************************
    //  Specify first palette register
    //**************************************************************************
    USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_WRITE_MODE_ADDRESS, (UCHAR) ClutBuffer->FirstEntry);

    //**************************************************************************
    //  Set CLUT registers directly on the hardware
    //**************************************************************************

    for (i = 0; i < ClutBuffer->NumEntries; i++)
        {
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Red);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Green);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Blue);
        }

    }

//******************************************************************************
//
// Function: NV4_SetPixMixBits()
//
// Routine Description: Set the NV_PRAMDAC_GENERAL_CONTROL_PIXMIX to 
//                      NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_SetPixMixBits(
    PHW_DEVICE_EXTENSION    HwDeviceExtension
)
{
    ULONG   ulGeneralCtrl;

    ulGeneralCtrl = PRAMDAC_REG_RD32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL);

    //
    //  Set NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON
    //

    ulGeneralCtrl |= 0x30;
    PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,ulGeneralCtrl);
}

//******************************************************************************
//
// Function: NV4_InitPalette()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_InitPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
    {
    USHORT i;

    //**************************************************************************
    // Blast out our palette values.  First Init to index 0
    //**************************************************************************
    USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_WRITE_MODE_ADDRESS, (UCHAR) 0);

    //**************************************************************************
    // Init to a gray scale so something will appear instead of just black
    // 256 * 3 (for each R,G, and B component)
    //**************************************************************************

    for (i = 0; i < 256; i++)
        {
        //**********************************************************************
        // Just initialize to a gray scale for now.
        //**********************************************************************
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        }

    return;


    }


//******************************************************************************
//
// Function:    NVMapMemoryRanges()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NVMapMemoryRanges(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PHYSICAL_ADDRESS CrtcRange;
    PHYSICAL_ADDRESS TimerRange;
    PHYSICAL_ADDRESS NV_PhysBaseAddress;
    PHYSICAL_ADDRESS NV_PhysFBAddress;
    ULONG CrtcLength;
    ULONG TimerLength;
    ULONG NV_RegisterLength;
    ULONG NV_FrameBufferLength;
    PHWREG CrtcAddress;
    PHWREG TimerAddress;
    PHWREG NV_LinearBaseAddress;
    PHWREG NV_LinearFBAddress;
    PHYSICAL_ADDRESS ConfigPciRange;
    ULONG ConfigPciLength;
    PHWREG ConfigPciAddress;
    ULONG CurrentValue;

    //**************************************************************************
    // Make SURE to always ENABLE bus mastering!  Our chip needs it ENABLED !!
    // (Some DELL Bios's disable bus mastering on our card)
    //**************************************************************************

    //**************************************************************************
    // First get access to the CONFIG_PCI_NV1 register
    //**************************************************************************

    ConfigPciRange.HighPart  = 0x00000000;
    ConfigPciRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    ConfigPciRange.LowPart   += NV_PBUS_PCI_NV_1;
    ConfigPciLength          = 0x1000;   // Arbitrary 4k length

    ConfigPciAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         ConfigPciRange,
                                         ConfigPciLength, FALSE);
    if (ConfigPciAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Config PCI Reg\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Make sure bus mastering is always ENABLED !!  (Bit 2)
    // Read current value then enable the bus_master bit.
    //**************************************************************************

    CurrentValue = TEMP_REG_RD32(ConfigPciAddress);
    CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_PCI_NV_1_BUS_MASTER));
    TEMP_REG_WR32(ConfigPciAddress,  CurrentValue);

    //**************************************************************************
    // Free up this temporary range
    //**************************************************************************

    VideoPortFreeDeviceBase(hwDeviceExtension, ConfigPciAddress);


    //**************************************************************************
    // Make SURE to disable VBLANK and TIMER interrupts on startup!
    // (Some COMPAQ systems do not reset the chip, so these interrupts
    // may inadvertently get left enabled.  These interrupts (vblank/timer) then
    // enter our interrupt handler before its ready to accept them)
    //**************************************************************************

    //**************************************************************************
    // First get access to VBLANK interrupt enable register
    //**************************************************************************

    CrtcRange.HighPart  = 0x00000000;
    CrtcRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    CrtcRange.LowPart   += NV_PCRTC_INTR_EN_0;
    CrtcLength          = 0x1000;   // Arbitrary 4k length

    CrtcAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         CrtcRange,
                                         CrtcLength, FALSE);
    if (CrtcAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Crtc Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Get access to TIMER interrupt enable register
    //**************************************************************************

    TimerRange.HighPart  = 0x00000000;
    TimerRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    TimerRange.LowPart   += NV_PTIMER_INTR_EN_0 ;
    TimerLength          = 0x1000;   // Arbitrary 4k length

    TimerAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         TimerRange,
                                         TimerLength, FALSE);
    if (TimerAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Timer Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Make sure these interrupts are always DISABLED initially!
    //**************************************************************************

    TEMP_REG_WR32(CrtcAddress,  0x00000000);
    TEMP_REG_WR32(TimerAddress, 0x00000000);

    //**************************************************************************
    // Free up these temporary ranges
    //**************************************************************************

    VideoPortFreeDeviceBase(hwDeviceExtension, CrtcAddress);
    VideoPortFreeDeviceBase(hwDeviceExtension, TimerAddress);

    //**************************************************************************
    // Map entire NV register space
    //**************************************************************************

    NV_PhysBaseAddress.HighPart = 0x00000000;
    NV_PhysBaseAddress.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    NV_RegisterLength           = 0x1000000;    // 16M

    if ( (  NV_LinearBaseAddress = VideoPortGetDeviceBase(hwDeviceExtension,
                                                          NV_PhysBaseAddress,
                                                          NV_RegisterLength, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PGRAPH Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }
    hwDeviceExtension->NvRegisterBase = NV_LinearBaseAddress;

    //**************************************************************************
    // Initialize the 'individual' memory ranges
    //**************************************************************************

    hwDeviceExtension->NV1_Lin_PMC_Registers    = NV_LinearBaseAddress + (DEVICE_BASE(NV_PMC)/4);
    hwDeviceExtension->NV1_Lin_PFB_Registers    = NV_LinearBaseAddress + (DEVICE_BASE(NV_PFB)/4);
    hwDeviceExtension->NV1_Lin_PFIFO_Registers  = NV_LinearBaseAddress + (DEVICE_BASE(NV_PFIFO)/4);
    hwDeviceExtension->NV1_Lin_PBUS_Registers   = NV_LinearBaseAddress + (DEVICE_BASE(NV_PBUS)/4);
    hwDeviceExtension->NV1_Lin_PGRAPH_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PGRAPH)/4);
    hwDeviceExtension->NV1_Lin_PEXTDEV_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_PEXTDEV)/4);
    hwDeviceExtension->NV3_Lin_PRMVIO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PRMVIO)/4);
    hwDeviceExtension->NV3_Lin_PRMCIO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PRMCIO)/4);
    hwDeviceExtension->NV3_Lin_PRAMDAC_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_PRAMDAC)/4);
    hwDeviceExtension->NV3_Lin_USERDAC_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_USER_DAC)/4);
    hwDeviceExtension->NV3_Lin_PVIDEO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PVIDEO)/4);
    hwDeviceExtension->NV1_Lin_USER_Registers   = NV_LinearBaseAddress + (DEVICE_BASE(NV_USER)/4);
    hwDeviceExtension->pBios = (PUCHAR)(&((hwDeviceExtension->NvRegisterBase)->Reg008[DEVICE_BASE(NV_PRAMIN)]));

    //**************************************************************************
    // Return successful
    //**************************************************************************

    return(NO_ERROR);

    } // NVMapMemoryRanges()

//******************************************************************************
//
// Function:    NVMapFrameBuffer()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NVMapFrameBuffer(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VIDEO_MEMORY_INFORMATION memoryInformation;
    PHWINFO NVInfo;
    PHYSICAL_ADDRESS NVFrameBuffer;
    ULONG inIoSpace;
    ULONG status;
    ULONG MapMemoryAdjust;

    //**************************************************************************
    // Get the amount of memory available on the card
    // (Determined in GetNVInfo)
    //**************************************************************************

    NVInfo = &(hwDeviceExtension->NvInfo);
    memoryInformation.VideoRamLength = NVInfo->Framebuffer.RamSize;

    //**************************************************************************
    // Set VideoRamBase to zero, to map range at any location in the
    // logical address space of the current process
    //**************************************************************************

    memoryInformation.VideoRamBase = 0;

    //**************************************************************************
    // Get the physical address of the frame buffer
    //**************************************************************************

    NVFrameBuffer.HighPart = 0x00000000;
    NVFrameBuffer.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
    NVFrameBuffer.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;

    //**************************************************************************
    // Always set write combining for NT4.0 or later
    // Do NOT set it for NT 3.51 !!!!
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0400)
    inIoSpace = VIDEO_MEMORY_SPACE_P6CACHE;
#else
    inIoSpace = 0;
#endif

    //**************************************************************************
    // When calling RmPostNvDevice, and passing in our ptr to the frame buffer,
    // RmPostNvDevice needs to read and write a little bit PAST the end
    // of video memory in order to size it.  
    // 
    // So, in order to accomodate this and prevent a fatal exception error, 
    // we'll allocate just a little bit more memory than the actual amount needed. 
    // (Only necessary for Win2k or better)
    //**************************************************************************

    MapMemoryAdjust = memoryInformation.VideoRamLength;

#if (_WIN32_WINNT >= 0x0500)
    MapMemoryAdjust += BIOS_MEM_SIZE_ADJUST_FACTOR;
#endif


    status = VideoPortMapMemory(hwDeviceExtension,
                                 NVFrameBuffer,
                                 &(MapMemoryAdjust),
                                 &(inIoSpace),
                                 &(memoryInformation.VideoRamBase));


#if _WIN32_WINNT < 0x0500

    //**************************************************************************
    // Special Case unattended setup issue:
    //
    //      Normally, a 32Mb video card will install successfully on a system 
    //      with 32Mb of system memory, when the display driver is installed manually.
    //
    //      However, UNATTENDED setup of a 32Mb video card on a system with 32Mb
    //      may fail.  And what makes matters worse is that during unattended setup,
    //      the driver is usually installed BEFORE the service packs are applied.
    //      (Display driver should REALLY be installed AFTER the service pack is applied)
    //
    //      To alleviate this situation and allow a 32Mb video card to be installed
    //      via unattended setup, we'll try just allocating 16Mb if the above VideoPortMapMemory 
    //      call fails.  This is REALLY not valid (and may result in the driver
    //      not working correctly), but it will allow the driver to install
    //      and get past unattended setup.
    //
    //      After the service pack is applied, subsequent VideoPortMapMemory calls should 
    //      then succeed with no problem.    
    //       
    //**************************************************************************

    if (status != NO_ERROR)
        {

        NVInfo->Framebuffer.RamSizeMb = 16;
        NVInfo->Framebuffer.RamSize   = 0x01000000;

        memoryInformation.VideoRamLength = NVInfo->Framebuffer.RamSize;
        memoryInformation.VideoRamBase = 0;


        status = VideoPortMapMemory(hwDeviceExtension,
                                     NVFrameBuffer,
                                     &(memoryInformation.VideoRamLength),
                                     &(inIoSpace),
                                     &(memoryInformation.VideoRamBase));
        }
#endif



    hwDeviceExtension->FrameBufferPtr = memoryInformation.VideoRamBase;
    hwDeviceExtension->FrameBufferBase= memoryInformation.VideoRamBase;

    //**************************************************************************
    // If this call fails, driver should revert back to standard VGA
    //**************************************************************************

    return(status);



    }


//******************************************************************************
//
// Function: NVIsPresent()
//
// Routine Description:
//
// Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//
//******************************************************************************


BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      PULONG NV1Slot)

    {
    USHORT  usVendorId;
    USHORT  usDeviceId;
    ULONG   ulSlot     = 0;
    ULONG   i;
    BOOL    FoundNV4=FALSE;
    BOOL    FoundNV5=FALSE;
    BOOL    FoundNV5VANTA=FALSE;
    BOOL    FoundNV5ULTRA=FALSE;
    BOOL    FoundNV5MODEL64=FALSE;
    BOOL    FoundNV0A=FALSE;
    BOOL    FoundNV10=FALSE;
    BOOL    FoundNV10DDR=FALSE;
    BOOL    FoundNV10GL=FALSE;
    BOOL    FoundNV11=FALSE;
    BOOL    FoundNV11DDR=FALSE;
    BOOL    FoundNV11M=FALSE;
    BOOL    FoundNV11GL=FALSE;
    BOOL    FoundNV15=FALSE;
    BOOL    FoundNV15DDR=FALSE;
    BOOL    FoundNV15BR=FALSE;
    BOOL    FoundNV15GL=FALSE;
    BOOL    FoundNV20=FALSE;
    BOOL    FoundNV20_1=FALSE;
    BOOL    FoundNV20_2=FALSE;
    BOOL    FoundNV20_3=FALSE;

    //**************************************************************************
    // VideoPortGetAccessRanges calls the PCI Bios to determine
    //    if the specified device is present or not.  This appears
    //    to be the equivalent call to the PCI Bios FIND_PCI_DEVICE call.
    //
    // Specify NumRequestedResources = 0
    //         RequestedResources = NULL
    //         NumAccessRanges = 1
    //         TempAccessRanges = Bus relative memory ranges for device (returned)
    //         VendorID = ID which identifies manufacturer
    //         DeviceID = ID which identifies device
    //         Slot = Specifies the Nth device of this type.
    //                Specify 0 to find the first (zero'th) occurence of device)
    //**************************************************************************

    //**************************************************************************
    // First, check and see if NV4 is present
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0500)

    // NT5 version uses Plug-n-Play, i.e. no VID and DID required
    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 3,
                                 HwDeviceExtension->NVAccessRanges,
                                 NULL,
                                 NULL,
                                 &ulSlot) == NO_ERROR)

#else

    //**************************************************************************
    // Look for genuine NV4 (TNT)
    //**************************************************************************

    ulSlot     = 0;
    usVendorId = NV4_VENDOR_ID;
    usDeviceId = NV4_DEVICE_NV4_ID;

    // other NT versions must specify VID and DID
    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 2,
                                 HwDeviceExtension->NVAccessRanges,
                                 &usVendorId,
                                 &usDeviceId,
                                 &ulSlot) == NO_ERROR)

        {
        FoundNV4=TRUE;
        }

    else

        {

        //**********************************************************************
        // Look for NV5 (TNT2), backwards compatible with NV4
        //**********************************************************************

        ulSlot     = 0;
        usVendorId = NV4_VENDOR_ID;
        usDeviceId = NV5_DEVICE_NV5_ID;

        // other NT versions must specify VID and DID
        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 2,
                                 HwDeviceExtension->NVAccessRanges,
                                 &usVendorId,
                                 &usDeviceId,
                                 &ulSlot) == NO_ERROR)

            {
            FoundNV5=TRUE;
            }

        else

            {


            //******************************************************************
            // Look for ULTRA, backwards compatible with NV4
            //******************************************************************

            ulSlot     = 0;
            usVendorId = NV4_VENDOR_ID;
            usDeviceId = NV5ULTRA_DEVICE_NV5ULTRA_ID;

            // other NT versions must specify VID and DID
            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                     0,
                                     NULL,
                                     2,
                                     HwDeviceExtension->NVAccessRanges,
                                     &usVendorId,
                                     &usDeviceId,
                                     &ulSlot) == NO_ERROR)

                {
                FoundNV5ULTRA=TRUE;
                }


            else

                {


                //**************************************************************
                // Look for VANTA, backwards compatible with NV4
                //**************************************************************

                ulSlot     = 0;
                usVendorId = NV4_VENDOR_ID;
                usDeviceId = NV5VANTA_DEVICE_NV5VANTA_ID;

                // other NT versions must specify VID and DID
                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                         0,
                                         NULL,
                                         2,
                                         HwDeviceExtension->NVAccessRanges,
                                         &usVendorId,
                                         &usDeviceId,
                                         &ulSlot) == NO_ERROR)

                    {
                    FoundNV5VANTA=TRUE;
                    }


                else


                    {

                    //**************************************************************
                    // Look for TNT2 Model 64 backwards compatible with NV4
                    //**************************************************************

                    ulSlot     = 0;
                    usVendorId = NV4_VENDOR_ID;
                    usDeviceId = NV5MODEL64_DEVICE_NV5MODEL64_ID;

                    // other NT versions must specify VID and DID
                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                             0,
                                             NULL,
                                             2,
                                             HwDeviceExtension->NVAccessRanges,
                                             &usVendorId,
                                             &usDeviceId,
                                             &ulSlot) == NO_ERROR)

                        {
                        FoundNV5MODEL64=TRUE;
                        }


                    else


                        {
    
    
                        //**********************************************************
                        // Look for NV0A, backwards compatible with NV4
                        //**********************************************************
    
                        ulSlot     = 0;
                        usVendorId = NV4_VENDOR_ID;
                        usDeviceId = NV0A_DEVICE_NV0A_ID;
    
                        // other NT versions must specify VID and DID
                        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                 0,
                                                 NULL,
                                                 2,
                                                 HwDeviceExtension->NVAccessRanges,
                                                 &usVendorId,
                                                 &usDeviceId,
                                                 &ulSlot) == NO_ERROR)
    
                            {
                            FoundNV0A=TRUE;
                            }
    
    
                        else
    
                            {
    
                            //******************************************************
                            // Look for NV10, backwards compatible with NV4
                            //******************************************************
    
                            ulSlot     = 0;
                            usVendorId = NV4_VENDOR_ID;
                            usDeviceId = NV10_DEVICE_NV10_ID;
    
                            // other NT versions must specify VID and DID
                            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                 0,
                                                 NULL,
                                                 2,
                                                 HwDeviceExtension->NVAccessRanges,
                                                 &usVendorId,
                                                 &usDeviceId,
                                                 &ulSlot) == NO_ERROR)
    
                                {
                                FoundNV10=TRUE;
                                }


                            else
                            
                                {
                                
                                
                                //******************************************************
                                // Look for NV10DDR, backwards compatible with NV4
                                //******************************************************
    
                                ulSlot     = 0;
                                usVendorId = NV4_VENDOR_ID;
                                usDeviceId = NV10DDR_DEVICE_NV10DDR_ID;
    
                                // other NT versions must specify VID and DID
                                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                     0,
                                                     NULL,
                                                     2,
                                                     HwDeviceExtension->NVAccessRanges,
                                                     &usVendorId,
                                                     &usDeviceId,
                                                     &ulSlot) == NO_ERROR)
    
                                    {
                                    FoundNV10DDR=TRUE;
                                    }


                                else
                                
                                    {
                                    

                                    //******************************************************
                                    // Look for NV10GL, backwards compatible with NV4
                                    //******************************************************
    
                                    ulSlot     = 0;
                                    usVendorId = NV4_VENDOR_ID;
                                    usDeviceId = NV10GL_DEVICE_NV10GL_ID;
    
                                    // other NT versions must specify VID and DID
                                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                         0,
                                                         NULL,
                                                         2,
                                                         HwDeviceExtension->NVAccessRanges,
                                                         &usVendorId,
                                                         &usDeviceId,
                                                         &ulSlot) == NO_ERROR)
        
                                        {
                                        FoundNV10GL=TRUE;
                                        }

                                    else
                                    
                                        {

                                        //******************************************************
                                        // Look for NV11, backwards compatible with NV4
                                        //******************************************************
    
                                        ulSlot     = 0;
                                        usVendorId = NV4_VENDOR_ID;
                                        usDeviceId = NV11_DEVICE_NV11_ID;
    
                                        // other NT versions must specify VID and DID
                                        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                         0,
                                                         NULL,
                                                         2,
                                                         HwDeviceExtension->NVAccessRanges,
                                                         &usVendorId,
                                                         &usDeviceId,
                                                         &ulSlot) == NO_ERROR)
        
                                            {
                                            FoundNV11=TRUE;
                                            }


                                        else
                                        
                                            {

    
                                            //******************************************************
                                            // Look for NV11DDR, backwards compatible with NV4
                                            //******************************************************
    
                                            ulSlot     = 0;
                                            usVendorId = NV4_VENDOR_ID;
                                            usDeviceId = NV11DDR_DEVICE_NV11DDR_ID;
    
                                            // other NT versions must specify VID and DID
                                            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                         0,
                                                         NULL,
                                                         2,
                                                         HwDeviceExtension->NVAccessRanges,
                                                         &usVendorId,
                                                         &usDeviceId,
                                                         &ulSlot) == NO_ERROR)
        
                                                {
                                                FoundNV11DDR=TRUE;
                                                }


                                            else
 
                                                {


                                                //******************************************************
                                                // Look for NV11M, backwards compatible with NV4
                                                //******************************************************

                                                ulSlot     = 0;
                                                usVendorId = NV4_VENDOR_ID;
                                                usDeviceId = NV11M_DEVICE_NV11M_ID;

                                                // other NT versions must specify VID and DID
                                                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                             0,
                                                             NULL,
                                                             2,
                                                             HwDeviceExtension->NVAccessRanges,
                                                             &usVendorId,
                                                             &usDeviceId,
                                                             &ulSlot) == NO_ERROR)

                                                    {
                                                    FoundNV11M=TRUE;
                                                    }


                                                else
                                    
                                                    {

                                                    //******************************************************
                                                    // Look for NV11GL, backwards compatible with NV4
                                                    //******************************************************
        
                                                    ulSlot     = 0;
                                                    usVendorId = NV4_VENDOR_ID;
                                                    usDeviceId = NV11GL_DEVICE_NV11GL_ID;
        
                                                    // other NT versions must specify VID and DID
                                                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                 0,
                                                                 NULL,
                                                                 2,
                                                                 HwDeviceExtension->NVAccessRanges,
                                                                 &usVendorId,
                                                                 &usDeviceId,
                                                                 &ulSlot) == NO_ERROR)
            
                                                    {
                                                    FoundNV11GL=TRUE;
                                                    }

                                                    else
                                        
                                                        {


                                                        //******************************************************
                                                        // Look for NV15, backwards compatible with NV4
                                                        //******************************************************
            
                                                        ulSlot     = 0;
                                                        usVendorId = NV4_VENDOR_ID;
                                                        usDeviceId = NV15_DEVICE_NV15_ID;
            
                                                        // other NT versions must specify VID and DID
                                                        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                     0,
                                                                     NULL,
                                                                     2,
                                                                     HwDeviceExtension->NVAccessRanges,
                                                                     &usVendorId,
                                                                     &usDeviceId,
                                                                     &ulSlot) == NO_ERROR)
                
                                                            {
                                                            FoundNV15=TRUE;
                                                            }


                                                        else
                                    
                                                            {

                                                        //******************************************************
                                                        // Look for NV15DDR, backwards compatible with NV4
                                                        //******************************************************
                
                                                            ulSlot     = 0;
                                                            usVendorId = NV4_VENDOR_ID;
                                                            usDeviceId = NV15DDR_DEVICE_NV15DDR_ID;
                
                                                        // other NT versions must specify VID and DID
                                                            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                         0,
                                                                         NULL,
                                                                         2,
                                                                         HwDeviceExtension->NVAccessRanges,
                                                                         &usVendorId,
                                                                         &usDeviceId,
                                                                         &ulSlot) == NO_ERROR)
                    
                                                                {
                                                                FoundNV15DDR=TRUE;
                                                                }



                                                            else
                                    
                                                                {

                                                            //******************************************************
                                                            // Look for NV15BR, backwards compatible with NV4
                                                            //******************************************************
                
                                                                ulSlot     = 0;
                                                                usVendorId = NV4_VENDOR_ID;
                                                                usDeviceId = NV15BR_DEVICE_NV15BR_ID;
                
                                                            // other NT versions must specify VID and DID
                                                                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                             0,
                                                                             NULL,
                                                                             2,
                                                                             HwDeviceExtension->NVAccessRanges,
                                                                             &usVendorId,
                                                                             &usDeviceId,
                                                                             &ulSlot) == NO_ERROR)
                    
                                                                    {
                                                                    FoundNV15BR=TRUE;
                                                                    }



                                                                else
                                            
                                                                    {

                                                                //******************************************************
                                                                // Look for NV15GL backwards compatible with NV4
                                                                //******************************************************
                    
                                                                    ulSlot     = 0;
                                                                    usVendorId = NV4_VENDOR_ID;
                                                                    usDeviceId = NV15GL_DEVICE_NV15GL_ID;
                    
                                                                // other NT versions must specify VID and DID
                                                                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                 0,
                                                                                 NULL,
                                                                                 2,
                                                                                 HwDeviceExtension->NVAccessRanges,
                                                                                 &usVendorId,
                                                                                 &usDeviceId,
                                                                                 &ulSlot) == NO_ERROR)
                            
                                                                        {
                                                                        FoundNV15GL=TRUE;
                                                                        }
    
    
                                                                    else

                                                                        {


                                                                        //******************************************************
                                                                        // Look for NV20 (note: NV20 has 3 BAR's)
                                                                        //******************************************************

                                                                        ulSlot     = 0;
                                                                        usVendorId = NV4_VENDOR_ID;
                                                                        usDeviceId = NV20_DEVICE_NV20_ID;

                                                                        // other NT versions must specify VID and DID
                                                                        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                     0,
                                                                                     NULL,
                                                                                     3,
                                                                                     HwDeviceExtension->NVAccessRanges,
                                                                                     &usVendorId,
                                                                                     &usDeviceId,
                                                                                     &ulSlot) == NO_ERROR)

                                                                            {
                                                                            FoundNV20=TRUE;
                                                                            }


                                                                        else

                                                                            {


                                                                            //******************************************************
                                                                            // Look for NV20 (note: NV20 has 3 BAR's)
                                                                            //******************************************************

                                                                            ulSlot     = 0;
                                                                            usVendorId = NV4_VENDOR_ID;
                                                                            usDeviceId = NV20_DEVICE_NV20_1_ID;

                                                                            // other NT versions must specify VID and DID
                                                                            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                         0,
                                                                                         NULL,
                                                                                         3,
                                                                                         HwDeviceExtension->NVAccessRanges,
                                                                                         &usVendorId,
                                                                                         &usDeviceId,
                                                                                         &ulSlot) == NO_ERROR)

                                                                                {
                                                                                FoundNV20_1=TRUE;
                                                                                }


                                                                            else

                                                                                {


                                                                                //******************************************************
                                                                                // Look for NV20 (note: NV20 has 3 BAR's)
                                                                                //******************************************************

                                                                                ulSlot     = 0;
                                                                                usVendorId = NV4_VENDOR_ID;
                                                                                usDeviceId = NV20_DEVICE_NV20_2_ID;

                                                                                // other NT versions must specify VID and DID
                                                                                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                             0,
                                                                                             NULL,
                                                                                             3,
                                                                                             HwDeviceExtension->NVAccessRanges,
                                                                                             &usVendorId,
                                                                                             &usDeviceId,
                                                                                             &ulSlot) == NO_ERROR)

                                                                                    {
                                                                                    FoundNV20_2=TRUE;
                                                                                    }


                                                                                else

                                                                                    {


                                                                                    //******************************************************
                                                                                    // Look for NV20 (note: NV20 has 3 BAR's)
                                                                                    //******************************************************

                                                                                    ulSlot     = 0;
                                                                                    usVendorId = NV4_VENDOR_ID;
                                                                                    usDeviceId = NV20_DEVICE_NV20_3_ID;

                                                                                    // other NT versions must specify VID and DID
                                                                                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                                 0,
                                                                                                 NULL,
                                                                                                 3,
                                                                                                 HwDeviceExtension->NVAccessRanges,
                                                                                                 &usVendorId,
                                                                                                 &usDeviceId,
                                                                                                 &ulSlot) == NO_ERROR)

                                                                                        {
                                                                                        FoundNV20_3=TRUE;
                                                                                        }


                                                                                    } // Look for NV20 ID 203

                                                                                } // Look for NV20 ID 202

                                                                            } // Look for NV20 ID 201

                                                                        } // Look for NV20

                                                                    } // Look for NV15 GL


                                                                } // Look for NV15 BR


                                                            } // Look for NV 15 DDR

                                        
                                                        } // Look for NV15

                                        
                                                    } // Look for NV11 GL


                                                } // Look for NV11M

                                            
                                            } // Look for NV11 DDR


                                        } // Look for NV11


                                    } // Look for NV10 GL

                                
                                } // Look for NV10 ULTRA
                                
    
                            } // Look for NV10
    
    
                        } // Look for NV0A


                    } // Look for TNT2 Model 64


                } // Look for VANTA 


            }  // Look for ULTRA (TNT2 ULTRA)


        } // Look for NV5 (TNT2)

    //**************************************************************************
    // Look for an NV4 compatible chip
    //**************************************************************************

    if ( (FoundNV4)  || 
         (FoundNV5)  || (FoundNV5ULTRA) || (FoundNV5VANTA) || (FoundNV5MODEL64) || 
         (FoundNV0A) || 
         (FoundNV10) || (FoundNV10DDR) || (FoundNV10GL) ||
         (FoundNV11) || (FoundNV11DDR) || (FoundNV11M)  || (FoundNV11GL) ||
         (FoundNV15) || (FoundNV15DDR) || (FoundNV15BR) || (FoundNV15GL) ||
         (FoundNV20) || (FoundNV20_1)  || (FoundNV20_2) || (FoundNV20_3))


#endif // _WIN32_WINNT >= 0x0500

        {
        VideoDebugPrint((1,"Found an NV4 (or better) in pci slot %d\n", ulSlot));

        //**********************************************************************
        //  At this point we have identified an NV4 on the PCI bus by using
        //  the vendor and device id.
        //**********************************************************************

        HwDeviceExtension->ulSlot       = ulSlot;
        HwDeviceExtension->ulChipID     = NV4_DEVICE_NV4_ID;
        HwDeviceExtension->ulRevLevel   = REV_UNDEF;
        HwDeviceExtension->BoardID      = NV4_VENDOR_ID;


        //**********************************************************************
        // Check for NV5, NV5 ULTRA, NV5 VANTA, NV5 Model 64, NV0A, or NV10 (all NV4 compatible)
        // and assign a unique chip ID
        //**********************************************************************

        if (FoundNV5)
            HwDeviceExtension->ulChipID     = NV5_DEVICE_NV5_ID;
        else if (FoundNV5ULTRA)
            HwDeviceExtension->ulChipID     = NV5ULTRA_DEVICE_NV5ULTRA_ID;
        else if (FoundNV5VANTA)
            HwDeviceExtension->ulChipID     = NV5VANTA_DEVICE_NV5VANTA_ID;
        else if (FoundNV5MODEL64)
            HwDeviceExtension->ulChipID     = NV5MODEL64_DEVICE_NV5MODEL64_ID;
        else if (FoundNV0A)
            HwDeviceExtension->ulChipID     = NV0A_DEVICE_NV0A_ID;

        else if (FoundNV10)
            HwDeviceExtension->ulChipID     = NV10_DEVICE_NV10_ID;
        else if (FoundNV10DDR)
            HwDeviceExtension->ulChipID     = NV10DDR_DEVICE_NV10DDR_ID;
        else if (FoundNV10GL)
            HwDeviceExtension->ulChipID     = NV10GL_DEVICE_NV10GL_ID;

        else if (FoundNV11)
            HwDeviceExtension->ulChipID     = NV11_DEVICE_NV11_ID;
        else if (FoundNV11DDR)
            HwDeviceExtension->ulChipID     = NV11DDR_DEVICE_NV11DDR_ID;
        else if (FoundNV11M)
            HwDeviceExtension->ulChipID     = NV11M_DEVICE_NV11M_ID;
        else if (FoundNV11GL)
            HwDeviceExtension->ulChipID     = NV11GL_DEVICE_NV11GL_ID;

        else if (FoundNV15)
            HwDeviceExtension->ulChipID     = NV15_DEVICE_NV15_ID;
        else if (FoundNV15DDR)
            HwDeviceExtension->ulChipID     = NV15DDR_DEVICE_NV15DDR_ID;
        else if (FoundNV15BR)
            HwDeviceExtension->ulChipID     = NV15BR_DEVICE_NV15BR_ID;
        else if (FoundNV15GL)
            HwDeviceExtension->ulChipID     = NV15GL_DEVICE_NV15GL_ID;
        
        else if (FoundNV20)
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_ID;
        else if (FoundNV20_1)
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_1_ID;
        else if (FoundNV20_2)
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_2_ID;
        else if (FoundNV20_3)
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_3_ID;


        //**********************************************************************
        // NOTE: For Win2K, device IDs are in the INF, so we don't
        //       know what chip we're running on.  So for Win2k, we actually
        //       determine the chip ID just a little bit later in NVGetNVInfo !!.
        //**********************************************************************

        //**********************************************************************
        // Save the slot number of later (for VideoPortSetBusData)
        //**********************************************************************

        *NV1Slot = ulSlot;

        //**********************************************************************
        // QUERY_PUBLIC_ACCESS_RANGES will use the following values to properly map
        // in the public access ranges.  For our display driver, we're going
        // to declare public access ranges:     1) NV User Channel containing subchannels
        //                                      2) Graphics Status Register
        //                                      3) Frame buffer VBLANK register
        //                                      4) Frame buffer START register
        //                                      5) CRTC regs, etc....
        // Only the miniport will have access to all of the other privileged
        // graphics registers.
        //**********************************************************************

        //**********************************************************************
        // Init NV memory range offset values to zero
        //**********************************************************************

        for (i=0 ; i<NV_NUM_RANGES ;i++)
          {
          RangeOffsets[i].ulOffset = 0;
          RangeOffsets[i].ulLength = 0;
          }

        //**********************************************************************
        // Initialize the actual offset values
        //**********************************************************************

        RangeOffsets[NV_PMC_INDEX].ulOffset = DEVICE_BASE(NV_PMC);
        RangeOffsets[NV_PMC_INDEX].ulLength = DEVICE_EXTENT(NV_PMC);

        RangeOffsets[NV_PFB_INDEX].ulOffset = DEVICE_BASE(NV_PFB);
        RangeOffsets[NV_PFB_INDEX].ulLength = DEVICE_EXTENT(NV_PFB);

        RangeOffsets[NV_PFIFO_INDEX].ulOffset = DEVICE_BASE(NV_PFIFO);
        RangeOffsets[NV_PFIFO_INDEX].ulLength = DEVICE_EXTENT(NV_PFIFO);

        RangeOffsets[NV_PBUS_INDEX].ulOffset = DEVICE_BASE(NV_PBUS);
        RangeOffsets[NV_PBUS_INDEX].ulLength = DEVICE_EXTENT(NV_PBUS);

        RangeOffsets[NV_PGRAPH_INDEX].ulOffset = DEVICE_BASE(NV_PGRAPH);
        RangeOffsets[NV_PGRAPH_INDEX].ulLength = DEVICE_EXTENT(NV_PGRAPH);

        RangeOffsets[NV_PEXTDEV_INDEX].ulOffset = DEVICE_BASE(NV_PEXTDEV);
        RangeOffsets[NV_PEXTDEV_INDEX].ulLength = DEVICE_EXTENT(NV_PEXTDEV);

        RangeOffsets[NV_PRMVIO_INDEX].ulOffset = DEVICE_BASE(NV_PRMVIO);
        RangeOffsets[NV_PRMVIO_INDEX].ulLength = DEVICE_EXTENT(NV_PRMVIO);

        RangeOffsets[NV_PRMCIO_INDEX].ulOffset = DEVICE_BASE(NV_PRMCIO);
        RangeOffsets[NV_PRMCIO_INDEX].ulLength = DEVICE_EXTENT(NV_PRMCIO);

        RangeOffsets[NV_PRAMDAC_INDEX].ulOffset = DEVICE_BASE(NV_PRAMDAC);
        RangeOffsets[NV_PRAMDAC_INDEX].ulLength = DEVICE_EXTENT(NV_PRAMDAC);

        RangeOffsets[NV_USERDAC_INDEX].ulOffset = DEVICE_BASE(NV_USER_DAC);
        RangeOffsets[NV_USERDAC_INDEX].ulLength = DEVICE_EXTENT(NV_USER_DAC);

        RangeOffsets[NV_PVIDEO_INDEX].ulOffset = DEVICE_BASE(NV_PVIDEO);
        RangeOffsets[NV_PVIDEO_INDEX].ulLength = DEVICE_EXTENT(NV_PVIDEO);

        //**********************************************************************
        // Currently allows us to write to 64k of PRAMIN memory
        //**********************************************************************

        RangeOffsets[NV_PRAMIN_INDEX].ulOffset = (ULONG) (DEVICE_BASE(NV_PRAMIN) - DEVICE_BASE(NV_PDFB));
        RangeOffsets[NV_PRAMIN_INDEX].ulLength = 0x10000;

        RangeOffsets[NV_USER_INDEX].ulOffset = DEVICE_BASE(NV_USER);
        RangeOffsets[NV_USER_INDEX].ulLength = 0x10000;

        //**********************************************************************
        // Just allocate memory for the GRAPHICS STATUS register
        // Allocate minimal 16 bytes because we're only mapping 1 register
        //**********************************************************************

        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset = NV_PGRAPH_STATUS;
        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulLength = 16;

        //**********************************************************************
        // Setmode still uses PFB_CONFIG
        //**********************************************************************

        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset = NV_PFB_CONFIG_0;
        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulLength = 16;

        //**********************************************************************
        // DUMB FRAME BUFFER location
        // The actual amount of memory is determined later in NV_GetNVInfo,
        // but for now, just default to 4Mb.  This value will be fixed up
        // in NV_GetNVInfo so that IOCTL_VIDEO_MAP_MEMORY will subsequently
        // map in the correct number of bytes.
        //**********************************************************************

        RangeOffsets[NV_PDFB_INDEX].ulOffset = 0x0;
        RangeOffsets[NV_PDFB_INDEX].ulLength =  0x400000;

        return(TRUE);
        }
    else
        return(FALSE);
    }



//******************************************************************************
//
// Function:    MiniportGetRegistryValue
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

BOOL MiniportGetRegistryValue
    (PHW_DEVICE_EXTENSION HwDeviceExtension,
     U032 Type,
     char *Node,
     char *Name,
     VOID *pData)

    {
    ULONG NumRegValueEntries = sizeof(Nv_Registry_Switch_Offset_Table) / sizeof(NT_NV_REGISTRY_SWITCH_OFFSET);    
    ULONG i=0;   
    BOOL FoundFlag = FALSE;
    ULONG FoundIndex;
    BOOL status;
    char *RegValuePtr;
    char TempNameString[REG_STRING_DATA_MAX];
    WCHAR parameterName[80];
    

    //**************************************************************************
    // This function is called by the RM to get registry switch values.
    // Normally, the RM expects a 'Win9x' type registry, with various levels
    // of keys.  But with WinNT, all our registry switches must fit in
    // ONE key (ie. a flat structure).
    //
    // This routine attempts to find the registry switch name in our
    // registry switch table.  If it's present, we return the value (or string) back.
    // Otherwise, we return false   
    //**************************************************************************

    //**************************************************************************
    // First convert the registry value name string, and
    // convert to all upper case
    //**************************************************************************
    
    my_strcpy(TempNameString,Name);
    my_strupr(TempNameString);
    
    //**************************************************************************
    // Next, Search our registry table to see if this registry switch exists
    // in our 'local' registry structure.
    //**************************************************************************
        
    while ( (i < NumRegValueEntries) && (FoundFlag == FALSE) )
        {
        //**********************************************************************
        // Convert the registry switch names in our local registry table to upper case
        //**********************************************************************

        my_strupr(&Nv_Registry_Switch_Offset_Table[i].RegName[0]);

        //**********************************************************************
        // Now compare and see if this registry switch exists in our table
        // If so, then get the index into our registry switch table.
        //**********************************************************************
        
        status = my_strcmp(&Nv_Registry_Switch_Offset_Table[i].RegName[0], TempNameString);
        if (status == 0)
            {
            FoundFlag = TRUE;
            FoundIndex = i;
            }
                        
        i++;                
        }


    //**************************************************************************
    // If the registry switch was found in our table, then
    // get the corresponding value from our RegistrySwitch structure 
    // in our HwDeviceExtension.  Otherwise, return FALSE. 
    //**************************************************************************

    if (FoundFlag==TRUE)

        {

        if (Type == IS_STRING)

            {
            //******************************************************************
            // Copy the String value
            //******************************************************************

            RegValuePtr = (CHAR *) ((PUCHAR)&HwDeviceExtension->NV_Registry_Table + Nv_Registry_Switch_Offset_Table[FoundIndex].Offset); 
            my_strcpy(pData, RegValuePtr);
            }

        else if (Type == IS_DWORD)

            {
            //******************************************************************
            // Return the DWORD value
            //******************************************************************

            RegValuePtr = (CHAR *) ((PUCHAR)&HwDeviceExtension->NV_Registry_Table + Nv_Registry_Switch_Offset_Table[FoundIndex].Offset); 
            *(ULONG *)pData = *(ULONG *)RegValuePtr;
            

            //******************************************************************
            // Check if we should IGNORE the registry value
            //******************************************************************

            if ( *(ULONG *)pData == IGNORE_REGISTRY_SWITCH)
                return(FALSE);



            }
                
        return(TRUE);
        }
                
          
    else

        {

        //**********************************************************************
        // Unknown registry switch encountered.
        // This may happen if the RM is looking at a Win9x registry switch
        // and it hasn't been added to the NT registry switch table.
        // 
        // In that case, just read the registry switch as a normal
        // value entry (instead of inside our own local NT registry structure)
        // First, convert the parameter into a unicode string
        //**********************************************************************


        for (i = 0; Name[i]; i++)
            {
            parameterName[i] = Name[i];
            }
        parameterName[i] = (WCHAR)NULL;


        status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       parameterName,
                                       FALSE,
                                       NVReadRegistrySwitchesCallback,
                                       (ULONG *)pData);

        if (status == NO_ERROR)
            return(TRUE);
        else
            return(FALSE);            

        }
        
                    
       
    }
    

//******************************************************************************
//
// Function:    LoadRegistrySettings
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID LoadRegistrySettings(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG status;

    //**************************************************************************
    // There are 2 ways we can store registry switches for our NT driver:
    // 
    //   1) Store each registry switch in its own value entry
    //
    //      Advantages:     Easy to edit individual entries with RegEdit
    //      Disadvantages:  Lots of value entries are created which clutter
    //                      up the registry key.  If we need to delete them,
    //                      we may have to delete the entries one by one.
    //
    //   2) Store ALL the registry switches as a chunk in one value entry
    //         
    //      Advantages:     All the registry switches are in one place, not as unwieldly
    //      Disadvantes:    Not as easy to edit individual entries with RegEdit.
    //                          
    // 
    //   For now, we'll go with option 2) and store the switches as
    //   one chunk in a Value Entry.
    //**************************************************************************

    //**************************************************************************
    // First, check and see if our NT registry value entry (which contains our
    // local registry switches) is present or not.  If it's present, then
    // just read it straight into our registry structure.
    //**************************************************************************

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"NVREGSWITCHES",
                                       FALSE,
                                       NVReadRegistrySwitchesCallback,
                                       &(HwDeviceExtension->NV_Registry_Table));

    if (status == NO_ERROR)
        {
        return;
        }
        
    else
    
        {
        //**********************************************************************
        // If the registry value entry was NOT present, then
        //   1) Load up our registry structure with default values, then
        //   2) Write the registry structure to the registry.   
        //**********************************************************************

        LoadDefaultRegistrySwitchValues(HwDeviceExtension);
                
        //**********************************************************************
        // Write the registry switches to the registry as one binary chunk (a structure)
        //**********************************************************************

        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"NVREGSWITCHES",
                                       &(HwDeviceExtension->NV_Registry_Table),
                                       sizeof(HwDeviceExtension->NV_Registry_Table));

        return;        
        }

    }
    

//******************************************************************************
//
// Function:    LoadDefaultRegistrySwitchValues
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID LoadDefaultRegistrySwitchValues(
    PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG status;

// STUB OUT FOR NOW SINCE \common\NVREG.H is constantly changing 
// and breaking the NT build.  When NVREG.H settles down, then
// we can put this function back in

//    //**************************************************************************
//    // Default DISPLAY registry switch values        
//    //**************************************************************************
//
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastDisplayDevice[0]),     NV4_REG_DRV_LAST_DEVICE_CRT );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastCRTMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastDFPMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastNTSCMode[0]),          "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastPALMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.CRTMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DFPMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.NTSCMode[0]),              "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.PALMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DefaultCRTRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DefaultDFPRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.OptimalCRTRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.OptimalDFPRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.MonitorTiming[0]),          NV4_REG_DRV_MONITOR_TIMING_DMT);
//
//    HwDeviceExtension->NV_Registry_Table.Display.DisplayType =                           DISPLAY_TYPE_MONITOR;
//    HwDeviceExtension->NV_Registry_Table.Display.TVType =                                DISPLAY_TYPE_MONITOR;
//    HwDeviceExtension->NV_Registry_Table.Display.CursorAlpha =                           0;
//
//    //**************************************************************************
//    // Default DIRECTDRAW registry switch values        
//    //**************************************************************************
//
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.VPENABLE                    = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayMode                 = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayColorControlEnable   = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayBrightness           = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayContrast             = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayHue                  = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlaySaturation           = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayGamma                = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlaySharpness            = 0;
//
//    //**************************************************************************
//    // Default DIRECT3D registry switch values        
//    //**************************************************************************
//
//    HwDeviceExtension->NV_Registry_Table.Direct3D.ANTIALIASENABLE               = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.COLORKEYCOMPATABILITYENABLE   = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.CONTROLTRAFFIC                = 0;             
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DIRECTMAPENABLE               = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.FOGTABLENABLE                 = 0;              
//    HwDeviceExtension->NV_Registry_Table.Direct3D.LOGOENABLE                    = 0;                 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.SCENESYNCENABLE               = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TILINGENABLE                  = 0;                
//    HwDeviceExtension->NV_Registry_Table.Direct3D.USERMIPMAPENABLE              = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VIDEOTEXTUREENABLEENABLE      = 0;    
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VSYNCENABLE                   = 0;                 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WENABLE                       = 0;                     
//    HwDeviceExtension->NV_Registry_Table.Direct3D.Z24ENABLE                     = 0;                   
//
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AAMETHOD                      = D3D_REG_AAMETHOD_MIN;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AUTOMIPMAPMETHOD              = D3D_REG_AUTOMIPMAPMETHOD_BILINEAR; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.CKREF                         = D3D_REG_CKREF_MIN;                       
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DX6ENABLE                     = 0;                   
//    HwDeviceExtension->NV_Registry_Table.Direct3D.ANISOTOPIC4TAP                = D3D_REG_MIPMAPDITHERMODE_DISABLE;  
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PAL8TEXTURECONVERT            = D3D_REG_PAL8TEXCONVERT_NONE; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PMTRIGGER                     = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TEXELALIGNMENT                = D3D_REG_TEXELALIGNMENT_ZOH_CENTER;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VALIDATEZMETHOD               = D3D_REG_VALIDATEZMETHOD_FLEXIBLE;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.W16FORMAT                     = D3D_REG_WFORMAT_FIXED;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.W32FORMAT                     = D3D_REG_WFORMAT_FIXED;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AGPTEXCUTOFF                  = D3D_REG_DEFAULT_AGPTEXCUTOFF;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.D3DCONTEXTMAX                 = D3D_REG_DEFAULT_D3DCONTEXTMAX; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.D3DTEXTUREMAX                 = D3D_REG_DEFAULT_D3DTEXTUREMAX;  
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DMAMINPUSHCOUNT               = D3D_REG_DEFAULT_DMAMINPUSHCOUNT;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.LODBIASADJUST                 = D3D_REG_DEFAULT_LODBIASADJUST;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.MINVIDEOTEXSIZE               = D3D_REG_DEFAULT_MINVIDEOTEXSIZE;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.MIPMAPLEVELS                  = D3D_REG_DEFAULT_MIPMAPLEVELS;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PERFSTRATEGY                  = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.NOVSYNCPREREDNERLIMIT         = D3D_REG_DEFAULT_PRERENDERLIMIT;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DMAPUSHBUFFERSIZEMAX          = D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TEXHEAP                       = D3D_REG_DEFAULT_TEXHEAPSIZEMAX;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WSCALE16                      = D3D_REG_DEFAULT_WSCALE16;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WSCALE24                      = D3D_REG_DEFAULT_WSCALE24;
//
//    //**************************************************************************
//    // Default SYSTEM registry switch values        
//    //**************************************************************************
//                    
//    HwDeviceExtension->NV_Registry_Table.System.Super7Compat                    = 0;    
//    HwDeviceExtension->NV_Registry_Table.System.FlipOnHSync                     = 0;     
//    HwDeviceExtension->NV_Registry_Table.System.FilterOverride                  = 0;  
//    HwDeviceExtension->NV_Registry_Table.System.NoNT4AGP                        = 0;        
//    HwDeviceExtension->NV_Registry_Table.System.George                          = IGNORE_REGISTRY_SWITCH;          
//    HwDeviceExtension->NV_Registry_Table.System.Gracie                          = IGNORE_REGISTRY_SWITCH;          
//    HwDeviceExtension->NV_Registry_Table.System.TVOutOnPrimary                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.Enable256Burst                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.DisableMPCDetect                = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.MemoryOverride                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.RTLOverride                     = IGNORE_REGISTRY_SWITCH;  
//
//    //**************************************************************************
//    // Default NVTWEAK Control Panel registry switch values ?       
//    //**************************************************************************

    }
    
//******************************************************************************
//
// Function:   BuildAvailableModesTable
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID BuildAvailableModesTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {

    U016 i;
    U016 NumGTFModes;    
    U016 GTFWidth,GTFHeight,GTFDepth,GTFRefresh;
    U016 RegWidth,RegHeight,RegDepth,RegRefresh;
    U032 *GTFModePtr;
    U016 *RegDataPtr;
    U016 *ValidModePtr, *BaseOfValidModeTable;
    BOOL FoundRefreshFlag;
    ULONG status;
    PMODE_ENTRY PModePtr;            
    ULONG widthDivide = 1, heightDivide = 1; // For NV11 MultiHead support.
    
    //**************************************************************************
    // The NVx_MODES modetable entries for each chip type will always be stored 
    // in the \device0 key, since the INF doesn't appear to be able to store them
    // in device1,device2, etc...   As a result, we always store and get modetable
    // registry data from the \device0 key for ALL chip types, and then save them
    // off in global mode tables. Essentially, all modetable registry data will
    // only be read when the FIRST nv device is found.   
    //    
    // That is, VideoPortGetRegistryParameters() will SUCCEED when reading the
    // mode table value entries from \device0, but will FAIL when it tries 
    // to read them from \device1\2\3...because the modetable entries won't be present!
    //
    // We use global modedata tables, so that we can copy modetable data
    // into the hwdeviceextension of each device found.
    //
    // The following is a simplified explanation:
    //
    // 1) hkey_local_machine\system\currentcontrolset\services\nv4\device0\
    //      
    //       nv4_modes      -> This value entry contains mode data for nv4
    //       nv5_modes      -> This value entry contains mode data for nv5
    //       nv5m64_modes   -> This value entry contains mode data for nv5m64
    //       nvvanta_modes  -> This value entry contains mode data for nvvanta
    //       etc...
    //
    // 2) When ..\NVx\device0 is found, all the mode data will be read from the
    //    registry into the global mode data tables:
    //
    //       NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       etc....
    //
    // 3) For each device, the mode data for the corresponding chip
    //    type is copied into the ValidModeData in the device's
    //    hwDeviceExtension->ValidModeTable[]
    //  
    //**************************************************************************
                    
    //**************************************************************************
    // Init the global modedata tables with an 0xFFFF terminator.
    // That way, we can tell if the mode registry data was sucessfully copied.
    // (This could happen if the driver was not properly installed, using an
    // INF without mode table data)
    //
    // We ONLY initialize these mode tables the first time the driver is initialized.
    // We can tell by looking at the first entry, which should be 8bpp, width=640,
    // height=480).
    //**************************************************************************

    if ( !( (NV4_registry_data[0] == 8) && (NV4_registry_data[1] == 640) && (NV4_registry_data[2] == 480) && (NV4_registry_data[3] == 60)) )
        {    
        NV4_registry_data[0]        = 0xFFFF ;
        NV5_registry_data[0]        = 0xFFFF ;
        NV0A_registry_data[0]       = 0xFFFF ;
        NVVANTA_registry_data[0]    = 0xFFFF ; 
        NV5M64_registry_data[0]     = 0xFFFF ;
        NV5ULTRA_registry_data[0]   = 0xFFFF ; 
        NV10_registry_data[0]       = 0xFFFF ;
        NV10DDR_registry_data[0]    = 0xFFFF ;
        NV10GL_registry_data[0]     = 0xFFFF ;

        NV11_registry_data[0]       = 0xFFFF ;
        NV11DDR_registry_data[0]    = 0xFFFF ;
        NV11M_registry_data[0]      = 0xFFFF ;
        NV11GL_registry_data[0]     = 0xFFFF ;

        NV15_registry_data[0]       = 0xFFFF ;
        NV15DDR_registry_data[0]    = 0xFFFF ;
        NV15BR_registry_data[0]     = 0xFFFF ;
        NV15GL_registry_data[0]     = 0xFFFF ;

        NV20_registry_data[0]       = 0xFFFF ;
        NV20_1_registry_data[0]     = 0xFFFF ;
        NV20_2_registry_data[0]     = 0xFFFF ;
        NV20_3_registry_data[0]     = 0xFFFF ;

            
        //*********************************************************************
        // Now copy the registry data per each specific chip type
        // and copy it into our mode tables
        //*********************************************************************

        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV4_MODES",         &(NV4_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5_MODES",         &(NV5_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV0A_MODES",        &(NV0A_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NVVANTA_MODES",     &(NVVANTA_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5M64_MODES",      &(NV5M64_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5ULTRA_MODES",    &(NV5ULTRA_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10_MODES",        &(NV10_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10DDR_MODES",     &(NV10DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10GL_MODES",      &(NV10GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11_MODES",        &(NV11_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11DDR_MODES",     &(NV11DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11M_MODES",       &(NV11M_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11GL_MODES",      &(NV11GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15_MODES",        &(NV15_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15DDR_MODES",     &(NV15DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15BR_MODES",      &(NV15BR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15GL_MODES",      &(NV15GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_MODES",        &(NV20_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_1_MODES",      &(NV20_1_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_2_MODES",      &(NV20_2_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_3_MODES",      &(NV20_3_registry_data[0] ));



        }
    
    //**************************************************************************
    // 
    // GTFTimingTable Format in vesadata.c (ulong values):
    //
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //
    // Registry Data Format (word values)
    //
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  etc...    
    //  0,
    //
    // ValidModeTable[]  (2 bytes each data item)
    //
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  ..
    //  ..
    //   
    //**************************************************************************

    //**************************************************************************
    // This variable is used to keep track of how many modes
    // are initially specified in the REGISTRY.  These modes will 
    // be trimmed down further according to the amount of video memory on the card.
    // The final number of modes available will be stored in 
    //
    //  hwDeviceExtension->NumAvailableModes;
    //
    //**************************************************************************

    HwDeviceExtension->NumRegistryModes=0;

    //**************************************************************************
    // We allow modes according to the following:
    //
    //    1) What modes are actually available in vesadata.c (in the GTFTimingTable)
    //       We use the GTF table because it's a superset of the DMT table,
    //       in terms of the modes which are supported
    //    2) What modes are specified in the registry
    // 
    //**************************************************************************

    NumGTFModes =  (USHORT)vesaGetNumGTFEntries();

    //**************************************************************************
    // Get ptr to valid mode table (which we build here)
    //**************************************************************************

    ValidModePtr            = &(HwDeviceExtension->ValidModeTable[0]);
    BaseOfValidModeTable    = &(HwDeviceExtension->ValidModeTable[0]);

    //**************************************************************************
    // Build the ValidModeTable.  
    //
    // We allow modes which are:
    //
    //      1) Available in the GTFTimingTable    AND 
    //      2) Specified in the registry
    //
    // The GTF table does NOT specify depths.  The registry data DOES specify bit depths.
    // 
    // NOTE: If for some reason, the mode table was NOT initialized
    //       (ie...the mode table was not found in the registry), we'll
    //       default to ALL modes specified in the GTFTimingTable
    //
    //**************************************************************************

    //**************************************************************************
    // Determine which mode table to use
    //**************************************************************************

    switch (HwDeviceExtension->ulChipID)

        {
        case NV4_DEVICE_NV4_ID:

            RegDataPtr = &NV4_registry_data[0];                                    
            break;

        case NV5_DEVICE_NV5_ID:

            RegDataPtr = &NV5_registry_data[0];                                    
            break;

        case NV0A_DEVICE_NV0A_ID:

            RegDataPtr = &NV0A_registry_data[0];                                    
            break;

        case NV5VANTA_DEVICE_NV5VANTA_ID:

            RegDataPtr = &NVVANTA_registry_data[0];                                    
            break;

        case NV5MODEL64_DEVICE_NV5MODEL64_ID:

            RegDataPtr = &NV5M64_registry_data[0];                                    
            break;

        case NV5ULTRA_DEVICE_NV5ULTRA_ID:

            RegDataPtr = &NV5ULTRA_registry_data[0];                                    
            break;

        case NV10_DEVICE_NV10_ID:

            RegDataPtr = &NV10_registry_data[0];                                    
            break;

        case NV10DDR_DEVICE_NV10DDR_ID:

            RegDataPtr = &NV10DDR_registry_data[0];                                    
            break;

        case NV10GL_DEVICE_NV10GL_ID:

            RegDataPtr = &NV10GL_registry_data[0];                                    
            break;

        case NV11_DEVICE_NV11_ID:

            RegDataPtr = &NV11_registry_data[0];                                    
            break;

        case NV11DDR_DEVICE_NV11DDR_ID:

            RegDataPtr = &NV11DDR_registry_data[0];                                    
            break;

        case NV11M_DEVICE_NV11M_ID:

            RegDataPtr = &NV11M_registry_data[0];                                    
            break;

        case NV11GL_DEVICE_NV11GL_ID:

            RegDataPtr = &NV11GL_registry_data[0];                                    
            break;


        case NV15_DEVICE_NV15_ID:

            RegDataPtr = &NV15_registry_data[0];                                    
            break;

        case NV15DDR_DEVICE_NV15DDR_ID:

            RegDataPtr = &NV15DDR_registry_data[0];                                    
            break;

        case NV15BR_DEVICE_NV15BR_ID:

            RegDataPtr = &NV15BR_registry_data[0];                                    
            break;


        case NV15GL_DEVICE_NV15GL_ID:

            RegDataPtr = &NV15GL_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_ID:

            RegDataPtr = &NV20_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_1_ID:

            RegDataPtr = &NV20_1_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_2_ID:

            RegDataPtr = &NV20_2_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_3_ID:

            RegDataPtr = &NV20_3_registry_data[0];                                    
            break;

        default:

            RegDataPtr = &NV4_registry_data[0];                                    
            break;

        }

    #ifndef ENABLE_COMMON_MODESET_CODE
    //**************************************************************************
    // Check if the registry data was never read in
    // (i.e...the modetable wasn't installed in the registry for some reason)
    //**************************************************************************

    if (*RegDataPtr == 0xffff)
    
        {
        //**********************************************************************
        // Default to allowing ALL MODES specified in the vesa GTF timing table
        //**********************************************************************

        i=0;
        GTFModePtr = &(GTFTimingTable[i][0]);

        //**********************************************************************
        // But first, we need to make sure 640x480 8bpp 60Hz mode is specified first
        // (At some point in time, it seemed that this was a requirement)
        //**********************************************************************

        *ValidModePtr      = TRUE;              // Force first mode to be
        *(ValidModePtr+1)  = 640;               // 640x480x8bpp 60Hz
        *(ValidModePtr+2)  = 480;               //
        *(ValidModePtr+3)  = 8;                 //
        *(ValidModePtr+4)  = 60;                //
        ValidModePtr +=5;                       

        *ValidModePtr      = TRUE;              // Force first mode to be
        *(ValidModePtr+1)  = 640;               // 640x480x8bpp 60Hz
        *(ValidModePtr+2)  = 480;               //
        *(ValidModePtr+3)  = 16;                 //
        *(ValidModePtr+4)  = 60;                //
        ValidModePtr +=5;                       

        *ValidModePtr      = TRUE;              // Force first mode to be
        *(ValidModePtr+1)  = 640;               // 640x480x8bpp 60Hz
        *(ValidModePtr+2)  = 480;               //
        *(ValidModePtr+3)  = 32;                 //
        *(ValidModePtr+4)  = 60;                //
        ValidModePtr +=5;                       

        HwDeviceExtension->NumRegistryModes+=3;
    
        //**********************************************************************
        // Specify all modes from GTF table
        //**********************************************************************

        while ( i < NumGTFModes) 
            {                                                       
            //******************************************************************
            // Get width,height,refresh from GTF table
            //******************************************************************

            GTFWidth = (U016)(*(GTFModePtr));           // Get Width from GTF
            GTFHeight = (U016)(*(GTFModePtr+1));        // Get Height from GTF
            GTFRefresh = (U016)(*(GTFModePtr+2));       // Get Refresh*100
            GTFRefresh /= 100;                          // Normalize the value
                                   
            //******************************************************************
            // Skip the first mode (640x480 8bpp 60hz)
            //
            // Also, NT4 can only handle a max of about 295 modes.
            // So, if the registry mode table was NOT found, then
            // we specify a default list of available modes.
            // (This is the lowest common denominator of modes supported for NV4)
            //******************************************************************

            if (  !((GTFWidth == 640) && (GTFHeight == 480) && (GTFRefresh == 60))  &&
                   (  ((GTFWidth == 640)  &&  (GTFHeight == 480)  && (GTFRefresh >  60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 320)  &&  (GTFHeight == 200)  && (GTFRefresh >  60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 320)  &&  (GTFHeight == 240)  && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 400)  &&  (GTFHeight == 300)  && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 480)  &&  (GTFHeight == 360)  && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 512)  &&  (GTFHeight == 384)  && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 640)  &&  (GTFHeight == 400)  && (GTFRefresh >  60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 800)  &&  (GTFHeight == 600)  && (GTFRefresh >= 60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 1024) &&  (GTFHeight == 768)  && (GTFRefresh >= 60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 1152) &&  (GTFHeight == 864)  && (GTFRefresh >= 60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 1280) &&  (GTFHeight == 1024) && (GTFRefresh >= 60) && (GTFRefresh <= 100))  ||
                      ((GTFWidth == 1600) &&  (GTFHeight == 1200) && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 1920) &&  (GTFHeight == 1080) && (GTFRefresh >= 60) && (GTFRefresh <= 72))   ||
                      ((GTFWidth == 1920) &&  (GTFHeight == 1200) && (GTFRefresh >= 60) && (GTFRefresh <= 60))  )    )
                {
            
                //**************************************************************
                // Generate 8bpp entry for this refresh rate
                //**************************************************************
    
                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = GTFWidth;          // Width
                *(ValidModePtr+2)  = GTFHeight;         // Height
                *(ValidModePtr+3)  = 8;                 // Depth                                                                 
                *(ValidModePtr+4)  = GTFRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode
    
                HwDeviceExtension->NumRegistryModes++;
    
                //**************************************************************
                // Generate 16bpp entry for this refresh rate
                //**************************************************************
    
                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = GTFWidth;          // Width
                *(ValidModePtr+2)  = GTFHeight;         // Height
                *(ValidModePtr+3)  = 16;                // Depth                                                                 
                *(ValidModePtr+4)  = GTFRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode
    
                HwDeviceExtension->NumRegistryModes++;
    
                //**************************************************************
                // Generate 32bpp entry for this refresh rate
                //**************************************************************
    
                RegDepth = 32;
                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = GTFWidth;          // Width
                *(ValidModePtr+2)  = GTFHeight;         // Height
                *(ValidModePtr+3)  = 32;                // Depth                                                                 
                *(ValidModePtr+4)  = GTFRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode
    
                HwDeviceExtension->NumRegistryModes++;
    
    
                //**************************************************************
                // DEBUG safety check
                // Make sure we never go past the end of the
                // allocated valid mode table. (back off 30 words from end of table)
                //**************************************************************
    
                if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2)) )
                    {
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                    }
                }
                
                   
            //******************************************************************
            // Advance to next GTF entry
            // (12 items per each mode entry in the GTF timing table)
            //******************************************************************

            GTFModePtr += 12;
            i++;

            }


        //**********************************************************************
        // Now sort the valid modes...(we'll use a simple bubble sort routine)
        //**********************************************************************

        PModePtr = (PMODE_ENTRY)BaseOfValidModeTable;

        //**********************************************************************
        // Skip the first 640x480 mode, we always want it to be first
        //**********************************************************************

        PModePtr++;                         

        //**********************************************************************
        // Sort the modes from smallest height to largest height
        // Skip the first (640x480 mode), keep it at the beginning.
        //**********************************************************************

        BubbleSort(HwDeviceExtension, PModePtr , HwDeviceExtension->NumRegistryModes - 1);

        

        
        }
    #endif ENABLE_COMMON_MODESET_CODE
        

    //**************************************************************************
    // Parse each line from the registry.
    // For each refresh rate (of each mode), check if the refresh is present in the
    // vesa data table.  If so, then it's a valid mode. 
    // Registry data is terminated with 0xffff
    //**************************************************************************

    while (*RegDataPtr != 0xffff)
        {
        RegDepth   = *(RegDataPtr);             // Get Depth from registry
        RegWidth   = *(RegDataPtr+1);           // Get Width from registry
        RegHeight  = *(RegDataPtr+2);           // Get Height from registry

        //**********************************************************************
        // Advance to the registry refresh rates for this particular mode
        //**********************************************************************

        RegDataPtr+=3;

        //**********************************************************************
        // Each mode entry in the registry data is NULL terminated.
        // Parse all refresh rates for this mode, and see if they're
        // also present in the vesadata GTF timing table
        //**********************************************************************

        while (*RegDataPtr !=0)
            {        
            RegRefresh  = *(RegDataPtr++);      // Get Refresh from registry data

            //******************************************************************
            // Search the vesa GTF table to see if this mode is supported
            //******************************************************************

            i=0;
            GTFModePtr = &(GTFTimingTable[i][0]);
            FoundRefreshFlag = FALSE;              

            while ( (i<NumGTFModes) && (FoundRefreshFlag == FALSE) )
                {                                                       
                //**************************************************************
                // Get width,height,refresh from GTF table
                //**************************************************************

                GTFWidth = (U016)(*(GTFModePtr));           // Get Width from GTF
                GTFHeight = (U016)(*(GTFModePtr+1));        // Get Height from GTF
                GTFRefresh = (U016)(*(GTFModePtr+2));       // Get Refresh*100
                GTFRefresh /= 100;                          // Normalize the value
                                   
                //**************************************************************
                // See if we found a match in the GTF table
                //**************************************************************

                if (MULTIMON_MODE(RegWidth, RegHeight)) 
                    {
                    if (HORIZONTAL_MODE(RegWidth, RegHeight))
                        {
                            widthDivide = 2;
                            heightDivide = 1;
                        }
                    else
                        {
                        if (VERTICAL_MODE(RegWidth, RegHeight))
                            {
                            widthDivide = 1;
                            heightDivide = 2;
                            }
                        }
                    }
                        
#ifndef ENABLE_COMMON_MODESET_CODE
                if ( (GTFWidth == RegWidth/widthDivide) && (GTFHeight == RegHeight/heightDivide) && (GTFRefresh == RegRefresh) &&
                     ((RegDepth == 8) || (RegDepth == 16) || (RegDepth == 32)) )
#endif
            
                    {
                    //**********************************************************
                    // Generate 8bpp entry for this refresh rate
                    //**********************************************************

                    *ValidModePtr      = TRUE;              // Valid Flag
                    *(ValidModePtr+1)  = RegWidth;          // Width
                    *(ValidModePtr+2)  = RegHeight;         // Height
                    *(ValidModePtr+3)  = RegDepth;          // Depth                                                                 
                    *(ValidModePtr+4)  = RegRefresh;        // Refresh                                                               
                    ValidModePtr +=5;                       // Next Valid Mode

                    //**********************************************************
                    // Keep track of how many modes have currently been specified
                    //**********************************************************

                    HwDeviceExtension->NumRegistryModes++;

                    //**********************************************************
                    // DEBUG safety check
                    // Make sure we never go past the end of the
                    // allocated valid mode table. (back off 30 words from end of table)
                    //**********************************************************

                    if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2) ))
                        {
                        VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                        }
                
                    FoundRefreshFlag = TRUE;
                    }
                
                //**************************************************************
                // Advance to next GTF entry
                // (12 items per each mode entry in the GTF timing table)
                //**************************************************************

                GTFModePtr += 12;
                i++;


                } // while (i < NumGTFModes)...
                
            } // while (*RegDataPtr !=0)...


        //**********************************************************************
        // Skip past null terminator
        //**********************************************************************

        RegDataPtr++;
                
        } // while (*RegDataPtr != 0xffff)...

    
    // Print the master mode list for debugging purposes.
    {
        MODE_ENTRY *PModeEntry;
        VideoDebugPrint((7,"buildAvailableModes(): Printing Master Mode List: NumRegstryModes: %d\n", HwDeviceExtension->NumRegistryModes));
        RegDataPtr = &HwDeviceExtension->ValidModeTable[0];
    
         
        for (i=0; i < HwDeviceExtension->NumRegistryModes; i++)
        {
            VideoDebugPrint((7,"%d, (%d, %d), %d bpp, %d HZ\n",
                            *(RegDataPtr + 0),
                            *(RegDataPtr + 1),
                            *(RegDataPtr + 2),
                            *(RegDataPtr + 3),
                            *(RegDataPtr + 4)));
           RegDataPtr += 5;
        }
        VideoDebugPrint((7,"End.................\n"));
    }

#ifdef ENABLE_COMMON_MODESET_CODE
        // Read in the Monitor restriction mode lists for each head.
        ReadMonitorRestrictionModeList (HwDeviceExtension);
#endif

                
    }




//******************************************************************************
//
// Function:   NV_ReadAndCopyRegistryData
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_ReadAndCopyRegistryData(
PHW_DEVICE_EXTENSION HwDeviceExtension,
WCHAR *ModeDataNameStr,
U016 *DstRegDataPtr)

    {
    U016 *SrcRegDataPtr;
    ULONG status;
        
    //**************************************************************************
    // Parse INF and determine which modes to support
    //
    // WARNING:  When reading modetable registry data, the registry callback
    //           routine gets called SEVERAL times for each modetable. That is,
    //           it does NOT get called once for each table as one would expect.
    //           Instead, the registry callback routine gets called for EACH line
    //           appended to the string.  But the CONTEXT ptr does NOT automatically
    //           get incremented.  So we'll have to keep track of it MANUALLY,
    //           so we can continue storing data from where we last left off.
    //           See the registry callback function for more information.
    //**************************************************************************

    HwDeviceExtension->RegistryDataOffset = 0;

    //**************************************************************************
    // The NVx_MODES modetable entries for each chip type will always be stored 
    // in the \device0 key, since the INF doesn't appear to be able to store them
    // in device1,device2, etc...   As a result, we always store and get modetable
    // registry data from the \device0 key for ALL chip types, and then save them
    // off in global mode tables. Essentially, all modetable registry data will
    // only be read when the FIRST nv device is found.   
    //    
    // That is, VideoPortGetRegistryParameters() will SUCCEED when reading the
    // mode table value entries from \device0, but will FAIL when it tries 
    // to read them from \device1\2\3...because the modetable entries won't be present!
    //
    // We use global modedata tables, so that we can copy modetable data
    // into the hwdeviceextension of each device found.
    //
    // The following is a simplified explanation:
    //
    // 1) hkey_local_machine\system\currentcontrolset\services\nv4\device0\
    //      
    //       nv4_modes      -> This value entry contains mode data for nv4
    //       nv5_modes      -> This value entry contains mode data for nv5
    //       nv5m64_modes   -> This value entry contains mode data for nv5m64
    //       nvvanta_modes  -> This value entry contains mode data for nvvanta
    //       etc...
    //
    // 2) When nvx\device0 is found, all the mode data will be read from the
    //    registry into the global mode data tables:
    //
    //       NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       etc....
    //
    // 3) For each device, the mode data for the corresponding chip
    //    type is copied into the ValidModeData in the device's
    //    hwDeviceExtension->ValidModeTable[]
    //  
    //**************************************************************************

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       ModeDataNameStr,
                                       FALSE,
                                       NVRegistryCallback,
                                       &registry_data[0]);

    if (status == NO_ERROR)
        {
        //**********************************************************************
        // Terminate the temporary registry data buffer with 0xffff !
        //**********************************************************************

        registry_data[HwDeviceExtension->RegistryDataOffset / 2] = 0xffff;

        //**********************************************************************
        // Now copy the registry data per specific chip type
        //**********************************************************************
        
        SrcRegDataPtr= &(registry_data[0]);
        
        while (*SrcRegDataPtr != 0xffff)
            {
            *DstRegDataPtr = *SrcRegDataPtr;// Copy the data
            
            DstRegDataPtr++;
            SrcRegDataPtr++;            
            }
    
        *DstRegDataPtr = 0xffff;           // Null terminate the list

        }
    else
        {
        //**********************************************************************
        // Error Case (when VideoPortGetRegistryParameters fails because
        // the ValueEntry for the mode data is NOT present)
        //
        // The NVx_MODES keys are only located in the \device0 key.
        // That is, ALL the registry mode data tables are copied when the FIRST
        // device is installed.  When additional instances of the adapter
        // are found, we don't no need to do anything since we've already
        // copied the data.
        //**********************************************************************
        
        }


    }
                                




//******************************************************************************
//
// Function:   BubbleSort
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID BubbleSort(
PHW_DEVICE_EXTENSION HwDeviceExtension,
PMODE_ENTRY BaseModePtr,
ULONG NumModes)

    {

    ULONG i,j;
    PMODE_ENTRY LeftModePtr, RightModePtr;
    MODE_ENTRY TempMode;


    //**************************************************************************
    // Sort by height
    //**************************************************************************

    for (i=0; i < NumModes; i++)
        {
        for (j=NumModes-1; j > i; j--)
            {
            LeftModePtr  = &BaseModePtr[j-1];
            RightModePtr = &BaseModePtr[j];                

            if (LeftModePtr->Height > RightModePtr->Height)
                {
                //**************************************************************
                // Swap mode entries, smaller modes first
                //**************************************************************
                
                TempMode = (*LeftModePtr);
                (*LeftModePtr)  = (*RightModePtr);
                (*RightModePtr) = TempMode;
                
                }

            }
            
        }


    //**************************************************************************
    // Sort by depth
    //**************************************************************************

    for (i=0; i < NumModes; i++)
        {
        for (j=NumModes-1; j > i; j--)
            {
            LeftModePtr  = &BaseModePtr[j-1];
            RightModePtr = &BaseModePtr[j];                

            if (LeftModePtr->Depth > RightModePtr->Depth)
                {
                //**************************************************************
                // Swap mode entries, smaller depths first
                //**************************************************************
                
                TempMode = (*LeftModePtr);
                (*LeftModePtr)  = (*RightModePtr);
                (*RightModePtr) = TempMode;
                
                }

            }
            
        }
        
        
        
    }
    

//******************************************************************************
//
// Function:   NV_OEMEnableExtensions
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    U008 lock;

    //**************************************************************************
    // For NV4, registers are locked using the NV_CIO_SR_LOCK register
    // (That is,the locking mechanism has been moved to CRTC register space,
    // where it should have been in the first place).  We need to
    // use the NV4_REF header file, so this function is locatedin NV4.C
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);


    }


//******************************************************************************
//
// Function:   NV4 OEMDisableExtensions
//
// Routine Description:
//
//    Lock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_OEMDisableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    U008 lock;

    //**************************************************************************
    // For NV4, registers are locked using the NV_CIO_SR_LOCK register
    // (That is,the locking mechanism has been moved to CRTC register space,
    // where it should have been in the first place).  We need to
    // use the NV4_REF header file, so this function is locatedin NV4.C
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);

    }


//******************************************************************************
//
// Function:   NV4_OEMSetRegs
//
// Routine Description:
//
//       OEMSetRegs - Set extended registers (standard VGA has been set)
//
//       Entry:  ES:DI = Standard VGA parameter pointer
//               DS = Seg0
//       Exit:   None
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_OEMSetRegs(MODEDESC *mi)
{
    U016  wv;                     // Write value{
    U016  i, c;
    U032   lwv;
    U032   lrv;
    U008   cv;

    //*************************************************************************
    // NV4 version of this function is slightly different than
    // the NV3 version. (565 mode and TV stuff)
    //*************************************************************************

    if (mi->mdCMode != 0xFF)        // Do we have a CRTC Override Table?
    {
        // Yep - program it
        WritePriv08(NV_PRMVIO_MISC__WRITE, crt_override[mi->mdCMode].CO_Misc);

        wv = crt_override[mi->mdCMode].CO_ClockMode;
        wv <<= 8;
        wv |= 0x01;
        WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01

        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);    // Read CR11
        wv &= 0x7FFF;               // Unlock CR0-7
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR11

        // Do CR0-CR8 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, 8, (U008 *)&(crt_override[mi->mdCMode].HTotal));

        wv = crt_override[mi->mdCMode].CO_CellHeight;
        wv <<= 8;
        wv |= 0x09;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR09

        // Do CR10-CR12 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x10, 0x03, (U008 *)&(crt_override[mi->mdCMode].CO_VSyncStart));

        // Do CR15-CR16 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x15, 0x02, (U008 *)&(crt_override[mi->mdCMode].CO_VBlankStart));
    }

    // Program Extended Registers

    wv = eregs[mi->mdEMode].xrOffset;
    wv <<= 13;
    wv &= 0xE000;                   // Clear start address bits
    wv |= 0x19;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR19

    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    wv &= 0xC0FF;                   // Preserve sync disables
    wv |= 0x3800;                   // Set reserved bits and text mode

    c = (eregs[mi->mdEMode].xrFlags);

    if (c & 0x01)
        wv |= 0x0100;               // Set address wrap

    i = (eregs[mi->mdEMode].xrVOver);
    i &= 0x20;
    i >>= 0x03;
    wv |= (i << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A

    // Default Fifo
    wv = 0x011B;                    // Default CR1B value for VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A

    wv = c;
    wv &= 0x06;
    wv <<= 8;
    wv |= 0x1C;                     // CR1C

    i = (eregs[mi->mdEMode].xrPixFmt);
    i &= 0x30;                      // Mask off chain-4 optimize bits
    i >>= 1;            // (shr 4-3?)

    wv |= (i << 8);                 // Set chain 4 optimize bits
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A


    wv = 0x001D;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1D

    wv = 0x001E;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1E

    wv = 0x1020;                    // Fifo Setting for Standar VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set low water mark at CR20

    c = (eregs[mi->mdEMode].xrVOver); // Vertical Overflow
    c &= 0x1F;                      // Mask our bits

    i = (eregs[mi->mdEMode].xrOffset);
    i &= 0x08;                      // Bit 3
    i <<= 2;                        // Move to bit 5
    c |= i;
    wv =  (c << 8) | 0x25;          // Write data to CR25
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR25


    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv &= 0xF8FF;                   // Preserve sync disables

    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0x07;                      // Set bits [2:0] - clear rest
    wv |= (c << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR28

    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0xC0;
    c >>= 6;

    i = eregs[mi->mdEMode].xrVOver;
    i &= 0xC0;
    i >>= 4;
    c |= i;
    wv = ((c << 8) | 0x2D);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR2D

    wv = 0x29;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
    wv = 0x2A;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);


    //**************************************************************************
    // Don't touch CR33 if we're on a flat panel
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

        // Do CR29-32
        for (i = 0x30; i <= 0x32; i++)
            {
            wv = (U016)i;
            WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
            }

        }

    else

        {


        // Do CR29-33
        for (i = 0x30; i <= 0x33; i++)
            {
            wv = (U016)i;
            WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
            }

        }


    wv = (((eregs[mi->mdEMode].xrIntlace) << 8) | 0x39);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

    //**************************************************************************
    // Don't set clock if we're on a flat panel
    //**************************************************************************

    //OEMSetClock(eregs[mi->mdEMode].xrClkSel);
    if (HwDeviceExtension->FlatPanelIsPresent != TRUE)
        OEMSetClock(tblClockFreq[eregs[mi->mdEMode].xrClkSel]);

    wv = (((eregs[mi->mdEMode].xrVOffset) << 8) | 0x13);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

    //**************************************************************************
    // No TV support yet for NV class chips
    //**************************************************************************

//    if (isTV())

    if (HwDeviceExtension->TvIsPresent)

        {
            NV4_ProgramTV( mi->mdTVMode );
        }

#if 0
    //
    // Set VCLK divide by 2 setting
    //
    wv = (eregs[mi->mdEMode].xrPixFmt);
    lwv = (U032)(wv & 0x08);

    lwv <<= (DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO) - 3);

    // Read current coefficient
    //
    // Note that this code preserves the VPLL_BYBASS bit which is nessesary for TV
    lrv = ReadPriv32(NV_PRAMDAC_PLL_COEFF_SELECT);

    // Mask off the bits we'll use.
    //
    // NOTE: Careful: the BIT definitions have CHANGED from NV3 to NV4 !!!!
    //
    lrv &= (U032)(((U032)(1L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO)) |
           ((U032)(1L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE))) |
           ((U032)(7L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE)))) ^ -1L);

    lrv |= lwv;         // Set the VCLK Ratio

    // Now we have to set to programmed VPLL based on XTAL
    //
    // NOTE: Careful: the BIT definitions have CHANGED from NV3 to NV4 !!!!
    //
    lrv |= (U032)(2L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE));

    WritePriv32(lrv, NV_PRAMDAC_PLL_COEFF_SELECT);
#endif


    //**************************************************************************
    // If flat panel, we may need to adjust CRTC's
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)

        FlatPanelCrtc(mi->mdXRes);

    else

        WritePriv32(0x10000700, NV_PRAMDAC_PLL_COEFF_SELECT);

    //**************************************************************************
    // If flat panel, leave DAC alone
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent != TRUE)

        {

        lrv = ReadPriv32(NV_PRAMDAC_GENERAL_CONTROL);

        lrv &= (U032)(((1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE)) |
                 (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE)) |
                 (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC))) ^ -1L);

        lrv |= (U032)(1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE));

        wv = (eregs[mi->mdEMode].xrOffset);
        lwv = (U032)(wv & 0x80);       // Set 565 Mode

        lwv <<= (DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE) - 7L);

        lrv |= lwv;

        cv = (eregs[mi->mdEMode].xrFlags);
        cv ^= (U008)-1;
        cv &= 0x08;                 // Isolate DAC width

        lwv = (U032)(cv);          // Dac Width
        lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC) - 3L);

        lrv |= lwv;

        cv = (eregs[mi->mdEMode].xrPixFmt);
        cv ^= (U008)-1;                   // Invert
        cv &= 0x02;                 // Isolate index/gamma bit

        lwv = (U032)(cv);

        //KJK lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE) - 1L);
        lrv |= lwv;

        WritePriv32(lrv, NV_PRAMDAC_GENERAL_CONTROL);

        // Disable tiling
        lrv = ReadPriv32(NV_PFB_CONFIG_0);
        lrv &= (U032)((1L << DRF_SHIFT(NV_PFB_CONFIG_0_TILING)) ^ -1L);
        lrv |= (NV_PFB_CONFIG_0_TILING_DISABLED << DRF_SHIFT(NV_PFB_CONFIG_0_TILING));

        //**********************************************************************
        // Do NOT touch this register for NV10 !!
        //**********************************************************************

        if ( !((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
               (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
               (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
               (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
               (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
               (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID)))

            {
               WritePriv32(lrv, NV_PFB_CONFIG_0);
            }
            

        }


    WritePriv08(NV_PRMCIO_CRX__COLOR, 0x18);    // Select CR18 (why?)


}



//******************************************************************************
//
// Function:   NV4_ProgramTV
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_ProgramTV(U008 tvmode)

    {
    // TODO:
    }


//******************************************************************************
//
// Function:   NVGetMonitorType
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVGetMonitorType(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG result;
    PHWINFO NVInfo;
    NV_CFGEX_GET_EDID_PARAMS EdidParams;
    ULONG EdidBufferSize;
    
        
    //**************************************************************************
    // Get ptr to NVInfo structure 
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    
    //**************************************************************************
    // Ask the RM what's attached to the card (Flat Panel/Monitor/ or TV)
    //**************************************************************************

    HwDeviceExtension->TvIsPresent              = FALSE;
    HwDeviceExtension->FlatPanelIsPresent       = FALSE; 

    //**************************************************************************
    // By default, a standard VGA monitor is attached.
    // Check if either a Flat Panel or TV is attached
    //**************************************************************************

    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_MONITOR_TYPE ,&result) ;

    if (result == MONITOR_TYPE_FLAT_PANEL)
        {
        HwDeviceExtension->FlatPanelIsPresent   = TRUE;

        //**********************************************************************
        // Get max resolution supported by this display type
        //**********************************************************************

        RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_SCREEN_MAX_WIDTH ,&HwDeviceExtension->MaxFlatPanelWidth) ;

        RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_SCREEN_MAX_HEIGHT ,&HwDeviceExtension->MaxFlatPanelHeight) ;

        }

    // GK: HACKHACK: Temporary. Once we verify the EDID info per head, we don't need any of this MaxFlatPanelWidth stuff.
    if (HwDeviceExtension->MaxFlatPanelWidth == 0)
    {
        HwDeviceExtension->MaxFlatPanelWidth = 1024;
    }
    if (HwDeviceExtension->MaxFlatPanelHeight == 0)
    {
        HwDeviceExtension->MaxFlatPanelHeight = 768;
    }


    if ((result == MONITOR_TYPE_NTSC) || (result == MONITOR_TYPE_PAL))
        HwDeviceExtension->TvIsPresent          = TRUE;

    //**************************************************************************
    // This TV code used to work on NV3.. Need to test on NV4 or better...
    //**************************************************************************

   if (HwDeviceExtension->TvIsPresent)                // NO TV support yet !
       {
       // don't diff between NTSC & PAL for now
       NVInfo->Framebuffer.MonitorType = NV_MONITOR_NTSC;

       // Preset the default values
       NVInfo->Framebuffer.Underscan_x = DST_X_RES;
       NVInfo->Framebuffer.Scale_x = X_RES << 20;
       NVInfo->Framebuffer.Scale_x /= NVInfo->Framebuffer.Underscan_x;

       NVInfo->Framebuffer.Underscan_y = DST_Y_RES;
       NVInfo->Framebuffer.Scale_y = Y_RES << 20;
       NVInfo->Framebuffer.Scale_y /= NVInfo->Framebuffer.Underscan_y;

       // No filtering needed for NV5 or better
       NVInfo->Framebuffer.FilterEnable = 0;
       }
    else
       {
       NVInfo->Framebuffer.MonitorType = NV_MONITOR_VGA;

       // If filtering gets enabled for VGA, assume 1:1 scaling
       NVInfo->Framebuffer.Underscan_x = X_RES;
       NVInfo->Framebuffer.Scale_x = (1 << 20);        // default to 1:1

       NVInfo->Framebuffer.Underscan_y = Y_RES;
       NVInfo->Framebuffer.Scale_y = (1 << 20);

       // Assume filtering is disabled
       NVInfo->Framebuffer.FilterEnable = 0;
       }



    }

//******************************************************************************
//
// Function:   NV_FixLowWaterMark
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_FixLowWaterMark(U016 clock)

    {
    U016  wv;
    U032   lwv;
    U016  i;
    U032  clockMHz;

    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv >>= 8;
    wv &= 0x03;       // mask pixel format bits

    // Check dac format
    if (wv)
        {
        wv--;
        clockMHz = clock;
        clockMHz <<= (U008)wv;
        clockMHz /= 100;

        for (i = 0; clockMHz > DACFifoTable[i].Freq ; i++)
            ;   // Find the proper FIFO value
        
        if  ( (HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
              (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
              (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
              (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
              (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
              (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        
            {
            // for NV10, bit 4 is the 128-bit bit.
            lwv = ReadPriv32(NV_PFB_CFG) & 0x00000010L;
            }
        else
            {
            // Bit 2 is the 128-bit bit.
            lwv = ReadPriv32(NV_PFB_BOOT_0) & 0x00000004L;
            }

        if (lwv)
            {
            // 128 bit
            // Do WV first, as I get's blown away
            wv = ((DACFifoTable[i].LowWaterMark128) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize128) << 8) | 0x1B;

            }
        else
            {
            // 64 bit
            wv = ((DACFifoTable[i].LowWaterMark64) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize64) << 8) | 0x1B;
            }

        WriteIndexed(NV_PRMCIO_CRX__COLOR, i);
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
        }
    }





//******************************************************************************
//
// Function:   NV_OEMGetMemSize
//
// Routine Description:
//
//
//       OEMGetMemSize - Return the pre-calculated memory size
//
//       Entry:  None
//       Exit:   AX = Number of 64K blocks
//
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

U016 NV_OEMGetMemSize(VOID)
{
    U032 msize;
    U016 ms;


    if  ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
         (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
         (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
         (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
         (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
         (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
    {
        ms = (U016)(PFB_REG_RD32(PFB_Base,NV_PFB_CSTATUS) >> 16);
    }
    else
    {
        //*************************************************************************
        // NV4 version of this function is slightly different than
        // the NV3 version. (We want to use #DEFINES from NV4_REF for NV4,
        // and #DEFINES from NV3_REF for NV3)
        //*************************************************************************

        msize = ReadPriv32(NV_PFB_BOOT_0) & 0x00000003;
        ms = (U016)msize;

        if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_4MB)
            ms = 64;            // 4MB
        else if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_8MB)
            ms = 128;           // 8MB
        else if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_16MB)
            ms = 256;           // 16MB
        else
            ms = 512;           // 32Mb

        //**************************************************************************
        // Check for UMA usage
        //
        // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
        // bit fields to zero.
        //**************************************************************************

        if (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
        {
            switch (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA_SIZE))
            {
                case NV_PFB_BOOT_0_UMA_SIZE_2M:
                    ms = 2 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_4M:
                    ms = 4 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_6M:
                    ms = 6 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_8M:
                    ms = 8 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_10M:
                    ms = 10 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_12M:
                    ms = 12 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_14M:
                    ms = 14 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_16M:
                    ms = 16 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_18M:
                    ms = 18 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_20M:
                    ms = 20 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_22M:
                    ms = 22 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_24M:
                    ms = 24 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_26M:
                    ms = 26 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_28M:
                    ms = 28 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_30M:
                    ms = 30 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_32M:
                    ms = 32 << 4;
                    break;
            }
        }
    }

    return ms;

}




//******************************************************************************
//
// Function:   NV4_dacCalculateArbitration
//
// Routine Description:
//
//      Calculate the closest arbitration values for a given system configuration
//
//      NOTE: Please excuse this code.  In comes from the hardware group...
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4_dacCalculateArbitration
(
           nv4_fifo_info *fifo,
           nv4_sim_state  *arb
)
{
  int data, m,n,p, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int found, mclk_extra, mclk_loop, cbs, m1, p1;
  int xtal_freq, mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
  int craw, vraw;
  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width >> 6;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 0;
  cbs = 128;
  pclks = 2; // lwm detect.

  nvclks = 2; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)
  nvclks += 1; // fbi reqsync

  mclks = 5; // Fifo
  mclks += 3; // MA0 -> MA2
  mclks += 1; // pad->out
  mclks += cas; // Cas Latency.
  mclks += 1; // pad in
  mclks += 1; // latch data
  mclks += 1; // fifo load
  mclks += 1; // fifo write
  mclk_extra = 3; // Margin of error

  nvclks += 2; // fifo sync
  nvclks += 1; // read data
  nvclks += 1; // fbi_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
    if(video_enable) {
      video_drain_rate = pclk_freq * 2; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 2; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
      else
    video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;

      us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

      vlwm = us_video * video_drain_rate/(1000*1000);
      vlwm++; // fixed point <= float_point - 1.  Fixes that
      vbs = 128;

      if(vlwm > 128) vbs = 64;
      if(vlwm > (256-64)) vbs = 32;

      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
      else
    video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
    us_video  // Wait for video
    +video_fill_us // Wait for video to fill up
    +cpm_us // CRT Page miss
    +us_m + us_n +us_p // other latency
    ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 2; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    }
    /*
      Overfill check:

      */

    m1 = clwm + cbs - 512; /* Amount of overfill */
    p1 = m1 * pclk_freq / mclk_freq; /* pclk cycles to drain */
    p1 = p1 * bpp / 8; // bytes drained.

    if((p1 < m1) && (m1 > 0)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
    }
    else if(video_enable){
      if((clwm > 511) || (vlwm > 255)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    } else {
      if(clwm > 519){ // Have some margin
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    }
    craw = clwm;
    vraw = vlwm;
    if(clwm < 384) clwm = 384;
    if(vlwm < 128) vlwm = 128;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->graphics_lwm = data;   fifo->graphics_burst_size = 128;
    //    fifo->craw = craw;

    data = (int)((vlwm+15));
    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = data;  fifo->video_burst_size = vbs;
  }
}



//******************************************************************************
//
// Function:   NV4_UpdateArbitrationSettings
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_UpdateArbitrationSettings
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{

    nv4_fifo_info fifo_data;
    nv4_sim_state sim_data;
    U008 i, lock;
    U032 M, N, O, P , crystal , NVClk, VClk;

    //
    // Determine current strap crystal frequency (in Hz)
    //
    if (PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
        crystal = 13500000;
    else if (PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
        crystal = 14318180;



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _PDIV);
    O = 1;

    HwDeviceExtension->NvInfo.Dac.MPllM = M;
    HwDeviceExtension->NvInfo.Dac.MPllN = N;
    HwDeviceExtension->NvInfo.Dac.MPllO = O;
    HwDeviceExtension->NvInfo.Dac.MPllP = P;
    if ( (!P) && (HwDeviceExtension->ulChipID == NV4_DEVICE_NV4_ID))
        P = 1;      // never really zero
    HwDeviceExtension->NvInfo.Dac.MClk  = (N * crystal / (1 << P) / M);



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;

    HwDeviceExtension->NvInfo.Dac.VPllM = M;
    HwDeviceExtension->NvInfo.Dac.VPllN = N;
    HwDeviceExtension->NvInfo.Dac.VPllO = O;
    HwDeviceExtension->NvInfo.Dac.VPllP = P;
    VClk = HwDeviceExtension->NvInfo.Dac.VClk  = (N * crystal / (1 << P) / M);



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _PDIV);
    O = 1;

    NVClk  = (N * crystal / (1 << P) / M);

    //
    // Last minute kludge to work around bug in NV4 arbitration
    // algorithm.
    //

    if (((HwDeviceExtension->NvInfo.Framebuffer.Depth < 16) && (VClk > 180000000)) ||
        ((HwDeviceExtension->NvInfo.Framebuffer.Depth == 16) && (VClk > 130000000)) ||
        ((HwDeviceExtension->NvInfo.Framebuffer.Depth > 16) && (VClk > 80000000)))
       HwDeviceExtension->bHwVidOvl = FALSE;
    else
        {
        //
        // Build the sim table as if hw video overlay was enabled
        //
        sim_data.pix_bpp        = (UCHAR)HwDeviceExtension->NvInfo.Framebuffer.Depth;
        sim_data.enable_video   = 1;
        sim_data.enable_mp      = 0;
        sim_data.memory_width   = HwDeviceExtension->NvInfo.Dac.InputWidth;;
        sim_data.mem_latency    = 3;
        sim_data.mem_aligned    = 1;
        sim_data.mem_page_miss  = 10;
        sim_data.gr_during_vid  = 0;
        sim_data.pclk_khz       = HwDeviceExtension->NvInfo.Dac.VClk / 1000;    // in kHz, not MHz
        sim_data.mclk_khz       = HwDeviceExtension->NvInfo.Dac.MClk / 1000;    // in kHz, not MHz
        sim_data.nvclk_khz      = NVClk / 1000;                                 // in kHz, not MHz

        //
        // Get those new numbers
        //
        NV4_dacCalculateArbitration(&fifo_data, &sim_data);
        HwDeviceExtension->bHwVidOvl = (fifo_data.valid != 0);
        }

    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (UCHAR)HwDeviceExtension->NvInfo.Framebuffer.Depth;
    sim_data.enable_video   = 0;
    sim_data.enable_mp      = 0;
    sim_data.memory_width   = HwDeviceExtension->NvInfo.Dac.InputWidth;;
    sim_data.mem_latency    = (char)PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _CAS_LATENCY); // 3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char)(PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _RAS_RAS)  +  PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _READ_TO_PCHG)); // 10
    sim_data.gr_during_vid  = 0;
    sim_data.pclk_khz       = HwDeviceExtension->NvInfo.Dac.VClk / 1000;    // in kHz, not MHz
    sim_data.mclk_khz       = HwDeviceExtension->NvInfo.Dac.MClk / 1000;    // in kHz, not MHz
    sim_data.nvclk_khz      = NVClk / 1000;                                 // in kHz, not MHz


    //
    // Get those new numbers
    //
    NV4_dacCalculateArbitration(&fifo_data, &sim_data);

    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size
        //
        PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
        switch (fifo_data.video_burst_size)
        {
            case 128:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 3);
                break;

            case 64:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 2);
                break;

            case 32:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 1);
                break;
        }


        //
        // Update the CRTC watermarks
        //
        // Unlock CRTC extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);

        //
        // Set the CRTC watermarks and burst size
        //
        CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.graphics_lwm >> 3);

        switch (fifo_data.graphics_burst_size)
        {
            case 256:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 4);
                break;

            case 128:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 3);
                break;

            case 64:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 2);
                break;

            case 32:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 1);
                break;

            case 16:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 0);
                break;
        }

        //
        // Relock if necessary
        //
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE);

        return;
    }
    else
        //
        // No valid setting was found!!!  Either we fail this configuration
        // or we live with the current default settings for this mode.
        //
        return;

}


//******************************************************************************
//
// Function:    NVEnableBusMastering()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVEnableBusMastering(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;

    //**************************************************************************
    // Make sure bus mastering is always ENABLED !!  (Bit 2)
    // Read current value then enable the bus_master bit.
    //**************************************************************************

    CurrentValue = REG_RD32(NV_PBUS_PCI_NV_1);
    CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_PCI_NV_1_BUS_MASTER));
    REG_WR32(NV_PBUS_PCI_NV_1,  CurrentValue);

    }

//******************************************************************************
//
// Function:    NVSaveSpecificRegistersForPwrMgmt()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;

    //**************************************************************************
    // This code was copied from ..\nvalloc\win9x\vxd\osapi.c 
    // for the case NVRM_API_POWER_DOWN:
    //**************************************************************************

    //**************************************************************************
    // Save off instance memory, mainly because the Win9x DX7 driver
    // allocates DMA contexts, but doesn't free them up. (One time init)
    // If we lose power , then all instance memory associated with those
    // DMA contexts are gone.  So we need to save instance mem here before we power down.
    //**************************************************************************
    NV4SaveInstanceMemory(HwDeviceExtension);

    //**************************************************************************
    // Save off miscellaneous registers not reloaded by RmLoadState
    //**************************************************************************

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        {
        NV10ChipFBPowerSave(HwDeviceExtension);
        }
                
    else

        {
        NV4ChipFBPowerSave(HwDeviceExtension);
        }

    }


//******************************************************************************
//
// Function:    NVRestoreSpecificRegistersForPwrMgmt()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;


    //**************************************************************************
    // Restore chip dependent FB power registers
    //**************************************************************************

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        {
        NV10ChipFBPowerRestore(HwDeviceExtension);
        }

    else
                    
        {
        NV4ChipFBPowerRestore(HwDeviceExtension);
        }


    //**************************************************************************
    // Save off instance memory, mainly because Win9x DX7 driver
    // allocates DMA contexts, but doesn't free them up.
    // If we lose power , then all instance memory associated with those
    // DMA contexts are gone.  So we need to save them here before we power down.
    //**************************************************************************
    NV4RestoreInstanceMemory(HwDeviceExtension);

    }


//******************************************************************************
//
// Function:    NV4ChipFBPowerSave()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4ChipFBPowerSave (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    // power down mode - max out memory refresh value
    HwDeviceExtension->Power_refresh = REG_RD32(NV_PFB_DEBUG_0);               // refresh
    FLD_WR_DRF_NUM(_PFB, _DEBUG_0, _REFRESH_COUNTX64, 0x01);       // max refresh
    // Chip has been init'd with the BIOS init tables, unless the BIOS
    // has an incompatible structure and the table was not found, in which case
    // we used a default table, which may not have the correct RAM config, so
    // we save away the current config for restoration above.
    HwDeviceExtension->Power_PfbBoot0     = REG_RD32(NV_PFB_BOOT_0);               // RAM config
    HwDeviceExtension->Power_PfbConfig0   = REG_RD32(NV_PFB_CONFIG_0);           // RAM config
    HwDeviceExtension->Power_PfbConfig1   = REG_RD32(NV_PFB_CONFIG_1);           // RAM config
    HwDeviceExtension->Power_PextdevBoot0 = REG_RD32(NV_PEXTDEV_BOOT_0);       // READ STRAP REG
    HwDeviceExtension->Power_PfifoRamHT   = REG_RD32(NV_PFIFO_RAMHT);
    HwDeviceExtension->Power_PfifoRamRO   = REG_RD32(NV_PFIFO_RAMRO);
    HwDeviceExtension->Power_PfifoRamFC   = REG_RD32(NV_PFIFO_RAMFC);
    }
    
 
//******************************************************************************
//
// Function:    NV4ChipFBPowerRestore()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4ChipFBPowerRestore (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    // power up mode - restore previous refresh value
    U032 D0_DELAY_RETRIES = 10; 
    U032 retry = 0;             
    U032 i;                     

    REG_WR32(NV_PFB_DEBUG_0, HwDeviceExtension->Power_refresh);          // refresh
    REG_WR32(NV_PFB_BOOT_0,  HwDeviceExtension->Power_PfbBoot0);         // RAM config
    REG_WR32(NV_PFB_CONFIG_0, HwDeviceExtension->Power_PfbConfig0);      // RAM config
    REG_WR32(NV_PFB_CONFIG_1, HwDeviceExtension->Power_PfbConfig1);      // RAM config

//  A delay seems to be necessary for i820 on Win9x.
//  The problem hasn't been demonstrated on W2K, but its here for safety
//  Reading NV_PMC_ENABLE is simply a convenient delay    
    while (REG_RD32(NV_PEXTDEV_BOOT_0) != HwDeviceExtension->Power_PextdevBoot0) 
    {
        for (i=0; i<2000; i++) 
        {
            REG_RD32(NV_PMC_ENABLE);
        }
        REG_WR32(NV_PEXTDEV_BOOT_0, HwDeviceExtension->Power_PextdevBoot0);    // WRITE STRAP REG
        retry++;
        if (retry == D0_DELAY_RETRIES) 
            break;
    }

    REG_WR32(NV_PFIFO_RAMHT, HwDeviceExtension->Power_PfifoRamHT);      
    REG_WR32(NV_PFIFO_RAMRO, HwDeviceExtension->Power_PfifoRamRO);      
    REG_WR32(NV_PFIFO_RAMFC, HwDeviceExtension->Power_PfifoRamFC);      

    // Touching the CONFIG_0 register messes up the VGA text screen.
    // Unfortunately, SetMode doesn't occur for a while, so this garbage text screen
    // may linger for a while,  so we'll blank the screen to hide it.
    // (SetMode will turn it back on)
    
    REG_RD32(NV_PRMCIO_INP0__COLOR);  // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);    // Turn off screen at AR
    REG_RD32(NV_PRMCIO_INP0__COLOR);  // Reset ATC FlipFlop
    }
    

//******************************************************************************
//
// Function:    NV4SaveInstanceMemory()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4SaveInstanceMemory(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 *fb_sv;
    U032 i;
                
    fb_sv = (U032 *)&(HwDeviceExtension->SavedInstanceMemory[0]);
    
    for(i=0; i < ((HwDeviceExtension->TotalInstanceMemory)/4); i++)
         *fb_sv++ = REG_RD32(NV_PRAMIN_DATA032(i));   // from the top--64k BIOS + instance memory
                                                      // this actually decrements from the top
    }

//******************************************************************************
//
// Function:    NV4RestoreInstanceMemory()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4RestoreInstanceMemory(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 *fb_sv;
    U032 data;
    U032 i;
                    
    fb_sv = (U032 *)&(HwDeviceExtension->SavedInstanceMemory[0]);
    
    for(i=0; i < ((HwDeviceExtension->TotalInstanceMemory)/4); i++)
       {
       data = *fb_sv++;
       REG_WR32(NV_PRAMIN_DATA032(i), data);
       }            

    }


//******************************************************************************
//
// Function:    NVEnableVGASubsystem()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVEnableVGASubsystem(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {


    //**************************************************************************
    // Make sure VGA IO subsystem is alive !!!
    //**************************************************************************

    REG_WR08(NV_PRMVIO_VSE2,  1);


    }

//******************************************************************************
//
// Function:    NVClearMutexPmeAudBuff0()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVClearMutexPmeAudBuff0(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    // Do nothing, this function is only used by NV3
    }


//******************************************************************************
//
// Function:    NVExtractBiosImage()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVExtractBiosImage(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR *buffer;
    UCHAR char1,char2;
    U032 CurrentValue;
    U032 i;
    
    //**************************************************************************
    // Get ptr to buffer where we'll store the bios image
    //**************************************************************************

    buffer = (UCHAR *)(&(HwDeviceExtension->SavedBiosImageArray[0]));

    char1 = REG_RD08(DEVICE_BASE(NV_PROM) + 0);
    char2 = REG_RD08(DEVICE_BASE(NV_PROM) + 1);

    //**************************************************************************
    // First attempt to get the BIOS image from PROM
    // (Look for the 55,AA signature)
    //**************************************************************************
    
    if ((char1 == 0x55) && (char2 == 0xAA))
    {
        //**********************************************************************
        // Read BIOS image via PROM
        //**********************************************************************
        for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
        {
            buffer[i] = REG_RD08(DEVICE_BASE(NV_PROM) + i);
        }
    }
    else
    {
#if 0
#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
        UCHAR *pVideoRomData;
        pVideoRomData = VideoPortGetRomImage(HwDeviceExtension, NULL, 0, SAVED_BIOS_IMAGE_SIZE);

        if(pVideoRomData != NULL)
        {
            char1 = pVideoRomData[0];
            char2 = pVideoRomData[1];
        }

        if ((char1 == 0x55) && (char2 == 0xAA))
        {
            for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
            {
                buffer[i] = pVideoRomData[i];
            }
        }
        else
#endif // WINN32_WINNT >= 0x0500 NT5 only
#endif
        {
            //**********************************************************************
            // Otherwise, get BIOS image from PRAMIN
            //**********************************************************************

            for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
            {
                buffer[i] = REG_RD08(DEVICE_BASE(NV_PRAMIN) + i);
            }
        }
    }            
}

//******************************************************************************
//
// Function:    FlatPanelCrtc
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

// some CRTC bit definitions
// CR07
#define VT08    1
#define VT09    0x20
#define VRS08   0x04
#define VRS09   0x80
#define EXT_VRS 0x84
#define VDE08   0x02
#define VDE09   0x40
#define VBS08   0x08
// CR09
#define VBS09   0x20
// CR25
#define VT10    0x01
#define VDE10   0x02
#define VRS10   0x04
#define VBS10   0x08

VOID FlatPanelCrtc( U016 XRes )
{
U032    DacHcrtc, DacHt, Ht, Hrs, Hre, DacVcrtc, DacVt, Vt, Vrs, Vre, Vbs, data32;
U016    Attr, Seq;
U008    Cr07, Cr09, Cr11, Cr25;

    // Make sure to always default to centered mode for now
    // Read the current control register value, and force it to be centered
    
    data32 = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_FP_TG_CONTROL);

    // Clear out all the bits

    data32 &= (~ ((DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _NATIVE )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _HORIZ )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _VERT  )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _BOTH  ))   ));

    // Force it to be centered (automatic centering)
    data32 |= (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER ));
    
    PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_FP_TG_CONTROL,data32);


    // check for pixel doubled modes
    if (XRes < 640)
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }

    // Make sure attr is set correctly
    Cr07 = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    Ht = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x00)>>8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)((Ht-3)<<8 | 0x04));   // HRS
    Hre = ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05)>>8) & 0xe0);    // read CR05 and mask 4:0
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(((Ht-2) | Hre)<<8 | 0x05));   // HRE = Ht - 2, CR04[4:0]

    // gather VT bits
    Vt = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x06)>>8);
    Cr07 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07)>>8);
    Cr25 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25)>>8);
    if (Cr07 & VT08)
        Vt |= 0x0100;
    if (Cr07 & VT09)
        Vt |= 0x0200;
    if (Cr25 & VT10)
        Vt |= 0x0400;

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vrs<<8 | 0x10));
    Cr07 &= ~EXT_VRS;
    if (Vrs & 0x100) Cr07 |= VRS08;
    if (Vrs & 0x200) Cr07 |= VRS09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    if (Vrs & 0x400) Cr25 |= VRS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));

    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    Cr11 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11)>>8);
    Vre |= (Cr11 & 0xf0);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vre<<8 | 0x11));

    // VBS = VRS
    Cr09 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09)>>8);
    Vbs = Vrs;

    // write VBS
    Cr07 &= ~VBS08;
    if (Vbs & 0x100) Cr07 |= VBS08;
    Cr09 &= ~VBS09;
    if (Vbs & 0x200) Cr09 |= VBS09;
    Cr25 &= ~VBS10;
    if (Vbs & 0x400) Cr25 |= VBS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vbs<<8 | 0x15));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr09<<8 | 0x09));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));

    // wait for vsync

    while (PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
    while (!(PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start

    data32 = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_FP_DEBUG_0);           // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    PRAMDAC_REG_WR32(PRAMDAC_Base,NV_PRAMDAC_FP_DEBUG_0, data32);
}




//******************************************************************************
//
// Function:    Disable Interrupt
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_DisableNVInterrupts
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{

    ULONG CurrentValue;

    //**************************************************************************
    // Make sure that we're not currently in an interrupt routine first
    // If interrupts are disabled, then someone is currently handling
    // the interrupts.  Wait for Interrupts to get re-activated.
    //**************************************************************************

    CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);
    while (CurrentValue == 0)
        CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);

    //**************************************************************************
    // Save off current value of PMC_INTR_EN_0
    //**************************************************************************
    
    CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);

    HwDeviceExtension->SavedPMCState = CurrentValue;

    //**************************************************************************
    // Disable NV Interrupts
    //**************************************************************************

    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, 0x00000000);


}


//******************************************************************************
//
// Function:    Re-Enable Interrupt
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ReEnableNVInterrupts
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, HwDeviceExtension->SavedPMCState);

}


//******************************************************************************
//
// Function:    ManualTextModeSet
//
// Routine Description:
//
//              This code was ported from the BIOS
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ManualTextModeSet
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    U008 byteValue;
    U032 dwordValue;
    U008 savedCrtcIndex;
    U008 savedLockValue;
    U008 initialLockValue;
            
    //**************************************************************************
    // Unlock extended registers
    //**************************************************************************
                    
    savedCrtcIndex = REG_RD08(NV_PRMCIO_CRX__COLOR); // 3d4

    CRTC_RD(NV_CIO_SR_LOCK_INDEX , savedLockValue);  // 1f lock index
    initialLockValue = savedLockValue;
    savedLockValue &=1;

    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    byteValue &=0xfe;
    byteValue |=savedLockValue;
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    
    CRTC_WR(NV_CIO_SR_LOCK_INDEX , NV_CIO_SR_UNLOCK_RW_VALUE ); // 0x57 unlock value

    //**************************************************************************
    // OEMPreSetMode
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent)      // Flat panel is present
        {
        CRTC_WR(0x21, 0xba);
        }
    else if (HwDeviceExtension->TvIsPresent)        // TV is present
        {
        ;       // Do nothing
        }
    else
        {
        CRTC_WR(0x21, 0xfa);                        // CRT present
        }
                             
    //**************************************************************************
    // ATCOFF
    //**************************************************************************

// cli
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
    REG_WR08(NV_PRMCIO_ARX, 0);                     // 3c0
// sti

    //**************************************************************************
    // OEMPreSetRegs
    //**************************************************************************
    
    CRTC_RD(0x28, byteValue);                       // 3d4
    byteValue &=0xf8;
    CRTC_WR(0x28, byteValue);
    
    CRTC_RD(0x1a, byteValue);                       // 3d4
    byteValue |=2;
    CRTC_WR(0x1a, byteValue);

    //**************************************************************************
    // SetRegs
    //**************************************************************************
    
    REG_WR08(NV_PRMVIO_SRX, 0);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 1);                // 3c5
    
    REG_WR08(NV_PRMVIO_MISC__WRITE , 0x67);         // 3c2
                               

    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 0);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 2);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 3);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 3);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 0);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 4);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 2);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 0);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 3);                // 3c5

    //**************************************************************************
    // CRTC Regs
    //**************************************************************************

    CRTC_WR(0x11, 0x20);                            // 3d4
    CRTC_WR(0x00, 0x5f);
    CRTC_WR(0x01, 0x4f);
    CRTC_WR(0x02, 0x50);
    CRTC_WR(0x03, 0x82);
    CRTC_WR(0x04, 0x55);
    CRTC_WR(0x05, 0x81);
    CRTC_WR(0x06, 0xbf);
    CRTC_WR(0x07, 0x1f);
    CRTC_WR(0x08, 0x00);
    CRTC_WR(0x09, 0x4f);
    CRTC_WR(0x0a, 0x0d);
    CRTC_WR(0x0b, 0x0e);
    CRTC_WR(0x0c, 0x00);
    CRTC_WR(0x0d, 0x00);
    CRTC_WR(0x0e, 0x00);
    CRTC_WR(0x0f, 0x00);
    CRTC_WR(0x10, 0x9c);
    CRTC_WR(0x11, 0x8e);
    CRTC_WR(0x12, 0x8f);
    CRTC_WR(0x13, 0x28);
    CRTC_WR(0x14, 0x1f);
    CRTC_WR(0x15, 0x96);
    CRTC_WR(0x16, 0xb9);
    CRTC_WR(0x17, 0xa3);
    CRTC_WR(0x18, 0xff);

    //**************************************************************************
    // GDC Regs
    //**************************************************************************

    REG_WR08(NV_PRMVIO_GRX,   0x0);                 // 3ce
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x1);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x2);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x3);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x4);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x5);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x10);            

    REG_WR08(NV_PRMVIO_GRX,   0x6);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0e);            

    REG_WR08(NV_PRMVIO_GRX,   0x7);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x8);            
    REG_WR08(NV_PRMVIO_GX_SR, 0xff);            

    //**************************************************************************
    // Full Cpu ON
    //**************************************************************************
    
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
    byteValue |=0x20;
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET,byteValue  );       // 3c5

    //**************************************************************************
    // OEMSetRegs
    //**************************************************************************

    CRTC_WR(0x19, 0x0);

    CRTC_RD(0x1a,byteValue);
    byteValue &=0xc0;
    byteValue |=0x38;
    byteValue |=1;
    byteValue |=4;
    CRTC_WR(0x1a, byteValue);

    CRTC_WR(0x1b, 0x3);
    CRTC_WR(0x1c, 0x18);
    CRTC_WR(0x1d, 0x0);
    CRTC_WR(0x1e, 0x0);

    CRTC_WR(0x20, 0x20);
    CRTC_WR(0x25, 0x0);

    CRTC_RD(0x28,byteValue);
    byteValue &=0xf8;
    CRTC_WR(0x28, byteValue);


    CRTC_WR(0x2d, 0x0);
    CRTC_WR(0x29, 0x0);
    CRTC_WR(0x2a, 0x0);
    CRTC_WR(0x30, 0x0);
    CRTC_WR(0x31, 0x0);
    CRTC_WR(0x32, 0x0);

    CRTC_RD(0x33,byteValue);
    byteValue &= 0x7f;
    CRTC_WR(0x33, byteValue);

    CRTC_WR(0x39, 0xff);


    dwordValue = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
    dwordValue &=0xeffffdfe;
    if (HwDeviceExtension->FlatPanelIsPresent)      // Flat panel is present
        dwordValue |= 0x00000200;
    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT,dwordValue);

    dwordValue = REG_RD32(NV_PRAMDAC_GENERAL_CONTROL);
    dwordValue &= 0xffefeeef;
    dwordValue |= 0x00000100;
    dwordValue |= 0x00000010;
    REG_WR32(NV_PRAMDAC_GENERAL_CONTROL,dwordValue);

    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x18);                    

    //**************************************************************************
    // Skip Load Palette and LoadSysfont
    //**************************************************************************

    //**************************************************************************
    // Skip OemFixupSetMode/ FPEndSetMode for now    (Flat panel only)
    //**************************************************************************

//    FPEndSetMode();

    //**************************************************************************
    // SetDPMSOff
    // Turn off DPMS on CRT only
    //**************************************************************************

    if ((!(HwDeviceExtension->FlatPanelIsPresent)) &&   // Flat panel not present
        (!(HwDeviceExtension->TvIsPresent)) )           // TV not present
        {    
        CRTC_RD(0x1a, byteValue);
        byteValue&=0x3f;
        CRTC_WR(0x1a, byteValue);

        //**********************************************************************
        // Full CPU Off
        //**********************************************************************
    
        REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
        byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
        byteValue &=0xdf;
        REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
        REG_WR08(NV_PRMVIO_SR_RESET,byteValue);         // 3c5
    
        //**********************************************************************
        // ATCON
        //**********************************************************************
// cli    
        byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
        byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
        REG_WR08(NV_PRMCIO_ARX, 0x20);                  // 3c0
        byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
        byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
// sti
        }
            
    //**************************************************************************
    // Full CPU Off
    //**************************************************************************

    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
    byteValue &=0xdf;
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET,byteValue);         // 3c5

    //**************************************************************************
    // ATCON
    //**************************************************************************

//cli
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
    REG_WR08(NV_PRMCIO_ARX, 0x20);                  // 3c0
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
//sti

    //**************************************************************************
    // Skip OEMPostSetMode  (TV only)
    //**************************************************************************

    //**************************************************************************
    // Restore / Lock extended registers if necessary
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    byteValue &=0xfe;                                // remove bit 0
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c

    if (initialLockValue == 0)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);
        }
    else if (initialLockValue == 1)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RO_VALUE);
        }
    else if (initialLockValue == 3)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);
        }

    //**************************************************************************
    // Restore the original CRTC index register
    //**************************************************************************

    REG_WR08(NV_PRMCIO_CRX__COLOR, savedCrtcIndex); // 3d4

    }



#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
//
// Function:    NV_VBE_DPMS_GetPowerState()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

BOOLEAN NV_VBE_DPMS_GetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG *CurrentPowerState)

    {
    UCHAR lock;
    UCHAR cr1a;
    UCHAR result;

    //**************************************************************************
    // Save off original lock value, then unlock extended registers
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);

    //**************************************************************************
    // Read CR1A
    //
    //   Bit 7 Hsync Toggle disable.  When set to a 1, this bit forces the Hsync to
    //            inactive state (high or low as programmed in the bit-6 of the
    //            Miscellaneous output register).
    //
    //   Bit 6 Vsync Toggle disable.  When set to a 1, this bit forces the Vsync to
    //            inactive state (high or low as programmed in the bit-7 of the
    //            Miscellaneous output register).
    //
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, cr1a);

    //**************************************************************************
    // Isolate DPMS bits (CR1A bits 7 & 6)
    //**************************************************************************

    cr1a >>=14;
    *CurrentPowerState = tblDPMSStates[cr1a];

    //**************************************************************************
    // Relock the extended registers, if necessary
    //**************************************************************************

    //**************************************************************************
    // Relock the extended registers, if necessary
    //**************************************************************************

    if (lock == 0)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);
        }
    else if (lock == 1)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RO_VALUE);
        }
    else if (lock == 3)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);
        }


    return(TRUE);
    }


//******************************************************************************
//
// Function:    NV_VBE_DPMS_SetPowerState()
//
// Routine Description:
//
//       VBE Function 10h
//       VBE_DPMS - Display Power Management Signaling functions (DPMS).
//
//       Entry:  AX = 4F10h
//               BL = Subfunction
//               ES:DI = Null pointer
//               DS = Seg0
//
//               Other registers dependent on subfunction
//               Subfunction 0:
//                       None
//               Subfunction 1:
//                       BH = Requested power state
//                            0 = On
//                            1 = Stand by
//                            2 = Suspend
//                            4 = Off
//                            8 = Reduced on
//               Subfunction 2:
//                       None
//
//       Exit:   AX = VBE return status
//               Other registers dependent on subfunction:
//               Subfunction 0:
//                       BH = States supported:
//                            bit 0      Stand by
//                            bit 1      Suspend
//                            bit 2      Off
//                            bit 3      Reduced on
//                            bits 4-7   Reserved
//                       BL = VBE/PM Version number:
//                            bits 0-3   Minor version number (0)
//                            bits 4-7   Major version number (1)
//               Subfunction 1:
//                       None
//               Subfunction 2:
//                       BH = Power state currently requested by controller
//                            0 = On
//                            1 = Stand by
//                            2 = Suspend
//                            4 = Off
//                            8 = Reduced on
//
//       The VESA committee defined a method of signalling a monitor
//       to shutdown or to go into standby mode. The sync signals are
//       used in the following manner:
//
//       H Sync  V Sync  Result
//       ======  ======  ======
//       Pulses  Pulses  Monitor is active
//       None    Pulses  Monitor is in "stand-by" mode
//       Pulses  None    Monitor is in "suspend" mode
//       None    None    Monitor is in "shut down" mode
//
//       Note: ES, DS, SI have been pushed on the stack already
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
BOOLEAN NV_VBE_DPMS_SetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PowerState)
{
    BOOLEAN bRet = 0;
    ULONG i;

    for(i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
    {
        
        switch (PowerState)
        {

            case VideoPowerOn:
            case VideoPowerHibernate:
                bRet |= 
                    RmSetDisplayPowerState
                    (
                        HwDeviceExtension->DeviceReference,
                        HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i],
                        TRUE
                    );
                HwDeviceExtension->ulRmTurnedOffMonitor = FALSE;
                break;

            case VideoPowerStandBy:
                    //RmSetDisplayPowerState...
                    break;

            case VideoPowerSuspend:
                    //RmSetDisplayPowerState...
                    break;

            case VideoPowerOff:
                bRet |= 
                    RmSetDisplayPowerState
                    (
                        HwDeviceExtension->DeviceReference,
                        HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i],
                        FALSE
                    );
                HwDeviceExtension->ulRmTurnedOffMonitor = TRUE;
                break;
        }
    }    

    return(bRet);

}

//******************************************************************************
//
// Function:    GetCurrentDPMSState(HwDeviceExtension)
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

U032 GetCurrentDPMSState(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    U032 Value;
    
    
    Value = hwDeviceExtension->CurrentDPMSState;
    return(Value);
    }


//******************************************************************************
//
// Function:    NV_ATCOff()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ATCOff(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    NV_ResetATCFlipFlop(HwDeviceExtension);        // Reset ATC to index state

    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x0);

    }


//******************************************************************************
//
// Function:    NV_ATCOn()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ATCOn(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    NV_ResetATCFlipFlop(HwDeviceExtension);    // Reset ATC to index state

    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x20);

    NV_ResetATCFlipFlop(HwDeviceExtension);    // For compatibility with DOS EDIT

    }


//******************************************************************************
//
// Function:    NV_ResetATCFlipFlop()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ResetATCFlipFlop(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    volatile U008 value;

    value = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR);
    value = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__MONO);

    }


#endif // WINN32_WINNT >= 0x0500 NT5 only



//******************************************************************************
//
//  Function: NVGetTimingForDac()
//
//  Routine Description:
//
//      This routine get timing values for dac at giving mode.
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//
//  Return Value:
//      TRUE - successful; FALSE - failed
//
//******************************************************************************
BOOL NVGetTimingForDac(PHW_DEVICE_EXTENSION hwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo)
{

    ULONG ulDisplayWidth;
    ULONG ulDisplayHeight;
    ULONG ulDisplayRefresh;
    ULONG ulDisplayPixelDepth;

    MODE_TIMING_VALUES timingInfo;
    unsigned int vesaStatus;

#ifdef ENABLE_COMMON_MODESET_CODE
    GetTimingDacCommonModesetCode(hwDeviceExtension, pResolution, pTimingInfo);
    return (TRUE);
#endif


    ulDisplayWidth      = pResolution->ulDisplayWidth;   
    ulDisplayHeight     = pResolution->ulDisplayHeight;  
    ulDisplayRefresh    = pResolution->ulDisplayRefresh; 
    ulDisplayPixelDepth = pResolution->ulDisplayPixelDepth;

    if(hwDeviceExtension->bUseGTF) {

        //**********************************************************************
        // Here we use GTF timings as requested by the user
        //**********************************************************************

        vesaStatus = vesaGetGTFTimings(ulDisplayWidth,
                                       ulDisplayHeight, 
                                       ulDisplayRefresh,
                                       (MODE_TIMING_VALUES *)pTimingInfo);
                                   
        if (vesaStatus)
            {
            // Could not find a GTF timing for this mode
            return(FALSE);
            }

        return(TRUE);
    }


    //**************************************************************************
    // By default, we use DMT timings  (instead of GTF timings)
    //**************************************************************************

    vesaStatus = vesaGetDMTTimings(ulDisplayWidth,
                                   ulDisplayHeight, 
                                   ulDisplayRefresh,
                                   (MODE_TIMING_VALUES *)pTimingInfo);
                                   
    //**************************************************************************
    // If DMT timings don't exist for this mode, use the GTF timings
    //**************************************************************************

    if (vesaStatus)
    {
        //**********************************************************************
        // Set mode using GTF timings if DMT timings don't exist
        //**********************************************************************
        vesaStatus = vesaGetGTFTimings(ulDisplayWidth,
                                       ulDisplayHeight, 
                                       ulDisplayRefresh,
                                       (MODE_TIMING_VALUES *)pTimingInfo);
        if (vesaStatus)
    
        {
            // Could not find a DMT / GTF timing for this mode
            return(FALSE);
        }
                                    
    }

    return(TRUE);
}

//
// Read in the monitor restriction mode list per head from the registry.
//
VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    U016 *ValidModePtr;
    U016 *RegDataPtr;
    ULONG NumRegistryModes;
    U016  *BaseOfValidModeTable;
    ULONG i;
    U016 RegWidth,RegHeight,RegDepth,RegRefresh;
    
    // init the Monitor restriction mode tables.
    MonitorRestrictionModeList0_registry_data[0]     = 0xFFFF ;
    MonitorRestrictionModeList1_registry_data[0]     = 0xFFFF ;
    HwDeviceExtension->NumRestrictionModes0 = 0;
    HwDeviceExtension->NumRestrictionModes1 = 0;
    // copy the monitor restriction modelists for both heads.
    NV_ReadAndCopyRegistryData(HwDeviceExtension, L"MonitorModeList0",      &(MonitorRestrictionModeList0_registry_data[0] ));
    NV_ReadAndCopyRegistryData(HwDeviceExtension, L"MonitorModeList1",      &(MonitorRestrictionModeList1_registry_data[0] ));

    for (i=0; i < NV_NO_DACS; i++)
    {
        RegDataPtr = (i ? (U016 *)&MonitorRestrictionModeList1_registry_data[0] : (U016 *)&MonitorRestrictionModeList0_registry_data[0]);
        ValidModePtr = (i ? (U016 *)&HwDeviceExtension->RestrictionModeTable1[0] : (U016 *)&HwDeviceExtension->RestrictionModeTable0[0]);
        BaseOfValidModeTable = ValidModePtr;
        NumRegistryModes = 0;
    
        //**************************************************************************
        // Parse each line from the registry.
        // For each refresh rate (of each mode), check if the refresh is present in the
        // vesa data table.  If so, then it's a valid mode. 
        // Registry data is terminated with 0xffff
        //**************************************************************************

        while (*RegDataPtr != 0xffff)
            {
            RegDepth   = *(RegDataPtr);             // Get Depth from registry
            RegWidth   = *(RegDataPtr+1);           // Get Width from registry
            RegHeight  = *(RegDataPtr+2);           // Get Height from registry

            //**********************************************************************
            // Advance to the registry refresh rates for this particular mode
            //**********************************************************************

            RegDataPtr+=3;

            //**********************************************************************
            // Each mode entry in the registry data is NULL terminated.
            // Parse all refresh rates for this mode
            //**********************************************************************

            while (*RegDataPtr !=0)
            {        
                RegRefresh  = *(RegDataPtr++);      // Get Refresh from registry data

                //**********************************************************
                // Generate 8bpp entry for this refresh rate
                //**********************************************************

                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = RegWidth;          // Width
                *(ValidModePtr+2)  = RegHeight;         // Height
                *(ValidModePtr+3)  = RegDepth;          // Depth                                                                 
                *(ValidModePtr+4)  = RegRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode

                //**********************************************************
                // Keep track of how many modes have currently been specified
                //**********************************************************

                NumRegistryModes++;

                //**********************************************************
                // DEBUG safety check
                // Make sure we never go past the end of the
                // allocated valid mode table. (back off 30 words from end of table)
                //**********************************************************

                if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2) ))
                {
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                }
            } // while (*RegDataPtr !=0)...

            //**********************************************************************
            // Skip past null terminator
            //**********************************************************************

            RegDataPtr++;
                
        } // while (*RegDataPtr != 0xffff)...

        //
        // Save the number of restriction modes for each head
        //
        if (i == 0) 
        {
            HwDeviceExtension->NumRestrictionModes0 = NumRegistryModes;
        }
        else
        {
            HwDeviceExtension->NumRestrictionModes1 = NumRegistryModes;
        }
    } // for each head
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\arb_fifo.h ===
#ifndef _ARB_FIFO_H

#define ARB_FIFO_H

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128


typedef struct {
  int gdrain_rate;
  int vdrain_rate;
  int mdrain_rate;

  int gburst_size;
  int vburst_size;
  char vid_en;
  char gr_en;
  int wcmocc, wcgocc, wcvocc, wcvlwm, wcglwm;
  int by_gfacc;
  char vid_only_once;
  char gr_only_once;
  char first_vacc;
  char first_gacc;
  char first_macc;
  int vocc;
  int gocc;
  int mocc;
  char cur;
  char engine_en;
  char converged;
  int priority;
} arb_info;


// the following structures are used by nv3

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;  //Burst size
  int video_burst_size;   // Burst size

  int graphics_hi_priority; // FBI arbitration
  int media_hi_priority;

  int rtl_values;
  int valid;  // good values


} fifo_info;
typedef struct {

  int pix_bpp;          /* 8, 16 or 32 */

  char enable_video; /* Video scalar enabled */
  char gr_during_vid; /* Graphic displays during video */
  char enable_mp; /* Media Port enabled */

  int memory_width;  /* 64 or 128 bits */

  int video_scale; /* video scale factor */

  long pclk_khz; /* Pixel clock, in KHz */
  long mclk_khz; /* Memory clock, in KHz */

  int mem_page_miss; /* Memory page miss penalty */
  int mem_latency;  /* Memory latency */

  char mem_aligned; /* FB is aligned on a 256 byte boundry */
} sim_state;


// the following structures are used by nv4

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;
  int video_burst_size;

  int valid;  // good values

} nv4_fifo_info;

typedef struct {
  int pclk_khz;
  int mclk_khz;
  int nvclk_khz;
  char mem_page_miss;
  char mem_latency; //cas_latency
  int memory_width;
  char enable_video;
  char gr_during_vid;
  char pix_bpp;
  char mem_aligned;
  char enable_mp;
} nv4_sim_state;




#define VIDEO       0
#define GRAPHICS    1
#define MPORT       2
#define ENGINE      3


#define GFIFO_SIZE  320     /* Graphics Fifo Sizes */
#define GFIFO_SIZE_128  256     /* Graphics Fifo Sizes */
#define MFIFO_SIZE  120 /* MP  Fifo Sizes */
#define VFIFO_SIZE  256 /* Video Fifo Sizes */

#define ABS(a)  (a>0?a:-a)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modedefs.h ===
//******************************************************************************
//
// Copyright (c) 1998  NVidia Corporation
//
// Module Name:
//
//     modedefs.h
//
// Abstract:
//
// Environment:
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1998 NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#define NUMBER_OF_MODES 18
#define NUMBER_OF_DEPTHS 4
#define NUMBER_OF_RATES  7
#define MODE_TABLE_LENGTH (NUMBER_OF_MODES * NUMBER_OF_DEPTHS * sizeof(U016))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modehw.h ===
//
// MODEHW.H - Header file for OS specific portions of mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines for accessing NV registers in the 'C' based modeset code.
//
//
VOID WriteFb32(U032 datum, U032 addr);
U032 ReadFb32(U032 addr);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WriteIndexed(U032 addr, U016 datum);
VOID WritePriv08(U032 addr, U008 datum);
U016 ReadIndexed(U032 addr, U008 reg);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\ddminint.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995,1997 NVidia Corporation. All Rights Reserved.
 *
 *  File:       ddmini.h
 *  Content:    header for Windows95 Direct Draw driver
 *
 *  Files:
 *           ddmini16.c
 *           ddddrv16.c
 *           ddmode.c
 *
 *           dddrv32.c
 *           blt832.c
 *           blt1632.c
 *           blt3232.c
 *
 ***************************************************************************/
#ifndef _DDMININT_H_
#define _DDMININT_H_

// Note:

// From NT4 DDK (Graphics System Overview)
//    The display driver is in the same privileged kernel-mode address space as the 
//    rest of the Windows NT Executive. Faults in the display driver will cause GDI 
//    and the rest of the system to fault.

#ifndef NVD3D
#include "nvFourCC.h"

#undef NV_MAX_FOURCC
#define NV_MAX_FOURCC 7

#endif

// This came from dx95types.h which is not in the dx path being used for NT4
typedef PDD_DIRECTDRAW_GLOBAL           LPDDRAWI_DIRECTDRAW_GBL;

#include "CompileControl.h"

#if IS_WINNT4
#include "nvPusher.h"
#include "nvVPP.h"
#endif

#define NV_MAX_EXTRA_FS_SURFACES 4
#define NV_MAX_EXTRA_SURFACES    6

//  Remove double-defintion warning
#ifdef  DIRECTDRAW_DLLNAME
#undef  DIRECTDRAW_DLLNAME
#endif
#define DIRECTDRAW_DLLNAME "NV3DD32.DLL"
//#else
//#define DIRECTDRAW_DLLNAME "NVD3D32.DLL"
//#endif

#ifndef _WIN32
#define NOUSER
#define NOGDI
#define NOGDIOBJ
#define NOGDICAPMASKS
#include <windows.h>
#define NOPTRC
#define PTTYPE POINT
#include <nvgdi.inc>
#define NVFAR FAR
#include <nvdib.inc>
typedef struct tagPALETTEENTRY FAR* LPPALETTEENTRY;
typedef struct tagRGNDATA      FAR* LPRGNDATA;
#include <ddrawi.h>
#endif

#define FAST register

//  Remove double-definition warning
#ifdef  asmMergeCoords
#undef  asmMergeCoords
#endif
#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)

// Probably should move these up to a more general level -@mjl@

/* Other NV specific defines */
#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L

/* Surface Alignment */
#if (NVARCH >= 0x010)
#define NV_BYTE_ALIGNMENT_PAD           63L
#define NV_BYTE_ALIGNMENT               64L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#elif (NVARCH >= 0x04)
#define NV_BYTE_ALIGNMENT_PAD           31L
#define NV_BYTE_ALIGNMENT               32L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#else /* NVARCH < 0x04 */
#define NV_BYTE_ALIGNMENT_PAD           15L
#define NV_BYTE_ALIGNMENT               16L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      128
#define NV_BIT_ALIGNMENT                128
#endif  /* !(NV10 || NV4) */


//************************************************************************************
// Entry/exit macros used by the ddraw driver to acquire the rendering semaphore from the
// This notifies the OGL ICD that we need to touch the fifo
//************************************************************************************
#define START_DMA_PUSH_SYNC()           \
{ \
    ppdev->pfnAcquireOglMutex(ppdev); \
    ppdev->NVFreeCount = 0; \
    releaseOpenglSemaphore = TRUE; \
}

#define ENTER_DMA_PUSH_SYNC()           \
    if (OglIsEnabled(ppdev))       \
        {                               \
        START_DMA_PUSH_SYNC(); \
        }

#define END_DMA_PUSH_SYNC() \
    if (releaseOpenglSemaphore == TRUE) \
        {                               \
        ppdev->pfnReleaseOglMutex(ppdev); \
        }

#define EXIT_DMA_PUSH_SYNC(exitcode)    \
{ \
    END_DMA_PUSH_SYNC();            \
    return(exitcode); \
}

#define NV_VPP_CHANNEL_IID  0xDD115020   // Special version for NT4

#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017 // Was coming from win9x header!

// Not sure this is the best approach to accessing this object methods. -@mjl@
#define BETA4_SET_BETA_FACTOR_OFFSET                            NV072_SET_BETA_FACTOR
#define SURFACES_2D_PITCH_OFFSET                                NV042_SET_PITCH
#define BLIT_POINT_IN_OFFSET                                    NV05F_CONTROL_POINT_IN
#define MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET                      NV039_OFFSET_IN
#define SET_ROP_OFFSET                                          NV043_SET_ROP5
#define SET_TRANSCOLOR_OFFSET                                   NV057_SET_COLOR
#define SURFACES_2D_SET_COLOR_FORMAT_OFFSET                     NV042_SET_COLOR_FORMAT
#define SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET                   NV077_SET_CONTEXT_DMA_IMAGE
#define SCALED_IMAGE_CONTEXT_SURFACE_OFFSET                     NV077_SET_CONTEXT_SURFACE
#define SCALED_IMAGE_SET_COLOR_FORMAT                           NV077_SET_COLOR_FORMAT
#define SCALED_IMAGE_CLIPPOINT_OFFSET                           NV077_CLIP_POINT
#define SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET                       NV077_IMAGE_IN_SIZE
#define SCALED_IMAGE_NOTIFY_OFFSET                              NV077_NOTIFY

//---------------------------------------------------------------------------
// blit data, including cached values and other control parameters
// 
// Used to allow sharing of several objects (ROP, 2D SURFACE, ...?)
//  by multiple users within the same context (may not need in NT4) -@mjl@

typedef struct BltData_s {
    NvU32               dwStatusReferenceCount;
    NvU32               dwSystemSurfaceContextDMAIndex;
    NvU32               dwMTMFIndex;     // alternating odd or even, does not need to be initialized
    NvU32               dwLastRop;
    NvU32               dwLastColourKey;
    NvU32               dwLastColourFormat;
    NvU32               dwLastCombinedPitch;
    NvU32               dwLastSrcOffset;
    NvU32               dwLastDstOffset;
    NvU32               dwSystemBltFallback;
    NvU32               dwLetItThrash;
    NvU32               dwQueuedPrimaryBlitCount;
} BltData_t;


/***************************************************************************
 *
 * DriverData
 *
 * this structure contains all the globals of the driver, it is shared
 * between the 16 and 32bit side of the driver.
 *
 ***************************************************************************/

//  Remove double-definition warning
#ifdef  DDMINI_VERSION
#undef  DDMINI_VERSION
#endif
#define DDMINI_VERSION  0x0300



typedef DWORD  (FAR PASCAL *LPDDHALSURFCB_GETSURFACEINFO)(LPDDRAWI_DDRAWSURFACE_LCL);

#ifndef NVD3D
typedef struct {
    short   x;
    short   y;
} NVXY;

typedef struct {
    short   y;
    short   x;
} NVYX;

typedef struct {
    unsigned short w;
    unsigned short h;
} NVWH;

typedef struct {
    unsigned short h;
    unsigned short w;
} NVHW;

typedef union {
    long xy;
    long yx;
    unsigned long wh;
    unsigned long hw;
    NVXY xy16;
    NVYX yx16;
    NVWH wh16;
    NVHW hw16;
} NVCOORD;

typedef struct {
    DWORD               fpFlipFrom;
    DWORD               dwFlipDuration;
    DWORD               bFlipFlag;
    DWORD               bIsD3DSurface;
    DWORD               fpFlipTo;
    DWORD               fpPreviousFlipFrom;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    LONGLONG            llFlipTime;
    LONGLONG            llPreviousFlipTime;
} FLIPRECORD;

// I think these are mocomp... why are they used in VPP? -@mjl@
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
typedef struct tagNVMCSURFACEFLAGS {
  DWORD dwMCSurfaceBase;
  DWORD dwMCSurface422Offset;
  DWORD dwMCMotionCompReferenceCount;
  DWORD dwMCFormatCnvReferenceCount;
  DWORD dwMCCompositeReferenceCount;
  DWORD dwMCTemporalFilterReferenceCount;
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
  BYTE  bMCFrameIsFiltered;
  BYTE  bMCFrameIsComposited;
  BYTE  bMCFrameAlreadyFormatConverted;
} NVMCSURFACEFLAGS, *LPNVMCSURFACEFLAGS;


typedef struct _GLOBALDATA
{
    // lpPDevice *must* be first (DIBLINK.ASM) uses it.
#ifdef _WIN32
    DWORD                       lpPDevice;
#else
    DIBENGINE FAR *             lpPDevice;
#endif


    DWORD                       dwVersion;
    DWORD                       fIsDisplay;

    // flags
    DWORD                       DDrawVideoSurfaceCount; // *MUST* start at 0xC offset from beginning of struct (cursor code and realizeObject checks it)
    WORD                        fDmaPusherActive;   // *MUST* start at 0x10 offset from beginning of struct (both display driver and direct draw check it)
    WORD                        fFullScreenDosOccurred; // *MUST* start at 0x12 offset from beginning of struct (both display driver and direct draw check it)
    WORD                        fVidMemLocked;
    WORD                        fActiveExternalUser; // NVLIB, NVDDX, etc
    WORD                        fNvActiveFloatingContexts;
    WORD                        OverlayBufferIndex;

    // info about the current mode
    DWORD                       ModeNumber;
    DWORD                       TotalVRAM;          // total VRAM on card
    DWORD                       ScreenSel;          // selector to screen
    DWORD                       maxOffScreenY;      // maximum screen pitch width Y at current resolution
    DWORD                       BaseAddress;        // base addess of accessable video memory.
    long                        VideoHeapBase;      // start of video heap
    long                        VideoHeapEnd;       // end of video heap
    DWORD                       GARTLinearBase;     // linear base address of AGP GART memory
    DWORD                       GARTPhysicalBase;   // physical base address of AGP GART memory
    WORD                        OverlaySrcX;        // overlay source starting point
    WORD                        OverlaySrcY;

    // bitmapinfo for current mode
    BITMAPINFOHEADER            bi;
    DWORD                       color_table[256];

    PDEV *                      ppdev;  // A pointer back to the physical device
    NvU32                       dwRootHandle;       
    NvU32                       dwDeviceHandle;
    NvU32                       dwSurfaceAlignPad;
    NvU32                       dwMostRecentCelsiusUser;
    BltData_t                   bltData;
    CPushBuffer                 nvPusher;

    // TBD: port the process manager to NT4 -@mjl@
    PROCESSINFO                 procInfo;           // statically created for NT

    Vpp_t                       vpp;
    NV_SystemInfo_t             sysInfo;     // TBD: duplicates most of D3dPerf -- fix that - @mjl@


    // TBD: vpp makes ref to these! -@mjl@
    // TBD: make sure this are initialized properly -@mjl@
    DWORD                       dwDXVAFlags; // Unused (in WinNT4) except for reference in VPP code -- must be zero. @mjl@
    DWORD                       dwSharedClipChangeCount; // TBD: vpp makes global ref to these! -@mjl@
    FLIPRECORD                  flipPrimaryRecord;
    FLIPRECORD                  flipOverlayRecord;
    NVMCSURFACEFLAGS            nvMCSurfaceFlags[9];
    NvU8                        bMCOverlaySrcIsSingleField1080i;
    BYTE                        bMCHorizontallyDownscale1080i;
    DWORD                       dwMCNV12Surface[8];
    DWORD                       dwMCDestinationSurface;
    DWORD                       dwMCNVMCSurface;
    BYTE                        bMCTemporalFilterDisabled;
    BYTE                        bMCPercentCurrentField;
    DWORD                       dwMCNVDSSurfaceBase;
    DWORD                       dwMCMostRecentlyDecodedSurfaceBase;
    DWORD                       dwMCNVSPSurface;
    DWORD                       dwMCIDCTAGPSurfaceBase[4];
    DWORD                       dwMCCurrentCelsiusIDCTCtxDma;
    DWORD                       dwMCIDCTAGPCtxDmaSize[4];
    DWORD                       dwMCNVIDSurface[4];
    DWORD                       dwMCNVIDSurfaceReferenceCount[4];

    NvU32                       dwTVTunerFlipCount;
    NvU32                       dwOverlayFlipCount;
    NvU32                       dwHeads;            // number of heads (DACs) on this device
    NvU32                       dwDesktopState;
    NvU32                       regOverlayColourControlEnable;
    NvU16                       NvDeviceVersion;
    NvU16                       unused_01;



    // NV stuff
    DWORD                       lpNvDev;
    DWORD                       lpNvDmaBuffer;
    DWORD                       NvDevFlat;
    DWORD                       NvDevFlatVPE; // Vpe channel
    DWORD                       NvDmaBufferFlat;
    DWORD                       NvDummyNotifierFlat;
    DWORD                       NvFlipPrimaryNotifierFlat;
    DWORD                       NvFlipOverlayNotifierFlat;
    DWORD                       NvFlipVportNotifierFlat;
    DWORD                       NvDmaToMemNotifierFlat;
    DWORD                       NvDmaFromMemNotifierFlat;
    DWORD                       NvDmaFromMemBaseAddress;
    DWORD                       NvDmaFromMemSurfaceMem;
    DWORD                       NvPusherSyncNotifierFlat;
    DWORD                       NvScanlineBufferFlat;
    DWORD                       NvFloating0UYVYSurfaceMem;
    DWORD                       NvFloating1UYVYSurfaceMem;
    DWORD                       NvFloating0YUYVSurfaceMem;
    DWORD                       NvFloating1YUYVSurfaceMem;
    DWORD                       NvFloatingMem2MemFormatBaseAddress;
    DWORD                       NvYUY2Surface0Mem;
    DWORD                       NvYUY2Surface1Mem;
    DWORD                       NvFloatingMem2MemFormatMemoryHandle;
    DWORD                       NvWinDmaPusherNotifierFlat;
    DWORD                       dwVideoPortsAvailable;
    DWORD                       NvFloatingTexture;
    DWORD                       CurrentVisibleSurfaceAddress;
    DWORD                       dDrawSpareSubchannelObject;
    DWORD                       lpLast3DSurfaceRendered;
    DWORD                       NvBaseFlat;
//    DWORD                       dwOverlaySurfaces;
//    DWORD                       dwOverlayOwner;

//    DWORD                       dwOverlaySrcHeight;
//    DWORD                       dwOverlayDstHeight;
    DWORD                       dwModeIndex;
    DWORD                       dwUseRefreshRate;
    DWORD                       NvFloatingMem2MemFormatNextAddress;
    DWORD                       NvYUY2Surface2Mem;
    DWORD                       dwDDPad0; /* unused */
    DWORD                       dwDDPad1; /* unused */
    DWORD                       ddClipUpdate;
    DWORD                       physicalColorMask;
    WORD                        flatSelector;
    WORD                        NvFreeCount;
    BYTE                        NvFirstCall;
    BYTE                        NvPrevDepth;
    BYTE                        TwoDRenderingOccurred;
    BYTE                        ThreeDRenderingOccurred;
    DWORD                       fourCC[16];    // leave some empty locations so we can add more without rereleasing 16 bit portion of driver

    // D3D stuff
    DWORD                       dwCurrentContextHandle;
    DWORD                       dwCurrentContextPtr;
    DWORD                       dwCurrentTextureHandle;
    DWORD                       dwCurrentTexturePtr;
    DWORD                       dwD3DContextCount;
    DWORD                       dwZBufferContextAddr;
    DWORD                       dwTriangleContextHandle;
    DWORD                       dwTriangleContextAddr;
    DWORD                       dwD3DTextureCount;
    DWORD                       dwDMAPushContext;
    DWORD                       dwDmaPushBufferSize;
    DWORD                       hContexts_gbl;
    DWORD                       hTextures_gbl;
    DWORD                       hAGPList_gbl;
    DWORD                       hTextureHeap;
    DWORD                       hPipelines_gbl;
    DWORD                       hMaterials_gbl;
    DWORD                       dwDmaMaxPushCount;
    DWORD                       regD3DEnableBits1;
    DWORD                       regDmaPushBufferSizeMax;
    DWORD                       regMipMapLevels;
    DWORD                       regZOHMode;
    DWORD                       regTexHeap;
    DWORD                       regMinVideoTextureSize;
    DWORD                       regFilterControl;
    DWORD                       regDmaMinPushCount;
    DWORD                       regD3DContextMax;
    DWORD                       regD3DTextureMax;
    DWORD                       dwContextListHead;
    DWORD                       dwDmaFifoAddr;
    DWORD                       dwDmaFifoOffset;
    DWORD                       dwDmaFifoCurrentBuffer;
    DWORD                       dwDmaCount;

    // DirectDraw stuff
    DWORD                       fReset;
    DD_HALINFO                  HALInfo;
    DD_CALLBACKS                DDCallbacks;
    DD_SURFACECALLBACKS         DDSurfaceCallbacks;
    DD_PALETTECALLBACKS         DDPaletteCallbacks;

} GLOBALDATA;
#endif // #ifndef NVD3D

/***************************************************************************
 ***************************************************************************/
#ifdef _WIN32

/* Ternary raster operation indexes */

#define BLACKNESSINDEX      0x00000000L
#define NOTSRCERASEINDEX    0x00000011L
#define NOTSRCCOPYINDEX     0x00000033L
#define SRCERASEINDEX       0x00000044L
#define PATINVERTINDEX      0x0000005AL
#define SRCINVERTINDEX      0x00000066L
#define SRCANDINDEX         0x00000088L
#define MERGEPAINTINDEX     0x000000BBL
#define SRCCOPYINDEX        0x000000CCL
#define SRCPAINTINDEX       0x000000EEL
#define PATCOPYINDEX        0x000000F0L
#define WHITENESSINDEX      0x000000FFL


#else  // _WIN32

/* Ternary raster operations */
#define BLACKNESS           0x00000042L
#define SRCCOPY             0x00CC0020L
#define PATCOPY             0x00F00021L
#define WHITENESS           0x00FF0062L

/***************************************************************************
 *
 * global driver data
 *
 ***************************************************************************/

extern GLOBALDATA           DriverData;     // in ddmini16.c

/***************************************************************************
 *
 * functions in ddmini.c
 *
 ***************************************************************************/

void FAR PASCAL _loadds BeginAccess(DIBENGINE FAR *pde, int left, int top, int right, int bottom, UINT flags);
void FAR PASCAL _loadds EndAccess(DIBENGINE FAR *pde, UINT flags);

/***************************************************************************
 *
 * functions in setmode.c
 *
 ***************************************************************************/

BOOL HWSetMode();
BOOL HWTestMode(int ModeNumber);
void FAR PASCAL HWBeginAccess(DIBENGINE FAR *,short,short,DWORD,DWORD);
void HWEndAccess(void);
BOOL HWSetPalette(int start, int count, DWORD FAR *colors);


/***************************************************************************
 *
 * functions in DIBENG
 *
 ***************************************************************************/

extern DWORD FAR PASCAL CreateDIBPDevice    (LPBITMAPINFOHEADER lpbi, DIBENGINE FAR *lpDevice, LPVOID lpBits, WORD dwFlags);
extern UINT  FAR PASCAL DIB_Enable          (LPVOID, UINT, LPSTR, LPSTR, LPVOID);
extern UINT  FAR PASCAL DIB_Disable         (DIBENGINE FAR *);
extern LONG  FAR PASCAL DIB_Control         (DIBENGINE FAR *, UINT, LPVOID, LPVOID);
extern UINT  FAR PASCAL DIB_BeginAccess     (DIBENGINE FAR *, int left, int top, int right, int bottom, WORD flags);
extern UINT  FAR PASCAL DIB_EndAccess       (DIBENGINE FAR *, WORD flags);
extern UINT  FAR PASCAL DIB_SetPaletteExt   (UINT start, UINT count, DWORD FAR *lpPalette, DIBENGINE FAR * pde);
extern UINT  FAR PASCAL DIB_BitBlt          (DIBENGINE FAR *, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *);
extern UINT  FAR PASCAL DIB_StretchBlt      (DIBENGINE FAR *, int, int, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_StretchDIBits   (DIBENGINE FAR *, int, int, int, int, int, int, int, int, LPVOID, BITMAPINFO FAR *, LPVOID, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_DibToDevice     (DIBENGINE FAR *, int, int, int, int, RECT FAR *, DRAWMODE FAR *, LPVOID, BITMAPINFO FAR *, LPVOID);
extern UINT  FAR PASCAL DIB_Output          (DIBENGINE FAR *, int, int, POINT FAR *, DIB_Pen FAR *, DIB_Brush8 FAR *, DRAWMODE FAR *, RECT FAR *);
extern UINT  FAR PASCAL DIB_ExtTextOutExt   (DIBENGINE FAR *pde, int x, int y, RECT FAR *Clip, LPSTR sz, UINT cb, LPVOID lpFont, DRAWMODE FAR *pdm, LPVOID xform, int FAR *pdx, RECT FAR *lpORect, UINT f, LPVOID DrawBitmap, LPVOID DrawRect);
// extern UINT  FAR PASCAL DIB_SetCursorExt    (CURSORSHAPE FAR *lpCursor, DIBENGINE FAR *pde);
extern UINT  FAR PASCAL DIB_MoveCursorExt   (int x, int y, DIBENGINE FAR * pde);

#endif // _WIN32

/* Escape functions */
#define MOUSETRAILS         39
#define DCICOMMAND          3075
#define GETSURFINFO         0x6979
#define GETNVCHANNELPTR     0x6980
#define RECONFIGNVOFFSCREEN 0x6981
#define NVSETDDRAWMODE      0x6982


#ifndef DX7   // For DX7, this is defined in ddmini.h.
/* AGP stuff */
#define NV_MAX_AGP_MEMORY_LIMIT 0x1FFFFFF
#endif

/* Dma flags */
#define NV_WIN_DMA_PUSHER_IS_ACTIVE  1
#define NV_DD_DMA_PUSHER_IS_ACTIVE   2

/* Floating system memory context in use flags */
#define NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        1
#define NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        2
#define NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        4
#define NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        8
#define NV_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY       16

/* Other NV specific defines. NV3 and NV4 surface alignments have
   been changed since NV10 video scaler only supports 64 byte aligned
   surfaces. Note that changing these #defines causes ALL vidmem surfaces
   to be 64 byte aligned.
 */
#define NV3_BYTE_ALIGNMENT_PAD   15L
#define NV3_BIT_ALIGNMENT        128
#define NV4_BYTE_ALIGNMENT_PAD   31L
#define NV4_BIT_ALIGNMENT        256
#define NV10_BYTE_ALIGNMENT_PAD  63L
#define NV10_BIT_ALIGNMENT       512

#define NV10_INITIAL_PITCH    64
#define NV4_INITIAL_PITCH     32

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010

#ifndef NVD3D

#if _WIN32_WINNT < 0x0500
//*************************************************************************
// Misc stuff which changed between dx3 and dx5, Win95 and WinNT
//*************************************************************************
#define DDSCAPS_LOCALVIDMEM DDSCAPS_VIDEOMEMORY
#ifndef NV_AGP
// BUGBUG need to undefine this when AGP support arrives
#define DDSCAPS_NONLOCALVIDMEM DDSCAPS_SYSTEMMEMORY
#endif
#endif // #if _WIN32_WINNT < 0x0500
#endif  // #ifndef NVD3D

/***************************************************************************
 *
 * DEBUG stuff
 *
 ***************************************************************************/
#ifdef IS_32
#ifdef DEBUG
#if defined(_WIN32_WINNT)
#define DPF(a) DISPDBG((0, (a))
#define BREAK() EngDebugBreak();
#else
    extern void __cdecl DPF(LPSTR szFormat, ...);
    #define BREAK() DebugBreak();
#endif
#else
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif
#else
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif

#define DDRAW_SET_PRIMARY(ppdev, Offset, Stride)        \
       if (Stride < 32)                                 \
           ppdev->DdCurrentDestPitch = 32;              \
       else                                             \
           {                                            \
           ppdev->DdCurrentDestPitch = ((Stride + ppdev->ulSurfaceAlign ) & ~ppdev->ulSurfaceAlign);          \
           }                                            \
                                                        \
       ppdev->DdCurrentDestOffset = Offset;             \
       while (freeCount < 3*4)                          \
           freeCount = NvGetFreeCount(npDev, NV_DD_PRIMARY);    \
       freeCount -= 3*4;                                \
                                                        \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = ((ppdev->DdCurrentDestPitch << 16) | (ppdev->DdCurrentSourcePitch));  \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource = ppdev->DdCurrentSourceOffset;  \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = Offset

#define DDRAW_SET_SOURCE(ppdev, Offset, Stride)         \
    if (Stride < 32)                                    \
        ppdev->DdCurrentSourcePitch = 32;               \
    else                                                \
        {                                               \
        ppdev->DdCurrentSourcePitch = ((Stride + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);          \
        }                                               \
    ppdev->DdCurrentSourceOffset = Offset;              \
    while (freeCount < 3*4)                             \
        freeCount = NvGetFreeCount(npDev, NV_DD_PRIMARY);    \
    freeCount -= 3*4;                                   \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = ((ppdev->DdCurrentDestPitch <<16) | (ppdev->DdCurrentSourcePitch));    \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource = Offset;  \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = ppdev->DdCurrentDestOffset

#if (_WIN32_WINNT >= 0x0500) && defined(NV3) && !defined(DISPDRV)
#ifdef RM_HEAPMGR
#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define MEM_TYPE_PRIMARY                     8
#define MEM_TYPE_IMAGE_TILED                 9

extern BOOL __fastcall bMoveAllDfbsFromOffscreenToDibs(PDEV *);

// TBD: create a better way of allocating and freeing memory - huge macro!  Baaaadddd. -@mjl@
#define NVHEAP_ALLOC(pvm,sz,tp)             \
{                                           \
    NVOS11_PARAMETERS   HeapParams;         \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
                                            \
    if (!PPDEV()->DDrawVideoSurfaceCount)     \
    {                                       \
        PPDEV()->cbGdiHeap = PPDEV()->VideoHeapTotal -   \
        PPDEV()->VideoHeapFree;                      \
                                                                    \
    }                                       \
                                                    \
    HeapParams.hRoot = PPDEV()->hClient;  \
    HeapParams.hObjectParent = PPDEV()->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                         \
        PPDEV()->hDriver,            \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    if (!(pvm))                                                 \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(PPDEV());    \
        HeapParams.hRoot = PPDEV()->hClient;  \
        HeapParams.hObjectParent = PPDEV()->hDevice;                  \
        HeapParams.function = HEAP_ALLOC_SIZE;                      \
        HeapParams.owner    = 'NVDD';                               \
        HeapParams.type     = (tp);                                 \
        HeapParams.size     = (sz);                                 \
        EngDeviceIoControl(                         \
            PPDEV()->hDriver,            \
            (DWORD)IOCTL_NV01_ARCH_HEAP,            \
            (&pParms),                              \
            sizeof(PVOID),                          \
            pParms,                                 \
            sizeof(NVOS11_PARAMETERS),              \
            &cbReturned                             \
        );                                          \
        (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    }                                               \
    if (pvm)                                        \
        PPDEV()->VideoHeapFree = HeapParams.free;    \
}

#define NVHEAP_FREE(pvm)                    \
{                                           \
    NVOS11_PARAMETERS HeapParams;           \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
    HeapParams.hRoot = PPDEV()->hClient;      \
    HeapParams.hObjectParent = PPDEV()->hDevice; \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.owner    = 'NVDD';         \
    HeapParams.offset   = (U032)(pvm);      \
    EngDeviceIoControl(                         \
        PPDEV()->hDriver,                                \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    PPDEV()->VideoHeapFree = HeapParams.free;              \
}
#else // !RM_HEAPMGR
#define NVHEAP_INIT(strt, end, heap)  \
    heap_init((strt), (end), heap)
#define NVHEAP_INFO()
#define NVHEAP_CLEAR(heap)  \
    heap_clear(heap)
#define NVHEAP_ALLOC(pvm,sz,tp)             \
    (pvm) = heap_alloc(sz, (memory_t *) (ppdev)->heap.heap_2d_ptr);
#define NVHEAP_FREE(pvm)             \
    heap_free((pvm), (memory_t *) (ppdev)->heap.heap_2d_ptr);
#endif // !RM_HEAPMGR
#endif // NV3

//**************************************************************************************
// Common ddraw fct prototypes.
//**************************************************************************************
DWORD Nv3Blt(PDD_BLTDATA pbd);
DWORD Nv4Blt(PDD_BLTDATA pbd);
DWORD __stdcall DdCanCreateSurface(PDD_CANCREATESURFACEDATA lpCanCreateSurface );
DWORD DdCreateSurface(PDD_CREATESURFACEDATA lpCreateSurface);
DWORD __stdcall Nv3DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface );
DWORD __stdcall Nv4DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface );
DWORD __stdcall Nv3Flip(PDD_FLIPDATA pfd);
DWORD __stdcall Nv4Flip(PDD_FLIPDATA pfd);
DWORD Nv3GetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD Nv4GetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD WINAPI DdGetDriverInfo(struct _DD_GETDRIVERINFODATA *lpData);
DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD Nv3Lock(PDD_LOCKDATA lpLockData);
DWORD Nv4Lock(PDD_LOCKDATA lpLockData);
DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory);
DWORD __stdcall DdSetColorKey(PDD_SETCOLORKEYDATA lpSetColorKey);
DWORD __stdcall DdSetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
DWORD __stdcall Nv3Unlock( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv4Unlock( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv3UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData );
DWORD __stdcall Nv4UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData );
DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
#ifdef NVD3D
DWORD WINAPI GetAvailDriverMemory (PDD_GETAVAILDRIVERMEMORYDATA  pDmd);
#endif
DWORD GetScanLine32(PDD_GETSCANLINEDATA lpGetScanLine );
HRESULT Nv3UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem );
HRESULT Nv4UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem );
DWORD __stdcall Nv3UnlockOverlay( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv4UnlockOverlay( PDD_UNLOCKDATA lpUnlockData );
BOOLEAN bCreateNV4DDPatchPio(PDEV *ppdev);
BOOLEAN bDestroyNV4DDPatchPio(PDEV *ppdev);
DWORD Nv3GetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD Nv4GetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD __stdcall Nv3SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
DWORD __stdcall Nv4SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
extern DWORD __stdcall Nv3Blt8( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv3Blt16( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv3Blt32( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt8( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt16( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt32( PDD_BLTDATA pbd );

//------------------------------------------------------------------------------
// The minimum depth of the NV chip's FIFO -- never wait for the free count
// to reach a value greater than NV_GUARANTEED_FIFO_SIZE (124 bytes)!
//------------------------------------------------------------------------------

#define NV_GUARANTEED_FIFO_SIZE                 (0x007C)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\monitor.h ===
//******************************************************************************
// 
// Copyright (c) 1998  NVidia Corporation
// 
// Module Name:
// 
//     monitor.h
// 
// Environment:
// 
// Revision History:
// 
//******************************************************************************

//******************************************************************************
// 
// Copyright (c) 1998  NVidia Corporation. All Rights Reserved
// 
//******************************************************************************

#define NV_MONITOR_VGA  0
#define NV_MONITOR_NTSC 2
#define NV_MONITOR_PAL  3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\dspioctl.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     dspioctl.h
//
// Abstract:
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "nvMultiMon.h"
//******************************************************************************
// Number of dacs
//******************************************************************************
#define NV_NO_DACS                  2

//******************************************************************************
// Private IOCTL info - Used by all components of the display driver
//******************************************************************************

#define IOCTL_VIDEO_GET_VIDEO_CARD_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_RESTORE_DISPLAY_PATCH    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2050, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2051, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2052, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2053, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_VBLANK_FLAG    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2054, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_NV_PFIFO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2055, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_WRITE_COMBINING \
        CTL_CODE (FILE_DEVICE_VIDEO, 2056, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2057, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT \
        CTL_CODE (FILE_DEVICE_VIDEO, 2058, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SYSMEM_SHARE_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2059, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2060, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_LOCK_DOWN_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2061, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNLOCK_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2062, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_TO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2063, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNMAP_FROM_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2064, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_DEVICE_REF \
        CTL_CODE (FILE_DEVICE_VIDEO, 2065, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ALLOC_AGP_MEM \
        CTL_CODE (FILE_DEVICE_VIDEO, 2066, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_FREE_AGP_MEM  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2067, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_PIXMIX_INDEX \
                CTL_CODE (FILE_DEVICE_VIDEO, 2068, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_VPE_COMMAND \
        CTL_CODE (FILE_DEVICE_VIDEO, 2069, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_VAL  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2071, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_REGISTRY_VALUE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2072, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2073, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_DISPLAY_DEVICE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2075, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_DISPLAY_DEVICE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2076, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VALIDATE_DEVICE_MODE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2077, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2078, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_GAMMA_CLUT  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2079, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_MAP_PHYS_ADDR  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2080, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_PHYS_ADDR  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2081, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_SYSTEM_MEMORY_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2082, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2083, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_STOP_TIMER_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2084, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2085, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_DESKTOP_INFO_MODE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2086, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TIMING_DAC \
        CTL_CODE (FILE_DEVICE_VIDEO, 2087, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_PREMODE_SET \
        CTL_CODE (FILE_DEVICE_VIDEO, 2088, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_POSTMODE_SET \
        CTL_CODE (FILE_DEVICE_VIDEO, 2089, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TWINVIEW_STATE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2090, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_TWINVIEW_STATE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2091, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_NUMBER_DACS \
        CTL_CODE (FILE_DEVICE_VIDEO, 2092, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING \
        CTL_CODE (FILE_DEVICE_VIDEO, 2093, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SAVE_GAMMA_VALUES \
        CTL_CODE (FILE_DEVICE_VIDEO, 2094, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESTORE_GAMMA_VALUES \
        CTL_CODE (FILE_DEVICE_VIDEO, 2095, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_PCI_SLOT  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2096, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2097, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _GET_NUMBER_DACS
{
    ULONG ulNumberDacsOnBoard;          // Number of heads on the board.
    ULONG ulNumberDacsConnected;        // Number of heads connected to any device.
    ULONG ulAllDeviceMask;              // Bitmask for all connectors in the board.
    ULONG ulConnectedDeviceMask;        // Bitmask for all connected devices in the system.
    ULONG ulDeviceMask[NV_NO_DACS];     // The bitmask of device connected to the head.
                                       // defined in nvcm.h
    ULONG ulDeviceType[NV_NO_DACS];     // The type of device connected to the head viz., CRT, TV, FlatPanel
                                       // defined in nvcm.h
    ULONG ulTVFormat[NV_NO_DACS];       // The TV type: defined in nvcm.h
    ULONG ulHeadDeviceOptions[NV_NO_DACS]; // A matrix of possible device options for each head.

} GET_NUMBER_DACS;

typedef struct _HEAD_MODE_LIST_INFO
{
    ULONG ulHead;
    ULONG ulEnableDDC;
    ULONG ulDeviceMask;
    ULONG ulDeviceType;
    ULONG ulTVType;
    ULONG ulNumVirtualModes;
    MODE_ENTRY *pVirtualModeList;
    MODE_ENTRY *pPhysicalModeList;    // Caller should have allocated this memory. It is assumed that this
                                      // PhysicalModeList is atleast as big as the VirtualModeList.
} HEAD_MODE_LIST_INFO;

typedef struct _NV_DESKTOP_INFO
{
    ULONG ulDesktopMode;                // 0x0000 -> Single Monitor
    ULONG ulDesktopModeIndex;           // Display driver set the requested mode index  
    ULONG ulDesktopWidth;               // Miniport driver return the width based on the mode index
    ULONG ulDesktopHeight;              // Miniport driver return the height based on the mode index
    ULONG ulDisplayWidth[NV_NO_DACS];   // Display driver set these values; 
    ULONG ulDisplayHeight[NV_NO_DACS];  // control panel should give it to display driver
    ULONG ulDisplayRefresh[NV_NO_DACS]; // refresh rate 
    ULONG ulDisplayPixelDepth[NV_NO_DACS]; // Color Depth
    ULONG ulNumberDacsOnBoard;          // Number of DACs on the board
    ULONG ulNumberDacsConnected;        // Number of DACs which have a device (CRT/DFP/TV) connected to them
    ULONG ulNumberDacsActive;           // Number of DACs which are currently active. For example, in the Normal
                                        // mode, this value will be 1.
    ULONG ulAllDeviceMask;              // Bitmask of all output connectors in the board.
    ULONG ulConnectedDeviceMask;        // Bitmask for all connected devices in the system.
    ULONG ulDeviceMask[NV_NO_DACS];     // The bitmask of device connected to the head.
                                        // defined in nvcm.h
    ULONG ulDeviceType[NV_NO_DACS];     // The type of device connected to the head viz., CRT, TV, FlatPanel
                                        // defined in nvcm.h
    ULONG ulTVFormat[NV_NO_DACS];       // The TV type: defined in nvcm.h
    ULONG ulDeviceDisplay[NV_NO_DACS];  // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
    ULONG ulHeadDeviceOptions[NV_NO_DACS];    // A matrix of possible device options for each head. Defined in nvMultiMon.h.
                                                // This info is used mainly by the NV control panel and gets scanned in after each
                                                // modeset since this matrix can be changed by the RM after a modeset.
                                                // This is a static entity as opposed to ulDeviceType[NV_NO_DACS] which specifies
                                                // the currently selected device type for this head.

} NV_DESKTOP_INFO;

typedef struct _NV_CURSOR_INFO
{
    LONG    lCursorX;
    LONG    lCursorY;
    LONG    lCursorWidth;
    LONG    lCursorHeight;
    LONG    lScreenStride;
    LONG    lScreenPixelDepth;
    ULONG   ulHwCursorWidth;
    ULONG   ulOriginalImageMemOffset;
    ULONG   ulCursorMemOffset;
} NV_CURSOR_INFO;

typedef struct _NV_SYSMEM_SHARE_MEMORY
    {
    PVOID pSystemMdl;           // MDL for locked down memory
    PVOID userVirtualAddress;   // user virtual address
    PVOID ddVirtualAddress;     // display driver virtual address
    ULONG physicalAddress;      // physical address of memory
    ULONG byteLength;           // byte length of data to lock down
    } NV_SYSMEM_SHARE_MEMORY;


typedef struct _NV_LOCK_DOWN_MEMORY
    {
    PVOID virtualAddress; // display driver virtual address
    ULONG byteLength;     // byte length of data to lock down
    PVOID pMdl;           // MDL for locked down memory
    } NV_LOCK_DOWN_MEMORY;

typedef struct _NV_UNLOCK_MEMORY
    {
    PVOID pMdl;           // MDL for memory to unlock
    } NV_UNLOCK_MEMORY;

//
// AGP memory block node structure.
//
typedef struct _AGP_MEM
    {
    ULONG   hContext;       // Addr context of process
    ULONG   cb;             // Size of memory region in bytes
    PVOID   VirtualAddress; // Based address of Virtual AGP buffer
    } *PAGP_MEM, AGP_MEM;

//
// Registry set structure
//
typedef struct _NV_REGISTRY_STRUCT
    {
    PWSTR keyName;          // Name of key in unicode string format
    PVOID keyVal;           // pointer to key value
    ULONG keyValSize;       // Size of Key Value;
    } *PNV_REGISTRY_STRUCT, NV_REGISTRY_STRUCT;

#if _WIN32_WINNT >= 0x0500
//
// System Memory Information structure
//
typedef struct _NV_SYSMEM_INFO
    {
    ULONGLONG SystemMemorySize;      // Physical memory size in bytes
    ULONGLONG AgpAllocationLimit;    // Max recommended size in bytes for committed AGP meme
    } *PNV_SYSMEM_INFO, NV_SYSMEM_INFO;
#endif // _WIN32_WINNT >= 0x0500


typedef struct _RESOLUTION_INFO
{
    ULONG ulDisplayWidth; 			// width  
    ULONG ulDisplayHeight;  		// Height
    ULONG ulDisplayRefresh;  		// refresh rate 
    ULONG ulDisplayPixelDepth; // Color Depth
} RESOLUTION_INFO;

typedef struct _HEAD_RESOLUTION_INFO
{
    ULONG ulDisplayWidth; 			// width  
    ULONG ulDisplayHeight;  		// Height
    ULONG ulDisplayRefresh;  		// refresh rate 
    ULONG ulDisplayPixelDepth;      // Color Depth
    ULONG ulHead;                     // Whether 0 or 1. This is the physical head number
    ULONG ulDeviceMask;             // Bitmask of Device.
    ULONG ulDeviceType;             // Device type of the head.
    ULONG ulTVFormat;
} HEAD_RESOLUTION_INFO;


typedef struct _dac_timing_values
{  
    unsigned int HorizontalVisible; 
    unsigned int VerticalVisible;
    unsigned int Refresh;
    unsigned int HorizontalTotal; 
    unsigned int HorizontalBlankStart; 
    unsigned int HorizontalRetraceStart; 
    unsigned int HorizontalRetraceEnd; 
    unsigned int HorizontalBlankEnd;
    unsigned int VerticalTotal; 
    unsigned int VerticalBlankStart; 
    unsigned int VerticalRetraceStart; 
    unsigned int VerticalRetraceEnd; 
    unsigned int VerticalBlankEnd;
    unsigned int PixelClock;
    unsigned int HSyncpolarity; 
    unsigned int VSyncpolarity; 
} DAC_TIMING_VALUES;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modedata.c ===
//
// modedata.c - Data tables used for setting extended VESA modes.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    "modes.h"
#endif // DOS_COMPILE
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"

#define POLAR_NEG_NEG        0x0c0
#define POLAR_POS_NEG        0x040
#define POLAR_NEG_POS        0x080
#define POLAR_POS_POS        0x000




VGATBL   vga_tbl[] =
{
    // Basic CRTC Table for Packed Pixel Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
     0x05, 0x0F, 0xFF}
    },

    // Basic CRTC Table for Planar Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xA000,
    {0x01, 0x0F, 0x00, 0x06},
     0xE3,
    {0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C,
     0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B,
     0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x05, 0x0F, 0xFF}
    }
};

EXTREGS eregs[] =    // Extended Register Tables
{
    {0x49, 0x00, 0x20, 0x30, 0xFF, 0xFF, 0x0000, CLKID_25_175}, // 00: VGA Modes      00:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 08: Mode 5F/101    01:
    {0x48, 0x00, 0x20, 0x30, 0x32, 0xFF, 0xFA00, CLKID_40},     // 09: Mode 58/6A/102 02:
    {0x4C, 0x00, 0x20, 0x39, 0x64, 0xFF, 0xFFFF, CLKID_40},     // 0A: Mode 5C/103    03:
    {0x48, 0x00, 0x20, 0x30, 0x40, 0xFF, 0xFFFF, CLKID_65},     // 0B: Mode 5D/104    04:
    {0x4C, 0x00, 0x20, 0x39, 0x80, 0xFF, 0xFFFF, CLKID_65},     // 0C: Mode 5E/105    05:
    {0x08, 0x00, 0x15, 0x30, 0x50, 0xFF, 0xFFFF, CLKID_108_5},  // 0F: Mode 5A/106    06:
    {0x0C, 0x00, 0x15, 0x39, 0xA0, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    07:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 08:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 09:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0A:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0B:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0C:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 22: Mode 78        0D:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 23: Mode 6E        0E:
    {0x44, 0x80, 0x20, 0x3A, 0xC8, 0xFF, 0xFFFF, CLKID_40},     // 24: Mode 6F        0F:
    {0x54, 0x81, 0x20, 0x3A, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72        10:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        11:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        12:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        13:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        14:
    {0x44, 0x00, 0x20, 0x3B, 0xC8, 0xFF, 0xFFFF, CLKID_20},     // 27: Mode 20        15:
    {0x44, 0x00, 0x20, 0x3B, 0xF0, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72        16:
    {0x54, 0x01, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72        17:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        18:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 28: Mode 21        19:
    {0x54, 0x01, 0x20, 0x3B, 0x90, 0xFF, 0xFFFF, CLKID_40},     // 29: Mode 22        1A:
    {0x54, 0x01, 0x20, 0x3B, 0xE0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72        1B:
    {0x64, 0x02, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72        1C:
    {0x24, 0x02, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        1D:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x4000, CLKID_12_588}, // 27: Mode 20        1E:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x8000, CLKID_12_588}, // 27: Mode 20        1F:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x5000, CLKID_12_588}, // 27: Mode 20        20:
    {0x4C, 0x00, 0x20, 0x39, 0x32, 0xFF, 0x8000, CLKID_20},     // 27: Mode 20        21:
    {0x4C, 0x00, 0x20, 0x39, 0x3C, 0xFF, 0xB000, CLKID_27_93},  // 25: Mode 72        22:
    {0x4C, 0x00, 0x20, 0x39, 0x40, 0xFF, 0xD000, CLKID_32_5},   // 25: Mode 72        23:
    {0x4C, 0x00, 0x20, 0x39, 0x78, 0xFF, 0xFFFF, CLKID_55_86},  // 0C: Mode 5E/105    24:
    {0x0C, 0x00, 0x20, 0x39, 0x90, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        25:
    {0x0C, 0x00, 0x0F, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        26:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        27:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xA000, CLKID_12_588}, // 27: Mode 20        28:
    {0x44, 0x80, 0x20, 0x3A, 0x64, 0xFF, 0xF000, CLKID_20},     // 27: Mode 20        29:
    {0x44, 0x80, 0x20, 0x3A, 0x78, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72        2A:
    {0x44, 0x80, 0x20, 0x3A, 0x80, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72        2B:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        2C:
    {0x44, 0x80, 0x20, 0x3A, 0xF0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72        2D:
    {0x14, 0x81, 0x20, 0x3A, 0x20, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        2E:
    {0x14, 0x81, 0x15, 0x3A, 0x40, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    2F:
    {0x14, 0x81, 0x0F, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        30:
    {0x24, 0x02, 0x15, 0x3B, 0x80, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    31:
    {0x24, 0x03, 0x0F, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        32:

    // JJV - New Modes (I think this starts at 0x33 ??)
    {0x0C, 0x40, 0x0F, 0x79, 0xE1, 0xFF, 0xFFFF, CLKID_219_566}, // 33: 1800X1440X8
    {0x0C, 0x41, 0x0F, 0x7A, 0xC2, 0xFF, 0xFFFF, CLKID_219_566}, // 34: 1800X1440X16
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_172_798}, // 35: 1920X1080X8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_172_798}, // 36: 1920X1080X16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_172_798}, // 37: 1920X1080X32
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_193_156}, // 38: 1920X1200X8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_193_156}, // 39: 1920X1200X16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_193_156},  // 3A: 1920X1200X32
    // JJV - New Modes

    // VEL - New Dell Modes
    {0x0C, 0x40, 0x05, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_136_36},  // 3B: 1600x1024x8      
    {0x0C, 0x41, 0x05, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_136_36},  // 3C: 1600x1024x16     
    {0x0C, 0x43, 0x05, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_136_36}   // 3D: 1600x1024x32     
    // VEL - New Dell Modes

};

TVREGS tvregs[] =    // TV Timing Tables
{
    {0x60, 0x00, 0x67, 0x5B, 0x31, 0x2E, 0xDE, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 0 - VGA Mode 3
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xA9, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 1 - VGA Mode 11/12
    {0x60, 0x00, 0x68, 0x5B, 0x23, 0x3E, 0xDE, 0x4F, 0x4F, 0x8B, 0x85, 0x38, 0x8F, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0xA1, 0xBA, 0x30, 0x4F, 0x50, 0x00, 0x85, 0x05, 0x7F, 0xE0, 0x0D },   // TV Mode 2 - VGA Mode 13
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xD0, 0xFF, 0x0D,
     0x06, 0x82, 0x70, 0x81, 0xF8, 0x30, 0x63, 0x63, 0x8B, 0x85, 0x05, 0x00, 0xE0, 0x0D },   // TV Mode 3 - VGA Modes > 640x480
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0x90, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 4 - 640x400 Extended Modes
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D }   // TV Mode 5 - 640x480 Extended Modes
};

//
// Mode clock frequencies
//
U016 tblClockFreq[] =
{
    5035,       // 00: 50.350
    5664,       // 01: 56.644
    3325,       // 02: 33.250
    5200,       // 03: 52.000
    8000,       // 04: 80.000
    6300,       // 05: 63.000
    0000,       // 06: Ext
    7500,       // 07: 75.000 (1024x768@70)
    2518,       // 08: 25.175 (VGA)
    2832,       // 09: 28.322 (VGA)
    3150,       // 0A: 31.500 (640x480@72)
    3600,       // 0B: 36.000 (800x600@56)
    4000,       // 0C: 40.000 (800x600@60)
    4490,       // 0D: 44.900 (1024x768@87i)
    5000,       // 0E: 50.000 (800x600@72)
    6500,       // 0F: 65.000 (1024x768@60)
    10800,      // 10: 108.000/2 (1280x1024@60) use clock doubler
    13500,      // 11: 135.000/2 (1280x1024@75) use clock doubler
    4950,       // 12: 49.500
    5625,       // 13: 56.250
    7875,       // 14: 78.750
    9450,       // 15: 94.500
    10850,      // 16: 108.500/2 use clock doubler
    3550,       // 17: 35.500
    15800,      // 18: 158.000/2 use clock doubler
    5586,       // 19: 55.860
    2000,       // 1A: 20.000
    2793,       // 1B: 27.930
    3250,       // 1C: 32.500
    1259,       // 1D: 12.588 (VGA/2)
    8162,       // 1E: 81.624
    21957,      // 1F: 219.566
    17280,      // 20: 172.798
    19316,      // 21: 193.156
    22950,      // 22: 229.50 (for max dot clock)
    13636       // 23: 136.36
};

U016 DMTOverrideTable[NUMBER_OF_MODES*NUMBER_OF_RATES][13] =
{
    //0:
    // Settings for 1600x1200:
    16200, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    18900, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    20250, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    22950, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    //1:
    // Settings for 1280x1024:
    10800, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a7, 0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    13500, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a3,   0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    15750, POLAR_POS_POS, 0x0d3, 0x09f, 0x097, 0x0a9,   0x01d, 0x02e, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x02f,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    //2:
    // Settings for 1152x864:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    10800, POLAR_POS_POS, 0x0c3, 0x08f, 0x087, 0x099, 0x009, 0x082, 0x0ff, (0x061-1), (0x024-1) | 0x080, 0x05f, 0x083,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //3:
    // Settings for 1024x768:
    6500 , POLAR_NEG_NEG, 0x0a3, 0x07f, 0x087, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7500 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
// 72Hz does not appear in DMT, so this is a fudge of the GTF's
    7843 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x085, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7875 , POLAR_POS_POS, 0x09f, 0x07f, 0x083, 0x083, 0x08f, 0x01e, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x01f,
    9450 , POLAR_POS_POS, 0x0a7, 0x07f, 0x08b, 0x087, 0x093, 0x026, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x027,
// 100Hz does not appear in DMT, so this is a fudge of the GTF's
    11370, POLAR_POS_POS, 0x0a9, 0x07f, 0x08D, 0x086, 0x098, 0x02C, 0x0f5, (0x002-1), (0x024-1) | 0x080, 0x0ff, 0x027,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //4:
    // Settings for 960x720:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //5:
    // Settings for 800x600:
    4000 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x06a, 0x01a, 0x072, 0x0f0, (0x059-1), (0x02d-1) | 0x080, 0x057, 0x073,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    5000 , POLAR_POS_POS, 0x07d, 0x063, 0x081, 0x06c, 0x01b, 0x098, 0x0f0, (0x07d-1), (0x023-1) | 0x080, 0x057, 0x099,
    4950 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x067, 0x011, 0x06f, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x070,
    5625 , POLAR_POS_POS, 0x07e, 0x063, 0x082, 0x069, 0x011, 0x075, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x076,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //6:
    // Settings for 640x480:
    2517 , POLAR_NEG_NEG, 0x05f, 0x04f, 0x083, 0x053, 0x09f, 0x00b, 0x03e, (0x0ea-1), (0x02c-1) | 0x080, 0x0df, 0x00c,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    3150 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x054, 0x099, 0x006, 0x03e, (0x0e9-1), (0x02c-1) | 0x080, 0x0df, 0x007,
    3150 , POLAR_NEG_NEG, 0x064, 0x04f, 0x088, 0x053, 0x09b, 0x0f2, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0f3,
    3600 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x058, 0x09f, 0x0fb, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0fc,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //7:
    // Settings for 640x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //8:
    // Settings for 512x384:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //9:
    // Settings for 480x360:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //10:
    // Settings for 400x300:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //11:
    // Settings for 320x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //12:
    // Settings for 320x240:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //13:
    // Settings for 320x200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //14:
    // Settings for 1920x1200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //15:
    // Settings for 1920x1080:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //16:
    // Settings for 1800x1440:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //17:
    // Settings for 1600x1024:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

};

//  this table translates resolutions into their VESA BIOS mode equivalents
U016 ModeSetTable[NUMBER_OF_MODES*NUMBER_OF_DEPTHS] =
{
    // depths: 4 (planar modes), 8, 16, 24/32
    //0:
    // 1600 x 1200
    0xff, 0x145, 0x146, 0x14E,
    //1:
    // 1280 x 1024
    0x106, 0x107, 0x11a, 0x14D,
    //2:
    // 1152 x 864
    0xff, 0x141, 0x142, 0x143,
    //3:
    // 1024 x 768
    0x104, 0x105, 0x117, 0x118,
    //4:
    // 960 x 720
    0xff, 0x14a, 0x14b, 0x14c,
    //5:
    // 800 x 600
    0x102, 0x103, 0x114, 0x115,
    //6:
    // 640 x 480
    0xff, 0x101, 0x111, 0x112,
    //7:
    // 640 x 400
    0xff, 0x100, 0x13d, 0x13e,
    //8:
    // 512 x 384
    0xff, 0x13a, 0x13b, 0x13c,
    //9:
    // 480 x 360
    0xff, 0x147, 0x148, 0x149,
    //10:
    // 400 x 300
    0xff, 0x137, 0x138, 0x139,
    //11:
    // 320 x 400
    0xff, 0x131, 0x132, 0x133,
    //12:
    // 320 x 240
    0xff, 0x134, 0x135, 0x136,
    //13:
    // 320 x 200
    0xff, 0x130, 0x10e, 0x10f,

    //14:
    // 1920 x 1200
    0xff, 0x154, 0x155, 0x156,
    //15:
    // 1920 x 1080
    0xff, 0x151, 0x152, 0x153,
    //16:
    // 1800 x 1440
    0xff, 0x14f, 0x150, 0xff,

    //17:
    // 1600 x 1024
    0xff, 0x157, 0x158, 0x159


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\minii2c.c ===
/*----------------------------------------------------------------------------*/
/*
 * minii2c.c
 *
 *  I2C functionality for the miniport
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#ifdef NVPE

//#define INITGUID     // Instantiate GUID_I2C_INTERFACE

#include <ntstatus.h>
#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
typedef unsigned int    UINT;

#include "nv.h"
#include "nv32.h"
#include "nvos.h"

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif
#define PDEVICE_OBJECT  PVOID
#include "i2cgpio.h"

#define WDM_TO_VPE_COMMAND_MASK 0xdead0000

// backdoor VPE command functions
ULONG nvVPECommand(PHW_DEVICE_EXTENSION pHwDevExt, ULONG cmd, PVOID pData);
U032 vddWriteVPEPrescale(PHW_DEVICE_EXTENSION pHwDevExt, U032 ulX, U032 ulY, 
                         U032 ulCap, U032 ulVPUseOverlay, U032 ulFlag);

////////////////////////
// BUGBUG: The following section is extracted from nvmisc.h.
//         The miniport has no access to the nvidia\sdk directory !!!
//
//#include "nvmisc.h"
//
// control struct and defines for NvRmI2CAccess()
//
typedef struct
{
    unsigned long   token;
    unsigned long   cmd;
    unsigned long   port;
    unsigned long   flags;
    unsigned long   data;
    unsigned long   status;
} NVRM_I2C_ACCESS_CONTROL;

// commands
#define NVRM_I2C_ACCESS_ACQUIRE         1
#define NVRM_I2C_ACCESS_RELEASE         2
#define NVRM_I2C_ACCESS_WRITE_BYTE      3
#define NVRM_I2C_ACCESS_READ_BYTE       4
#define NVRM_I2C_ACCESS_NULL            5
#define NVRM_I2C_ACCESS_RESET           6

// flags
#define NVRM_I2C_ACCESS_START_FLAG      0x1
#define NVRM_I2C_ACCESS_STOP_FLAG       0x2
#define NVRM_I2C_ACCESS_ACK_FLAG        0x4

// port
#define NVRM_I2C_ACCESS_PRIMARY_PORT    1
#define NVRM_I2C_ACCESS_SECONDARY_PORT  2

// End of extracted section
//////////////////////////////////////////////

/*----------------------------------------------------------------------------*/
/*
 * misc defines and prototypes
 */

#define MINI_I2C_UNINITIALIZED  0
#define MINI_I2C_INITIALIZED    1
#define MINI_I2C_ACQUIRED   2

#define MINI_I2C_BASE_INST  0xa50f0001

extern ULONG i2cAccess(PVOID, U032, NVRM_I2C_ACCESS_CONTROL *);

/*----------------------------------------------------------------------------*/
/*
 * globals
 *
 */

static UINT     miniI2Cstate = MINI_I2C_UNINITIALIZED;
extern PHWINFO NvDBPtr_Table[];
static NVRM_I2C_ACCESS_CONTROL  rmI2CCtrl;


/*----------------------------------------------------------------------------*/
/*
 * miniI2COpen() - NV version of I2COpen()
 */

NTSTATUS miniI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT        acquire,
    PI2CControl     pI2CCtrl )
{

    UINT            rc;
    NTSTATUS            result = STATUS_SUCCESS;    /* just to be safe */
    PHWINFO         pNvInfo;
    PHW_DEVICE_EXTENSION pHwDevExt;
    ULONG           head = 0;

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));

    pNvInfo = NvDBPtr_Table[pHwDevExt->DeviceReference];

     /*
     * check for WDM backdoor to VPE request  (This is allow WDM drivers to set
     * some VPE parameters that aren't or can't be set by WDM's overlay mixer.)
     */

    if ( (pI2CCtrl->Command & 0xffff0000) == WDM_TO_VPE_COMMAND_MASK ) {
        rc = nvVPECommand (pHwDevExt, (pI2CCtrl->Command & 0x0000ffff), (void*) pI2CCtrl);
        pI2CCtrl->Status = rc;
        return rc;
    }

    /*
     * acquire/release I2C service
     */

    if ( acquire == TRUE ) {

    if ( miniI2Cstate == MINI_I2C_ACQUIRED ) {

        /* 
         * I2C has already been acquired, return error 
         */

        pI2CCtrl->dwCookie = 0;
        pI2CCtrl->Status = I2C_STATUS_BUSY;

        result = STATUS_OPEN_FAILED;

    }
    else {

        /* 
         * I2C is available so attempt to acquire it 
         */

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_ACQUIRE;
        rmI2CCtrl.port = NVRM_I2C_ACCESS_SECONDARY_PORT;
        rmI2CCtrl.flags = 0;

        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

        if ( rc != 0 ) {

        /* unable to get I2C service */
        pI2CCtrl->dwCookie = 0;
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_OPEN_FAILED;

        }
        else {

        /* I2C service was obtained */
        pI2CCtrl->dwCookie = MINI_I2C_BASE_INST; /* for lack of better cookie */
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        miniI2Cstate = MINI_I2C_ACQUIRED;
        result = STATUS_SUCCESS;

        }

    }

    }
    else {

    if ( (miniI2Cstate != MINI_I2C_ACQUIRED) || (pI2CCtrl->dwCookie != MINI_I2C_BASE_INST) ) {

        /* 
         * I2C has not been previously "acquired" or cookie is wrong 
         */

        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_INVALID_HANDLE;

    }
    else {

        /* 
         * I2C was previously acquired and cookie is valid, so ok to "release" 
         */

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_RELEASE;
        rmI2CCtrl.port = NVRM_I2C_ACCESS_SECONDARY_PORT;
        rmI2CCtrl.flags = 0;

        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

        if ( rc != 0 ) {

        /* error in releasing I2C */
        pI2CCtrl->dwCookie = 0;
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_OPEN_FAILED;

        }
        else {

        /* I2C released */
        pI2CCtrl->dwCookie = 0;
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
        miniI2Cstate = MINI_I2C_INITIALIZED;  /* ready to be acquired again */

        }

    }

    }

    return(result);

}

/*----------------------------------------------------------------------------*/
/*
 * miniI2CAccess - NV version of I2CAccess()
 */

NTSTATUS miniI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{
    UINT            rc;
    ULONG           startFlag;
    ULONG           stopFlag;
    ULONG           ackFlag;
    NTSTATUS            result = STATUS_SUCCESS;
    ULONG           readData = 0;
    //NVRM_I2C_ACCESS_CONTROL   rmI2CCtrl;
    PHWINFO         pNvInfo;
    PHW_DEVICE_EXTENSION pHwDevExt;
    ULONG           head = 0;

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));
    pNvInfo = NvDBPtr_Table[pHwDevExt->DeviceReference];

    /*
     * make sure I2C has been acquired
     */

    if ( (miniI2Cstate == MINI_I2C_UNINITIALIZED) || 
     (miniI2Cstate == MINI_I2C_INITIALIZED) ||
     (pI2CCtrl->dwCookie != MINI_I2C_BASE_INST) ) {

        pI2CCtrl->Status = I2C_STATUS_ERROR;
    return(STATUS_INVALID_HANDLE);

    }

    /*
     * retrieve the flags we can deal with
     */

    startFlag = pI2CCtrl->Flags & I2C_FLAGS_START;
    stopFlag = pI2CCtrl->Flags & I2C_FLAGS_STOP;
    ackFlag = pI2CCtrl->Flags & I2C_FLAGS_ACK;

    rmI2CCtrl.flags = 0;

    if ( startFlag ) {
    rmI2CCtrl.flags |= NVRM_I2C_ACCESS_START_FLAG;
    }

    if ( stopFlag ) {
    rmI2CCtrl.flags |= NVRM_I2C_ACCESS_STOP_FLAG;
    }

    if ( ackFlag ) {
    rmI2CCtrl.flags |= NVRM_I2C_ACCESS_ACK_FLAG;
    }

    /*
     * handle the command
     */

    rmI2CCtrl.port = NVRM_I2C_ACCESS_SECONDARY_PORT;

    switch ( pI2CCtrl->Command ) {

      case I2C_COMMAND_WRITE:

    rmI2CCtrl.cmd = NVRM_I2C_ACCESS_WRITE_BYTE;
    rmI2CCtrl.data = pI2CCtrl->Data;
        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

    if ( rc == 0 ) {
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_ADAPTER_HARDWARE_ERROR;
    }

        break;

      case I2C_COMMAND_READ:

    rmI2CCtrl.cmd = NVRM_I2C_ACCESS_READ_BYTE;
        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

    if ( rc == 0 ) {
        pI2CCtrl->Data = (BYTE) (rmI2CCtrl.data & 0xFF);             // returned byte
        pI2CCtrl->Reserved[0] = (BYTE)((rmI2CCtrl.data >> 8) & 0xFF);
        pI2CCtrl->Reserved[1] = (BYTE)((rmI2CCtrl.data >> 16) & 0xFF);
        pI2CCtrl->Reserved[2] = (BYTE)((rmI2CCtrl.data >> 24) & 0xFF);
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_ADAPTER_HARDWARE_ERROR;
    }

        break;

      case I2C_COMMAND_NULL:

    rmI2CCtrl.cmd = NVRM_I2C_ACCESS_NULL;
        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

    if ( rc == 0 ) {
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_ADAPTER_HARDWARE_ERROR;
    }

        break;

      case I2C_COMMAND_STATUS:

    if ( miniI2Cstate == MINI_I2C_ACQUIRED ) {
        /* nothing is going on just return success */
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        /* not applicable since we're synchronous but return something reasonable just in case */
        pI2CCtrl->Status = I2C_STATUS_BUSY;
        result = STATUS_DEVICE_BUSY;
    }

        break;

      case I2C_COMMAND_RESET:

    rmI2CCtrl.cmd = NVRM_I2C_ACCESS_NULL;
        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

    if ( rc == 0 ) {
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_ADAPTER_HARDWARE_ERROR;
    }

        break;

      default:
    
    pI2CCtrl->Status = I2C_STATUS_ERROR;
    result = STATUS_INVALID_PARAMETER;

        break;

    }

    return(result);

}

/*
 * nvVPECommand() is a backdoor function to allow other Ring0 programs (like WDM)
 * to change or request various VPE functions.
 */

#define NV_VPE_CMD_SET_PRESCALE_MODE    1
#define NV_VPE_CMD_SET_CROP_MODE        2

ULONG nvVPECommand (
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG cmd,
    PVOID pData )
{

    switch ( cmd ) {

    case NV_VPE_CMD_SET_PRESCALE_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to prescale
         * as oppose to cropping.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * set prescale flag and size
             */
            //Data(lower nibble)    =   0   not capturing
            //                          1   capturing
            //Data(upper nibble)    =   2   X scale
            //                          4   Y scale
            //Status    =   prescale/height * 1000
            if((pI2CCtrl->Data)& 0x40){
                vddWriteVPEPrescale(pHwDevExt,
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Status,//set Y-prescale 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    6);                             //prog. y-pre & cap. flag
            }else if((pI2CCtrl->Data)& 0x20){
                vddWriteVPEPrescale(pHwDevExt,
                                    ((PI2CControl)pI2CCtrl)->Status,//set X-prescale
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    0xa);                           //prog. x-pre & cap.flag
            }else if(!((pI2CCtrl->Data)& 0x1)){
                vddWriteVPEPrescale(pHwDevExt,
                                    0,
                                    0, 
                                    0,  //capture flag=0 (not capturing)
                                    0, 
                                    0x2);   
            }
        }
        break;

    case NV_VPE_CMD_SET_CROP_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to crop
         * as oppose to prescaling.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * turn off prescale flag
             */

        }
        break;

    default:
        return 1;   
    }

    return 0;
}

void nvpeVDDInit(PHW_DEVICE_EXTENSION pHwDevExt)
{
    //Initialize VPE capture hack for WDM
    vddWriteVPEPrescale(pHwDevExt,
                        1000,   //setting ME X-prescale factor. 1000=no scale
                        1000,   //setting ME Y-prescale factor. 1000=no scale
                        0,      //set to not vpe capture mode 
                        0,      //set default VP surf type = overlay 
                        0xf);   //use all values

}

// A mechanism to populate the WDM prescale values
// This is a back door mechanism and should not really be in this module.
U032 vddWriteVPEPrescale(PHW_DEVICE_EXTENSION pHwDevExt, U032 ulX, U032 ulY, 
                         U032 ulCap, U032 ulVPNotUseOverlay, U032 ulFlag)
{
    PNVP_CONTEXT pVPEContext;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "nvpekmvt: vddWriteVPEPrescale()\n");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    
    if(ulFlag & 0x8){
        pVPEContext->ulVPECapturePrescaleXFactor=ulX;
    }

    if(ulFlag & 0x4){
        pVPEContext->ulVPECapturePrescaleYFactor=ulY;
    }

    if(ulFlag & 0x2){
        pVPEContext->ulVPECaptureFlag=ulCap;
    }

    if(ulFlag & 0x1){
        pVPEContext->ulVPNotUseOverSurf=ulVPNotUseOverlay;
    }


    return 0;
}

#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modehw.c ===
//
// modehw.c -  OS specific NV register access routines for mode set code.
//
// These Win NT specific routines access the NV3 through a series of NV
// engine pointers contained in the global HwDeviceExtension and frame
// buffer pointer, fbAddr.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"
#include "nv3a_ref.h"

#include "modes.h"

PHW_DEVICE_EXTENSION HwDeviceExtension;
PHWREG fbAddr;

//******************************************************************************
// External function declarations
//******************************************************************************

// write a dword value to a fb address
VOID WriteFb32(U032 datum, U032 addr)
{
    MEM_WR32(addr, datum);
}


// read a dword value from a fb address
U032 ReadFb32(U032 addr)
{
    return MEM_RD32(addr);
}


// write a dword value to an NV register
// assume extended CRTC registers are unlocked
VOID WritePriv32(U032 datum, U032 addr)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR32(PRMVIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR32(PRMCIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRAMDAC) && addr < DEVICE_BASE(NV_PRAMDAC) + DEVICE_EXTENT(NV_PRAMDAC))
    {
        PRAMDAC_REG_WR32(PRAMDAC_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PFB) && addr < DEVICE_BASE(NV_PFB) + DEVICE_EXTENT(NV_PFB))
    {
        PFB_REG_WR32(PFB_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PMC) && addr < DEVICE_BASE(NV_PMC) + DEVICE_EXTENT(NV_PMC))
    {
        PMC_REG_WR32(PMC_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PEXTDEV) && addr < DEVICE_BASE(NV_PEXTDEV) + DEVICE_EXTENT(NV_PEXTDEV))
    {
        PEXTDEV_REG_WR32(PEXTDEV_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PBUS) && addr < DEVICE_BASE(NV_PBUS) + DEVICE_EXTENT(NV_PBUS))
    {
        PBUS_REG_WR32(PBUS_Base, addr, datum);
        return;
    }

    // catch bad ranges
    //DebugBreakPoint();
}


// read a dword value from an NV register
U032 ReadPriv32(U032 addr)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        return PRMVIO_REG_RD32(PRMVIO_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        return PRMCIO_REG_RD32(PRMCIO_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PRAMDAC) && addr < DEVICE_BASE(NV_PRAMDAC) + DEVICE_EXTENT(NV_PRAMDAC))
    {
        return PRAMDAC_REG_RD32(PRAMDAC_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PFB) && addr < DEVICE_BASE(NV_PFB) + DEVICE_EXTENT(NV_PFB))
    {
        return PFB_REG_RD32(PFB_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PMC) && addr < DEVICE_BASE(NV_PMC) + DEVICE_EXTENT(NV_PMC))
    {
        return PMC_REG_RD32(PMC_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PEXTDEV) && addr < DEVICE_BASE(NV_PEXTDEV) + DEVICE_EXTENT(NV_PEXTDEV))
    {
        return PEXTDEV_REG_RD32(PEXTDEV_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PBUS) && addr < DEVICE_BASE(NV_PBUS) + DEVICE_EXTENT(NV_PBUS))
    {
        return PBUS_REG_RD32(PBUS_Base, addr);
    }

    // catch bad ranges
    //DbgBreakPoint();

	return(0);
}

// write a data word to Priveledged IO
VOID WriteIndexed(U032 addr, U016 datum)
{
    //
    // Keep it 8bit to be safe; index in lower byte, data in upper
    //
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, datum & 0xFF);
        PRMVIO_REG_WR08(PRMVIO_Base, addr+1, (datum >> 8) & 0xFF);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, datum & 0xFF);
        PRMCIO_REG_WR08(PRMCIO_Base, addr+1, (datum >> 8) & 0xFF);
        return;
    }

    // catch bad ranges
    //DbgBreakPoint();

}


// write a data byte to Priveledged IO
VOID WritePriv08(U032 addr, U008 datum)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_USER_DAC) && addr < DEVICE_BASE(NV_USER_DAC) + DEVICE_EXTENT(NV_USER_DAC))
    {
        USERDAC_REG_WR08(USERDAC_Base, addr, datum);
        return;
    }

    // catch bad ranges
    //DbgBreakPoint();

}

// read a data word from Priveledged IO
U016 ReadIndexed(U032 addr, U008 reg)
{
    U016   datum;

    //
    // Return the data in the upper byte, index in the lower
    //
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, reg);
        datum = (PRMVIO_REG_RD08(PRMVIO_Base, addr+1) << 8) & 0xFF00;
        datum |= reg;
        return datum;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, reg);
        datum = (PRMCIO_REG_RD08(PRMCIO_Base, addr+1) << 8) & 0xFF00;
        datum |= reg;
        return datum;
    }

    // catch bad ranges
    //DbgBreakPoint();

	return(0);
}


// end of modehw.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modes.h ===
//
// MODES.H - Header file for mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines and structures for use with the 'C' based modeset code.
//
//

#ifdef DOS_COMPILE
typedef unsigned long U032;
typedef unsigned short U016;
typedef unsigned char U008;
#define VOID void
#endif


#define PACKED  0
#define PLANAR  1

#define NVRM_ACCESS         0x38
#define NVRM_ACCESS_MASK    0x01
#define NVRM_IDENT          0x00
#define NVRM_ADDRESS        0x02
#define NVRM_DATA           0x04
#define NVRM_DATA32         0x06
#define NVRM_SELECT_MASK    0x06    // Mask for decode bits
#define NVRM_SELECT         0x01    // Least signifcant bit is 1

#ifdef DOS_COMPILE
//
// These defines are the standard NV defines... the appropriate include
// file should be utilized, rather than these values.
//
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB       0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB       0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB       0x00000002 /* RW--V */
#define NV_PRMVIO_MISC__WRITE              0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                      0x000C03c4 /* RW-1R */
#define NV_PRMVIO_GRX                      0x000C03ce /* RW-1R */
#define NV_PFB_BOOT_0                      0x00100000 /* RW-4R */
#define NV_PFB_CONFIG_0                    0x00100200 /* RW-4R */
#define NV_PRMCIO_ARX                      0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ         0x006013c1 /* R--1R */
#define NV_PRMCIO_CRX__COLOR               0x006013d4 /* RW-1R */
#define NV_PRMCIO_INP0__COLOR              0x006013da /* R--1R */
#define NV_PRAMDAC_VPLL_COEFF              0x00680508 /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT        0x0068050C /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL         0x00680600 /* RW-4R */
#define NV_USER_DAC_PIXEL_MASK             0x006813C6 /* RWI1R */
#define NV_USER_DAC_READ_MODE_ADDRESS      0x006813C7 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS     0x006813C8 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA           0x006813C9 /* RW-1R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO  28    /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE 16    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE     12    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE      4    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE     8    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC          20    /* RWIVF */
#define NV_PFB_CONFIG_0_TILING                  12    /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DISABLED    0x00000001 /* RWI-V */
#endif // DOS_COMPILE


#define CRYSTAL_FREQ143         14318180           // 14.318,180 MHz
#define CRYSTAL_FREQ135         13500000           // 13.500,180 MHz
#define CRYSTAL_FREQ143KHZ      14318              // 14318 kHz
#define CRYSTAL_FREQ135KHZ      13500              // 13500 kHz

//
// VBE3.0-based CRTC Timings Table
//
typedef struct gtf_timings_structure
{
    U016    horiz_total;
    U016    horiz_start;
    U016    horiz_end;
    U016    vertical_total;
    U016    vertical_start;
    U016    vertical_end;
    U008    flags;
    U032    dot_clock;
    U016    refresh;
} GTF_TIMINGS, *PGTF_TIMINGS;

//
// DMT Override Table
//
typedef struct DMT_Overrides_structure
{
    U016    DotClock;
    U016    Polarity;
    U016    CR0;
    U016    CR2;
    U016    CR3;
    U016    CR4;
    U016    CR5;
    U016    CR6;
    U016    CR7;
    U016    CR10;
    U016    CR11;
    U016    CR15;
    U016    CR16;

} DMT_OVERRIDES, *PDMT_OVERRIDES;

//
// State flags for GTF structure
//
#define GTF_FLAGS_SINGLE_SCANNED    0x00
#define GTF_FLAGS_DOUBLE_SCANNED    0x01
#define GTF_FLAGS_NON_INTERLACED    0x00
#define GTF_FLAGS_INTERLACED        0x02
#define GTF_FLAGS_HSYNC_POSITIVE    0x00
#define GTF_FLAGS_HSYNC_NEGATIVE    0x04
#define GTF_FLAGS_VSYNC_POSITIVE    0x00
#define GTF_FLAGS_VSYNC_NEGATIVE    0x08


// Standard VGA Mode Table Structure
typedef struct _seq_
{
    U008 ClockMode;
    U008 MapMask;
    U008 FontAddr;
    U008 MemMode;
} SEQ;

typedef struct  _crtc_
{
    U008   HTotal;
    U008   HDispEnd;
    U008   HBlankS;
    U008   HBlankE;
    U008   HSyncS;
    U008   HSyncE;
    U008   VTotal;
    U008   Overflow;
    U008   PresetRowScan;
    U008   CellHeight;
    U008   CursorS;
    U008   CursorE;
    U008   RegenSHigh;
    U008   RegenSLow;
    U008   CursorPosHigh;
    U008   CursorPosLow;
    U008   VSyncS;
    U008   VSyncE;
    U008   VDispE;
    U008   RowOffset;
    U008   ULineRow;
    U008   VBlankS;
    U008   VBlandE;
    U008   Mode;
    U008   LineCompare;
} CRTC;

typedef struct  _gr_
{
    U008   SetReset;
    U008   EnableSetReset;
    U008   ColorCmp;
    U008   ROP;
    U008   ReadMap;
    U008   Mode;
    U008   Misc;
    U008   CDC;
    U008   BitMask;
} GR;

// Standard VGA Mode Table format.
typedef struct _vga_mode_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U016  RegenLenght;
    SEQ     seq_regs;              // SR1-4
    U008   PT_Misc;               // Misc Register
    CRTC    crtc_regs;             // CR0-18
    U008   PT_ATC[20];            // Attribute Controller
    GR      gr_regs;               // GR0-8
} VGATBL;

// Indexes into the clock table
#define MAX_DCLK    0x1F            // 229.50 Mhz
#define MAX_ATC     0x16            // 108 Mhz

#define    CLKID_50_35     0x00
#define    CLKID_56_64     0x01
#define    CLKID_33_25     0x02
#define    CLKID_52        0x03
#define    CLKID_80        0x04
#define    CLKID_63        0x05
#define    CLKID_EXT       0x06
#define    CLKID_75        0x07
#define    CLKID_25_175    0x08
#define    CLKID_28_322    0x09
#define    CLKID_31_5      0x0A
#define    CLKID_36        0x0B
#define    CLKID_40        0x0C
#define    CLKID_44_9      0x0D
#define    CLKID_50        0x0E
#define    CLKID_65        0x0F
#define    CLKID_108       0x10        // Requires clock doubler
#define    CLKID_135       0x11        // Requires clock doubler
#define    CLKID_49_5      0x12
#define    CLKID_56_25     0x13
#define    CLKID_78_75     0x14
#define    CLKID_94_5      0x15
#define    CLKID_108_5     0x16        // Requires clock doubler
#define    CLKID_35_5      0x17
#define    CLKID_158       0x18        // Requires clock doubler
#define    CLKID_55_86     0x19
#define    CLKID_20        0x1A
#define    CLKID_27_93     0x1B
#define    CLKID_32_5      0x1C
#define    CLKID_12_588    0x1D
#define    CLKID_81_62     0x1E
#define    CLKID_219_566   0x1F
#define    CLKID_172_798   0x20
#define    CLKID_193_156   0x21
#define    CLKID_229_5     0x22
#define    CLKID_136_36    0x23

// Video Mode Control Structure
typedef struct _vmode_
{
    U016  mdVMode;                // Mode Number of this mode
    U008   mdMode;                 // Internal Mode Number
    U008   mdIMode;                // Standard Mode Table Index
    U008   mdEMode;                // Extended Mode Table Index
    U008   mdTVMode;               // TV Mode Table Index
    U008   mdCMode;                // Extended CRTC Override Index
    U008   mdBPP;                  // Bits per Pixel
    U016  mdXRes;                 // X resolutio
    U016  mdYRes;                 // Y resolutionn
    U016  mdRowOff;               // Scanline Row Offset
    U016  mdMaxDotClock;          // Maximum DCLK

} MODEDESC;


typedef struct _ext_regs_
{
                            // ++++------- Reserved
                            // |||| +----- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| |+---- CR1C[2] - Sequential Chain 4
                            // |||| ||+--- CR1C[1] - Page Select Control
                            // |||| |||+-- CR1A[0] - Address Wrap
    U008   xrFlags;         // VVVV VVVV
                            // 7654 3210

                            // +---------- NV_PRAMDAC_GENERAL_CONTROL[12] - 565_MODE
                            // |+++------- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| +----- CR25[5] - Bit 11 of offset
                            // |||| |+++-- CR19[7:5] - Bits 8->10 of Offset
    U008   xrOffset;        // VVVV VVVV
                            // 7654 3210

                            // ++--------- CR2D[3:2] - Bit 8 of HRetrace & HBlank Starts
                            // ||+-------- CR1A[2] - Large Screen bit
                            // |||+------- CR25[4] - Bit 6 of HBlank End
                            // |||| ++---- Bit 10 of VBlank & VRetrace Start
                            // |||| ||++-- VDisp End, VTotal
    U008   xrVOver;         // VVVV VVVV
                            // 7654 3210

                            // ++--------- CR2D[1:0] - Bit 8 of DHisp End and HTotoal
                            // ||++------- CR1C[4:3] - Optimized chain-4 write/read access
                            // |||| +----- CR28[3] - NV_PRAMDAC_PLL_COEFF_SELECT[28]
                            // |||| |                VCLK Divide by 1 or 2
                            // |||| |+---- CR28[2] - Linear/Tile mode
                            // |||| ||++-- CR28[1:0] - Pixel Format
    U008   xrPixFmt;        // VVVV VVVV
                            // 7654 3210

    U008   xrVOffset;      // CR13 - VGA Offset register
    U008   xrIntlace;      // CR39 - Interlace Half Field Start
    U016  xrRegenLength;   // Override of PT_RegenLength (res+color depth specific)
    U008   xrClkSel;       // Pixel Clock Select

} EXTREGS;

typedef struct _tv_regs_
{
    U008   tvIntlace;              // CRTC[39] (Interlace Half Field Start)
    U008   tvDecimate_NTSC;        // CRTC[29] (Decimate for TV)
    U008   tvHT_NTSC;              // CRTC[00] (Horiztonal total for NTSC)
    U008   tvHRS_NTSC;             // CRTC[04] (Horizontal retrace start for NTSC)
    U008   tvVT_NTSC;              // CRTC[06] (Vertical total for NTSC)
    U008   tvVO_NTSC;              // CRTC[07] (Vertical overflow for NTSC)
    U008   tvVRS_NTSC;             // CRTC[10] (Vertical retrace start for NTSC)
    U008   tvHDE_NTSC;             // CRTC[01] (Horizontal Display End)
    U008   tvHBS_NTSC;             // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_NTSC;             // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_NTSC;             // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_NTSC;             // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_NTSC;             // CRTC[12] (Vertical Display End)
    U008   tvVBS_NTSC;             // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_NTSC;             // CRTC[16] (Vertical Blank End)
    U008   tvDecimate_PAL;         // CRTC[29] (Decimate for TV)
    U008   tvHT_PAL;               // CRTC[00] (Horiztonal total for PAL)
    U008   tvHRS_PAL;              // CRTC[04] (Horizontal retrace start for PAL)
    U008   tvVT_PAL;               // CRTC[06] (Vertical total for PAL)
    U008   tvVO_PAL;               // CRTC[07] (Vertical overflow for PAL)
    U008   tvVRS_PAL;              // CRTC[10] (Vertical retrace start for PAL)
    U008   tvHDE_PAL;              // CRTC[01] (Horizontal Display End)
    U008   tvHBS_PAL;              // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_PAL;              // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_PAL;              // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_PAL;              // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_PAL;              // CRTC[12] (Vertical Display End)
    U008   tvVBS_PAL;              // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_PAL;              // CRTC[16] (Vertical Blank End)

} TVREGS;

// CRTC Override Structure. This structure overrides the settings selected
// from the standard modeset mode table.
//
typedef struct _crtc_ovr_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U008   CO_Misc;                // Misc Register
    U008   CO_ClockMode;           // SR1
    U008   HTotal;                 // CR00
    U008   HDispEnd;               // CR01
    U008   HBlankS;                // CR02
    U008   HBlankE;                // CR03
    U008   HSyncS;                 // CR04
    U008   HSyncE;                 // CR05
    U008   VTotal;                 // CR06
    U008   Overflow;               // CR07
    U008   CO_CellHeight;          // CR09
    U008   CO_VSyncStart;          // CR10
    U008   VSyncE;                 // CR11
    U008   VDispE;                 // CR12
    U008   CO_VBlankStart;         // CR15
    U008   VBlandE;                // CR16

}CRTC_OVERRIDE;

//
// Fifo settings
//
typedef struct _modeset_fifo_
{
    U016  Freq;                   // Maximum frequency for these water marks
    U008   LowWaterMark64;         // Low water mark for 64 bit bus
    U008   BurstSize64;            // Burst size for 64 bit bus
    U008   LowWaterMark128;        // Low water mark for 128 bit bus
    U008   BurstSize128;           // Burst size for 128 bit bus

} MODESET_FIFO;

//
// CRTC access state (for dos compile)
//
typedef struct _save_astate_
{
    U016   crtc_addr;          // CRTC Address
    U032   nv_address;         // 32-bit NV address
    U008   access_bits;        // Access Control Bits
    U008   access_reg;         // Access Register (NVRM_ACCESS)
    U016   data_low;           // Low 32-bits of data register
} ACCESS_STATE;


//
// Modeset function prototypes
//
VOID NvPost(VOID);
U016 VBESetMode(U016, PGTF_TIMINGS,PDMT_OVERRIDES,U016);         // VESA SetMode
U016 VBESetRefresh(PGTF_TIMINGS);
MODEDESC *ValidateMode(U016 );    // Validate VESA Mode
U008 isTV(VOID);
U008 OEMValidateMode(MODEDESC *);
U016 OEMGetMemSize(VOID);
VOID SaveNVAccessState(ACCESS_STATE *);
VOID RestoreNVAccessState(ACCESS_STATE *);
U032 ReadPriv32(U032 );
U016 ReadIndexed(U032 , U008 );
VOID WriteIndexed(U032, U016);
VOID OEMPreSetRegs(VOID);
VOID SetRegs(MODEDESC *);
VOID LoadIndexRange(U032, U008, U008, U008 *);
VOID ATCOff(VOID);
VOID ATCOn(VOID);
VOID OEMSetRegs(MODEDESC *);
VOID FullCpuOn(VOID);
VOID FullCpuOff(VOID);
U032 CalcMNP(U016 *);
VOID OEMSetClock(U016 );
VOID WritePriv32(U032 , U032 );
VOID LoadDefaultATCAndSavePtr(U008 *);
VOID LoadDefaultRAMDAC(MODEDESC *);
VOID LoadPalette(MODEDESC *);
VOID LoadColorDACTable(VOID);
VOID LoadColor256DAC(VOID);
VOID LoadIdentityDAC(VOID);
VOID WriteColor(U008 );
VOID WriteColor2(U016 , U016 , U016 , U016 );
VOID FixLowWaterMark(U016 );
VOID SetDACClock(U032 );
VOID WritePriv08(U032 , U008 );
U016 h2i(U008 *);                // Hex 2 Integer
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modesetNT.c ===
//
// modeset.c -  Program to set a VESA mode. Assumes the controller is
//              already initialized.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifndef NTMINIPORT

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    <stdlib.h>
#else
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <vga.h>
#endif // DOS_COMPILE

#include    "modes.h"
#include    "modedata.c"
#include    "modehw.h"
#include "nvhw.h"

#else

//*****************************************************************************
//
// NV1/NV3/NV4 conventions...
//
//       This modeset code was originally designed to be compiled for each
//       version of the chip (NV1/NV3/NV4).  However, this miniport was designed
//       to work with ALL versions of the chip.  That is, the original modeset
//       code had to be compiled for each chip.  But since this miniport
//       determines which chip it's running on at RUN time (i.e. we don't
//       compile several versions of the miniport) we need to use the following
//       convention:
//
//          THIS MODULE SHOULD ONLY CONTAIN NV3 SPECIFIC CODE
//          (OR CODE THAT HAS NOT CHANGED ACROSS CHIPS) !!
//
//       Mainly because NV_REF.H already includes NV3_REF.H.
//       For code which is different from NV3, that code
//       should exist separately in NV4.C/NV5.C/...etc...
//
//       We'll follow the convention that the Miniport decides at runtime
//       which chip it's running on (i.e. only ONE miniport instead of
//       compiling several versions for each type of chip).
//
//*****************************************************************************

//*****************************************************************************
//
// ModeSet Code differences between chips:
//
//       NV3:   - CRTC registers are locked using NV_PRMVIO_SR_LOCK
//                (See OEMEnableExtension/OEMDisableExtension)
//
//              - 565 mode is set with PRAMDAC_GENERAL_CONTROL_565_MODE
//                (See OEMSetRegs)
//
//              - PRAMDAC_PLL_COEFF_SELECT and PRAMDAC_PLL_SETUP_CONTROL
//                bit definitions are different than NV4
//
//              - FixLowWaterMark is different than NV4 version
//
//              - OEMGetMemSize
//
//       NV4:   - CRTC registers are locked using NV_CIO_SR_LOCK_INDEX.
//                (See NV4_OEMEnableExtenions/NV4_OEMDisableExtension)
//
//              - 565 mode is set with NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE
//                (See NV4_OEMSetRegs)
//
//              - PRAMDAC_PLL_COEFF_SELECT and PRAMDAC_PLL_SETUP_CONTROL
//                bit definitions are different than NV3
//
//              - TV functionality has changed
//
//              - FixLowWaterMark is different than NV3 version
//
//              - NV4_OEMGetMemSize
//
//*****************************************************************************


#include <miniport.h>
#include <nv_ref.h>
#include <ntddvdeo.h>
#include <video.h>
#include "nv.h"
#include "modes.h"
#include "modedata.c"
#include "modehw.h"

// Debug level values and output macro
#define DEBUGLEVEL_TRACEINFO    0     // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO    1     // For informational debug setup info
#define DEBUGLEVEL_USERERRORS   2     // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS     3     // For debug warning info
#define DEBUGLEVEL_ERRORS       4     // For debug error info
#define DBG_PRINT_STRING_VALUE(l, s, v) VideoDebugPrint(((l), s ## " 0x%x\n", (v)))

#endif // NTMINIPORT

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID ProgramTV( U008 tvmode );
VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides);

//******************************************************************************
// External variables
//******************************************************************************

// global device extension pointer - We need it to distinguish between NV3/NV4..
extern PHW_DEVICE_EXTENSION HwDeviceExtension;
extern CRTC_OVERRIDE crt_override[];
extern MODEDESC mib[];            // Our Mode List

//******************************************************************************
// External functions
//******************************************************************************

extern VOID NV_OEMSetRegs(MODEDESC *);
extern VOID NV_FixLowWaterMark(U016);
extern U016 NV_OEMGetMemSize(VOID);
extern VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION);
extern VOID NV_OEMDisableExtensions(PHW_DEVICE_EXTENSION);

U016 VBESetModeEx(PHW_DEVICE_EXTENSION pHwDevExt, U016 vbeMode, PGTF_TIMINGS pVbeTimings, PDMT_OVERRIDES pDMTOverrides, U016 UseDMTFlag)
{
    HwDeviceExtension = pHwDevExt;
    return VBESetMode(vbeMode, pVbeTimings, pDMTOverrides, UseDMTFlag);
}

VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION pHwDevExt)
{
    HwDeviceExtension = pHwDevExt;
}



//******************************************************************************
//
// Function: WakeUpCard
//
// Description:
//
//           NV4 or better:
//
//           When RmInitNvDevice() is called during NVInitialize(),
//           it tries to detect if a monitor, flat panel, or TV is connected.
//           It does this when InitDac() calls dacMonitorConnectStatus(). 
//
//           However, dacMonitorConnectStatus() seems to fail on some cards
//           if the card is secondary and the monitor is not 'alive'
//           The end result is that dacMonitorConnectStatus() incorrectly identifies
//           the secondary card. This results in the secondary monitor coming up blank.
//
//           This does NOT happen on Win9x, since by that time, the secondary monitor
//           is already 'alive' and in text mode.  But under WinNT, the secondary
//           monitor has not yet been initialized.
//          
//           Aos, this does NOT happen on all cards (ie...my TNT2 works without this workaround)
//           but DOES happen on my NV4.    
//
//           So, under NT, to make sure that dacMonitorConnectStatus correctly identifies 
//           the monitor and that the 'monitor' is awake, we'll touch just enough registers
//           on the card to make sure it's alive.
//                   
//*****************************************************************************


VOID WakeUpCard(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    MODEDESC    *minfo;             

    //*************************************************************************
    // Mib[1] is the entry for 640x480
    //*************************************************************************

    minfo = &mib[1];

    //*************************************************************************
    // NV3 still uses the OLD style modeset code, and does NOT go thru
    // the RM to set the mode.  Only do this for NV4 or better.
    //*************************************************************************

    if  (HwDeviceExtension->ulChipID != NV3_DEVICE_NV3_ID)
        {
        //**********************************************************************
        // Make sure card is 'active'.  This code doesn't completely set a mode,
        // but it touches enough registers to make sure that dacMonitorConnectStatus()
        // in the RM will succeed, and correctly detect the monitor.
        //**********************************************************************

        SetGlobalHwDev(HwDeviceExtension);
        NV_OEMEnableExtensions(HwDeviceExtension);        
        SetRegs(minfo);             
        }
        
    }



//
// VBE Function 02h - Vesa SetMode routine.
//
// Used to set a VESA mode. This routine will not accept standard
// VGA Mode numbers, nor will it load/support fonts. This means that
// TTY output is DISABLED.
//
// Entry:   U016 mode             // VESA mode to be set
//
//          +------------------ Don't clear screen (1=Save Screen)
//          |+----------------- Linear Frame Buffer (1=Enable)
//          ||++--------------- Reserved for VBE/AF
//          ||||+-------------- User Refresh (1=User Specified)
//          |||||++------------ Reserved
//          |||||||+-++++++++-- Mode Number
//          VVVVVVVV VVVVVVVV
//          00000000 00000000
//
//          111111
//          54321098 76543210
//
//          CRTCInfoBlk *cib        // Pointer to CRTCInfoBlock Structure
//
// Exit:    U016 rc               // VESA Error Status
//


U016 VBESetMode(U016 mode, PGTF_TIMINGS timings, PDMT_OVERRIDES pDMTOverrides, U016 UseDmtFlag)
{
    MODEDESC    *minfo;             // Mode Information
    U016        wv;
    U016        rc = 0x014F;        // Default to FAIL
    U032        data32;
    U016        data,shadow;    


    NV_OEMEnableExtensions(HwDeviceExtension);          // Unlock the registers

    //**************************************************************************
    // Do this for flat panel only
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

#define NV_PRAMDAC_FP_DEBUG_0                            0x00680880 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX                0x00000002 /* RWI-V */

        // de-couple vertical sync from flat panel while setting mode
        data32 = ReadPriv32(NV_PRAMDAC_FP_DEBUG_0); 
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
        WritePriv32(data32, NV_PRAMDAC_FP_DEBUG_0 );
        }



    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {
    
        shadow = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x21);        // read shadow lock (is there really no define for this reg?)

        data = shadow | 0xC800;         // Enable loading of CRTC's: bit 7 Horiz shadow, bit 3 Vert shadow
                                    // bit 6 = scanline doubling shadow
        WriteIndexed(NV_PRMCIO_CRX__COLOR, data);


        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        data = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09);         // read scanline double
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (data &= ~0x8000));   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        while (PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
        while (!(PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start
    
        // shadow = CR21
        shadow &= ~0x4000;  // shadow the scanline double bit
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (shadow |= 0x8800)); // allow horiz & vert write-thru
        }    


    if ((minfo = ValidateMode((U016) (mode & 0x1FF))) != (MODEDESC *) NULL)
    {
        // Mode is maintained here, for the linear/regen flags
        // minfo now points to everything we need to program the mode.

        // Set the mode
        // SetBIOSVariables(minfo); // Set low memory variables from parms.
        ATCOff();                   // Screen off
        OEMPreSetRegs();            // Set up DAC for programming palette.

        SetRegs(minfo);             // Set the VGA Registers
        FullCpuOn();

        NV_OEMSetRegs(minfo);          // Set the OEM Registers
        LoadPalette(minfo);

        // Not in VESA modes...
        /*
        LoadSysFont(minfo);      // Not in these VESA modes...

        if (!(mode & 0x8000))     // Save the screen?
          OEMClearScreen();       // Clear the buffer

        if (mode & 0x4000)
          VBESetLinearFB();
        */

        // Use DMT override values instead of GTF timings
        if (UseDmtFlag)
            {
            // Mode now successfully set .. Set DMT override values
            SetDMTOverrideValues(pDMTOverrides);
            }

        else
            {

            // Mode now successfully set .. Set GTF timings
            if ((mode & 0x0800) && timings)  // See if bit 11 is set for VBE Refresh
              VBESetRefresh(timings);        // Set the VBE 3.0 Refresh
            }


        FullCpuOff();
        ATCOn();

        // Clear the DPMS State
        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
        wv &= 0x3FFF;                   // Strip to standard DAC settings
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

        // if (isTV())
        //    fixup_tv();          // Only required on Mode 13h

        rc &= 0x00FF;               // Clear error status
    }
    NV_OEMDisableExtensions(HwDeviceExtension);         // Unlock the registers

    return(rc);                     // Mode Not Supported
}

//
// Program the CRTC timing values given by the GTF parameters
//
// WARNING: This is not going to be pretty!!
// TODO: Clean the code to be more straightforward.
//
U016 VBESetRefresh(PGTF_TIMINGS timings)
{

    U032 val32;
    U016 val16, val16b, val16c;
    U008 val08;
    U016 pixperclk;
    U016 border;
    U008 ov07, ov25, ov2D;
    U016 horiz_total;
    U016 hbe;


    //
    // Program the new clocks
    //
    OEMSetClock((U016)(timings->dot_clock / 10000));

    /*
        ; Program new horizontal sync polarity
        mov     bl, [edi].CRTCInfoBlock.HorizontalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 040h
@@:
        ; Program new vertical sync polarity
        mov     bl, [edi].CRTCInfoBlock.VerticalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 080h
@@:
        mov     dx, MISC_OUTPUT
        LOG_GO  dx, al
    */
    //
    // Program the sync polarities
    //
    val32 = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    if (timings->flags & GTF_FLAGS_HSYNC_NEGATIVE)
        val32 |= 0x40;
    if (timings->flags & GTF_FLAGS_VSYNC_NEGATIVE)
        val32 |= 0x80;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: PRMVIO_MISC=",(U008)val32);

    /*
        ;---------------------------------------------------------
        ; Compute CRTC settings
        call    PixPerCharClk
        mov     si, ax
    */
    //
    // Get the pixels per char settings
    //
    if (ReadIndexed(NV_PRMVIO_SRX, NV_PRMVIO_SR_CLOCK_INDEX) & 0x0100)
        pixperclk = 8;
    else
        pixperclk = 9;

    /*
        ; Another way to compute vertical border would be to
        ; subtract current CR12 (VDE[0:7]) from CR15 (VBS[0:7])
        call    GetCRTCAddr
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bh, ah
        mov     al, 015h
        call    GetIndexRegister        ; VBS[7:0]
        sub     ah, bh
        ;add    ah, 1-1                 ; VGA adjustments cancel
        xor     al, al
        or      ah, ah
        jz      @f
        inc     al                      ; 1 character horizontal
@@:
        mov     bx, [edi].CRTCInfoBlock.RefreshRate
        cmp     bx, 7200
        jle     @f
        xor     ax,ax                   ; No boarder for refresh above 72Hz
@@:
        mov     bp, ax                  ; Save boarders in bp
    */
    //
    // Get the border setting
    //
    border = (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x15) & 0xFF00;
    border -= (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) & 0xFF00;
    border &= 0xFF00;
    if (border & 0xFF00)
        border++;
    if (timings->refresh > 7200)
        border = 0;

    /*
        ;---------------------------------------------------------
        ; Store CRTC settings
        ; Get overflow values to accumulate
        mov     al, 007h
        call    GetIndexRegister
        mov     ch, ah                  ; Save off overflow register
        and     ch, 01010010b           ; Mask bits to save
        mov     al, 025h
        call    GetIndexRegister
        mov     cl, ah                  ; Save off extra bits screen register
        and     cl, 11100010b           ; Mask bits to save
IFDEF NVIDIA_SPECIFIC
        ; Load original 02Dh
        mov     al,02Dh
        call    GetIndexRegister
        and     ah,0E2h         ; Save unused bits and HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Get the overflow bits
    //
    ov07 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07) >> 8;
    ov07 &= 0x52;
    ov25 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25) >> 8;
    ov25 &= 0xE2;
    ov2D = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x2D) >> 8;
    ov2D &= 0xE2;

    /*
        ; cl = CRTC[25] overflow
        ; ch = CRTC[07] overflow
        ; upper cl = CRTC[2D] overflow
        ; dx = CRTC I/O address
        ; si = pixels per character
        ; es:di = pointer to CRTCInfoBlock
        ; ds = seg0
        ; bp = boarder
        mov     ax, [edi].CRTCInfoBlock.HorizontalTotal
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax                  ; Save original
        sub     ax, 5                   ; VGA HT adjustment
IFDEF NVIDIA_SPECIFIC
        ; Do bit 8 of HT
        and     ah,1            ; mask out bit 8
        ;shl     ah,0-0          ; already in position 0
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        ; CRTC[00]
        mov     ah, al
        mov     al, 000h
        LOG_GO  dx, ax
    */
    //
    // Calculate and program horizontal total (CR00)
    //
    horiz_total = timings->horiz_total / pixperclk;
    val16 = horiz_total - 5;
    val16 &= 0x01FF;
    ov2D |= (U008)(val16 >> 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((val16 << 8) & 0xFF00));

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR00=",(U008)val16);

    /*
IFDEF NVIDIA_SPECIFIC
        ; CRTC[39]
        ; Note, we are assuming that the 9th bit of interlace half field start is always 0
        mov     ax, bx
        shr     ax, 1           ; Compute horizontal total divided by 2
        mov     ah, [edi].CRTCInfoBlock.Flags
        and     ah,00000010b    ; ?Interlaced mode
        jnz     @f              ; Y: Leave ah at 1/2 HT
        mov     al, 0FFh        ; N: Disable interlace
@@:
        mov     ah, al
        mov     al, 039h
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program interlace half-field value (CR39)
    //
    if (timings->flags & GTF_FLAGS_INTERLACED)
        val16 = (((horiz_total >> 1) << 8) & 0xFF00) | 0x39;
    else
        val16 = 0xFF39;   // disabled
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR39=",(U008)(val16>>8));

    /*
        mov     ax, bp
        xor     ah, ah                  ; Make into word
        sub     bx, ax                  ; Subtract boarder from HT
        ; CRTC[03]
        mov     al, 003h
        call    GetIndexRegister
        and     ah, 11100000b
        dec     bl                      ; VGA HBE Adjustment
        mov     bh, bl                  ; save HBE
        and     bl, 00011111b           ; HBE[4:0]
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking end (CR03)
    //
    val16 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x03);
    val16 &= 0xE0FF;
    hbe = horiz_total - (border & 0xFF) - 1;
    val16 |= ((hbe & 0x1F) << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR03=",(U008)(val16>>8));

    /*
        ; CRTC[05]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncEnd
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bl, al
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bl              ; VGA HSE adjustment is +2
        .endif
        inc     bl                      ; Native HSE adjustment is +1
        mov     al, 005h
        call    GetIndexRegister
        and     ah, 01100000b
        and     bl, 00011111b           ; HSE[4:0]
        or      ah, bl
        mov     bl, bh                  ; restore HBE
        and     bl, 00100000b           ; HBE[5]
        shl     bl, 7-5                 ; Move from bit 5 to bit 7
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace end (CR05)
    //
    val16 = timings->horiz_end / pixperclk;
    val16++;    // always native mode
    val16 &= 0x1F;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05);
    val16b &= 0x60FF;
    val16b |= (val16 << 8);
    val16 = (hbe & 0x20) << 2;
    val16b |= (val16 << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR05=",(U008)(val16b>>8));

    /*
IFDEF NVIDIA_SPECIFIC
        and     bh, 01000000b
        shr     bh, 6-4
        ; MSK - Assume HBE[6] can always be set, but only takes effect if LC ignore flag is set
        or      cl, bh                  ; HBE[6]
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Modify overflow25
    //
    ov25 |= ((hbe & 0x40) >> 2);

    /*
        ; CRTC[02]
        mov     al, 001h
        call    GetIndexRegister        ; HDE[0:7]
        mov     al, ah
IFDEF NVIDIA_SPECIFIC
        ; Get bit 8 of HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah, cl
        ror     ecx,16          ; switch back to lower part of ECX
        and     ah, 2           ; mask out bit 1
        shr     ah, 1-0         ; shift into position 0
ELSE ; NVIDIA_SPECIFIC
        xor     ah, ah
ENDIF ; NVIDIA_SPECIFIC
        ;
        inc     ax                      ; VGA HDE adjustment
        mov     bx, bp
        xor     bh, bh
        add     ax, bx
        dec     ax                      ; VGA HBS Adjustment
IFDEF NVIDIA_SPECIFIC
        ; Store bit 8 of HBS
        and     ah,1            ; mask out bit 8
        shl     ah,2-0          ; shift into position 2
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, al
        mov     al, 002h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking start (CR02)
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x01) >> 8) & 0x00FF;
    val16 |= ((U016)(ov2D & 2) << 7) & 0xFF00;
    val16++;
    val16 += (border & 0xFF);
    val16--;
    val08 = ((val16 >> 8) & 1) << 2;
    ov2D |= (U016)val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR02=",(U008)(val16>>8));

    /*
        ; CRTC[04]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncStart
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bx              ; VGA HSS adjustment is +2
        .endif
        inc     bx                      ; Native HSS adjustment is +1
IFDEF NVIDIA_SPECIFIC
        ; do bit 8 of HRS
        and     bh,1            ; mask out bit 8
        shl     bh,3-0          ; shift into position 3
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,bh
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, bl
        mov     al, 004h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace start (CR04)
    //
    val16 = timings->horiz_start / pixperclk;
    val16++;    // always native mode
    val08 = ((val16 >> 8) & 1) << 3;
    ov2D |= val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR04=",(U008)(val16>>8));

    /*
IFDEF NVIDIA_SPECIFIC
        ; CRTC[2D]
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah,cl
        ror     ecx,16          ; switch back to lower part of ECX
        mov     al,02Dh
        SIM_NO  dx,ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program CR2D
    //
    val16 = ((((U016)ov2D) << 8) & 0xFF00) | 0x2D;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR2D=",(U008)(val16>>8));

    /*
        ; CRTC[16]
        mov     bx, [edi].CRTCInfoBlock.VerticalTotal
        mov     ax, bp
        mov     al, ah
        xor     ah, ah
        sub     ax, bx
        neg     ax
        mov     ah, al
        mov     al, 016h
        dec     ah                      ; VGA VBE Adjustment
        LOG_GO  dx, ax                  ; VBE[0:7]
    */
    //
    // Program vertical blanking end (CR16)
    //
    val16 = (border >> 8) - timings->vertical_total;
    val16 = -val16;
    val16--;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR16=",(U008)(val16>>8));

    /*
        ; CRTC[06]
        mov     al, 006h
        sub     bx, 2                   ; VGA VT Adjustement
        mov     ah, bl
        LOG_GO  dx, ax                  ; VT[0:7]
    */
    //
    // Program the vertical total (CR06)
    //
    val16 = timings->vertical_total - 2;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR06=",(U008)(val16>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        ;shl    0-(8-8)
        or      ch, bl                  ; VT[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ch, bl                  ; VT[9]
        and     bh, 00000100b
        shr     bh, (10-8)-0
        or      cl, bh                  ; VT[10]
        ; CRTC[15]
        mov     ah, cl                  ; CRTC[25]
        and     ah, 00000010b
        shl     ah, (10-8)-1
        mov     bh, ah                  ; VDE[10]
        mov     al, ch                  ; CRTC[7]
        and     al, 01000000b
        shr     al, 6-(9-8)
        or      bh, al                  ; VDE[9]
        mov     ah, ch                  ; CRTC[7]
        and     ah, 00000010b
        shr     ah, 1-(8-8)
        or      bh, ah                  ; VDE[8]
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bl, ah
        inc     bx                      ; VGA VDE adjustment
        mov     ax, bp                  ; Adjust boarder
        mov     al, ah
        xor     ah, ah
        add     bx, ax
        mov     al, 015h
        dec     bx                      ; VGA VBS adjustment
        mov     ah, bl
        LOG_GO  dx, ax                  ; VBS[0:7]
    */
    //
    // Program vertical blanking start (CR15)
    //
    val16 = timings->vertical_total - 2;
    val08 = (val16 >> 8) & 0x01;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x02;
    val08 <<= 4;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x04;
    val08 >>= 2;
    ov25 |= (U016)val08;

    val08 = (ov25 & 0x02) << 1;
    val16 = (U016)val08 << 8;
    val08 = (ov07 & 0x40) >> 5;
    val16 |= (U016)val08 << 8;
    val08 = (ov07 & 0x02) >> 1;
    val16 |= (U016)val08 << 8;

    val16 &= 0xFF00;
    val16 |= (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
    val16++;
    val16 += (border >> 8);
    val16--;
    val16c = val16;                     // save for later
    val16b = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR15=",(U008)(val16b>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 3-(8-8)
        or      ch, bl                  ; VBS[8]
    */
    val08 = ((val16 >> 8) & 1) << 3;
    ov07 |= val08;

    /*
        ; CRTC[09]
        ; MSK - 5/15/97
        ; To allow a double scan mode to be non double scanned, we need to preserve the
        ; double scan bit so we can check it later
        ; We need to adjust VDE based on the old and new double scan bits
        ; We also need the original VDE
        ; NOTE: alternate way would be to get the value from the mode tables

        mov     al, 009h
        call    GetIndexRegister
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     ah,10000000b    ; Old double scan mode
        shr     ah,7-0
        and     bl,00000001b    ; ?Double scan mode
        cmp     bl, ah
        .if     (!zero?)        ; Mismatch
    */
    //
    // Is the current doublescan status different from the requested flag?
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16 >>= 7;
    // this takes advantage that the flag is 0x01
    if ((timings->flags & GTF_FLAGS_DOUBLE_SCANNED) != (U008)val16)
    {

        /*
                ; New mode had different double scan setting from old mode
                ; We have to multiply or divide VDE by 2

                mov     bl, ch          ; CR[7].1
                and     bl, 00000010b
                shr     bl, 1-0         ; move to bit 0

                mov     ah, ch          ; CR[7].6
                and     ah, 01000000b
                shr     ah, 6-1         ; move to bit 1
                or      bl, ah

                mov     ah, cl          ; CR[25].1
                and     ah, 00000010b
                shl     ah, 2-1         ; Move to bit 2
                or      bl, ah
        */
        //
        // Adjust VDE
        //
        val08 = (ov07 & 0x02) >> 1;
        val08 |= (ov07 & 0x40) >> 5;
        val08 |= (ov25 & 0x02) << 1;

        /*
                mov     al, 012h
                call    GetIndexRegister
                mov     al, [edi].CRTCInfoBlock.Flags
                and     al, 00000001b   ; Is new mode a double scan mode?
                .if (zero?)
                        ; was double scan, now is not, so divide by 2
                        shr     bl, 1           ; Divide by 2
                        rcr     ah, 1
                .else
                        ; was not double scan, now is, so multiply by 2
                        shl     ah, 1           ; Multiply by 2
        BUG? =>         rcr     bl, 1
                        inc     ah              ; Make lsb set

                .endif
                mov     al, 012h

                LOG_GO  dx, ax          ; VDE[0:7]
        */

        val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
        val16 |= (U016)val08 << 8;
        if (!(timings->flags & GTF_FLAGS_DOUBLE_SCANNED))
        {
            val16 >>= 1;
        }
        else
        {
            val16 <<= 1;
            val16++;
        }
        val16b = ((val16 << 8) & 0xFF00) | 0x12;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR12=",(U008)(val16b>>8));

        /*
                and     ch, NOT 01000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000001b
                shl     al, 1-0         ; move to bit 1
                or      ch, al          ; CR[7].1
                mov     al, bl
                and     al, 00000010b
                shl     al, 6-1         ; move to bit 6
                or      ch, al          ; CR[7].1

                and     cl, NOT 00000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000100b
                shr     al, 2-1         ; move to bit 1
                or      cl, al          ; CR[25].1

        .endif
        ; End MSK - 5/15/97
        */
        //
        // Adjust the overflows based on the new VDE
        //
        ov07 &= 0xBD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x01) << 1;
        ov07 |= val08;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x02) << 5;
        ov07 |= val08;
        ov25 &= 0xFD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x04) >> 1;
        ov25 |= val08;
    }

    /*
        mov     al, 009h
        call    GetIndexRegister
        and     ah, NOT 10100000b
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     bl,00000001b    ; ?Double scan mode
        jz      @f              ; N: Leave clear
        or      ah, 10000000b   ; Y: Set double scan
@@:
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ah, bl                  ; VBS[9]
        LOG_GO  dx, ax
    */
    //
    //
    val16b = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16b &= 0x5F;
    if (timings->flags & GTF_FLAGS_DOUBLE_SCANNED)
        val16b |= 0x80;
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x02) << 4;
    val16b |= (U016)val08;
    val16 = ((val16b << 8) & 0xFF00) | 0x09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR09=",(U008)(val16>>8));

    /*
        and     bh, 00000100b
        shl     bh, 3-(10-8)
        or      cl, bh                  ; VBS[10]
        ; CRTC[10]
        mov     al, 010h
        mov     bx, [edi].CRTCInfoBlock.VerticalSyncStart
        mov     ah, bl
        LOG_GO  dx, ax                  ; VSS[0:7]
    */
    //
    //
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x04) << 1;
    ov25 |= val08;
    val16 = timings->vertical_start;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR10=",(U008)(val16>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 2-(8-8)
        or      ch, bl                  ; VSS[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 7-(9-8)
        or      ch, bl                  ; VSS[9]
        and     bh, 00000100b
        ;shl     bh, 2-(10-8)
        or      cl, bh                  ; VSS[10]
        ; CRTC[11]
        mov     al, 011h
        call    GetIndexRegister
        and     ah, 11110000b
        mov     bl, byte ptr [edi].CRTCInfoBlock.VerticalSyncEnd
        and     bl, 00001111b
        or      ah, bl
        LOG_GO  dx, ax                  ; VSE[0:3]
    */
    //
    //
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x01) << 2;
    ov07 |= val08;
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x02) << 6;
    ov07 |= val08;
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = val08 & 0x04;
    ov25 |= val08;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);
    val16b &= 0xF0FF;
    val16b |= (timings->vertical_end & 0x000F) << 8;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR11=",(U008)(val16b>>8));

    /*
        ; Store overflow registers
        ; CRTC[7]
        mov     al, 007h
        mov     ah, ch
        LOG_GO  dx, ax
    */
    val16 = ((((U016)ov07) << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR07=",(U008)(val16>>8));

    /*
        ; CRTC[25]
IFDEF NVIDIA_SPECIFIC
        mov     al, 025h
        mov     ah, cl
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    val16 = ((((U016)ov25) << 8) & 0xFF00) | 0x25;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR25=",(U008)(val16>>8));

    return(0);
}


//*****************************************************************************
//
// Function: SetDMTOverrideValues()
//
// Description:
//
//      Do VESA 1.0 rev 0.7 DMT timings for the following modes:
//
//      DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7
//      Monitor Timing Specifications and D.Reed's NV3 CRTC spreadsheet.
//
//           1600 x 1200 @ 60,70,75,85
//           1280 x 1024 @ 60,75,85
//           1152 x  864 @ 75
//           1024 x  768 @ 60,70,75,85
//            800 x  600 @ 60,72,75,85
//            640 x  480 @ 60,72,75,85
//
//      DMT_Overrides_structure
//
//          U016    DotClock;
//          U016    Polarity;
//          U016    CR0;
//          U016    CR2;
//          U016    CR3;
//          U016    CR4;
//          U016    CR5;
//          U016    CR6;
//          U016    CR7;
//          U016    CR10;
//          U016    CR11;
//          U016    CR15;
//          U016    CR16;
//
//*****************************************************************************


VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides)

{

    U032 val32;
    U016 val16;
    U016  wv;

    //
    // Program the new clocks
    //

    OEMSetClock((U016)(pDMTOverrides->DotClock));

    //
    // Program the sync polarity
    //

    val32   = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    val32  &= 0xf3;
    val32  |= 0x8;
    val32  |= pDMTOverrides->Polarity;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    //
    // Clear the crtc protection bit.
    //

    val16 = 0x0011;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR0
    //

    val16 = pDMTOverrides->CR0;
    val16 = ((val16 << 8) & 0xFF00) | 0x00;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR2
    //

    val16 = pDMTOverrides->CR2;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR3
    //

    val16 = pDMTOverrides->CR3;
    val16 = ((val16 << 8) & 0xFF00) | 0x03;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR4
    //

    val16 = pDMTOverrides->CR4;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR5
    //

    val16 = pDMTOverrides->CR5;
    val16 = ((val16 << 8) & 0xFF00) | 0x05;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR6
    //

    val16 = pDMTOverrides->CR6;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR7
    //

    val16 = pDMTOverrides->CR7;
    val16 = ((val16 << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR10
    //

    val16 = pDMTOverrides->CR10;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    //
    // Update CR11
    //

    val16 = pDMTOverrides->CR11;
    val16 = ((val16 << 8) & 0xFF00) | 0x11;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR15
    //

    val16 = pDMTOverrides->CR15;
    val16 = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR16
    //

    val16 = pDMTOverrides->CR16;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    }

#define COMBINE_INDEX_DATA(i, d) ((U016)((((U016)(d)) << 8 & 0xff00) + (i)))
#define EXTRACT_DATA(x) (x) >> 8 & 0x00ff
VOID ProgramTV
(
    U008    tvmode
)
{
    U016    data;

    // 11-07-97 wk. Note that either the commented out tvreg table for CRTC[12] is
    //              wrong or the BIOS CRTC[12] programming code is wrong. The BIOS doesn't
    //              have tvreg tables for TV modes 4 and 5. The C code will use the tvreg
    //              table, so if the bug is in the table then make the correction there.

    WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_ILACE__INDEX, tvregs[tvmode].tvIntlace));        // CRTC[39]

    // Un-write protect CR0-7 registers.
    data = ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_VRE_INDEX);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(data & 0x7fff));

    // Check for NTSC or PAL.
    data = EXTRACT_DATA(ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CRE_PIXEL_INDEX));
    if(( data & 0xc0 ) == 0x80 )
    {
        // NTSC
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_DEC__INDEX, tvregs[ tvmode ].tvDecimate_NTSC ));      // CR[29]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDT_INDEX,   tvregs[ tvmode ].tvHT_NTSC       ));      // CR[00]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRS_INDEX,   tvregs[ tvmode ].tvHRS_NTSC      ));      // CR[04]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDT_INDEX,   tvregs[ tvmode ].tvVT_NTSC       ));      // CR[06]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_OVL_INDEX,   tvregs[ tvmode ].tvVO_NTSC       ));      // CR[07]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRS_INDEX,   tvregs[ tvmode ].tvVRS_NTSC      ));      // CR[10]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDE_INDEX,   tvregs[ tvmode ].tvHDE_NTSC      ));      // CR[01]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBS_INDEX,   tvregs[ tvmode ].tvHBS_NTSC      ));      // CR[02]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBE_INDEX,   tvregs[ tvmode ].tvHBE_NTSC      ));      // CR[03]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRE_INDEX,   tvregs[ tvmode ].tvHRE_NTSC      ));      // CR[05]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRE_INDEX,   tvregs[ tvmode ].tvVRE_NTSC      ));      // CR[11]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDE_INDEX,   tvregs[ tvmode ].tvVDE_NTSC      ));      // CR[12]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBS_INDEX,   tvregs[ tvmode ].tvVBS_NTSC      ));      // CR[15]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBE_INDEX,   tvregs[ tvmode ].tvVBE_NTSC      ));      // CR[16]
    }
    else
    {
        // PAL
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_DEC__INDEX, tvregs[ tvmode ].tvDecimate_PAL ));      // CR[29]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDT_INDEX,   tvregs[ tvmode ].tvHT_PAL       ));      // CR[00]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRS_INDEX,   tvregs[ tvmode ].tvHRS_PAL      ));      // CR[04]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDT_INDEX,   tvregs[ tvmode ].tvVT_PAL       ));      // CR[06]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_OVL_INDEX,   tvregs[ tvmode ].tvVO_PAL       ));      // CR[07]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRS_INDEX,   tvregs[ tvmode ].tvVRS_PAL      ));      // CR[10]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDE_INDEX,   tvregs[ tvmode ].tvHDE_PAL      ));      // CR[01]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBS_INDEX,   tvregs[ tvmode ].tvHBS_PAL      ));      // CR[02]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBE_INDEX,   tvregs[ tvmode ].tvHBE_PAL      ));      // CR[03]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRE_INDEX,   tvregs[ tvmode ].tvHRE_PAL      ));      // CR[05]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRE_INDEX,   tvregs[ tvmode ].tvVRE_PAL      ));      // CR[11]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDE_INDEX,   tvregs[ tvmode ].tvVDE_PAL      ));      // CR[12]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBS_INDEX,   tvregs[ tvmode ].tvVBS_PAL      ));      // CR[15]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBE_INDEX,   tvregs[ tvmode ].tvVBE_PAL      ));      // CR[16]

        // PAL Fix up.

        // 11-07-97 wk. mighty suspect bios code (or documentation)!
        //
        // mov     al,1                    ; Look at value in CR01
        // SIM_GET_INDEX_REGISTER_NV       ; Read CR01
        // cmp     ah,4Fh                  ; Is it > 4Fh? (800 s/b 63h)
        //
        // jbe     @low_pal                ; it's a 640x480 or less mode... jump!

        //CRTC_RD( NV_CIO_CR_HDE_INDEX, data );      // CRTC[01]
        data = EXTRACT_DATA(ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_HDE_INDEX));
        if( data > 0x4f )
        {
            // PAL timings for modes 800x600 or more.

            // set VPLL to SOURCE
            WritePriv32(0x00010100, NV_PRAMDAC_PLL_COEFF_SELECT );
            WritePriv32(0x00035A09, NV_PRAMDAC_VPLL_COEFF       );

            // tblPALTimingsHi
            WritePriv32(0x0000004F, NV_PRAMDAC_HSYNC_WIDTH      );
            WritePriv32(0x0000005F, NV_PRAMDAC_HBURST_START     );
            WritePriv32(0x000003FF, NV_PRAMDAC_HBLANK_START     );
            WritePriv32(0x00000438, NV_PRAMDAC_HTOTAL           );
            WritePriv32(0x00000027, NV_PRAMDAC_HEQU_WIDTH       );
            WritePriv32(0x000001CA, NV_PRAMDAC_HSERR_WIDTH      );
        }
        else
        {
            // PAL timings for modes less then 800x600.

            // set VPLL to SOURCE
            WritePriv32(0x02010100, NV_PRAMDAC_PLL_COEFF_SELECT );
            WritePriv32(0x00034709, NV_PRAMDAC_VPLL_COEFF       );

            // tblPALTimingsLo
            WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH      );
            WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START     );
            WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START     );
            WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL           );
            WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH       );
            WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH      );
        }
    }

    // write protect CR0-7 registers.
    data = ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_VRE_INDEX);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(data & 0x7fff));
}



//
//       LoadPalette - Load the system palette and the user defined palette if there is one
//
//       Entry:  DS = Seg0
//               ES:DI = Pointer to parameter entry
//       Exit:   None
VOID LoadPalette(MODEDESC *mi)
{
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    //
    // Load default internal palette
    //
    LoadDefaultATCAndSavePtr((vga_tbl[mi->mdIMode].PT_ATC));

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop

    WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!

    //
    // Load default external palette
    //
    LoadDefaultRAMDAC(mi);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif

}

//
//       LoadDefaultATCAndSavePtr - Load a the default ATC registers and store them in the saveptr area if necessary
//
//       Entry:  ES:SI = Pointer to palette data
//               DX = I/O Address of Input Status Register
//               DS = Seg0
//       Exit:   None
//
//       AX, CX, SI are trashed
//       DX is preserved
//
VOID LoadDefaultATCAndSavePtr(U008 *pal)
{
    U008  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop

    for (i = 0; i < 20; i++)
    {
        WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//
//       LoadDefaultRAMDAC - Load the default palette
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed
//

// #define DAC_MASK 0x3C6

VOID LoadDefaultRAMDAC(MODEDESC *mi)
{
    WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask
    // outp(DAC_MASK, 0xFFh);

    switch(mi->mdBPP)
    {
    case    4:          // 4bpp - Planar
        LoadColorDACTable();
        break;

    case    8:          // 8bpp - Packed
        LoadColor256DAC();
        break;

    case    16:         // 16bpp - Packed
    case    32:         // 16bpp - Packed
    default:
        LoadIdentityDAC();
        break;
    }
}

//
//       LoadColorDACTable - Load the DAC for the 16-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       WARNING! This routine must follow "LoadColorTextDACTable"!
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadColorDACTable(VOID)
{
    U008  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        WriteColor(i);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//
//       LoadColor256DAC - Load the DAC for the 256-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
// These tables are defined in Resman code in DACMODE.C
//
extern U008 CompatColors[];

//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
extern U008 GrayColors[];

//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
extern U008 FixupColors[];

//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
extern U008 IntenseTable[];

VOID LoadColor256DAC(VOID)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        WriteColor(CompatColors[i]);

    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }

    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //

    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {

        // I know these could probably be a function, but for now...
        // (this is getting tedious).

        // Traverse(blue, red);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            red++;
        } while (red < blue);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            blue--;
        } while (blue);

        // Traverse(red, green);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            green++;
        } while (green < red);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            red--;
        } while (red);


        // Traverse(green, blue);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            blue++;
        } while (blue < green);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            green--;
        } while (green);
    }

    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif

}

//
//       WriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               BL = 6 bit color (R'G'B'RGB)
//       Exit:   None
//
//       AX is trashed
//
VOID WriteColor(U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write

    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component

        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;

        WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}

//
//       WriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               CS:BX points to intensity table
//               SI = Red index (0 to 4)
//               DI = Green index (0 to 4)
//               CX = Blue index (0 to 4)
//
//       Exit:   None
//
//       AL is trashed
//
VOID WriteColor2(U016 red, U016 green, U016 blue, U016 tblidx)
{
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       LoadIdentityDAC - Load the DAC with a gamma ramp
//
//       Entry:  DS = Seg0
//               ES = _TEXT
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadIdentityDAC(VOID)
{
    U016  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    for (i = 0; i < 256; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
    }

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//       OEMSetClock - Set the clock chip to the requested frequency
//
//       Entry:  AL = Clock select index
//       Exit:   None
//
//       All registers are preserved.
VOID OEMSetClock(U016 clock)
{
    U032   mnp;

    //clock = tblClockFreq[csel];         // Get selected clock value
    NV_FixLowWaterMark(clock);             // Set low water mark.
    mnp = CalcMNP(&clock);              // Get the MNP of frequency

    // mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM

//  AL = M parameter
//  AH = N parameter
//  DL = P parameter

    SetDACClock(mnp);
}

//       SetDACClock - Set the VPLL parameters in the NVidia DAC
//
//  Entry:  mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
//       Entry:  AL = M parameter
//               AH = N parameter
//               DL = P parameter
//       Exit:   None
//
VOID SetDACClock(U032 mnp)
{
    // NOTE: if we need to support divide by two, use msb of p parameter
    // Set the MNP VPLL parameters in the DAC
    WritePriv32(mnp, NV_PRAMDAC_VPLL_COEFF);
}



//       CalcMNP - Set the clock chip to the requested frequency
//
//       Entry:  AX = Clock frequency in 100 kHz
//       Exit:   AL = M parameter
//               AH = N parameter
//               DL = P parameter
//               BX = Closest clock frequency in 100 kHz
//
//      Returns: long lwv = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
U032 CalcMNP(U016 *clock)
{
    U016  crystalFreq;
    U032   vclk;
    U016  vclkClosest;
    U016  deltaOld;
    U016  bestM;
    U016  bestP;
    U016  bestN;
    U016  lowM;
    U016  highM;

    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032   lwv;

    U032   edx;
    U016  dx, cx, bx;
    U016  lwvs, vclks;
    U016  t;

    vclk = (U032)(*clock * 10);     // Make KHz

    deltaOld = 0xFFFF;

    lwv = ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040;

    if (lwv)
    {
        // 14.3Khz
        dx = CRYSTAL_FREQ143KHZ;
        cx = 8;
        bx = 14;
    }
    else
    {
        // 13.5Khz
        dx = CRYSTAL_FREQ135KHZ;
        cx = 7;
        bx = 13;
    }

    lowM = cx;
    highM = bx;
    crystalFreq = dx;

    // Register usage below
    // eax = scratch
    // ebx = scratch
    // edx = scratch
    // si = m
    // di = n

    // P Loop
    for (powerP = 0; powerP <= 4; powerP++) // Init Power of P
    {
        // M Loop
        for (m = lowM; m <= highM; m++)
        {
            lwv = vclk << powerP;   // vclk * P

            // Compare with internal range of DAC
            if ((lwv >= 128000) && (lwv <= 256000))
            {
                lwv *= (U032)m;    // vclk * P * M

                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);

                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);

                lwv *= crystalFreq; // N * crystal

                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2

                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P

                i = m;
                j = m;

                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M


//                   ; upper part of ebx should still be 0
//                   mov     bx, m
//                   ; Note: edx should be zero from multiply above
//                   mov     dx, bx
//                   shr     dx, 1           ; m / 2
//                   add     eax, edx        ; This will round better
//                   xor     dx, dx
//                   div     ebx             ; Freq=N*crystal/P/M
//
//                   mov     edx, eax        ; Save a copy

                edx = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta

                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);

                if (lwvs < vclks)
                {
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }

                lwvs -= vclks;      // ABS(Freq-Vclk);

                // lwvs is ax
                // vclks is bx

                if (lwvs < deltaOld)
                {
                    // Closer match
                    deltaOld = lwvs;

                    bestP = powerP;
                    bestM = m;
                    bestN = n;

                    //         mov     deltaOld, ax
                    //         mov     bestP, powerP
                    //         mov     ax, m
                    //         mov     bestM, al
                    //         mov     ax, n
                    //         mov     bestN, al

                    edx /= 10;

                    //         mov     eax,edx
                    //         xor     edx,edx
                    //         mov     ebx,10
                    //         div     ebx             ; Convert
                    //         mov     vclkClosest,ax
                    vclkClosest = (U016)(edx & 0xFFFF);
                }
            }
        }
    }

  //  lwv = ((bestP << 16) | (bestN << 8) | (bestM));
    lwv = bestP;
    lwv <<= 16;
    lwv |= ((bestN << 8) | (bestM));


    // mov     bx, vclkClosest
    *clock = vclkClosest;

    return(lwv);
}

//       FullCpuOn - Give the CPU full bandwidth to video memory
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOn(VOID)
{
    U016  datum;

    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum |= 0x2000;                            // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
}

//       FullCpuOff - Share the CPU bandwidth with the CRTC
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOff(VOID)
{
    U016  datum;

    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum &= 0xDFFF;                            // Full Bandwidth bit OFF
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
}

//
//       SetRegs - Set VGA registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID SetRegs(MODEDESC *mi)
{
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset

    WritePriv08(NV_PRMVIO_MISC__WRITE, vga_tbl[mi->mdIMode].PT_Misc);

    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    LoadIndexRange(NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(vga_tbl[mi->mdIMode].seq_regs));

    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset

    // Load CRTC's
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x2011);  // Unlock CR0-7

    // Load CRTC, beginning at CR0, for all CR's (CR0-18), from the mode table
    LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, sizeof(CRTC), (U008 *)&(vga_tbl[mi->mdIMode].crtc_regs));

    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    LoadIndexRange(NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(vga_tbl[mi->mdIMode].gr_regs));
}

VOID LoadIndexRange(U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;

    // Program SR1-4
    for (i = 0; i < count; i++)
    {
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }
}

//       OEMPreSetRegs - Make special preparations to load registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID OEMPreSetRegs(VOID)
{
    U016  rc;

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    rc &= 0xF8FF;                   // Strip to standard DAC settings
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    rc |= 0x0200;                   // Use 6-bit DAC
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);
}

//
//       ATCOff - Turn off Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOff(VOID)
{
    U016  flags = 0;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax            // Save flags
    _asm    cli;                    // No interrupts during this!
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Turn off screen at AR

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf
#endif
}

//
//       ATCOn - Turn on Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOn(VOID)
{
    U016  flags;

#ifdef DOS_COMPILE
    _asm
    {
        pushf
        pop ax
        mov flags,ax
        cli
    }
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x20);   // Turn off screen at AR
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE
    _asm
    {
        mov ax,flags
        push ax
        popf
    }
#endif
}

//
// ValidateMode - Validate the passed mode is valid, and if it is,
//                return the pointer to the mode information block.
//
//  Entry:  U016  mode            // VESA Mode Number to validate
//
//  Exit:   MODEDESC *mi            // Mode Information Block Pointer
//                                  // NULL if error (invalid mode)
//  NOTES:  This function must also verify the operational mode,
//          and return failure status if not valid on TV
//

MODEDESC *ValidateMode(U016 mode)
{
    MODEDESC    *mi;

    for (mi = &mib[0]; mi->mdVMode != 0xFFFF; mi++)
    {
        if (mi->mdVMode == mode)
        {
            if (OEMValidateMode(mi))
                return(mi);
            break;      // Out of the for - report error
        }
    }
    return(NULL);
}

// From OEMIsModeAvailable - validate the mode from the OEM perspective.
//
U008 OEMValidateMode(MODEDESC *m)
{
    U032   memory;

    // Are we running tv mode? If so, we need an additional filter

    // For now, NV5 or better only supports Flat Panel
    // We don't support TV yet 

    if  ( (HwDeviceExtension->ulChipID == NV3_DEVICE_NV3_ID) &&
          (isTV()) )       

    {
        if (m->mdTVMode == 0xFF)
            return((U008)0);
    }

    // Validate we have enough memory
    // (XRes * YRes * Bpp)/8
    //           +--- XRes / 8
    //           V
    memory = (((m->mdXRes >> 3) * m->mdBPP) * m->mdYRes);
    memory += 0xFFFF;               // Take to next 64K bank size
    memory >>= 16;                  // Divide by 64K for number of banks

    // memory now has the 64K blocks necessary for this mode.

    if (((U016)memory) > NV_OEMGetMemSize())
        return((U008)0);
    return((U008)1);
}

// Returns 1 if the TV is active
//
U008 isTV(VOID)
{
    U016   rc;

    // WARNING: This code was ONLY valid on NV3.
    //          It's no longer adequate for NV5 or better !!

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    return((U008)((rc >> 8) & 0x80));
}





/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

// And the following routines will become "throwaway" code, as they
// deal with the saving and restoring of the IO state during the
// accesses to the PRIV_IO.

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
//       SaveNVAccessState - Save the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//       Exit:   cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//               Real mode access registers set to address
VOID SaveNVAccessState(ACCESS_STATE *as)
{
    U008   rc;

    U016  wval;
    U032   dval;

/*
    as->crtc_addr = 0x3D4;           // Set 3D4 by default
    as->access_reg = 0x38;           // Set CR38

    // rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x38);
    dval = NV_PRMCIO_CRX__COLOR;

    // Output the MSW of the address
    outpw(0x3D2, (U016)((dval >> 16) & 0xFFFF));

    // and the LSW of the address
    outpw(0x3D0, (U016)(dval & 0xFFFF));

    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));

    outp(0x3D0, 0x38);              // Select the register
    wval = inpw(0x3D0);             // This data is Byte/Word accessable

    as->access_reg = (U008)(wval & 0xFF);
    as->access_bits = (U008)((wval >> 8) & 0xFF);

    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));

    as->data_low = inpw(0x3D0);      // Save lsw of 32-bit data

    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));

    as->nv_address = inpw(0x3D2);    // Read MSW of address
    as->nv_address <<= 16;           // Put in high word.
    as->nv_address |= inpw(0x3D0);   // Read LSW of address
*/

}


//       RestoreNVAccessState - Restore the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//               cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//       Exit:   none
VOID RestoreNVAccessState(ACCESS_STATE *as)
{
/*
    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));
    outpw(0x3D2, (U016)(as->nv_address >> 16));       // MSW of address
    outpw(0x3D0, (U016)(as->nv_address & 0xFFFF));    // LSW of address

    // Select the buffered data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA32) << 8) | (as->access_reg)));

    outpw(0x3D0, as->data_low);     // LSW of address

    outpw(as->crtc_addr, (((as->access_bits) << 8) | (as->access_reg)));
*/
}

/**********************************************************************/
/**********************************************************************/

//
// POST the chip, just like the BIOS normally does
//
VOID NvPost()
{
    U032 memconfig;
    U032 val32;

    //////////////////////////////////////////////
    //
    // Taken from BIOS POST sequence
    //

    //
    // Enable requisite engines
    //
    WritePriv32(0x11111111, NV_PMC_ENABLE);

    //
    // Program 100MHz MPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
    else
        WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    //
    // Program PFB Config to defaults
    //
    WritePriv32( DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED), NV_PFB_CONFIG_0);

    //
    // Program VPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x00028D0E, NV_PRAMDAC_MPLL_COEFF);
    else
        WritePriv32(0x0001400C, NV_PRAMDAC_MPLL_COEFF);

    //
    // Program PFB Power control
    //
    WritePriv32(DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED), NV_PFB_GREEN_0);

    //
    // Program memory timings based on framebuffer size
    //
    //

    //
    // Determine how wide/deep is the framebuffer
    //
    /*
     Memory layout:

           4mb 128-bit     33221100 77665544 bbaa9988 ffeeddcc
           2mb 128-bit     33221100 77665544 xxxxxxxx xxxxxxxx

           128-bit covers address 0-3fffff in both 2mb and 4mb configs,
           but the second 2 dwords are garbage on 2mb boards.

           4mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc
           2mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc

           64-bit covers address 0-3fffff in 4mb configs, while
           64-bit covers address 0-1fffff in 2mb configs. All bytes are
           addressed.
    */

    memconfig = ReadPriv32(NV_PFB_BOOT_0);
    memconfig &= 0xFFFFFFFC;
    memconfig |= DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _DEFAULT); // mask to 4meg, keep bus width

    //
    // Poke the framebuffer based on bus width
    //
    if (memconfig & DRF_DEF(_PFB, _BOOT_0, _RAM_WIDTH_128, _ON))
    {
        //
        // 128bit test
        //
        WriteFb32('NV3A', 0x00200008);  // 2meg+8

        //
        // 4meg?
        //
        if (ReadFb32(0x00200008) != 'NV3A')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);

    } else {

        //
        // 64bit test
        //
        WriteFb32('NV3A', 0x00100000);  // 1meg
        WriteFb32('NV3B', 0x00300000);  // 3meg

        //
        // 4meg?
        //
        if (ReadFb32(0x00300000) != 'NV3B')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);

            //
            // 2meg?
            //
            if (ReadFb32(0x00100000) != 'NV3A')
                //
                // Assume 1meg
                //
                ;//memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _1MB);

    }

    //
    // Write the memory config
    //
    WritePriv32(memconfig, NV_PFB_BOOT_0);

    //
    // Now program the appropriate memory timings
    //
    if ((memconfig & 3) == DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB))
    {
        //
        // 2meg timings
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);

        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);

        WritePriv32((ULONG) (DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON)), NV_PFB_CONFIG_1);

        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);

        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    } else {
        //
        // 4meg
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);

        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);

        WritePriv32((ULONG) (DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON)), NV_PFB_CONFIG_1);

        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);

        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    }

    //
    // Enable clocking
    //
    WritePriv32(DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_DLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_SOURCE,_PROG)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_SOURCE,_DEFAULT)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_PCLK_SOURCE,_VPLL)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VCLK_RATIO,_DB1), NV_PRAMDAC_PLL_COEFF_SELECT);

    //
    // Setup optimal PCI interface
    //
    WritePriv32(DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP)
              | DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO), NV_PBUS_DEBUG_1);


    //
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A) & 0x3FFF) | 0x0000));

    //
    // Boot with TV off, and set for NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28) & 0x00FF) | 0x0000));

    //
    // Float DDC pins high (not touched during a mode set or save/restore state)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3300));

    //
    // Disable DDC
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3200));

    //
    // Program NTSC TV settings
    //
    WritePriv32(0x00000006, NV_PRAMDAC_VSERR_WIDTH);
    WritePriv32(0x0000000C, NV_PRAMDAC_VEQU_END);
    WritePriv32(0x0000000C, NV_PRAMDAC_VBBLANK_END);
    WritePriv32(0x00000024, NV_PRAMDAC_VBLANK_END);
    WritePriv32(0x0000020C, NV_PRAMDAC_VBLANK_START);
    WritePriv32(0x00000206, NV_PRAMDAC_VBBLANK_START);
    WritePriv32(0x00000207, NV_PRAMDAC_VEQU_START);
    WritePriv32(0x0000020D, NV_PRAMDAC_VTOTAL);
    WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
    WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
    WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
    WritePriv32(0x0000034A, NV_PRAMDAC_HBLANK_START);
    WritePriv32(0x00000088, NV_PRAMDAC_HBLANK_END);
    WritePriv32(0x0000035A, NV_PRAMDAC_HTOTAL);
    WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
    WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);

    //
    // If strapped to PAL, program PAL TV settings
    //
    if ((ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000180) == 0x00000100)
    {

        WritePriv32(0x00000005, NV_PRAMDAC_VSERR_WIDTH);
        WritePriv32(0x0000000A, NV_PRAMDAC_VEQU_END);
        WritePriv32(0x0000000A, NV_PRAMDAC_VBBLANK_END);
        WritePriv32(0x0000002C, NV_PRAMDAC_VBLANK_END);
        WritePriv32(0x0000026C, NV_PRAMDAC_VBLANK_START);
        WritePriv32(0x00000269, NV_PRAMDAC_VBBLANK_START);
        WritePriv32(0x0000026C, NV_PRAMDAC_VEQU_START);
        WritePriv32(0x00000271, NV_PRAMDAC_VTOTAL);
        WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
        WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
        WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
        WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START);
        WritePriv32(0x00000092, NV_PRAMDAC_HBLANK_END);
        WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL);
        WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
        WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);
    }

}

/**********************************************************************/
/**********************************************************************/


//
// The following MAIN() routine is only used for standalone DOS compiles
//
#ifdef DOS_COMPILE
VOID main(U016 ac, U008 **av)
{
    U016  mode;                   // Mode to be set
    U016  rc;                     // Return code

    printf("NVIDIA MODESET V1.00\n\n");

    if (ac < 2)
    {
        printf("Usage: modeset vmode\n");
        printf("       vmode - Vesa Mode Number\n");
        exit(1);
    }

    if ((mode = h2i(*(++av))) == 0xFFFF)
    {
        printf("Error! Bad Vesa Mode Number\n");
        exit(2);
    }

    printf("Setting Mode 0x%02X\n", mode);
    getchar();

    rc = VBESetMode(mode);

    if (((rc & 0xFF) != 0x4F) || ((rc & 0xFF00) >> 8))
    {
        printf("Error! Could Not Set Mode 0x%02X [rc=%04X]\n", mode, rc);
        exit(3);
    }

    exit(0);
}

//
// h2i - convert Hex string to an Unsigned Integer
U016 h2i(U008 *str)
{
    U016  sus = 0;                // Starting unsigned short
    U016  i;
    U016  val;                    // Conversion value

    // Since we only do U016's, we have a max of 0xFFFF-1
    if ((i = strlen(str)) > 4)
        return(0xFFFF);

    while (i--)
    {
        val = toupper(*str) - 0x30;  // Convert Hex 0-9
        if (val > 9)
        {
            val -= 7;               // Take 7 more to convert A-F
            if (val < 0x0A || val > 0x0F)
                return(0xFFFF);     // Error!
        }
        sus *= 16;                  // Shift by 4
        sus += val;
        str++;
    }
    return(sus);
}
#endif // DOS_COMPILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\ntnvreg.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/



//******************************************************************************
// Common typedefs
//******************************************************************************

typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

//******************************************************************************
// Type of REGISTRY entry
//******************************************************************************

#define IS_BINARY       0
#define IS_STRING       1
#define IS_DWORD        2

//******************************************************************************
// REGISTRY data length max values
//******************************************************************************

#define REG_STRING_DATA_MAX 30

//******************************************************************************
// Maximum number of NV registry switches
//******************************************************************************

#define MAX_NV_REGISTRY_SWITCHES   100

//******************************************************************************
// Dword value used to IGNORE the presence of the registry switch
//******************************************************************************

#define IGNORE_REGISTRY_SWITCH     0x99999999

//******************************************************************************
// NT Registry Switches:
// ====================
//
// The implementation of NT registry keys are different than Win9x,
// since NT is more restricted when it comes to setting values in its registry.
// Essentially, for NT, we only use a 'flat' registry structure, as opposed to 
// several different keys (directory structure) in Win9x.
//  
// For Win9x, the registy keys and values are stored under 
//          \HKEY_LOCAL_MACHINE\SOFTWARE\NVIDIA Corporation\Riva TNT\
// 
// For WinNT, the registry values are all stored under 
//          \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\nv\DeviceXX
//
// Even though the implementation is different on NT, we'll attempt to keep the
// registry functionality as close to Win9x as possible.
//
//
// NOTE: Since OPENGL is NOT part of the NT display driver (it'a separate DLL),
//       it can read the registry by itself, and does NOT have its registry
//       switches in the same location as all the switches.
//       It's switches are still located in .\Software\NVIDIA Corporation\Riva TNT\
//
//
//      Please Refer to NVREG.H in the \drivers\common\inc directory to
//              see how this structure was obtained
//
//******************************************************************************

typedef struct _NT_NV_REGISTRY_SWITCH_OFFSET
    {
    U032    RegType;
    U008    RegName[REG_STRING_DATA_MAX];
    U032    Offset;
    } NT_NV_REGISTRY_SWITCH_OFFSET;


typedef struct _NT_NV_REGISTRY_DISPLAY
    {
    U008    LastDisplayDevice[REG_STRING_DATA_MAX];     // String
    U008    LastCRTMode[REG_STRING_DATA_MAX];           // String
    U008    LastDFPMode[REG_STRING_DATA_MAX];           // String
    U008    LastNTSCMode[REG_STRING_DATA_MAX];          // String
    U008    LastPALMode[REG_STRING_DATA_MAX];           // String
    U008    CRTMode[REG_STRING_DATA_MAX];               // String
    U008    DFPMode[REG_STRING_DATA_MAX];               // String
    U008    NTSCMode[REG_STRING_DATA_MAX];              // String
    U008    PALMode[REG_STRING_DATA_MAX];               // String
    U008    DefaultCRTRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    DefaultDFPRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    OptimalCRTRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    OptimalDFPRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    DisplayDeviceType[REG_STRING_DATA_MAX];     // String
    U008    MonitorTiming[REG_STRING_DATA_MAX];         // String
    U032    DisplayType;                                // Dword
    U032    TVType;                                     // Dword
    U032    CursorAlpha;                                // Dword
    } NT_NV_REGISTRY_DISPLAY;

typedef struct _NT_NV_REGISTRY_DIRECTDRAW
    {
    U032    VPENABLE;                                   // Dword
    U032    OverlayMode;                                // Dword
    U032    OverlayColorControlEnable;                  // Dword
    U032    OverlayBrightness;                          // Dword
    U032    OverlayContrast;                            // Dword
    U032    OverlayHue;                                 // Dword
    U032    OverlaySaturation;                          // Dword
    U032    OverlayGamma;                               // Dword
    U032    OverlaySharpness;                           // Dword
    } NT_NV_REGISTRY_DIRECTDRAW;


typedef struct _NT_NV_REGISTRY_DIRECT3D
    {
    U032    ANTIALIASENABLE;                            // Dword
    U032    COLORKEYCOMPATABILITYENABLE;                // Dword
    U032    CONTROLTRAFFIC;                             // Dword
    U032    DIRECTMAPENABLE;                            // Dword
    U032    FOGTABLENABLE;                              // Dword
    U032    LOGOENABLE;                                 // Dword
    U032    SCENESYNCENABLE;                            // Dword
    U032    TILINGENABLE;                               // Dword
    U032    USERMIPMAPENABLE;                           // Dword
    U032    VIDEOTEXTUREENABLEENABLE;                   // Dword
    U032    VSYNCENABLE;                                // Dword
    U032    WENABLE;                                    // Dword
    U032    Z24ENABLE;                                  // Dword        
    U032    AAMETHOD;                                   // Dword
    U032    AUTOMIPMAPMETHOD;                           // Dword
    U032    CKREF;                                      // Dword
    U032    DX6ENABLE;                                  // Dword
    U032    ANISOTOPIC4TAP;                             // Dword
    U032    PAL8TEXTURECONVERT;                         // Dword
    U032    PMTRIGGER;                                  // Dword
    U032    TEXELALIGNMENT;                             // Dword
    U032    VALIDATEZMETHOD;                            // Dword
    U032    W16FORMAT;                                  // Dword
    U032    W32FORMAT;                                  // Dword
    U032    AGPTEXCUTOFF;                               // Dword       
    U032    D3DCONTEXTMAX;                              // Dword
    U032    D3DTEXTUREMAX;                              // Dword
    U032    DMAMINPUSHCOUNT;                            // Dword
    U032    LODBIASADJUST;                              // Dword     
    U032    MINVIDEOTEXSIZE;                            // Dword
    U032    MIPMAPLEVELS;                               // Dword       
    U032    PERFSTRATEGY;                               // Dword
    U032    NOVSYNCPREREDNERLIMIT;                      // Dword
    U032    DMAPUSHBUFFERSIZEMAX;                       // Dword
    U032    TEXHEAP;                                    // Dword
    U032    WSCALE16;                                   // Dword
    U032    WSCALE24;                                   // Dword
    
    
    } NT_NV_REGISTRY_DIRECT3D;


typedef struct _NT_NV_REGISTRY_SYSTEM
    {
    U032    Super7Compat;                               // Dword  
    U032    FlipOnHSync;                                // Dword                     
    U032    FilterOverride;                             // Dword                  
    U032    NoNT4AGP;                                   // Dword
    U032    George;                                     // Dword
    U032    Gracie;                                     // Dword
    U032    TVOutOnPrimary;                             // Dword
    U032    Enable256Burst;                             // Dword
    U032    DisableMPCDetect;                           // Dword
    U032    MemoryOverride;                             // Dword
    U032    RTLOverride;                                // Dword
    } NT_NV_REGISTRY_SYSTEM;


typedef struct _NT_NV_REGISTRY_NVTWEAK
    {
    U032    test;                                       // Dword
    } NT_NV_REGISTRY_NVTWEAK;
                     



    //**************************************************************************
    // Complete Registry Structure
    //**************************************************************************


typedef struct _NT_NV_REGISTRY
    {
    //**************************************************************************
    // DISPLAY Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DISPLAY Display;
            
    //**************************************************************************
    // DIRECTDRAW Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DIRECTDRAW DirectDraw;

    //**************************************************************************
    // DIRECT3D Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DIRECT3D Direct3D;

    //**************************************************************************
    // RESMAN Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_SYSTEM System;

    //**************************************************************************
    // NVTWEAK Control Panel Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_NVTWEAK NVTweak;


    } NT_NV_REGISTRY;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\nv.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nv.h
//
// Abstract:
//
//     This module contains the definitions for the code that implements the
//     NVidia NV device driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

//******************************************************************************
// Include IOCTL codes to be shared among all components of driver
//******************************************************************************

#include <dspioctl.h>
#include "ntnvreg.h"

#ifdef NVPE
#include "nvpecntx.h"
#endif // NVPE

#include "nvMultiMon.h"

// Uncomment this line to enable the common modeset code
//#define ENABLE_COMMON_MODESET_CODE

// Uncomment this line to enable exporting the EDID data in nvGetChildDescriptor().
// Terry needs to automatically disble EDID processing when the user wants to switch to spanning modes before
// This code can be enabled.
// #define ENABLE_EXPORTING_EDID_TO_WIN2K

// Uncomment this line to enable the new ResMan power management API code
#define ENABLE_RESMAN_ACPI_CODE

//
// Win2K currently supports 8 different power states as defined in ntddvdeo.h
// We use 16 slots just as a cushion for future additional power states in succeeding
// versions of Win2K.
//
#define MAX_WIN2K_POWER_STATES 16
//
// The only power states of relevance in Win2K currently are on, standby, suspend, off, hibernate
//
#define NV_VideoPowerUnspecified 0
#define NV_VideoPowerOn 1
#define NV_VideoPowerStandBy 2
#define NV_VideoPowerSuspend 3
#define NV_VideoPowerOff 4
#define NV_VideoPowerHibernate 5
#define NV_VideoPowerShutdown 6


//******************************************************************************
// Common typedefs
//******************************************************************************

typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;

typedef unsigned long   BOOL;
typedef long            S032;

#define PHYSICAL_ADDRESS_VALUE(p) ((p).LowPart)

//******************************************************************************
// Polymorphic type stubs for NT4
//******************************************************************************

#if (_WIN32_WINNT < 0x0500)
#define SIZE_T ULONG
#define ULONG_PTR ULONG
#endif // _WIN32_WINNT < 0x0500

//******************************************************************************
// Monitor types  -> Values MUST agree with those from RM !!!
//******************************************************************************

#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3

// Use the following for monitor types. The ones above are obsolete names.
#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

// Use the following for display types. The ones above are obsolete names.
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3

//******************************************************************************
// Our hardcoded defines
//******************************************************************************

#define MAX_CLIP_REGIONS      16
#define MAX_GRPATCH_FANOUT    56
#define MAX_GRPATCH_INPUT     56
#define NUM_PATCHES           10
#define NUM_SUBCHANNELS       8
#define NUM_GRAPHICS_DEVICES  0x1e
#define INVALID               0xffffffff;
#define BIOS_STR_MAX 50

//******************************************************************************
// Size of saved BIOS image (used for manual posting)
//******************************************************************************

#define SAVED_BIOS_IMAGE_SIZE   0x10000

//******************************************************************************
// Bios memory sizing adjust value (for RM Post Device memory sizing)
//******************************************************************************

#define BIOS_MEM_SIZE_ADJUST_FACTOR 0x00010000;

//******************************************************************************
// EDID buffer size (in bytes)
//******************************************************************************

#define EDID_V2_SIZE   256

//******************************************************************************
// Max Size in bytes of saved instance memory (used when powering down)
//******************************************************************************

#define MAX_INSTANCE_MEM_SIZE   0x30000

//******************************************************************************
// Enough memory to store registry data
//
// Set MAX of 30 numbers per mode entry (each line) in INF
// Set MAX of 90  mode entries ( MAX 30 width_height * 3 (for depths))
// Data table will consist of type U016
//
//          Registry Data Format (word values)
//              MAX word values per line = 30 word values
//              MAX of 90 lines (90 mode entries)
//
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           etc...
//******************************************************************************

#define MAX_STRING_REGISTRY_VALUES  30
#define MAX_STRING_REGISTRY_LINES   90
#define MAX_STRING_REGISTRY_DATA_WORDS (MAX_STRING_REGISTRY_VALUES * MAX_STRING_REGISTRY_LINES)

//******************************************************************************
// Enough memory to store valid mode table data
// Set MAX of 1800 mode entries ( MAX 30 width/height * 3 (for depths) * MAX 20 refresh rates)
// Each struct entry  has 5 entries (valid flag, width,height, bpp, refresh)
// Data table will consist of type U016
//******************************************************************************

#define MAX_VALID_MODE_REFRESH_RATES 20
#define MAX_VALID_MODE_TABLE_DATA_WORDS (MAX_STRING_REGISTRY_LINES * MAX_VALID_MODE_REFRESH_RATES * 5)


#define MAX_BIOS_SCAN 1024

//******************************************************************************
// VSync/HSync defines
//******************************************************************************

#define BUFFER_HSYNC_NEGATIVE  0
#define BUFFER_HSYNC_POSITIVE  1

//******************************************************************************
// Memory types
//******************************************************************************

#define NV_BUFFER_SDRAM            0
#define NV_BUFFER_SGRAM            1

//******************************************************************************
// Resolution defines
//******************************************************************************
#define RESOLUTION_640X480      0
#define RESOLUTION_320X240      3
#define RESOLUTION_320X400      6
#define RESOLUTION_400X300      9
#define RESOLUTION_480X360      12
#define RESOLUTION_512X384      15
#define RESOLUTION_640X400      18
#define RESOLUTION_320X200      21
#define RESOLUTION_800X600      24
#define RESOLUTION_960X720      27
#define RESOLUTION_1024X768     30
#define RESOLUTION_1152X864     33
#define RESOLUTION_1280X1024    36
#define RESOLUTION_1600X1200    39
#define RESOLUTION_1800X1440    42
#define RESOLUTION_1920X1080    45
#define RESOLUTION_1920X1200    48

//******************************************************************************
// Various NV Chip ID's
//******************************************************************************

#define NV1_REV_B_02             2
#define NV1_REV_B_03             3
#define NV1_REV_C_01             4
#define NV1_REV_C_02             5
#define NV3_REV_A_00             0
#define NV3_REV_B_00             1
#define NV3_REV_C_00             2


//******************************************************************************
// NV1 Color Format values to be used to generate CONTEXT values
// for STATIC image objects. (Assumes only Destination Buffer 0 enabled)
//******************************************************************************

#define COLOR_FORMAT_X17R5G5B5        0x00000000
#define COLOR_FORMAT_X16A1R5G5B5      0x00002000
#define COLOR_FORMAT_X8R8G8B8         0x00000200
#define COLOR_FORMAT_A8R8G8B8         0x00002200
#define COLOR_FORMAT_X2R10G10B10      0x00000400
#define COLOR_FORMAT_A2R10G10B10      0x00002400
#define COLOR_FORMAT_X24Y8            0x00000600
#define COLOR_FORMAT_X16A8Y8          0x00002600

//******************************************************************************
// NV3 Color Format values to be used to generate CONTEXT values
// for STATIC image objects. (Assumes only Destination Buffer 0 enabled)
// See PGRAPH_CTX_SWITCH register definition for more information.
//******************************************************************************

#define NV3_COLOR_FORMAT_X17R5G5B5        (0x00000000)
#define NV3_COLOR_