Registry routines of general use
//

BOOL
GetMaxSizeValueInKey(
    HKEY    hKey,
    LPDWORD cbData
    );

PVOID
GetValueEntry(
    HKEY  hKey,
    LPSTR szValueName
    );

BOOL
GenerateUniqueFileName(
    IN     LPSTR TempPath,
    IN     LPSTR Prefix,
    IN OUT LPSTR TempFile
    );


//
// 2. Install workers
//

BOOL
SetMyComputerNameWorker(
    LPSTR ComputerName
    );


BOOL
SetEnvVarWorker(
    LPSTR UserOrSystem,
    LPSTR Name,
    LPSTR Title,
    LPSTR RegType,
    LPSTR Data
    );

BOOL
ExpandSzWorker(
    LPSTR EnvironmentString,
    LPSTR ReturnBuffer,
    DWORD cbReturnBuffer
    );

VOID
DoDelnode(
    IN PCHAR Directory
    );

//=====================================================
// Security.c declarations
//=====================================================


#define ENABLE_PRIVILEGE  0
#define DISABLE_PRIVILEGE 1
#define RESTORE_PRIVILEGE 2


//
// 1. Security routines of general use
//

BOOL
AdjustPrivilege(
    IN LONG PrivilegeType,
    IN INT  Action,
    IN PTOKEN_PRIVILEGES PrevState,
    IN PULONG ReturnLength
    );

BOOL
RestorePrivilege(
    IN PTOKEN_PRIVILEGES PrevState
    );

//
// 2. Workers for install entry points
//

BOOL
CheckPrivilegeExistsWorker(
    IN LPSTR PrivilegeType
    );

BOOL
EnablePrivilegeWorker(
    LPSTR PrivilegeType,
    LPSTR Action
    );

//======================================================
// Printer.c declarations
//======================================================

BOOL
AddPrinterDriverWorker(
    LPSTR Model,
    LPSTR Environment,
    LPSTR Driver,
    LPSTR DataFile,
    LPSTR ConfigFile,
    LPSTR Server
    );

BOOL
AddPrinterWorker(
    LPSTR Name,
    LPSTR Port,
    LPSTR Model,
    LPSTR Description,
    LPSTR PrintProcessor,
    DWORD Attributes,
    LPSTR Server
    );

BOOL
AddPrinterMonitorWorker(
    IN LPSTR Model,
    IN LPSTR Environment,
    IN LPSTR Driver,
    IN LPSTR Server
    );

//======================================================
// Netcon.c declarations
//======================================================
BOOL
AddNetConnectionWorker(
    IN LPSTR szUNCName,
    IN LPSTR szPassword,
    IN LPSTR szLocalName
    );

BOOL
DeleteNetConnectionWorker(
    IN LPSTR szLocalName,
    IN LPSTR szForceClosure
    );

CHAR CheckNetConnection(
    LPSTR szUNCName
    );

VOID
DeleteAllConnectionsWorker(
    VOID
   );


//======================================================
// Nls.c declarations
//======================================================

BOOL
SetCurrentLocaleWorker(
    LPSTR Locale,
    LPSTR ModifyCPL
    );


//======================================================
// sc.c declarations (service controller)
//======================================================

BOOL
TestAdminWorker(
    );

BOOL
SetupCreateServiceWorker(
    LPSTR   lpServiceName,
    LPSTR   lpDisplayName,
    DWORD   dwServiceType,
    DWORD   dwStartType,
    DWORD   dwErrorControl,
    LPSTR   lpBinaryPathName,
    LPSTR   lpLoadOrderGroup,
    LPSTR   lpDependencies,
    LPSTR   lpServiceStartName,
    LPSTR   lpPassword
    );

BOOL
SetupChangeServiceStartWorker(
    LPSTR   lpServiceName,
    DWORD   dwStartType
    );

BOOL
SetupChangeServiceConfigWorker(
    LPSTR  lpServiceName,
    DWORD  dwServiceType,
    DWORD  dwStartType,
    DWORD  dwErrorControl,
    LPSTR  lpBinaryPathName,
    LPSTR  lpLoadOrderGroup,
    LPSTR  lpDependencies,
    LPSTR  lpServiceStartName,
    LPSTR  lpPassword,
    LPSTR  lpDisplayName
    );

LPSTR
ProcessDependencyList(
    LPSTR lpDependenciesList
    );

//======================================================
// Mips NVRAM var functions
//======================================================

BOOL GetEnvironmentString(IN LPSTR lpVar, OUT LPSTR lpValue,IN  USHORT MaxLengthValue);
BOOL SetEnvironmentString(IN LPSTR lpVar, IN LPSTR lpValue);

//
// Object directory manipulation functions
//

BOOL
GetSymbolicLinkSource(
    IN  PUNICODE_STRING pObjDir_U,
    IN  PUNICODE_STRING pTarget_U,
    OUT PUNICODE_STRING pSource_U
    );

BOOL
GetSymbolicLinkTarget(
    IN     PUNICODE_STRING pSourceString_U,
    IN OUT PUNICODE_STRING pDestString_U
    );

//
// DOS Name and Arc Name space manipulation
//

BOOL
DosPathToNtPathWorker(
    IN  LPSTR DosPath,
    OUT LPSTR NtPath
    );

BOOL
NtPathToDosPathWorker(
    IN  LPSTR NtPath,
    OUT LPSTR DosPath
    );

BOOL
DosPathToArcPathWorker(
    IN  LPSTR DosPath,
    OUT LPSTR ArcPath
    );

BOOL
ArcPathToDosPathWorker(
    IN  LPSTR ArcPath,
    OUT LPSTR DosPath
    );

BOOL
IsDriveExternalScsi(
    IN  LPSTR DosDrive,
    OUT BOOL  *IsExternalScsi
    );


// external data

extern HANDLE MyDllModuleHandle;
extern ULONG  SectorSize;

// data structs

typedef struct _tagTEMPFILE {
    struct _tagTEMPFILE *Next;      // *MUST* BE THE FIRST FIELD!!!
    LPSTR               Filename;
} TEMPFILE,*PTEMPFILE;

// the following are used for portable access to various
// in-memory copies of disk structures

#define LoadBYTE(x)   ((DWORD)(*(PBYTE)(x)))

#define LoadWORD(x)   ((DWORD)(    (USHORT)(* (PBYTE)(x)    )        \
                                | ((USHORT)(*((PBYTE)(x) + 1)) << 8) ))

#define LoadDWORD(x)  ((LoadWORD((PBYTE)(x)+2) << 16) | LoadWORD(x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\stack.c ===
#include "precomp.h"
#pragma hdrstop

extern HWND hWndShell;

/*
**  Pointer to top of Dialog Stack DBCB (dialog box context block).
*/
PDBCB  GLOBAL(pdbcbTop) = NULL;


/*
**  Purpose:
**      To allocate enough storage to hold one DBCB (dialog box context block).
**  Arguments:
**      None.
**  Returns:
**      A Non-NULL pointer to a block of memory the size of one DBCB if
**      allocation succeeds, NULL otherwise.
**
****************************************************************************/
PDBCB APIENTRY PdbcbAlloc()
{
    PDBCB pdbcb;

    if ((pdbcb = (PDBCB)SAlloc(sizeof(DBCB))) != (PDBCB)NULL)
        {
        pdbcb->szDlgName          = (SZ)NULL;
        pdbcb->hDlg               = (HDLG)NULL;
        pdbcb->lpprocDlg          = (WNDPROC)NULL;
        pdbcb->lpprocEventHandler = (PFNEVENT)NULL;
        pdbcb->hDlgFocus          = (HDLG)NULL;
        pdbcb->szHelp             = (SZ)NULL;
        pdbcb->hDlgHelp           = (HDLG)NULL;
        pdbcb->lpprocHelp         = (WNDPROC)NULL;
        pdbcb->pdbcbNext          = (PDBCB)NULL;
        pdbcb->fActive            = fFalse;
        }

    return(pdbcb);
}


/*
**  Purpose:
**      To free the storage occupied by one DBCB (dialog box context block).
**  Arguments:
**      pdbcb: A pointer to the DBCB.
**  Returns:
**      fFalse if the pdbcb is NULL or the operation fails, fTrue if the
**      operation succeeds.
**
*****************************************************************************/
BOOL APIENTRY FFreeDbcb(pdbcb)
PDBCB pdbcb;
{
    PreCondition(pdbcb != NULL, fFalse);

    SFree(pdbcb);
    return(fTrue);
}


/*
**  Purpose:
**      To push a dialog onto the dialog stack.
**  Arguments:
**      hinst:          Handle to instance of the APP (i.e. the shell).
**      szDlgName:      Name of the dialog (e.g. GetDestPath, PrinterSelection).
**      szDlgTemplate:  Name of dialog template.
**      hwndParent:     Handle to the dialogs parent window (i.e. the shell).
**      lpprocDlg:      Procedure-instance address for the dialog procedure.
**      lParam:         32-bit initialization value that will be passed to the
**                          dialog procedure when the dialog box is created.
**                          Currently unused by our general dialog procedures.
**      lpprocEH:       Procedure-instance address for the dialog event handler.
**      szHelp:         Name of Help dialog template associated with this dialog.
**      lpprocHelp:     Procedure-instance address for the help dlg procedure.
**  Returns:
**      A window handle to the dialog if the Push succeeds, NULL if it fails
**      (i.e. if unable to allocate storage for the DBCB or the dialog creation
**      fails.
**
****************************************************************************/
HDLG APIENTRY HdlgPushDbcb(hinst, szDlgName, szDlgTemplate,
    hwndParent, lpprocDlg, lParam, lpprocEH, szHelp, lpprocHelp)
HANDLE   hinst;
SZ       szDlgName;
SZ       szDlgTemplate;
HWND     hwndParent;
WNDPROC  lpprocDlg;
DWORD    lParam;
PFNEVENT lpprocEH;
SZ       szHelp;
WNDPROC  lpprocHelp;
{
    PDBCB pdbcb;

    Unused(szHelp);
    Unused(lpprocHelp);

    AssertDataSeg();

    ChkArg(hinst != NULL, 1, NULL);
    ChkArg(szDlgTemplate != NULL, 2, NULL);
    ChkArg(hwndParent != NULL, 4, NULL);
    ChkArg(lpprocDlg != NULL, 5, NULL);

    while ((pdbcb = PdbcbAlloc()) == NULL)
        if (!FHandleOOM(hwndParent))
            return(NULL);


    if (szDlgName != NULL)
        while ((pdbcb->szDlgName = SzDupl(szDlgName)) == (SZ)NULL)
            if (!FHandleOOM(hwndParent))
                return(NULL);

    pdbcb->lpprocDlg          = lpprocDlg;
    pdbcb->lpprocEventHandler = lpprocEH;


    pdbcb->pdbcbNext  = GLOBAL(pdbcbTop);


    if ((pdbcb->hDlg = HdlgCreateFillAndShowDialog(hinst, szDlgTemplate,
        hwndParent, lpprocDlg, lParam)) != NULL)
        {

        //
        // Disable the main app window
        //

        EnableWindow( hWndShell, fFalse );
        FFlashParentWindow( fFalse ) ;

        //
        // If there is a dialog on the stack disable it too
        //

        if (GLOBAL(pdbcbTop) != NULL) {
            FDisableDialog(GLOBAL(pdbcbTop)->hDlg);
        }

        GLOBAL(pdbcbTop) = pdbcb;

        //
        // Set this window as the active window
        //

        //SetActiveWindow( pdbcb->hDlg );
        SetForegroundWindow(pdbcb->hDlg);

    }

    return(pdbcb->hDlg);
}


/*
**  Purpose:
**      To pop a dialog from the dialog stack and free the storage occupied by
**      the DBCB(dialog box context block).
**  Arguments:
**      None.
**  Returns:
**      fFalse if the stack is empty, fTrue otherwise.
**
****************************************************************************/
BOOL APIENTRY FPopDbcb()
{
    PDBCB pdbcbTemp = GLOBAL(pdbcbTop);

    AssertDataSeg();

    // changed so that we no longer fail if there's nothing to pop (lonnym)
    // PreCondition(GLOBAL(pdbcbTop) != NULL, fFalse);
    if(GLOBAL(pdbcbTop) == NULL) {
        return(fTrue);
    }

    //
    // Enable the shell window till we have another dialog active
    //

    EnableWindow( hWndShell, fTrue );

    //
    // If the dialog stack is empty, flash the parent app's window
    //   if there is one.
    //
    if ( GLOBAL(pdbcbTop)->pdbcbNext == NULL )
    {
        FFlashParentWindow( fTrue ) ;
    }

    EvalAssert(FCloseDialog(GLOBAL(pdbcbTop)->hDlg));
    if (GLOBAL(pdbcbTop)->szDlgName != NULL) {
        SFree(GLOBAL(pdbcbTop)->szDlgName);
    }

    GLOBAL(pdbcbTop) = GLOBAL(pdbcbTop)->pdbcbNext;
    EvalAssert(FFreeDbcb(GLOBAL(pdbcbTemp)));

    return(fTrue);
}


/*
**  Purpose:
**      To pop N dialogs from the dialog stack and free the storage associated
**      with the N DBCB's (dialog box context blocks).
**  Arguments:
**      n: The non-negative number of dialogs to be popped from the stack.
**  Returns:
**      fTrue if n == 0 or the n'th Pops succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FPopNDbcb(cDlgs)
INT cDlgs;
{
    AssertDataSeg();

    ChkArg(cDlgs >= 0, 1, fFalse);

    if (cDlgs == 0)
        return(fTrue);

    while(--cDlgs != 0)
         EvalAssert(FPopDbcb());

    return(FPopDbcb());
}


/*
**  Purpose:
**      To preprocess messages sent to the main app window (i.e. the shell) that
**      have special significance to the UI component.  This function must be
**      inserted in the message loop in the app's WinMain. The message should
**      be passed to TranslateMessage or DispatchMessage if and only if
**      FUiLibFilter returns fTrue.
**  Arguments:
**      pmsg: points to a MSG data structure that contains the message to be
**              checked.
**  Returns:
**      fTrue if the message should also be passed to TranslateMessage and
**      DispatchMessage, and fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FUiLibFilter(pmsg)
MSG * pmsg;
{
    HDLG hDlg;
    HDLG hDlgHelp;

    AssertDataSeg();

    switch(pmsg->message)
        {
//    case WM_SETFOCUS:
//        if(GLOBAL(pdbcbTop) != NULL)
//            SetFocus(GLOBAL(pdbcbTop)->hDlg);
//        break;

//    case WM_KEYDOWN:
//        if (pmsg->wParam == VK_TAB && GetKeyState(VK_CONTROL) < 0)
//            {
//            EvalAssert(FToggleDlgActivation());
//            return(fFalse);
//            }
//        break;

    case WM_SYSCOMMAND:
        if (pmsg->wParam == SC_CLOSE && GLOBAL(pdbcbTop) != NULL)
            {
//            if (GLOBAL(pdbcbTop)->hDlgHelp != NULL)
//                SendMessage(GLOBAL(pdbcbTop)->hDlgHelp, WM_SYSCOMMAND, SC_CLOSE,
//                        pmsg->lParam);
//            else
                SendMessage(GLOBAL(pdbcbTop)->hDlg, WM_SYSCOMMAND, SC_CLOSE,
                        pmsg->lParam);
            return(fFalse);
            }
        break;
        }


    if (pdbcbTop == NULL)
        hDlg = hDlgHelp = NULL;
    else
        {
        hDlg = GLOBAL(pdbcbTop)->hDlg;
        hDlgHelp = NULL;
//        hDlgHelp  = GLOBAL(pdbcbTop)->hDlgHelp;
        }

    return(((hDlg == 0 || !IsDialogMessage(hDlg, pmsg)) &&
            (hDlgHelp == 0 || !IsDialogMessage(hDlgHelp, pmsg))));
}




/*
**  Purpose:
**      To activate and enable the dialog on the top of the stack.  This is
**      used after the dialog stack has been popped to resume the previously
**      inactive dialog.
**  Arguments:
**      None.
**  Returns:
**      fFalse if the stack is empty, fTrue otherwise.
**
****************************************************************************/
BOOL APIENTRY FResumeStackTop()
{
    AssertDataSeg();

    PreCondition(GLOBAL(pdbcbTop) != NULL, fFalse);

    EnableWindow( hWndShell, fFalse );
    FFlashParentWindow(  fFalse );

    FEnableDialog(GLOBAL(pdbcbTop)->hDlg);  /* do not EvalAssert */
    SetActiveWindow(GLOBAL(pdbcbTop)->hDlg);

//    EvalAssert(FActivateStackTop());

    return(fTrue);
}


/*
**  Purpose:
**      To get the name of the dialog on the top of the dialog stack.
**  Arguments:
**      None.
**  Returns:
**      NULL if the stack is empty, the sz that is the name of the top-of-stack
**      dialog otherwise.
**
*****************************************************************************/
SZ APIENTRY SzStackTopName()
{
    AssertDataSeg();

    if (GLOBAL(pdbcbTop) == NULL)
        return(NULL);
    else
        return(GLOBAL(pdbcbTop)->szDlgName);
}


/*
**  Purpose:
**      Called by the main app (i.e. the shell) to handle the events that can
**      occur while executing the top-of-stack dialog.  The events can
**      optionally be preprocessed by a specific event handler for the dialog.
**      The standard events (continue, back, help, exit) can be handled
**      directly.
**  Arguments:
**      hInst:      Handle to instance of the APP (i.e. the shell).
**      hwndShell:  Handle to the main app window (i.e. the shell).
**      wMsg:       UI-Lib defined messages indicating what event occurred.
**      wParam:     the wParam associated with the message wMsg.
**      lParam:     the lParam associated with the message wMsg.
**  Notes:
**      This processes button events by getting the associated value for
**      $(ButtonPressed) from the Symbol Table (set by the standard dialogs)
**      and, if that value equals IDC_C, IDC_B, or IDC_X, setting the
**      value associated with the symbol $(DLGEVENT) to either "CONTINUE",
**      "BACK", or "EXIT" respectively.
**  Returns:
**      fTrue if the event was handled, fFalse otherwise or if the stack is
**      empty.
**
*****************************************************************************/
BOOL APIENTRY FGenericEventHandler(HANDLE hInst, HWND hwndShell,
        UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PFNEVENT pfnEvent;
    EHRC     ehrc = ehrcNotHandled;

    AssertDataSeg();

    PreCondition(GLOBAL(pdbcbTop) != NULL, fFalse);

    if (GLOBAL(pdbcbTop)->lpprocEventHandler != NULL)
        {
        pfnEvent = (PFNEVENT)GLOBAL(pdbcbTop)->lpprocEventHandler;
        ehrc = (*pfnEvent)(hInst, hwndShell, wMsg, wParam, lParam);
        }

    if (ehrc == ehrcNotHandled)
        {
        SZ szEvent;

        ehrc = ehrcPostInterp;
        EvalAssert((szEvent= SzFindSymbolValueInSymTab("ButtonPressed"))!=NULL);

        switch (atoi(szEvent))
            {
        case IDC_C:
            szEvent = "CONTINUE";
            break;

        case IDCANCEL:
        case IDC_B:
            szEvent = "BACK";
            break;

        case IDC_H:
            szEvent = "HELP";
            break;

        case IDC_X:
            szEvent = "EXIT";
            break;

        case IDC_M:
            szEvent = "FREEBUTTON1";
            break;

        case IDC_O:
            szEvent = "FREEBUTTON2";
            break;

        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:
            {
            SZ butns[10] = {"DLGBUTTON0",
                            "DLGBUTTON1", "DLGBUTTON2", "DLGBUTTON3",
                            "DLGBUTTON4", "DLGBUTTON5", "DLGBUTTON6",
                            "DLGBUTTON7", "DLGBUTTON8", "DLGBUTTON9",
                           };
            szEvent = butns[atoi(szEvent) - IDC_BTN0];
            }
            break;

        default:
            szEvent = (SZ)NULL;
            ehrc = ehrcError;
            break;
            }

        if (szEvent != (SZ)NULL)
            {
            while (!FAddSymbolValueToSymTab("DLGEVENT", szEvent))
                if (!FHandleOOM(hwndShell))
                    ehrc = ehrcError;
            }
        }

    if (ehrc == ehrcPostInterp)
        PostMessage(hwndShell, (WORD)STF_SHL_INTERP, 0, 0L);

    return(ehrc != ehrcError);
}


/*
**  Purpose:
**      To check if the stack is empty.
**  Arguments:
**      None.
**  Returns:
**      fTrue if the stack is empty, fFalse otherwise.
**
*****************************************************************************/
BOOL APIENTRY FStackEmpty()
{
    AssertDataSeg();

    return(!GLOBAL(pdbcbTop));
}


/*
**  Purpose:
**      To get the handle of the dialog on the top of the stack.
**  Arguments:
**      None.
**  Returns:
**      The handle to the dialog on the top of the stack, or NULL if the
**      stack is empty.
**
*****************************************************************************/
HDLG APIENTRY HdlgStackTop()
{
    AssertDataSeg();

    if (GLOBAL(pdbcbTop) == (PDBCB)NULL)
        return((HDLG)NULL);

    return((GLOBAL(pdbcbTop))->hDlg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\sysinicm.c ===
#include "precomp.h"
#pragma hdrstop
/* File - SYSINICM.C */


extern HWND hwndFrame;


void APIENTRY ConstructSysIniLine(SZ, SZ, SZ);
SZ   APIENTRY SzNextConfigLine(SZ);
SZ   APIENTRY SzSysIniEdit(SZ, SZ, SZ, SZ);
BOOL APIENTRY FCreateSysIniKeyValue(SZ, SZ, SZ, SZ, CMO);
SZ   APIENTRY SzCopyBuf(SZ, SZ, int);
int  APIENTRY Linelenl(SZ);


#define ISWHITE(c) ((c) == ' '  || (c) == '\t' || (c) == '\n' || (c) == '\r')
#define UP_CASE(c) (CHP)(LOBYTE(LOWORD((DWORD)(AnsiUpper((LPSTR)MAKELONG((WORD)(c),0))))))
#define MAX_INF_LINE_LEN	(150)
#define ISEOL(c)     	((c) == '\n' || (c) == '\r')
#define	_CR 0x0D
#define LF 0x0A



/* void ConstructSysIniLine(char*, char*, char*);
*
* ENTRY:   szSysIniLine, Address of a buffer large enough to hold the
*                        constructed system.ini line.
*          ProfString,   The profile string to be used in constructing
*                        the system.ini line.
*          NameString,   The name of the driver, exe, or any string to
*                        be placed after the profile string in the new
*                        system.ini line.
*
* EXIT :   No exit value, newly constructed system.ini line will reside
*          in buffer pointed to by szSysIniLine.
*
***********************************************************************/
void APIENTRY ConstructSysIniLine(szSysIniLine, szProfString, szNameString)
SZ szSysIniLine;
SZ szProfString;
SZ szNameString;
{
	strcpy(szSysIniLine, szProfString);
	SzStrCat(szSysIniLine, "=");
	if (*(szNameString + 1) == ':')
		SzStrCat(szSysIniLine, (szNameString + 2));
	else
		SzStrCat(szSysIniLine, szNameString);
}


/* LPSTR fnNextConfigLine(LPSTR lpFileOffset);
*
* Advances Far pointer into config.sys files to the first non-white char
* of the next line in the buffer containing the file. Will return null
* in the EOF case.
*
* ENTRY: Far pointer into buffer holding file.
*
* EXIT:  Far pointer into buffer holding file. NULL on EOF.
*
***********************************************************************/
SZ APIENTRY SzNextConfigLine(szFileOffset)
SZ szFileOffset;
{
	while (!ISEOL(*szFileOffset))
		szFileOffset = SzNextChar(szFileOffset);

	while (ISWHITE(*szFileOffset) && *szFileOffset != 0)
		szFileOffset = SzNextChar(szFileOffset);

	return(szFileOffset);
}


/* BOOL fnSysIniEdit(PSTR szSection,PSTR szSysIniLine);
*
*  This function will either add or remove an entire line from the
*  system.ini file.
*
* ENTRY:    szSection, section string, [boot], [system], or [win386]
*           specifies section from which line will be added to. Ignored
*           when removing an entry.
*
*           szSysIniLine, buffer containing line to be added to system.ini
*           file. In the case of RETURN, this buffer will return the line
*           from system.ini
*
* EXIT:     Returns bool value as to success or failure of function.
*
***********************************************************************/
SZ APIENTRY SzSysIniEdit(szFile, szSection, szSysIniLine, szIniBuf)
SZ szFile;
SZ szSection;
SZ szSysIniLine;
SZ szIniBuf;
{
	BOOL fResult;
	SZ   szFileOffset;
	SZ   szTo;
	SZ   szNewHead;

	szFileOffset = szIniBuf;
	while (ISWHITE(*szFileOffset) && *szFileOffset != '\0')
		szFileOffset = SzNextChar(szFileOffset);

	if (*szFileOffset == '\0')
		/* REVIEW should create it */
		{
		EvalAssert(EercErrorHandler(hwndFrame, grcMissingSysIniSectionErr,
				fTrue, szSection, szFile, 0) == eercAbort);
        return(NULL);
		}

	while ((szTo = (SZ)SAlloc(strlen(szIniBuf) + strlen(szSysIniLine)
			+ 3)) == (SZ)NULL)
		if (!FHandleOOM(hwndFrame))
            return(NULL);

	szNewHead = szTo;
	fResult = fFalse;
	while (*szFileOffset != 0 && fResult == fFalse)
		{
		if (!strncmp(szSection, SzNextChar(szFileOffset),strlen(szSection)))
			{
			szTo = SzCopyBuf(szFileOffset, szTo, Linelenl(szFileOffset));
			szTo = SzCopyBuf(szSysIniLine, szTo, strlen(szSysIniLine));
			szFileOffset = SzNextConfigLine(szFileOffset);
			*szTo = _CR;
			szTo = SzNextChar(szTo);
			*szTo = LF;
			szTo = SzNextChar(szTo);
			SzCopyBuf(szFileOffset, szTo, 0Xffff);
			SFree(szIniBuf);
			szIniBuf = szNewHead;
			fResult = fTrue;
			continue;
			}
		szTo = SzCopyBuf(szFileOffset, szTo, Linelenl(szFileOffset));
		szFileOffset = SzNextConfigLine(szFileOffset);
		}

	if (fResult)
	   	return(szIniBuf);
	else
		{
		/* REVIEW should create it */
		EvalAssert(EercErrorHandler(hwndFrame, grcMissingSysIniSectionErr,
				fTrue, szSection, szFile, 0) == eercAbort);
		return(NULL);
		}
}


/*
**	Purpose:
**	Arguments:
**		szFile:	a zero terminated string containing the file name for the
**			ini file.
**		szSect:	a zero terminated string containing the name of the section
**			in which the key/value pair will be created.
**		szKey:	the name of the key to be created in the section szSect.
**		szValue:	the name of the value to be created in conjunction with the
**			key szKey in the section szSect.
**		cmo:		valid command options:
**			cmoNone: 	  no effect
**			cmoOverwrite: causes the key/value pair to be removed if it
**				already exists before creating the key.
**			cmoVital:	  causes the Vital command handler to be called
**				if the function fails for any reason.
**	Returns:
**	  	fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FCreateSysIniKeyValue(SZ  szFile,
                                                SZ  szSect,
                                                SZ  szKey,
                                                SZ  szValue,
                                                CMO cmo)
{
	struct _stat FileStatus;
	CHL  szSysIniLine[MAX_INF_LINE_LEN];
	PFH  pfh;
	SZ   szIniBuf;
	BOOL fVital = cmo & cmoVital;
	EERC eerc;

	while ((pfh = PfhOpenFile(szFile, ofmRead)) == (PFH)NULL)
		if ((eerc = EercErrorHandler(hwndFrame, grcOpenFileErr, fVital, szFile,
				0, 0)) != eercAbort)
			return(eerc == eercIgnore);

	while (_fstat(pfh->iDosfh, &FileStatus))
		if ((eerc = EercErrorHandler(hwndFrame, grcReadFileErr, fVital, szFile,
				0, 0)) != eercAbort)
			{
			EvalAssert(FCloseFile(pfh));
			return(eerc == eercIgnore);
			}

	while ((szIniBuf = (SZ)SAlloc((CB)FileStatus.st_size + 1)) == (SZ)NULL)
		if (!FHandleOOM(hwndFrame))
			{
			EvalAssert(FCloseFile(pfh));
			return(!fVital);
			}

	Assert((CB)(FileStatus.st_size) < (CB)(-1));
	if ((CB)(FileStatus.st_size) != CbReadFile(pfh, szIniBuf,
			(CB)(FileStatus.st_size)))
		{
        EvalAssert(EercErrorHandler(hwndFrame, grcReadFileErr, fVital, szFile,
				0, 0) == eercAbort);
		SFree(szIniBuf);
		EvalAssert(FCloseFile(pfh));
		return(!fVital);
		}

	*(szIniBuf + FileStatus.st_size) = '\0';
	EvalAssert(FCloseFile(pfh));

	ConstructSysIniLine((SZ)szSysIniLine, szKey, szValue);
	if ((szIniBuf = SzSysIniEdit(szFile, szSect, szSysIniLine, szIniBuf)) ==
			(SZ)NULL)
		{
		SFree(szIniBuf);
		return(!fVital);
		}

	while (!(pfh = PfhOpenFile(szFile, ofmCreate)))
		if ((eerc = EercErrorHandler(hwndFrame, grcOpenFileErr, fVital, szFile,
				0, 0)) != eercAbort)
			{
			SFree(szIniBuf);
			return(eerc == eercIgnore);
			}

	if (strlen(szIniBuf) != CbWriteFile(pfh, szIniBuf,
			strlen(szIniBuf)))
		{
		EvalAssert(FCloseFile(pfh));
		SFree(szIniBuf);
        EvalAssert(EercErrorHandler(hwndFrame, grcWriteFileErr, fVital, szFile,
				0, 0) == eercAbort);
		return(!fVital);
		}

	EvalAssert(FCloseFile(pfh));
	SFree(szIniBuf);

	return(fTrue);
}


/* LPSTR NEAR PASCAL fnCopyBuff(LPSTR pFrom, LPSTR pTo);
*
* Function moves the remaining contents of a text buffer from one location
* within the buffer to a new location within the buffer. This is used to
* either remove or make room for an entry in the file buffer.
*
* ENTRY: pointers To and From designate where the remaining protion of the
*        buffer will be moved to. The new buffer will be NULL terminated.
*
* EXIT:  Returns pointer to next available char position in the buffer.
*
***********************************************************************/
SZ APIENTRY SzCopyBuf(szFrom,szTo,iCnt)
SZ  szFrom;
SZ  szTo;
int iCnt;
{
	/* REVIEW won't work for DBCS */
	while (*szFrom != 0 && iCnt-- != 0)
		{
		*szTo = *szFrom;
		szTo   = SzNextChar(szTo);
		szFrom = SzNextChar(szFrom);
		}

	if (*szFrom == '\0')
		*szTo = '\0';

	return(szTo);
}


/* int fnLinelenl(LPSTR)
*
* Returns length of buffer line up to and including the LF char.
* (far pointer version).
*
* ENTRY:    LPSTR to buffer
* EXIT:     length of line.
*
***********************************************************************/
int APIENTRY Linelenl(szBuf)
SZ szBuf;
{
	unsigned i = 1;

	while (*szBuf != LF)
		{
		szBuf = SzNextChar(szBuf);
		i++;
		}

	return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\stinf2.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Common Library Component - SymTab INF File Handling Routines 2 *****/
/**************************************************************************/



/*
**	Purpose:
**		Adds a new symbol/value association to the Symbol Table for the
**		key and first field of the current line pointed to by the current
**		INF read location.
**	Arguments:
**		none
**	Notes:
**		Requires that the current INF structure was initialized with a
**		successful call to GrcOpenInf() and that the current INF read
**		location is defined.
**		Requires that the Symbol Table was initialized with a successful
**		call to FInitSymTab().
**		Requires that the current INF line contain a key.
**	Returns:
**		fFalse if an allocate operation fails.
**		fTrue if the current line contains a key and it was successfully
**			associated with the value from the first field of the current
**			line (or the empty string if the first field does not exist.)
**
**************************************************************************/
BOOL APIENTRY FAddSymbolFromInfLineToSymTab(INT Line)
{
	BOOL fAnswer;
	SZ   szKey;
	SZ   szValue;

	PreCondSymTabInit(fFalse);
	PreCondInfOpen(fFalse);
    PreCondition(FKeyInInfLine(Line), fFalse);

    szKey = SzGetNthFieldFromInfLine(Line,0);
	AssertRet(*szKey != '\0' &&
			!FWhiteSpaceChp(*szKey), fFalse);

    if ((szValue = SzGetNthFieldFromInfLine(Line,1)) == (SZ)NULL)
		fAnswer = FAddSymbolValueToSymTab(szKey, "");
    else
        fAnswer = FAddSymbolValueToSymTab(szKey, szValue);

	if(szValue) {
        SFree(szValue);
    }

	SFree(szKey);

	return(fAnswer);
}


/*
**	Purpose:
**		Adds a new symbol/value association to the Symbol Table for the
**		key and first field of each line in the specified section.
**	Arguments:
**		szSection: non-NULL, non-empty section.
**	Notes:
**		Requires that the current INF structure was initialized with a
**		successful call to GrcOpenInf().
**		Requires that the Symbol Table was initialized with a successful
**		call to FInitSymTab().
**	Returns:
**		grcINFBadRSLine if any line does not contain a key.
**		grcOutOfMemory if any allocation operation fails.
**		grcOkay if szSection was found, each line in it contained a key, and
**			every key and first field (or the empty string if the first field
**			does not exist) is successfully added to the Symbol Table as a
**			symbol/value association.
**		grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcAddSymsFromInfSection(SZ szSection)
{
    INT  Line;

	AssertDataSeg();

	PreCondSymTabInit(grcNotOkay);
	PreCondInfOpen(grcNotOkay);

	ChkArg(szSection != (SZ)NULL &&
			*szSection != '\0' &&
			!FWhiteSpaceChp(*szSection), 1, grcNotOkay);

    Line = FindFirstLineFromInfSection(szSection);
    while (Line != -1)
		{
        if (!FKeyInInfLine(Line))
			return(grcINFBadRSLine);

        if (!FAddSymbolFromInfLineToSymTab(Line))
			return(grcOutOfMemory);

        Line = FindNextLineFromInf(Line);
		}

	return(grcOkay);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\strings.c ===
#include "precomp.h"
#pragma hdrstop

/*
**	Purpose:
**		Duplicates a zero terminated string into a newly allocated buffer
**		just large enough to hold the source string and its zero terminator.
**	Arguments:
**		sz: non-NULL zero terminated string to duplicate.
**	Returns:
**		NULL if a new buffer to hold the duplicated string cannot be allocated.
**		Pointer to a newly allocated buffer into which sz has been copied with
**			its zero terminator.
**
***************************************************************************/
SZ  APIENTRY SzDupl(sz)
SZ sz;
{
	SZ szNew;

	AssertDataSeg();
	ChkArg(sz != (SZ)NULL, 1, (SZ)NULL);

	if ((szNew = (SZ)SAlloc(strlen(sz) + 1)) != (SZ)NULL)
		strcpy(szNew, sz);

	return(szNew);
}



/*
**	Purpose:
**		Compares two zero terminated strings lexicographically and with
**		case-sensitivity.  Comparison depends on the current language
**		selected by the user.
**	Arguments:
**		sz1: non-NULL zero terminated string to compare.
**		sz2: non-NULL zero terminated string to compare.
**	Returns:
**		crcError for errors.
**		crcEqual if the strings are lexicographically equal.
**		crcFirstHigher if sz1 is lexicographically greater than sz2.
**		crcSecondHigher if sz2 is lexicographically greater than sz1.
**
***************************************************************************/
CRC  APIENTRY CrcStringCompare(sz1, sz2)
SZ sz1;
SZ sz2;
{
	INT iCmpReturn;

	AssertDataSeg();

	ChkArg(sz1 != (SZ)NULL, 1, crcError);
	ChkArg(sz2 != (SZ)NULL, 2, crcError);

	if ((iCmpReturn = lstrcmp((LPSTR)sz1, (LPSTR)sz2)) == 0)
		return(crcEqual);
	else if (iCmpReturn < 0)
		return(crcSecondHigher);
	else
		return(crcFirstHigher);
}


/*
**	Purpose:
**		Compares two zero terminated strings lexicographically and without
**		case-sensitivity.  Comparison depends on the current language
**		selected by the user.
**	Arguments:
**		sz1: non-NULL zero terminated string to compare.
**		sz2: non-NULL zero terminated string to compare.
**	Returns:
**		crcError for errors.
**		crcEqual if the strings are lexicographically equal.
**		crcFirstHigher if sz1 is lexicographically greater than sz2.
**		crcSecondHigher if sz2 is lexicographically greater than sz1.
**
***************************************************************************/
CRC  APIENTRY CrcStringCompareI(sz1, sz2)
SZ sz1;
SZ sz2;
{
	INT iCmpReturn;

	AssertDataSeg();

	ChkArg(sz1 != (SZ)NULL, 1, crcError);
	ChkArg(sz2 != (SZ)NULL, 2, crcError);

	if ((iCmpReturn = lstrcmpi((LPSTR)sz1, (LPSTR)sz2)) == 0)
		return(crcEqual);
	else if (iCmpReturn < 0)
		return(crcSecondHigher);
	else
		return(crcFirstHigher);
}


/*
**	Purpose:
**		Finds the last character in a string.
**	Arguments:
**		sz: non-NULL zero terminated string to search for end in.
**	Returns:
**		NULL for an empty string.
**		non-Null string pointer to the last valid character in sz.
**
***************************************************************************/
SZ  APIENTRY SzLastChar(sz)
SZ sz;
{
	SZ szCur  = (SZ)NULL;
	SZ szNext = sz;

	AssertDataSeg();

	ChkArg(sz != (SZ)NULL, 1, (SZ)NULL);

	while (*szNext != '\0')
		{
		szNext = SzNextChar((szCur = szNext));
		Assert(szNext != (SZ)NULL);
		}

	return(szCur);
}


#define MAX_BUFFER	1024

extern CHAR ReturnTextBuffer[MAX_BUFFER];

/*
ToLower - this function will convert the string to lower case.

Input: Arg[0] - string to be convertd.
Output: lower case string.

*/

BOOL
ToLower(
    IN DWORD cArgs,
    IN LPSTR Args[],
    OUT LPSTR *TextOut
    )

{
    int i;  // counter
    CHAR *pszTmp = ReturnTextBuffer;

    if ( cArgs < 1 )
    {
        SetErrorText(IDS_ERROR_BADARGS);
        return( FALSE );
    }

    for (i=0;(Args[0][i]!='\0') && (i<MAX_BUFFER);i++,pszTmp++)
    {
        *pszTmp = (CHAR)tolower(Args[0][i]);
    }
    *pszTmp='\0';

    *TextOut = ReturnTextBuffer;

    return TRUE;
}


/*

SetupStrncmp - Similar to c strncmp runtime library
    The user must passed 3 arguments to the function.
    1st argument - the first string
    2nd argument - the second string
    3rd argument - number of characters compared

    Provide the same function as strncmp

*/

BOOL
SetupStrncmp(
    IN DWORD cArgs,
    IN LPSTR Args[],
    OUT LPSTR *TextOut
    )

{
    if ( cArgs != 3 )
    {
        SetErrorText(IDS_ERROR_BADARGS);
        return( FALSE );
    }

    wsprintf( ReturnTextBuffer, "%d", strncmp( Args[0], Args[1], atol(Args[2])));

    *TextOut = ReturnTextBuffer;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\symtab.c ===
#include "precomp.h"
#pragma hdrstop

#ifdef SYMTAB_STATS
UINT SymbolCount;
#endif

/*
**	Purpose:
**      Creates a new Symbol Table.
**	Arguments:
**      szName - Name of the INF file
**	Returns:
**		fFalse if the initialization failed because it could not allocate
**			the memory it needed.
**		fTrue if the initialization succeeded.
**
**************************************************************************/
PINFTEMPINFO  APIENTRY CreateInfTempInfo( pPermInfo )
PINFPERMINFO pPermInfo;
{
    PINFTEMPINFO    pTempInfo;

    //
    //  Allocate space for context data
    //
    pTempInfo = (PINFTEMPINFO)SAlloc( (CB)sizeof(INFTEMPINFO) );

    if ( pTempInfo ) {

        if ( !(pTempInfo->SymTab  = SymTabAlloc())) {

            SFree(pTempInfo);
            pTempInfo = NULL;

        } else if ( !(pTempInfo->pParsedInf = ParsedInfAlloc( pPermInfo )) )  {

            FFreeSymTab( pTempInfo->SymTab );
            SFree(pTempInfo);
            pTempInfo = NULL;

        } else {

            pTempInfo->pInfPermInfo = pPermInfo;

            pTempInfo->cRef = 1;


            //
            //  Add to chain.
            //
            if ( pLocalContext() ) {
                pTempInfo->pPrev = pLocalInfTempInfo();
            } else {
                pTempInfo->pPrev = NULL;
            }
            pTempInfo->pNext = pTempInfo->pPrev ? (pTempInfo->pPrev)->pNext : NULL;

            if ( pTempInfo->pPrev ) {
                (pTempInfo->pPrev)->pNext = pTempInfo;
            }
            if ( pTempInfo->pNext ) {
                (pTempInfo->pNext)->pPrev = pTempInfo;
            }

        }
    }

    return pTempInfo;
}



#ifdef SYMTAB_STATS

void ContextDump( FILE*);
void TempInfoDump( FILE*);
void PermInfoDump( FILE*);
void SymTabDump( FILE*, PSYMTAB);

void
SymTabStatDump(void)
{
    FILE         *statfile;

    statfile = fopen("D:\\SYMTAB.TXT","wt");

    ContextDump( statfile );

    TempInfoDump( statfile );

    PermInfoDump( statfile );

    fclose(statfile);
}


void
ContextDump( FILE* f )
{
    PINFCONTEXT     pContext;
    UINT            i = 0;

    fprintf( f, "CONTEXT STACK DUMP\n");
    fprintf( f, "------------------\n");

    pContext = pLocalContext();

    while ( pContext ) {

        fprintf( f, "\n\n\n");
        fprintf( f, "Context #%u.- Line: %8u  INF Name: %s\n",
                 i,
                 pContext->CurrentLine, pContext->pInfTempInfo->pInfPermInfo->szName );
        fprintf( f, "Local Symbol Table:\n");

        SymTabDump( f, pContext->SymTab );

        i++;
        pContext = pContext->pNext;
    }

    fprintf( f, "\n\n\n");
}


void
TempInfoDump( FILE* f )
{
    PINFPERMINFO pPermInfo;
    PINFTEMPINFO pTempInfo;

    fprintf( f, "\n\n\n");
    fprintf( f, "INF TEMPORARY INFO DUMP\n");
    fprintf( f, "-----------------------\n");

    pTempInfo = pGlobalContext()->pInfTempInfo;

    while ( pTempInfo ) {

        pPermInfo = pTempInfo->pInfPermInfo;

        fprintf( f, "\n\n\n" );
        fprintf( f, "INF Name:         %s\n",  pPermInfo->szName );
        fprintf( f, "INF Id:           %8u\n", pPermInfo->InfId );
        fprintf( f, "Reference Count:  %8u\n", pTempInfo->cRef );
        fprintf( f, "Line Count:       %8u\n", pTempInfo->MasterLineCount );
        fprintf( f, "File Size:        %8u\n", pTempInfo->MasterFileSize );
        fprintf( f, "Static Symbol Table:\n");

        SymTabDump( f, pTempInfo->SymTab );

        pTempInfo = pTempInfo->pNext;
    }

    fprintf( f, "\n\n\n");
}



void
PermInfoDump( FILE* f )
{
    PINFPERMINFO pPermInfo;

    fprintf( f, "\n\n\n");
    fprintf( f, "INF PERMANENT INFO DUMP\n");
    fprintf( f, "-----------------------\n\n");

    pPermInfo = pInfPermInfoHead;

    while ( pPermInfo ) {

        fprintf( f, "INF Name:         %s\n",  pPermInfo->szName );

        pPermInfo = pPermInfo->pNext;
    }

    fprintf( f, "\n\n\n");
}


void
SymTabDump( FILE* f, PSYMTAB pSymTab )
{
    UINT    i;
    PSTE    p;

    fprintf( f, "\n");

    for(i=0; i<cHashBuckets; i++) {

        p = pSymTab->HashBucket[i];

        fprintf( f, "\n\tBucket # %u (%u items):\n",i,pSymTab->BucketCount[i]);

        while(p) {
            fprintf( f, "\n\t    Symbol = %s\n\t    Value  = %s\n",p->szSymbol,p->szValue);
            p = p->psteNext;
        }
    }
}

#endif


/*
**	Purpose:
**		Allocates an STE structure and returns it.
**	Arguments:
**		none
**	Returns:
**		NULL if the allocation failed.
**		Pointer to the allocated STE structure.
+++
**	Notes:
**		A linked list of unused STEs is maintained with FFreePste()
**		placing unused STEs into it.  If this linked list (psteUnused)
**		is empty then a block of cStePerSteb STEs is allocated at once
**		and added to the unused list with one being returned by this
**		routine.
**
**************************************************************************/
PSTE  APIENTRY PsteAlloc(VOID)
{
	PSTE pste;

	if (GLOBAL(psteUnused) == (PSTE)NULL)
		{
		PSTEB  psteb;
		USHORT us;

		if ((psteb = (PSTEB)SAlloc((CB)sizeof(STEB))) == (PSTEB)NULL)
			return((PSTE)NULL);
		psteb->pstebNext = GLOBAL(pstebAllocatedBlocks);
		GLOBAL(pstebAllocatedBlocks) = psteb;

		GLOBAL(psteUnused) = &(psteb->rgste[0]);
		for (us = 1; us < cStePerSteb; us++)
			(psteb->rgste[us - 1]).psteNext = &(psteb->rgste[us]);
		(psteb->rgste[cStePerSteb - 1]).psteNext = (PSTE)NULL;
		}

	pste = GLOBAL(psteUnused);
	GLOBAL(psteUnused) = pste->psteNext;

	pste->szSymbol = (SZ)NULL;
	pste->szValue  = (SZ)NULL;

#ifdef SYMTAB_STATS
    SymbolCount++;
#endif

    return(pste);

}


/*
**	Purpose:
**		Frees an STE structure.
**	Arguments:
**		pste: non-NULL STE structure to be freed.
**	Returns:
**		fFalse if either of the string fields of the STE structure or the
**			STE itself could not be successfully freed.
**		fTrue if both string fields of the STE structure and the structure
**			itself are successfully freed.
**
**************************************************************************/
BOOL  APIENTRY FFreePste(pste)
PSTE pste;
{
	BOOL fAnswer = fTrue;

	ChkArg(pste != (PSTE)NULL, 1, fFalse);

	if (pste->szSymbol != (SZ)NULL)
		SFree(pste->szSymbol);
	if (pste->szValue != (SZ)NULL)
		SFree(pste->szValue);

	pste->szSymbol = pste->szValue = (SZ)NULL;
	pste->psteNext = GLOBAL(psteUnused);
	GLOBAL(psteUnused) = pste;

#ifdef SYMTAB_STATS
    SymbolCount--;
#endif

	return(fAnswer);
}



/*
**  Purpose:
**      Decrements the reference count of a symbol table, freeing its
**      memory if the reference count reaches zero
**	Arguments:
**		none
**	Returns:
**		fFalse if all the STE structures and their string fields cannot be
**			successfully freed.
**		fTrue if all the STE structures and their string fields can be
**			successfully freed.
**
**************************************************************************/
BOOL  APIENTRY FFreeInfTempInfo( PVOID p )
{
    BOOL            fAnswer = fTrue;
    PINFTEMPINFO    pTempInfo = (PINFTEMPINFO)p;

    AssertDataSeg();


    if ( pTempInfo->cRef > 1 ) {

        pTempInfo->cRef--;

    } else {

        //
        //  Free static symbol table
        //
        FFreeSymTab( pTempInfo->SymTab );

        //
        //  Free preparsed INF
        //
        FFreeParsedInf( pTempInfo->pParsedInf );



        //
        //  Remove from chain
        //
        if ( pTempInfo->pPrev ) {
            (pTempInfo->pPrev)->pNext = pTempInfo->pNext;
        }
        if ( pTempInfo->pNext ) {
            (pTempInfo->pNext)->pPrev = pTempInfo->pPrev;
        }

        SFree(p);

        //
        //  bugbug ramonsa - should we free PSTE blocks here?
        //
    }
	return(fAnswer);
}


/*
**	Purpose:
**		Calculates a hash value for a zero terminated string of bytes
**		(characters) which is used by the Symbol Table to divide the
**		symbols into separate buckets to improve the search efficiency.
**	Arguments:
**		pb: non-NULL, non-empty zero terminated string of bytes.
**	Returns:
**		-1 for an error.
**		A number between 0 and cHashBuckets.
**
**************************************************************************/
USHORT  APIENTRY UsHashFunction( pb )
register PB pb;
{
	register USHORT usValue = 0;
        register PB     pbMax = pb + cbBytesToSumForHash ;

	ChkArg(pb != (PB)NULL &&
			*pb != '\0', 1, (USHORT)(-1));

        while ( *pb && pb < pbMax )
        {
            usValue = (usValue << 1) ^ (USHORT) *pb++ ;
        }

    return(usValue % (USHORT)cHashBuckets);
}


/*
**	Purpose:
**		Finds a corresponding STE structure if the symbol is already in
**		the Symbol Table or else points to where it should be inserted.
**	Arguments:
**		szSymbol: non-NULL, non-empty zero terminated string containing
**			the value of the symbol to be searched for.
**	Notes:
**		Requires that the Symbol Table was initialized with a successful
**		call to FInitSymTab().
**	Returns:
**		NULL in an error.
**		Non-NULL pointer to a pointer to an STE structure.  If szSymbol is
**			in the Symbol Table, then (*PPSTE)->szSymbol is it.  If szSymbol
**			is not in the Symbol Table, then *PPSTE is the PSTE to insert
**			its record at.
**
**************************************************************************/
PPSTE  APIENTRY PpsteFindSymbol(pSymTab, szSymbol)
PSYMTAB pSymTab;
SZ      szSymbol;
{
    PPSTE   ppste;
    USHORT  usHashValue;

    PreCondSymTabInit((PPSTE)NULL);

    ChkArg(  szSymbol != (SZ)NULL
           && *szSymbol != '\0', 1, (PPSTE)NULL);

    usHashValue = UsHashFunction(szSymbol);

    ppste = &(pSymTab->HashBucket[usHashValue]);
    AssertRet(ppste != (PPSTE)NULL, (PPSTE)NULL);
    AssertRet(*ppste == (PSTE)NULL ||
              ((*ppste)->szSymbol != (SZ)NULL &&
              *((*ppste)->szSymbol) != '\0' &&
              (*ppste)->szValue != (SZ)NULL), (PPSTE)NULL);

    while ( *ppste != (PSTE)NULL &&
            lstrcmp(szSymbol, (*ppste)->szSymbol) > 0 )
    {
        ppste = &((*ppste)->psteNext);
        AssertRet(ppste != (PPSTE)NULL, (PPSTE)NULL);
	AssertRet(*ppste == (PSTE)NULL ||
	          ((*ppste)->szSymbol != (SZ)NULL &&
		  *((*ppste)->szSymbol) != '\0' &&
		  (*ppste)->szValue != (SZ)NULL), (PPSTE)NULL);
    }

    return(ppste);
}



/*
**	Purpose:
**		Inserts a new symbol-value pair into the Symbol Table or replaces
**		an existing value associated with the symbol if it already exists
**		in the Symbol Table.
**	Arguments:
**		szSymbol: non-NULL, non-empty string symbol value.
**		szValue:  string value to associate with szSymbol, replacing and
**			freeing any current value.  If it is NULL then the empty string
**			is used in its place.  There are two types of values - simple
**			and list.  A simple value is any string of characters which is
**			not a list.  A list is a string which starts with a '{', and ends
**			with a '}' and contains doubly quoted items, separated by commas
**			with no extraneous whitespace.  So examples of lists are:
**				{}
**				{"item1"}
**				{"item1","item2"}
**				{"item 1","item 2","item 3","item 4"}
**			Examples of non-lists are:
**				{item1}
**				{"item1", "item2"}
**	Notes:
**		Requires that the Symbol Table was initialized with a successful
**		call to FInitSymTab().
**	Returns:
**		fFalse if an existing value cannot be freed or if space cannot be
**			allocated to create the needed STE structure or duplicate the
**			szValue.
**		fTrue if szValue is associated with szSymbol in the Symbol Table.
**
**************************************************************************/
BOOL APIENTRY FAddSymbolValueToSymTab(szSymbol, szValue)
SZ szSymbol;
SZ szValue;
{
    PPSTE       ppste;
    SZ          szValueNew;
    SZ          szRealSymbol;
    PSYMTAB     pSymTab;


	AssertDataSeg();

    PreCondSymTabInit(fFalse);

	ChkArg(szSymbol != (SZ)NULL &&
			*szSymbol != '\0' &&
			!FWhiteSpaceChp(*szSymbol), 1, fFalse);

	if (szValue == (SZ)NULL)
		szValue = "";

	if ((szValueNew = SzDupl(szValue)) == (SZ)NULL)
		return(fFalse);

    if ( !(pSymTab = PInfSymTabFind( szSymbol, &szRealSymbol ))) {
        return(fFalse);
    }

    ppste = PpsteFindSymbol( pSymTab, szRealSymbol);

	AssertRet(ppste != (PPSTE)NULL, fFalse);
	AssertRet(*ppste == (PSTE)NULL ||
			((*ppste)->szSymbol != (SZ)NULL &&
			 *((*ppste)->szSymbol) != '\0' &&
			 (*ppste)->szValue != (SZ)NULL), fFalse);

	if (*ppste != (PSTE)NULL &&
            CrcStringCompare((*ppste)->szSymbol, szRealSymbol) == crcEqual)
		{
		AssertRet((*ppste)->szValue != (SZ)NULL, fFalse);
		SFree((*ppste)->szValue);
		(*ppste)->szValue = (SZ)NULL;
        }

	else
		{
		PSTE pste;

		if ((pste = PsteAlloc()) == (PSTE)NULL ||
                (pste->szSymbol = SzDupl(szRealSymbol)) == (SZ)NULL)
			{
			if (pste != (PSTE)NULL)
				EvalAssert(FFreePste(pste));
			SFree(szValueNew);
			return(fFalse);
            }
#ifdef SYMTAB_STATS
        pSymTab->BucketCount[UsHashFunction(szRealSymbol)]++;
#endif
		pste->szValue = (SZ)NULL;
		pste->psteNext = *ppste;
		*ppste = pste;
		}

	AssertRet(ppste != (PPSTE)NULL &&
			*ppste != (PSTE)NULL &&
			(*ppste)->szValue  == (SZ)NULL &&
			(*ppste)->szSymbol != (SZ)NULL &&
			*((*ppste)->szSymbol) != '\0' &&
            CrcStringCompare((*ppste)->szSymbol, szRealSymbol) == crcEqual, fFalse);
		
	(*ppste)->szValue = szValueNew;

	return(fTrue);
}


/*
**	Purpose:
**		Finds the associated string value for a given symbol from the
**		Symbol Table if such exists.
**	Arguments:
**		szSymbol: non-NULL, non-empty string symbol value.
**	Notes:
**		Requires that the Symbol Table was initialized with a successful
**		call to FInitSymTab().
**	Returns:
**		NULL if error or szSymbol could not be found in the Symbol Table.
**		Non-NULL pointer to the associated string value in the Symbol
**			Table.  This value must not be mucked but should be duplicated
**			before changing it.  Changing it directly will change the value
**			associated with the symbol.  If it is changed, be sure the new
**			value has the same length as the old.
**
**************************************************************************/
SZ APIENTRY SzFindSymbolValueInSymTab(szSymbol)
SZ szSymbol;
{
    register PSTE  pste;
    PSYMTAB        pSymTab;
    SZ             szValue = NULL ;
    SZ             szRealSymbol ;
    int            i ;

    PreCondSymTabInit((SZ)NULL);

    if ( !(pSymTab = PInfSymTabFind( szSymbol, & szRealSymbol )))
        return NULL ;

    pste = pSymTab->HashBucket[ UsHashFunction( szRealSymbol ) ] ;

    do
    {
        if ( pste == NULL )
            break ;
        if ( pste->szSymbol == NULL )
            break ;
        if ( pste->szSymbol[0] == 0 )
            break;
        if ( pste->szValue == NULL )
            break;
        if ( (i = lstrcmp( szRealSymbol, pste->szSymbol )) == 0 )
            szValue = pste->szValue ;
    } while ( i > 0 && (pste = pste->psteNext) ) ;

    return szValue ;
}



/*
**	Purpose:
**		Removes and frees a symbols STE structure if it exists.
**	Arguments:
**		szSymbol: non-NULL, non-empty symbol string to remove from the
**			Symbol Table which starts with a non-whitespace character.
**	Notes:
**		Requires that the Symbol Table was initialized with a successful
**		call to FInitSymTab().
**	Returns:
**		fFalse if szSymbol was found but its STE structure could not be freed.
**		fTrue if either szSymbol never existed in the Symbol Table or it was
**			found, unlinked, and successfully freed.
**
**************************************************************************/
BOOL  APIENTRY FRemoveSymbolFromSymTab(szSymbol)
SZ szSymbol;
{
    PPSTE       ppste;
    PSTE        pste;
    PSYMTAB     pSymTab;
    SZ          szRealSymbol;

	AssertDataSeg();

    PreCondSymTabInit(fFalse);

	ChkArg(szSymbol != (SZ)NULL &&
			*szSymbol != '\0' &&
			!FWhiteSpaceChp(*szSymbol), 1, fFalse);

    if ( !(pSymTab = PInfSymTabFind( szSymbol, &szRealSymbol ))) {
        return(fFalse);
    }

    ppste = PpsteFindSymbol( pSymTab, szRealSymbol);
	AssertRet(ppste != (PPSTE)NULL, fFalse);

	if (*ppste == (PSTE)NULL ||
            CrcStringCompare(szRealSymbol, (*ppste)->szSymbol) != crcEqual)
		return(fTrue);

	pste = *ppste;
	*ppste = pste->psteNext;

	return(FFreePste(pste));
}


PSYMTAB  APIENTRY SymTabAlloc(VOID)
{
    PSYMTAB     pSymTab;
    USHORT      iHashBucket;

    if ( pSymTab = (PSYMTAB)SAlloc( sizeof( SYMTAB ) ) ) {

        for (iHashBucket = 0; iHashBucket < cHashBuckets; iHashBucket++) {
            pSymTab->HashBucket[iHashBucket] = NULL;
#ifdef SYMTAB_STATS
            pSymTab->BucketCount[iHashBucket] = 0;
#endif
        }
    }

    return pSymTab;

}


BOOL APIENTRY FFreeSymTab(PSYMTAB pSymTab)
{

    USHORT      iHashBucket;
    BOOL        fAnswer = fTrue;

    //  Free symbol table space
    //
    for (iHashBucket = 0; iHashBucket < cHashBuckets; iHashBucket++) {

        PSTE pste = pSymTab->HashBucket[iHashBucket];

        while (pste != (PSTE)NULL) {

            PSTE psteSav = pste->psteNext;

            fAnswer &= FFreePste(pste);
            pste = psteSav;
        }
    }

    SFree(pSymTab);

    return fAnswer;

}


BOOL  APIENTRY FCheckSymTab(PSYMTAB pSymTab)
{

    USHORT      iHashBucket;

    for (iHashBucket = 0; iHashBucket < cHashBuckets; iHashBucket++) {

        PSTE pste = pSymTab->HashBucket[iHashBucket];
        SZ   szPrev = "";

        while (pste != (PSTE)NULL) {

            if (pste->szSymbol == (SZ)NULL ||
                    *(pste->szSymbol) == '\0' ||
                    FWhiteSpaceChp(*(pste->szSymbol)))
                AssertRet(fFalse, fFalse);
            if (UsHashFunction((PB)(pste->szSymbol)) != iHashBucket)
                AssertRet(fFalse, fFalse);
            if (CrcStringCompare(szPrev, pste->szSymbol) != crcSecondHigher)
                AssertRet(fFalse, fFalse);
            if (pste->szValue == (SZ)NULL)
                AssertRet(fFalse, fFalse);
            pste = pste->psteNext;
        }
    }

    return fTrue;
}





/*
**	Purpose:
**		Ensures that the Symbol Table is valid.  It checks that the
**		Symbol Table has been initialized and that each STE structure
**		is in the correct hash bucket and that the symbols are in
**		ascending order within each hash bucket and that each has a
**		non-NULL value string associated with it.
**	Arguments:
**		none
**	Notes:
**		Requires that the Symbol Table was initialized with a successful
**		call to FInitSymTab().
**	Returns:
**		fFalse if the Symbol Table has not been initialized or if an STE
**			structure is in the wrong hash bucket or if each STE linked
**			list is not in ascending order or if each symbol does not have
**			a non-NULL string value associated with it.
**		fTrue if the Symbol Table has been initialized and if every STE
**			structure is in the correct hash bucket and if each STE linked
**			list is in ascending order and if each symbol does have a
**			non-NULL string value associated with it.
**
**************************************************************************/
BOOL  APIENTRY FCheckSymTabIntegrity(VOID)
{
    PINFTEMPINFO    pTempInfo;

	AssertDataSeg();

    PreCondSymTabInit(fFalse);

    pTempInfo = pGlobalContext()->pInfTempInfo;

    while ( pTempInfo ) {
        if ( !FCheckSymTab( pTempInfo->SymTab ) ) {
            return fFalse;
        }

        pTempInfo = pTempInfo->pNext;
    }

	return(fTrue);
}

BOOL
DumpSymbolTableToFile(
    IN PCSTR Filename
    )
{
    FILE *OutFile;
    UINT HashBucket;
    PSTE pste;
    PINFCONTEXT InfContext;
    #define MAX_SYMTAB 1000
    PVOID SymbolTables[MAX_SYMTAB];
    PVOID InfNames[MAX_SYMTAB];
    UINT SymbolTableCount;
    UINT i;
    BOOL Found;

    //
    // Handle preconditions.
    //
    PreCondSymTabInit(fFalse);
    FCheckSymTabIntegrity();

    //
    // Open/create the dump file.
    //
    SetFileAttributes(Filename,FILE_ATTRIBUTE_NORMAL);
    OutFile = fopen(Filename,"w");
    if(!OutFile) {
        return(FALSE);
    }

    //
    // Iterate through all inf file contexts.
    // Unfortunately there is no good way to simply iterate symbol tables
    // we'll track the ones we've done and skip them if encountered again.
    //
    SymbolTableCount = 0;
    for(InfContext=pContextTop; InfContext; InfContext=InfContext->pNext) {
        if(SymbolTableCount < MAX_SYMTAB) {
            Found = FALSE;
            for(i=0; i<SymbolTableCount; i++) {
                if(SymbolTables[i] == InfContext->SymTab) {
                    Found = TRUE;
                    break;
                }
            }
            if(!Found) {
                SymbolTables[SymbolTableCount] = InfContext->SymTab;
                InfNames[SymbolTableCount] = InfContext->pInfTempInfo->pInfPermInfo->szName;
                SymbolTableCount++;
            }
        }
    }

    for(i=0; i<SymbolTableCount; i++) {

        fprintf(OutFile,"*** Inf %s:\n\n",InfNames[i] ? InfNames[i] : "(unknown)");

        //
        // Dump symbols in each hash bucket.
        //
        for(HashBucket=0; HashBucket<cHashBuckets; HashBucket++) {
            for(pste=((PSYMTAB)(SymbolTables[i]))->HashBucket[HashBucket]; pste; pste=pste->psteNext) {
                fprintf(OutFile,"[%s] = [%s]\n",pste->szSymbol,pste->szValue);
            }
        }

        fprintf(OutFile,"\n\n");
    }

    fclose(OutFile);
    return(TRUE);
}

#define  cListItemsMax  0x07FF
#define  ItemSizeIncr   0x2000

/*
**	Purpose:
**		Determines if a string is a list value.
**	Arguments:
**		szValue: non-NULL, zero terminated string to be tested.
**	Returns:
**		fTrue if a list; fFalse otherwise.
**
**************************************************************************/
BOOL
APIENTRY
FListValue(
    IN SZ szValue
    )
{
	ChkArg(szValue != (SZ)NULL, 1, fFalse);

    if(*szValue++ != '{') {
        return(fFalse);
    }

    while((*szValue != '}') && *szValue) {

        if(*szValue++ != '"') {
            return(fFalse);
        }

        while(*szValue) {

            if(*szValue != '"') {
                szValue++;
            } else if(*(szValue + 1) == '"') {
                szValue += 2;
            } else {
				break;
            }
        }

        if(*szValue++ != '"') {
            return(fFalse);
        }

        if(*szValue == ',') {
            if(*(++szValue) == '}') {
                return(fFalse);
            }
		}
    }

    if(*szValue != '}') {
        return(fFalse);
    }

	return(fTrue);
}


/*
**	Purpose:
**		Converts a list value into an RGSZ.
**	Arguments:
**		szListValue: non-NULL, zero terminated string to be converted.
**	Returns:
**		NULL if an error occurred.
**		Non-NULL RGSZ if the conversion was successful.
**
**************************************************************************/
RGSZ
APIENTRY
RgszFromSzListValue(
    SZ szListValue
    )
{
	USHORT cItems;
	SZ     szCur;
    RGSZ   rgsz;

    DWORD  ValueBufferSize;
    DWORD  BytesLeftInValueBuffer;


	ChkArg(szListValue != (SZ)NULL, 1, (RGSZ)NULL);

    if(!FListValue(szListValue)) {

        if((rgsz = (RGSZ)SAlloc((CB)(2 * sizeof(SZ)))) == (RGSZ)NULL ||
           (rgsz[0] = SzDupl(szListValue)) == (SZ)NULL)
        {
            return((RGSZ)NULL);
        }
		rgsz[1] = (SZ)NULL;
		return(rgsz);
    }

    if((rgsz = (RGSZ)SAlloc((CB)((cListItemsMax + 1) * sizeof(SZ)))) == (RGSZ)NULL) {
        return((RGSZ)NULL);
    }

	cItems = 0;
	szCur = szListValue + 1;
    while((*szCur != '}') && (*szCur != '\0') && (cItems < cListItemsMax)) {

        SZ szValue;
		SZ szAddPoint;

		AssertRet(*szCur == '"', (RGSZ)NULL);
        szCur++;

        //
        // Allocate an initial buffer.
        //
        ValueBufferSize = ItemSizeIncr+1;
        BytesLeftInValueBuffer = ItemSizeIncr;

        if((szValue = (SZ)SAlloc(ValueBufferSize)) == (SZ)NULL) {

            rgsz[cItems] = (SZ)NULL;
			FFreeRgsz(rgsz);
			return((RGSZ)NULL);
        }

        szAddPoint = szValue;

        while(*szCur) {

            if(*szCur == '"') {

                //
                // Got a quote.  If the next character is a double quote, then
                // we've got a literal double quote, and we want to store a
                // single double quote in the target.  If the next char is not
                // a double-quote, then we've reached the string-ending double-quote.
                //
                // Advance szCur either way because:
                // In the former case, szCur will now point to the second
                // double-quote, and we can fall through the the ordinary
                // character (ie, non-quote) case.
                // In the latter case, we will break out of the loop, and want
                // szCur advanced past the end of the string.
                //

                if(*(++szCur) != '"') {
                    break;
                }
            }

            if(!BytesLeftInValueBuffer) {

                SZ szSave = szValue;

                if(szValue = SRealloc(szValue,ValueBufferSize+ItemSizeIncr)) {

                    szAddPoint = (SZ)((PUCHAR)szValue + ValueBufferSize - 1);

                    BytesLeftInValueBuffer = ItemSizeIncr;
                    ValueBufferSize += ItemSizeIncr;

                } else {
                    SFree(szSave);
                    rgsz[cItems] = (SZ)NULL;
                    FFreeRgsz(rgsz);
                    return((RGSZ)NULL);
                }
            }

            BytesLeftInValueBuffer--;

            *szAddPoint++ = *szCur++;
        }

        *szAddPoint = 0;

        if((szAddPoint = SzDupl(szValue)) == NULL) {

            SFree(szValue);
			rgsz[cItems] = (SZ)NULL;
			FFreeRgsz(rgsz);
			return((RGSZ)NULL);
        }

        SFree(szValue);

        if (*szCur == ',') {
            szCur++;
        }

		rgsz[cItems++] = szAddPoint;
    }

    rgsz[cItems] = (SZ)NULL;

    if((*szCur != '}') || (cItems >= cListItemsMax)) {

        FFreeRgsz(rgsz);
		return((RGSZ)NULL);
    }

    if (cItems < cListItemsMax) {

        rgsz = (RGSZ)SRealloc(
                        (PB)rgsz,
                        (CB)((cItems + 1) * sizeof(SZ))
                        );
    }

	return(rgsz);
}


#define  cbListMax    (CB)0x2000

VOID
GrowValueBuffer( SZ *pszBuffer, PDWORD pSize, PDWORD pLeft, DWORD dwWanted, SZ *pszPointer );


#define VERIFY_SIZE(s)                                                          \
    if ( dwSizeLeft < (s) ) {                                                   \
        GrowValueBuffer( &szValue, &dwValueSize, &dwSizeLeft, (s), &szAddPoint );    \
    }


/*
**	Purpose:
**		Converts an RGSZ into a list value.
**	Arguments:
**		rgsz: non-NULL, NULL-terminated array of zero-terminated strings to
**			be converted.
**	Returns:
**		NULL if an error occurred.
**		Non-NULL SZ if the conversion was successful.
**
**************************************************************************/
SZ  APIENTRY SzListValueFromRgsz(rgsz)
RGSZ rgsz;
{
    SZ      szValue;
    SZ      szAddPoint;
    SZ      szItem;
    BOOL    fFirstItem = fTrue;
    DWORD   dwValueSize;
    DWORD   dwSizeLeft;
    UINT    rgszIndex = 0;

	ChkArg(rgsz != (RGSZ)NULL, 1, (SZ)NULL);

    if ((szAddPoint = szValue = (SZ)SAlloc(cbListMax)) == (SZ)NULL) {
        return((SZ)NULL);
    }

    dwValueSize = dwSizeLeft = cbListMax;

    *szAddPoint++ = '{';
    dwSizeLeft--;

    while(szItem = rgsz[rgszIndex]) {

        VERIFY_SIZE(2);

        if (fFirstItem) {
			fFirstItem = fFalse;
        } else {
            *szAddPoint++ = ',';
            dwSizeLeft--;
        }

        *szAddPoint++ = '"';
        dwSizeLeft--;

        while (*szItem) {

            VERIFY_SIZE(1);
            dwSizeLeft--;
            if((*szAddPoint++ = *szItem++) == '"') {
                VERIFY_SIZE(1);
                dwSizeLeft--;
                *szAddPoint++ = '"';
            }
        }

        VERIFY_SIZE(1);
        *szAddPoint++ = '"';
        dwSizeLeft--;
        rgszIndex++;
    }

    VERIFY_SIZE(2);
	*szAddPoint++ = '}';
    *szAddPoint = '\0';
    dwSizeLeft -= 2;

    // AssertRet(strlen(szValue) < dwValueSize, (SZ)NULL);
	szItem = SzDupl(szValue);
    SFree(szValue);

	return(szItem);
}



VOID
GrowValueBuffer( SZ *pszBuffer, PDWORD pSize, PDWORD pLeft, DWORD dwWanted, SZ *pszPointer )
{


    if ( *pLeft < dwWanted ) {

        DWORD_PTR   Offset = *pszPointer - *pszBuffer;

        *pszBuffer = SRealloc( *pszBuffer, *pSize + cbListMax );
        EvalAssert( *pszBuffer );

        *pSize += cbListMax;
        *pLeft += cbListMax;

        *pszPointer = *pszBuffer + Offset;
    }
}


static BOOL  APIENTRY FSymbol(SZ sz)
{
	ChkArg(sz != (SZ)NULL, 1, fFalse);

	if (*sz++ != '$' ||
			*sz++ != '(' ||
			FWhiteSpaceChp(*sz) ||
			*sz == ')')
		return(fFalse);
	
	while (*sz != ')' &&
			*sz != '\0')
		sz = SzNextChar(sz);

	return(*sz == ')');
}


/*
**	Purpose:
**		Substitutes values from the Symbol Table for symbols of the form
**		'$( <symbol> )' in the source string.
**	Arguments:
**		szSrc: non-NULL string in which to substitute symbol values.
**	Notes:
**		Requires that the Symbol Table was initialized with a successful
**		call to FInitSymTab().
**		A successful return value must be freed by the caller.
**	Returns:
**		NULL if any of the alloc operations fail or if the substituted
**			string is larger than 8KB bytes (cchpFieldMax).
**		non-NULL string with values substituted for symbols if all of the
**			alloc operations succeed.
**
**************************************************************************/
SZ  APIENTRY SzGetSubstitutedValue(SZ szSrc)
{
	SZ   szDest;
	PCHP pchpDestCur;
	CCHP cchpDest = (CCHP)0;

	AssertDataSeg();

    PreCondSymTabInit(NULL);

	ChkArg(szSrc != (SZ)NULL, 1, (SZ)NULL);

	if ((szDest = pchpDestCur = (SZ)SAlloc((CB)cchpFieldMax)) == (SZ)NULL)
		return((SZ)NULL);

	while (*szSrc != '\0')
		{
		if (FSymbol(szSrc))
			{
			SZ szSymEnd;
			SZ szValue;

			Assert(*szSrc == '$');
			szSrc++;
			Assert(*szSrc == '(');
			szSymEnd = ++szSrc;
			Assert(*szSrc != '\0' && *szSrc != ')');
			while (*szSymEnd != ')')
				{
				Assert(*szSymEnd != '\0');
				szSymEnd = SzNextChar(szSymEnd);
				}
			Assert(*szSymEnd == ')');
			*szSymEnd = '\0';
			szValue = SzFindSymbolValueInSymTab(szSrc);
			*szSymEnd = ')';
			szSrc = SzNextChar(szSymEnd);

			if (szValue == (SZ)NULL)
				continue;

			if (cchpDest + strlen(szValue) >= cchpFieldMax ||
					strcpy(pchpDestCur, szValue) != pchpDestCur)
				{
				SFree(szDest);
				return((SZ)NULL);
				}

			pchpDestCur += strlen(szValue);
			Assert(*pchpDestCur == '\0');
			cchpDest += strlen(szValue);
			Assert(cchpDest < cchpFieldMax);
			}
		else
			{
			SZ szNext = SzNextChar(szSrc);

			while (szSrc < szNext)
				{
				*pchpDestCur++ = *szSrc++;
				if (++cchpDest >= cchpFieldMax)
					{
					SFree(szDest);
					return((SZ)NULL);
					}
				}
			}
		}

	Assert(cchpDest < cchpFieldMax);

	*(szDest + cchpDest++) = '\0';
	if (cchpDest < cchpFieldMax)
		szDest = SRealloc(szDest,cchpFieldMax);

	return(szDest);
}


//
// Routines exported from the legacy setup dll to allow
// direct manipulation of the inf symtab table.
//

PCSTR
LegacyInfLookUpSymbol(
    IN PCSTR SymbolName
    )
{
    return(SzFindSymbolValueInSymTab((SZ)SymbolName));
}


BOOL
LegacyInfSetSymbolValue(
    IN PCSTR SymbolName,
    IN PCSTR SymbolValue
    )
{
    return(FAddSymbolValueToSymTab((SZ)SymbolName,(SZ)SymbolValue));
}


BOOL
LegacyInfRemoveInfSymbol(
    IN PCSTR SymbolName
    )
{
    return(FRemoveSymbolFromSymTab((SZ)SymbolName));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\tinterp.c ===
#include <precomp.h>
#pragma hdrstop


#if 0
BOOL
LegacyInfInterpret(
    IN  HWND  OwnerWindow,
    IN  PCSTR InfFilename,
    IN  PCSTR InfSection,
    IN  PCHAR ExtraVariables,
    OUT PSTR  InfResult,
    IN  DWORD BufferSize,
    OUT int   *InterpResult
    );
#endif


CHAR ExtraVars[] = { "ExtraSymbol1\0"
                     "ExtraValue1\0"
                     "ExtraSymbol2\0"
                     "ExtraValue2\0"
                     "ExtraSymbol3\0"
                     "ExtraValue3\0"
                     "ExtraSymbol4\0"
                     "ExtraValue4\0"
                     "ExtraSymbol5\0"
                     "ExtraValue5\0"
                   };

VOID
DoIt(
    VOID
    )
{
    HMODULE h;
    FARPROC p;
    int i;
    BOOL b;
    CHAR Result[256];
    CHAR Filename[MAX_PATH];

    if(h = LoadLibrary("setupdll")) {

        if(p = GetProcAddress(h,"LegacyInfInterpret")) {

           b = p(
                NULL,
                "test.inf",
                "TestSection",
                ExtraVars,
                Result,
                sizeof(Result),
                &i
                );
        }         \

        //
        // Make SURE it's gone.
        //
        while(GetModuleFileName(h,Filename,MAX_PATH)) {
            FreeLibrary(h);
        }
    }
}


VOID
__cdecl
main(
    IN int argc,
    IN char *argv[]
    )
{
    DoIt();
    DoIt();
    DoIt();
    DoIt();
    DoIt();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\tagfile.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tagfile.h

Abstract:

    Header file for tagged-file functions.

Author:

    Ramon J. San Andres (ramonsa) January 1991

--*/



typedef struct _TFKEYWORD *PTFKEYWORD;
typedef struct _TFKEYWORD {
    PTFKEYWORD  pNext;
    SZ          szName;
    SZ          szValue;
} TFKEYWORD;


typedef struct _TFSECTION *PTFSECTION;
typedef struct _TFSECTION {
    PTFSECTION  pNext;
    SZ          szName;
    PTFKEYWORD  pKeywordHead;
} TFSECTION;


typedef struct _TAGGEDFILE  *PTAGGEDFILE;
typedef struct _TAGGEDFILE {
    PTFSECTION    pSectionHead;
} TAGGEDFILE;






PTAGGEDFILE
GetTaggedFile(
    IN SZ   szFile
    );


PTFSECTION
GetSection(
    IN  PTAGGEDFILE pFile,
    IN  SZ          szSection
    );


PTFKEYWORD
GetKeyword(
    IN  PTFSECTION  pSection,
    IN  SZ          szKeyword
    );


PTFKEYWORD
GetNextKeyword(
    IN  PTFSECTION  pSection,
    IN  PTFKEYWORD  pKeyword
    );


BOOL
CloseTaggedFile(
    OUT PTAGGEDFILE pFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\tagfile.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tagfile.c

Abstract:

    tagged-file functions.

Author:

    Ramon J. San Andres (ramonsa) January 1991

--*/





// ***************************************************************************
//
//                  Tagged file manipulation functions
//
// ***************************************************************************



BOOL    fLineRead   =   fFalse;
BOOL    fEndOfFile  =   fFalse;


//
//  Local prototypes
//
BOOL
CloseTaggedSection(
    OUT PTFSECTION  pSection
    );

BOOL
CloseKeyword(
    OUT PTFKEYWORD  pKeyword
    );

PTAGGEDFILE
AllocTaggedFile(
    );

PTFSECTION
AllocTaggedSection(
    OUT PTEXTFILE   pTextFile
    );

PTFKEYWORD
AllocKeyword(
    OUT PTEXTFILE   pTextFile
    );

BOOL
ReadTaggedFile(
    OUT PTAGGEDFILE pFile,
    OUT PTEXTFILE   pTextFile
    );

PTFSECTION
ReadTaggedSection(
    OUT PTEXTFILE   pTextFile,
    OUT PBOOL       pfOkay
    );

PTFKEYWORD
ReadKeyword(
    OUT PTEXTFILE   pTextFile,
    OUT PBOOL       pfOkay
    );

VOID
SkipComments(
    OUT PTEXTFILE   pTextFile
    );

BOOL
IsTaggedLine(
    IN  PTEXTFILE   pTextFile
    );

BOOL
TaggedFileReadLine (
    OUT PTEXTFILE   pTextFile
    );

VOID
TaggedFileConsumeLine (
    VOID
    );





//
//  Gets the specified tagged file
//
PTAGGEDFILE
GetTaggedFile(
    IN SZ   szFile
    )
{
    PTAGGEDFILE pFile = NULL;
    TEXTFILE    TextFile;

    if ( szFile ) {

        //
        //  Open file
        //
        if ( TextFileOpen( szFile, &TextFile ) ) {

            //
            //  Allocate an empty TAGGEDFILE structure
            //
            if ( pFile = AllocTaggedFile() ) {

                //
                //  Read in the file
                //
                if ( !ReadTaggedFile( pFile, &TextFile ) ) {
                    CloseTaggedFile( pFile );
                    pFile = NULL;
                }
            }

            TextFileClose( &TextFile );
        }
    }

    return pFile;
}





//
//  Finds the specified section
//
PTFSECTION
GetSection(
    IN  PTAGGEDFILE pFile,
    IN  SZ          szSection
    )
{
    PTFSECTION  pSection = NULL;

    if ( pFile && szSection ) {

        pSection = pFile->pSectionHead;

        while ( pSection ) {

            if ( _strcmpi( szSection, pSection->szName ) == 0 ) {
                break;
            }

            pSection = pSection->pNext;
        }
    }

    return pSection;
}







//
//  Finds the specified keyword within a section
//
PTFKEYWORD
GetKeyword(
    IN  PTFSECTION  pSection,
    IN  SZ          szKeyword
    )
{
    PTFKEYWORD  pKeyword = NULL;

    if ( pSection && szKeyword ) {

        pKeyword = pSection->pKeywordHead;

        while ( pKeyword ) {

            if ( _strcmpi( szKeyword, pKeyword->szName ) == 0 ) {
                break;
            }

            pKeyword = pKeyword->pNext;
        }
    }

    return pKeyword;
}








//
//  Gets first/next keyword within a section
//
PTFKEYWORD
GetNextKeyword(
    IN  PTFSECTION  pSection,
    IN  PTFKEYWORD  pKeyword
    )
{
    PTFKEYWORD  pNext = NULL;


    if ( pKeyword ) {

        pNext = pKeyword->pNext;

    } else if ( pSection ) {

        pNext = pSection->pKeywordHead;

    }

    return pNext;
}






//
//  Deallocates memory used by the TAGGEDFILE
//
BOOL
CloseTaggedFile(
    OUT PTAGGEDFILE pFile
    )
{
    PTFSECTION  pSection;

    pSection = pFile->pSectionHead;

    while ( pSection ) {

        PTFSECTION  pThis = pSection;

        pSection = pSection->pNext;

        CloseTaggedSection( pThis );
    }

    SFree( pFile );

    return fTrue;
}




//
//  Deallocates memory used by a section
//
BOOL
CloseTaggedSection(
    OUT PTFSECTION pSection
    )
{
    PTFKEYWORD  pKeyword;

    pKeyword = pSection->pKeywordHead;

    while ( pKeyword ) {

        PTFKEYWORD  pThis = pKeyword;

        pKeyword = pKeyword->pNext;

        CloseKeyword( pThis );
    }

    SFree( pSection );

    return fTrue;
}




//
//  Deallocates memory sued by a keyword
//
BOOL
CloseKeyword(
    OUT PTFKEYWORD  pKeyword
    )
{
    SFree( pKeyword->szName );
    SFree( pKeyword->szValue );
    SFree( pKeyword );

    return fTrue;
}




//
//  Allocate and initialize an empty tagged file
//
PTAGGEDFILE
AllocTaggedFile(
    )
{
    PTAGGEDFILE     pFile = NULL;

    pFile = (PTAGGEDFILE)SAlloc( sizeof(TAGGEDFILE) );

    if ( pFile ) {
        pFile->pSectionHead = NULL;
    }

    return pFile;
}




//
//  Allocate a tagged section
//
PTFSECTION
AllocTaggedSection(
    OUT PTEXTFILE   pTextFile
    )
{
    PTFSECTION  pSection;
    SZ          szName;
    SZ          szEnd;
    DWORD       dwSize;
    SZ          szLine = TextFileSkipBlanks( TextFileGetLine( pTextFile ) );

    if ( szLine ) {

        if ( *szLine == '[' ) {

            szLine++;

            szEnd = strchr( szLine, ']' );

            if ( szEnd ) {

                pSection = (PTFSECTION)SAlloc( sizeof(TFSECTION) );

                if ( pSection ) {

                    dwSize = (DWORD)(szEnd - szLine);

                    szName = (SZ)SAlloc( dwSize + 1 );

                    if ( szName ) {

                        memcpy( szName, szLine, dwSize );

                        *(szName + dwSize) = '\0';

                        pSection->pNext         = NULL;
                        pSection->szName        = szName;
                        pSection->pKeywordHead  = NULL;

                        TaggedFileConsumeLine(  );

                        return pSection;
                    }

                    SFree( pSection );
                }
            }
        }
    }

    return NULL;
}




//
//  Allocate a Keyword
//
PTFKEYWORD
AllocKeyword(
    OUT PTEXTFILE   pTextFile
    )
{

    PTFKEYWORD  pKeyword = NULL;
    SZ          szLine   = TextFileSkipBlanks( TextFileGetLine( pTextFile ) );
    SZ          szName;
    SZ          szValue;
    size_t      Idx;

    if ( szLine ) {
        Idx = strcspn( szLine, " \t=" );

        if ( Idx < strlen(szLine) ) {

            szName = (SZ)SAlloc( Idx+1 );

            if ( szName ) {

                memcpy( szName, szLine, Idx );
                *(szName + Idx) = '\0';

                szLine += Idx;

                if ( *szLine != '=' ) {
                    szLine = TextFileSkipBlanks( szLine );
                }

                if ( szLine && *szLine == '=' ) {

                    szLine++;
                    if( szLine = TextFileSkipBlanks( szLine ) ) {

                        Idx = strlen(szLine);

                        szValue = (SZ)SAlloc( Idx+1 );

                        if ( szValue ) {

                            strcpy( szValue, szLine );

                            pKeyword = (PTFKEYWORD)SAlloc( sizeof(TFKEYWORD) );

                            if ( pKeyword ) {

                                pKeyword->pNext     = NULL;
                                pKeyword->szName    = szName;
                                pKeyword->szValue   = szValue;

                                TaggedFileConsumeLine(  );

                                return pKeyword;

                            }

                            SFree( szValue );
                        }
                    }
                }

                SFree( szName );
            }
        }
    }

    return NULL;
}







//
//  Reads a tagged file
//
BOOL
ReadTaggedFile(
    OUT PTAGGEDFILE pFile,
    OUT PTEXTFILE   pTextFile
    )
{
    PTFSECTION  pSection;
    PTFSECTION  pLastSection = NULL;
    BOOL        fOkay        = fTrue;

    while ( fTrue ) {

        pSection = ReadTaggedSection( pTextFile, &fOkay );

        if ( fOkay && pSection ) {

            if ( pLastSection ) {
                pLastSection->pNext = pSection;
            } else {
                pFile->pSectionHead = pSection;
            }

            pLastSection = pSection;

        } else {

            break;
        }
    }

    return fOkay;
}






//
//  Reads a tagged section
//
PTFSECTION
ReadTaggedSection(
    OUT PTEXTFILE   pTextFile,
    OUT PBOOL       pfOkay
    )
{

    PTFKEYWORD  pKeyword;
    PTFSECTION  pSection     = NULL;
    PTFKEYWORD  pLastKeyword = NULL;
    DWORD       TagSize      = 0;

    SkipComments( pTextFile );

    if ( !fEndOfFile ) {

        if ( IsTaggedLine( pTextFile ) &&
             (pSection = AllocTaggedSection( pTextFile )) ) {

            while ( fTrue ) {

                pKeyword = ReadKeyword( pTextFile, pfOkay );

                if ( *pfOkay && pKeyword ) {

                    if ( pLastKeyword ) {
                        pLastKeyword->pNext    = pKeyword;
                    } else {
                        pSection->pKeywordHead = pKeyword;
                    }

                    pLastKeyword = pKeyword;

                } else {

                    break;
                }
            }

            if ( !*pfOkay ) {

                CloseTaggedSection( pSection );
                pSection = NULL;
            }

        } else {

            *pfOkay = fFalse;
        }
    }

    return pSection;
}





//
//  Reads a keyword
//
PTFKEYWORD
ReadKeyword(
    OUT PTEXTFILE   pTextFile,
    OUT PBOOL       pfOkay
    )
{

    PTFKEYWORD  pKeyword    =   NULL;

    SkipComments( pTextFile );

    if ( !fEndOfFile ) {

        if ( !IsTaggedLine( pTextFile ) &&
             !(pKeyword = AllocKeyword( pTextFile)) ) {

            *pfOkay = fFalse;
        }
    }

    return pKeyword;
}





//
//  Skip comments and blank lines
//
VOID
SkipComments(
    OUT PTEXTFILE   pTextFile
    )
{
    SZ      szLine;

    while( TaggedFileReadLine( pTextFile ) ) {

        szLine = TextFileGetLine( pTextFile );

        if ( szLine = TextFileSkipBlanks( szLine ) ) {

            if ( *szLine != ';' ) {
                break;
            }
        }

        TaggedFileConsumeLine(  );
    }
}





//
//  True if tagged section
//
BOOL
IsTaggedLine(
    IN  PTEXTFILE   pTextFile
    )
{
    SZ      szLine = TextFileSkipBlanks( TextFileGetLine( pTextFile ) );

    if ( szLine ) {

        if ( *szLine == '[' ) {

            return (BOOL)(strchr( szLine+1, ']' ) != NULL);
        }
    }

    return fFalse;
}





//
//  Read a line
//
BOOL
TaggedFileReadLine (
    OUT PTEXTFILE   pTextFile
    )
{

    BOOL    f = fFalse;

    if ( !fEndOfFile ) {

        f = fLineRead;

        if ( !f ) {

            f = fLineRead = TextFileReadLine( pTextFile );

            if ( !f ) {
                fEndOfFile = fTrue;
            }
        }
    }

    return f;
}


//
//  Consume a line
//
VOID
TaggedFileConsumeLine (
    VOID
    )
{
    fLineRead = fFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\ui.c ===
#include "precomp.h"
#pragma hdrstop
/*************************************************************************/
/***** Custom User Interface Library Sample ******************************/
/*************************************************************************/

DLGMP DialogMap[] =
   {
      (SZ)"Info",             (WNDPROC)FGstInfoDlgProc,         (PFNEVENT)NULL,
      (SZ)"Edit",             (WNDPROC)FGstEditDlgProc,         (PFNEVENT)NULL,
      (SZ)"MultiEdit",        (WNDPROC)FGstMultiEditDlgProc,    (PFNEVENT)NULL,
      (SZ)"Check",            (WNDPROC)FGstCheckDlgProc,        (PFNEVENT)NULL,
      (SZ)"Check1",           (WNDPROC)FGstCheck1DlgProc,       (PFNEVENT)EhrcGstCheck1EventHandler,
      (SZ)"Radio",            (WNDPROC)FGstRadioDlgProc,        (PFNEVENT)NULL,
      (SZ)"List",             (WNDPROC)FGstListDlgProc,         (PFNEVENT)NULL,
      (SZ)"Multi",            (WNDPROC)FGstMultiDlgProc,        (PFNEVENT)NULL,
      (SZ)"Dual",             (WNDPROC)FGstDualDlgProc,         (PFNEVENT)NULL,
      (SZ)"Dual1",            (WNDPROC)FGstDual1DlgProc,        (PFNEVENT)NULL,
      (SZ)"MultiCombo",       (WNDPROC)FGstMultiComboDlgProc,   (PFNEVENT)EhrcGstMultiComboEventHandler,
      (SZ)"Combination",      (WNDPROC)FGstCombinationDlgProc,  (PFNEVENT)EhrcGstMultiComboEventHandler,
      (SZ)"RadioCombination", (WNDPROC)FGstComboRadDlgProc,     (PFNEVENT)EhrcGstMultiComboEventHandler,
      (SZ)"Maintenance",      (WNDPROC)FGstMaintDlgProc,        (PFNEVENT)EhrcGstMaintenanceEventHandler,
      (SZ)"Billboard",        (WNDPROC)FGstBillboardDlgProc,    (PFNEVENT)NULL
   };

/*
**  Purpose:
**      To push the dialog szDlgName onto the top of the dialog stack if it
**      is not already on top of the stack.  if it is already on the top of
**      the stack it merely ensures that the dialog is active and enabled.
**
**  Arguments:
**      szDlgName:  the name of the dialog (not the dialog template name).
**      hinst:      Handle to instance of the APP (i.e. the shell).
**      hwndShell:  Handle to the main app window (i.e. the shell).
**
**  Returns:
**      fTrue if the operation succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY
FDoDialog(
    IN SZ     szDlgName,
    IN HANDLE hInst,
    IN HWND   hwndShell
    )

{
    BOOL   fReturn;
    SZ     szDlgType, szDlgTemplate;
    pDLGMP pdlgmp;

    AssertDataSeg();
    Assert(szDlgName != NULL);

    // find the dialog type associated with this dialog and
    // validate it

    EvalAssert((szDlgType = SzFindSymbolValueInSymTab(DLGTYPE)) != NULL);

    // Handle the case when the dialog is already on the stack

    if (SzStackTopName() != NULL &&
            CrcStringCompare(szDlgName, SzStackTopName()) == crcEqual) {

        if (FResumeStackTop()) {
            Assert(HdlgStackTop() != NULL);
            PostMessage(HdlgStackTop(), (UINT)STF_REINITDIALOG, 0, 0L);
            fReturn = fTrue;
        }
        else {
           fReturn = fFalse;
        }

    }

    else {

        // find out if the dialog is a message box.  message boxes are handled
        // here.

        if ( CrcStringCompare(szDlgType, "MessageBox") == crcEqual ) {

            fReturn = FHandleUIMessageBox(hwndShell);
            PostMessage(hwndShell, (UINT) STF_SHL_INTERP, 0, 0L);
            return(fReturn);

        }

        else {
            //
            // find the dialog template associated with this dialog and
            // validate it.  see if what we are doing is enough
        
            EvalAssert((szDlgTemplate = SzFindSymbolValueInSymTab(DLGTEMPLATE)) != NULL);

            //
            // map the dialog type into a dialog procedure
            //

            EvalAssert((pdlgmp = pdlgmpFindDlgType (szDlgType, DialogMap)) != NULL);

            //
            // start the dialog
            //

            fReturn = (HdlgPushDbcb(
                           hInst,
                           szDlgName,
                           szDlgTemplate,
                           hwndShell,
                           pdlgmp->FGstDlgProc,
                           (DWORD)0,
                           pdlgmp->EhrcEventHandler,
                           (SZ)"",
                           (WNDPROC)NULL
                           ) != NULL);
        }
    }

    if ( CrcStringCompare( szDlgType, "Billboard" ) == crcEqual ) {
        PostMessage(hwndShell, (UINT) STF_SHL_INTERP, 0, 0L);
    }

    return( fReturn );
}


pDLGMP
pdlgmpFindDlgType(
    IN SZ szDlgType,
    IN pDLGMP DialogMap
    )

{
    while ( DialogMap!=NULL &&
            CrcStringCompare(szDlgType, DialogMap->szDlgType) != crcEqual ) {

        DialogMap++;

    }

    return (DialogMap);
}



/*
**  Purpose:
**      To destroy the top N dialogs on the dialog stack and free the storage
**      occupied by their DBCB's (dialog box context blocks).
**
**  Arguments:
**      n:          The number of dialogs to be destroyed.
**      fResume:    Indicates if the dialog on top of the dialog stack after
**                  killing N dialogs should be resumed.  fResume = fTrue means
**                  that it should be resumed, fFalse means that it should not
**                  be resumed.
**
**  Returns:
**      fTrue if the operation is completely successful (i.e. all n of the
**      dialogs are successfully destroyed and the top of stack is resumed if
**      appropriate), fFalse otherwise.
****************************************************************************/
BOOL APIENTRY FKillNDialogs(USHORT n,BOOL fResume)
{
    BOOL fReturn;

   AssertDataSeg();
    Assert(n > 0);

    if ((fReturn = (FPopNDbcb(n) != fFalse)) &&
            fResume)
        {
        Assert(!FStackEmpty());
        fReturn = FResumeStackTop();
        }

    return(fReturn);
}





/*
**  Purpose:
**      Display a message box whose characteristics are drawn from the
**      symbol table.
**  Arguments:
**      hwndParent: non-NULL handle to parent's window.
**  Symbol Table Inputs:
**      STF_MB_TITLE: string to display as title - can be blank.
**      STF_MB_TEXT:  string to display as text - should not be blank.
**      STF_MB_TYPE:  1 -> MB_OK; 2 -> MB_OKCANCEL; 3 -> MB_YESNO;
**          4 -> MB_YESNOCANCEL; 5 -> MB_RETRYCANCEL; 6 -> MB_ABORTRETRYIGNORE.
**      STF_MB_ICON:  1 -> none; 2 -> info; 3 -> stop; 4 -> ?; 5 -> !
**      STF_MB_DEF:   default button - 1 (default), 2, or 3.
**  Symbol Table Outputs:
**      DLGEVENT: "ABORT", "CANCEL", "IGNORE", "NO", "OK", "RETRY", or "YES".
**  Returns:
**      fFalse for undefined input symbols or OOM; fTrue otherwise.
****************************************************************************/
BOOL APIENTRY FHandleUIMessageBox(hwndParent)
HWND hwndParent;
{
    INT  imbReturn;
    UINT wType = MB_TASKMODAL;
    SZ   szTitle, szText;
    BOOL fRet = fFalse;
    HWND aw;

    ChkArg(hwndParent != NULL, 1, fFalse);

    if ((szText = SzFindSymbolValueInSymTab("STF_MB_TYPE")) == NULL)
        {
        Assert(fFalse);
        goto LHUIMBError;
        }

    switch (*szText)
        {
    case '1':
        wType |= MB_OK;
        break;
    case '2':
        wType |= MB_OKCANCEL;
        break;
    case '3':
        wType |= MB_YESNO;
        break;
    case '4':
        wType |= MB_YESNOCANCEL;
        break;
    case '5':
        wType |= MB_RETRYCANCEL;
        break;
    case '6':
        wType |= MB_ABORTRETRYIGNORE;
        break;
    default:
        Assert(fFalse);
        goto LHUIMBError;
        }

    if ((szText = SzFindSymbolValueInSymTab("STF_MB_ICON")) == NULL)
        {
        Assert(fFalse);
        goto LHUIMBError;
        }

    switch (*szText)
        {
    case '1':
        break;
    case '2':
        wType |= MB_ICONINFORMATION;
        break;
    case '3':
        wType |= MB_ICONSTOP;
        break;
    case '4':
        wType |= MB_ICONQUESTION;
        break;
    case '5':
        wType |= MB_ICONEXCLAMATION;
        break;
    default:
        Assert(fFalse);
        goto LHUIMBError;
        }

    if ((szText = SzFindSymbolValueInSymTab("STF_MB_DEF")) == NULL)
        {
        Assert(fFalse);
        goto LHUIMBError;
        }

    switch (*szText)
        {
    case '1':
        break;
    case '2':
        wType |= MB_DEFBUTTON2;
        break;
    case '3':
        wType |= MB_DEFBUTTON3;
        break;
    default:
        Assert(fFalse);
        goto LHUIMBError;
        }

    if ((szText = SzFindSymbolValueInSymTab("STF_MB_TEXT")) == NULL)
        {
        Assert(fFalse);
        goto LHUIMBError;
        }

    if ((szTitle = SzFindSymbolValueInSymTab("STF_MB_TITLE")) == NULL)
        szTitle = "";


    aw = GetActiveWindow();
    if ( aw == NULL || aw == GetDesktopWindow() ) {
        aw = hwndParent;
    }

    while ((imbReturn = MessageBox(aw, szText, szTitle, wType)) == 0) {
        if (!FHandleOOM(hwndParent)) {
            goto LHUIMBError;
        }
    }

    switch (imbReturn)
        {
    case IDABORT:
        szText = "ABORT";
        break;
    case IDCANCEL:
        szText = "CANCEL";
        break;
    case IDIGNORE:
        szText = "IGNORE";
        break;
    case IDNO:
        szText = "NO";
        break;
    case IDOK:
        szText = "OK";
        break;
    case IDRETRY:
        szText = "RETRY";
        break;
    case IDYES:
        szText = "YES";
        break;
    default:
        Assert(fFalse);
        goto LHUIMBError;
        }

    while (!FAddSymbolValueToSymTab("DLGEVENT", szText))
        if (!FHandleOOM(hwndParent))
            goto LHUIMBError;

    fRet = fTrue;

LHUIMBError:

    return(fRet);
}


/*
**  Purpose:
**      ??
**  Arguments:
**      ??
**  Returns:
**      ??
****************************************************************************/
EHRC APIENTRY EhrcGstCheck1EventHandler(HANDLE hInst,
                                                   HWND   hwndShell,
                                                   UINT   wMsg,
                                                   WPARAM wParam,
                                                   LONG   lParam)
{

   SZ     sz = SzFindSymbolValueInSymTab("ButtonPressed");
   WORD   idc;
   INT    iButton;
   CHP    rgchNum[10];

   Unused(hInst);
   Unused(hwndShell);
   Unused(wMsg);
   Unused(wParam);
   Unused(lParam);

    Assert(sz != NULL);

   switch (idc = (WORD)atoi(sz))
      {
   case IDC_B1:
   case IDC_B2:
   case IDC_B3:
   case IDC_B4:
   case IDC_B5:
   case IDC_B6:
   case IDC_B7:
   case IDC_B8:
   case IDC_B9:
   case IDC_B10:
      sz = "NOTIFY";
      iButton = (INT) (idc - IDC_B1 + 1);
      break;

   case IDC_SP1:
   case IDC_SP2:
   case IDC_SP3:
   case IDC_SP4:
   case IDC_SP5:
   case IDC_SP6:
   case IDC_SP7:
   case IDC_SP8:
   case IDC_SP9:
   case IDC_SP10:
      sz = "CUSTOMISE";
      iButton = (INT) (idc - IDC_SP1 + 1);
      break;

   default:
      return(ehrcNotHandled);
       }

   _itoa(iButton, rgchNum, 10);
   if(!FAddSymbolValueToSymTab("ButtonChecked", rgchNum)  ||
      !FAddSymbolValueToSymTab("DLGEVENT", sz))
      return(ehrcError);
   else
      return(ehrcPostInterp);

}


/*
**  Purpose:
**      ??
**  Arguments:
**      ??
**  Returns:
**      ??
****************************************************************************/
EHRC APIENTRY EhrcGstMultiComboEventHandler(HANDLE hInst,
                                                       HWND   hwndShell,
                                                       UINT   wMsg,
                                                       WPARAM wParam,
                                                       LONG   lParam)
{
   SZ     sz = SzFindSymbolValueInSymTab("ButtonPressed");
   WORD   idc;
   INT    iButton;
   CHP    rgchNum[10];

   Unused(hInst);
   Unused(hwndShell);
   Unused(wMsg);
   Unused(wParam);
   Unused(lParam);

    Assert(sz != NULL);

   switch (idc = (WORD)atoi(sz))
      {
   case IDC_COMBO1:
   case IDC_COMBO2:
   case IDC_COMBO3:
   case IDC_COMBO4:
   case IDC_COMBO5:
   case IDC_COMBO6:
   case IDC_COMBO7:
   case IDC_COMBO8:
   case IDC_COMBO9:
      sz = "NOTIFY";
      iButton = (INT) (idc - IDC_COMBO1 + 1);
      break;

   default:
      return(ehrcNotHandled);

       }

   _itoa(iButton, rgchNum, 10);
   if(!FAddSymbolValueToSymTab("ButtonChecked", rgchNum)  ||
      !FAddSymbolValueToSymTab("DLGEVENT", sz))
      return(ehrcError);
   else
      return(ehrcPostInterp);

}

/*
**  Purpose:
**      ??
**  Arguments:
**      ??
**  Returns:
**      ??
****************************************************************************/
EHRC APIENTRY
EhrcGstMaintenanceEventHandler(
    HANDLE hInst,
    HWND   hwndShell,
    UINT   wMsg,
    WPARAM wParam,
    LONG   lParam
    )
{
    SZ     sz = SzFindSymbolValueInSymTab("ButtonPressed");
    WORD   idc;
    INT    iButton;
    CHP    rgchNum[10];

    Unused(hInst);
    Unused(hwndShell);
    Unused(wMsg);
    Unused(wParam);
    Unused(lParam);

    Assert(sz != NULL);

    switch (idc = (WORD)atoi(sz)) {

        case MENU_CHANGE:
            sz = "SYSTEM";
            iButton = 1;
            break;

        default:
            return(ehrcNotHandled);
    }

    _itoa(iButton, rgchNum, 10);
    if(!FAddSymbolValueToSymTab("ButtonChecked", rgchNum)  ||
       !FAddSymbolValueToSymTab("DLGEVENT", sz)) {
        return(ehrcError);
    }
    else {
        return(ehrcPostInterp);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\uilstf.h ===
/***************************************************************************/
/***********************  include file for UI Library  *********************/
/***************************************************************************/

#ifndef __uilstf_
#define __uilstf_

#define STF_MESSAGE               (WM_USER + 0x8000)

/*
**  Window Messages
*/
#define STF_UI_EVENT              (STF_MESSAGE)
#define STF_DESTROY_DLG           (STF_MESSAGE + 1)
#define STF_HELP_DLG_DESTROYED    (STF_MESSAGE + 2)
#define STF_INFO_DLG_DESTROYED    (STF_MESSAGE + 3)
#define STF_EDIT_DLG_DESTROYED    (STF_MESSAGE + 4)
#define STF_RADIO_DLG_DESTROYED   (STF_MESSAGE + 5)
#define STF_CHECK_DLG_DESTROYED   (STF_MESSAGE + 6)
#define STF_LIST_DLG_DESTROYED    (STF_MESSAGE + 7)
#define STF_MULTI_DLG_DESTROYED   (STF_MESSAGE + 8)
#define STF_QUIT_DLG_DESTROYED    (STF_MESSAGE + 9)
#define STF_DLG_ACTIVATE          (STF_MESSAGE + 10)
#define STF_UILIB_ACTIVATE        (STF_MESSAGE + 11)
#define STF_REINITDIALOG          (STF_MESSAGE + 12)
#define STF_SHL_INTERP            (STF_MESSAGE + 13)
#define STF_COMBO_DLG_DESTROYED   (STF_MESSAGE + 14)
#define STF_MULTICOMBO_DLG_DESTROYED (STF_MESSAGE + 15)
#define STF_DUAL_DLG_DESTROYED    (STF_MESSAGE + 16)
#define STF_MULTICOMBO_RADIO_DLG_DESTROYED (STF_MESSAGE + 17)
#define STF_MAINT_DLG_DESTROYED   (STF_MESSAGE + 18)


#define STF_ERROR_ABORT           (STF_MESSAGE + 0x103)


//
// Button IDS to communicate help and exit button messages to shell
//
#define ID_EXITBUTTON       7
#define ID_HELPBUTTON       8


/*
**  Symbols used by Basic Dialog Class procedures
*/

#define CLS_MYDLGS          "mydlg"
#define DLGTEXT             "DlgText"
#define DLGCAPTION          "Caption"
#define DLGTYPE             "DlgType"
#define DLGTEMPLATE         "DlgTemplate"



#define INSTRUCTIONTEXT     "InstructionText"
#define HELPCONTEXT         "HelpContext"
#define EXITSTATE           "ExitState"

#define EXIT_ENABLE          "Active"
#define EXIT_DISABLE         "Inactive"


/*
**  PushButton Control IDs
*/
#define IDC_A        401
#define IDC_B        402
#define IDC_C        403
#define IDC_D        404
#define IDC_E        405
#define IDC_F        406
#define IDC_G        407
#define IDC_H        408
#define IDC_I        409
#define IDC_J        410
#define IDC_K        411
#define IDC_L        412
#define IDC_M        413
#define IDC_N        414
#define IDC_O        415
#define IDC_P        416
#define IDC_Q        417
#define IDC_R        418
#define IDC_S        419
#define IDC_T        420
#define IDC_U        421
#define IDC_V        422
#define IDC_W        423
#define IDC_X        424
#define IDC_Y        425
#define IDC_Z        426


/*
**  Text Control IDs
*/
#define IDC_TEXT1    431
#define IDC_TEXT2    432
#define IDC_TEXT3    433
#define IDC_TEXT4    434
#define IDC_TEXT5    435
#define IDC_TEXT6    436
#define IDC_TEXT7    437
#define IDC_TEXT8    438
#define IDC_TEXT9    439
#define IDC_TEXT10   440
#define IDC_TEXT11   441


/*
**  Radio and Checkbox Button Control IDs
*/
#define IDC_B0       450
#define IDC_B1       451
#define IDC_B2       452
#define IDC_B3       453
#define IDC_B4       454
#define IDC_B5       455
#define IDC_B6       456
#define IDC_B7       457
#define IDC_B8       458
#define IDC_B9       459
#define IDC_B10      460

#define IDC_RB0       610
#define IDC_RB1       611
#define IDC_RB2       612
#define IDC_RB3       613
#define IDC_RB4       614
#define IDC_RB5       615
#define IDC_RB6       616
#define IDC_RB7       617
#define IDC_RB8       618
#define IDC_RB9       619
#define IDC_RB10      620

/*
**  Generic Dialog Button IDs
*/

#define IDC_BTN0        630
#define IDC_BTN1        631
#define IDC_BTN2        632
#define IDC_BTN3        633
#define IDC_BTN4        634
#define IDC_BTN5        635
#define IDC_BTN6        636
#define IDC_BTN7        637
#define IDC_BTN8        638
#define IDC_BTN9        639


/*
**  Combo box IDs
*/
#define IDC_COMBO0   480
#define IDC_COMBO1   481
#define IDC_COMBO2   482
#define IDC_COMBO3   483
#define IDC_COMBO4   484
#define IDC_COMBO5   485
#define IDC_COMBO6   486
#define IDC_COMBO7   487
#define IDC_COMBO8   488
#define IDC_COMBO9   489

/*
**  ICON IDs
*/
#define IDC_ICON0    500
#define IDC_ICON1    501
#define IDC_ICON2    502
#define IDC_ICON3    503
#define IDC_ICON4    504
#define IDC_ICON5    505
#define IDC_ICON6    506
#define IDC_ICON7    507
#define IDC_ICON8    508
#define IDC_ICON9    509

/*
** SPECIAL PUSHBUTTONS
*/

#define IDC_SP1    521
#define IDC_SP2    522
#define IDC_SP3    523
#define IDC_SP4    524
#define IDC_SP5    525
#define IDC_SP6    526
#define IDC_SP7    527
#define IDC_SP8    528
#define IDC_SP9    529
#define IDC_SP10   530

/*
** STATUS TEXT FIELDS
*/

#define IDC_STATUS1    541
#define IDC_STATUS2    542
#define IDC_STATUS3    543
#define IDC_STATUS4    544
#define IDC_STATUS5    545
#define IDC_STATUS6    546
#define IDC_STATUS7    547
#define IDC_STATUS8    548
#define IDC_STATUS9    549
#define IDC_STATUS10   550



/*
** SIZE FIELDS ASSOCIATED WITH CHECK OPTIONAL COMPONENTS
*/

#define IDC_SIZE1    551
#define IDC_SIZE2    552
#define IDC_SIZE3    553
#define IDC_SIZE4    554
#define IDC_SIZE5    555
#define IDC_SIZE6    556
#define IDC_SIZE7    557
#define IDC_SIZE8    558
#define IDC_SIZE9    559
#define IDC_SIZE10   560



/*
** TOTALS OF SIZES
*/

#define IDC_TOTAL1    561
#define IDC_TOTAL2    562
#define IDC_TOTAL3    563
#define IDC_TOTAL4    564
#define IDC_TOTAL5    565
#define IDC_TOTAL6    566
#define IDC_TOTAL7    567
#define IDC_TOTAL8    568
#define IDC_TOTAL9    569
#define IDC_TOTAL10   570

/*
** MAXIMUM SIZES
*/

#define IDC_MAX1    571
#define IDC_MAX2    572
#define IDC_MAX3    573
#define IDC_MAX4    574
#define IDC_MAX5    575
#define IDC_MAX6    576
#define IDC_MAX7    577
#define IDC_MAX8    578
#define IDC_MAX9    579
#define IDC_MAX10   580

/*
**  Edit Control IDs
*/

#define IDC_EDIT1   581
#define IDC_EDIT2   582
#define IDC_EDIT3   583
#define IDC_EDIT4   584
#define IDC_EDIT5   585
#define IDC_EDIT6   586
#define IDC_EDIT7   587
#define IDC_EDIT8   588
#define IDC_EDIT9   589
#define IDC_EDIT10  590

/*
**  ListBox Control IDs
*/

#define IDC_LIST1   591
#define IDC_LIST2   592
#define IDC_LIST3   593
#define IDC_LIST4   594
#define IDC_LIST5   595
#define IDC_LIST6   596
#define IDC_LIST7   597
#define IDC_LIST8   598
#define IDC_LIST9   599
#define IDC_LIST10  600


/*
** MENU IDS
*/

#define ID_MAINTAIN  651


/*
** ID_MAINTAIN MENU IDS
*/

#define MENU_CHANGE           701
#define MENU_EXIT             704
#define MENU_HELPINDEX        705
#define MENU_HELPSEARCH       706
#define MENU_HELPONHELP       708
#define MENU_HELPONLINE       709
#define MENU_ABOUT            710


/*
**  Handle-Dialog type
*/
typedef HWND     HDLG;

/*
**  Event Handler Return Code type
*/
typedef USHORT   EHRC;

#define ehrcError       (EHRC) 0
#define ehrcNoPost      (EHRC) 1
#define ehrcPostInterp  (EHRC) 2
#define ehrcNotHandled  (EHRC) 3

/*
**  Prototype for Specific Dialog Event Handlers -- 1632
*/
typedef EHRC ( APIENTRY *PFNEVENT)(HANDLE, HWND, UINT, WPARAM, LPARAM);

    /* Standard Dialog handler routines */

extern INT_PTR APIENTRY LDefSetupDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstInfoDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstEditDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstMultiEditDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstGetPathDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstRadioDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstCheckDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstCheck1DlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstListDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstMultiDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstModelessDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstMultiComboDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstComboRadDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstCombinationDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstDualDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstDual1DlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstMaintDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY FGstBillboardDlgProc(HWND, UINT, WPARAM, LPARAM);

    /* stack manipulation routines */
extern HDLG    APIENTRY HdlgPushDbcb(HANDLE, SZ, SZ, HWND, WNDPROC, DWORD,
                                     PFNEVENT, SZ, WNDPROC);
extern BOOL    APIENTRY FPopDbcb(VOID);
extern BOOL    APIENTRY FPopNDbcb(INT);

extern BOOL    APIENTRY FUiLibFilter(MSG *);
extern BOOL    APIENTRY FResumeStackTop(VOID);
extern SZ      APIENTRY SzStackTopName(VOID);
extern BOOL    APIENTRY FGenericEventHandler(HANDLE, HWND, UINT, WPARAM, LPARAM);  // 1632
extern BOOL    APIENTRY FStackEmpty(VOID);
extern HDLG    APIENTRY HdlgStackTop(VOID);


//
// Display of integer items in text fields
//
extern VOID MySetDlgItemInt(HDLG, INT, LONG);
extern VOID NumericFormat(SZ szSrcBuf, SZ szDispBuf);

//
// Winhelp related externals
//

extern BOOL FInitWinHelpFile(HWND, SZ, SZ, SZ, SZ);
extern BOOL FCloseWinHelp(HWND);
extern BOOL FProcessWinHelp(HWND);
extern BOOL FProcessWinHelpMenu(HWND, WORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\ui.h ===
extern EHRC  APIENTRY EhrcGstCheck1EventHandler(HANDLE, HWND, UINT, WPARAM, LONG);
extern EHRC  APIENTRY EhrcGstMultiComboEventHandler(HANDLE, HWND, UINT, WPARAM, LONG);
extern EHRC  APIENTRY EhrcGstMaintenanceEventHandler(HANDLE, HWND, UINT, WPARAM, LONG);

//extern VOID  FSetDlgInstructionText(HWND);
//extern VOID  FSetDlgHelpContext(HWND);
//extern VOID  FSetDlgExitState(HWND);


extern BOOL  APIENTRY FDoDialog(SZ, HANDLE, HWND);
extern BOOL  APIENTRY FKillNDialogs(USHORT, BOOL);
extern BOOL  APIENTRY FHandleUIMessageBox(HWND);

typedef struct _dlgmp
   {
   SZ       szDlgType;
   WNDPROC  FGstDlgProc;
	PFNEVENT EhrcEventHandler;
	} DLGMP, *pDLGMP;

extern pDLGMP pdlgmpFindDlgType(SZ, pDLGMP);

/*------------------------
   MENUDEMO.H header file
  ------------------------*/

#define IDM_HELP      1
#define IDM_INFO      2
#define IDM_EDIT      3
#define IDM_RADIO     4
#define IDM_LIST      5
#define IDM_MULTI     6
#define IDM_QUIT      7
#define IDM_SHOWA		 8
#define IDM_SHOWNA	 9
#define IDM_HIDE		 10
#define IDM_ACTIVATE  11
#define IDM_INACTIVATE 12
#define IDM_PUSH		  13
#define IDM_POP		  14
#define IDM_SHOWHELP   15
#define IDM_CLOSEHELP  16
#define IDM_RESUME     17
#define IDM_ENABLE	  18
#define IDM_DISABLE    19
#define IDM_POP1			20
#define IDM_POP2			21
#define IDM_POP3			22
#define IDM_POP4			23
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_dinterp.h ===
/* File: _dinterp.h */

/**************************************************************************/
/***** DETECT COMPONENT - Header file for detect interpreter.
/**************************************************************************/

/* Minimum good value returned by load DLL function */
#define hLibMin ((HANDLE)32)

/* Detect command constants */
#define szDetSym "?"
#define iszDetSym 1
#define iszLib    2
#define iszCmd    3
#define iszArg    4
#define cFieldDetMin 4

/* Default command return value buffer size */
#define cbValBufDef 1024
/* NOTE (TEST): Defining cbValBufDef as 1 causes a PbRealloc
** for each detect command.  This can be useful for testing.
*/

/* Function pointer for detect commands */
typedef CB ( APIENTRY *PFNCMD)(RGSZ, USHORT, SZ, CB);
#define pfncmdNull ((PFNCMD)NULL)


BOOL  APIENTRY FDetectInfSection(HWND, SZ);
BOOL  APIENTRY FLoadDetectLib(SZ, SZ, HANDLE *);
DRC   APIENTRY DrcGetDetectValue(SZ *, PFNCMD, RGSZ, CB);   // 1632
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_context.h ===
/*************************************************/
/* Common Library Component private include file */
/*************************************************/



// ****************************************************************************
//
//  This file contains declarations that have to do  with INF contexts
//
//
//  For each INF file loaded, Setup maintains a permanent INF information
//  block and a temporary INF information block.
//
//  InfPermInfo:    The permanent information block contains the data
//                  that is kept throughout the life of Setup, even after an
//                  INF file has been discarded. This is reused if an INF
//                  is re-loaded.
//
//  InfTempInfo:    The temporary information block contains data that is
//                  kept only as long as the INF is loaded. This consists
//                  mainly of the preparsed INF and its symbol table.
//
//
//  An INF context consists of a line number ( which is the INF line being
//  executed), plus the temporary and permanent INF information.
//
//  INF contexts are entered with the SHELL command and exited with the
//  RETURN command.
//
// ****************************************************************************




//
//  Count of strings in each String-Table-Freeing node
//
#define  cszPerStf  (62)

//
//  String-Table-Free structure
//
typedef struct _STF *PSTF;
typedef  struct _STF {
    PSTF          pstfNext;
	SZ            rgsz[cszPerStf];
	USHORT        cszFree;
}  STF;
typedef  PSTF * PPSTF;



//
//  INF permanent information. This is kept throughout all of SETUP.
//
//  There is one if these for each INF file that has been used by SETUP.
//
typedef struct _INFPERMINFO *PINFPERMINFO;
typedef struct _INFPERMINFO {
    PINFPERMINFO    pNext;      // Next in List
    SZ              szName;     // INF name
    UINT            InfId;      // INF Id
    PSDLE           psdleHead;  // Source media description list head
    PSDLE           psdleCur;   // Current source media description
    PCLN            pclnHead;   // Head of copy list
    PPCLN           ppclnTail;  // Tail of copy list
    PSTF            pstfHead;   // Head of free string table
} INFPERMINFO;


//
//  Parsed INF info. There is one of these per active INF plus a few
//  cached ones for previously used INFs.
//
typedef struct _PARSED_INF *PPARSED_INF;
typedef struct _PARSED_INF {
    PPARSED_INF     pPrev;
    PPARSED_INF     pNext;
    PINFPERMINFO    pInfPermInfo;
    PINFLINE        MasterLineArray;
    UINT            MasterLineCount;
    PUCHAR          MasterFile;
    UINT            MasterFileSize;
} PARSED_INF;



//
//  INF temporary information. This goes away when no context
//  references the INF.
//
typedef struct _INFTEMPINFO *PINFTEMPINFO;
typedef struct _INFTEMPINFO {
    PINFTEMPINFO    pPrev;                      //  Previous in chain
    PINFTEMPINFO    pNext;                      //  Next in chain
    PINFPERMINFO    pInfPermInfo;               //  INF permanent information
    PPARSED_INF     pParsedInf;                 //  Parsed INF
    DWORD           cRef;                       //  Reference count
    PSYMTAB         SymTab;                     //  Static symbol table
} INFTEMPINFO;


//
//  Context entry in context stack. There is one of these for
//  each context entered.
//
typedef struct _INFCONTEXT *PINFCONTEXT;
typedef struct _INFCONTEXT {
    PINFCONTEXT     pNext;                  //  Next context in chain
    PINFTEMPINFO    pInfTempInfo;           //  INF temporary info
    INT             CurrentLine;            //  Current line being executed
    PSEFL           pseflHead;              //  Flow statement block
    PSYMTAB         SymTab;                 //  Local symtol table
    SZ              szShlScriptSection;     //  Shell script section
    SZ              szHelpFile;             //  Help file
    DWORD           dwLowContext;           //  Help context low
    DWORD           dwHighContext;          //  Help context high
    DWORD           dwHelpIndex;            //  Help index.
    BOOL            bHelpIsIndexed;         //  Whether help is indexed
} INFCONTEXT;







//
//  Global variables
//
extern PINFCONTEXT     pContextBottom;     // The global (SETUP) context
extern PINFCONTEXT     pContextTop;        // Top of context stack
extern PINFPERMINFO    pInfPermInfoHead;   // Head of InfPermInfo list
extern PINFPERMINFO    pInfPermInfoTail;   // Tail of InfPermInfo list






//
//  Some macros for accessing contexts and INF information
//
#define pLocalContext()             pContextTop
#define pGlobalContext()            pContextBottom
#define pInfTempInfo( Context )     ((Context)->pInfTempInfo)
#define pInfPermInfo( Context )     (pInfTempInfo( Context )->pInfPermInfo)
#define pParsedInf( Context )       (pInfTempInfo( Context )->pParsedInf)
#define pLocalInfTempInfo()         pInfTempInfo( pLocalContext() )
#define pLocalInfPermInfo()         pInfPermInfo( pLocalContext() )

#define PpclnHeadList( pPermInfo )  &(pPermInfo->pclnHead)
#define PppclnTailList( pPermInfo ) &(pPermInfo->ppclnTail)



#define PreCondSymTabInit(r) PreCondition( (pLocalContext() != NULL), r )






//
//  Function Prototypes
//
extern BOOL         APIENTRY PushContext( PINFCONTEXT pContext );
extern PINFCONTEXT  APIENTRY PopContext( VOID );
extern VOID         APIENTRY FreeContext( PINFCONTEXT pContext );
extern PINFPERMINFO APIENTRY NameToInfPermInfo( SZ szName , BOOL AllocIfNotPresent);
extern PINFPERMINFO APIENTRY AddInfPermInfo( SZ szName );
extern BOOL         APIENTRY PathToInfName( SZ szPath, SZ szName );
extern PSYMTAB      APIENTRY PInfSymTabFind( SZ szSymbol, SZ *szNewSymbol );

extern PINFTEMPINFO APIENTRY CreateInfTempInfo( PINFPERMINFO );

extern BOOL         APIENTRY FFreeSrcDescrList(PINFPERMINFO);
extern PSDLE        APIENTRY PsdleFromDid(DID, PINFPERMINFO);

extern BOOL         APIENTRY FFreeCopyList(PINFPERMINFO);
#if DBG
extern BOOL         APIENTRY FValidCopyList(PINFPERMINFO);
#endif

extern BOOL         APIENTRY FInitFreeTable(PINFPERMINFO);
extern BOOL         APIENTRY FAddSzToFreeTable(SZ, PINFPERMINFO);
extern BOOL         APIENTRY FAddNewSzsInPoerToFreeTable(POER, POER, PINFPERMINFO);
extern BOOL         APIENTRY FFreeFreeTable(PINFPERMINFO);
extern PPARSED_INF  APIENTRY ParsedInfAlloc(PINFPERMINFO);
extern BOOL         APIENTRY FFreeParsedInf( PPARSED_INF);
extern BOOL         APIENTRY FlushInfParsedInfo(SZ szInfName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_drives.h ===
/* File: _drives.h */

/**************************************************************************/
/***** DETECT COMPONENT - Disk Drive Detect Commands Internal Header
/**************************************************************************/

/* Size of drives list string */
#define cbDrivesListMax 106

/* Function pointer to BOOL drive commands */
typedef BOOL ( APIENTRY *PFNBDC)(INT);
#define pfnbdcNull ((PFNBDC)NULL)

/* Function pointer to LONG drive commands */
typedef LONG ( APIENTRY *PFNLDC)(INT);
#define pfnldcNull ((PFNLDC)NULL)

CB  APIENTRY CbDriveCmd(PFNBDC, SZ, SZ, CB);
CB  APIENTRY CbDriveListCmd(PFNBDC, SZ, CB);
CB  APIENTRY CbDriveSpaceCmd(PFNLDC, SZ, SZ, CB);
INT  APIENTRY NDriveFromDriveStr(SZ);

BOOL  APIENTRY FIsLocalHardDrive(INT);
BOOL  APIENTRY FIsValidDrive(INT);
BOOL  APIENTRY FIsRemoteDrive(INT);
LONG  APIENTRY LcbTotalDrive(INT);
LONG  APIENTRY LcbFreeDrive(INT);
INT  APIENTRY NDrivePhysical(INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\vdm.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdm.c

Abstract:

    Routines to handle VDM config files

    Detect Routines:
    ----------------

    1. GetDosPathVar:  This finds out the value of the DOS Path variable

    2. GetWindowsPath: THis finds out the directory where windows in installed
                       on the current system

    3. GetInstalledOSNames: Finds out all the OSs installed on current system.

    Install Routines Workers:
    -------------------------

    1. VdmFixupWorker: This forms the NT VDM configuration files from DOS
                       configuration files and NT VDM template config files.

    2. MigrateWinIniWorker: This migrates windows ini configuration from
                            win.ini files.  BUGBUG**REMOVED

    General Subroutines:
    --------------------

    1. FFileExist:  Whether a file exists or not.

    2. FileSize:     The size of a file.


Author:

    Sunil Pai (sunilp) Mar 31, 1992

--*/

#define WIN_COM     "WIN.COM"
#define INI         ".INI"
#define TMP         ".TMP"

#define CONFIG_SYS  "C:\\CONFIG.SYS"
#define BATCH_BAT   "C:\\AUTOEXEC.BAT"

#define CONFIG_NT   "\\CONFIG.NT"
#define BATCH_NT    "\\AUTOEXEC.NT"

#define CONFIG_TMP  "\\CONFIG.TMP"
#define BATCH_TMP   "\\AUTOEXEC.TMP"

#define IO_SYS      "C:\\IO.SYS"
#define MSDOS_SYS   "C:\\MSDOS.SYS"
#define IBMBIO_COM  "C:\\IBMBIO.COM"
#define IBMDOS_COM  "C:\\IBMDOS.COM"
#define OS2LDR      "C:\\OS2LDR"
#define STARTUPCMD  "C:\\STARTUP.CMD"

#define DOS         "DOS"
#define OS2         "OS2"

//
//  Local prototypes
//

BOOL  FilterDosConfigFile(LPSTR szSrc, LPSTR szDst, LPSTR szTemplate);
BOOL  DosConfigFilter(IN OUT TEXTFILE *SrcText, IN OUT FILE *f, OUT RGSZ *rgszFound);
DWORD FileSize(SZ szFile);
BOOL  AppendSzToFile( SZ szFileName, SZ szAddOnSz );
SZ    SzGetDosPathVar(DWORD MaxLength);
BOOL  GetPathVarFromLine( SZ, SZ, DWORD );
BOOL  CheckDosConfigModified( IN  LPSTR szConfig);


#if 0
BOOL  FilterDosBatchFile(LPSTR szSrc, LPSTR szDst, LPSTR szTemplate);
BOOL  DosBatchFilter( TEXTFILE*, FILE* );
BOOL  FixConfigFileMacroChar(SZ szConfigFile, CHAR cReplaceChar, SZ szSystemDir);


BOOL  FFindAndCopyIniFiles( SZ szSrcDir, SZ szDstDir );
BOOL  FMigrateStandardIniData( SZ szWindowsDir );
BOOL  FMigrateWinIniAppSections( SZ szWindowsDir );
SZ    SzMapStandardIni( SZ szIniFile );
VOID  CleanupIniFiles( SZ szWindowsDir );
BOOL  FIsStandardWinIniSection( SZ szSection );
#endif


// ***************************************************************************
//
//                  DOS VDM FIXUP MAIN ROUTINE
//
// ***************************************************************************

BOOL
VdmFixupWorker(
    LPSTR szAddOnConfig,
    LPSTR szAddOnBatch
    )
{
    CHAR  szConfigVDM[MAX_PATH], szBatchVDM[MAX_PATH];
    CHAR  szConfigTmp[MAX_PATH], szBatchTmp[MAX_PATH];
    SZ    szConfigDOS, szBatchDOS;
    CHAR  szSystemDir[ MAX_PATH ];
    DWORD dwDosConfigAttr = FILE_ATTRIBUTE_NORMAL;
    DWORD dwDosBatchAttr  = FILE_ATTRIBUTE_NORMAL;
    DWORD dw;
    BOOL  bStatus = TRUE;

    //
    // A. Determine names to use: no renaming any more.  Config.sys and
    //    autoexec.bat on root of C drive are the files to use for DOS,
    //    config.nt and autoexec.nt in the system directory are the files
    //    to use for nt.  the template config.nt and autoexec.nt are
    //    still copied into the root of the C drive for reference.
    //

    GetSystemDirectory( szSystemDir, MAX_PATH );

    szConfigDOS = CONFIG_SYS;
    szBatchDOS  = BATCH_BAT;

    lstrcpy( szConfigVDM, szSystemDir );
    lstrcat( szConfigVDM, CONFIG_NT );

    lstrcpy( szBatchVDM, szSystemDir );
    lstrcat( szBatchVDM, BATCH_NT );

    lstrcpy( szConfigTmp, szSystemDir );
    lstrcat( szConfigTmp, CONFIG_TMP );

    lstrcpy( szBatchTmp, szSystemDir );
    lstrcat( szBatchTmp, BATCH_TMP );


    //
    // Verify that the template files exist, else
    //

    if ( !(FFileExist( szConfigTmp ) && FFileExist( szBatchTmp )) ) {
        SetErrorText(IDS_ERROR_OPENFAIL);
        return( fFalse );
    }
    else {
        SetFileAttributes ( szConfigTmp, FILE_ATTRIBUTE_NORMAL );
        SetFileAttributes ( szBatchTmp,  FILE_ATTRIBUTE_NORMAL );
    }

    //
    // Fix the attributes of the DOS CONFIG FILES so that we can look at
    // them henceforth
    //

    if ( FFileExist(szConfigDOS) ) {
        if ( (dw = GetFileAttributes( szConfigDOS )) != 0xFFFFFFFF) {
            dwDosConfigAttr = dw;
        }
        SetFileAttributes( szConfigDOS, FILE_ATTRIBUTE_NORMAL );
    }

    if ( FFileExist(szBatchDOS) ) {
        if ( (dw = GetFileAttributes( szBatchDOS )) != 0xFFFFFFFF) {
            dwDosBatchAttr = dw;
        }
        SetFileAttributes( szBatchDOS, FILE_ATTRIBUTE_NORMAL );
    }

    //
    // Delete the existing config files for the vdm - no upgrade supported
    // at this moment.
    //

    if ( FFileExist( szConfigVDM ) ) {
        SetFileAttributes ( szConfigVDM, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( szConfigVDM );
    }

    if ( FFileExist( szBatchVDM ) ) {
        SetFileAttributes ( szBatchVDM, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( szBatchVDM );
    }


    //
    // Check if configuration information exists, else just rename
    // the default temporary configuration files to the final names.
    //

    if ((!FFileExist(szConfigDOS))            ||
        (!CheckConfigTypeWorker(szConfigDOS))
       ) {
        if( !( MoveFile( szConfigTmp, szConfigVDM ) &&
               MoveFile( szBatchTmp,  szBatchVDM  ))) {
            SetErrorText(IDS_ERROR_WRITE);
            bStatus = fFalse;
            goto cleanup;
        }
    }
    else {
        if( !FilterDosConfigFile(szConfigDOS, szConfigVDM, szConfigTmp) ) {
            bStatus = fFalse;
            goto cleanup;
        }

        //
        // Nothing is being migrated from the DOS batch file, so we
        // can just rename the temporary file to the permanent one
        //

        if( !MoveFile( szBatchTmp,  szBatchVDM ) ) {
            SetErrorText(IDS_ERROR_WRITE);
            bStatus = fFalse;
            goto cleanup;
        }

    }

    //
    // Append the NT Signature blocks onto the existing config files. If
    // files don't exist then create them
    //

    if(!CheckDosConfigModified(szConfigDOS) ) {
        if( !AppendSzToFile( szConfigDOS, szAddOnConfig ) ) {
            //
            //  Silently fail if unable to append the signature.
            //  Failure will occur if c: is not formatted.
            //
            //  bStatus = fFalse;
            goto cleanup;
        }
    }

    if(!CheckDosConfigModified(szBatchDOS) ) {
        if( !AppendSzToFile( szBatchDOS, szAddOnBatch ) ) {
            //
            //  Silently fail if unable to append the signature.
            //  Failure will occur if c: is not formatted.
            //
            //  bStatus = fFalse;
            goto cleanup;
        }
    }

cleanup:

    //
    // If autoexec.nt and config.nt files not found, try creating them from
    // the tmp files if possible
    //

    if( !FFileExist( szConfigVDM ) ) {
        MoveFile( szConfigTmp, szConfigVDM );
    }
    if( !FFileExist( szBatchVDM ) ) {
        MoveFile( szBatchTmp, szBatchVDM );
    }

    //
    // Remove the temporary config files if they exist.
    //

    DeleteFile( szConfigTmp );
    DeleteFile( szBatchTmp  );

    //
    // reset the attributs on the DOS config files, if they exist
    //

    if ( FFileExist( szConfigDOS ) ) {
        SetFileAttributes( szConfigDOS, dwDosConfigAttr );
    }

    if ( FFileExist( szBatchDOS ) ) {
        SetFileAttributes( szBatchDOS, dwDosBatchAttr );
    }

#if 0
    //
    // If the NT config files have been created, set the attributes of these
    // to system and readonly
    //

    if( FFileExist( szConfigVDM ) ) {
        SetFileAttributes(
            szConfigVDM,
            FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY
            );
    }
    if( FFileExist( szBatchVDM ) ) {
        SetFileAttributes(
            szBatchVDM,
            FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY
            );
    }
#endif

    return( bStatus );
}


// ***************************************************************************
//
//                  DOS CONFIG.SYS ROUTINES
//
// ***************************************************************************

//
//  copy a DOS config file REMing out any line that is not a
//  SET or a PATH command
//
//  szSrc: Source batch file      (DOS    c:\autoexec.bat )
//  szDst: Destination batch file (NT VDM c:\autoexec.nt  )

BOOL
FilterDosConfigFile(
    LPSTR szSrc,
    LPSTR szDst,
    LPSTR szTemplate

    )
{
    TEXTFILE    SrcText, TemplateText;
    FILE*       f;
    size_t      Idx;
    RGSZ        rgszFound = NULL;
    BOOL        bStatus = TRUE;
    SZ          sz, szLine;
    CHAR        Buffer[ MAX_PATH ];

    //
    //  If destination already exists get rid of it
    //

    if (FFileExist( szDst )) {
        bStatus = SetFileAttributes ( szDst, FILE_ATTRIBUTE_NORMAL );
        if (bStatus) {
              bStatus = DeleteFile( szDst );
        }
    }

    if (!bStatus) {
        SetErrorText(IDS_ERROR_WRITE);
        return (fFalse);
    }

    //
    // Open destination file for writing.
    //

    if ( !(f = fopen( szDst, "w" )) ) {
        SetErrorText(IDS_ERROR_WRITE);
        return( FALSE );
    }

    //
    //  Open source file and filter it
    //

    if ( FFileExist( szSrc )            &&
         TextFileOpen( szSrc, &SrcText ) ) {

        bStatus = DosConfigFilter( &SrcText, f, &rgszFound );
        TextFileClose( &SrcText );

    }

    if( !bStatus ) {
        goto err;
    }

    //
    // Now add on the default config file from the template file
    //

    if ( !TextFileOpen( szTemplate, &TemplateText ) ) {
        bStatus = fFalse;
        SetErrorText(IDS_ERROR_OPENFAIL);
        goto err;
    }

    while ( TextFileReadLine( &TemplateText ) ) {
        BOOL    fFound = FALSE;

        szLine  = TextFileGetLine( &TemplateText );
        sz      = TextFileSkipBlanks( szLine );


        //
        //  If blank line, ignore
        //

        if ( sz && *sz != '\0' && rgszFound ) {
            Idx = strcspn( sz, " \t=" );
            if ( Idx <= strlen(sz) ) {

                PSZ psz;

                memcpy( Buffer, sz, Idx );
                Buffer[Idx] = '\0';

                //
                // If one of the entries we have found from a dos config file
                // set fFound to true so that we don't copy this file
                //

                psz = rgszFound;

                while ( *psz ) {
                    if ( !lstrcmpi( Buffer, *psz ) ) {
                        fFound = fTrue;
                        break;
                    }
                    psz++;
                }

            }
        }

        if( !fFound ) {
            fprintf( f, "%s\n", szLine );
        }

    }
    TextFileClose( &TemplateText );
    bStatus = fTrue;
err:
    fclose( f );
    if( rgszFound ) {
        RgszFree( rgszFound );
    }

    return(bStatus);
}



BOOL
DosConfigFilter(
    IN OUT  TEXTFILE *  SrcText,
    IN OUT  FILE*       f,
       OUT  RGSZ*       rgszFound
    )
{
    SZ      szLine;
    SZ      sz;
    CHAR    Buffer[ MAX_PATH ];
    size_t  Idx;
    int     i;
    RGSZ    rgsz;

    #define NUM_RESPECTED_ENTRIES 4

    CHAR    *ConfEntry[NUM_RESPECTED_ENTRIES] = {
                "BREAK", "FCBS",
                "FILES", "LASTDRIVE"
                };

    BOOL ConfEntryFound[NUM_RESPECTED_ENTRIES] = {
                FALSE,FALSE,FALSE,FALSE
                };


    if( !(rgsz = RgszAlloc(1)) ) {
        SetErrorText(IDS_ERROR_DLLOOM);
        return( FALSE );
    }

    while ( TextFileReadLine( SrcText ) ) {

        szLine  = TextFileGetLine( SrcText );
        sz      = TextFileSkipBlanks( szLine );


        //
        //  If blank line, ignore
        //
        if ( !sz || *sz == '\0' ) {
            continue;
        }


        Idx = strcspn( sz, " \t=" );
        if ( Idx <= strlen(sz) ) {

            memcpy( Buffer, sz, Idx );
            Buffer[Idx] = '\0';

            //
            // If one of the entries we respect, copy the line out verbatim
            //

            for (i = 0; i<NUM_RESPECTED_ENTRIES; i++) {

                if(!ConfEntryFound[i] && !lstrcmpi( Buffer, ConfEntry[i] ) ) {

                    ConfEntryFound[i] = TRUE;

                    if( !RgszAdd( &rgsz, SzDup(Buffer) ) ) {
                        SetErrorText(IDS_ERROR_DLLOOM);
                        return( FALSE );
                    }
                    fprintf( f, "%s\n", szLine );
                    break;
                }
            }

        }
    }

    *rgszFound = rgsz;
    return fTrue;
}




// ***************************************************************************
//
//                  DOS/OS2 DETECT and WORKER ROUTINES
//
// ***************************************************************************


/*
    list of installed OS names (DOS / OS2)
*/
CB
GetInstalledOSNames(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    #define TEMP_INSTALLEDOSNAMES "{}"

    RGSZ   rgsz;
    SZ     sz;
    CB     cbRet;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    rgsz = RgszAlloc(1);

    //
    // Check for DOS first
    //

    if ( FFileExist( CONFIG_SYS ) ) {

        //
        //  Look for Kernel and IO files to see if DOS installed
        //

        if ( (FFileExist(MSDOS_SYS)  && FFileExist(IO_SYS)) ||
             (FFileExist(IBMDOS_COM) && FFileExist(IBMBIO_COM)) ) {

            RgszAdd ( &rgsz, SzDup( DOS ) );
        }

        //
        // Look at OS2LDR and STARTUP.CMD to see if OS2 installed
        //

        if ( FFileExist( OS2LDR )  && FFileExist( STARTUPCMD ) ) {
            RgszAdd ( &rgsz, SzDup( OS2 ) );
        }
    }

    sz = SzListValueFromRgsz( rgsz );

    if ( sz ) {

        lstrcpy( ReturnBuffer, sz );
        cbRet = lstrlen( sz ) + 1;
        SFree( sz );


    }
    else {
        lstrcpy(ReturnBuffer,TEMP_INSTALLEDOSNAMES);
        cbRet = lstrlen( TEMP_INSTALLEDOSNAMES ) + 1;
    }

    if ( rgsz ) {
        RgszFree( rgsz );
    }

    return ( cbRet );
}



BOOL
CheckConfigTypeWorker(
    IN  LPSTR szConfig
    )
{
    TEXTFILE    SrcText;
    SZ          szLine;
    SZ          sz;
    CHAR        Buffer[ MAX_PATH ];
    size_t      Idx;
    BOOL        DosType = FALSE;
    INT         i;


    CHAR       *ConfEntry[] = {
                    "DISKCACHE", "LIBPATH",   "PAUSEONERROR",
                    "RMSIZE",    "RUN",       "SWAPPATH",
                    "IOPL",      "MAXWAIT",   "MEMMAN",
                    "PRIORITY",  "PROTSHELL", "PROTECTONLY",
                    "THREADS",   "TIMESLICE", "TRACE",
                    "TRACEBUF",  "DEVINFO",   NULL
                    };

    //
    //  Open source file
    //

    if ( FFileExist( szConfig ) &&
         TextFileOpen( szConfig, &SrcText ) ) {

        DosType = TRUE;

        //
        // Process config file, line by line
        //

        while ( TextFileReadLine( &SrcText ) && DosType ) {

            szLine  = TextFileGetLine( &SrcText );
            sz      = TextFileSkipBlanks( szLine );


            //
            //  If blank line, skip
            //
            if ( !sz || *sz == '\0' ) {
                continue;
            }


            //
            // Get first field
            //

            Idx = strcspn( sz, " \t=" );
            if ( Idx <= strlen(sz) ) {

                memcpy( Buffer, sz, Idx );
                Buffer[Idx] = '\0';

                //
                // Compare against list of known key words for OS2
                //


                for (i = 0; ConfEntry[i] != NULL; i++) {
                    if ( !lstrcmpi( Buffer, ConfEntry[i] ) ) {
                        DosType = FALSE;
                        break;
                    }
                }
            }
        }
        TextFileClose(&SrcText);
    }

    return( DosType );
}

BOOL
CheckDosConfigModified(
    IN  LPSTR szConfig
    )
{
    TEXTFILE    SrcText;
    SZ          szLine;
    SZ          sz;
    BOOL        Modified = FALSE;

    #define SEARCH_STRING "REM Windows NT DOS subsystem"

    //
    //  Open source file
    //

    if ( FFileExist( szConfig ) &&
         TextFileOpen( szConfig, &SrcText ) ) {

        //
        // Process config file, line by line
        //

        while ( TextFileReadLine( &SrcText ) ) {

            szLine  = TextFileGetLine( &SrcText );
            sz      = TextFileSkipBlanks( szLine );


            //
            //  If blank line, skip
            //
            if ( !sz || *sz == '\0' ) {
                continue;
            }


            //
            // Search for search_string.  If this is found it means that
            // the config file has already been modified during an
            // earlier installation.
            //

            if( strstr( sz, SEARCH_STRING ) ) {
                Modified = TRUE;
                break;
            }

        }
        TextFileClose(&SrcText);
    }
    return( Modified );
}


BOOL
AppendSzToFile(
    SZ szFileName,
    SZ szAddOnSz
    )
{
    DWORD  BytesWritten;
    HANDLE hfile;

    //
    // Open the file
    //

    hfile = CreateFile(
                szFileName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (hfile == INVALID_HANDLE_VALUE) {
        SetErrorText(IDS_ERROR_OPENFAIL);
        return FALSE;
    }

    //
    // Go to end of file
    //

    SetFilePointer (
        hfile,
        0,
        NULL,
        FILE_END
        );

    //
    // Append string passed in at the end of the file
    //

    WriteFile (
        hfile,
        szAddOnSz,
        lstrlen( szAddOnSz ),
        &BytesWritten,
        NULL
        );

    CloseHandle (hfile);
    return TRUE;
}


// ***************************************************************************
//
//              DOS AND WINDOWS PATH DETECT ROUTINES
//
// ***************************************************************************

//
//  Get the PATH environment variable used in AUTOEXEC.BAT
//

CB
GetDosPathVar(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    #define     NODOSPATH "{}"
    SZ          sz;
    SZ          PathVar;
    RGSZ        rgszDosPath;
    BOOL        fOkay = fFalse;


    Unused( Args );
    Unused( cArgs );


    if ( PathVar = SzGetDosPathVar(cbReturnBuffer-1) ) {
        if (lstrcmpi( PathVar, "" )) {
            if ( rgszDosPath = RgszFromPath( PathVar ) ) {

                sz = SzListValueFromRgsz( rgszDosPath );
                RgszFree( rgszDosPath );

                if ( sz ) {
                    strncpy( ReturnBuffer, sz, cbReturnBuffer-1 );
                    ReturnBuffer[cbReturnBuffer-1] = 0;
                    SFree( sz );
                    fOkay = fTrue;
                }
            }
        }

        SFree( PathVar );
    }

    if ( !fOkay ) {
        lstrcpy(ReturnBuffer, NODOSPATH);
    }

    return(lstrlen(ReturnBuffer)+1);
}




//
//  Get the PATH environment variable used in AUTOEXEC.BAT
//
SZ
SzGetDosPathVar(
    IN DWORD MaxLength
    )
{
    TEXTFILE    AutoexecBat;
    SZ          szPath = (SZ)NULL;
    SZ          szConfigDOS, szBatchDOS;
    BOOL        fOkay = fFalse;

    szConfigDOS = CONFIG_SYS;
    szBatchDOS  = BATCH_BAT;

    if (szPath = SAlloc( MaxLength )) {

        *szPath = '\0';

        //
        //  Open AUTOEXEC.BAT file
        //
        if ( FFileExist(szConfigDOS)              &&
             CheckConfigTypeWorker(szConfigDOS)   &&
             FFileExist( szBatchDOS )             &&
             TextFileOpen( szBatchDOS, &AutoexecBat ) ) {

            //
            //  Read all lines in the file and update the PATH
            //  environment variable
            //
            while ( TextFileReadLine( &AutoexecBat ) ) {

                GetPathVarFromLine( TextFileGetLine( &AutoexecBat ), szPath, MaxLength );
            }

            TextFileClose( &AutoexecBat );
        }
    }

    return szPath;
}




//
//  Parse a line and update the PATH variable
//
BOOL
GetPathVarFromLine(
    IN  SZ    szLine,
    OUT SZ    szPath,
    IN  DWORD MaxLength
    )
{

    #define PATH        "PATH"

    PCHAR   PrevPath = NULL;
    CHAR    Buffer[ MAX_PATH ];
    size_t  Idx;
    BOOL    fSet = fFalse;
    SZ      pBegin, pEnd, pLast;
    DWORD   PrevPathLen,BeginLen;

    //
    //  Skip blanks.  return if blank line
    //

    szLine = TextFileSkipBlanks( szLine );
    if( !szLine || *szLine == '\0') {
        return( fFalse );
    }

    //
    //  If "no echo" command, skip the '@'
    //
    if ( *szLine == '@' ) {
        szLine++;
    }

    Idx = strcspn( szLine, " \t=" );
    if ( Idx < strlen(szLine) ) {

        //
        //  If this is a SET command, skip over the SET and set the
        //  fSet flag.
        //
        memcpy( Buffer, szLine, Idx );
        Buffer[Idx] = '\0';

        if ( !_strcmpi( Buffer, "SET" ) ) {

            //
            //  SET command
            //
            fSet   = fTrue;
            szLine = TextFileSkipBlanks( szLine+Idx );
            if( !szLine || *szLine == '\0' ) {
                return ( fFalse );
            }

            Idx    = strcspn( szLine, " \t=" );

            if ( Idx >= strlen(szLine) ) {
                return fFalse;
            }

            memcpy( Buffer, szLine, Idx );
            Buffer[Idx] = '\0';

        }
        else if (*(szLine + Idx) == '=') {

            //
            // This is a command of type Var=Value ( A Set command without
            // the "SET" keyword

            fSet = fTrue;
        }

        //
        //  At this point we should be pointing to "PATH" and fSet tells
        //  us whether this is a SET command or not.
        //
        if ( !_strcmpi( Buffer, PATH ) ) {

            szLine = TextFileSkipBlanks( szLine+Idx );
            if( !szLine || *szLine == '\0' ) {
                return ( fFalse );
            }

            //
            //  If SET, skip the "="
            //
            if ( fSet ) {
                if ( *szLine != '=' ) {
                    return fFalse;
                }
                szLine = TextFileSkipBlanks( szLine+1 );
                if( !szLine || *szLine == '\0' ) {
                    return ( fFalse );
                }
            }

            //
            //  Now we point at the value of PATH.
            //
            //  Remember all value of PATH
            //
            PrevPathLen = lstrlen(szPath);
            PrevPath = SAlloc(PrevPathLen+1);
            strcpy( PrevPath, szPath );
            szPath[0] = '\0';

            pBegin = szLine;
            pLast  = pBegin + strlen( pBegin );

            //
            //  Copy the new value of PATH, one directory at a time
            //
            do {

                pEnd = strchr(pBegin, ';' );

                if ( pEnd == NULL ) {
                    pEnd = pBegin + strlen( pBegin );
                }
                *pEnd = '\0';

                if ( (BeginLen = strlen(pBegin)) > 0 ) {

                    //
                    //  If a variable substitution, only do it if it is
                    //  substituting "PATH"
                    //
                    if ( *pBegin   == '%' &&
                         *(pEnd-1) == '%' ) {

                        memcpy( Buffer, pBegin+1, (size_t)(pEnd-pBegin-2) );
                        Buffer[pEnd-pBegin-2] = '\0';

                        if ( !_strcmpi( Buffer, PATH ) ) {
                            if(lstrlen(szPath)+PrevPathLen < MaxLength) {
                                strcat( szPath, PrevPath );
                                if ( pEnd != pLast ) {
                                    strcat( szPath, ";" );
                                }
                            }
                        }

                    } else {

                        if(lstrlen(szPath)+BeginLen < MaxLength) {
                            strcat( szPath, pBegin );
                            if ( pEnd != pLast ) {
                                strcat( szPath, ";" );
                            }
                        }
                    }
                }

                pBegin = pEnd+1;

            } while ( pBegin < pLast );

            SFree(PrevPath);
        }
    }

    return fFalse;
}






//
//  Get Windows Path, "" if not installed
//
CB
GetWindowsPath(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    #define WIN_PTH_NONE    ""

    SZ      szDosPath;
    RGSZ    rgszDosPath;
    INT     i;
    CHAR    szFile[ MAX_PATH ];
    BOOL    fOkay = fFalse;
    SZ      szEnd;

    Unused( Args );
    Unused( cArgs );

    if ( szDosPath = SzGetDosPathVar(cbReturnBuffer-1) ) {

        if ( rgszDosPath = RgszFromPath( szDosPath ) ) {

            for ( i=0; rgszDosPath[i]; i++ ) {

                strcpy( szFile, rgszDosPath[i] );
                if ( szFile[strlen(szFile)-1] != '\\' ) {
                    strcat( szFile, "\\" );
                }
                szEnd = szFile + strlen(szFile);
                strcat( szFile, WIN_COM );

                if ( FFileExist( szFile ) ) {
                    *szEnd = '\0';
                    strcpy( ReturnBuffer, szFile );
                    fOkay = fTrue;
                    break;
                }
            }

            RgszFree( rgszDosPath );

            if ( !fOkay ) {
                strcpy( ReturnBuffer, WIN_PTH_NONE );
                fOkay = fTrue;
            }
        }

        SFree( szDosPath );
    }

    if ( fOkay ) {
        return lstrlen( ReturnBuffer )+1;
    } else {
        return 0;
    }
}




// ***************************************************************************
//
//                  COMMON SUBROUTINES
//
// ***************************************************************************

//
//  Determine if the specified file is present.
//

BOOL
FFileExist(
    IN  LPSTR  szFile
    )
{
    DWORD   Attr;

    Attr = GetFileAttributes( szFile );

    return  ((Attr != -1) && !(Attr & FILE_ATTRIBUTE_DIRECTORY ));

}

//
// File Size
//


DWORD
FileSize(
    SZ szFile
    )
{
    DWORD Size = 0xFFFFFFFF;
    FILE* f;

    if( f = fopen( szFile, "r" ) ) {
        if( !fseek( f, 0L, SEEK_END ) ) {
            Size = (DWORD) ftell( f ) ;
        }
        fclose( f );
    }
    return ( Size );
}


//
// BUGBUG** Following code has been removed because it is no longer needed
// It is still being kept in the file till it is determined that it
// is definitely not needed
//

#if 0


#define MAX_CONFIG_SIZE  1024

BOOL
FixConfigFileMacroChar(
    SZ   szConfigFile,
    CHAR cReplaceChar,
    SZ   szSystemDir
    )
{

    CHAR   Buffer [MAX_CONFIG_SIZE];
    DWORD  len,i;
    DWORD  BytesRead,BytesWritten;
    HANDLE hfile;

    hfile = CreateFile(
                szConfigFile,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (hfile == INVALID_HANDLE_VALUE) {
        SetErrorText(IDS_ERROR_OPENFAIL);
        return FALSE;
    }


    if (!ReadFile(hfile, Buffer, MAX_CONFIG_SIZE, &BytesRead, NULL)){
        CloseHandle (hfile);
        SetErrorText( IDS_ERROR_READFAILED );
        return FALSE;
    }

    if (BytesRead == MAX_CONFIG_SIZE) {
        CloseHandle (hfile);
        SetErrorText( IDS_ERROR_READFAILED );
        return FALSE;
    }

    SetFilePointer (
        hfile,
        0,
        NULL,
        FILE_BEGIN
        );

    len = strlen (szSystemDir);

    for (i=0; i < BytesRead; i++) {
        if (Buffer [i] != cReplaceChar){
            WriteFile (
                hfile,
                &Buffer[i],
                1,
                &BytesWritten,
                NULL
                );
        }
        else {
            WriteFile (
                   hfile,
                   szSystemDir,
                   len,
                   &BytesWritten,
                   NULL
                   );
        }
    }

    CloseHandle (hfile);
    return TRUE;
}



// ***************************************************************************
//
//                  DOS AUTOEXEC.BAT ROUTINES
//
// ***************************************************************************

//
//  copy a DOS batch file REMing out any line that is not a
//  SET or a PATH command
//
//  szSrc: Source batch file      (DOS    c:\autoexec.bat )
//  szDst: Destination batch file (NT VDM c:\autoexec.nt  )

BOOL
FilterDosBatchFile(
    LPSTR szSrc,
    LPSTR szDst,
    LPSTR szTemplate
    )
{
    TEXTFILE    SrcText, TemplateText;
    FILE*       f;
    BOOL        bStatus = TRUE;
    SZ          szLine;
    CHAR        Buffer[ MAX_PATH ];

    //
    // Open the destination file for write access
    //

    if (FFileExist( szDst )) {
        bStatus = SetFileAttributes ( szDst, FILE_ATTRIBUTE_NORMAL );
        if (bStatus) {
              bStatus = DeleteFile( szDst );
        }
    }

    if(!bStatus) {
        SetErrorText(IDS_ERROR_WRITE);
        return( FALSE );
    }

    if ( !(f = fopen( szDst, "w" )) ) {
        SetErrorText(IDS_ERROR_OPENFAIL);
        return( FALSE );
    }


    //
    //  Open source file
    //

    if ( FFileExist( szSrc ) &&
         TextFileOpen( szSrc, &SrcText ) ) {

        SZ TempBuffer = " @echo off\n";

        //
        // First put an echo off command here
        //

        fputs( TempBuffer, f );

        //
        // Then migrate the existing batch file
        //

        bStatus = DosBatchFilter( &SrcText, f );
        TextFileClose( &SrcText );
    }

    if(!bStatus) {
        fclose( f );
        return( FALSE );
    }

    //
    // Now add on the default autoexec file from the template file
    //

    if ( !TextFileOpen( szTemplate, &TemplateText ) ) {
        SetErrorText(IDS_ERROR_OPENFAIL);
        return( FALSE );
    }

    while ( TextFileReadLine( &TemplateText ) ) {

        szLine  = TextFileGetLine( &TemplateText );
        sprintf( Buffer, " %s\n", szLine );
        fputs( Buffer, f );
    }

    TextFileClose( &TemplateText );
    fclose( f );
    return( fTrue );
}


BOOL
DosBatchFilter(
    IN OUT  TEXTFILE *  SrcText,
    IN OUT  FILE*       f
    )
{
    SZ      szLine;
    SZ      sz;
    CHAR    Buffer[ MAX_PATH ],*temp;
    size_t  Idx;



    while ( TextFileReadLine( SrcText ) ) {

        szLine  = TextFileGetLine( SrcText );
        sz      = TextFileSkipBlanks( szLine );


        //
        //  If blank line, ignore it
        //
        if ( !sz || *sz == '\0'  || *sz == EOF ) {
            // fputs( " \n", f );
            // fprintf( f, "\n" );
            continue;
        }


        //
        //  If this is a comment line, a SET or a PATH command, we
        //  write it verbatim, otherwise we REM it out
        //

        //
        //  If "no echo" command, skip the '@'
        //
        if ( *sz == '@' ) {
            sz++;
        }

        Idx = strcspn( sz, " \t" );
        if ( Idx <= strlen(sz) ) {

            memcpy( Buffer, sz, Idx );
            Buffer[Idx] = '\0';

            if ( !_strcmpi( Buffer, "SET" ) ) {

                // special hack to take out comspec line. we dont need
                // this one for nt dos.

                temp = &sz[Idx+1];            // point after set

                // skip blanks

                while (*temp && (*temp == ' ' || *temp == '\t')) {
                    temp++;
                }

                if (*temp == '\0') {
                    continue;
                }

                if (_strnicmp (temp,"comspec",7) == 0) {     // ignore comspec
                    continue;
                }

                //
                //  SET line, copy verbatim
                //
                sprintf( Buffer, " %s\n", szLine );
                fputs( Buffer, f );
                //fprintf( f, "%s\n", szLine );
                continue;

            } else if ( !_strcmpi( Buffer, "PATH" ) ) {

                //
                //  PATH line, copy verbatim
                //
                sprintf( Buffer, " %s\n", szLine );
                fputs( Buffer, f );
                //fprintf( f, "%s\n", szLine );
                continue;

            } else {

                //
                //  Any other, ignore
                //
                // sprintf( Buffer, " REM %s\n", szLine );
                // fputs( Buffer, f );
                // fprintf( f, "REM %s\n", szLine );
                continue;

            }
        }
    }

    return fTrue;
}



// ***************************************************************************
//
//                  Windows Ini File Migration
//
// ***************************************************************************




BOOL
MigrateWinIniWorker(
    LPSTR szWin31Dir
    )
{
    CHAR szPath[ MAX_PATH ];
    CHAR szWindowsDir[ MAX_PATH ];
    BOOL bStatus = FALSE;

    //
    // Check validity of windows directory
    //

    if ( !lstrcmpi( szWin31Dir, "" ) ) {
        return ( TRUE );
    }

    lstrcpy( szPath, szWin31Dir );
    lstrcat( szPath, WIN_COM );
    if ( !FFileExist( szPath ) ) {
        return( TRUE );
    }

    //
    // Initialize local variables
    //

    if( !GetWindowsDirectory( szWindowsDir, MAX_PATH ) ) {
        // BUGBUG -- Some error here
        return( FALSE );
    }
    lstrcat ( szWindowsDir, "\\" );

    //
    // If win31 directory and NT windows directory the same then we don't
    // have to do anything
    //

    if( !lstrcmpi( szWin31Dir, szWindowsDir ) ) {
        return( TRUE );
    }

    //
    // INI FILE MIGRATION:
    // -------------------
    // We will copy over any ini files found in the win31 directory over
    // to the NT Windows directory.  standard ini files that ship with win31 are
    // copied over under alternate names so that when we access these with
    // profile api, these do not map to the registry. Then we will use
    // private profile api to migrate information selectively from the
    // standard set to the nt ini files.  Lastly the win3.1 win.ini is search
    // for sections which do not ship with the default win.ini and these
    // sections are transferred over to the NT win.ini useing private profile
    // api
    //



    //
    // Locate all ini files and copy over ini files from win31 directory to
    // nt windows directory
    //

    if( !FFindAndCopyIniFiles( szWin31Dir, szWindowsDir ) ) {
        goto cleanup;
    }

    //
    // Migrate over all information we need to from infs in standard set
    //

    if( !FMigrateStandardIniData( szWindowsDir ) ) {
        goto cleanup;
    }

    //
    // Go through win.ini using Rtl routines and migrate information to
    // our win.ini
    //

    if( !FMigrateWinIniAppSections( szWindowsDir ) ) {
        goto cleanup;
    }

    //
    // Do Ini cleanup where all the temporary ini files that were
    //

    bStatus = TRUE;
cleanup:
    CleanupIniFiles( szWindowsDir );
    return ( bStatus );
}


BOOL
FFindAndCopyIniFiles(
    SZ szSrcDir,
    SZ szDstDir
    )
{
    HANDLE hff;
    CHAR szFindFile[ MAX_PATH ];
    CHAR szSrcFile[ MAX_PATH ];
    CHAR szDstFile[ MAX_PATH ];
    WIN32_FIND_DATA FindFileData;


    //
    // Do find first, find next search and copy over any infs found which
    // are not in the standard set under the same name and any under the
    // standard set with a tmp extenstion
    //

    lstrcpy( szFindFile, szSrcDir );
    lstrcat( szFindFile, "*.ini" );

    if ((hff = FindFirstFile( szFindFile, &FindFileData )) != (HANDLE)-1) {

        do {
            SZ sz;

            lstrcpy( szSrcFile, szSrcDir );
            lstrcat( szSrcFile, (SZ)FindFileData.cFileName );
            lstrcpy( szDstFile, szDstDir );

            if ( sz = SzMapStandardIni( (SZ)FindFileData.cFileName ) ) {
                if( !lstrcmpi( sz, "" ) ) {
                    continue;
                }
                lstrcat( szDstFile, sz );
            }
            else {
                lstrcat( szDstFile, (SZ)FindFileData.cFileName );
            }

            if( FFileExist( szDstFile ) ) {
                SetFileAttributes ( szDstFile, FILE_ATTRIBUTE_NORMAL );
                DeleteFile( szDstFile );
            }

            if (!CopyFile( szSrcFile, szDstFile, FALSE )) {
                SetErrorText(IDS_ERROR_COPYFILE);
                FindClose( hff );
                return( FALSE );
            }

        }
        while (FindNextFile(hff, &FindFileData));

        FindClose( hff );
    }

    return ( TRUE );
}

//
// The following is the data the migration routines work off
//

typedef struct _inifilenames {
    SZ szIniFileName;
    SZ szIniTmpFileName;
    } INIFILENAMES;

INIFILENAMES IniList[] = {
                {"win.ini"     , "win.tmp"     },
                {"system.ini"  , ""            },
                {"mouse.ini"   , ""            },
                {"winfile.ini" , ""            },
                {"control.ini" , ""            },
                {"msd.ini"     , ""            },
                {"dosapp.ini"  , ""            },
                {"progman.ini" , ""            }
            };

INT nIniList = sizeof(IniList) / sizeof( INIFILENAMES ) ;

typedef struct _inimigratedata {
    SZ szSrcIniFile;
    SZ szSrcSection;
    SZ szSrcKey;
    SZ szDstIniFile;
    SZ szDstSection;
    SZ szDstKey;
    } INIMIGRATEDATA;

INIMIGRATEDATA IniMigrateList[] = {
    {"win.tmp",    "windows",  "NullPort"         ,   "win.ini", "windows",  "NullPort"         },
    };

INT nIniMigrateList = sizeof( IniMigrateList ) / sizeof( INIMIGRATEDATA );


//
// BUGBUG ** Post BETA enumerate them from the registry
//

SZ WinIniStandardSections[] = {
       "windows"           ,
       "Desktop"           ,
       "intl"              ,
       "ports"             ,
       "Sounds"            ,
       "Compatibility"     ,
       "fonts"             ,
       "Network"           ,
       "Windows Help"      ,
       "spooler"           ,
       "MS Proofing Tools" ,
       "devices"           ,
       "Winlogon"          ,
       "Console"           ,
       "Extensions"        ,
       "MCI Extensions"    ,
       "Clock"             ,
       "Terminal"          ,
       "FontSubstitutes"   ,
       "FontCache"         ,
       "TrueType"          ,
       "Colors"            ,
       "Sounds"            ,
       "MMDEBUG"           ,
       NULL
       };

//
// Migration worker routines
//

BOOL
FMigrateStandardIniData(
    SZ szWindowsDir
    )
{
    CHAR szValue[ MAX_PATH ];
    CHAR szSrcFile[ MAX_PATH ];


    INT i;

    for( i = 0; i < nIniMigrateList; i++ ) {
        lstrcpy( szSrcFile, szWindowsDir );
        lstrcat( szSrcFile, IniMigrateList[i].szSrcIniFile );

        if( FFileExist( szSrcFile ) &&
            GetPrivateProfileString(
                IniMigrateList[i].szSrcSection,
                IniMigrateList[i].szSrcKey,
                "",
                (LPSTR)szValue,
                (DWORD)MAX_PATH,
                szSrcFile
                ) ) {

            if( !WritePrivateProfileString(
                     IniMigrateList[i].szDstSection,
                     IniMigrateList[i].szDstKey,
                     szValue,
                     IniMigrateList[i].szDstIniFile
                     ) ) {
                //
                // BUGBUG .. what do we do here .. do we quit or do
                // we continue
                //

                KdPrint(("SETUPDLL: Failed to migrate ini entry."));
            }
        }
    }
    return ( TRUE );
}


BOOL
FMigrateWinIniAppSections(
    SZ szWindowsDir
    )
{
    CHAR        szConfig[ MAX_PATH ];
    CHAR        szSection[ MAX_PATH ];
    TEXTFILE    SrcText;
    SZ          szLine;
    SZ          sz, szEnd;
    DWORD       dwSize;

    #define MAX_SECTION_BUFFER 10 * 1024
    PVOID       Buffer;

    lstrcpy( szConfig, szWindowsDir );
    lstrcat( szConfig, "win.tmp" );

    //
    //  Open source file
    //

    if ( FFileExist( szConfig ) &&
         TextFileOpen( szConfig, &SrcText ) ) {

        //
        // Allocate section buffer
        //

        if ( !(Buffer = SAlloc((CB) MAX_SECTION_BUFFER))) {
            TextFileClose(&SrcText);
            SetErrorText(IDS_ERROR_DLLOOM);
            return( FALSE );
        }

        //
        // Process config file, line by line
        //

        while ( TextFileReadLine( &SrcText ) ) {

            szLine  = TextFileGetLine( &SrcText );
            sz      = TextFileSkipBlanks( szLine );


            //
            //  If first character not [ get next line
            //

            if ( !sz || *sz != '[' ) {
                continue;
            }

            sz++;
            szEnd = strchr( sz, ']' );
            if ( szEnd ) {

                dwSize = szEnd - sz;
                if ( dwSize > MAX_PATH ) {
                    continue;
                }

                memcpy( szSection, sz, dwSize );
                *(szSection + dwSize) = '\0';

                //
                // If section name one of standard set ignore
                //

                if( FIsStandardWinIniSection( szSection ) ) {
                    continue;
                }

                //
                // Read the entire section corresponding to the section
                // from the source file and transfer it to the destination
                // file using profile api
                //

                if( GetPrivateProfileSection(
                        szSection,
                        (LPSTR)Buffer,
                        MAX_SECTION_BUFFER,
                        szConfig
                        ) ) {

                    if (!WriteProfileSection( szSection, Buffer ) ) {
                        // BUGBUG Do we quit here??
                        KdPrint(("SETUPDLL: Failed to migrate ini section."));
                    }
                }


            }


        }
        SFree( Buffer );
        TextFileClose(&SrcText);
    }

    return ( TRUE );
}



SZ
SzMapStandardIni(
    SZ szIniFile
    )
{
    INT i;

    for ( i = 0; i < nIniList; i++ ) {

        if( !lstrcmpi(szIniFile, IniList[i].szIniFileName ) ) {
            return( IniList[i].szIniTmpFileName );
        }
    }

    return( NULL );
}


VOID
CleanupIniFiles(
    SZ szWindowsDir
    )
{
    CHAR szFile[ MAX_PATH ];

    INT i;

    for ( i = 0; i < nIniList; i++ ) {
        if ( lstrcmpi( IniList[i].szIniTmpFileName, "" ) ) {

            lstrcpy( szFile, szWindowsDir );
            lstrcat( szFile, IniList[i].szIniTmpFileName );

            if( FFileExist( szFile ) ) {
                SetFileAttributes ( szFile, FILE_ATTRIBUTE_NORMAL );
                DeleteFile( szFile );
            }

        }
    }

    return;

}

BOOL
FIsStandardWinIniSection(
    SZ szSection
    )
{
    PSZ psz;

    psz = WinIniStandardSections;
    while ( *psz ) {
        if( !lstrcmpi( *psz++, szSection ) ) {
            return ( TRUE );
        }
    }
    return( FALSE );

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\winhelp.c ===
#include "precomp.h"
#pragma hdrstop

// Globals to this module.

BOOL  bHelpActive   = fFalse;
//SZ    szHelpFile     = NULL;
//DWORD dwLowContext   = 0;
//DWORD dwHighContext  = 0;
//DWORD dwHelpIndex    = 0;
//BOOL  bHelpIsIndexed = fFalse;



BOOL
FInitWinHelpFile(
    HWND hWnd,
    SZ   szHelpFileName,
    SZ   szLowContext,
    SZ   szHiContext,
    SZ   szHelpIndex OPTIONAL
    )
{

    //
    // Check the parameters
    //
    AssertRet ( hWnd           != (HWND)NULL &&
                szHelpFileName != (SZ)NULL   &&
                szLowContext   != (SZ)NULL   &&
                szHiContext    != (SZ)NULL ,
                fFalse );

    //
    // Check if there is another help file active and close it
    //

    FCloseWinHelp(hWnd);

    //
    // Store the parameters passed in
    //

    pLocalContext()->dwLowContext   = atoi ( szLowContext );
    pLocalContext()->dwHighContext  = atoi ( szHiContext );

    if ( pLocalContext()->dwHighContext < pLocalContext()->dwLowContext ) {
        return ( fFalse );
    }

    while ((pLocalContext()->szHelpFile = SzDupl(szHelpFileName )) == (SZ)NULL) {
        if (!FHandleOOM(hWnd)) {
           return(fFalse);
        }
    }

    if ( szHelpIndex != (SZ)NULL ) {
        pLocalContext()->bHelpIsIndexed  = fTrue;
        pLocalContext()->dwHelpIndex     = atoi ( szHelpIndex );
    }
    else {
        pLocalContext()->bHelpIsIndexed  = fFalse;
    }

    return ( fTrue );
}




BOOL
FCloseWinHelp(
    HWND hWnd
    )
{

    AssertRet ( hWnd != (HWND)NULL, fFalse );

    //
    // Find out if Help active and close the help file
    //

    if ( bHelpActive && pLocalContext()->szHelpFile != (SZ)NULL ) {
        WinHelp( hWnd, pLocalContext()->szHelpFile, HELP_QUIT, 0L );
    }
    bHelpActive = fFalse;


    //
    // Free the helpfile string and clear the bHelpIsIndexed field
    //

    if ( pLocalContext()->szHelpFile != (SZ) NULL ) {
        SFree( pLocalContext()->szHelpFile );
        pLocalContext()->szHelpFile     = NULL;
        pLocalContext()->bHelpIsIndexed = fFalse;
    }

    return ( fTrue );

}




BOOL
FProcessWinHelp(
    HWND  hWnd
    )
{
    SZ    szHelpContext;
    DWORD dwHelpContext;

    AssertRet ( hWnd != (HWND)NULL, fFalse );

    //
    // Check if winhelp file available
    //

    if ( pLocalContext()->szHelpFile == (SZ)NULL ) {
        return ( fFalse );
    }

    //
    // Find the help context
    //

    if ((szHelpContext = SzFindSymbolValueInSymTab("HelpContext")) == (SZ)(NULL)) {
        return ( fFalse );
    }

    dwHelpContext = atoi ( szHelpContext );


    //
    // Validate it, see that it is within the two lo and hi contexts.
    //

    if ( dwHelpContext  < pLocalContext()->dwLowContext  ||
         dwHelpContext  > pLocalContext()->dwHighContext    ) {
        return ( fFalse );
    }

    //
    // Call Winhelp and set help active
    //

    bHelpActive = WinHelp(
                      hWnd,
                      pLocalContext()->szHelpFile,
                      HELP_CONTEXT,
                      dwHelpContext
                      );

    if ( !bHelpActive ) {
        WinHelp( hWnd, pLocalContext()->szHelpFile, HELP_QUIT, 0L );
        return ( fFalse );
    }

    if ( pLocalContext()->bHelpIsIndexed == fTrue ) {

        WinHelp(
            hWnd,
            pLocalContext()->szHelpFile,
            HELP_SETINDEX,
            pLocalContext()->dwHelpIndex
            );
    }

    return ( fTrue );

}


BOOL
FProcessWinHelpMenu(
    HWND  hWnd,
    WORD  idcMenu
    )
{

    AssertRet ( hWnd != (HWND)NULL && idcMenu != 0, fFalse );

    //
    // Check if winhelp file available
    //

    if ( pLocalContext()->szHelpFile == (SZ)NULL ) {
        return ( fFalse );
    }

    switch ( idcMenu ) {

    case MENU_HELPINDEX:

        if ( pLocalContext()->bHelpIsIndexed == fTrue ) {

            bHelpActive = WinHelp(
                              hWnd,
                              pLocalContext()->szHelpFile,
                              HELP_CONTEXT,
                              pLocalContext()->dwHelpIndex
                              );
        }
        else {

            bHelpActive = WinHelp(
                              hWnd,
                              pLocalContext()->szHelpFile,
                              HELP_INDEX,
			      0
                              );
        }

        break;

    case MENU_HELPSEARCH:

        bHelpActive = WinHelp(
                          hWnd,
                          pLocalContext()->szHelpFile,
                          HELP_PARTIALKEY,
                          (ULONG_PTR)""
                          );
        break;

    case MENU_HELPONHELP:

        bHelpActive = WinHelp(
                          hWnd,
                          pLocalContext()->szHelpFile,
                          HELP_HELPONHELP,
                          0
                          );

    default:

        return ( fFalse );

    }


    if ( !bHelpActive ) {
        WinHelp( hWnd, pLocalContext()->szHelpFile, HELP_QUIT, 0L );
        return ( fFalse );
    }

    if ( pLocalContext()->bHelpIsIndexed == fTrue ) {

        WinHelp(
            hWnd,
            pLocalContext()->szHelpFile,
            HELP_SETINDEX,
            pLocalContext()->dwHelpIndex
            );
    }

    return ( fTrue );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_comstf.h ===
/*************************************************/
/* Common Library Component private include file */
/*************************************************/


BOOL InfIsOpen(VOID);

#define PreCondInfOpen(r)    PreCondition(InfIsOpen(),r)


/*	INF internal limits
*/
#define cSectionsMax  0x1000
#define cKeysMax      0x1000
#define cchpFieldMax  0x2000
#define cchpBig       ((CCHP)cbAllocMax)
#define cchpSmall     ((CCHP)4*1024)



extern BOOL  APIENTRY FFindFirstInfSection(VOID);
extern BOOL  APIENTRY FFindNextInfSection(VOID);
extern BOOL  APIENTRY FValidSectionLabel(VOID);
extern BOOL  APIENTRY FListValue(SZ);

#define SzSkipField(ch, f) SzSkipFieldFromLine(ch,fFalse,f)

#define SzGetField(ch)     SzSkipFieldFromLine(ch,fTrue,fFalse)



/*
**	Symbol Table Entry structure
**
**	Fields:
**		psteNext: next STE in linked list.
**		szSymbol: zero terminated symbol string - non-NULL and non-empty.
**		szValue:  zero terminated value string - non-NULL.
*/
typedef struct _ste
	{
	struct _ste * psteNext;
	SZ            szSymbol;
	SZ            szValue;
	}  STE;

/*	Symbol Table Entry datatypes
*/
typedef  STE *  PSTE;
typedef  PSTE * PPSTE;

/*  Number of STE structs in each STEB
*/
#define cStePerSteb 0x07FF


/*
**	Symbol Table Entry Block structure
**
**	Fields:
**		pstebNext: next STEB in linked list.
**		rgste[]:   array of allocated STE structs.
*/
typedef struct _steb
	{
	struct _steb * pstebNext;
	STE            rgste[cStePerSteb];
	}  STEB;

/*	Symbol Table Entry Block datatypes
*/
typedef  STEB *  PSTEB;


/*	Number of hash buckets in symbol hash table (must be a power of 2)
*/
#define cHashBuckets 255

/*	Number of bytes used in hash function for finding a symbol
*/
#define cbBytesToSumForHash ((CB)25)       // effectively all chars are used




//
//  Symbol table
//
typedef struct _SYMTAB *PSYMTAB;

typedef struct _SYMTAB {
    PSTE        HashBucket[cHashBuckets];   //  Hash Buckets
#ifdef SYMTAB_STATS
    UINT        BucketCount[cHashBuckets];  //  Bucket count in hash table
#endif
} SYMTAB;



extern PSTE  psteUnused;
extern PSTEB pstebAllocatedBlocks;

extern PSTE         APIENTRY PsteAlloc(VOID);
extern BOOL         APIENTRY FFreePste(PSTE);
extern USHORT       APIENTRY UsHashFunction(PB);
extern PPSTE        APIENTRY PpsteFindSymbol(PSYMTAB, SZ);
extern BOOL         APIENTRY FAddSymbolFromInfLineToSymTab(INT Line);

extern PSYMTAB      APIENTRY SymTabAlloc(VOID);
extern BOOL         APIENTRY FFreeSymTab(PSYMTAB);
extern BOOL         APIENTRY FCheckSymTab(PSYMTAB);



extern BOOL    APIENTRY FValidFATPathChar(CHP);




#define PreCondFlowInit(r)   PreCondition(psptFlow!=(PSPT)NULL,r)


/*
**	Evaluation Return Code datatype
*/
typedef unsigned ERC;           // 1632 was USHORT

#define ercError 0
#define ercTrue  1
#define ercFalse 2


/*
**	Evaluate Compare Mode datatype
*/
typedef USHORT ECM;

#define ecmError       0
#define ecmIfStr       1
#define ecmIfStrI      2
#define ecmIfInt       3
#define ecmIfContains  4
#define ecmIfContainsI 5

extern BOOL  APIENTRY FSkipToElse(INT *Line,HWND hwndParent);
extern BOOL  APIENTRY FSkipToEnd(INT *Line,HWND hwndParent);
extern ERC   APIENTRY ErcEvaluateCompare(HWND, ECM, SZ, SZ, SZ);


  /* Stack Element For Loop */
typedef struct _sefl
	{
	struct _sefl * pseflNext;
    UINT           iStartLine;
	RGSZ           rgszList;
    UINT           iItemCur;
	SZ             szDollarSav;
	SZ             szPoundSav;
	}  SEFL;

 typedef SEFL *  PSEFL;
 typedef PSEFL * PPSEFL;

extern PSEFL pseflHead;

extern PSEFL  APIENTRY PseflAlloc(VOID);
extern BOOL   APIENTRY FFreePsefl(PSEFL);
extern BOOL   APIENTRY FSkipToEndOfLoop(INT *Line,HWND hwndParent);
extern BOOL   APIENTRY FInitForLoop(INT *Line,HWND hwndParent,SZ List);
extern BOOL   APIENTRY FContinueForLoop(INT *Line,HWND hwndParent);

extern SZ     APIENTRY SzProcessSz(HWND, SZ);

extern BOOL fSilentSystem;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_infdbg.h ===
#ifndef _INFDBG_
#define _INFDBG_

#if DEVL

VOID
SdAtNewLine(
    IN UINT Line
    );

VOID
SdTracingOn(
    VOID
    );

VOID
SdBreakNow(
    VOID
    );

#else

#define SdInit()
#define SdAtNewLine(Line)
#define SdTracingOn()
#define SdBreakNow()

#endif // DEVL

BOOL
SdpReconstructLine(
    IN  PINFLINE MasterLineArray,
    IN  UINT     MasterLineCount,
    IN  UINT     Line,
    OUT PUCHAR   Buffer,
    IN  UINT     BufferSize
    );

#endif // def _INFDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_filecm.h ===
/* File: _filecm.h */
/**************************************************************************/
/*      Install: File commands local header.
/**************************************************************************/



/*
**      CopyFile Limits
*/
#define cbCopyBufMax  (64*1021)
typedef BOOL                RO;
#define fOn                     fTrue
#define fOff            fFalse

extern BOOL fUserQuit;


/*
**      Read-Only Return Code
*/
typedef  unsigned  YNRC;        // 1632 -- was USHORT
#define ynrcNo     0
#define ynrcYes    1
#define ynrcErr1   2
#define ynrcErr2   3
#define ynrcErr3   4
#define ynrcErr4   5
#define ynrcErr5   6
#define ynrcErr6   7
#define ynrcErr7   8
#define ynrcErr8   9
#define ynrcErr9  10

typedef USHORT   CFRC;
#define cfrcFailure (0)
#define cfrcSuccess (1)
#define cfrcCancel  (2)

#ifdef UNUSED
extern BOOL  APIENTRY FBackupSectFile(SZ, PSFD);
extern BOOL  APIENTRY FRemoveSectFile(SZ, PSFD);
#endif // UNUSED

extern BOOL  APIENTRY FCopyListFile(HANDLE, PCLN, PSDLE, LONG);

extern BOOL  APIENTRY FBuildFullSrcPath(SZ, SZ, SZ, SZ);
extern BOOL  APIENTRY FBuildFullDstPath(SZ, SZ, PSFD, BOOL);
extern BOOL  APIENTRY FBuildFullBakPath(SZ, SZ, PSFD);
extern SZ        APIENTRY SzFindFileFromPath(SZ);
extern SZ        APIENTRY SzFindExt(SZ);
extern BOOL  APIENTRY FFileFound(SZ);
extern YNRC  APIENTRY YnrcFileReadOnly(SZ);
extern BOOL  APIENTRY FSetFileReadOnlyStatus(SZ, BOOL);
extern YNRC  APIENTRY YnrcBackupFile(SZ, SZ, PSFD);
extern YNRC  APIENTRY YnrcNewerExistingFile(USHORT, SZ, DWORD, DWORD);
extern BOOL  APIENTRY FGetFileVersion(SZ, DWORD *, DWORD *);
extern BOOL  APIENTRY FYield(VOID);
extern YNRC  APIENTRY YnrcEnsurePathExists(SZ, BOOL, SZ);
extern SZ    APIENTRY FRenameActiveFile(SZ);


extern BOOL  APIENTRY FGetCopyListCost(SZ, SZ, SZ, SZ, SZ, SZ, SZ, SZ);
extern BOOL  APIENTRY FSetupGetCopyListCost(SZ, SZ, SZ);

extern BOOL  APIENTRY FParseSharedAppList(SZ);
extern BOOL  APIENTRY FInstallSharedAppList(SZ);
extern SZ    APIENTRY SzFindNthIniField(SZ, INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_shell.h ===
/************************************************/
/***** Shell Component private include file *****/
/************************************************/

#define  cchpBufTmpLongMax   255
#define  cchpBufTmpLongBuf   (cchpBufTmpLongMax + 1)
#define  cchpBufTmpShortMax   63
#define  cchpBufTmpShortBuf  (cchpBufTmpShortMax + 1)


//
// Exit_Code values
//

#define SETUP_ERROR_SUCCESS    0
#define SETUP_ERROR_USERCANCEL 1
#define SETUP_ERROR_GENERAL    2


//
//  ShellCode values
//

#define SHELL_CODE_OK                   0
#define SHELL_CODE_NO_SUCH_INF          1
#define SHELL_CODE_NO_SUCH_SECTION      2
#define SHELL_CODE_ERROR                3


extern HANDLE hInst;
extern HWND   hWndShell;
extern HWND   hwParam;   // Top-level window provided by cmd line or NULL
extern HWND   hwPseudoParent ; // Window to use to center dialogs

#ifdef UNUSED
extern HWND   hWndRTF;
#endif // UNUSED

extern HWND   hWndInstr;
extern HWND   hWndExitB;
extern HWND   hWndHelpB;

// extern SZ     szShlScriptSection;


extern CHP    rgchBufTmpLong[cchpBufTmpLongBuf];
extern CHP    rgchBufTmpShort[cchpBufTmpShortBuf];

//
// ParseCmdLine returns the following codes
//

#define CMDLINE_SUCCESS   0
#define CMDLINE_ERROR     1
#define CMDLINE_SETUPDONE 2
extern INT    ParseCmdLine(HANDLE, SZ, PSZ, PSZ, PSZ, PSZ, INT *);


BOOL CreateShellWindow(HANDLE,INT,BOOL);
extern VOID   FDestroyShellWindow(VOID);
extern VOID   FFlashParentWindow ( BOOL On ) ;
extern BOOL   FInitApp(HANDLE, SZ, SZ, SZ, SZ, INT);
extern BOOL   FInterpretNextInfLine(WPARAM, LPARAM);                     // 1632

#ifdef UNUSED
extern BOOL    APIENTRY  FInitSysCD(PSDLE, SZ, SZ, BOOL);
#endif // UNUSED

extern LRESULT APIENTRY  ShellWndProc(HWND, UINT, WPARAM, LPARAM);       // 1632
extern VOID              PreexitCleanup();

VOID
ControlTerm(
    VOID
    );

//
// Hook Related externals
//

extern DWORD   APIENTRY  HookKeyFilter(INT nCode,LONG wParam,LONG lParam);
extern BOOL              FInitHook(VOID);
extern BOOL              FTermHook(VOID);

//
// Default dialog procedure initialisation
//
BOOL
DlgDefClassInit(
    IN HANDLE hInst,
    IN BOOL   Init
    );

extern BOOL              FVirCheck(HANDLE);


extern SCP    rgscp[];
extern PSPT   psptShellScript;
extern INT    dyChar;
extern INT    dxChar;

  /* for String Parsing Table */
#define spcError            0
#define spcUnknown          1
#define spcInstall          2
#define spcUI               3
#define spcDetect           4
#define spcReadSyms         5
#define spcUpdateInf        6
#define spcWriteInf         7
#define spcExit             8
#define spcWriteSymTab      9
#define spcSetTitle        10
#define spcInitSys         11
#define spcInitSysNet      12
#define spcProfileOn       13
#define spcProfileOff      14
#define spcExitAndExec     15
#define spcEnableExit      16
#define spcDisableExit     17
#define spcShell           18
#define spcReturn          19

#define IDC_CDOKAY               900
#define IDC_CDCANCEL             901
#define IDC_CDNAME               902
#define IDC_CDORG                903

#define IDM_ABOUT          101

#define IDI_STF_ICON    147

//
// Mode fields in the setup command line:
//
// /G : Gui Initial Setup
// /N : Setup To Share      <-- no longer supported!
//
// Otherwise normal
//

#define wModeSetupNormal       0
#define wModeGuiInitialSetup   1
#if 0
#define wModeSetupToShare      2
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_log.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    _log.h

Abstract:

    Function prototypes for restore diskette file logging and
    related activities, such as checksum computation.

Author:

    Ted Miller (tedm) 30-April-1992

Revision History:

--*/




VOID
InitRestoreDiskLogging(
    IN BOOL StartedByCommand
    );


VOID
LogOneFile(
    IN PCHAR SrcFullname,
    IN PCHAR DstFullname,
    IN PCHAR DiskDescription,
    IN ULONG Checksum,
    IN PCHAR DiskTag,
    IN BOOL  ThirdPartyFile
    );

VOID
RestoreDiskLoggingDone(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\i386\bootini.c ===
#include "precomp.h"
#pragma hdrstop

//
// x86 version (that deals with boot.ini) as opposed to arc
// version, that dceals with nvram (that routine is in the portable directory).
//

#ifdef _X86_

BOOL
FChangeBootIniTimeout(
    IN INT Timeout
    )
{
    CHP BOOTINI[]    = "C:\\boot.ini";
    HFILE hfile;
    ULONG FileSize;
    PUCHAR buf = NULL,p1,p2;
    BOOL b;
    CHAR TimeoutLine[256];

    sprintf(TimeoutLine,"timeout=%u\r\n",Timeout);

    //
    // Open and read boot.ini.
    //

    b = FALSE;
    hfile = _lopen(BOOTINI,OF_READ);
    if(hfile != HFILE_ERROR) {

        FileSize = _llseek(hfile,0,2);
        if(FileSize != (ULONG)(-1)) {

            if((_llseek(hfile,0,0) != -1)
            && (buf = SAlloc(FileSize+1))
            && (_lread(hfile,buf,FileSize) != (UINT)(-1)))
            {
                buf[FileSize] = 0;
                b = TRUE;
            }
        }

        _lclose(hfile);
    }

    if(!b) {
        if(buf) {
            SFree(buf);
        }
        return(FALSE);
    }

    if(!(p1 = strstr(buf,"timeout"))) {
        SFree(buf);
        return(FALSE);
    }

    if(p2 = strchr(p1,'\n')) {
        p2++;       // skip NL.
    } else {
        p2 = buf + FileSize;
    }

    SetFileAttributes(BOOTINI,FILE_ATTRIBUTE_NORMAL);

    hfile = _lcreat(BOOTINI,0);
    if(hfile == HFILE_ERROR) {
        SFree(buf);
        return(FALSE);
    }

    //
    // Write:
    //
    // 1) the first part, start=buf, len=p1-buf
    // 2) the timeout line
    // 3) the last part, start=p2, len=buf+FileSize-p2
    //

    b =  ((_lwrite(hfile,buf        ,p1-buf             ) != (UINT)(-1))
      &&  (_lwrite(hfile,TimeoutLine,strlen(TimeoutLine)) != (UINT)(-1))
      &&  (_lwrite(hfile,p2         ,buf+FileSize-p2    ) != (UINT)(-1)));

    _lclose(hfile);
    SFree(buf);

    //
    // Make boot.ini archive, read only, and system.
    //
    SetFileAttributes(
        BOOTINI,
        FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE
        );

    return(b);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_uilstf.h ===
/**********************************************/
/* user interface library function prototypes */
/**********************************************/


/*
**	Dialog Box Context Block structure
*/
typedef struct _dbcb
	{
	SZ             szDlgName;           /* name of dlg, not name of template */
	HDLG           hDlg;                /* handle to dialog                  */
    WNDPROC        lpprocDlg;           /* dialog proc 1632                  */
	PFNEVENT       lpprocEventHandler;  /* event handler for this dialog     */
	HDLG           hDlgFocus;           /* handle of control with focus      */
	SZ             szHelp;              /* name of help dialog template      */
	HDLG           hDlgHelp;            /* handle of help dlg for this dlg   */
    WNDPROC        lpprocHelp;          /* help dialog proc 1632             */
	struct _dbcb * pdbcbNext;           /* pointer to next item in list      */
	BOOL           fActive;             /* is dialog active?                 */
	} DBCB;
typedef DBCB * PDBCB;


	/* Dialog Handling routines */
extern  HDLG   APIENTRY HdlgCreateDialog(HANDLE, SZ, HWND, WNDPROC, DWORD);  //1632
extern  BOOL   APIENTRY FFillInDialogTextFromInf(HDLG, HANDLE);
extern  BOOL   APIENTRY FShowDialog(HDLG, BOOL);
extern  BOOL   APIENTRY FHideDialog(HDLG);
extern  BOOL   APIENTRY FActivateDialog(HDLG);
extern  BOOL   APIENTRY FInactivateDialog(HDLG);
extern  BOOL   APIENTRY FCloseDialog(HDLG);
extern  HDLG   APIENTRY HdlgCreateFillAndShowDialog(HANDLE, SZ, HWND, WNDPROC,  // 1632
		DWORD);
extern  BOOL   APIENTRY FEnableDialog(HDLG);
extern  BOOL   APIENTRY FDisableDialog(HDLG);
extern  BOOL   APIENTRY TextSubst(HWND, DWORD);
extern  BOOL            FCenterDialogOnDesktop(HWND);

	/* Dialog Stack routines */
extern  PDBCB  APIENTRY PdbcbAlloc(VOID);
extern  BOOL   APIENTRY FFreeDbcb(PDBCB);
//extern  BOOL   APIENTRY FInactivateHelp(VOID);
//extern  BOOL   APIENTRY FInactivateStackTop(VOID);
//extern  BOOL   APIENTRY FActivateHelp(VOID);
//extern  BOOL   APIENTRY FActivateStackTop(VOID);
//extern  BOOL   APIENTRY FActiveStackTop(VOID);
//extern  BOOL   APIENTRY FToggleDlgActivation(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\i386\rdskboot.asm ===
;
    ; Program to be inserted on the boot sector of the emergency repair
    ; disk.  Prints out a message and hangs.
    ;
    ; The program is designed to be inserted around the existing BPB.
    ; Whoever puts it in place should read the first three bytes of the
    ; boot sector to determine the byte offset within the sector where the
    ; program should be placed.
    ;
    ; See setup\src\restore.c.
    ;

TheSeg segment
    assume cs:TheSeg,ds:nothing,es:nothing,ss:nothing

    ;
    ; Make link happy with /tiny by setting org to 100h.
    ; The program itself is designed to run at 0:7c00h, so
    ; the org is just a dummy.
    ;
    org     100h
Start:

    ;
    ; Set up a stack and initialize necessary segment registers.
    ;
    xor     bx,bx
    mov     ss,bx
    mov     ds,bx
    mov     sp,7c00h

    ;
    ; Set video mode -- 80x25 text.
    ;
    mov     ax,3
    int     10h

    ;
    ; Make ds:si point at the message to be displayed.
    ;
    call    @f
@@: pop     si
    add     si,offset cs:msg - @b

    ;
    ; Print out the string via BIOS calls.  Registers ds, si, and bx are
    ; already set up.
    ;
    ; Some BIOSes don't preserve ax properly so we'll reload it
    ; on every iteration.
    ;
    cld
@@: mov     ah,0eh
    lodsb
    or      al,al
    jz      @f
    int     10h
    jmp     @b

    ;
    ; Done.  Hide the cursor and hang.
    ; Register bh is already set up.
    ;
@@: mov     ah,2
    mov     dl,bl
    mov     dh,19h
    int     10h
    sti
@@: jmp     @b

    ;
    ; The message to be printed.  This will be inserted by setup from its
    ; resources (IDS_REPAIR_BOOTCODE_MSG), and must be nul-terminated.
    ;
msg label byte

TheSeg ends

    end     Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\_stfinf.h ===
#define     NL                  '\n'
#define     CR                  '\r'

/*
    The following equate is used starting with the earliest preprocessing
    to handle the case of two lines with quoted strings that are joined
    by a line continuation character.  The result is something like
    "abc""def" -- which evaluates to abc"def.  So DQUOTE is used to start and
    end a quoted string, and the " character is used where a " character is
    actually part of the string.
*/

#define     DQUOTE              1

#define     NUL                 0
#define     EOL                 NUL

#define     IS_SEPARATOR(x)     (((x) == ' ') || ((x) == ','))

/*
    Structure used to describe a preparsed line.  Array of
    these is set up at load time and used at run time.

    The union is used because at preparse time, the offset of the
    line is stored instead of a pointer to the line's text.  This is
    because the buffer is reallocated as it grows and thus may move.
    When preparsing is complete the offsets are converted to pointers.
*/

typedef struct _tagINFLINE {
    USHORT  flags;
    union {
        LPSTR   addr;
        UINT    offset;
    } text;
} INFLINE, *PINFLINE;


#define     INFLINE_NORMAL                  0x00
#define     INFLINE_SECTION                 0x01
#define     INFLINE_KEY                     0x02

/*
    Token and token-related constants
*/

#define     TOKEN_VARIABLE                          10
#define     TOKEN_LIST_FROM_SECTION_NTH_ITEM        11
#define     TOKEN_FIELD_ADDRESSOR                   12
#define     TOKEN_APPEND_ITEM_TO_LIST               13
#define     TOKEN_NTH_ITEM_FROM_LIST                14
#define     TOKEN_LOCATE_ITEM_IN_LIST               15

#define     TOKEN_OPERATOR_FIRST                    TOKEN_VARIABLE
#define     TOKEN_OPERATOR_LAST                     TOKEN_LOCATE_ITEM_IN_LIST

#define     IS_OPERATOR_TOKEN(x)   (((x) >= TOKEN_OPERATOR_FIRST)  && \
                                    ((x) <= TOKEN_OPERATOR_LAST ))

#define     TOKEN_LIST_START                        20
#define     TOKEN_LIST_END                          21

#define     TOKEN_SPACE                             40
#define     TOKEN_COMMA                             41

#define     TOKEN_RIGHT_PAREN                       50

#define     TOKEN_KEY                               60

/*
    a short string is one whose length is 0-99.  This is the most
    common case, so the length is encoded into the token.  A short
    string can really therefore be any token from 100-199.

    A string is one whose length is 100-355.  Its length fits into
    one byte after subtracting 100.

    A long string is > 355.  Its length takes two bytes to represent
    and is not specially modified with an add or subtract like a string.
*/

#define     TOKEN_SHORT_STRING                      100
#define     TOKEN_STRING                            200
#define     TOKEN_LONG_STRING                       201

#define     IS_STRING_TOKEN(x)      (((x) >= TOKEN_SHORT_STRING)  &&  \
                                     ((x) <= TOKEN_LONG_STRING ))

#define     TOKEN_EOL                               253
#define     TOKEN_ERROR                             254
#define     TOKEN_UNKNOWN                           255


/*
    Function prototypes
*/

GRC
PreprocessINFFile(
    LPSTR FileName,
    PBYTE *ResultBuffer,
    UINT  *ResultBufferSize
    );

GRC
PreparseINFFile(
    PUCHAR    INFFile,
    UINT      INFFileSize,
    PUCHAR   *PreparsedINFFile,
    UINT     *PreparsedINFFileBufferSize,
    PINFLINE *LineArray,
    UINT     *LineCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\libmsg\libmsg.h ===
#include <windows.h>

//
// Message output routines.
//

#if defined(__cplusplus)

extern "C"
{
#endif

LPTSTR
GetFormattedMessage(
    IN HMODULE  ThisModule, OPTIONAL
    IN BOOL     SystemMessage,
    OUT PWCHAR  Message,
    IN ULONG    LengthOfBuffer,
    IN UINT     MessageId,
    ...
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\localinf\local.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>


/*
    local.c -   It will open a localization file and append the content of the
                localization file to each file indicated within the
                localization file.

    syntax: local < input file > < localize directory >

 */


typedef struct _PLATFORM_DATA {

    //
    // Name of platform and platform's subdirectory in
    // the build tree.
    //
    PSTR PlatformName;

    //
    // Current output file for this platform.
    // If a line in the input file applies to this platform,
    // this handle will be used to write the line into the
    // output file being generated for this platform.
    //
    FILE *OutputFile;

} PLATFORM_DATA, *PPLATFORM_DATA;


//
// When porting, simply bump up this number and add
// a line to the PlatformData array below.
//
#define NUMBER_OF_PLATFORMS 4

PLATFORM_DATA PlatformData[NUMBER_OF_PLATFORMS] =

    {{ "i386",  NULL },
     { "mips",  NULL },
     { "alpha", NULL },
     { "ppc",   NULL }};

//
// Value to indicate that a line of input belongs in output file
// for all platforms.
//
#define ALL_PLATFORMS NUMBER_OF_PLATFORMS

//
// Input buffer.
//
CHAR InputBuffer[1000];


VOID
CloseAllOpenOutputFiles(
    VOID
    )
{
    unsigned Platform;

    for(Platform=0; Platform<NUMBER_OF_PLATFORMS; Platform++) {

        if(PlatformData[Platform].OutputFile) {
            fclose(PlatformData[Platform].OutputFile);
            PlatformData[Platform].OutputFile = NULL;
        }
    }
}


BOOL
ProcessInputFile(
    IN FILE *InputFile,
    IN PSTR  TargetDirectory
    )
{
    CHAR InfFileName[MAX_PATH];
    CHAR PlatformName[100];
    CHAR OutputFileName[MAX_PATH];
    BOOL TotalSuccess;
    unsigned CurrentPlatform;
    unsigned Platform;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    //
    // Assume overall success.
    //
    TotalSuccess = TRUE;

    //
    // Until a platform is specified, all platforms are selected.
    // Note that nothing will actually get written until a platform
    // is selected because no output files are open until then.
    //
    CurrentPlatform = ALL_PLATFORMS;

    //
    // Process each line in the input file.
    //
    while(TotalSuccess && fgets(InputBuffer,sizeof(InputBuffer),InputFile)) {

        //
        // If the line begins with ##### then this line specifies
        // which platform lines following it in the input file apply to.
        //
        // Otherwise the line will be copied to the appropriate output
        // file(s).
        //
        if(strncmp(InputBuffer,"#####",5)) {

            //
            // Plain old line. Place in output file for current platform
            // or all platforms as appropriate.
            //
            for(Platform=0; TotalSuccess && (Platform<NUMBER_OF_PLATFORMS); Platform++) {

                if(PlatformData[Platform].OutputFile
                && ((CurrentPlatform == ALL_PLATFORMS) || (Platform == CurrentPlatform))) {

                    if(fputs(InputBuffer,PlatformData[Platform].OutputFile) == EOF) {
                        fprintf(stderr,"unable to write to output file\n");
                        TotalSuccess = FALSE;
                    }
                }
            }

        } else {

            //
            // Platform specifier line. Next two values are output filename
            // and output file platform.
            //
            if (sscanf(InputBuffer,"#####%s %s",InfFileName,PlatformName) < 2) {
	        fprintf(stderr,"invalid localization file\n");
	        TotalSuccess = FALSE;
                break;
            }

            //
            // Attempt to determine the platform specified.
            // If the value in the input file is not recognized then
            // it specifies all platforms.
            //
            CurrentPlatform = ALL_PLATFORMS;

            for(Platform=0; Platform<NUMBER_OF_PLATFORMS; Platform++) {

                if(!_stricmp(PlatformName,PlatformData[Platform].PlatformName)) {
                    CurrentPlatform = Platform;
                    break;
                }
            }

            //
            // Close all open output files.
            //
            CloseAllOpenOutputFiles();

            //
            // Now open output files as appropriate.  Note that this means
            // we will either open a single platform's output file or all
            // platforms' output files.
            //
            for(Platform=0; TotalSuccess && (Platform<NUMBER_OF_PLATFORMS); Platform++) {

                if((Platform == CurrentPlatform) || (CurrentPlatform == ALL_PLATFORMS)) {

                    //
                    // First we will determine whether the relevent platform's
                    // directory exists.  If not, we'll simply skip this platform.
                    // This prevents us from erroring out when we're generating
                    // 3.5" media, because there will be no mips, alpha, ppc, etc
                    // subdirectories for 3.5" media.
                    //
                    sprintf(
                        OutputFileName,
                        "%s\\%s",
                        TargetDirectory,
                        PlatformData[Platform].PlatformName
                        );

                    FindHandle = FindFirstFile(OutputFileName,&FindData);
                    if(FindHandle != INVALID_HANDLE_VALUE) {

                        FindClose(FindHandle);

                        strcat(OutputFileName,"\\");
                        strcat(OutputFileName,InfFileName);

                        if((PlatformData[Platform].OutputFile = fopen(OutputFileName,"a")) == NULL) {
                            fprintf(stderr,"open file:%s fail.\n",OutputFileName);
                            TotalSuccess = FALSE;
                        }
                    }
                }
            }
        }
    }

    //
    // Close all open output files.
    //
    CloseAllOpenOutputFiles();

    //
    // Return value indicating whether we were totally successful.
    //
    return TotalSuccess;
}

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    FILE *InputFile;
    int ReturnCode;

    if(argc != 3) {
        fprintf(stderr,"usage: local <file name> <directory name>\n");
        return 1;
    }

    if(InputFile = fopen(argv[1],"r")) {

        ReturnCode = ProcessInputFile(InputFile,argv[2]) ? 0 : 1;
        fclose(InputFile);

    } else {

        fprintf(stderr,"cannot open localizer file.");
        ReturnCode = 1;
    }

    return ReturnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\inc\baseinc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    baseinc.h

Abstract:

    Includes SDK headers needed for the project, and allutils.h.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// basetypes.h creates better types for managing DBCS and UNICODE
// with the C runtime, and defines other types that should be defined
// by the Win32 headers but aren't.
//

#include "basetypes.h"

//
// COBJMACROS turns on the C-style macros for COM.  We don't use C++!
//

#define COBJMACROS

//
// Windows
//

#include <windows.h>
#include <winnt.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>

//
// PORTBUG -- I had to uncomment shlobj.h just to get the #define DOUBLE working...
//
#include <shlobj.h>
//#include <objidl.h>
//#include <mmsystem.h>
//

//
// Private utilities
//

#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\inc\allutils.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    allutils.h

Abstract:

    Includes all header files necessary to use the libraries generated under the
    utils directory. Declares many macros and MAX constants.

Author:

    Jim Schmidt (jimschm) 23-Aug-1996

Revision History:

    marcw 2-Sep-1999 Ported over from win95upg project (migutil.h) Needs lots of cleanup.

--*/

#pragma once

//
// Includes
//

#include "utiltypes.h"
#include "main.h"
#include "dbgtrack.h"
#include "basemem.h"
#include "log.h"
#include "growbuf.h"
#include "strings.h"
#include "poolmem.h"
#include "growlist.h"
#include "version.h"
#include "unicode.h"
#include "hash.h"
#include "basefile.h"
#include "memdb.h"
#include "inf.h"
#include "ini.h"
#include "blobs.h"
#include "objstr.h"
#include "exclist.h"
#include "reg.h"
#include "regenum.h"
#include "fileenum.h"
#include "wnd.h"

//
// Strings
//

// None

//
// Constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_SERVER_NAMEA + (20 * 2))
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_SERVER_NAMEW + 20)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

#define MAX_CMDLINEW                1024            // maximum number of chars in a Win95 command line

#ifdef UNICODE

#define MAX_SERVER_NAME             MAX_SERVER_NAMEW
#define MAX_USER_NAME               MAX_USER_NAMEW
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYW
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEW
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEW
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEW
#define MAX_CMDLINE                 MAX_CMDLINEW

#define MAX_TCHAR_PATH              MAX_WCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_WCHAR_PRINTABLE_PATH

#else

#define MAX_SERVER_NAME             MAX_SERVER_NAMEA
#define MAX_USER_NAME               MAX_USER_NAMEA
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYA
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEA
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEA
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEA
#define MAX_CMDLINE                 MAX_CMDLINEA

#define MAX_TCHAR_PATH              MAX_MBCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_MBCHAR_PRINTABLE_PATH

#endif


//
// Macros
//


//
// OSVERSION macros...
//
#define ISNT()              (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISWIN9X()           (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
#define ISWIN95_GOLDEN()    (ISWIN95() && WORD(g_OsInfo.dwBuildNumber) <= 1000)
#define ISWIN95_OSR2()      (ISWIN95() && WORD(g_OsInfo.dwBuildNumber) > 1000)
#define ISWIN95()           (ISWIN9X() && !ISMEMPHIS())
#define ISMEMPHIS()         (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==10)
#define BUILDNUMBER()       (g_OsInfo.dwBuildNumber)

//
// Error condition tags.
//
// These tags should be used for all error conditions.
//

#define ERROR_CRITICAL
#define ERROR_NONCRITICAL
#define ERROR_TRIVIAL
#define ERROR_ABNORMAL_CONDITION



//
// Types
//

typedef struct {
    HANDLE EventHandle;
} OUR_CRITICAL_SECTION, *POUR_CRITICAL_SECTION;

//
// String Mapping
//

typedef struct {
    BOOL UnicodeData;

    //
    // The filter can replace NewSubString.  (The filter must also
    // set NewSubStringSizeInBytes when replacing NewSubString.)
    //

    union {
        struct {
            PCWSTR OriginalString;
            PCWSTR CurrentString;
            PCWSTR OldSubString;
            PCWSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Unicode;

        struct {
            PCSTR OriginalString;
            PCSTR CurrentString;
            PCSTR OldSubString;
            PCSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Ansi;
    };
} REG_REPLACE_DATA, *PREG_REPLACE_DATA;

typedef BOOL(REG_REPLACE_FILTER_PROTOTYPE)(PREG_REPLACE_DATA Data);
typedef REG_REPLACE_FILTER_PROTOTYPE * REG_REPLACE_FILTER;

typedef struct _tagCHARNODE {
    WORD Char;
    WORD Flags;
    PVOID OriginalStr;
    PVOID ReplacementStr;
    INT ReplacementBytes;
    struct _tagCHARNODE *NextLevel;
    struct _tagCHARNODE *NextPeer;
    REG_REPLACE_FILTER Filter;
} CHARNODE, *PCHARNODE;

typedef struct {
    PMHANDLE Pool;
    PCHARNODE FirstLevelRoot;
} MAPSTRUCT, *PMAPSTRUCT;


//
// Globals
//

extern HINSTANCE g_hInst;
extern HANDLE g_hHeap;
extern OSVERSIONINFOA g_OsInfo;


extern BOOL g_IsPc98;

//
// Boot drive letter
//

extern PCSTR g_BootDrivePathA;
extern PCWSTR g_BootDrivePathW;
extern PCSTR g_BootDriveA;
extern PCWSTR g_BootDriveW;
extern CHAR g_BootDriveLetterA;
extern WCHAR g_BootDriveLetterW;


//
// Macro expansion list
//

// None

//
// Public function prototypes
//

//
// Critical Section APIs, implemented because TryEnterCriticalSection is
// supported only on NT, and we need it on Win9x.
//


BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

//
// Includes of util modules
//


VOID
CenterWindow (
    HWND Wnd,
    HWND Parent     OPTIONAL
    );

VOID
TurnOnWaitCursor (
    VOID
    );

VOID
TurnOffWaitCursor (
    VOID
    );

VOID
OutOfMemory_Terminate (
    VOID
    );


VOID
SetOutOfMemoryParent (
    HWND hwnd
    );


PMAPSTRUCT
CreateStringMapping (
    VOID
    );

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    );

VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter       OPTIONAL
    );

#define AddStringMappingPairA(Map,Old,New) AddStringMappingPairExA(Map,Old,New,NULL)

VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter       OPTIONAL
    );

#define AddStringMappingPairW(Map,Old,New) AddStringMappingPairExW(Map,Old,New,NULL)

BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      BOOL CompleteMatchOnly
    );

#define MappingSearchAndReplaceA(map,buffer,maxbytes)   MappingSearchAndReplaceExA(map,buffer,buffer,0,NULL,maxbytes,FALSE)


BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      BOOL CompleteMatchOnly
    );

#define MappingSearchAndReplaceW(map,buffer,maxbytes)   MappingSearchAndReplaceExW(map,buffer,buffer,0,NULL,maxbytes,FALSE)


HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    );

//
// Macro expansion definition
//

// None

//
// Unicode/Ansi mappings.
//
#ifdef UNICODE

#define g_BootDrivePath     g_BootDrivePathW
#define g_BootDrive         g_BootDriveW
#define g_BootDriveLetter   g_BootDriveLetterW

#define VERSION_STRUCT                  VERSION_STRUCTW
#define PVERSION_STRUCT                 PVERSION_STRUCTW
#define CreateVersionStruct             CreateVersionStructW
#define DestroyVersionStruct            DestroyVersionStructW
#define EnumFirstVersionTranslation     EnumFirstVersionTranslationW
#define EnumNextVersionTranslation      EnumNextVersionTranslationW
#define EnumFirstVersionValue           EnumFirstVersionValueW
#define EnumNextVersionValue            EnumNextVersionValueW
#define AddStringMappingPair            AddStringMappingPairW
#define AddStringMappingPairEx          AddStringMappingPairExW
#define MappingSearchAndReplace         MappingSearchAndReplaceW
#define MappingSearchAndReplaceEx       MappingSearchAndReplaceExW

#else

#define g_BootDrivePath     g_BootDrivePathA
#define g_BootDrive         g_BootDriveA
#define g_BootDriveLetter   g_BootDriveLetterA

#define VERSION_STRUCT                  VERSION_STRUCTA
#define PVERSION_STRUCT                 PVERSION_STRUCTA
#define CreateVersionStruct             CreateVersionStructA
#define DestroyVersionStruct            DestroyVersionStructA
#define EnumFirstVersionTranslation     EnumFirstVersionTranslationA
#define EnumNextVersionTranslation      EnumNextVersionTranslationA
#define EnumFirstVersionValue           EnumFirstVersionValueA
#define EnumNextVersionValue            EnumNextVersionValueA
#define AddStringMappingPair            AddStringMappingPairA
#define AddStringMappingPairEx          AddStringMappingPairExA
#define MappingSearchAndReplace         MappingSearchAndReplaceA
#define MappingSearchAndReplaceEx       MappingSearchAndReplaceExA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\libmsg\libmsg.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    libmsg.c

Abstract:

    Message handling routines.

Author:

    Mandar Gokhale(mandarg) 20-Dec-2001

Revision History:

--*/

#include "libmsg.h"

LPTSTR
GetFormattedMessage(
    IN  HMODULE ThisModule, OPTIONAL
    IN  BOOL    SystemMessage,
    OUT PWCHAR  Message,
    IN  ULONG   LengthOfBuffer,
    IN  UINT    MessageId,
    ...
    )
/*++

Routine Description:

    Retreive and format a message.

Arguments:

    ThisModule - Handle to this module that contains the message.

    SystemMessage - specifies whether the message is to be located in
        this module, or whether it's a system message.

    Message  - Message buffer that will contain the formatted message.

    LengthOfBuffer - Length of the message buffer in characters.

    MessageId - If SystemMessage is TRUE, then this supplies a system message id,
        such as a Win32 error code. If SystemMessage is FALSE, the this supplies
        the id for the message within this module's resources.

    Additional arguments supply values to be inserted in the message text.

Return Value:

    Returns a pointer to the message buffer if a message is retrieved 
    into the messaage buffer otherwise returns NULL.
	

--*/

{
    va_list arglist;
    DWORD d;
    

    if (Message && LengthOfBuffer){

	*Message = UNICODE_NULL;
    	va_start(arglist,MessageId);
    	d = FormatMessage(
            SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
            ThisModule,
            MessageId,
            0,
            Message,
            LengthOfBuffer,
            &arglist
            );
	    va_end(arglist);
    }
	 
    	return(Message);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\exe\setup.c ===
#include <windows.h>
#include <setupapi.h>


#define PNP_NEW_HW_PIPE       TEXT("\\\\.\\pipe\\PNP_New_HW_Found")
#define PNP_CREATE_PIPE_EVENT TEXT("PNP_Create_Pipe_Event")
#define PNP_PIPE_TIMEOUT      180000

typedef BOOL     (WINAPI *FP_DEVINSTALLW)(HDEVINFO, PSP_DEVINFO_DATA);
typedef HDEVINFO (WINAPI *FP_CREATEDEVICEINFOLIST)(LPGUID, HWND);
typedef BOOL     (WINAPI *FP_OPENDEVICEINFO)(HDEVINFO, PCWSTR, HWND, DWORD, PSP_DEVINFO_DATA);
typedef BOOL     (WINAPI *FP_DESTROYDEVICEINFOLIST)(HDEVINFO);
typedef BOOL     (WINAPI *FP_GETDEVICEINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS_W);
typedef BOOL     (WINAPI *FP_ENUMDEVICEINFO)(HDEVINFO, DWORD, PSP_DEVINFO_DATA);
typedef  INT      (WINAPI *FP_PROMPTREBOOT)(HSPFILEQ, HWND, BOOL);


VOID
InstallNewHardware(
    IN HMODULE hSysSetup
    );



int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    BOOL    NewSetup = TRUE, NewHardware = FALSE;
    INT     i;
    HMODULE h = NULL;
    FARPROC p = NULL;
    CHAR    FileName[MAX_PATH];

    //
    // Scan Command Line for -newsetup flag
    //
    for(i = 0; i < argc; i++) {
        if(argv[i][0] == '-') {
            if(!_stricmp(argv[i],"-newsetup")) {
                NewSetup = TRUE;
            } else if (!_stricmp(argv[i], "-plugplay")) {
                NewHardware = TRUE;
            } else if (!_stricmp(argv[i], "-asr")) {
                ;   // do nothing
            } else if (!_stricmp(argv[i], "-asrquicktest")) {
                ;   // do nothing
            } else if (!_stricmp(argv[i], "-mini")) {
                ;   // do nothing
            } else
                return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Load the Appropriate Libary and function pointer
    //

    h = LoadLibrary("syssetup");


    if( h ){

        if (NewHardware) {
            InstallNewHardware(h);
        } else {
            
            //
            // Call the target function.
            //
            p=GetProcAddress(h,"InstallWindowsNt");
            if(p) {
                i = (int) p(argc,argv);
            }

        }
    }
    
    //
    // Make sure that the library goes away
    //

    while(h && GetModuleFileName(h,FileName,MAX_PATH)) {
        FreeLibrary(h);
    }

    return i;
}



VOID
InstallNewHardware(
    IN HMODULE hSysSetup
    )
{
    FP_DEVINSTALLW            fpDevInstallW = NULL;
    FP_CREATEDEVICEINFOLIST   fpCreateDeviceInfoList = NULL;
    FP_OPENDEVICEINFO         fpOpenDeviceInfoW = NULL;
    FP_DESTROYDEVICEINFOLIST  fpDestroyDeviceInfoList;
    FP_GETDEVICEINSTALLPARAMS fpGetDeviceInstallParams;
    FP_ENUMDEVICEINFO         fpEnumDeviceInfo;
    FP_PROMPTREBOOT           fpPromptReboot;

    HMODULE             hSetupApi = NULL;
    WCHAR               szBuffer[MAX_PATH];
    ULONG               ulSize = 0, Index;
    HANDLE              hPipe = INVALID_HANDLE_VALUE;
    HANDLE              hEvent = NULL;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA     DeviceInfoData;
    SP_DEVINSTALL_PARAMS_W DeviceInstallParams;
    BOOL                bReboot = FALSE;
    BOOL                Status = FALSE;

    //
    // retrieve a proc address of the DevInstallW procedure in syssetup
    //
    if (!(fpDevInstallW =
            (FP_DEVINSTALLW)GetProcAddress(hSysSetup, "DevInstallW"))) {

        goto Clean0;
    }

    //
    // also load setupapi and retrieve following proc addresses
    //
    hSetupApi = LoadLibrary("setupapi");

    if (!(fpCreateDeviceInfoList =
            (FP_CREATEDEVICEINFOLIST)GetProcAddress(hSetupApi,
                                "SetupDiCreateDeviceInfoList"))) {
        goto Clean0;
    }

    if (!(fpOpenDeviceInfoW =
            (FP_OPENDEVICEINFO)GetProcAddress(hSetupApi,
                                "SetupDiOpenDeviceInfoW"))) {
        goto Clean0;
    }

    if (!(fpDestroyDeviceInfoList =
            (FP_DESTROYDEVICEINFOLIST)GetProcAddress(hSetupApi,
                                "SetupDiDestroyDeviceInfoList"))) {
        goto Clean0;
    }

    if (!(fpGetDeviceInstallParams =
            (FP_GETDEVICEINSTALLPARAMS)GetProcAddress(hSetupApi,
                                "SetupDiGetDeviceInstallParamsW"))) {
        goto Clean0;
    }

    if (!(fpEnumDeviceInfo =
            (FP_ENUMDEVICEINFO)GetProcAddress(hSetupApi,
                                "SetupDiEnumDeviceInfo"))) {
        goto Clean0;
    }

    if (!(fpPromptReboot =
            (FP_PROMPTREBOOT)GetProcAddress(hSetupApi,
                                "SetupPromptReboot"))) {
        goto Clean0;
    }

    //
    // open the event that will be used to signal the successful
    // creation of the named pipe (event should have been created
    // before I was called but if this process is started by anyone
    // else then it will go away now safely)
    //
    hEvent = OpenEvent(EVENT_MODIFY_STATE,
                       FALSE,
                       PNP_CREATE_PIPE_EVENT);

    if (hEvent == NULL) {
        goto Clean0;
    }

    //
    // create the named pipe, umpnpmgr will write requests to
    // this pipe if new hardware is found
    //
    hPipe = CreateNamedPipe(PNP_NEW_HW_PIPE,
                            PIPE_ACCESS_INBOUND,
                            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
                            1,                         // only one connection
                            MAX_PATH * sizeof(WCHAR),  // out buffer size
                            MAX_PATH * sizeof(WCHAR),  // in buffer size
                            PNP_PIPE_TIMEOUT,          // default timeout
                            NULL                       // default security
                            );

    //
    // signal the event now, whether the pipe was successfully created
    // or not (don't keep userinit/cfgmgr32 waiting)
    //
    SetEvent(hEvent);

    if (hPipe == INVALID_HANDLE_VALUE) {
        goto Clean0;
    }

    //
    // connect to the newly created named pipe
    //
    if (ConnectNamedPipe(hPipe, NULL)) {
        //
        // create a devinfo handle and device info data set to
        // pass to DevInstall
        //
        if((hDevInfo = (fpCreateDeviceInfoList)(NULL, NULL))
                        == INVALID_HANDLE_VALUE) {
            goto Clean0;
        }

        while (TRUE) {
            //
            // listen to the named pipe by submitting read
            // requests until the named pipe is broken on the
            // other end.
            //
            if (!ReadFile(hPipe,
                     (LPBYTE)szBuffer,    // device instance id
                     MAX_PATH * sizeof(WCHAR),
                     &ulSize,
                     NULL)) {

                if (GetLastError() != ERROR_BROKEN_PIPE) {
                    // Perhaps Log an Event
                }

                goto Clean0;
            }

            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            if(!(fpOpenDeviceInfoW)(hDevInfo, szBuffer, NULL, 0, &DeviceInfoData)) {
                goto Clean0;
            }

            //
            // call syssetup, DevInstallW
            //
            if ((fpDevInstallW)(hDevInfo, &DeviceInfoData)) {
                Status = TRUE;  // at least one device installed successfully
            }
        }
    }

    Clean0:

    //
    // If at least one device was successfully installed, then determine
    // whether a reboot prompt is necessary.
    //
    if (Status && hDevInfo != INVALID_HANDLE_VALUE) {
        //
        // Enumerate each device that is associated with the device info set.
        //
        Index = 0;
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        while ((fpEnumDeviceInfo)(hDevInfo,
                                  Index,
                                  &DeviceInfoData)) {
            //
            // Get device install params, keep track if any report needing
            // a reboot.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS_W);
            if ((fpGetDeviceInstallParams)(hDevInfo,
                                           &DeviceInfoData,
                                           &DeviceInstallParams)) {

                if ((DeviceInstallParams.Flags & DI_NEEDREBOOT) ||
                    (DeviceInstallParams.Flags & DI_NEEDRESTART)) {

                    bReboot = TRUE;
                }
            }
            Index++;
        }

        (fpDestroyDeviceInfoList)(hDevInfo);

        //
        // If any devices need reboot, prompt for reboot now.
        //
        if (bReboot) {
            (fpPromptReboot)(NULL, NULL, FALSE);
        }
    }

    if (hSetupApi != NULL) {
        FreeLibrary(hSetupApi);
    }
    if (hPipe != INVALID_HANDLE_VALUE) {
        DisconnectNamedPipe(hPipe);
        CloseHandle(hPipe);
    }
    if (hEvent != NULL) {
        CloseHandle(hEvent);
    }

    return;

} // InstallNewHardware
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\inc\basetypes.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    chartype.h

Abstract:

    Declares macros and types for the multi-byte and Unicode
    character environment that the Win9x upgrade code requires.
    The following macros are defined:

    - Make sure UNICODE is defined if _UNICODE is defined
    - Make the type MBCHAR that holds both bytes of a multi-byte char
    - Make CHARTYPE point to wint_t for UNICODE and MBCHAR for not
      UNICODE

Author:

    Jim Schmidt (jimschm) 10-Oct-1996

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifndef PCUINT
typedef const unsigned int  *PCUINT;
#endif

#ifndef PCUINT64
typedef const unsigned _int64  *PCUINT64;
#endif

#if defined(_WIN64)

#define BINT    INT64
#define UBINT   UINT64
#define PBINT   PINT64
#define PUBINT  PUINT64
#define PCUBINT PCUINT64

#else

#define BINT    INT
#define UBINT   UINT
#define PBINT   PINT
#define PUBINT  PUINT
#define PCUBINT PCUINT

#endif

#if defined _UNICODE && !defined UNICODE
#define UNICODE
#endif

#ifdef UNICODE

//
// If UNICODE, define _UNICODE for tchar.h, and make
// a type to represent a single character.
//

#ifndef _UNICODE
#define _UNICODE
#endif

#define CHARTYPE wint_t

#pragma message ("UNICODE version being built")

#else       // ifdef UNICODE

//
// If not UNICODE, we must assume multibyte characters.
// Define _MBCS for tchar.h, and make a type that can
// hold a complete multibyte character.
//

#ifndef _MBCS
#define _MBCS
#endif
#define CHARTYPE unsigned int

#pragma message ("MBCS version being built")

#endif      // ifdef UNICODE, else

#define MBCHAR unsigned int

#include <tchar.h>

//
// Constant pointer to a void
//

#ifndef PCVOID
typedef const void * PCVOID;
#endif

//
// Pointer to a constant byte sequence
//

#ifndef PCBYTE
typedef const unsigned char * PCBYTE;
#endif


//
// use the result of sizeof operator as a DWORD
//
#define DWSIZEOF(x) ((DWORD)sizeof(x))

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\miglib\miglib.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdlls.c

Abstract:

    Library interface used to gather, store, query, and call migration dlls during an
    OS upgrade.

Author:

    Marc R. Whitten (marcw) 08-February-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "plugin.h"
#include "miglibp.h"



//
// Strings
//


#define PLUGIN_NEW_INITIALIZE_SRCA           "InitializeSrcA"
#define PLUGIN_NEW_GATHER_USER_SETTINGSA     "GatherUserSettingsA"
#define PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA   "GatherSystemSettingsA"
#define PLUGIN_NEW_INITIALIZE_SRCW           "InitializeSrcW"
#define PLUGIN_NEW_GATHER_USER_SETTINGSW     "GatherUserSettingsW"
#define PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW   "GatherSystemSettingsW"
#define PLUGIN_NEW_INITIALIZE_DSTW           "InitializeDstW"
#define PLUGIN_NEW_APPLY_USER_SETTINGSW      "ApplyUserSettingsW"
#define PLUGIN_NEW_APPLY_SYSTEM_SETTINGSW    "ApplySystemSettingsW"
#define PLUGIN_NEW_INITIALIZE_DSTA           "InitializeDstA"
#define PLUGIN_NEW_APPLY_USER_SETTINGSA      "ApplyUserSettingsA"
#define PLUGIN_NEW_APPLY_SYSTEM_SETTINGSA    "ApplySystemSettingsA"
#define PLUGIN_NEW_QUERY_MIGRATION_INFOA     "QueryMigrationInfoA"
#define PLUGIN_NEW_QUERY_MIGRATION_INFOW     "QueryMigrationInfoW"


//
// Constants
//


//
// Macros
//

// None

//
// Types
//


//
// Globals
//
PMHANDLE g_MigLibPool;
CHAR g_MigIsolPathA[MAX_MBCHAR_PATH];
WCHAR g_MigIsolPathW[MAX_WCHAR_PATH];
HANDLE g_WinTrustLib = NULL;
WINVERIFYTRUST WinVerifyTrustProc = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//




BOOL
pTestDllA (
    OUT PMIGRATIONDLLA DllData, 
    IN  BOOL SourceOs
    )
{
    BOOL valid = FALSE;


    //
    // Check to see if this is an old style Migration DLL.
    //
    if(SourceOs != SOURCEOS_WINNT){
        if (GetProcAddress (DllData->Library, PLUGIN_QUERY_VERSION) &&
            GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_9X)                     &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_9X)                   &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_9X)                 &&
            GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_NT)                     &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_NT)                   &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_NT)
            ) {

            valid = TRUE;
            DllData->OldStyle = TRUE;
            DllData->SrcUnicode = FALSE;
        }
    }
    else {
        if (GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOA) &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCA)           &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSA)     &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA)   &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTA)            &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSA)       &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSA)
            ) {

            valid = TRUE;
            DllData->OldStyle = FALSE;
            DllData->SrcUnicode = FALSE;
        }
        else if (GetProcAddress (DllData->Library,PLUGIN_NEW_QUERY_MIGRATION_INFOW) &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCW)           &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSW)     &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW)   &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTW)            &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSW)       &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSW)
            ) {

            valid = TRUE;
            DllData->OldStyle = FALSE;
            DllData->SrcUnicode = TRUE;
        }
    }


    return valid;
}


BOOL
pTestDllW (
    OUT PMIGRATIONDLLW DllData, 
    IN  BOOL SourceOs
    )
{
    BOOL valid = FALSE;


    //
    // Check to see if this is an old style Migration DLL.
    //
    if(SourceOs != SOURCEOS_WINNT){
        if (GetProcAddress (DllData->Library, PLUGIN_QUERY_VERSION) &&
            GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_9X)                     &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_9X)                   &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_9X)                 &&
            GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_NT)                     &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_NT)                   &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_NT)
            ) {

            valid = TRUE;
            DllData->OldStyle = TRUE;
            DllData->SrcUnicode = FALSE;
        }
    }
    else {
        if (GetProcAddress (DllData->Library,PLUGIN_NEW_QUERY_MIGRATION_INFOW) &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCW)           &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSW)     &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW)   &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTW)            &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSW)       &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSW)
            ) {

            valid = TRUE;
            DllData->OldStyle = FALSE;
            DllData->SrcUnicode = TRUE;
        }
        else if (GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOA) &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCA)           &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSA)     &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA)   &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTA)            &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSA)       &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSA)
                ) {

                valid = TRUE;
                DllData->OldStyle = FALSE;
                DllData->SrcUnicode = FALSE;
        }
    }


    return valid;
}


VOID
MigDllCloseA (
    IN OUT PMIGRATIONDLLA DllData
    )
{
    MYASSERT (DllData);
    if (DllData->Library != NULL) {
        FreeLibrary (DllData->Library);
        DllData->Library = NULL;
    }
    else if (DllData->Isolated) {
        IpcClose ();
    }
}


VOID
MigDllCloseW (
    IN OUT PMIGRATIONDLLW DllData
    )
{
    MYASSERT (DllData);
    if (DllData->Library != NULL) {
        FreeLibrary (DllData->Library);
        DllData->Library = NULL;
    }
    else if (DllData->Isolated) {
        IpcClose ();
    }
}


BOOL
MigDllOpenW (
    OUT PMIGRATIONDLLW DllData,
    IN PCWSTR DllPath,
    IN BOOL MigrationMode,
    IN BOOL Isolated,
    IN BOOL SourceOs
    )
{

    BOOL valid = FALSE;
    PWSTR p;
    MYASSERT (DllData);

    ZeroMemory (DllData, sizeof (MIGRATIONDLL));

    if (SourceOs == SOURCEOS_WINNT && WinVerifyTrustProc) {

        //
        // See if the migration dll is signed.
        //
        if (!IsDllSignedW (WinVerifyTrustProc, DllPath)) {
            return FALSE;
        }
    }

    //
    // Fill in basic bool flags in structure.
    //
    DllData->Isolated = Isolated;
    DllData->MigrationMode = MigrationMode;
    DllData->SourceOs = SourceOs;
    DllData->SrcUnicode = TRUE; // Assume UNICODE until proven false.
    DllData->OldStyle = FALSE; // Assume new migration dll.

    StringCopyW (DllData->Properties.DllPath, DllPath);
    p = wcsrchr (DllData->Properties.DllPath, '\\');
    if (p) {
        *p = 0;
        StringCopyW (DllData->Properties.WorkingDirectory, DllData->Properties.DllPath);
        StringCopyW (DllData->Properties.SourceMedia, DllData->Properties.DllPath);
        *p = '\\';
    }


    if (!Isolated) {

        DllData->Library = LoadLibraryW (DllPath);
        if (!DllData->Library) {
            return FALSE;
        }

        //
        //  See if this dll contains required entry points and test for various state (old style, srcunicode, etc.)
        //
        valid = pTestDllW (DllData, SourceOs);

        if (!valid) {

            MigDllCloseW (DllData);
            DEBUGMSGA ((DBG_MIGDLLS, "Migration DLL %s does not contain required entry points.", DllPath));
            return FALSE;
        }
    }
    else {

        //
        // Use MIGISOL for this DLL.
        //
    }

    return TRUE;




}



BOOL
MigDllOpenA (
    OUT PMIGRATIONDLLA DllData,
    IN PCSTR DllPath,
    IN BOOL MigrationMode,
    IN BOOL Isolated,
    IN BOOL SourceOs
    )
{
    BOOL valid = FALSE;
    PSTR p;

    MYASSERT (DllData);

    ZeroMemory (DllData, sizeof (MIGRATIONDLL));

    if (SourceOs == SOURCEOS_WINNT && WinVerifyTrustProc) {

        //
        // See if the migration dll is signed.
        //

        if (!IsDllSignedA (WinVerifyTrustProc, DllPath)) {
            return FALSE;
        }
    }

    //
    // Fill in basic bool flags in structure.
    //
    DllData->Isolated = Isolated;
    DllData->MigrationMode = MigrationMode;
    DllData->SourceOs = SourceOs;
    DllData->SrcUnicode = TRUE; // Assume UNICODE until proven false.
    DllData->OldStyle = FALSE; // Assume new migration dll.


    StringCopy (DllData->Properties.DllPath, DllPath);
    p = strrchr (DllData->Properties.DllPath, '\\');
    if (p) {
        *p = 0;
        StringCopy (DllData->Properties.WorkingDirectory, DllData->Properties.DllPath);
        StringCopy (DllData->Properties.SourceMedia, DllData->Properties.DllPath);
        *p = '\\';
    }

    if (!Isolated) {

        DllData->Library = LoadLibraryA (DllPath);
        if (!DllData->Library) {
            return FALSE;
        }

        //
        //  See if this dll contains required entry points and test for various state (old style, srcunicode, etc.)
        //
        valid = pTestDllA (DllData, SourceOs);

        if (!valid) {

            MigDllClose (DllData);
            DEBUGMSGA ((DBG_MIGDLLS, "Migration DLL %s does not contain required entry points.", DllPath));
            return FALSE;
        }



    }
    else {

        //
        // Still need to test the dll to gather basic state. Open and close.
        //
        DllData->Library = LoadLibraryA (DllPath);
        if (!DllData->Library) {
            return FALSE;
        }

        //
        //  See if this dll contains required entry points and test for various state (old style, srcunicode, etc.)
        //
        valid = pTestDllA (DllData, SourceOs);




        MigDllClose (DllData);
        DllData->Library = NULL;

        if (!valid) {
            return FALSE;
        }


        if (!IpcOpenA (
                MigrationMode == GATHERMODE ? TRUE : FALSE,
                g_MigIsolPathA,
                DllPath,
                DllData->Properties.WorkingDirectory
                )) {

            LOG ((
                LOG_WARNING,
                "Can't establish IPC connection for %s",
                DllPath
                ));

            return FALSE;
        }
    }

    return TRUE;
}


BOOL
MigDllInitializeSrcA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR NativeSource,
    IN PCSTR MediaDir,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    P_INITIALIZE_SRC_A InitializeSrc;
    CHAR WorkingDirCopy[MAX_PATH];
    CHAR MediaDirCopy [MAX_PATH];
    PSTR SourceListCopy;
    BOOL success = FALSE;
    DWORD rc;



    MYASSERT (DllData);
    MYASSERT (WorkingDir);
    MYASSERT (NativeSource);

    if (!DllData->Isolated) {

        SetCurrentDirectory (WorkingDir);

        //
        // Make copies of all the args so malicious dlls can't modify the strings.
        //

        StringCopyA (WorkingDirCopy, WorkingDir);
        StringCopyA (MediaDirCopy, MediaDir);
        SourceListCopy = DuplicateTextA (NativeSource);

        __try {

            if (DllData->OldStyle) {
                success = CallInitialize9x (DllData, WorkingDirCopy, SourceListCopy, (PVOID) MediaDirCopy, SizeOfString (MediaDirCopy));
            }
            else {
                if (!DllData->Library) {
                    DEBUGMSGA ((DBG_ERROR, "InitializeSrc called before Migration DLL opened."));
                    return FALSE;
                }

                InitializeSrc = (P_INITIALIZE_SRC_A) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCA);
                if (!InitializeSrc) {
                    DEBUGMSGA ((DBG_ERROR, "Could not get address for InitializeSrc."));
                    return FALSE;
                }

                rc = InitializeSrc (WorkingDirCopy, SourceListCopy, MediaDirCopy, Reserved);

                if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                    SetLastError (rc);
                }
            }

        }
        __finally {
            FreeText (SourceListCopy);
        }
    }
    else {

        if (DllData->OldStyle) {
            success = CallInitialize9x (DllData, WorkingDir, NativeSource, (PVOID) MediaDir, SizeOfString (MediaDir));
        }
    }

    return success;
}

BOOL
MigDllInitializeSrcW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDir,
    IN PCWSTR NativeSource,
    IN PCWSTR MediaDir,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    P_INITIALIZE_SRC_W InitializeSrcW;
    P_INITIALIZE_SRC_A InitializeSrcA;
    WCHAR WorkingDirCopy[MAX_WCHAR_PATH];
    WCHAR MediaDirCopy [MAX_WCHAR_PATH];
    PWSTR SourceListCopy;
    BOOL success = FALSE;
    DWORD rc;
    PCSTR ansiWorkingDir;
    PCSTR ansiSourceList;
    PCSTR ansiMediaDir;



    MYASSERT (DllData);
    MYASSERT (WorkingDir);
    MYASSERT (NativeSource);

    if (!DllData->Isolated) {

        SetCurrentDirectoryW (WorkingDir);

        //
        // Make copies of all the args so malicious dlls can't modify the strings.
        //

        StringCopyW (WorkingDirCopy, WorkingDir);
        StringCopyW (MediaDirCopy, MediaDir);
        SourceListCopy = DuplicateTextW (NativeSource);

        __try {

            if (DllData->OldStyle) {
                return FALSE;
            }
            else {
                if (!DllData->Library) {
                    DEBUGMSGW ((DBG_ERROR, "InitializeSrc called before Migration DLL opened."));
                    return FALSE;
                }

                if (DllData->SrcUnicode) {

                    InitializeSrcW = (P_INITIALIZE_SRC_W) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCW);
                    if (!InitializeSrcW) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for InitializeSrc."));
                        return FALSE;
                    }

                    __try {
                        rc = InitializeSrcW (WorkingDirCopy, SourceListCopy, MediaDirCopy, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_INITIALIZE_SRCW
                            ));
                        rc = ERROR_NOT_INSTALLED;
                    }
                }
                else {

                    InitializeSrcA = (P_INITIALIZE_SRC_A) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCA);
                    if (!InitializeSrcA) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for InitializeSrc."));
                        return FALSE;
                    }

                    ansiWorkingDir = ConvertWtoA (WorkingDirCopy);
                    ansiSourceList = ConvertWtoA (SourceListCopy);
                    ansiMediaDir = ConvertWtoA (MediaDirCopy);

                    __try {
                        rc = InitializeSrcA (ansiWorkingDir, ansiSourceList, ansiMediaDir, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_INITIALIZE_SRCA
                            ));
                        rc = ERROR_NOT_INSTALLED;
                    }

                    FreeConvertedStr (ansiWorkingDir);
                    FreeConvertedStr (ansiSourceList);
                    FreeConvertedStr (ansiMediaDir);
                }

                if (rc == ERROR_SUCCESS) {
                    success = TRUE;
                }
                else if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                    SetLastError (rc);
                }
            }
        }
        __finally {
            FreeTextW (SourceListCopy);
        }
    }

    return success;
}





BOOL
MigDllGatherUserSettingsA (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize

    )
{
    CHAR userNameBuf[MAX_USER_NAME];
    PSTR userNameCopy = NULL;
    CHAR unattendTxtCopy[MAX_USER_NAME];
    HKEY userHandle;
    P_GATHER_USER_SETTINGS_A GatherUserSettings;
    DWORD rc;
    BOOL success = FALSE;

    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //

        if (UserName && *UserName) {
            userNameCopy = userNameBuf;
            StringCopyA (userNameCopy, UserName);
        }

        StringCopyA (unattendTxtCopy, UnattendTxt);

        MYASSERT(UserKey);
        if (!UserKey) {
            UserKey = "";
        }

        userHandle = OpenRegKeyStr (UserKey);
        if (!userHandle) {
            DEBUGMSGA ((DBG_WHOOPS, "Cannot open %s", UserKey));
            return FALSE;
        }

        __try {

            //
            // Pass oldstyle migration dlls off to the appropriate function.
            //
            if (DllData->OldStyle) {

                success = CallMigrateUser9x (DllData, UserKey, userNameCopy, unattendTxtCopy, Reserved, ReservedSize);
            }
            else {

                if (!DllData->Library) {
                    DEBUGMSGA ((DBG_ERROR, "GatherUserSettings called before Migration DLL opened."));
                    return FALSE;
                }

                GatherUserSettings = (P_GATHER_USER_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSA);
                if (!GatherUserSettings) {
                    DEBUGMSGA ((DBG_ERROR, "Could not get address for GatherUserSettings."));
                    return FALSE;
                }

                rc = GatherUserSettings (unattendTxtCopy, userHandle, userNameCopy, Reserved);

                if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                    SetLastError (rc);
                }
            }
        }
        __finally {

            CloseRegKey (userHandle);
        }
    }
    else {

        if (DllData->OldStyle) {

            success = CallMigrateUser9x (DllData, UserKey, UserName, UnattendTxt, Reserved, ReservedSize);
        }
    }

    return TRUE;
}

BOOL
MigDllGatherUserSettingsW (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UserKey,
    IN      PCWSTR UserName,
    IN      PCWSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize

    )
{
    WCHAR userNameBuf[MAX_USER_NAME];
    PWSTR userNameCopy = NULL;
    WCHAR unattendTxtCopy[MAX_USER_NAME];
    HKEY userHandle;
    P_GATHER_USER_SETTINGS_W GatherUserSettingsW;
    P_GATHER_USER_SETTINGS_A GatherUserSettingsA;
    DWORD rc;
    BOOL success = FALSE;
    PCSTR ansiUserName;
    PCSTR ansiUnattendTxt;

    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //

        if (UserName && *UserName) {
            userNameCopy = userNameBuf;
            StringCopyW (userNameCopy, UserName);
        }

        StringCopyW (unattendTxtCopy, UnattendTxt);

        MYASSERT(UserKey);
        if (!UserKey) {
            UserKey = L"";
        }

        userHandle = OpenRegKeyStrW (UserKey);
        if (!userHandle) {
            DEBUGMSGW ((DBG_WHOOPS, "Cannot open %s", UserKey));
            return FALSE;
        }

        __try {

            //
            // Pass oldstyle migration dlls off to the appropriate function.
            //
            if (DllData->OldStyle) {

                return FALSE;
            }
            else {

                if (!DllData->Library) {
                    DEBUGMSGW ((DBG_ERROR, "GatherUserSettings called before Migration DLL opened."));
                    return FALSE;
                }

                if (DllData->SrcUnicode) {

                    GatherUserSettingsW = (P_GATHER_USER_SETTINGS_W) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSW);
                    if (!GatherUserSettingsW) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for GatherUserSettings."));
                        return FALSE;
                    }

                    __try {
                        rc = GatherUserSettingsW (unattendTxtCopy, userHandle, userNameCopy, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_GATHER_USER_SETTINGSW
                            ));
                    }
                }
                else {

                    GatherUserSettingsA = (P_GATHER_USER_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSA);
                    if (!GatherUserSettingsA) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for GatherUserSettings."));
                        return FALSE;
                    }

                    ansiUnattendTxt = ConvertWtoA (unattendTxtCopy);
                    ansiUserName = ConvertWtoA (userNameCopy);

                    __try {
                        rc = GatherUserSettingsA (ansiUnattendTxt, userHandle, ansiUserName, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_GATHER_USER_SETTINGSA
                            ));
                    }

                    FreeConvertedStr (ansiUnattendTxt);
                    FreeConvertedStr (ansiUserName);
                }

                if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                    SetLastError (rc);
                }
            }
        }
        __finally {

            CloseRegKey (userHandle);
        }
    }

    return TRUE;
}



BOOL
MigDllGatherSystemSettingsA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    DWORD rc;
    BOOL success = TRUE;
    CHAR answerFileCopy [MAX_PATH];
    P_GATHER_SYSTEM_SETTINGS_A GatherSystemSettings;


    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //
        StringCopyA (answerFileCopy, AnswerFile);

        if (DllData->OldStyle) {
            success = CallMigrateSystem9x (DllData, answerFileCopy, Reserved, ReservedSize);
        }
        else {

            if (!DllData->Library) {
                DEBUGMSGA ((DBG_ERROR, "GatherSystemSettings called before Migration DLL opened."));
                return FALSE;
            }

            GatherSystemSettings = (P_GATHER_SYSTEM_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA);
            if (!GatherSystemSettings) {
                DEBUGMSGA ((DBG_ERROR, "Could not get address for GatherSystemSettings."));
                return FALSE;
            }

            rc = GatherSystemSettings (answerFileCopy, Reserved);

            if (rc == ERROR_NOT_INSTALLED) {
                success = FALSE;
                SetLastError (ERROR_SUCCESS);
            }
            else if (rc != ERROR_SUCCESS) {
                success = FALSE;
                SetLastError (rc);
            }
        }
    }
    else {

        if (DllData->OldStyle) {
            success = CallMigrateSystem9x (DllData, AnswerFile, Reserved, ReservedSize);
        }
    }

    return success;
}


BOOL
MigDllGatherSystemSettingsW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    DWORD rc;
    BOOL success = TRUE;
    WCHAR answerFileCopy [MAX_WCHAR_PATH];
    P_GATHER_SYSTEM_SETTINGS_W GatherSystemSettingsW;
    P_GATHER_SYSTEM_SETTINGS_A GatherSystemSettingsA;
    PCSTR ansiAnswerFile;


    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //
        StringCopyW (answerFileCopy, AnswerFile);

        if (DllData->OldStyle) {
            return FALSE;
        }
        else {

            if (!DllData->Library) {
                DEBUGMSGW ((DBG_ERROR, "GatherSystemSettings called before Migration DLL opened."));
                return FALSE;
            }

            if (DllData->SrcUnicode) {

                GatherSystemSettingsW = (P_GATHER_SYSTEM_SETTINGS_W) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW);
                if (!GatherSystemSettingsW) {
                    DEBUGMSGW ((DBG_ERROR, "Could not get address for GatherSystemSettings."));
                    return FALSE;
                }

                __try {
                    rc = GatherSystemSettingsW (answerFileCopy, Reserved);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    DEBUGMSGW ((
                        DBG_MIGDLLS,
                        "Migration DLL %s threw an exception in %hs",
                        DllData->Properties.DllPath,
                        PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW
                        ));
                    rc = ERROR_NOT_INSTALLED;
                }
            }
            else {

                GatherSystemSettingsA = (P_GATHER_SYSTEM_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA);
                if (!GatherSystemSettingsA) {
                    DEBUGMSGW ((DBG_ERROR, "Could not get address for GatherSystemSettings."));
                    return FALSE;
                }

                ansiAnswerFile = ConvertWtoA (answerFileCopy);

                __try {
                    rc = GatherSystemSettingsA (ansiAnswerFile, Reserved);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    DEBUGMSGW ((
                        DBG_MIGDLLS,
                        "Migration DLL %s threw an exception in %hs",
                        DllData->Properties.DllPath,
                        PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA
                        ));
                    rc = ERROR_NOT_INSTALLED;
                }

                FreeConvertedStr (ansiAnswerFile);
            }

            if (rc == ERROR_NOT_INSTALLED) {
                success = FALSE;
                SetLastError (ERROR_SUCCESS);
            }
            else if (rc != ERROR_SUCCESS) {
                success = FALSE;
                SetLastError (rc);
            }
        }
    }

    return success;
}



BOOL
MigDllInitializeDstW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDir,
    IN PCWSTR NativeSource,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    P_INITIALIZE_DST_W InitializeDstW;
    P_INITIALIZE_DST_A InitializeDstA;
    WCHAR WorkingDirCopy[MAX_WCHAR_PATH];
    PCWSTR p;
    PWSTR SourceListCopy;
    BOOL success = FALSE;
    DWORD rc;
    PCSTR ansiWorkingDir;
    PCSTR ansiSourceList;



    MYASSERT (DllData);
    MYASSERT (WorkingDir);
    MYASSERT (NativeSource);

    if (!DllData->Isolated) {

        SetCurrentDirectoryW (WorkingDir);

        //
        // Make copies of all the args so malicious dlls can't modify the strings.
        //

        StringCopyW (WorkingDirCopy, WorkingDir);

        p = NativeSource;
        while (*p) {
            p = GetEndOfStringW (p) + 1;
        }
        p++;

        SourceListCopy = AllocTextW (p - NativeSource);
        if (SourceListCopy) {
            CopyMemory (SourceListCopy, NativeSource, (p - NativeSource) * sizeof (WCHAR));
        }

        __try {

            if (DllData->OldStyle) {

                success = CallInitializeNt (DllData, WorkingDirCopy, SourceListCopy, Reserved, ReservedSize);
            }
            else {

                if (!DllData->Library) {
                    DEBUGMSGW ((DBG_ERROR, "InitializeSrc called before Migration DLL opened."));
                    return FALSE;
                }

                if (DllData->SrcUnicode) {

                    InitializeDstW = (P_INITIALIZE_DST_W) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTW);
                    if (!InitializeDstW) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for InitializeSrc."));
                        return FALSE;
                    }

                    __try {
                        rc = InitializeDstW (WorkingDirCopy, SourceListCopy, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_INITIALIZE_DSTW
                            ));
                    }
                }
                else {

                    InitializeDstA = (P_INITIALIZE_DST_A) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTA);
                    if (!InitializeDstA) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for InitializeSrc."));
                        return FALSE;
                    }


                    ansiWorkingDir = ConvertWtoA (WorkingDirCopy);
                    ansiSourceList = ConvertWtoA (SourceListCopy);

                    __try {
                        rc = InitializeDstA (ansiWorkingDir, ansiSourceList, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_INITIALIZE_DSTA
                            ));
                    }

                    FreeConvertedStr (ansiWorkingDir);
                    FreeConvertedStr (ansiSourceList);

                }

                SetLastError (rc);

                if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                }
            }
        }
        __finally {
            FreeTextW (SourceListCopy);
        }
    }
    else {

        if (DllData->OldStyle) {

            success = CallInitializeNt (DllData, WorkingDir, NativeSource, Reserved, ReservedSize);
        }
    }


    return success;
}

BOOL
MigDllApplyUserSettingsW (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR WorkingDir,
    IN      PCWSTR UserKey,
    IN      PCWSTR UserName,
    IN      PCWSTR UserDomain,
    IN      PCWSTR FixedUserName,
    IN      PCWSTR UnattendTxt,
    IN      PCWSTR UserProfilePath,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize

    )
{
    WCHAR userNameBuf[MAX_USER_NAME];
    WCHAR fixedUserNameBuf[MAX_USER_NAME];
    WCHAR userDomainBuf[MAX_WCHAR_PATH];
    WCHAR orgUserProfilePath[MAX_WCHAR_PATH];
    PWSTR userDomainCopy = NULL;
    PWSTR userNameCopy = NULL;
    PWSTR fixedUserNameCopy = NULL;
    HINF unattendInf = NULL;
    HKEY userHandle;
    P_APPLY_USER_SETTINGS_W ApplyUserSettingsW;
    P_APPLY_USER_SETTINGS_A ApplyUserSettingsA;
    DWORD rc;
    BOOL success = FALSE;
    PCSTR ansiUserName;
    PCSTR ansiUserDomainName;
    PCSTR ansiFixedUserName;


    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //

        if (UserName && *UserName) {
            userNameCopy = userNameBuf;
            StringCopyW (userNameCopy, UserName);
        }


        if (FixedUserName && *FixedUserName) {
            fixedUserNameCopy = fixedUserNameBuf;
            StringCopyW (fixedUserNameCopy, FixedUserName);
        }

        if (UserDomain && *UserDomain) {
            userDomainCopy = userDomainBuf;
            StringCopyW (userDomainCopy, UserDomain);
        }




        //
        // Pass oldstyle migration dlls off to the appropriate function.
        //
        if (DllData->OldStyle) {

            success = CallMigrateUserNt (
                            DllData,
                            UnattendTxt,
                            UserKey,
                            userNameCopy,
                            userDomainCopy,
                            fixedUserNameCopy,
                            UserProfilePath,
                            Reserved,
                            ReservedSize
                            );
        }
        else {


            MYASSERT(UserKey);
            if (!UserKey) {
                UserKey = L"";
            }

            userHandle = OpenRegKeyStrW (UserKey);
            if (!userHandle) {
                DEBUGMSGW ((DBG_WHOOPS, "Cannot open %s", UserKey));
                return FALSE;
            }

            __try {

                GetEnvironmentVariableW (S_USERPROFILEW, orgUserProfilePath, MAX_WCHAR_PATH);
                SetEnvironmentVariableW (S_USERPROFILEW, UserProfilePath);
                SetCurrentDirectoryW (WorkingDir);


                if (!DllData->Library) {
                    DEBUGMSGW ((DBG_ERROR, "ApplyUserSettings called before Migration DLL opened."));
                    return FALSE;
                }

                if (DllData->SrcUnicode) {

                    ApplyUserSettingsW = (P_APPLY_USER_SETTINGS_W) GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSW);
                    if (!ApplyUserSettingsW) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for ApplyUserSettings."));
                        return FALSE;
                    }


                    rc = ApplyUserSettingsW (
                            unattendInf,
                            userHandle,
                            userNameCopy,
                            userDomainCopy,
                            fixedUserNameCopy,
                            Reserved
                            );
                }
                else {


                    ApplyUserSettingsA = (P_APPLY_USER_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSA);
                    if (!ApplyUserSettingsA) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for ApplyUserSettings."));
                        return FALSE;
                    }

                    ansiUserName = ConvertWtoA (userNameCopy);
                    ansiUserDomainName = ConvertWtoA (userDomainCopy);
                    ansiFixedUserName = ConvertWtoA (fixedUserNameCopy);

                    rc = ApplyUserSettingsA (
                            unattendInf,
                            userHandle,
                            ansiUserName,
                            ansiUserDomainName,
                            ansiFixedUserName,
                            Reserved
                            );

                    FreeConvertedStr (ansiUserName);
                    FreeConvertedStr (ansiUserDomainName);
                    FreeConvertedStr (ansiFixedUserName);



                }

                SetLastError (rc);

                if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;

                }

                SetEnvironmentVariableW (S_USERPROFILEW, orgUserProfilePath);

            }
            __finally {
                CloseRegKey (userHandle);
            }
        }
    }
    else {
        if (DllData->OldStyle) {

            success = CallMigrateUserNt (
                            DllData,
                            UnattendTxt,
                            UserKey,
                            UserName,
                            UserDomain,
                            FixedUserName,
                            UserProfilePath,
                            Reserved,
                            ReservedSize
                            );
        }

    }


    return TRUE;
}


BOOL
MigDllApplySystemSettingsW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDirectory,
    IN PCWSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    DWORD rc;
    BOOL success = TRUE;
    HINF infHandle = NULL;
    P_APPLY_SYSTEM_SETTINGS_W ApplySystemSettingsW;
    P_APPLY_SYSTEM_SETTINGS_A ApplySystemSettingsA;


    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //
        SetCurrentDirectoryW (WorkingDirectory);


        if (DllData->OldStyle) {
            success = CallMigrateSystemNt (DllData, AnswerFile, Reserved, ReservedSize);
        }
        else {

            //infHandle = SetupOpenInfFileW (AnswerFile, NULL,  INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);

            if (!DllData->Library) {
                DEBUGMSGW ((DBG_ERROR, "ApplySystemSettings called before Migration DLL opened."));
                return FALSE;
            }

            if (DllData->SrcUnicode) {

                ApplySystemSettingsW = (P_APPLY_SYSTEM_SETTINGS_W) GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSW);
                if (!ApplySystemSettingsW) {
                    DEBUGMSGW ((DBG_ERROR, "Could not get address for ApplySystemSettings."));
                    return FALSE;
                }

                rc = ApplySystemSettingsW (infHandle, Reserved);

            }
            else {

                ApplySystemSettingsA = (P_APPLY_SYSTEM_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSA);
                if (!ApplySystemSettingsA) {
                    DEBUGMSGW ((DBG_ERROR, "Could not get address for ApplySystemSettings."));
                    return FALSE;
                }

                rc = ApplySystemSettingsA (infHandle, Reserved);
            }

            SetLastError (rc);
            if (rc == ERROR_NOT_INSTALLED) {
                success = FALSE;
                SetLastError (ERROR_SUCCESS);
            }
            else if (rc != ERROR_SUCCESS) {
                success = FALSE;
            }

            //SetupCloseInfFile (infHandle);
        }
    }
    else {

        if (DllData->OldStyle) {
            success = CallMigrateSystemNt (DllData, AnswerFile, Reserved, ReservedSize);
        }
    }

    return success;
}



BOOL
MigDllQueryMigrationInfoA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    OUT PMIGRATIONINFOA * MigInfo
    )
{

    BOOL success = TRUE;
    DWORD rc = ERROR_NOT_INSTALLED;
    P_QUERY_MIGRATION_INFO_A QueryMigrationInfo;
    PMIGRATIONINFOA AMigInfo;

    MYASSERT (DllData);
    MYASSERT (WorkingDirectory);
    MYASSERT (MigInfo);


    //
    // Validate parameters.
    //
    if (!DllData || !WorkingDirectory || !MigInfo) {
        return FALSE;
    }

    if (DllData->OldStyle) {
        //
        // Windows 2000 style migration DLL, pass this off to the correct function.
        //

        AMigInfo = MemAllocZeroed (sizeof (MIGRATIONINFOA));
        AMigInfo->Size = sizeof (MIGRATIONINFOA);
        *MigInfo = AMigInfo;


        success =  CallQueryVersion (DllData, WorkingDirectory, AMigInfo);
        rc = GetLastError ();
        if (rc == ERROR_NOT_INSTALLED) {
            success = TRUE;
        }

    }
    else if (!DllData->Isolated) {

        if (!DllData->Library) {
            DEBUGMSGA ((DBG_ERROR, "QueryMigrationInfo called before Migration DLL opened."));
            return FALSE;
        }

        QueryMigrationInfo = (P_QUERY_MIGRATION_INFO_A) GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOA);
        if (!QueryMigrationInfo) {
            DEBUGMSGA ((DBG_ERROR, "Could not get address for QueryMigrationInfo."));
            return FALSE;
        }

        //
        // Call the function.
        //
        rc = QueryMigrationInfo (MigInfo);

    } else {
        //
        // running in isolated mode not implemented; should never get here
        //
        MYASSERT (FALSE);
    }

    if (rc == ERROR_SUCCESS) {

        success = TRUE;


        //
        // Trim whitespace off of product ID
        //

        if (ValidateNonNullStringA ((*MigInfo)->StaticProductIdentifier)) {
            (*MigInfo)->StaticProductIdentifier = SkipSpace ((*MigInfo)->StaticProductIdentifier);
            if (ValidateBinary ((PBYTE) ((*MigInfo)->StaticProductIdentifier), SizeOfStringA ((*MigInfo)->StaticProductIdentifier))) {
                TruncateTrailingSpace ((PSTR) ((*MigInfo)->StaticProductIdentifier));
            }
        }

        //
        // Validate inbound parameters
        //

        if (!ValidateNonNullStringA ((*MigInfo)->StaticProductIdentifier) ||
            !ValidateIntArray ((*MigInfo)->CodePageArray) ||
            !ValidateBinary ((PBYTE) ((*MigInfo)->VendorInfo), sizeof (VENDORINFO))
            ) {
            LOG ((LOG_ERROR, "One or more parameters from the DLL are invalid."));
            return FALSE;
        }

        if (!IsCodePageArrayValid ((*MigInfo)->CodePageArray)) {
            return FALSE;
        }

        //
        // Trim the product ID
        //

        if (ByteCountA ((*MigInfo)->StaticProductIdentifier) > MAX_PATH) {
            *CharCountToPointerA ((*MigInfo)->StaticProductIdentifier, MAX_PATH) = 0;
        }

        //
        // Make sure VENDORINFO is valid
        //
        if (!((*MigInfo)->VendorInfo)) {
            LOG ((LOG_ERROR, "DLL %s did not provide a VENDORINFO struct", (*MigInfo)->StaticProductIdentifier));
            return FALSE;
        }

        //
        // Copy in data to DllData structure.
        //
        CopyMemory (&DllData->Properties.Info, *MigInfo, sizeof (MIGRATIONINFOA));

        if ((*MigInfo)->StaticProductIdentifier) {
            DllData->Properties.Info.StaticProductIdentifier = (PCSTR) PmDuplicateStringA (g_MigLibPool, (*MigInfo)->StaticProductIdentifier);
        }

        if ((*MigInfo)->VendorInfo) {
            DllData->Properties.Info.VendorInfo = PmGetAlignedMemory (g_MigLibPool, sizeof (VENDORINFO));
            CopyMemory (DllData->Properties.Info.VendorInfo, (*MigInfo)->VendorInfo, sizeof (VENDORINFO));
        }

    }
    else if (rc != ERROR_NOT_INSTALLED) {
        DEBUGMSGA ((DBG_MIGDLLS, "Migration DLL returned rc = %u", rc));
    }

    return success;
}



BOOL
MigDllQueryMigrationInfoW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDirectory,
    OUT PMIGRATIONINFOW * MigInfo
    )
{

    BOOL success = FALSE;
    DWORD rc = ERROR_NOT_INSTALLED;
    P_QUERY_MIGRATION_INFO_W QueryMigrationInfoW;
    P_QUERY_MIGRATION_INFO_A QueryMigrationInfoA;
    PMIGRATIONINFOA ansiMigInfo;
    PMIGRATIONINFOW unicodeMigInfo;



    //
    // Validate parameters.
    //
    if (!DllData || !WorkingDirectory || !MigInfo) {
        return FALSE;
    }

    if (DllData->OldStyle) {

        return FALSE;

    }
    else if (!DllData->Isolated) {

        if (!DllData->Library) {
            return FALSE;
        }

        if (DllData->SrcUnicode) {

            QueryMigrationInfoW = (P_QUERY_MIGRATION_INFO_W) GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOW);
            if (!QueryMigrationInfoW) {
                return FALSE;
            }

            //
            // Call the function.
            //
            __try {
                rc = QueryMigrationInfoW (MigInfo);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DEBUGMSGW ((
                    DBG_MIGDLLS,
                    "Migration DLL %s threw an exception in %s",
                    DllData->Properties.DllPath,
                    PLUGIN_NEW_QUERY_MIGRATION_INFOW
                    ));
                rc = ERROR_NOT_INSTALLED;
            }


        }
        else {

            QueryMigrationInfoA = (P_QUERY_MIGRATION_INFO_A) GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOA);
            if (!QueryMigrationInfoA) {
                return FALSE;
            }



            //
            // Call the function.
            //
            __try {
                rc = QueryMigrationInfoA (&ansiMigInfo);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DEBUGMSGA ((
                    DBG_MIGDLLS,
                    "Migration DLL %s threw an exception in %s",
                    DllData->Properties.DllPath,
                    PLUGIN_NEW_QUERY_MIGRATION_INFOA
                    ));
                rc = ERROR_NOT_INSTALLED;
            }

            __try {
                //
                // convert miginfo over.
                //
                unicodeMigInfo = MemAllocZeroed (sizeof (MIGRATIONINFOW));
                unicodeMigInfo->Size = sizeof (MIGRATIONINFOW);


                if (ValidateNonNullStringA (ansiMigInfo->StaticProductIdentifier)) {
                    unicodeMigInfo->StaticProductIdentifier = ConvertAtoW (ansiMigInfo->StaticProductIdentifier);
                }

                unicodeMigInfo->DllVersion = ansiMigInfo->DllVersion;
                unicodeMigInfo->CodePageArray = ansiMigInfo->CodePageArray;
                unicodeMigInfo->SourceOs = ansiMigInfo->SourceOs;
                unicodeMigInfo->TargetOs = ansiMigInfo->TargetOs;
                unicodeMigInfo->VendorInfo = ansiMigInfo->VendorInfo;

                *MigInfo = unicodeMigInfo;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DEBUGMSGA ((
                    DBG_MIGDLLS,
                    "MigDllQueryMigrationInfoW: exception while converting data from %s",
                    DllData->Properties.DllPath
                    ));
                rc = ERROR_NOT_INSTALLED;
            }

        }
    } else {
        //
        // running in isolated mode not implemented; should never get here
        //
        MYASSERT (FALSE);
    }

    if (rc == ERROR_SUCCESS) {

        success = TRUE;


        //
        // Trim whitespace off of product ID
        //

        if (ValidateNonNullStringW ((*MigInfo)->StaticProductIdentifier)) {
            (*MigInfo)->StaticProductIdentifier = SkipSpaceW ((*MigInfo)->StaticProductIdentifier);
            if (ValidateBinary ((PBYTE) ((*MigInfo)->StaticProductIdentifier), SizeOfStringW ((*MigInfo)->StaticProductIdentifier))) {
                TruncateTrailingSpaceW ((PWSTR) ((*MigInfo)->StaticProductIdentifier));
            }
        }

        //
        // Validate inbound parameters
        //

        if (!ValidateNonNullStringW ((*MigInfo)->StaticProductIdentifier) ||
            !ValidateIntArray ((*MigInfo)->CodePageArray) ||
            !ValidateBinary ((PBYTE) ((*MigInfo)->VendorInfo), sizeof (VENDORINFO))
            ) {
            LOG ((LOG_ERROR, "One or more parameters from the DLL are invalid."));
            return FALSE;
        }

        if (!IsCodePageArrayValid ((*MigInfo)->CodePageArray)) {
            return FALSE;
        }

        //
        // Trim the product ID
        //

        if (CharCountW ((*MigInfo)->StaticProductIdentifier) > MAX_PATH) {
            *CharCountToPointerW ((*MigInfo)->StaticProductIdentifier, MAX_PATH) = 0;
        }

        //
        // Make sure VENDORINFO is valid
        //
        if (!((*MigInfo)->VendorInfo)) {
            LOG ((LOG_ERROR, "DLL %s did not provide a VENDORINFO struct", (*MigInfo)->StaticProductIdentifier));
            return FALSE;
        }

        //
        // Copy in data to DllData structure.
        //
        CopyMemory (&DllData->Properties.Info, *MigInfo, sizeof (MIGRATIONINFOW));

        if ((*MigInfo)->StaticProductIdentifier) {
            DllData->Properties.Info.StaticProductIdentifier = (PCWSTR) PmDuplicateStringW (g_MigLibPool, (*MigInfo)->StaticProductIdentifier);
        }

        if ((*MigInfo)->VendorInfo) {
            DllData->Properties.Info.VendorInfo = PmGetAlignedMemory (g_MigLibPool, sizeof (VENDORINFO));
            CopyMemory (DllData->Properties.Info.VendorInfo, (*MigInfo)->VendorInfo, sizeof (VENDORINFO));
        }

    }
    else if (rc != ERROR_NOT_INSTALLED) {
        DEBUGMSGA ((DBG_MIGDLLS, "Migration DLL returned rc = %u", rc));
    }


    return success;
}


BOOL
MigDllEnumNextA (
    IN OUT PMIGDLLENUMA Enum
    )
{
    Enum->Properties = (PMIGDLLPROPERTIESA) GlGetItem ((PGROWLIST) Enum->List, Enum->NextItem);
    Enum->NextItem++;



    return Enum->Properties != NULL;
}


BOOL
MigDllEnumNextW (
    IN OUT PMIGDLLENUMW Enum
    )
{

    if (GlGetSize ((PGROWLIST) Enum->List) == 0) {
        return FALSE;
    }

    Enum->Properties = (PMIGDLLPROPERTIESW) GlGetItem ((PGROWLIST) Enum->List, Enum->NextItem);
    Enum->NextItem++;



    return Enum->Properties != NULL;
}



BOOL
MigDllEnumFirstA (
    OUT PMIGDLLENUMA Enum,
    IN DLLLIST List
    )
{

    MYASSERT (List);
    MYASSERT (Enum);

    if (!List || !Enum) {
        return FALSE;
    }



    ZeroMemory (Enum, sizeof(MIGDLLENUMA));

    Enum->NextItem = 0;
    Enum->List = List;


    return MigDllEnumNextA (Enum);
}

BOOL
MigDllEnumFirstW (
    OUT PMIGDLLENUMW Enum,
    IN DLLLIST List
    )
{

    MYASSERT (List);
    MYASSERT (Enum);

    if (!List || !Enum) {
        return FALSE;
    }



    ZeroMemory (Enum, sizeof(MIGDLLENUMW));

    Enum->NextItem = 0;
    Enum->List = List;


    return MigDllEnumNextW (Enum);
}



DLLLIST
MigDllCreateList (
    VOID
    )
{
    PGROWLIST newList;

    newList = (PGROWLIST) MemAllocZeroed (sizeof (GROWLIST));

    return (DLLLIST) newList;
}


VOID
MigDllFreeList (
    DLLLIST List
    )
{
    if (List) {

        GlFree ((PGROWLIST) List);
        Free (List);
    }
}


BOOL
MigDllAddDllToListA (
    IN DLLLIST List,
    IN PMIGRATIONDLLA MigrationDll
    )
{

    MYASSERT (List);
    MYASSERT (MigrationDll);

    if (!List || !MigrationDll) {
        return FALSE;
    }

    GlAppend ((PGROWLIST) List, (PBYTE) &MigrationDll->Properties, sizeof (MIGDLLPROPERTIESA));

    return TRUE;
}


BOOL
MigDllAddDllToListW (
    IN DLLLIST List,
    IN PMIGRATIONDLLW MigrationDll
    )
{

    MYASSERT (List);
    MYASSERT (MigrationDll);

    if (!List || !MigrationDll) {
        return FALSE;
    }

    GlAppend ((PGROWLIST) List, (PBYTE) &MigrationDll->Properties, sizeof (MIGDLLPROPERTIESW));

    return TRUE;
}



BOOL
MigDllRemoveDllFromListA (
    IN DLLLIST List,
    IN PCSTR ProductId
    )
{


    int i;
    int size;
    PMIGDLLPROPERTIESA item;

    MYASSERT (ProductId);
    MYASSERT (List);

    if (!List || !ProductId) {
        return FALSE;
    }

    size = GlGetSize ((PGROWLIST) List);

    for (i = 0; i < size; i++) {

        item = (PMIGDLLPROPERTIESA) GlGetItem ((PGROWLIST) List, i);
        if (StringIMatchA (item->Info.StaticProductIdentifier, ProductId)) {
            GlDeleteItem ((PGROWLIST) List, i);
            return TRUE;
        }
    }

    return TRUE;

}

BOOL
MigDllRemoveDllFromListW (
    IN DLLLIST List,
    IN PCWSTR ProductId
    )
{


    int i;
    int size;
    PMIGDLLPROPERTIESW item;

    MYASSERT (ProductId);
    MYASSERT (List);

    if (!List || !ProductId) {
        return FALSE;
    }

    size = GlGetSize ((PGROWLIST) List);

    for (i = 0; i < size; i++) {

        item = (PMIGDLLPROPERTIESW) GlGetItem ((PGROWLIST) List, i);
        if (StringIMatchW (item->Info.StaticProductIdentifier, ProductId)) {
            GlDeleteItem ((PGROWLIST) List, i);
            return TRUE;
        }
    }

    return TRUE;

}


BOOL
MigDllRemoveDllInEnumFromListA (
    IN DLLLIST List,
    IN PMIGDLLENUMA Enum
    )
{
    MYASSERT (List);
    MYASSERT (Enum);

    Enum->NextItem--;

    return MigDllRemoveDllFromListA (List, Enum->Properties->Info.StaticProductIdentifier);
}

BOOL
MigDllRemoveDllInEnumFromListW (
    IN DLLLIST List,
    IN PMIGDLLENUMW Enum
    )
{
    MYASSERT (List);
    MYASSERT (Enum);

    Enum->NextItem--;

    return MigDllRemoveDllFromListW (List, Enum->Properties->Info.StaticProductIdentifier);
}


INT
MigDllGetDllCountInList (
    IN DLLLIST List
    )
{
    MYASSERT (List);

    return List ? GlGetSize ((PGROWLIST) List) : 0;

}


PMIGDLLPROPERTIESA
MigDllFindDllInListA (
    IN DLLLIST List,
    IN PCSTR ProductId
    )
{

    INT i;
    INT size;
    PMIGDLLPROPERTIESA rProp = NULL;

    MYASSERT (List);
    MYASSERT (ProductId);

    if (!List && !ProductId) {
        return NULL;
    }

    size = GlGetSize ((PGROWLIST) List);
    for (i = 0; i < size; i++) {
        rProp = (PMIGDLLPROPERTIESA) GlGetItem ((PGROWLIST) List, i);
        if (rProp && StringIMatch (rProp->Info.StaticProductIdentifier, ProductId)) {
            break;
        }

        rProp = NULL;
    }

    return rProp;
}


PMIGDLLPROPERTIESW
MigDllFindDllInListW (
    IN DLLLIST List,
    IN PCWSTR ProductId
    )
{

    INT i;
    INT size;
    PMIGDLLPROPERTIESW rProp = NULL;

    MYASSERT (List);
    MYASSERT (ProductId);

    if (!List && !ProductId) {
        return NULL;
    }

    size = GlGetSize ((PGROWLIST) List);
    for (i = 0; i < size; i++) {
        rProp = (PMIGDLLPROPERTIESW) GlGetItem ((PGROWLIST) List, i);
        if (rProp && StringIMatchW (rProp->Info.StaticProductIdentifier, ProductId)) {
            break;
        }

        rProp = NULL;
    }

    return rProp;
}



VOID
MigDllSetMigIsolPathA (
    IN PCSTR Path
    )
{
    MYASSERT (Path);
    StringCopyA (g_MigIsolPathA, Path);
}

VOID
MigDllSetMigIsolPathW (
    IN PCWSTR Path
    )
{
    MYASSERT (Path);
    StringCopyW (g_MigIsolPathW, Path);

}

BOOL
MigDllMoveDllLocallyW (
    IN PMIGRATIONDLLW Dll,
    IN PCWSTR WorkingDir
    )
{
    PWSTR p;
    BOOL bResult;

    FiRemoveAllFilesInTreeW (WorkingDir);

    if (!BfCreateDirectoryW (WorkingDir)) {

        return FALSE;
    }

    p = wcsrchr(Dll->Properties.DllPath, '\\');
    if(p){
        *p = '\0';
        bResult = CopyFilesTreeW(Dll->Properties.DllPath, WorkingDir, L"*.*", FALSE);
        *p = '\\';
        if(!bResult){
            return FALSE;
        }
    }

    StringCopyW (Dll->Properties.WorkingDirectory, WorkingDir);
    StringCopyW (Dll->Properties.DllPath, p);
    FreePathStringW (p);

    return TRUE;
}

BOOL
MigDllInit (
    VOID
    )
{
    UtInitialize (NULL);
    g_MigLibPool = PmCreatePool ();




    return TRUE;
}


VOID
MigDllShutdown (
    VOID
    )
{
    PmDestroyPool (g_MigLibPool);
    UtTerminate ();
    if (g_WinTrustLib && g_WinTrustLib != INVALID_HANDLE_VALUE) {
        FreeLibrary (g_WinTrustLib);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\miglib\migcmn.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migcmn.c

Abstract:

    Repository of functions used between several of the modules in miglib.

Author:

    Marc R. Whitten (marcw) 02-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "miglibp.h"


//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
BOOL
IsCodePageArrayValid (
    IN      PDWORD CodePageArray
    )
{
    DWORD CodePage;
    UINT u;

    if (!CodePageArray) {
        return TRUE;
    }

    //
    // Scan system's code pages
    //

    CodePage = GetACP();

    __try {
        for (u = 0 ; CodePageArray[u] != -1 ; u++) {
            if (CodePage == CodePageArray[u]) {
                return TRUE;
            }
        }
    }
    __except (TRUE) {
        LOG ((LOG_ERROR, "Caught an exception while validating array of code pages."));
    }

    return FALSE;
}


BOOL
ValidateBinary (
    IN      PBYTE Data,
    IN      UINT Size
    )
{
    BYTE Remember;

    if (!Data || !Size) {
        return TRUE;
    }

    __try {
        Remember = Data[0];
        Data[0] = Remember;
        Remember = Data[Size - 1];
        Data[Size - 1] = Remember;
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_MIGDLLS, "ValidateBinary failed for %u bytes", Size));
        return FALSE;
    }

    return TRUE;
}

BOOL
ValidateNonNullStringA (
    IN      PCSTR String
    )
{
    __try {
        SizeOfStringA (String);
        if (*String == 0) {
            return FALSE;
        }
    }
    __except (TRUE) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ValidateNonNullStringW (
    IN      PCWSTR String
    )
{
    __try {
        SizeOfStringW (String);
        if (*String == 0) {
            return FALSE;
        }
    }
    __except (TRUE) {
        return FALSE;
    }

    return TRUE;
}


BOOL
ValidateIntArray (
    IN      PINT Array
    )
{
    PINT End;

    if (!Array) {
        return TRUE;
    }

    __try {
        End = Array;
        while (*End != -1) {
            End++;
        }
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_MIGDLLS, "Int Array is invalid (or not terminated with -1)"));
        return FALSE;
    }

    return TRUE;
}

BOOL
ValidateMultiStringA (
    IN      PCSTR Strings
    )
{
    if (!Strings) {
        return TRUE;
    }

    __try {
        while (*Strings) {
            Strings = GetEndOfStringA (Strings) + 1;
        }
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_MIGDLLS, "ValidateMultiString failed"));
        return FALSE;
    }

    return TRUE;
}

BOOL
ValidateMultiStringW (
    IN      PCWSTR Strings
    )
{
    if (!Strings) {
        return TRUE;
    }

    __try {
        while (*Strings) {
            Strings = GetEndOfStringW (Strings) + 1;
        }
    }
    __except (TRUE) {
        DEBUGMSGW ((DBG_MIGDLLS, "ValidateMultiString failed"));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\miglib\sources.inc ===
!include ..\miglib.mk

MAJORCOMP=setup
MINORCOMP=miglib

# compiler options




SOURCES=    \
    miglib.c \
    oldstyle.c \
    migcmn.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\basefile.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    basefile.c

Abstract:

    Contains simple wrappers for commonly used file i/o functions.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#define INVALID_ATTRIBUTES      0xFFFFFFFF

BOOL
DoesFileExistExA (
    IN      PCSTR Path,
    OUT     PWIN32_FIND_DATAA FindData  OPTIONAL
    );

#define DoesFileExistA(x) DoesFileExistExA (x, NULL)

BOOL
DoesFileExistExW (
    IN      PCWSTR Path,
    OUT     PWIN32_FIND_DATAW FindData  OPTIONAL
    );

#define DoesFileExistW(x) DoesFileExistExW (x, NULL)

BOOL
PathIsDirectoryA (
    IN      PCSTR PathSpec
    );

BOOL
PathIsDirectoryW (
    IN      PCWSTR PathSpec
    );

BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    );

BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    );

PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

#define MapFileIntoMemoryA(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExA(FileName,FileHandle,MapHandle,FALSE)
#define MapFileIntoMemoryW(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExW(FileName,FileHandle,MapHandle,FALSE)

BOOL
UnmapFile (
    IN PCVOID FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    );

BOOL
BfGetTempFileNameA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars
    );

BOOL
BfGetTempFileNameW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars
    );

HANDLE
BfGetTempFile (
    VOID
    );

BOOL
BfSetFilePointer (
    IN      HANDLE File,
    IN      LONGLONG Offset
    );

HANDLE
BfOpenFileA (
    IN      PCSTR FileName
    );

HANDLE
BfOpenFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfCreateFileA (
    IN      PCSTR FileName
    );

HANDLE
BfCreateFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfCreateSharedFileA (
    IN      PCSTR FileName
    );

HANDLE
BfCreateSharedFileW (
    IN      PCWSTR FileName
    );

BOOL
BfSetSizeOfFile (
    HANDLE File,
    LONGLONG Size
    );

BOOL
BfGoToEndOfFile (
    IN      HANDLE File,
    OUT     PLONGLONG FileSize      OPTIONAL
    );

BOOL
BfGetFilePointer (
    IN      HANDLE File,
    OUT     PLONGLONG FilePointer       OPTIONAL
    );

BOOL
BfReadFile (
    IN      HANDLE File,
    OUT     PBYTE Buffer,
    IN      UINT BytesToRead
    );

BOOL
BfWriteFile (
    IN      HANDLE File,
    OUT     PCBYTE Buffer,
    IN      UINT BytesToWrite
    );


BOOL
BfCreateDirectoryA (
    IN      PCSTR FullPath
    );

BOOL
BfCreateDirectoryW (
    IN      PCWSTR FullPath
    );

LONGLONG
BfGetFileSizeA (
    IN      PCSTR FileName
    );

LONGLONG
BfGetFileSizeW (
    IN      PCWSTR FileName
    );

PCSTR
BfGetLongFileNameA (
    IN      PCSTR SrcFileName
    );

BOOL
BfGetLongFileNameExA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    );

PCWSTR
BfGetLongFileNameW (
    IN      PCWSTR SrcFileName
    );

BOOL
BfGetLongFileNameExW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    );

#ifdef UNICODE

#define DoesFileExist                   DoesFileExistW
#define DoesFileExistEx                 DoesFileExistExW
#define PathIsDirectory                 PathIsDirectoryW
#define WriteFileString                 WriteFileStringW
#define MapFileIntoMemory               MapFileIntoMemoryW
#define MapFileIntoMemoryEx             MapFileIntoMemoryExW
#define BfGetTempFileName               BfGetTempFileNameW
#define BfOpenFile                      BfOpenFileW
#define BfCreateFile                    BfCreateFileW
#define BfCreateSharedFile              BfCreateSharedFileW
#define BfCreateDirectory               BfCreateDirectoryW
#define BfGetFileSize                   BfGetFileSizeW
#define BfGetLongFileName               BfGetLongFileNameW
#define BfGetLongFileNameEx             BfGetLongFileNameExW

#else

#define DoesFileExist                   DoesFileExistA
#define DoesFileExistEx                 DoesFileExistExA
#define PathIsDirectory                 PathIsDirectoryA
#define WriteFileString                 WriteFileStringA
#define MapFileIntoMemory               MapFileIntoMemoryA
#define MapFileIntoMemoryEx             MapFileIntoMemoryExA
#define BfGetTempFileName               BfGetTempFileNameA
#define BfOpenFile                      BfOpenFileA
#define BfCreateFile                    BfCreateFileA
#define BfCreateSharedFile              BfCreateSharedFileA
#define BfCreateDirectory               BfCreateDirectoryA
#define BfGetFileSize                   BfGetFileSizeA
#define BfGetLongFileName               BfGetLongFileNameA
#define BfGetLongFileNameEx             BfGetLongFileNameExA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\miglib\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ipc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\basemem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    basemem.h

Abstract:

    Implements macros and declares functions for basic allocation functions.
    Consolidated into this file from debug.h and allutils.h

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:


--*/

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

#define INVALID_PTR             ((PVOID)-1)


//
// Fail-proof memory allocators
//

PVOID SafeHeapAlloc (HANDLE g_hHeap, DWORD Flags, SIZE_T Size);
PVOID SafeHeapReAlloc (HANDLE g_hHeap, DWORD Flags, PVOID OldBlock, SIZE_T Size);

//
// Reusable memory alloc, kind of like a GROWBUFFER but more simple
//

PVOID ReuseAlloc (HANDLE Heap, PVOID OldPtr, DWORD SizeNeeded);
VOID ReuseFree (HANDLE Heap,PVOID Ptr);





#ifdef DEBUG

#define MemAlloc(heap,flags,size) DebugHeapAlloc(__FILE__,__LINE__,heap,flags,size)
#define MemReAlloc(heap,flags,ptr,size) DebugHeapReAlloc(__FILE__,__LINE__,heap,flags,ptr,size)
#define MemFree(heap,flags,ptr) DebugHeapFree(__FILE__,__LINE__,heap,flags,ptr)
#define MemCheck(x) DebugHeapCheck(__FILE__,__LINE__,heap)
#define Free(ptr) DebugHeapFree(__FILE__,__LINE__,g_hHeap,0,ptr)
#define MemAllocUninit(size) DebugHeapAlloc(__FILE__,__LINE__,g_hHeap,0,size)
#define MemAllocZeroed(size) DebugHeapAlloc(__FILE__,__LINE__,g_hHeap,HEAP_ZERO_MEMORY,size)


LPVOID DebugHeapAlloc (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, SIZE_T dwSize);
LPVOID DebugHeapReAlloc (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, LPCVOID pMem, SIZE_T dwSize);
BOOL DebugHeapFree (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, LPCVOID pMem);
void DebugHeapCheck (LPCSTR File, DWORD Line, HANDLE hHeap);

VOID DumpHeapStats (VOID);

SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );

#define MemCheckPtr(heap,ptr)       (DebugHeapValidatePtr(heap,ptr,__FILE__,__LINE__) != INVALID_PTR)


#else

#define MemAlloc SafeHeapAlloc
#define MemReAlloc SafeHeapReAlloc
#define MemFree(x,y,z) HeapFree(x,y,(LPVOID) z)
#define MemCheck(x)
#define Free(ptr) HeapFree(g_hHeap,0,ptr)
#define MemAllocUninit(size) SafeHeapAlloc(g_hHeap,0,size)
#define MemAllocZeroed(size) SafeHeapAlloc(g_hHeap,HEAP_ZERO_MEMORY,size)

#define DebugHeapCheck(x,y,z)
#define DumpHeapStats()

#define MemCheckPtr(heap,ptr)       (1)

#endif


#ifdef _cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\blobs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    blobs.h

Abstract:

    Declares the interface functions to manage BLOBS and arrays of BLOBS.

Author:

    Ovidiu Temereanca (ovidiut)   24-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef enum {
    BDT_NONE        = 0,
    BDT_SZW,
    BDT_SZA,
    BDT_MULTISZW,
    BDT_MULTISZA,
    BDT_DWORD,
    BDT_QWORD,
    BDT_BINARY,
    BDT_LAST
} BLOB_DATA_TYPE;

typedef enum {
    BF_RECORDDATATYPE   = 0x0001,
    BF_RECORDDATASIZE   = 0x0002,
    BF_UNICODESTRINGS   = 0x0004,
} BLOB_FLAGS;

typedef struct {
    PBYTE       Data;
    DWORD       End;
    DWORD       AllocSize;
    DWORD       GrowSize;
    DWORD       Index;
    DWORD       Flags;
    DWORD       UserIndex;
} OURBLOB, *POURBLOB;

typedef struct {
    DWORD       Signature;
    POURBLOB*   Blobs;
    DWORD       BlobsCount;
    DWORD       BlobsAllocated;
    DWORD       BlobsGrowCount;
} BLOBS, *PBLOBS;


typedef struct {
    POURBLOB    CurrentBlob;
    PBLOBS      Array;
    DWORD       Index;
} BLOB_ENUM, *PBLOB_ENUM;


//
// Macros
//

#define OURBLOB_INIT    { NULL, 0, 0, 0, 0, 0, 0 }
#define BLOBS_INIT      { 0, NULL, 0, 0, 0 }


//
// Blob APIs
//

__inline
BOOL
BlobRecordsDataType (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_RECORDDATATYPE;
}

__inline
BOOL
BlobRecordsDataSize (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_RECORDDATASIZE;
}

__inline
BOOL
BlobRecordsUnicodeStrings (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_UNICODESTRINGS;
}

__inline
BOOL
BlobIsEOF (
    IN      POURBLOB Blob
    )
{
    return !Blob->Data || Blob->Index == Blob->End;
}

__inline
PBYTE
BlobGetPointer (
    IN      POURBLOB Blob
    )
{
    return Blob->Data ? Blob->Data + Blob->Index : NULL;
}

__inline
PBYTE
BlobGetEOF (
    IN      POURBLOB Blob
    )
{
    return Blob->Data ? Blob->Data + Blob->End : NULL;
}

__inline
DWORD
BlobGetIndex (
    IN      POURBLOB Blob
    )
{
    return Blob->Index;
}


__inline
DWORD
BlobGetDataSize (
    IN      POURBLOB Blob
    )
{
    return Blob->End;
}

POURBLOB
BlobCreate (
    VOID
    );

POURBLOB
BlobDuplicate (
    IN      POURBLOB SourceBlob
    );

VOID
BlobClear (
    IN OUT  POURBLOB Blob
    );

VOID
BlobDestroy (
    IN OUT  POURBLOB Blob
    );

BOOL
BlobSetIndex (
    IN OUT  POURBLOB Blob,
    IN      DWORD Index
    );

DWORD
BlobGetRecordedDataType (
    IN      POURBLOB Blob
    );

BOOL
BlobWriteEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD DataType,         OPTIONAL
    IN      BOOL RecordDataSize,
    IN      DWORD DataSize,
    IN      PCVOID Data
    );

PBYTE
BlobReadEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD ExpectedDataType,     OPTIONAL
    IN      DWORD ExpectedDataSize,     OPTIONAL
    IN      BOOL RecordedDataSize,
    OUT     PDWORD ActualDataSize,      OPTIONAL
    OUT     PVOID Data,                 OPTIONAL
    IN      PMHANDLE Pool               OPTIONAL
    );

BOOL
BlobWriteDword (
    IN OUT  POURBLOB Blob,
    IN      DWORD Data
    );

BOOL
BlobReadDword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORD Data
    );

BOOL
BlobWriteQword (
    IN OUT  POURBLOB Blob,
    IN      DWORDLONG Data
    );

BOOL
BlobReadQword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORDLONG Data
    );

BOOL
BlobWriteStringA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    );

BOOL
BlobWriteStringW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    );

BOOL
BlobReadStringA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobReadStringW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobWriteMultiSzA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    );

BOOL
BlobWriteMultiSzW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    );

BOOL
BlobReadMultiSzA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobReadMultiSzW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobWriteBinary (
    IN OUT  POURBLOB Blob,
    IN      PBYTE Data,
    IN      DWORD Size
    );

BOOL
BlobReadBinary (
    IN OUT  POURBLOB Blob,
    OUT     PBYTE* Data,
    OUT     PDWORD Size,
    IN      PMHANDLE Pool
    );

BOOL
BlobWriteToFile (
    IN      POURBLOB Blob,
    IN      HANDLE File
    );

BOOL
BlobReadFromFile (
    OUT     POURBLOB Blob,
    IN      HANDLE File
    );

//
// Blob Array APIs
//

__inline
DWORD
BlobsGetCount (
    IN      PBLOBS BlobsArray
    )
{
    return BlobsArray->BlobsCount;
}


BOOL
BlobsAdd (
    IN OUT  PBLOBS BlobsArray,
    IN      POURBLOB Blob
    );


VOID
BlobsFree (
    IN OUT  PBLOBS BlobsArray,
    IN      BOOL DestroyBlobs
    );

BOOL
EnumFirstBlob (
    OUT     PBLOB_ENUM BlobEnum,
    IN      PBLOBS BlobsArray
    );

BOOL
EnumNextBlob (
    IN OUT  PBLOB_ENUM BlobEnum
    );

BOOL
BlobsWriteToFile (
    IN      PBLOBS BlobsArray,
    IN      HANDLE File
    );

BOOL
BlobsReadFromFile (
    OUT     PBLOBS BlobsArray,
    IN      HANDLE File
    );

//
// Macros
//

#ifdef UNICODE

#define BlobWriteString         BlobWriteStringW
#define BlobReadString          BlobReadStringW
#define BlobWriteMultiSz        BlobWriteMultiSzW
#define BlobReadMultiSz         BlobReadMultiSzW

#else

#define BlobWriteString         BlobWriteStringA
#define BlobReadString          BlobReadStringA
#define BlobWriteMultiSz        BlobWriteMultiSzA
#define BlobReadMultiSz         BlobReadMultiSzA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\dbgtrack.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dbgtrack.h

Abstract:

    Implements macros and declares functions for resource tracking apis.
    Split from old debug.h

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:



--*/

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG

#ifndef DEBUG
#define DEBUG
#endif

#endif

#ifdef DEBUG

#ifndef DBG
#define DBG
#endif

#endif



//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

//
// Debug-only constants
//

#ifdef DEBUG

// This option makes fat, slow binaries
#define MEMORY_TRACKING

#define ALLOCATION_TRACKING_DEF , PCSTR File, UINT Line
#define ALLOCATION_TRACKING_CALL ,__FILE__,__LINE__
#define ALLOCATION_TRACKING_INLINE_CALL ,File,Line


#endif



//
// Macros
//

#ifdef DEBUG

#define DISABLETRACKCOMMENT()               DisableTrackComment()
#define ENABLETRACKCOMMENT()                EnableTrackComment()

#define TRACK_BEGIN(type,name)              Track##type(TrackPush(#name,__FILE__,__LINE__) ? (type) 0 : (
#define TRACK_END()                         ))

#define INVALID_POINTER(x)                  x=NULL

#else

#define DISABLETRACKCOMMENT()
#define ENABLETRACKCOMMENT()

#define TRACK_BEGIN(type,name)
#define TRACK_END()

#define INVALID_POINTER(x)

#define ALLOCATION_TRACKING_DEF
#define ALLOCATION_TRACKING_CALL
#define ALLOCATION_TRACKING_INLINE_CALL

#define InitAllocationTracking()
#define FreeAllocationTracking()
#define DebugRegisterAllocation(t,p,f,l)
#define DebugUnregisterAllocation(t,p)

#endif

//
// Types
//

typedef enum {
    MERGE_OBJECT,
    POOLMEM_POINTER,
    POOLMEM_POOL,
    INF_HANDLE
} ALLOCTYPE;



//
// Globals
//

extern PCSTR g_TrackComment;
extern INT g_UseCount;
extern PCSTR g_TrackFile;
extern UINT g_TrackLine;

//
// Macro expansion list
//

#define TRACK_WRAPPERS          \
        DEFMAC(PBYTE)           \
        DEFMAC(DWORD)           \
        DEFMAC(BOOL)            \
        DEFMAC(UINT)            \
        DEFMAC(PCSTR)           \
        DEFMAC(PCWSTR)          \
        DEFMAC(UBINT)           \
        DEFMAC(PVOID)           \
        DEFMAC(PSTR)            \
        DEFMAC(PWSTR)           \
        DEFMAC(HINF)            \
        DEFMAC(PMHANDLE)        \
        DEFMAC(PGROWBUFFER)     \

//
// Public function prototypes
//

#ifdef DEBUG

VOID InitAllocationTracking (VOID);
VOID FreeAllocationTracking (VOID);
VOID DebugRegisterAllocation (ALLOCTYPE Type, PVOID Ptr, PCSTR File, UINT Line);
VOID DebugUnregisterAllocation (ALLOCTYPE Type, PVOID Ptr);
VOID DisableTrackComment (VOID);
VOID EnableTrackComment (VOID);

INT TrackPush (PCSTR Name, PCSTR File, UINT Line);
INT TrackPop (VOID);

#define TRACKPUSH(n,f,l)        TrackPush(n,f,l)
#define TRACKPOP()              TrackPop()

//
// Macro expansion definition
//

#define DEFMAC(type)    __inline type Track##type (type Arg) {TrackPop(); return Arg;}

TRACK_WRAPPERS

#undef DEFMAC


#else       // i.e., if !DEBUG

#define TRACKPUSH(n,f,l)
#define TRACKPOP()

#endif

#ifdef _cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\exclist.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    exclist.h

Abstract:

    Set of APIs to manage exclusion lists of objects of various well-known types.

Author:

    Ovidiu Temereanca (ovidiut)   23-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Macro expansion list
//

#define EXCLUSIONLIST_TYPES                                     \
            DEFMAC(ELT_PATH,            "Path",         TRUE)   \
            DEFMAC(ELT_FILE,            "File",         FALSE)  \
            DEFMAC(ELT_REGKEY,          "RegKey",       TRUE)   \
            DEFMAC(ELT_REGVALUE,        "RegValue",     FALSE)  \

//
// Types
//

#define DEFMAC(TypeId,TypeName,Compound)    TypeId,

typedef enum {
    EXCLUSIONLIST_TYPES     /* , */
    ELT_UNKNOWN
} EL_TYPE;

#undef DEFMAC


//
// API
//

BOOL
ElInitialize (
    VOID
    );

VOID
ElTerminate (
    VOID
    );

EL_TYPE
ElGetTypeId (
    IN      PCSTR TypeName
    );

PCSTR
ElGetTypeName (
    IN      EL_TYPE TypeId
    );

BOOL
ElAddA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR ObjectName
    );

BOOL
ElAddW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR ObjectName
    );

VOID
ElRemoveAllA (
    VOID
    );

VOID
ElRemoveAllW (
    VOID
    );

BOOL
ElIsExcludedA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Object
    );

BOOL
ElIsExcludedW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Object
    );

BOOL
ElIsExcluded2A (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Node,
    IN      PCSTR Leaf              OPTIONAL
    );

BOOL
ElIsExcluded2W (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Node,
    IN      PCWSTR Leaf             OPTIONAL
    );

BOOL
ElIsTreeExcludedA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR TreePattern
    );

BOOL
ElIsTreeExcludedW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR TreePattern
    );

BOOL
ElIsTreeExcluded2A (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Root,
    IN      PCSTR LeafPattern           OPTIONAL
    );

BOOL
ElIsTreeExcluded2W (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Root,
    IN      PCWSTR Leaf             OPTIONAL
    );

BOOL
ElIsObsPatternExcludedA (
    IN      EL_TYPE ObjectType,
    IN      POBSPARSEDPATTERNA Pattern
    );

BOOL
ElIsObsPatternExcludedW (
    IN      EL_TYPE ObjectType,
    IN      POBSPARSEDPATTERNW Pattern
    );

//
// Macros
//

#ifdef UNICODE

#define ElAdd                   ElAddW
#define ElRemoveAll             ElRemoveAllW
#define ElIsExcluded            ElIsExcludedW
#define ElIsExcluded2           ElIsExcluded2W
#define ElIsTreeExcluded        ElIsTreeExcludedW
#define ElIsTreeExcluded2       ElIsTreeExcluded2W
#define ElIsObsPatternExcluded  ElIsObsPatternExcludedW

#else

#define ElAdd                   ElAddA
#define ElRemoveAll             ElRemoveAllA
#define ElIsExcluded            ElIsExcludedA
#define ElIsExcluded2           ElIsExcluded2A
#define ElIsTreeExcluded        ElIsTreeExcludedA
#define ElIsTreeExcluded2       ElIsTreeExcluded2A
#define ElIsObsPatternExcluded  ElIsObsPatternExcludedA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\miglib\miglibp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    migdllsp.h

Abstract:

    Private header for miglib.

Author:

    Marc R. Whitten (marcw) 25-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "plugin.h"
#include "mgdlllib.h"

#define DBG_FOO     "Foo"

//
// Strings
//

#define DBG_MIGDLLS     "MIGDLLS"
#define S_USERPROFILEW L"UserProfile"

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//






typedef LONG (CALLBACK *P_QUERY_MIGRATION_INFO_A)(
                            OUT PMIGRATIONINFOA * Info
                            );

typedef LONG (CALLBACK *P_INITIALIZE_SRC_A)(
                            IN PCSTR WorkingDirectories,
                            IN PCSTR SourceDirectories,
                            IN PCSTR MediaDirectories,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_GATHER_USER_SETTINGS_A)(
                            IN PCSTR AnswerFile,
                            IN HKEY UserRegKey,
                            IN PCSTR UserName,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_GATHER_SYSTEM_SETTINGS_A)(
                            IN PCSTR AnswerFile,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_QUERY_MIGRATION_INFO_W)(
                            OUT PMIGRATIONINFOW * Info
                            );

typedef LONG (CALLBACK *P_INITIALIZE_SRC_W)(
                            IN PCWSTR WorkingDirectories,
                            IN PCWSTR SourceDirectories,
                            IN PCWSTR MediaDirectories,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_GATHER_USER_SETTINGS_W)(
                            IN PCWSTR AnswerFile,
                            IN HKEY UserRegKey,
                            IN PCWSTR UserName,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_GATHER_SYSTEM_SETTINGS_W)(
                            IN PCWSTR AnswerFile,
                            PVOID Reserved
                            );



typedef LONG (CALLBACK *P_INITIALIZE_DST_W)(
                            IN PCWSTR WorkingDirectories,
                            IN PCWSTR SourceDirectories,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_APPLY_USER_SETTINGS_W)(
                            IN HINF AnswerFile,
                            IN HKEY UserRegKey,
                            IN PCWSTR UserName,
                            IN PCWSTR UserDomain,
                            IN PCWSTR FixedUserName,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_APPLY_SYSTEM_SETTINGS_W)(
                            IN PCWSTR AnswerFile,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_INITIALIZE_DST_A)(
                            IN PCSTR WorkingDirectories,
                            IN PCSTR SourceDirectories,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_APPLY_USER_SETTINGS_A)(
                            IN HINF AnswerFile,
                            IN HKEY UserRegKey,
                            IN PCSTR UserName,
                            IN PCSTR UserDomain,
                            IN PCSTR FixedUserName,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_APPLY_SYSTEM_SETTINGS_A)(
                            IN PCSTR AnswerFile,
                            PVOID Reserved
                            );


//
// Globals
//

extern PMHANDLE g_MigLibPool;
extern CHAR g_MigIsolPathA[MAX_MBCHAR_PATH];
extern WCHAR g_MigIsolPathW[MAX_WCHAR_PATH];

//
// Macro expansion list
//

// None

//
// Public function prototypes
//


//
// Oldstyle migration dll entry points.
//

BOOL
CallQueryVersion (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    OUT PMIGRATIONINFOA  MigInfo
    );

BOOL
CallInitialize9x (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR SourceDirList,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
CallMigrateUser9x (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );


BOOL
CallMigrateSystem9x (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UnattendTxt,
    IN      PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
CallInitializeNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR WorkingDir,
    IN      PCWSTR SourceDirArray,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

BOOL
CallMigrateUserNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UnattendFile,
    IN      PCWSTR RootKey,
    IN      PCWSTR Win9xUserName,
    IN      PCWSTR UserDomain,
    IN      PCWSTR FixedUserName,
    IN      PCWSTR UserProfilePath,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

BOOL
CallMigrateSystemNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UnattendFile,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

//
// Helper functions.
//
BOOL
IsCodePageArrayValid (
    IN      PDWORD CodePageArray
    );

BOOL
ValidateBinary (
    IN      PBYTE Data,
    IN      UINT Size
    );

BOOL
ValidateNonNullStringA (
    IN      PCSTR String
    );

BOOL
ValidateNonNullStringW (
    IN      PCWSTR String
    );


BOOL
ValidateIntArray (
    IN      PINT Array
    );

BOOL
ValidateMultiStringA (
    IN      PCSTR Strings
    );

BOOL
ValidateMultiStringW (
    IN      PCWSTR Strings
    );


//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\growbuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growbuf.h

Abstract:

    Implements the GROWBUFFER data type, a dynamically allocated buffer
    that grows (and potentially changes addresses).  GROWBUFFERs are
    typically used to maintain dynamic sized arrays, or multi-sz lists.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/



typedef struct TAG_GROWBUFFER {
    PBYTE Buf;
    DWORD Size;
    DWORD End;
    DWORD GrowSize;
    DWORD UserIndex;        // Unused by Growbuf. For caller use.
} GROWBUFFER;

#define INIT_GROWBUFFER {NULL,0,0,0,0}

PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD SpaceNeeded
    );

#define GbGrow(buf,size)    TRACK_BEGIN(PBYTE, GbGrow)\
                            RealGbGrow(buf,size)\
                            TRACK_END()

VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    );


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbMultiSzAppendA(buf,str)   TRACK_BEGIN(BOOL, GbMultiSzAppendA)\
                                    RealGbMultiSzAppendA(buf,str)\
                                    TRACK_END()

BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbMultiSzAppendW(buf,str)   TRACK_BEGIN(BOOL, GbMultiSzAppendW)\
                                    RealGbMultiSzAppendW(buf,str)\
                                    TRACK_END()

BOOL
RealGbMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    );

#define GbMultiSzAppendValA(buf,k,v)    TRACK_BEGIN(BOOL, GbMultiSzAppendValA)\
                                        RealGbMultiSzAppendValA(buf,k,v)\
                                        TRACK_END()

BOOL
RealGbMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    );

#define GbMultiSzAppendValW(buf,k,v)    TRACK_BEGIN(BOOL, GbMultiSzAppendValW)\
                                        RealGbMultiSzAppendValW(buf,k,v)\
                                        TRACK_END()

BOOL
RealGbMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    );

#define GbMultiSzAppendStringA(buf,k,v)     TRACK_BEGIN(BOOL, GbMultiSzAppendStringA)\
                                            RealGbMultiSzAppendStringA(buf,k,v)\
                                            TRACK_END()

BOOL
RealGbMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    );

#define GbMultiSzAppendStringW(buf,k,v)     TRACK_BEGIN(BOOL, GbMultiSzAppendStringW)\
                                            RealGbMultiSzAppendStringW(buf,k,v)\
                                            TRACK_END()

BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    );

#define GbAppendDword(buf,d)        TRACK_BEGIN(BOOL, GbAppendDword)\
                                    RealGbAppendDword(buf,d)\
                                    TRACK_END()

BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID p
    );

#define GbAppendPvoid(buf,p)        TRACK_BEGIN(BOOL, GbAppendPvoid)\
                                    RealGbAppendPvoid(buf,p)\
                                    TRACK_END()


BOOL
RealGbAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbAppendStringA(buf,str)    TRACK_BEGIN(BOOL, GbAppendStringA)\
                                    RealGbAppendStringA(buf,str)\
                                    TRACK_END()

BOOL
RealGbAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbAppendStringW(buf,str)    TRACK_BEGIN(BOOL, GbAppendStringW)\
                                    RealGbAppendStringW(buf,str)\
                                    TRACK_END()


BOOL
RealGbAppendStringABA (
    PGROWBUFFER GrowBuf,
    PCSTR Start,
    PCSTR EndPlusOne
    );

#define GbAppendStringABA(buf,a,b)      TRACK_BEGIN(BOOL, GbAppendStringABA)\
                                        RealGbAppendStringABA(buf,a,b)\
                                        TRACK_END()

BOOL
RealGbAppendStringABW (
    PGROWBUFFER GrowBuf,
    PCWSTR Start,
    PCWSTR EndPlusOne
    );

#define GbAppendStringABW(buf,a,b)      TRACK_BEGIN(BOOL, GbAppendStringABW)\
                                        RealGbAppendStringABW(buf,a,b)\
                                        TRACK_END()



BOOL
RealGbCopyStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbCopyStringA(buf,str)      TRACK_BEGIN(BOOL, GbCopyStringA)\
                                    RealGbCopyStringA(buf,str)\
                                    TRACK_END()

BOOL
RealGbCopyStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbCopyStringW(buf,str)      TRACK_BEGIN(BOOL, GbCopyStringW)\
                                    RealGbCopyStringW(buf,str)\
                                    TRACK_END()

#ifdef UNICODE

#define GbMultiSzAppend             GbMultiSzAppendW
#define GbMultiSzAppendVal          GbMultiSzAppendValW
#define GbMultiSzAppendString       GbMultiSzAppendStringW
#define GbAppendString              GbAppendStringW
#define GbAppendStringAB            GbAppendStringABW
#define GbCopyString                GbCopyStringW

#else

#define GbMultiSzAppend             GbMultiSzAppendA
#define GbMultiSzAppendVal          GbMultiSzAppendValA
#define GbMultiSzAppendString       GbMultiSzAppendStringA
#define GbAppendString              GbAppendStringA
#define GbAppendStringAB            GbAppendStringABA
#define GbCopyString                GbCopyStringA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\miglib\oldstyle.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    oldstyle.c

Abstract:

    Implements entry points for handling old style (Windows 2000 era) migration dlls.
    Culled from code in the win95upg project.

Author:

    Marc R. Whitten (marcw) 25-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "miglibp.h"
#include "plugin.h"


//
// Strings
//



//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PBYTE g_Data;
DWORD g_DataSize;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
VOID
pSetCwd (
    OUT     PWSTR SavedWorkDir,
    IN      PCWSTR NewWorkDir
    )
{
    GetCurrentDirectoryW (MAX_WCHAR_PATH, SavedWorkDir);
    SetCurrentDirectoryW (NewWorkDir);
}

VOID
pFreeGlobalIpcBuffer (
    VOID
    )
{
    //
    // Free old return param buffer
    //
    if (g_Data) {
        MemFree (g_hHeap, 0, g_Data);
        g_Data = NULL;
    }

    g_DataSize = 0;
}

DWORD
pFinishHandshake (
    IN      PCTSTR FunctionName
    )
{
    DWORD TechnicalLogId;
    DWORD GuiLogId;
    DWORD rc = ERROR_SUCCESS;
    BOOL b;
    UINT Count = 40;            // about 5 minutes
    UINT AliveAllowance = 10;   // about 30 minutes

    do {
        //
        // No OUT parameters on the NT side, so we don't care
        // about the return data
        //

        b = IpcGetCommandResults (
                IPC_GET_RESULTS_NT,
                NULL,
                NULL,
                &rc,
                &TechnicalLogId,
                &GuiLogId
                );

        //
        // Loop if no data received, but process is alive
        //

        if (!b) {
            if (!IpcProcessAlive()) {
                rc = ERROR_NOACCESS;
                break;
            }

            // continue if command was not sent yet but exe is still OK
            Count--;
            if (Count == 0) {
            /*
                if (WaitForSingleObject (g_AliveEvent, 0) == WAIT_OBJECT_0) {
                    DEBUGMSG ((DBG_WARNING, "Alive allowance given to migration DLL"));

                    AliveAllowance--;
                    if (AliveAllowance) {
                        Count = 24;        // about 3 minutes
                    }
                }
             */
                if (Count == 0) {
                    rc = ERROR_SEM_TIMEOUT;
                    break;
                }
            }
        }

    } while (!b);


    return rc;
}


DWORD
pFinishHandshake9x(
    VOID
    )
{
    DWORD TechnicalLogId;
    DWORD GuiLogId;
    DWORD rc = ERROR_SUCCESS;
    DWORD DataSize = 0;
    PBYTE Data = NULL;
    BOOL b;

    pFreeGlobalIpcBuffer();

    do {
        b = IpcGetCommandResults (
                IPC_GET_RESULTS_WIN9X,
                &Data,
                &DataSize,
                &rc,
                &TechnicalLogId,
                &GuiLogId
                );

        //
        // Loop if no data received, but process is alive
        //
        if (!b) {
            if (!IpcProcessAlive()) {
                rc = ERROR_NOACCESS;
                break;
            }


        }

    } while (!b);

    if (b) {
        //
        // Save return param block and loop back for IPC_LOG or IPC_DONE
        //

        g_DataSize = DataSize;
        g_Data = Data;


    }

    return rc;
}



BOOL
CallQueryVersion (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    OUT PMIGRATIONINFOA  MigInfo
    )
{

    P_QUERY_VERSION QueryVersion;
    DWORD rc;
    GROWBUFFER GrowBuf = INIT_GROWBUFFER;
    PBYTE DataPtr;
    INT ReturnArraySize;
    PDWORD ReturnArray;
    PCTSTR p;
    DWORD DataSize;


    MigInfo->StaticProductIdentifier = NULL;
    MigInfo->DllVersion = 1;
    MigInfo->NeededFileList = NULL;
    MigInfo->VendorInfo = NULL;
    MigInfo->SourceOs = OS_WINDOWS9X;
    MigInfo->TargetOs = OS_WINDOWS2000;

    if (!DllData->Isolated) {

        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "QueryVersion called before Migration DLL opened."));
            return FALSE;
        }

        QueryVersion = (P_QUERY_VERSION) GetProcAddress (DllData->Library, PLUGIN_QUERY_VERSION);
        if (!QueryVersion) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for QueryVersion."));
            return FALSE;
        }

        //
        // Call the function.
        //
        rc = QueryVersion (
                &MigInfo->StaticProductIdentifier,
                &MigInfo->DllVersion,
                &MigInfo->CodePageArray,
                MigInfo->NeededFileList,
                &MigInfo->VendorInfo
                );

        SetLastError (rc);

        if (rc != ERROR_SUCCESS && rc != ERROR_NOT_INSTALLED) {
            return FALSE;
        }

    }
    else {

        //
        // Isolated call.
        //
        pFreeGlobalIpcBuffer();

    __try {

            //
            // Send the working directory, since migisol will need to set this before
            // calling QueryVersion.
            //

            GbMultiSzAppendA (&GrowBuf, WorkingDirectory);

            DEBUGMSG ((DBG_MIGDLLS, "Calling QueryVersion via migisol.exe"));

            if (!IpcSendCommand (
                    IPC_QUERY,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR,"pRemoteQueryVersion failed to send command"));
                rc = GetLastError();
                __leave;
            }

            //
            // Finish transaction. Caller will interpret return code.
            //

            rc = pFinishHandshake9x();
            SetLastError (rc);

            if (rc != ERROR_SUCCESS && rc != ERROR_NOT_INSTALLED) {
                return FALSE;
            }


            //
            // Unpack the buffer, if received.
            //
            if (g_Data) {

                DEBUGMSG ((DBG_MIGDLLS, "Parsing QueryVersion return data"));

                __try {
                    DataPtr = g_Data;

                    //
                    // Unpack product ID
                    //
                    MigInfo->StaticProductIdentifier = DataPtr;
                    DataPtr = GetEndOfStringA ((PCSTR) DataPtr) + 1;

                    //
                    // Unpack DLL version
                    //
                    MigInfo->DllVersion = *((PINT) DataPtr);
                    DataPtr += sizeof(INT);

                    //
                    // Unpack the CP array
                    //
                    ReturnArraySize = *((PINT) DataPtr);
                    DataPtr += sizeof(INT);

                    if (ReturnArraySize) {
                        ReturnArray = (PDWORD) DataPtr;
                        DataPtr += ReturnArraySize * sizeof (DWORD);
                    } else {
                        ReturnArray = NULL;
                    }

                    MigInfo->CodePageArray = ReturnArray;

                    //
                    // Unpack Exe name buffer
                    //
                    MigInfo->NeededFileList = (PSTR *) DataPtr;

                    if (MigInfo->NeededFileList && *MigInfo->NeededFileList) {
                        p = *MigInfo->NeededFileList;
                        while (p && *p) {
                        p = GetEndOfStringA (p) + 1;
                        }
                        DataPtr = (PBYTE) (p + 1);
                    }

                    MigInfo->VendorInfo = ((PVENDORINFO) DataPtr);
                    DataPtr += sizeof (PVENDORINFO);

                    DEBUGMSG ((DBG_MIGDLLS, "Unpacked VendorInfo pointer is 0x%X", *MigInfo->VendorInfo));

                    if (MigInfo->VendorInfo) {
                        DataSize = *((PDWORD) DataPtr);
                        DataPtr += sizeof (DWORD);
                        MYASSERT (DataSize == sizeof (VENDORINFO));

                        MigInfo->VendorInfo = (PVENDORINFO) PmDuplicateMemory (g_MigLibPool, DataPtr, sizeof (VENDORINFO));
                        DataPtr += sizeof (VENDORINFO);
                    }

                    DEBUGMSG ((DBG_MIGDLLS, "QueryVersion is complete, rc=%u", rc));
                }

                __except(TRUE) {
                    LOG ((LOG_ERROR, "An error occurred while unpacking params"));
                    rc = ERROR_INVALID_PARAMETER;
                }
            } else {
                DEBUGMSG ((DBG_WARNING, "pRemoteQueryVersion: No OUT params received"));

                //
                // We should never return ERROR_SUCCESS if no buffer is received.
                //
                if (rc == ERROR_SUCCESS) {
                    SetLastError (ERROR_INVALID_PARAMETER);

                }

                return FALSE;
            }
        }
        __finally {
            GbFree (&GrowBuf);
        }



    }

    return TRUE;
}

BOOL
CallInitialize9x (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR SourceDirList,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    P_INITIALIZE_9X Initialize9x;
    CHAR WorkingDirCopy[MAX_PATH];
    PCSTR p;
    PSTR SourceDirListCopy;
    DWORD rc;
    GROWBUFFER GrowBuf = INIT_GROWBUFFER;
    PBYTE Data;
    DWORD ReturnSize;


    MYASSERT (DllData);
    MYASSERT (WorkingDir);
    MYASSERT (SourceDirList);

    if (!DllData->Isolated) {

        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "Initialize9x called before Migration DLL opened."));
            return FALSE;
        }

        Initialize9x = (P_INITIALIZE_9X) GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_9X);
        if (!Initialize9x) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for Initialize9x."));
            return FALSE;
        }

        //
        // Call the entry point directly
        //

        SetCurrentDirectory (WorkingDir);

        //
        // Make a copy of all the supplied params, so if the migration DLL changes
        // them, the rest of the upgrade isn't messed up.
        //

        StringCopyA (WorkingDirCopy, WorkingDir);

        p = SourceDirList;
        while (*p) {
            p = GetEndOfStringA (p) + 1;
        }
        p++;

        SourceDirListCopy = AllocText (p - SourceDirList);
        MYASSERT (SourceDirListCopy);
        if (SourceDirListCopy) {
            CopyMemory (SourceDirListCopy, SourceDirList, p - SourceDirList);
        }

        //
        // Call the entry point
        //

        rc = Initialize9x (WorkingDirCopy, SourceDirListCopy, Reserved);

        FreeText (SourceDirListCopy);

        //
        // If DLL returns ERROR_NOT_INSTALLED, do not call it any further
        // If DLL returns something other than ERROR_SUCCESS, abandon the DLL
        //

        if (rc == ERROR_NOT_INSTALLED) {
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        } else if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            DEBUGMSG ((DBG_MIGDLLS, "DLL failed in Initialize9x with rc=%u", rc));
            return FALSE;
        }
    }
    else {


        //
        // Call the entry point via migisol.exe.
        //

        pFreeGlobalIpcBuffer();

        __try {
            //
            // Send working dir and source dirs
            //
            GbMultiSzAppendA (&GrowBuf, WorkingDir);

            for (p = SourceDirList ; *p ; p = GetEndOfStringA (p) + 1) {
                GbMultiSzAppendA (&GrowBuf, p);
            }

            GbMultiSzAppendA (&GrowBuf, p);
            GbAppendDword (&GrowBuf, ReservedSize);

            if (ReservedSize) {
                Data = GbGrow (&GrowBuf, ReservedSize);
                CopyMemory (Data, Reserved, ReservedSize);
            }

            //
            // Send command to migisol
            //

            rc = ERROR_SUCCESS;

            if (!IpcSendCommand (
                    IPC_INITIALIZE,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR,"pRemoteInitialize9x failed to send command"));
                rc = GetLastError();
                __leave;
            }

            //
            // Finish transaction. Caller will interpret return code.
            //
            rc = pFinishHandshake9x();
            SetLastError (rc);

            //
            // The reserved parameter may come back
            //

            if (g_Data) {
                Data = g_Data;
                ReturnSize = *((PDWORD) Data);
                if (ReturnSize) {
                    Data += sizeof (DWORD);
                    CopyMemory (Reserved, Data, ReturnSize);
                } else if (ReservedSize) {
                    ZeroMemory (Reserved, ReservedSize);
                }
            }
        }
        __finally {
            GbFree (&GrowBuf);
        }


        //
        // CopyOfReserved now has the return value.  We don't
        // use it currently.
        //

    }


    return rc == ERROR_SUCCESS;

}


BOOL
CallMigrateUser9x (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    )
{
    LONG rc;
    P_MIGRATE_USER_9X MigrateUser9x;
    GROWBUFFER GrowBuf = INIT_GROWBUFFER;
    HKEY userHandle;


    if (!DllData->Isolated) {

        //
        // Call the entry point directly
        //
        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "MigrateUser9x called before Migration DLL opened."));
            return FALSE;
        }

        MigrateUser9x = (P_MIGRATE_USER_9X) GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_9X);
        if (!MigrateUser9x) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for MigrateUser9x."));
            return FALSE;
        }

        userHandle = OpenRegKeyStr (UserKey);
        if (!userHandle) {
            DEBUGMSG ((DBG_WHOOPS, "Cannot open %s", UserKey));
            return FALSE;
        }

        //
        // Call the migration DLL
        //

        rc = MigrateUser9x (
                NULL,
                UnattendTxt,
                userHandle,
                UserName,
                Reserved
                );

    } else {


        //
        // Call the entry point via migisol.exe
        //

        pFreeGlobalIpcBuffer();

        __try {

            GbMultiSzAppendA (&GrowBuf, TEXT(""));
            GbAppendDword (&GrowBuf, 0);
            GbMultiSzAppendA (&GrowBuf, UnattendTxt);
            GbMultiSzAppendA (&GrowBuf, UserKey);
            GbMultiSzAppendA (&GrowBuf, (NULL == UserName ? "" : UserName));

            if (!IpcSendCommand (
                     IPC_MIGRATEUSER,
                     GrowBuf.Buf,
                     GrowBuf.End
                     )) {

                LOG ((LOG_ERROR, "pRemoteMigrateUser9x failed to send command"));
                rc = GetLastError();
                __leave;
            }

            //
            // Complete the transaction. The caller will interpret the return
            // value.
            //
            rc = pFinishHandshake9x();

            //
            // No data buffer is coming back at this time
            //
        }

        __finally {
            GbFree (&GrowBuf);
        }
    }

    if (rc == ERROR_NOT_INSTALLED) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in MigrateUser9x with rc=%u", rc));
        return FALSE;
    }

    return TRUE;
}

BOOL
CallMigrateSystem9x (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UnattendTxt,
    IN      PVOID Reserved,
    IN      DWORD ReservedSize
    )
{
    LONG rc;
    P_MIGRATE_SYSTEM_9X MigrateSystem9x;
    GROWBUFFER GrowBuf = INIT_GROWBUFFER;


    if (!DllData->Isolated) {

        //
        // Call the entry point directly
        //
        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "MigrateSystem9x called before Migration DLL opened."));
            return FALSE;
        }

        MigrateSystem9x = (P_MIGRATE_SYSTEM_9X) GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_9X);
        if (!MigrateSystem9x) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for MigrateSystem9x."));
            return FALSE;
        }



        rc = MigrateSystem9x (
                 NULL,
                 UnattendTxt,
                 Reserved
                 );

    } else {

        pFreeGlobalIpcBuffer();

        __try {
            GbMultiSzAppendA (&GrowBuf, "");
            GbAppendDword (&GrowBuf, 0);
            GbMultiSzAppendA (&GrowBuf, UnattendTxt);

            if (!IpcSendCommand (
                    IPC_MIGRATESYSTEM,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR,"pRemoteMigrateSystem9x failed to send command"));
                rc = GetLastError();
                __leave;
            }

            //
            // Finish transaction. Caller will interpret return value.
            //

            rc = pFinishHandshake9x();
            SetLastError (rc);

            //
            // No data buffer is coming back at this time
            //
        }

        __finally {
            GbFree (&GrowBuf);
        }
    }

    if (rc == ERROR_NOT_INSTALLED) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in MigrateSystem9x with rc=%u", rc));
        return FALSE;
    }

    return TRUE;

}


BOOL
CallInitializeNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR WorkingDir,
    IN      PCWSTR SourceDirArray,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    P_INITIALIZE_NT InitializeNt;
    INT Count;
    PBYTE BufPtr;
    PDWORD ReservedBytesPtr;
    WCHAR SavedCwd [MAX_WCHAR_PATH];
    PWSTR p;
    GROWBUFFER GrowBuf = INIT_GROWBUFFER;




    if (!DllData->Isolated) {

        *SavedCwd = 0;
        pSetCwd (
            SavedCwd,       // old
            WorkingDir      // new
            );

        __try {
            //
            // Call the entry point directly
            //
            if (!DllData->Library) {
                DEBUGMSG ((DBG_ERROR, "InitializeNt called before Migration DLL opened."));
                return FALSE;
            }

            InitializeNt = (P_INITIALIZE_NT) GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_NT);
            if (!InitializeNt) {
                DEBUGMSG ((DBG_ERROR, "Could not get address for InitializeNt."));
                return FALSE;
            }

            //
            // Prepare multi-sz directory list
            //


            rc = InitializeNt (WorkingDir, SourceDirArray, Reserved);

        }
        __finally {
            if (*SavedCwd) {
                SetCurrentDirectoryW (SavedCwd);
            }
        }
    }
    else {
        __try {

            GbMultiSzAppendW (&GrowBuf, WorkingDir);

            //
            // Prepare multi-sz directory list
            //

            p = (PWSTR) SourceDirArray;
            while (p && *p) {
                GbMultiSzAppendW (&GrowBuf, p);
                p = GetEndOfStringW (p) + 1;
            }

            GbMultiSzAppendW (&GrowBuf, L"");

            ReservedBytesPtr = (PDWORD) GbGrow (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GbGrow (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!IpcSendCommand (
                    IPC_INITIALIZE,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR, "Call InitializeNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("InitializeNT"));

            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call InitializeNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }

        }
        __finally {
            GbFree (&GrowBuf);
        }
    }

    SetLastError (rc);

    if (rc != ERROR_SUCCESS) {

        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in InitializeNt with rc=%u", rc));
        return FALSE;
    }

    return TRUE;
}


BOOL
CallMigrateUserNt (

    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UnattendFile,
    IN      PCWSTR UserKey,
    IN      PCWSTR Win9xUserName,
    IN      PCWSTR UserDomain,
    IN      PCWSTR FixedUserName,
    IN      PCWSTR UserProfilePath,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes

    )
{
    DWORD rc = ERROR_SUCCESS;
    P_MIGRATE_USER_NT MigrateUserNt;
    GROWBUFFER GrowBuf = INIT_GROWBUFFER;
    PDWORD ReservedBytesPtr;
    PVOID BufPtr;
    WCHAR SavedCwd [MAX_WCHAR_PATH];
    WCHAR UserBuf[MAX_USER_NAME * 3 * sizeof (WCHAR)];
    PWSTR p;
    WCHAR OrgUserProfilePath[MAX_WCHAR_PATH];
    HKEY userHandle;
    HINF unattendInf = NULL;



    if (!DllData->Isolated) {

        //
        // Call the entry point directly
        //
        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "MigrateUserNt called before Migration DLL opened."));
            return FALSE;
        }

        MigrateUserNt = (P_MIGRATE_USER_NT) GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_NT);
        if (!MigrateUserNt) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for MigrateUserNt."));
            return FALSE;
        }


        __try {

            //
            // Transfer user, user domain and fixed name to a buffer
            //

            if (Win9xUserName) {
                StringCopyW (UserBuf, Win9xUserName);
            } else {
                UserBuf[0] = 0;
            }

            p = GetEndOfStringW (UserBuf) + 1;

            if (UserDomain) {
                StringCopyW (p, UserDomain);
            } else {
                p[0] = 0;
            }

            p = GetEndOfStringW (p) + 1;

            if (FixedUserName) {
                StringCopyW (p, FixedUserName);
            } else {
                p[0] = 0;
            }

            //unattendInf = SetupOpenInfFileW (UnattendFile, NULL,  INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
            MYASSERT(UserKey);
            if (!UserKey) {
                UserKey = L"";
            }

            userHandle = OpenRegKeyStrW (UserKey);
            if (!userHandle) {
                DEBUGMSG ((DBG_WHOOPS, "Cannot open %s", UserKey));
                return FALSE;
            }


            //
            // Call the entry point
            //

            rc = MigrateUserNt (
                        unattendInf,
                        userHandle,
                        UserBuf[0] ? UserBuf : NULL,
                        Reserved
                        );

            CloseRegKey (userHandle);
            //SetupCloseInfFile (unattendInf);


        }
        __finally {
           ;//empty.
        }
    } else {

        __try {
            GbMultiSzAppendW (&GrowBuf, UnattendFile);
            GbMultiSzAppendW (&GrowBuf, UserKey);
            GbMultiSzAppendW (&GrowBuf, Win9xUserName);
            GbMultiSzAppendW (&GrowBuf, UserDomain);
            GbMultiSzAppendW (&GrowBuf, FixedUserName);
            GbMultiSzAppendW (&GrowBuf, UserProfilePath);

            ReservedBytesPtr = (PDWORD) GbGrow (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GbGrow (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!IpcSendCommand (
                    IPC_MIGRATEUSER,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR, "Call MigrateUserNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("MigrateUserNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call MigrateUserNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            GbFree (&GrowBuf);
        }
    }

    SetEnvironmentVariableW (S_USERPROFILEW, OrgUserProfilePath);
    SetLastError (rc);

    if (rc != ERROR_SUCCESS) {
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in MigrateUserNt with rc=%u", rc));
        return FALSE;
    }

    return TRUE;


}


BOOL
CallMigrateSystemNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UnattendFile,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    P_MIGRATE_SYSTEM_NT MigrateSystemNt;
    GROWBUFFER GrowBuf = INIT_GROWBUFFER;
    PDWORD ReservedBytesPtr;
    PVOID BufPtr;
    HINF infHandle = NULL;


    if (!DllData->Isolated) {
        //
        // Call the entry point directly
        //
        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "MigrateSystemNt called before Migration DLL opened."));
            return FALSE;
        }

        MigrateSystemNt = (P_MIGRATE_SYSTEM_NT) GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_NT);
        if (!MigrateSystemNt) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for MigrateSystemNt."));
            return FALSE;
        }

        //infHandle = SetupOpenInfFileW (UnattendFile, NULL,  INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);

        rc = MigrateSystemNt (infHandle, Reserved);

        //SetupCloseInfFile (infHandle);

    }
    else {

        __try {

            GbMultiSzAppendW (&GrowBuf, UnattendFile);

            ReservedBytesPtr = (PDWORD) GbGrow (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GbGrow (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!IpcSendCommand (IPC_MIGRATESYSTEM, GrowBuf.Buf, GrowBuf.End)) {
                LOG ((LOG_ERROR, "Call MigrateSystemNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("MigrateSystemNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call MigrateSystemNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            GbFree (&GrowBuf);
        }

    }

    SetLastError (rc);

    if (rc != ERROR_SUCCESS) {
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in MigrateSysetmNt with rc=%u", rc));
        return FALSE;
    }

    return TRUE;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\hash.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    ovidiut     11-Oct-1999 Updated for new coding conventions and Win64 compliance

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define CASE_SENSITIVE      TRUE
#define CASE_INSENSITIVE    FALSE

//
// Types
//

typedef const void *HASHTABLE;

typedef const void *HASHITEM;

typedef struct {

    PCSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMA, *PHASHTABLE_ENUMA;

typedef struct {
    PCWSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMW, *PHASHTABLE_ENUMW;

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEA)(
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEW)(
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCWSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    );

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes and wrapper macros
//

HASHTABLE
HtAllocExAW (
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT BucketCount            OPTIONAL
    );

#define HtAllocA()                              HtAllocExAW(FALSE,FALSE,0,0)
#define HtAllocW()                              HtAllocExAW(TRUE,FALSE,0,0)

#define HtAllocWithDataA(size)                  HtAllocExAW(FALSE,FALSE,size,0)
#define HtAllocWithDataW(size)                  HtAllocExAW(TRUE,FALSE,size,0)

#define HtAllocExA(datasize,bucketcount)        HtAllocExAW(FALSE,FALSE,size,bucketcount)
#define HtAllocExW(datasize,bucketcount)        HtAllocExAW(TRUE,FALSE,size,bucketcount)

#define HtAllocExternStrA()                     HtAllocExAW(FALSE,TRUE,0,0)
#define HtAllocExternStrW()                     HtAllocExAW(TRUE,TRUE,0,0)

#define HtAllocExternStrWithDataA(size)         HtAllocExAW(FALSE,TRUE,0,0)
#define HtAllocExternStrWithDataW(size)         HtAllocExAW(TRUE,TRUE,0,0)

#define HtAllocExternStrExA(size,bucketcount)   HtAllocExAW(FALSE,TRUE,size,bucketcount)
#define HtAllocExternStrExW(size,bucketcount)   HtAllocExAW(TRUE,TRUE,size,bucketcount)

VOID
HtFree (
    IN      HASHTABLE HashTable
    );

HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtAddStringA(table,string)       HtAddStringExA(table,string,NULL,CASE_INSENSITIVE)

HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtAddStringW(table,string)       HtAddStringExW(table,string,NULL,CASE_INSENSITIVE)

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtFindStringA(table,string)       HtFindStringExA(table,string,NULL,CASE_INSENSITIVE)

HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtFindStringW(table,string)       HtFindStringExW(table,string,NULL,CASE_INSENSITIVE)

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR StringStart,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtFindPrefixA(table,str,end)    HtFindPrefixExA(table,str,end,NULL,CASE_INSENSITIVE)

HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR StringStart,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    );

#define HtFindPrefixW(table,str,end)     HtFindPrefixExW(table,str,end,NULL,CASE_INSENSITIVE)

BOOL
HtGetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    );

BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    );

BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    );

PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    );

PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    );

BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    );

BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    );


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    );

BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    );

BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    );

BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    );

//
// Macro expansion definition
//

// None

//
// A & W macros
//

#ifdef UNICODE

#define HASHTABLE_ENUM              HASHTABLE_ENUMW
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEW
#define HtAlloc                     HtAllocW
#define HtAllocWithData             HtAllocWithDataW
#define HtAllocEx                   HtAllocExW
#define HtAllocExternStr            HtAllocExternStrW
#define HtAllocExternStrWithData    HtAllocExternStrWithDataW
#define HtAllocExternStrEx          HtAllocExternStrExW
#define HtAddString                 HtAddStringW
#define HtAddStringEx               HtAddStringExW
#define HtFindString                HtFindStringW
#define HtFindStringEx              HtFindStringExW
#define HtFindPrefix                HtFindPrefixW
#define HtFindPrefixEx              HtFindPrefixExW
#define HtGetStringFromItem         HtGetStringFromItemW
#define EnumFirstHashTableString    EnumFirstHashTableStringW
#define EnumNextHashTableString     EnumNextHashTableStringW
#define EnumHashTableWithCallback   EnumHashTableWithCallbackW

#else

#define HASHTABLE_ENUM              HASHTABLE_ENUMA
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEA
#define HtAlloc                     HtAllocA
#define HtAllocWithData             HtAllocWithDataA
#define HtAllocEx                   HtAllocExA
#define HtAllocExternStr            HtAllocExternStrA
#define HtAllocExternStrWithData    HtAllocExternStrWithDataA
#define HtAllocExternStrEx          HtAllocExternStrExA
#define HtAddString                 HtAddStringA
#define HtAddStringEx               HtAddStringExA
#define HtFindString                HtFindStringA
#define HtFindStringEx              HtFindStringExA
#define HtFindPrefix                HtFindPrefixA
#define HtFindPrefixEx              HtFindPrefixExA
#define HtGetStringFromItem         HtGetStringFromItemA
#define EnumFirstHashTableString    EnumFirstHashTableStringA
#define EnumNextHashTableString     EnumNextHashTableStringA
#define EnumHashTableWithCallback   EnumHashTableWithCallbackA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\ini.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ini.h

Abstract:

    Declares interface for INI wrapper routines. These routines simplify
    access of INIs by wrapping the Win32 APIs with routines that use pools.

Author:

    04-Nov-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef struct {
    PCSTR   IniFilePath;
    DWORD   OriginalAttributes;
} INIFILEA, *PINIFILEA;

typedef struct {
    PCWSTR  IniFilePath;
    DWORD   OriginalAttributes;
} INIFILEW, *PINIFILEW;


typedef struct {
    PCSTR   CurrentSection;
    PCSTR   Sections;
} INISECT_ENUMA, *PINISECT_ENUMA;

typedef struct {
    PCWSTR  CurrentSection;
    PCWSTR  Sections;
} INISECT_ENUMW, *PINISECT_ENUMW;


typedef struct {
    PCSTR   CurrentKeyValuePair;
    PCSTR   KeyValuePairs;
    PCSTR   CurrentKey;
    PCSTR   CurrentValue;
    PSTR    Private;
} INIKEYVALUE_ENUMA, *PINIKEYVALUE_ENUMA;

typedef struct {
    PCWSTR  CurrentKeyValuePair;
    PCWSTR  KeyValuePairs;
    PCWSTR  CurrentKey;
    PCWSTR  CurrentValue;
    PWSTR   Private;
} INIKEYVALUE_ENUMW, *PINIKEYVALUE_ENUMW;

//
// Public function prototypes
//

BOOL
Ini_Init (
    VOID
    );

VOID
Ini_Exit (
    VOID
    );


BOOL
RealIniFileOpenA (
    OUT     PINIFILEA IniFile,
    IN      PCSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    );

#define IniFileOpenA(i,path,b)  TRACK_BEGIN(BOOL, IniFileOpenA)\
                                RealIniFileOpenA((i),(path),(b)/*,*/ ALLOCATION_TRACKING_CALL)\
                                TRACK_END()

BOOL
RealIniFileOpenW (
    OUT     PINIFILEW IniFile,
    IN      PCWSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    );

#define IniFileOpenW(i,path,b)  TRACK_BEGIN(BOOL, IniFileOpenW)\
                                RealIniFileOpenW((i),(path),(b)/*,*/ ALLOCATION_TRACKING_CALL)\
                                TRACK_END()


VOID
IniFileCloseA (
    IN      PINIFILEA IniFile
    );

VOID
IniFileCloseW (
    IN      PINIFILEW IniFile
    );

BOOL
EnumFirstIniSectionA (
    OUT     PINISECT_ENUMA IniSectEnum,
    IN      PINIFILEA IniFile
    );

BOOL
EnumFirstIniSectionW (
    OUT     PINISECT_ENUMW IniSectEnum,
    IN      PINIFILEW IniFile
    );

BOOL
EnumNextIniSectionA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    );

BOOL
EnumNextIniSectionW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    );

VOID
AbortIniSectionEnumA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    );

VOID
AbortIniSectionEnumW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    );

BOOL
EnumFirstIniKeyValueA (
    OUT     PINIKEYVALUE_ENUMA IniKeyValueEnum,
    IN      PINIFILEA IniFile,
    IN      PCSTR Section
    );

BOOL
EnumFirstIniKeyValueW (
    OUT     PINIKEYVALUE_ENUMW IniKeyValueEnum,
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section
    );

BOOL
EnumNextIniKeyValueA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    );

BOOL
EnumNextIniKeyValueW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    );

VOID
AbortIniKeyValueEnumA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    );

VOID
AbortIniKeyValueEnumW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    );

BOOL
IniReadValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    OUT     PSTR* Value,            OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    );

BOOL
IniReadValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR* Value,           OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    );

VOID
IniFreeReadValueA (
    IN      PCSTR Value
    );

VOID
IniFreeReadValueW (
    IN      PCWSTR Value
    );

BOOL
IniWriteValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    IN      PCSTR Value
    );

BOOL
IniWriteValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    IN      PCWSTR Value
    );


//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#define INIFILE                         INIFILEW
#define INISECT_ENUM                    INISECT_ENUMW
#define INIKEYVALUE_ENUM                INIKEYVALUE_ENUMW

#define IniFileOpen                     IniFileOpenW
#define IniFileClose                    IniFileCloseW
#define EnumFirstIniSection             EnumFirstIniSectionW
#define EnumNextIniSection              EnumNextIniSectionW
#define AbortIniSectionEnum             AbortIniSectionEnumW
#define EnumFirstIniKeyValue            EnumFirstIniKeyValueW
#define EnumNextIniKeyValue             EnumNextIniKeyValueW
#define AbortIniKeyValueEnum            AbortIniKeyValueEnumW
#define IniReadValue                    IniReadValueW
#define IniFreeReadValue                IniFreeReadValueW
#define IniWriteValue                   IniWriteValueW

#else

#define INIFILE                         INIFILEA
#define INISECT_ENUM                    INISECT_ENUMA
#define INIKEYVALUE_ENUM                INIKEYVALUE_ENUMA

#define IniFileOpen                     IniFileOpenA
#define IniFileClose                    IniFileCloseA
#define EnumFirstIniSection             EnumFirstIniSectionA
#define EnumNextIniSection              EnumNextIniSectionA
#define AbortIniSectionEnum             AbortIniSectionEnumA
#define EnumFirstIniKeyValue            EnumFirstIniKeyValueA
#define EnumNextIniKeyValue             EnumNextIniKeyValueA
#define AbortIniKeyValueEnum            AbortIniKeyValueEnumA
#define IniReadValue                    IniReadValueA
#define IniFreeReadValue                IniFreeReadValueA
#define IniWriteValue                   IniWriteValueA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\file\fileenum.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileenum.c

Abstract:

    Implements a set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FILEENUM    "FileEnum"

//
// Strings
//

#define S_FILEENUM      "FILEENUM"

//
// Constants
//

#define NO_OF_LETTERS                   ('Z' - 'A' + 1)
#define ALL_LOGICAL_DRIVES_LENGHT_MAX   (NO_OF_LETTERS * DWSIZEOF ("?:\\") + 1)

//
// Macros
//

#define pFileAllocateMemory(Size)   PmGetMemory (g_FileEnumPool,Size)
#define pFileFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_FileEnumPool, (PVOID)Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_FileEnumPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
FileEnumInitialize (
    VOID
    )

/*++

Routine Description:

    FileEnumInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_FileEnumPool = PmCreateNamedPool (S_FILEENUM);
    return g_FileEnumPool != NULL;
}


VOID
FileEnumTerminate (
    VOID
    )

/*++

Routine Description:

    FileEnumTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    if (g_FileEnumPool) {
        PmDestroyPool (g_FileEnumPool);
        g_FileEnumPool = NULL;
    }
}


/*++

Routine Description:

    EnumFirstDrive enumerates the first fixed drive root

Arguments:

    DriveEnum - Receives info about the first fixed drive root

Return Value:

    TRUE if a drive root was found; FALSE if not

--*/

BOOL
EnumFirstDriveA (
    OUT     PDRIVE_ENUMA DriveEnum,
    IN      UINT WantedDriveTypes
    )
{
    DWORD len;

    DriveEnum->AllLogicalDrives = pFileAllocateMemory (ALL_LOGICAL_DRIVES_LENGHT_MAX * DWSIZEOF (CHAR));
    len = GetLogicalDriveStringsA (
            ALL_LOGICAL_DRIVES_LENGHT_MAX - 1,
            DriveEnum->AllLogicalDrives
            );

    if (!len || len > ALL_LOGICAL_DRIVES_LENGHT_MAX - 1) {
        return FALSE;
    }

    MYASSERT (len <= ALL_LOGICAL_DRIVES_LENGHT_MAX - 1);

    DriveEnum->DriveName = NULL;
    DriveEnum->WantedDriveTypes = WantedDriveTypes;

    return EnumNextDriveA (DriveEnum);
}

BOOL
EnumFirstDriveW (
    OUT     PDRIVE_ENUMW DriveEnum,
    IN      UINT WantedDriveTypes
    )
{
    DWORD len;

    DriveEnum->AllLogicalDrives = pFileAllocateMemory (ALL_LOGICAL_DRIVES_LENGHT_MAX * DWSIZEOF (CHAR));
    len = GetLogicalDriveStringsW (
            ALL_LOGICAL_DRIVES_LENGHT_MAX - 1,
            DriveEnum->AllLogicalDrives
            );

    if (!len || len > ALL_LOGICAL_DRIVES_LENGHT_MAX - 1) {
        return FALSE;
    }

    MYASSERT (len <= ALL_LOGICAL_DRIVES_LENGHT_MAX - 1);

    DriveEnum->DriveName = NULL;
    DriveEnum->WantedDriveTypes = WantedDriveTypes;

    return EnumNextDriveW (DriveEnum);
}


/*++

Routine Description:

    EnumNextDrive enumerates the next fixed drive

Arguments:

    DriveEnum - Specifies info about the previous fixed drive root; receives updated info

Return Value:

    TRUE if a new drive root was found; FALSE if not

--*/

BOOL
EnumNextDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    )
{
    do {
        if (!DriveEnum->DriveName) {
            DriveEnum->DriveName = DriveEnum->AllLogicalDrives;
        } else {
            // Since DriveEnum->DriveName is not NULL, GetEndOfStringA will
            // not return NULL so...
            DriveEnum->DriveName = GetEndOfStringA (DriveEnum->DriveName) + 1;  //lint !e613
        }
        if (*DriveEnum->DriveName == 0) {
            AbortEnumDriveA (DriveEnum);
            return FALSE;
        }

        DriveEnum->DriveType = GetDriveTypeA (DriveEnum->DriveName);

    } while (!(DriveEnum->DriveType & DriveEnum->WantedDriveTypes));

    return TRUE;
}

BOOL
EnumNextDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    )
{
    do {
        if (!DriveEnum->DriveName) {
            DriveEnum->DriveName = DriveEnum->AllLogicalDrives;
        } else {
            DriveEnum->DriveName = GetEndOfStringW (DriveEnum->DriveName) + 1;
        }
        if (*DriveEnum->DriveName == 0) {
            AbortEnumDriveW (DriveEnum);
            return FALSE;
        }

        DriveEnum->DriveType = GetDriveTypeW (DriveEnum->DriveName);

    } while (!(DriveEnum->DriveType & DriveEnum->WantedDriveTypes));

    return TRUE;
}


/*++

Routine Description:

    AbortEnumDrive aborts enumeration of fixed drives

Arguments:

    DriveEnum - Specifies info about the previous fixed drive;
                receives a "clean" context

Return Value:

    none

--*/

VOID
AbortEnumDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    )
{
    if (DriveEnum->AllLogicalDrives) {
        pFileFreeMemory (DriveEnum->AllLogicalDrives);
        DriveEnum->AllLogicalDrives = NULL;
    }
}

VOID
AbortEnumDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    )
{
    if (DriveEnum->AllLogicalDrives) {
        pFileFreeMemory (DriveEnum->AllLogicalDrives);
        DriveEnum->AllLogicalDrives = NULL;
    }
}


/*++

Routine Description:

    pGetFileEnumInfo is a private function that validates and translates the enumeration info
    in an internal form that's more accessible to the enum routines

Arguments:

    FileEnumInfo - Receives the enum info
    EncodedPathPattern - Specifies the encoded dir pattern (encoded as defined by the
                         ParsedPattern functions)
    EnumDirs - Specifies TRUE if directories should be returned during the enumeration
               (if they match the pattern); a directory is returned before any of its
               subdirs or files
    ContainersFirst - Specifies TRUE if directories should be returned before any of its
                      files or subdirs; used only if EnumDirs is TRUE
    FilesFirst - Specifies TRUE if a dir's files should be returned before dir's subdirs;
                 this parameter decides the enum order between files and subdirs
                 for each directory
    DepthFirst - Specifies TRUE if the current subdir of any dir should be fully enumerated
                 before going to the next subdir; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a dir that is to be enumerated, relative to
                  the root; if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    paths/files are excluded from enumeration; this slows down the speed

Return Value:

    TRUE if all params are valid; in this case, FileEnumInfo is filled with the corresponding
         info.
    FALSE otherwise.

--*/

BOOL
pGetFileEnumInfoA (
    OUT     PFILEENUMINFOA FileEnumInfo,
    IN      PCSTR EncodedPathPattern,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions
    )
{
    FileEnumInfo->PathPattern = ObsCreateParsedPatternExA (EncodedPathPattern, FALSE);
    if (!FileEnumInfo->PathPattern) {
        DEBUGMSGA ((DBG_ERROR, "pGetFileEnumInfoA: bad EncodedPathPattern: %s", EncodedPathPattern));
        return FALSE;
    }

    //
    // check for empty filename; no filename will match in this case
    //
    if (FileEnumInfo->PathPattern->Leaf && *FileEnumInfo->PathPattern->Leaf == 0) {
        DEBUGMSGA ((
            DBG_ERROR,
            "pGetFileEnumInfoA: empty filename pattern specified in EncodedPathPattern: %s",
            EncodedPathPattern
            ));
        ObsDestroyParsedPatternA (FileEnumInfo->PathPattern);
        FileEnumInfo->PathPattern = NULL;
        return FALSE;
    }

    if (FileEnumInfo->PathPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsA (
                FileEnumInfo->PathPattern->ExactRoot,
                NULL,
                &FileEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        FileEnumInfo->RootLevel = 1;
    }

    if (!FileEnumInfo->PathPattern->LeafPattern) {
        //
        // no file pattern specified; assume only directory names will be returned
        // overwrite caller's setting
        //
        DEBUGMSGA ((
            DBG_FILEENUM,
            "pGetFileEnumInfoA: no filename pattern specified; forcing EnumDirs to TRUE"
            ));
        EnumDirs = TRUE;
    }

    if (EnumDirs) {
        FileEnumInfo->Flags |= FEIF_RETURN_DIRS;
    }
    if (ContainersFirst) {
        FileEnumInfo->Flags |= FEIF_CONTAINERS_FIRST;
    }
    if (FilesFirst) {
        FileEnumInfo->Flags |= FEIF_FILES_FIRST;
    }
    if (DepthFirst) {
        FileEnumInfo->Flags |= FEIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        FileEnumInfo->Flags |= FEIF_USE_EXCLUSIONS;
    }

    FileEnumInfo->MaxSubLevel = min (MaxSubLevel, FileEnumInfo->PathPattern->MaxSubLevel);

    return TRUE;
}

BOOL
pGetFileEnumInfoW (
    OUT     PFILEENUMINFOW FileEnumInfo,
    IN      PCWSTR EncodedPathPattern,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions
    )
{
    FileEnumInfo->PathPattern = ObsCreateParsedPatternExW (EncodedPathPattern, TRUE);
    if (!FileEnumInfo->PathPattern) {
        DEBUGMSGW ((DBG_ERROR, "pGetFileEnumInfoW: bad EncodedPathPattern: %s", EncodedPathPattern));
        return FALSE;
    }

    //
    // check for empty filename; no filename will match in this case
    //
    if (FileEnumInfo->PathPattern->Leaf && *FileEnumInfo->PathPattern->Leaf == 0) {
        DEBUGMSGW ((
            DBG_ERROR,
            "pGetFileEnumInfoW: empty filename pattern specified in EncodedPathPattern: %s",
            EncodedPathPattern
            ));
        ObsDestroyParsedPatternW (FileEnumInfo->PathPattern);
        FileEnumInfo->PathPattern = NULL;
        return FALSE;
    }

    if (FileEnumInfo->PathPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsW (
                FileEnumInfo->PathPattern->ExactRoot,
                NULL,
                &FileEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        FileEnumInfo->RootLevel = 1;
    }

    if (!FileEnumInfo->PathPattern->LeafPattern) {
        //
        // no file pattern specified; assume only directory names will be returned
        // overwrite caller's setting
        //
        DEBUGMSGW ((
            DBG_FILEENUM,
            "pGetFileEnumInfoW: no filename pattern specified; forcing EnumDirs to TRUE"
            ));
        EnumDirs = TRUE;
    }

    if (EnumDirs) {
        FileEnumInfo->Flags |= FEIF_RETURN_DIRS;
    }
    if (ContainersFirst) {
        FileEnumInfo->Flags |= FEIF_CONTAINERS_FIRST;
    }
    if (FilesFirst) {
        FileEnumInfo->Flags |= FEIF_FILES_FIRST;
    }
    if (DepthFirst) {
        FileEnumInfo->Flags |= FEIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        FileEnumInfo->Flags |= FEIF_USE_EXCLUSIONS;
    }

    FileEnumInfo->MaxSubLevel = min (MaxSubLevel, FileEnumInfo->PathPattern->MaxSubLevel);

    return TRUE;
}


/*++

Routine Description:

    pGetCurrentDirNode returns the current dir node to be enumerated, based on DepthFirst flag

Arguments:

    FileEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be retrieved, regardless of
                  DepthFirst flag

Return Value:

    The current node if any or NULL if none remaining.

--*/

PDIRNODEA
pGetCurrentDirNodeA (
    IN      PFILETREE_ENUMA FileEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &FileEnum->FileNodes;

    if (!gb->Buf || gb->End - gb->UserIndex < DWSIZEOF (DIRNODEA)) {
        return NULL;
    }

    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        return (PDIRNODEA)(gb->Buf + gb->End) - 1;
    } else {
        return (PDIRNODEA)(gb->Buf + gb->UserIndex);
    }
}

PDIRNODEW
pGetCurrentDirNodeW (
    IN      PFILETREE_ENUMW FileEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &FileEnum->FileNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (DIRNODEW)) {
        return NULL;
    }

    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        return (PDIRNODEW)(gb->Buf + gb->End) - 1;
    } else {
        return (PDIRNODEW)(gb->Buf + gb->UserIndex);
    }
}


/*++

Routine Description:

    pDeleteDirNode frees the resources associated with the current dir node and destroys it

Arguments:

    FileEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be deleted, regardless of
                  DepthFirst flag

Return Value:

    TRUE if there was a node to delete, FALSE if no more nodes

--*/

BOOL
pDeleteDirNodeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    IN      BOOL LastCreated
    )
{
    PDIRNODEA dirNode;
    PGROWBUFFER gb = &FileEnum->FileNodes;

    dirNode = pGetCurrentDirNodeA (FileEnum, LastCreated);
    if (!dirNode) {
        return FALSE;
    }

    if (dirNode->DirName) {
        FreeTextExA (g_FileEnumPool, dirNode->DirName);
    }

    if (dirNode->FindHandle) {
        FindClose (dirNode->FindHandle);
        dirNode->FindHandle = NULL;
    }

    if (FileEnum->LastNode == dirNode) {
        FileEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (DIRNODEA);
    } else {
        gb->UserIndex += DWSIZEOF (DIRNODEA);
        //
        // shift list
        //
        if (gb->Size - gb->End < DWSIZEOF (DIRNODEA)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }

    }

    return TRUE;
}

BOOL
pDeleteDirNodeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    IN      BOOL LastCreated
    )
{
    PDIRNODEW dirNode;
    PGROWBUFFER gb = &FileEnum->FileNodes;

    dirNode = pGetCurrentDirNodeW (FileEnum, LastCreated);
    if (!dirNode) {
        return FALSE;
    }

    if (dirNode->DirName) {
        FreeTextExW (g_FileEnumPool, dirNode->DirName);
    }

    if (dirNode->FindHandle) {
        FindClose (dirNode->FindHandle);
        dirNode->FindHandle = NULL;
    }

    if (FileEnum->LastNode == dirNode) {
        FileEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (DIRNODEW);
    } else {
        gb->UserIndex += DWSIZEOF (DIRNODEW);
        //
        // shift list
        //
        if (gb->Size - gb->End < DWSIZEOF (DIRNODEW)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }

    }

    return TRUE;
}


/*++

Routine Description:

    pCreateDirNode creates a new node given a context, a dir name or a parent node

Arguments:

    FileEnum - Specifies the context
    DirName - Specifies the dir name of the new node; may be NULL only if ParentNode is not NULL
    ParentNode - Specifies a pointer to the parent node of the new node; a pointer to the node
                 is required because the parent node location in memory may change as a result
                 of the growbuffer changing buffer location when it grows;
                 may be NULL only if DirName is not;
    Ignore - Receives a meaningful value only if NULL is returned (no node created);
             if TRUE upon return, the failure of node creation should be ignored

Return Value:

    A pointer to the new node or NULL if no node was created

--*/

PDIRNODEA
pCreateDirNodeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    IN      PCSTR DirName,              OPTIONAL
    IN      PDIRNODEA* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PDIRNODEA newNode;
    PSTR newDirName;
    PSEGMENTA FirstSegment;
    LONG offset = 0;

    if (DirName) {
        newDirName = DuplicateTextExA (g_FileEnumPool, DirName, 0, NULL);
    } else {
        MYASSERT (ParentNode);
        newDirName = JoinPathsInPoolExA ((
                        g_FileEnumPool,
                        (*ParentNode)->DirName,
                        (*ParentNode)->FindData.cFileName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        FirstSegment = FileEnum->FileEnumInfo.PathPattern->NodePattern->Pattern->Segment;
        if (FirstSegment->Type == SEGMENTTYPE_EXACTMATCH &&
            !StringIMatchByteCountA (
                    FirstSegment->Exact.LowerCasePhrase,
                    newDirName,
                    FirstSegment->Exact.PhraseBytes
                    )) {
            DEBUGMSGA ((
                DBG_FILEENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newDirName
                ));

            FreeTextExA (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
        //
        // look if this dir and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2A (ELT_FILE, newDirName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {

            DEBUGMSGA ((
                DBG_FILEENUM,
                "Skipping tree %s\\%s because it's excluded",
                newDirName,
                FileEnum->FileEnumInfo.PathPattern->Leaf
                ));

            FreeTextExA (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PDIRNODEA) GbGrow (&FileEnum->FileNodes, DWSIZEOF (DIRNODEA));
    if (!newNode) {
        FreeTextExA (g_FileEnumPool, newDirName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PDIRNODEA)(FileEnum->FileNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (DIRNODEA));

    newNode->DirName = newDirName;

    if (DirName) {
        newNode->DirAttributes = GetFileAttributesA (DirName);
        //
        // roots are not returned from enumeration because DNF_RETURN_DIRNAME is not set here
        //
        if ((FileEnum->FileEnumInfo.PathPattern->Leaf == NULL) &&
            (FileEnum->FileEnumInfo.PathPattern->ExactRoot) &&
            (!WildCharsPatternA (FileEnum->FileEnumInfo.PathPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    } else {
        MYASSERT (ParentNode);
        //ParentNode is not NULL (see the assert above) so...
        newNode->DirAttributes = (*ParentNode)->FindData.dwFileAttributes;  //lint !e613
        newNode->Flags |= DNF_RETURN_DIRNAME;
    }

    newNode->EnumState = DNS_ENUM_INIT;

    if ((FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternA (FileEnum->FileEnumInfo.PathPattern->NodePattern, newDirName)
        ) {
        newNode->Flags |= DNF_DIRNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (FileEnum->FileEnumInfo.CallbackOnError) {
            *Ignore = (*FileEnum->FileEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    return NULL;
}

PDIRNODEW
pCreateDirNodeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    IN      PCWSTR DirName,             OPTIONAL
    IN      PDIRNODEW* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PDIRNODEW newNode;
    PWSTR newDirName;
    PSEGMENTW FirstSegment;
    LONG offset = 0;

    if (DirName) {
        newDirName = DuplicateTextExW (g_FileEnumPool, DirName, 0, NULL);
    } else {
        MYASSERT (ParentNode);
        newDirName = JoinPathsInPoolExW ((
                        g_FileEnumPool,
                        (*ParentNode)->DirName,
                        (*ParentNode)->FindData.cFileName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        FirstSegment = FileEnum->FileEnumInfo.PathPattern->NodePattern->Pattern->Segment;
        if (FirstSegment->Type == SEGMENTTYPE_EXACTMATCH &&
            !StringIMatchByteCountW (
                    FirstSegment->Exact.LowerCasePhrase,
                    newDirName,
                    FirstSegment->Exact.PhraseBytes
                    )) {    //lint !e64
            DEBUGMSGW ((
                DBG_FILEENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newDirName
                ));

            FreeTextExW (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
        //
        // look if this dir and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2W (ELT_FILE, newDirName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {

            DEBUGMSGW ((
                DBG_FILEENUM,
                "Skipping tree %s\\%s because it's excluded",
                newDirName,
                FileEnum->FileEnumInfo.PathPattern->Leaf
                ));

            FreeTextExW (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PDIRNODEW) GbGrow (&FileEnum->FileNodes, DWSIZEOF (DIRNODEW));
    if (!newNode) {
        FreeTextExW (g_FileEnumPool, newDirName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PDIRNODEW)(FileEnum->FileNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (DIRNODEW));

    newNode->DirName = newDirName;

    if (DirName) {
        newNode->DirAttributes = GetFileAttributesW (DirName);
        //
        // roots are not returned from enumeration because DNF_RETURN_DIRNAME is not set here
        //
        if ((FileEnum->FileEnumInfo.PathPattern->Leaf == NULL) &&
            (FileEnum->FileEnumInfo.PathPattern->ExactRoot) &&
            (!WildCharsPatternW (FileEnum->FileEnumInfo.PathPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    } else {
        MYASSERT (ParentNode);
        //ParentNode is not NULL (see the assert above) so...
        newNode->DirAttributes = (*ParentNode)->FindData.dwFileAttributes;  //lint !e613
        newNode->Flags |= DNF_RETURN_DIRNAME;
    }

    newNode->EnumState = DNS_ENUM_INIT;

    if ((FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternW (FileEnum->FileEnumInfo.PathPattern->NodePattern, newDirName)
        ) {
        newNode->Flags |= DNF_DIRNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (FileEnum->FileEnumInfo.CallbackOnError) {
            *Ignore = (*FileEnum->FileEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    return NULL;
}


/*++

Routine Description:

    pEnumNextFile enumerates the next file that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new file was found; FALSE if not

--*/

BOOL
pEnumNextFileA (
    IN OUT  PDIRNODEA DirNode
    )
{
    do {
        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumNextFileW (
    IN OUT  PDIRNODEW DirNode
    )
{
    do {
        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstFile enumerates the first file that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first file was found; FALSE if not

--*/

BOOL
pEnumFirstFileA (
    OUT     PDIRNODEA DirNode,
    IN      PFILETREE_ENUMA FileEnum
    )
{
    CHAR pattern[MAX_MBCHAR_PATH];
    PCSTR p;

    if (FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_EXACTLEAF) {
        p = FileEnum->FileEnumInfo.PathPattern->Leaf;
        MYASSERT (p && *p);
    } else {
        p = "*";
    }
    StringCopyA (pattern, DirNode->DirName);
    StringCopyA (AppendWackA (pattern), p);

    DirNode->FindHandle = FindFirstFileA (pattern, &DirNode->FindData);
    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    do {
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }

        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumFirstFileW (
    OUT     PDIRNODEW DirNode,
    IN      PFILETREE_ENUMW FileEnum
    )
{
    WCHAR pattern[MAX_WCHAR_PATH];
    PCWSTR p;

    if (FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_EXACTLEAF) {
        p = FileEnum->FileEnumInfo.PathPattern->Leaf;
        MYASSERT (p && *p);
    } else {
        p = L"*";
    }

    StringCopyW (pattern, DirNode->DirName);
    StringCopyW (AppendWackW (pattern), p);

    DirNode->FindHandle = FindFirstFileW (pattern, &DirNode->FindData);
    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    do {
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }

        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pIsSpecialDirName checks if the specified dir name is a special name (used by the OS)

Arguments:

    DirName - Specifies the name

Return Value:

    TRUE if it's a special dir name

--*/

BOOL
pIsSpecialDirNameA (
    IN      PCSTR DirName
    )
{
    return DirName[0] == '.' && (DirName[1] == 0 || (DirName[1] == '.' && DirName[2] == 0));
}

BOOL
pIsSpecialDirNameW (
    IN      PCWSTR DirName
    )
{
    return DirName[0] == L'.' && (DirName[1] == 0 || (DirName[1] == L'.' && DirName[2] == 0));
}


/*++

Routine Description:

    pEnumNextSubDir enumerates the next subdir that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new subdir was found; FALSE if not

--*/

BOOL
pEnumNextSubDirA (
    IN OUT  PDIRNODEA DirNode
    )
{
    do {
        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore special dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            continue;
        }
        if (!pIsSpecialDirNameA (DirNode->FindData.cFileName)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumNextSubDirW (
    IN OUT  PDIRNODEW DirNode
    )
{
    do {
        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore special dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            continue;
        }
        if (!pIsSpecialDirNameW (DirNode->FindData.cFileName)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstSubDir enumerates the first subdir that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first subdir was found; FALSE if not

--*/

BOOL
pEnumFirstSubDirA (
    OUT     PDIRNODEA DirNode
    )
{
    CHAR pattern[MAX_MBCHAR_PATH];

    StringCopyA (pattern, DirNode->DirName);
    StringCopyA (AppendWackA (pattern), "*");

    //
    // BUGBUG - this should be enhanced for NT (it supports FindFirstFileExA)
    //
    DirNode->FindHandle = FindFirstFileA (pattern, &DirNode->FindData);
    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    do {
        //
        // ignore special dirs
        //
        if ((DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            !pIsSpecialDirNameA (DirNode->FindData.cFileName)
            ) {
            break;
        }

        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumFirstSubDirW (
    OUT     PDIRNODEW DirNode
    )
{
    WCHAR pattern[MAX_WCHAR_PATH];

    StringCopyW (pattern, DirNode->DirName);
    StringCopyW (AppendWackW (pattern), L"*");

    //
    // BUGBUG - this should be enhanced for NT (it supports FindFirstFileExW)
    //
    DirNode->FindHandle = FindFirstFileW (pattern, &DirNode->FindData);
    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    do {
        //
        // ignore special dirs
        //
        if ((DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            !pIsSpecialDirNameW (DirNode->FindData.cFileName)
            ) {
            break;
        }

        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumNextFileInTree is a private function that enumerates the next node matching
    the specified criteria; it's implemented as a state machine that travels the dirs/files
    as specified the the caller; it doesn't check if they actually match the patterns

Arguments:

    FileEnum - Specifies the current enum context; receives updated info
    CurrentDirNode - Receives the dir node that is currently processed, if success is returned

Return Value:

    TRUE if a next match was found; FALSE if no more dirs/files match

--*/

BOOL
pEnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    OUT     PDIRNODEA* CurrentDirNode
    )
{
    PDIRNODEA currentNode;
    PDIRNODEA newNode;
    BOOL ignore;

    while ((currentNode = pGetCurrentDirNodeA (FileEnum, FALSE)) != NULL) {

        *CurrentDirNode = currentNode;

        switch (currentNode->EnumState) {

        case DNS_FILE_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumFirstFileA (currentNode, FileEnum)) {
                currentNode->EnumState = DNS_FILE_NEXT;
                return TRUE;
            }
            currentNode->EnumState = DNS_FILE_DONE;
            break;

        case DNS_FILE_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumNextFileA (currentNode)) {
                return TRUE;
            }
            //
            // no more files for this one, go to the next
            //
            currentNode->EnumState = DNS_FILE_DONE;
            //
            // fall through
            //
        case DNS_FILE_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // done with this node
                //
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }
            //
            // now enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            //
            // fall through
            //
        case DNS_SUBDIR_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            //
            // check current dir's level; if max level reached, don't recurse into subdirs
            //
            if (currentNode->SubLevel >= FileEnum->FileEnumInfo.MaxSubLevel) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (!pEnumFirstSubDirA (currentNode)) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            currentNode->EnumState = DNS_SUBDIR_NEXT;
            newNode = pCreateDirNodeA (FileEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // look at the new node first
                //
                if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                    if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~DNF_RETURN_DIRNAME;
                        *CurrentDirNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating file system; aborting enumeration"
                    ));
                FileEnum->RootState = FES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case DNS_SUBDIR_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (pEnumNextSubDirA (currentNode)) {
                newNode = pCreateDirNodeA (FileEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                        if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~DNF_RETURN_DIRNAME;
                            *CurrentDirNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                //
                // did it fail because of a soft block?
                //
                if (!ignore) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating file system; aborting enumeration"
                        ));
                    FileEnum->RootState = FES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subdir
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = DNS_SUBDIR_DONE;
            //
            // fall through
            //
        case DNS_SUBDIR_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // now enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = DNS_ENUM_DONE;
            //
            // fall through
            //
        case DNS_ENUM_DONE:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (!(FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        //
                        // before returning, set some data
                        //
                        currentNode->FindData.cFileName[0] = 0;
                        return TRUE;
                    }
                }
            }
            pDeleteDirNodeA (FileEnum, FALSE);
            break;

        case DNS_ENUM_INIT:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        return TRUE;
                    }
                }
            }

            if (FileEnum->ControlFlags & FECF_SKIPDIR) {
                FileEnum->ControlFlags &= ~FECF_SKIPDIR;
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }

            if (FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST) {
                //
                // enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}

BOOL
pEnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    OUT     PDIRNODEW* CurrentDirNode
    )
{
    PDIRNODEW currentNode;
    PDIRNODEW newNode;
    BOOL ignore;

    while ((currentNode = pGetCurrentDirNodeW (FileEnum, FALSE)) != NULL) {

        *CurrentDirNode = currentNode;

        switch (currentNode->EnumState) {

        case DNS_FILE_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumFirstFileW (currentNode, FileEnum)) {
                currentNode->EnumState = DNS_FILE_NEXT;
                return TRUE;
            }
            currentNode->EnumState = DNS_FILE_DONE;
            break;

        case DNS_FILE_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumNextFileW (currentNode)) {
                return TRUE;
            }
            //
            // no more files for this one, go to the next
            //
            currentNode->EnumState = DNS_FILE_DONE;
            //
            // fall through
            //
        case DNS_FILE_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // done with this node
                //
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }
            //
            // now enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            //
            // fall through
            //
        case DNS_SUBDIR_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            //
            // check current dir's level; if max level reached, don't recurse into subdirs
            //
            if (currentNode->SubLevel >= FileEnum->FileEnumInfo.MaxSubLevel) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (!pEnumFirstSubDirW (currentNode)) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            currentNode->EnumState = DNS_SUBDIR_NEXT;
            newNode = pCreateDirNodeW (FileEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // look at the new node first
                //
                if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                    if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~DNF_RETURN_DIRNAME;
                        *CurrentDirNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            //
            // did it fail because of a soft block?
            //
            if (!ignore) {
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating file system; aborting enumeration"
                    ));
                FileEnum->RootState = FES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case DNS_SUBDIR_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (pEnumNextSubDirW (currentNode)) {
                newNode = pCreateDirNodeW (FileEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                        if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~DNF_RETURN_DIRNAME;
                            *CurrentDirNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                //
                // did it fail because of a soft block?
                //
                if (!ignore) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating file system; aborting enumeration"
                        ));
                    FileEnum->RootState = FES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subdir
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = DNS_SUBDIR_DONE;
            //
            // fall through
            //
        case DNS_SUBDIR_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // now enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = DNS_ENUM_DONE;
            //
            // fall through
            //
        case DNS_ENUM_DONE:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (!(FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        //
                        // before returning, set some data
                        //
                        currentNode->FindData.cFileName[0] = 0;
                        return TRUE;
                    }
                }
            }
            pDeleteDirNodeW (FileEnum, FALSE);
            break;

        case DNS_ENUM_INIT:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        return TRUE;
                    }
                }
            }

            if (FileEnum->ControlFlags & FECF_SKIPDIR) {
                FileEnum->ControlFlags &= ~FECF_SKIPDIR;
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }

            if (FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST) {
                //
                // enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}


/*++

Routine Description:

    pEnumFirstFileRoot enumerates the first root that matches caller's conditions

Arguments:

    FileEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumFirstFileRootA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    PCSTR root;
    BOOL ignore;

    root = FileEnum->FileEnumInfo.PathPattern->ExactRoot;

    if (root) {

        if (!PathIsDirectoryA (root)) {
            DEBUGMSGA ((DBG_FILEENUM, "pEnumFirstFileRootA: Invalid root spec: %s", root));
            return FALSE;
        }

        if (pCreateDirNodeA (FileEnum, root, NULL, NULL)) {
            FileEnum->RootState = FES_ROOT_DONE;
            return TRUE;
        }
    } else {
        FileEnum->DriveEnum = pFileAllocateMemory (DWSIZEOF (DRIVE_ENUMA));

        if (!EnumFirstDriveA (FileEnum->DriveEnum, FileEnum->DriveEnumTypes)) {
            return FALSE;
        }

        do {
            if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2A (ELT_FILE, FileEnum->DriveEnum->DriveName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {
                    DEBUGMSGA ((DBG_FILEENUM, "pEnumFirstFileRootA: Root is excluded: %s", FileEnum->DriveEnum->DriveName));
                    continue;
                }
            }
            if (!pCreateDirNodeA (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            FileEnum->RootState = FES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextDriveA (FileEnum->DriveEnum));

        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }

    return FALSE;
}

BOOL
pEnumFirstFileRootW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    PCWSTR root;
    BOOL ignore;

    root = FileEnum->FileEnumInfo.PathPattern->ExactRoot;

    if (root) {

        if (!PathIsDirectoryW (root)) {
            DEBUGMSGW ((DBG_FILEENUM, "pEnumFirstFileRootW: Invalid root spec: %s", root));
            return FALSE;
        }

        if (pCreateDirNodeW (FileEnum, root, NULL, NULL)) {
            FileEnum->RootState = FES_ROOT_DONE;
            return TRUE;
        }
    } else {
        FileEnum->DriveEnum = pFileAllocateMemory (DWSIZEOF (DRIVE_ENUMA));

        if (!EnumFirstDriveW (FileEnum->DriveEnum, FileEnum->DriveEnumTypes)) {
            return FALSE;
        }

        do {
            if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2W (ELT_FILE, FileEnum->DriveEnum->DriveName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {
                    DEBUGMSGW ((DBG_FILEENUM, "pEnumFirstFileRootW: Root is excluded: %s", FileEnum->DriveEnum->DriveName));
                    continue;
                }
            }
            if (!pCreateDirNodeW (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            FileEnum->RootState = FES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextDriveW (FileEnum->DriveEnum));

        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }

    return FALSE;
}


BOOL
pEnumNextFileRootA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    BOOL ignore;

    while (EnumNextDriveA (FileEnum->DriveEnum)) {
        if (pCreateDirNodeA (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    FileEnum->RootState = FES_ROOT_DONE;

    return FALSE;
}

BOOL
pEnumNextFileRootW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    BOOL ignore;

    while (EnumNextDriveW (FileEnum->DriveEnum)) {
        if (pCreateDirNodeW (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    FileEnum->RootState = FES_ROOT_DONE;

    return FALSE;
}


/*++

Routine Description:

    EnumFirstFileInTreeEx enumerates file system dirs, and optionally files, that match the
    specified criteria

Arguments:

    FileEnum - Receives the enum context info; this will be used in subsequent calls to
               EnumNextFileInTree
    EncodedPathPattern - Specifies the encoded dir pattern (encoded as defined by the
                        ParsedPattern functions)
    EncodedFilePattern - Specifies the encoded file pattern (encoded as defined by the
                          ParsedPattern functions); optional; NULL means no files
                          should be returned (only look for dirs)
    EnumDirs - Specifies TRUE if directories should be returned during the enumeration
               (if they match the pattern)
    ContainersFirst - Specifies TRUE if directories should be returned before any of its
                      files or subdirs
    FilesFirst - Specifies TRUE if a dir's files should be returned before dir's subdirs;
                  this parameter decides the enum order between files and subdirs
                  for each dir
    DepthFirst - Specifies TRUE if the current subdir of any dir should be fully enumerated
                 before going to the next subdir; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a subdir that is to be enumerated,
                  relative to the root; if 0, only the root is enumerated;
                  if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    paths/files are excluded from enumeration; this slows down the speed
    CallbackOnError - Specifies a pointer to a callback function that will be called during
                      enumeration if an error occurs; if the callback is defined and it
                      returns FALSE, the enumeration is aborted, otherwise it will continue
                      ignoring the error

Return Value:

    TRUE if a first match is found.
    FALSE otherwise.

--*/

BOOL
EnumFirstFileInTreeExA (
    OUT     PFILETREE_ENUMA FileEnum,
    IN      PCSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKA CallbackOnError    OPTIONAL
    )
{
    MYASSERT (FileEnum && EncodedPathPattern && *EncodedPathPattern);
    MYASSERT (g_FileEnumPool);

    ZeroMemory (FileEnum, DWSIZEOF (*FileEnum));    //lint !e613 !e668

    FileEnum->DriveEnumTypes = DriveEnumTypes;

    //
    // first try to get dir enum info in internal format
    //
    if (!pGetFileEnumInfoA (
            /*lint -e(613)*/&FileEnum->FileEnumInfo,
            EncodedPathPattern,
            EnumDirs,
            ContainersFirst,
            FilesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions
            )) {
        AbortEnumFileInTreeA (FileEnum);
        return FALSE;
    }
    if (UseExclusions) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedA (ELT_FILE, /*lint -e(613)*/FileEnum->FileEnumInfo.PathPattern)) {
            DEBUGMSGA ((
                DBG_FILEENUM,
                "EnumFirstFileInTreeExA: Root is excluded: %s",
                EncodedPathPattern
                ));
            AbortEnumFileInTreeA (FileEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstFileRootA (FileEnum)) {
        AbortEnumFileInTreeA (FileEnum);
        return FALSE;
    }

    /*lint -e(613)*/FileEnum->FileEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextFileInTreeA (FileEnum);
}

BOOL
EnumFirstFileInTreeExW (
    OUT     PFILETREE_ENUMW FileEnum,
    IN      PCWSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKW CallbackOnError    OPTIONAL
    )
{
    MYASSERT (FileEnum && EncodedPathPattern && *EncodedPathPattern);
    MYASSERT (g_FileEnumPool);

    ZeroMemory (FileEnum, DWSIZEOF (*FileEnum));    //lint !e613 !e668

    FileEnum->DriveEnumTypes = DriveEnumTypes;

    //
    // first try to get dir enum info in internal format
    //
    if (!pGetFileEnumInfoW (
            /*lint -e(613)*/&FileEnum->FileEnumInfo,
            EncodedPathPattern,
            EnumDirs,
            ContainersFirst,
            FilesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions
            )) {
        AbortEnumFileInTreeW (FileEnum);
        return FALSE;
    }
    if (UseExclusions) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedW (ELT_FILE, /*lint -e(613)*/FileEnum->FileEnumInfo.PathPattern)) {
            DEBUGMSGW ((
                DBG_FILEENUM,
                "EnumFirstFileInTreeExW: Root is excluded: %s",
                EncodedPathPattern
                ));
            AbortEnumFileInTreeW (FileEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstFileRootW (FileEnum)) {
        AbortEnumFileInTreeW (FileEnum);
        return FALSE;
    }

    /*lint -e(613)*/FileEnum->FileEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextFileInTreeW (FileEnum);
}


/*++

Routine Description:

    EnumNextFileInTree enumerates the next node matching the criteria specified in
    FileEnum; this is filled on the call to EnumFirstFileInTreeEx;

Arguments:

    FileEnum - Specifies the current enum context; receives updated info

Return Value:

    TRUE if a next match was found; FALSE if no more dirs/files match

--*/

BOOL
EnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    PDIRNODEA currentNode;
    BOOL success;

    MYASSERT (FileEnum);

    do {
        if (FileEnum->EncodedFullName) {
            ObsFreeA (FileEnum->EncodedFullName);
            FileEnum->EncodedFullName = NULL;
        }

        while (TRUE) {  //lint !e506

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = '\\';
                FileEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextFileInTreeA (FileEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->DirName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & DNF_DIRNAME_MATCHES)) {   //lint !e613
                continue;
            }

            if (/*lint -e(613)*/currentNode->FindData.cFileName[0] == 0) {
                MYASSERT (/*lint -e(613)*/currentNode->DirAttributes & FILE_ATTRIBUTE_DIRECTORY);

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->LastWackPtr = _mbsrchr (FileEnum->Location, '\\');
                if (!FileEnum->LastWackPtr) {
                    FileEnum->Name = FileEnum->Location;
                } else {
                    FileEnum->Name = _mbsinc (FileEnum->LastWackPtr);
                    if (!FileEnum->Name) {
                        FileEnum->Name = FileEnum->Location;
                    }
                }
                FileEnum->Attributes = /*lint -e(613)*/currentNode->DirAttributes;
                //
                // prepare full path buffer
                //
                StringCopyA (FileEnum->NativeFullName, FileEnum->Location);
                FileEnum->LastNode = currentNode;
                FileEnum->FileNameAppendPos = NULL;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2A (ELT_FILE, FileEnum->Location, NULL)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringA (
                                                FileEnum->Location,
                                                NULL
                                                );
            } else {

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->Name = /*lint -e(613)*/currentNode->FindData.cFileName;

                //
                // test if the filename matches
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !TestParsedPatternA (
                            FileEnum->FileEnumInfo.PathPattern->LeafPattern,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            )
                   ) {
                    continue;
                }

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2A (ELT_FILE, NULL, /*lint -e(613)*/currentNode->FindData.cFileName)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "File %s\\%s was found, but it's excluded by filename",
                            FileEnum->Location,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            ));
                        continue;
                    }
                }

                if (FileEnum->LastNode != currentNode) {
                    FileEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    FileEnum->NativeFullName[0] = 0;
                    FileEnum->FileNameAppendPos = StringCatA (FileEnum->NativeFullName, FileEnum->Location);
                    *FileEnum->FileNameAppendPos++ = '\\';
                } else if (!FileEnum->FileNameAppendPos) {
                    FileEnum->FileNameAppendPos = GetEndOfStringA (FileEnum->NativeFullName);
                    *FileEnum->FileNameAppendPos++ = '\\';
                }

                if (FileEnum->FileNameAppendPos + SizeOfStringA (FileEnum->Name) / DWSIZEOF(CHAR)>
                    FileEnum->NativeFullName + DWSIZEOF (FileEnum->NativeFullName) / DWSIZEOF(CHAR)) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "File %s\\%s was found, but it's path is too long",
                        FileEnum->Location,
                        FileEnum->Name
                        ));
                    continue;
                }

                StringCopyA (FileEnum->FileNameAppendPos, FileEnum->Name);
                FileEnum->Attributes = /*lint -e(613)*/currentNode->FindData.dwFileAttributes;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2A (ELT_FILE, FileEnum->Location, FileEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringA (
                                                FileEnum->Location,
                                                FileEnum->Name
                                                );
            }

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = 0;
            }

            FileEnum->CurrentLevel = FileEnum->FileEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            return TRUE;
        }

        //
        // try the next root
        //
        if (FileEnum->RootState == FES_ROOT_DONE) {
            break;
        }

        MYASSERT (FileEnum->RootState == FES_ROOT_NEXT);
        MYASSERT (FileEnum->DriveEnum);
        success = pEnumNextFileRootA (FileEnum);

    } while (success);

    AbortEnumFileInTreeA (FileEnum);

    return FALSE;
}

BOOL
EnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    PDIRNODEW currentNode;
    BOOL success;

    MYASSERT (FileEnum);

    do {
        if (FileEnum->EncodedFullName) {
            ObsFreeW (FileEnum->EncodedFullName);
            FileEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = L'\\';
                FileEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextFileInTreeW (FileEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->DirName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & DNF_DIRNAME_MATCHES)) {   //lint !e613
                continue;
            }

            if (/*lint -e(613)*/currentNode->FindData.cFileName[0] == 0) {
                MYASSERT (/*lint -e(613)*/currentNode->DirAttributes & FILE_ATTRIBUTE_DIRECTORY);

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->LastWackPtr = wcsrchr (FileEnum->Location, L'\\');
                if (!FileEnum->LastWackPtr) {
                    FileEnum->Name = FileEnum->Location;
                } else {
                    FileEnum->Name = FileEnum->LastWackPtr + 1;
                    if (!FileEnum->Name) {
                        FileEnum->Name = FileEnum->Location;
                    }
                }
                FileEnum->Attributes = /*lint -e(613)*/currentNode->DirAttributes;
                //
                // prepare full path buffer
                //
                StringCopyW (FileEnum->NativeFullName, FileEnum->Location);
                FileEnum->LastNode = currentNode;
                FileEnum->FileNameAppendPos = NULL;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2W (ELT_FILE, FileEnum->Location, NULL)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringW (
                                                FileEnum->Location,
                                                NULL
                                                );
            } else {

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->Name = /*lint -e(613)*/currentNode->FindData.cFileName;

                //
                // test if the filename matches
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !TestParsedPatternW (
                            FileEnum->FileEnumInfo.PathPattern->LeafPattern,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            )
                   ) {
                    continue;
                }

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2W (ELT_FILE, NULL, /*lint -e(613)*/currentNode->FindData.cFileName)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "File %s\\%s was found, but it's excluded by filename",
                            FileEnum->Location,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            ));
                        continue;
                    }
                }

                if (FileEnum->LastNode != currentNode) {
                    FileEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    FileEnum->NativeFullName[0] = 0;
                    FileEnum->FileNameAppendPos = StringCatW (FileEnum->NativeFullName, FileEnum->Location);
                    *FileEnum->FileNameAppendPos++ = L'\\';
                } else if (!FileEnum->FileNameAppendPos) {
                    FileEnum->FileNameAppendPos = GetEndOfStringW (FileEnum->NativeFullName);
                    *FileEnum->FileNameAppendPos++ = L'\\';
                }
                MYASSERT (FileEnum->Name && *FileEnum->Name);

                if (FileEnum->FileNameAppendPos + SizeOfStringW (FileEnum->Name) / DWSIZEOF(WCHAR)>
                    FileEnum->NativeFullName + DWSIZEOF (FileEnum->NativeFullName) / DWSIZEOF(WCHAR)) {
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "File %s\\%s was found, but it's path is too long",
                        FileEnum->Location,
                        FileEnum->Name
                        ));
                    continue;
                }

                StringCopyW (FileEnum->FileNameAppendPos, FileEnum->Name);
                FileEnum->Attributes = /*lint -e(613)*/currentNode->FindData.dwFileAttributes;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2W (ELT_FILE, FileEnum->Location, FileEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringW (
                                                FileEnum->Location,
                                                FileEnum->Name
                                                );
            }

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = 0;
            }

            FileEnum->CurrentLevel = FileEnum->FileEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            return TRUE;
        }

        //
        // try the next root
        //
        if (FileEnum->RootState == FES_ROOT_DONE) {
            break;
        }

        MYASSERT (FileEnum->RootState == FES_ROOT_NEXT);
        MYASSERT (FileEnum->DriveEnum);
        success = pEnumNextFileRootW (FileEnum);

    } while (success);

    AbortEnumFileInTreeW (FileEnum);

    return FALSE;
}


/*++

Routine Description:

    AbortEnumFileInTree aborts the enumeration, freeing all resources allocated

Arguments:

    FileEnum - Specifies the current enum context; receives a "clean" context

Return Value:

    none

--*/

VOID
AbortEnumFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    while (pDeleteDirNodeA (FileEnum, TRUE)) {
    }
    GbFree (&FileEnum->FileNodes);

    if (FileEnum->EncodedFullName) {
        ObsFreeA (FileEnum->EncodedFullName);
        FileEnum->EncodedFullName = NULL;
    }

    if (FileEnum->FileEnumInfo.PathPattern) {
        ObsDestroyParsedPatternA (FileEnum->FileEnumInfo.PathPattern);
        FileEnum->FileEnumInfo.PathPattern = NULL;
    }

    if (FileEnum->DriveEnum) {
        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }
}

VOID
AbortEnumFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    while (pDeleteDirNodeW (FileEnum, TRUE)) {
    }
    GbFree (&FileEnum->FileNodes);

    if (FileEnum->EncodedFullName) {
        ObsFreeW (FileEnum->EncodedFullName);
        FileEnum->EncodedFullName = NULL;
    }

    if (FileEnum->FileEnumInfo.PathPattern) {
        ObsDestroyParsedPatternW (FileEnum->FileEnumInfo.PathPattern);
        FileEnum->FileEnumInfo.PathPattern = NULL;
    }

    if (FileEnum->DriveEnum) {
        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\file\tree.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Implements routines that do operations on entire trees

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_TREE        "Tree"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
FiRemoveAllFilesInDirA (
    IN      PCSTR Dir
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;

    pattern = ObsBuildEncodedObjectStringExA (Dir, "*", FALSE);

    if (EnumFirstFileInTreeExA (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            SetFileAttributesA (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);

            if (!DeleteFileA (e.NativeFullName)) {
                AbortEnumFileInTreeA (&e);
                result = FALSE;
                break;
            }

        } while (EnumNextFileInTreeA (&e));
    }

    ObsFreeA (pattern);

    return result;
}


BOOL
FiRemoveAllFilesInDirW (
    IN      PCWSTR Dir
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;

    pattern = ObsBuildEncodedObjectStringExW (Dir, L"*", FALSE);

    if (EnumFirstFileInTreeExW (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            SetFileAttributesW (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);

            if (!DeleteFileW (e.NativeFullName)) {
                AbortEnumFileInTreeW (&e);
                result = FALSE;
                break;
            }

        } while (EnumNextFileInTreeW (&e));
    }

    ObsFreeW (pattern);

    return result;
}


BOOL
FiRemoveAllFilesInTreeA (
    IN      PCSTR Dir
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PCSTR dirPattern;

    dirPattern = JoinPathsA (Dir, "*");
    pattern = ObsBuildEncodedObjectStringExA (dirPattern, "*", FALSE);

    if (EnumFirstFileInTreeExA (&e, pattern, 0, TRUE, FALSE, FALSE, TRUE, FILEENUM_ALL_SUBLEVELS, FALSE, NULL)) {
        do {
            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                result = RemoveDirectoryA (e.NativeFullName);
            } else {
                SetFileAttributesA (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);
                result = DeleteFileA (e.NativeFullName);
            }
            if (!result) {
                AbortEnumFileInTreeA (&e);
                break;
            }
        } while (EnumNextFileInTreeA (&e));
    }

    if (result) {
        result = RemoveDirectoryA (Dir);
    }

    ObsFreeA (pattern);
    FreePathStringA (dirPattern);

    return result;
}


BOOL
FiRemoveAllFilesInTreeW (
    IN      PCWSTR Dir
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PCWSTR dirPattern;

    dirPattern = JoinPathsW (Dir, L"*");
    pattern = ObsBuildEncodedObjectStringExW (dirPattern, L"*", FALSE);

    if (EnumFirstFileInTreeExW (&e, pattern, 0, TRUE, FALSE, FALSE, TRUE, FILEENUM_ALL_SUBLEVELS, FALSE, NULL)) {
        do {
            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                result = RemoveDirectoryW (e.NativeFullName);
            } else {
                SetFileAttributesW (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);
                result = DeleteFileW (e.NativeFullName);
            }
            if (!result) {
                AbortEnumFileInTreeW (&e);
                break;
            }
        } while (EnumNextFileInTreeW (&e));
    }

    if (result) {
        result = RemoveDirectoryW (Dir);
    }

    ObsFreeW (pattern);
    FreePathStringW (dirPattern);

    return result;
}

BOOL
CopyFilesTreeA (
    IN      PCSTR SourceDir, 
    IN      PCSTR DestDir, 
    IN      PCSTR FileMask, 
    IN      BOOL   Recursive
    )
{
    HANDLE hFind;
    WIN32_FIND_DATAA win32findData;
    CHAR SourceDirAndMask[MAX_PATH];
    CHAR ExistFilePath[MAX_PATH];
    CHAR NewFilePath[MAX_PATH];
    PSTR pExistFile;
    PSTR pNewFile;
    BOOL  bResult = TRUE;

    if(!SourceDirAndMask || !DestDir || !FileMask){
        return FALSE;
    }

    if(-1 == GetFileAttributesA(SourceDir) || 
       -1 == GetFileAttributesA(DestDir)){
        return FALSE;
    }

    lstrcpy(SourceDirAndMask, SourceDir);
    lstrcat(AppendWack(SourceDirAndMask), FileMask);

    hFind = FindFirstFileA(SourceDirAndMask, &win32findData);
    if(INVALID_HANDLE_VALUE == hFind){
        return FALSE;
    }

    lstrcpy(ExistFilePath, SourceDir);
    pExistFile = AppendWackA(ExistFilePath);
    lstrcpy(NewFilePath, DestDir);
    pNewFile = AppendWackA(NewFilePath);

    do{
        lstrcat(pExistFile, win32findData.cFileName);
        lstrcat(pNewFile, win32findData.cFileName);

        if(!(FILE_ATTRIBUTE_DIRECTORY&win32findData.dwFileAttributes)){
            if(!CopyFileA(ExistFilePath, NewFilePath, FALSE)){
                bResult = FALSE;
                break;
            }
        }else{
            if(Recursive){
                if(!(('.' == win32findData.cFileName[0] && !win32findData.cFileName[1]) || 
                    ('.' == win32findData.cFileName[0] && '.' == win32findData.cFileName[1] && !win32findData.cFileName[2]))){
                    if(!CreateDirectoryA(NewFilePath, NULL) || !CopyFilesTreeA(ExistFilePath, NewFilePath, FileMask, TRUE)){
                        bResult = FALSE;
                        break;
                    }
                }
            }
        }
        
        *pExistFile = '\0';
        *pNewFile = '\0';
    }while(FindNextFileA(hFind, &win32findData));

    FindClose(hFind);

    return bResult;
}

BOOL
CopyFilesTreeW (
    IN      PCWSTR SourceDir, 
    IN      PCWSTR DestDir, 
    IN      PCWSTR FileMask, 
    IN      BOOL   Recursive
    )
{
    HANDLE hFind;
    WIN32_FIND_DATAW win32findData;
    WCHAR SourceDirAndMask[MAX_PATH];
    WCHAR ExistFilePath[MAX_PATH];
    WCHAR NewFilePath[MAX_PATH];
    PWSTR pExistFile;
    PWSTR pNewFile;
    BOOL  bResult = TRUE;

    if(!SourceDirAndMask || !DestDir || !FileMask){
        return FALSE;
    }

    if(-1 == GetFileAttributesW(SourceDir) || 
       -1 == GetFileAttributesW(DestDir)){
        return FALSE;
    }

    wcscpy(SourceDirAndMask, SourceDir);
    wcscat(AppendWackW(SourceDirAndMask), FileMask);

    hFind = FindFirstFileW(SourceDirAndMask, &win32findData);
    if(INVALID_HANDLE_VALUE == hFind){
        return FALSE;
    }

    wcscpy(ExistFilePath, SourceDir);
    pExistFile = AppendWackW(ExistFilePath);
    wcscpy(NewFilePath, DestDir);
    pNewFile = AppendWackW(NewFilePath);

    do{
        wcscat(pExistFile, win32findData.cFileName);
        wcscat(pNewFile, win32findData.cFileName);

        if(!(FILE_ATTRIBUTE_DIRECTORY&win32findData.dwFileAttributes)){
            if(!CopyFileW(ExistFilePath, NewFilePath, FALSE)){
                bResult = FALSE;
                break;
            }
        }else{
            if(Recursive){
                if(!(('.' == win32findData.cFileName[0] && !win32findData.cFileName[1]) || 
                    ('.' == win32findData.cFileName[0] && '.' == win32findData.cFileName[1] && !win32findData.cFileName[2]))){
                    if(!CreateDirectoryW(NewFilePath, NULL) || !CopyFilesTreeW(ExistFilePath, NewFilePath, FileMask, TRUE)){
                        bResult = FALSE;
                        break;
                    }
                }
            }
        }
        
        *pExistFile = '\0';
        *pNewFile = '\0';
    }while(FindNextFileW(hFind, &win32findData));

    FindClose(hFind);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\ipc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ipc.h

Abstract:

    Implements IPC interface to allow setup to talk with migisol.exe,
    in order to run migration DLLs in separate processes.

Author:

    Jim Schmidt (jimschm)   28-Mar-1997

Revision History:

    jimschm 23-Sep-1998     Changed from mailslots to memory mapped files

--*/


#pragma once

BOOL
IpcOpenW (
    IN      BOOL Win95Side,
    IN      PCWSTR ExePath,                 OPTIONAL
    IN      PCWSTR MigrationDllPath,        OPTIONAL
    IN      PCWSTR WorkingDir               OPTIONAL
    );

BOOL
IpcOpenA (
    IN      BOOL Win95Side,
    IN      PCSTR ExePath,                  OPTIONAL
    IN      PCSTR MigrationDllPath,         OPTIONAL
    IN      PCSTR WorkingDir                OPTIONAL
    );

DWORD
IpcCheckForWaitingData (
    IN      HANDLE Slot,
    IN      DWORD MinimumSize,
    IN      DWORD Timeout
    );

BOOL
IpcProcessAlive (
    VOID
    );

VOID
IpcKillProcess (
    VOID
    );

BOOL
IpcSendCommand (
    IN      DWORD Command,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    );

BOOL
IpcGetCommandResults (
    IN      DWORD Timeout,
    OUT     PBYTE *ReturnData,      OPTIONAL
    OUT     PDWORD ReturnDataSize,  OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    );

BOOL
IpcGetCommand (
    IN      DWORD Timeout,
    IN      PDWORD Command,         OPTIONAL
    IN      PBYTE *Data,            OPTIONAL
    IN      PDWORD DataSize         OPTIONAL
    );

BOOL
IpcSendCommandResults (
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    );

#define IPC_GET_RESULTS_WIN9X       1000
#define IPC_GET_RESULTS_NT          7500
#define IPC_GET_COMMAND_WIN9X       10000
#define IPC_GET_COMMAND_NT          10000




#ifdef UNICODE
#define IpcOpen IpcOpenW
#else
#define IpcOpen IpcOpenA
#endif

VOID
IpcClose (
    VOID
    );

typedef LONG (WINAPI WINVERIFYTRUST_PROTOTYPE)(HWND hwnd, GUID *ActionId, PVOID Data);
typedef WINVERIFYTRUST_PROTOTYPE * WINVERIFYTRUST;



BOOL
IsDllSignedA (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCSTR DllSpec
    );

BOOL
IsDllSignedW (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCWSTR DllSpec
    );


#ifdef UNICODE
#define IsDllSigned IsDllSignedW
#else
#define IsDllSigned IsDllSignedA
#endif

//
// Remote commands
//

#define IPC_QUERY           1
#define IPC_INITIALIZE      2
#define IPC_MIGRATEUSER     3
#define IPC_MIGRATESYSTEM   4
#define IPC_TERMINATE       5
#define IPC_DVDCHECK        6

//
// APIs implemented in IPC
//

BOOL
IsolatedIsDvdPresentA (
    PCSTR ExePath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\log.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    log.h

Abstract:

    Implements routines that simplify the writing to setupact.log
    and setuperr.log.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    mikeco      23-May-1997     Ran code through train_wreck.exe
    Ovidiu Temereanca (ovidiut) 23-Oct-1998
        Added new logging capabilities

*/


//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef DEBUG
#ifndef DBG
#define DBG
#endif
#endif

//
// Redefine MYASSERT
//

#ifdef DEBUG

#ifdef MYASSERT
#undef MYASSERT
#endif

#define DBG_ASSERT          "Assert"

#define MYASSERT(expr)      LogIfA(                                     \
                                !(expr),                                \
                                DBG_ASSERT,                             \
                                "Assert Failure\n\n%s\n\n%s line %u",   \
                                #expr,                                  \
                                __FILE__,                               \
                                __LINE__                                \
                                );

#else

#ifndef MYASSERT
#define MYASSERT(x)
#endif

#endif

#define LOG_FATAL_ERROR   "Fatal Error"
#define LOG_ERROR         "Error"
#define LOG_WARNING       "Warning"
#define LOG_INFORMATION   "Info"
#define LOG_ACCOUNTS      "Accounts"
#define LOG_CONFIG        "Configuration"

BOOL
Init_Log (
    IN      HWND LogPopupParentWnd
    );

VOID
Exit_Log (
    VOID
    );

BOOL
LogReInit (
    IN      HWND *NewParent,           OPTIONAL
    OUT     HWND *OrgParent            OPTIONAL
    );

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title
    );

VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title
    );

VOID
LogLineA (
    IN      PCSTR Line
    );

VOID
LogLineW (
    IN      PCWSTR Line
    );

VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    );

VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    );

VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    );

#ifdef PROGRESS_BAR

VOID
_cdecl
LogTime (
    IN      PCSTR Format,
    ...
    );

#endif

// Define W symbols

#define LOGW(x) LogW x
#define LOGW_IF(x) LogIfW x
#define ELSE_LOGW(x) else{LogW x;}
#define ELSE_LOGW_IF(x) else{LogIfW x;}
#define LOGTITLEW(type,title) LogTitleW (type,title)
#define LOGLINEW(title) LogLineW (title)
#define LOGDIRECTW(type,text) LogDirectW (type,text)

// Define A symbols

#define LOGA(x) LogA x
#define LOGA_IF(x) LogIfA x
#define ELSE_LOGA(x) else{LogA x;}
#define ELSE_LOGA_IF(x) else{LogIfA x;}
#define LOGTITLEA(type,title) LogTitleA (type,title)
#define LOGLINEA(line) LogLineA (line)
#define LOGDIRECTA(type,text) LogDirectA (type,text)

// Define generic symbols

#ifdef UNICODE

#define LOG(x) LOGW(x)
#define LOG_IF(x) LOGW_IF(x)
#define ELSE_LOG(x) ELSE_LOGW(x)
#define ELSE_LOG_IF(x) ELSE_LOGW_IF(x)
#define LOGTITLE(type,title) LOGTITLEW(type,title)
#define LOGLINE(title) LOGLINEW(title)
#define LOGDIRECT(type,text) LOGDIRECTW(type,text)

#else

#define LOG(x) LOGA(x)
#define LOG_IF(x) LOGA_IF(x)
#define ELSE_LOG(x) ELSE_LOGA(x)
#define ELSE_LOG_IF(x) ELSE_LOGA_IF(x)
#define LOGTITLE(type,title) LOGTITLEA(type,title)
#define LOGLINE(title) LOGLINEA(title)
#define LOGDIRECT(type,text) LOGDIRECTA(type,text)

#endif // UNICODE


#ifdef DEBUG

#define DBG_NAUSEA      "Nausea"
#define DBG_VERBOSE     "Verbose"
#define DBG_STATS       "Stats"
#define DBG_WARNING     "Warning"
#define DBG_ERROR       "Error"
#define DBG_WHOOPS      "Whoops"
#define DBG_TRACK       "Track"
#define DBG_TIME        "Time"

extern CHAR g_DebugInfPathBufA[];
extern WCHAR g_DebugInfPathBufW[];
#define g_DebugInfPath  g_DebugInfPathBufA
#define g_DebugInfPathA g_DebugInfPathBufA
#define g_DebugInfPathW g_DebugInfPathBufW

extern BOOL g_ResetLog;             // Defined in log.c
#define SET_RESETLOG()   g_ResetLog = TRUE
#define CLR_RESETLOG()   g_ResetLog = FALSE
#define RESETLOG()       (g_ResetLog)

extern BOOL g_DoLog;                // Defined in log.c
#define SET_DOLOG()     g_DoLog = TRUE
#define CLR_DOLOG()     g_DoLog = FALSE
#define DOLOG()         (g_DoLog)


#ifndef PROGRESS_BAR

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    );

#endif


// Define W symbols

#define DEBUGMSGW(x) LogW x
#define DEBUGMSGW_IF(x) LogIfW x
#define ELSE_DEBUGMSGW(x) else LogW x
#define ELSE_DEBUGMSGW_IF(x) else LogW x
#ifdef PROGRESS_BAR
#define DEBUGLOGTIMEW(x) LogTime x
#else
#define DEBUGLOGTIMEW(x) DebugLogTimeW x
#endif


// Define A symbols

#define DEBUGMSGA(x) LogA x
#define DEBUGMSGA_IF(x) LogIfA x
#define ELSE_DEBUGMSGA(x) else LogA x
#define ELSE_DEBUGMSGA_IF(x) else LogIfA x
#ifdef PROGRESS_BAR
#define DEBUGLOGTIMEA(x) LogTime x
#else
#define DEBUGLOGTIMEA(x) DebugLogTimeA x
#endif

// Define generic symbols

#ifdef UNICODE

#define DEBUGMSG(x) DEBUGMSGW(x)
#define DEBUGMSG_IF(x) DEBUGMSGW_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGW(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGW_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEW(x)

#else

#define DEBUGMSG(x) DEBUGMSGA(x)
#define DEBUGMSG_IF(x) DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGA_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEA(x)

#endif // UNICODE

#else // !defined(DEBUG)

//
// No-debug constants
//

#define SET_RESETLOG()
#define CLR_RESETLOG()
#define RESETLOG()

#define SET_DOLOG()
#define CLR_DOLOG()
#define DOLOG()

#define DEBUGMSG(x)
#define DEBUGMSGA(x)
#define DEBUGMSGW(x)

#define DEBUGMSG_IF(x)
#define DEBUGMSGA_IF(x)
#define DEBUGMSGW_IF(x)

#define ELSE_DEBUGMSG(x)
#define ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSGW(x)

#define ELSE_DEBUGMSG_IF(x)
#define ELSE_DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSGW_IF(x)

#ifdef PROGRESS_BAR
#define DEBUGLOGTIME(x) LogTime x
#else
#define DEBUGLOGTIME(x)
#endif

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\main.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    main.h

Abstract:

    Declares the interface to utils\main

Author:

    Jim Schmidt (jimschm) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/


//
// MAX constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_SERVER_NAMEA + (20 * 2))
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_TRANSLATION             32
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_SERVER_NAMEW + 20)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

//
// Prototypes
//

VOID
UtInitialize (
    IN      HANDLE Heap             OPTIONAL
    );

VOID
UtTerminate (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\fileenum.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileenum.h

Abstract:

    Set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

//
// Drive enumeration structures
//

#define DRIVEENUM_UNKNOWN   DRIVE_UNKNOWN
#define DRIVEENUM_NOROOTDIR DRIVE_NO_ROOT_DIR
#define DRIVEENUM_REMOVABLE DRIVE_REMOVABLE
#define DRIVEENUM_FIXED     DRIVE_FIXED
#define DRIVEENUM_REMOTE    DRIVE_REMOTE
#define DRIVEENUM_CDROM     DRIVE_CDROM
#define DRIVEENUM_RAMDISK   DRIVE_RAMDISK
#define DRIVEENUM_NONE      0
#define DRIVEENUM_ALL       (DRIVE_UNKNOWN|DRIVE_NO_ROOT_DIR|DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK)
#define DRIVEENUM_ALLVALID  (DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK)

typedef struct {
    PCSTR           DriveName;
    UINT            DriveType;

    //
    // private members, maintained by enumeration
    //
    PSTR            AllLogicalDrives;
    UINT            WantedDriveTypes;
} DRIVE_ENUMA, *PDRIVE_ENUMA;

typedef struct {
    PCWSTR          DriveName;
    UINT            DriveType;

    //
    // private members, maintained by enumeration
    //
    PWSTR           AllLogicalDrives;
    UINT            WantedDriveTypes;
} DRIVE_ENUMW, *PDRIVE_ENUMW;

//
// File enumeration structures
//

#define FILEENUM_ALL_SUBLEVELS  0xFFFFFFFF

typedef enum {
    FECF_SKIPDIR                = 0x0001,
    FECF_SKIPSUBDIRS            = 0x0002,
    FECF_SKIPFILES              = 0x0004,
} FILEENUM_CONTROLFLAGS;

typedef enum {
    FEIF_RETURN_DIRS            = 0x0001,
    FEIF_FILES_FIRST            = 0x0002,
    FEIF_DEPTH_FIRST            = 0x0004,
    FEIF_USE_EXCLUSIONS         = 0x0008,
    FEIF_CONTAINERS_FIRST       = 0x0010,
} FILEENUM_INFOFLAGS;

typedef enum {
    DNS_ENUM_INIT,
    DNS_FILE_FIRST,
    DNS_FILE_NEXT,
    DNS_FILE_DONE,
    DNS_SUBDIR_FIRST,
    DNS_SUBDIR_NEXT,
    DNS_SUBDIR_DONE,
    DNS_ENUM_DONE
} DNS_ENUM_STATE;

typedef enum {
    FES_ROOT_FIRST,
    FES_ROOT_NEXT,
    FES_ROOT_DONE
} FES_ROOT_STATE;

typedef enum {
    DNF_RETURN_DIRNAME      = 0x0001,
    DNF_DIRNAME_MATCHES     = 0x0002,
} DIRNODE_FLAGS;

typedef struct {
    PCSTR               DirName;
    DWORD               DirAttributes;
    PSTR                FileName;
    HANDLE              FindHandle;
    WIN32_FIND_DATAA    FindData;
    DWORD               EnumState;
    DWORD               Flags;
    DWORD               SubLevel;
} DIRNODEA, *PDIRNODEA;

typedef struct {
    PCWSTR              DirName;
    DWORD               DirAttributes;
    PWSTR               FileName;
    HANDLE              FindHandle;
    WIN32_FIND_DATAW    FindData;
    DWORD               EnumState;
    DWORD               Flags;
    DWORD               SubLevel;
} DIRNODEW, *PDIRNODEW;

typedef BOOL (*FPE_ERROR_CALLBACKA)(PDIRNODEA);

typedef struct {
    POBSPARSEDPATTERNA      PathPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    FPE_ERROR_CALLBACKA     CallbackOnError;
} FILEENUMINFOA, *PFILEENUMINFOA;

typedef BOOL (*FPE_ERROR_CALLBACKW)(PDIRNODEW);

typedef struct {
    POBSPARSEDPATTERNW      PathPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    FPE_ERROR_CALLBACKW     CallbackOnError;
} FILEENUMINFOW, *PFILEENUMINFOW;

typedef struct {
    PCSTR           EncodedFullName;
    PCSTR           Name;
    PCSTR           Location;
    CHAR            NativeFullName[MAX_MBCHAR_PATH];
    DWORD           Attributes;
    DWORD           CurrentLevel;

    //
    // Private members
    //
    DWORD           ControlFlags;
    FILEENUMINFOA   FileEnumInfo;
    GROWBUFFER      FileNodes;
    DWORD           RootState;
    PDRIVE_ENUMA    DriveEnum;
    UINT            DriveEnumTypes;
    PDIRNODEA       LastNode;
    PSTR            FileNameAppendPos;
    PSTR            LastWackPtr;
} FILETREE_ENUMA, *PFILETREE_ENUMA;

typedef struct {
    PCWSTR          EncodedFullName;
    PCWSTR          Name;
    PCWSTR          Location;
    WCHAR           NativeFullName[MAX_WCHAR_PATH];
    DWORD           Attributes;
    DWORD           CurrentLevel;

    //
    // Private members
    //
    DWORD           ControlFlags;
    FILEENUMINFOW   FileEnumInfo;
    GROWBUFFER      FileNodes;
    DWORD           RootState;
    PDRIVE_ENUMW    DriveEnum;
    UINT            DriveEnumTypes;
    PDIRNODEW       LastNode;
    PWSTR           FileNameAppendPos;
    PWSTR           LastWackPtr;
} FILETREE_ENUMW, *PFILETREE_ENUMW;


//
// API
//

BOOL
FileEnumInitialize (
    VOID
    );

VOID
FileEnumTerminate (
    VOID
    );

//
// File enumeration APIs
//

BOOL
EnumFirstFileInTreeExA (
    OUT     PFILETREE_ENUMA FileEnum,
    IN      PCSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumContainers,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevels,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKA CallbackOnError OPTIONAL
    );

#define EnumFirstFileInTreeA(e,p)  EnumFirstFileInTreeExA(e,p,DRIVEENUM_ALLVALID,TRUE,TRUE,TRUE,TRUE,FILEENUM_ALL_SUBLEVELS,FALSE,NULL)

BOOL
EnumFirstFileInTreeExW (
    OUT     PFILETREE_ENUMW FileEnum,
    IN      PCWSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumContainers,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevels,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKW CallbackOnError OPTIONAL
    );

#define EnumFirstFileInTreeW(e,p)  EnumFirstFileInTreeExW(e,p,DRIVEENUM_ALLVALID,TRUE,TRUE,TRUE,TRUE,FILEENUM_ALL_SUBLEVELS,FALSE,NULL)

BOOL
EnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    );

BOOL
EnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    );

VOID
AbortEnumFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    );

VOID
AbortEnumFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    );

//
// Drive enumeration APIs
//

BOOL
EnumFirstDriveA (
    OUT     PDRIVE_ENUMA DriveEnum,
    IN      UINT WantedDriveTypes
    );

BOOL
EnumFirstDriveW (
    OUT     PDRIVE_ENUMW DriveEnum,
    IN      UINT WantedDriveTypes
    );

BOOL
EnumNextDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    );

BOOL
EnumNextDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    );

VOID
AbortEnumDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    );

VOID
AbortEnumDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    );


//
// Routines built on enum
//

BOOL
FiRemoveAllFilesInDirA (
    IN      PCSTR Dir
    );

BOOL
FiRemoveAllFilesInDirW (
    IN      PCWSTR Dir
    );

BOOL
FiRemoveAllFilesInTreeA (
    IN      PCSTR Dir
    );

BOOL
FiRemoveAllFilesInTreeW (
    IN      PCWSTR Dir
    );

BOOL
CopyFilesTreeA (
    IN      PCSTR SourceDir,
    IN      PCSTR DestDir,
    IN      PCSTR FileMask,
    IN      BOOL   Recursive
    );

BOOL
CopyFilesTreeW (
    IN      PCWSTR SourceDir,
    IN      PCWSTR DestDir,
    IN      PCWSTR FileMask,
    IN      BOOL   Recursive
    );


//
// Macros
//

#ifdef UNICODE

#define DIRNODE                     DIRNODEW
#define PDIRNODE                    PDIRNODEW
#define FILENODE                    FILENODEW
#define PFILENODE                   PFILENODEW
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKW
#define FILEENUMINFO                FILEENUMINFOW
#define PFILEENUMINFO               PFILEENUMINFOW
#define FILETREE_ENUM               FILETREE_ENUMW
#define PFILETREE_ENUM              PFILETREE_ENUMW
#define EnumFirstFileInTree         EnumFirstFileInTreeW
#define EnumFirstFileInTreeEx       EnumFirstFileInTreeExW
#define EnumNextFileInTree          EnumNextFileInTreeW
#define AbortEnumFileInTree         AbortEnumFileInTreeW

#define DRIVE_ENUM                  DRIVE_ENUMW
#define EnumFirstDrive              EnumFirstDriveW
#define EnumNextDrive               EnumNextDriveW
#define AbortEnumDrive              AbortEnumDriveW
#define FiRemoveAllFilesInDir       FiRemoveAllFilesInDirW
#define FiRemoveAllFilesInTree      FiRemoveAllFilesInTreeW
#define CopyFilesTree               CopyFilesTreeW

#else

#define DIRNODE                     DIRNODEA
#define PDIRNODE                    PDIRNODEA
#define FILENODE                    FILENODEA
#define PFILENODE                   PFILENODEA
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKA
#define FILEENUMINFO                FILEENUMINFOA
#define PFILEENUMINFO               PFILEENUMINFOA
#define FILETREE_ENUM               FILETREE_ENUMA
#define PFILETREE_ENUM              PFILETREE_ENUMA
#define EnumFirstFileInTree         EnumFirstFileInTreeA
#define EnumFirstFileInTreeEx       EnumFirstFileInTreeExA
#define EnumNextFileInTree          EnumNextFileInTreeA
#define AbortEnumFileInTree         AbortEnumFileInTreeA

#define DRIVE_ENUM                  DRIVE_ENUMA
#define EnumFirstDrive              EnumFirstDriveA
#define EnumNextDrive               EnumNextDriveA
#define AbortEnumDrive              AbortEnumDriveA
#define FiRemoveAllFilesInDir       FiRemoveAllFilesInDirA
#define FiRemoveAllFilesInTree      FiRemoveAllFilesInTreeA
#define CopyFilesTree               CopyFilesTreeA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\growlist.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growlist.h

Abstract:

    Implements a dynamic array-indexed list of binary objects.  Typically,
    the binary objects are strings.  The list uses a GROWBUF for the array,
    and a pool for the binary data of each list item.

Author:

    Jim Schmidt (jimschm) 08-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    GROWBUFFER ListArray;
    PMHANDLE ListData;
} GROWLIST, *PGROWLIST;

#define INIT_GROWLIST {NULL,0,0,0,0, NULL}

#define GlGetPtrArray(listptr)           ((PVOID *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayA(listptr)    ((PCSTR *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayW(listptr)    ((PCWSTR *) ((listptr)->ListArray.Buf))

PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppend(list,data,size)    TRACK_BEGIN(PBYTE, GlAppend)\
                                    RealGlAppend (list,data,size)   \
                                    TRACK_END()

PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppendAddNul(list,data,size)    TRACK_BEGIN(PBYTE, GlAppendAddNul)         \
                                          RealGlAppendAddNul (list,data,size)       \
                                          TRACK_END()

VOID
GlFree (
    IN  PGROWLIST GrowList
    );

PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    );

UINT
GlGetSize (
    IN      PGROWLIST GrowList
    );

PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsert(list,index,data,size)      TRACK_BEGIN(PBYTE,GlInsert)   \
                                            RealGlInsert (list,index,data,size)             \
                                            TRACK_END()


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsertAddNul(list,index,data,size)    TRACK_BEGIN(PBYTE, GlInsertAddNul)           \
                                                RealGlInsertAddNul (list,index,data,size)   \
                                                TRACK_END()


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToSet,           OPTIONAL
    IN      UINT SizeOfData
    );

#define GlSetItem(list,index,data,size)     TRACK_BEGIN(PBYTE, GlSetItem)        \
                                            RealGlSetItem(list,index,data,size) \
                                            TRACK_END()

__inline
PCSTR
RealGlAppendStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABA"));

    return (PCSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCWSTR
RealGlAppendStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABW"));

    return (PCWSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCSTR
RealGlInsertStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABA"));

    return (PCSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCWSTR
RealGlInsertStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABW"));

    return (PCWSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

#define GlAppendStringABA(list,a,b)         TRACK_BEGIN(PCSTR, GrowListAppendStringABA)          \
                                            RealGlAppendStringABA(list,a,b)\
                                            TRACK_END()

#define GlAppendStringABW(list,a,b)         TRACK_BEGIN(PCWSTR, GrowListAppendStringABW)         \
                                            RealGlAppendStringABW(list,a,b)\
                                            TRACK_END()

#define GlInsertStringABA(list,index,a,b)   TRACK_BEGIN(PCSTR, GrowListInsertStringABA)            \
                                            RealGlInsertStringABA(list,index,a,b)\
                                            TRACK_END()

#define GlInsertStringABW(list,index,a,b)   TRACK_BEGIN(PCWSTR, GrowListInsertStringABW)           \
                                            RealGlInsertStringABW(list,index,a,b)\
                                            TRACK_END()



#define GlAppendStringA(list,str) GlAppendStringABA(list,str,GetEndOfStringA(str))
#define GlAppendStringW(list,str) GlAppendStringABW(list,str,GetEndOfStringW(str))

#define GlInsertStringA(list,index,str) GlInsertStringABA(list,index,str,GetEndOfStringA(str))
#define GlInsertStringW(list,index,str) GlInsertStringABW(list,index,str,GetEndOfStringW(str))

#define GlAppendStringNA(list,str,len) GlAppendStringABA(list,str,CharCountToPointerA(str,len))
#define GlAppendStringNW(list,str,len) GlAppendStringABW(list,str,CharCountToPointerW(str,len))

#define GlInsertStringNA(list,index,str,len) GlInsertStringABA(list,index,str,CharCountToPointerA(str,len))
#define GlInsertStringNW(list,index,str,len) GlInsertStringABW(list,index,str,CharCountToPointerW(str,len))

#define GlGetStringA(list,index) (PCSTR)(GlGetItem(list,index))
#define GlGetStringW(list,index) (PCWSTR)(GlGetItem(list,index))

#define GlAppendEmptyItem(list)           GlAppend (list,NULL,0)
#define GlInsertEmptyItem(list,index)     GlInsert (list,index,NULL,0)

#ifdef UNICODE

#define GlAppendString GlAppendStringW
#define GlInsertString GlInsertStringW
#define GlAppendStringAB GlAppendStringABW
#define GlInsertStringAB GlInsertStringABW
#define GlAppendStringN GlAppendStringNW
#define GlInsertStringN GlInsertStringNW
#define GlGetString GlGetStringW
#define GlGetStringPtrArray GlGetStringPtrArrayW

#else

#define GlAppendString GlAppendStringA
#define GlInsertString GlInsertStringA
#define GlAppendStringAB GlAppendStringABA
#define GlInsertStringAB GlInsertStringABA
#define GlAppendStringN GlAppendStringNA
#define GlInsertStringN GlInsertStringNA
#define GlGetString GlGetStringA
#define GlGetStringPtrArray GlGetStringPtrArrayA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\inf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    inf.h

Abstract:

    Declares interface for INF wrapper routines.  These routines simplify
    access of INFs by wrapping the setup APIs with routines that use
    pools or grow buffers.

    The INF wrapper routines also implement append and replace capabilities,
    so any INF used by the Win9x upgrade can be appended in the future, or
    completely replaced.

Author:

    Marc R. Whitten (marcw) 20-Oct-1997

Revision History:

    jimschm     05-Jan-1999     INF parser moved to migutil
    marcw       28-Oct-1998     Append/Replace capability
    marcw       08-Aug-1997     Pool/Growbuf routines

--*/


typedef enum {
    INF_USE_PMHANDLE,
    INF_USE_GROWBUFFER,
    INF_USE_PRIVATE_GROWBUFFER,
    INF_USE_PRIVATE_PMHANDLE
} ALLOCATORTYPES;

typedef struct {
    INFCONTEXT      Context;
    GROWBUFFER      GrowBuffer;
    PMHANDLE        PoolHandle;
    ALLOCATORTYPES  Allocator;
} INFSTRUCT, *PINFSTRUCT;

#define INFCONTEXT_INIT {NULL,NULL,0,0}
#define INITINFSTRUCT_GROWBUFFER {INFCONTEXT_INIT,INIT_GROWBUFFER,NULL,INF_USE_PRIVATE_GROWBUFFER}
#define INITINFSTRUCT_PMHANDLE {INFCONTEXT_INIT,INIT_GROWBUFFER,NULL,INF_USE_PRIVATE_PMHANDLE}
#define InfOpenAppendInfFile    SetupOpenAppendInfFile



VOID
InfCleanUpInfStruct (
    PINFSTRUCT Context
    );

VOID
InitInfStruct (
    OUT PINFSTRUCT Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  PMHANDLE PoolHandle  OPTIONAL
    );



#define InfOpenInfFileA(f)              TRACK_BEGIN(HINF, InfOpenInfFile)\
                                        RealInfOpenInfFileA((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        TRACK_END()

#define InfOpenInfFileW(f)              TRACK_BEGIN(HINF, InfOpenInfFile)\
                                        RealInfOpenInfFileW((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        TRACK_END()



HINF
RealInfOpenInfFileA (
    IN PCSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

HINF
RealInfOpenInfFileW (
    IN PCWSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

VOID
InfCloseInfFile (HINF Inf);

//
// See the macros below before calling InfOpenInfInAllSourcesA or W.
//
HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    );

HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    );

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCT
    );


PWSTR
InfGetLineTextW (
    IN OUT  PINFSTRUCT
    );

PSTR
InfGetStringFieldA (
    IN OUT PINFSTRUCT    Context,
    IN     UINT         FieldIndex
    );

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCT    Context,
    IN     UINT         FieldIndex
    );

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    ) ;

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    ) ;


BOOL
InfGetIntField (
    IN PINFSTRUCT       Context,
    IN UINT            FieldIndex,
    IN PINT             Value
    );

PBYTE
InfGetBinaryField (
    IN  PINFSTRUCT      Context,
    IN  UINT           FieldIndex
    );

BOOL
InfGetLineByIndexA(
    IN HINF InfHandle,
    IN PCSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
);

BOOL
InfGetLineByIndexW(
    IN HINF InfHandle,
    IN PCWSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
);

BOOL
InfFindFirstLineA (
    IN HINF             InfHandle,
    IN PCSTR            Section,
    IN PCSTR            Key,
    OUT PINFSTRUCT      Context
    );

BOOL
InfFindFirstLineW (
    IN HINF             InfHandle,
    IN PCWSTR           Section,
    IN PCWSTR           Key,
    OUT PINFSTRUCT      Context
    );

BOOL
InfFindNextLine (
    IN OUT PINFSTRUCT   Context
    );

UINT
InfGetFieldCount (
    IN PINFSTRUCT       Context
    );


PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCT Context,
    IN      UINT Field
    );

BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PTSTR ReturnBuffer,
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize
    );

VOID
InfResetInfStruct (
    IN OUT PINFSTRUCT Context
    );



//
// INF parser
//

typedef struct _tagINFLINE {
    PCWSTR Key;             OPTIONAL
    PCWSTR Data;
    DWORD LineFlags;
    struct _tagINFLINE *Next, *Prev;
    struct _tagINFSECTION *Section;
} INFLINE, *PINFLINE;

#define LINEFLAG_KEY_QUOTED         0x0001
#define LINEFLAG_ALL_COMMENTS       0x0002
#define LINEFLAG_TRAILING_COMMENTS  0x0004


typedef struct _tagINFSECTION {
    PCWSTR Name;
    PINFLINE FirstLine;
    PINFLINE LastLine;
    UINT LineCount;
    struct _tagINFSECTION *Next, *Prev;
} INFSECTION, *PINFSECTION;

PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    );

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    );


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    );

PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    );

PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    );

PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    );

PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    );

PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    );

UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    );

BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    );

BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    );

HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileA(Path) OpenInfFileExA (Path, NULL, TRUE)

HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileW(Path) OpenInfFileExW (Path, NULL, TRUE)

VOID
CloseInfFile (
    HINF InfFile
    );

BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    );

BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    );


//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#   define InfFindFirstLine                 InfFindFirstLineW
#   define InfGetLineByIndex                InfGetLineByIndexW
#   define InfGetStringField                InfGetStringFieldW
#   define InfGetMultiSzField               InfGetMultiSzFieldW
#   define InfGetLineText                   InfGetLineTextW
#   define InfOpenInfFile                   InfOpenInfFileW
#   define InfGetOemStringField             InfGetStringFieldW
#   define SetupGetOemStringField           SetupGetStringFieldW
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesW((x),1,&g_SourceDirectory);
#   define AddInfSectionToTable             AddInfSectionToTableW
#   define FindInfSectionInTable            FindInfSectionInTableW
#   define AddInfLineToTable                AddInfLineToTableW
#   define FindLineInInfSection             FindLineInInfSectionW
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrW
#   define OpenInfFileEx                    OpenInfFileExW
#   define OpenInfFile                      OpenInfFileW
#   define SaveInfFile                      SaveInfFileW


#else

#   define InfFindFirstLine                 InfFindFirstLineA
#   define InfGetLineByIndex                InfGetLineByIndexA
#   define InfGetStringField                InfGetStringFieldA
#   define InfGetMultiSzField               InfGetMultiSzFieldA
#   define InfGetLineText                   InfGetLineTextA
#   define InfOpenInfFile                   InfOpenInfFileA
#   define InfGetOemStringField             InfGetOemStringFieldA
#   define SetupGetOemStringField           SetupGetOemStringFieldA
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesA((x),g_SourceDirectoryCount,g_SourceDirectories);
#   define AddInfSectionToTable             AddInfSectionToTableA
#   define FindInfSectionInTable            FindInfSectionInTableA
#   define AddInfLineToTable                AddInfLineToTableA
#   define FindLineInInfSection             FindLineInInfSectionA
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrA
#   define OpenInfFileEx                    OpenInfFileExA
#   define OpenInfFile                      OpenInfFileA
#   define SaveInfFile                      SaveInfFileA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\sandbox.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sandbox.h

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

#define SB_CLOSE        0x0100

//
// Macros
//

// None

//
// Types
//

typedef void * SBHANDLE;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

// None

//
// Macro expansion definition
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\unicode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unicode.h

Abstract:

    Declares the interfaces for unicode/ansi conversion.

    When specific conversion is needed, use:

        unicode = ConvertAtoW (ansi) / FreeConvertedStr (unicode)
        ansi = ConvertWtoA (unicode) / FreeConvertedStr (ansi)

        KnownSizeAtoW (ansi,unicode)
        KnownSizeWtoA (unicode,ansi)

    When TCHAR conversion is needed, use:

        ansi = CreateDbcs (tchar) / DestroyDbcs (ansi)
        unicode = CreateUnicode (tchar) / DestroyUnicode (unicode)
        tchar = ConvertAtoT (ansi) / FreeAtoT (tchar)
        tchar = ConvertWtoT (ansi) / FreeWtoT (tchar)

Author:

    Jim Schmidt (jimschm)   02-Sep-1997

Revision History:

    jimschm 15-Feb-1999     Eliminated AnsiFromUnicode and UnicodeFromAnsi
    calinn  07-Jul-1998     SetGlobalPage/GetGlobalPage
    mikeco  03-Nov-1997     AnsiFromUnicode/UnicodeFromAnsi

--*/

#pragma once

extern WORD g_GlobalCodePage;

#define OurGetACP() (g_GlobalCodePage)

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    );


VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    );


#define INVALID_CHAR_COUNT      0xffffffff

//
// Explicit conversions, pool-based, unlimited size
//

PCSTR
RealUnicodeToDbcsN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    );

PCWSTR
RealDbcsToUnicodeN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    );

#define UnicodeToDbcsN(p,s,c)       TRACK_BEGIN(PCSTR, UnicodeToDbcsN)\
                                    RealUnicodeToDbcsN(p,s,c)\
                                    TRACK_END()

#define DbcsToUnicodeN(p,s,c)       TRACK_BEGIN(PCWSTR, DbcsToUnicodeN)\
                                    RealDbcsToUnicodeN(p,s,c)\
                                    TRACK_END()

#define UnicodeToDbcs(pool,str) UnicodeToDbcsN(pool,str,(DWORD)wcslen(str))
#define DbcsToUnicode(pool,str) DbcsToUnicodeN(pool,str,CharCountA(str))

#define ConvertWtoA(unicode_str) UnicodeToDbcsN(NULL,unicode_str,(DWORD)wcslen(unicode_str))
#define ConvertAtoW(dbcs_str) DbcsToUnicodeN(NULL,dbcs_str,CharCountA(dbcs_str))

VOID
FreeConvertedPoolStr (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    );

#define FreeConvertedStr(str) FreeConvertedPoolStr(NULL,(PVOID)(str))

//
// In-place explicit conversions, caller handles buffer sizing
//

PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD CharCount
    );

PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD CharCount
    );

#define KnownSizeUnicodeToDbcs(out,in)      KnownSizeUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define KnownSizeDbcsToUnicode(out,in)      KnownSizeDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define KnownSizeWtoA                       KnownSizeUnicodeToDbcs
#define KnownSizeAtoW                       KnownSizeDbcsToUnicode

PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    );

PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    );

#define DirectUnicodeToDbcs(out,in)         DirectUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define DirectDbcsToUnicode(out,in)         DirectDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define DirectWtoA                          DirectUnicodeToDbcs
#define DirectAtoW                          DirectDbcsToUnicode




//
// TCHAR conversions -- do not call A & W versions directly
//

#define CreateDbcsW(unicode_str)            ConvertWtoA(unicode_str)
#define DestroyDbcsW(unicode_str)           FreeConvertedStr(unicode_str)
#define CreateUnicodeW(unicode_str)         (unicode_str)
#define DestroyUnicodeW(unicode_str)
#define CreateDbcsA(dbcs_str)               (dbcs_str)
#define DestroyDbcsA(dbcs_str)
#define CreateUnicodeA(dbcs_str)            ConvertAtoW(dbcs_str)
#define DestroyUnicodeA(dbcs_str)           FreeConvertedStr(dbcs_str)

#ifdef UNICODE

#define CreateDbcs          CreateDbcsW
#define CreateUnicode       CreateUnicodeW
#define DestroyDbcs         DestroyDbcsW
#define DestroyUnicode      DestroyUnicodeW
#define ConvertAtoT         ConvertAtoW
#define ConvertWtoT(x)      (x)
#define FreeAtoT            FreeConvertedStr
#define FreeWtoT(x)

#define KnownSizeAtoT           KnownSizeAtoW
#define KnownSizeWtoT(out,in)   (in)

#define DirectAtoT              DirectAtoW
#define DirectWtoT(out,in)      (in)

#else

#define CreateDbcs          CreateDbcsA
#define CreateUnicode       CreateUnicodeA
#define DestroyDbcs         DestroyDbcsA
#define DestroyUnicode      DestroyUnicodeA
#define ConvertAtoT(x)      (x)
#define ConvertWtoT         ConvertWtoA
#define FreeAtoT(x)
#define FreeWtoT            FreeConvertedStr

#define KnownSizeAtoT(out,in)   (in)
#define KnownSizeWtoT           KnownSizeWtoA

#define DirectAtoT(out,in)      (in)
#define DirectWtoT              DirectWtoA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\utiltypes.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    utiltypes.h

Abstract:

    Defines types used by utilities

Author:

    Jim Schmidt (jimschm) 25-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef PVOID PMHANDLE;
typedef struct TAG_GROWBUFFER *PGROWBUFFER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\version.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    version.h

Abstract:

    This file implements a set of enumeration routines to access
    version info in a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    calinn      03-Sep-1999 Moved over from Win9xUpg project.

--*/

#pragma once

//
// Includes
//

// None

//
// Debug constants
//

// None

//
// Strings
//

// None

//
// Constants
//

#define MAX_TRANSLATION             32

//
// Macros
//

// None

//
// Types
//

typedef struct {
    WORD CodePage;
    WORD Language;
} TRANSLATION, *PTRANSLATION;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    CHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCSTR FileSpec;
    PCSTR VersionField;
} VRVALUE_ENUMA, *PVRVALUE_ENUMA;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    WCHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCWSTR FileSpec;
    PCWSTR VersionField;
} VRVALUE_ENUMW, *PVRVALUE_ENUMW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes
//

BOOL
VrCreateEnumStructA (
    OUT     PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR FileSpec
    );

BOOL
VrCreateEnumStructW (
    OUT     PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR FileSpec
    );

VOID
VrDestroyEnumStructA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

VOID
VrDestroyEnumStructW (
    IN      PVRVALUE_ENUMW VrValueEnum
    );

PCSTR
VrEnumFirstValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionField
    );

PCWSTR
VrEnumFirstValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionField
    );

PCSTR
VrEnumNextValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
VrEnumNextValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

ULONGLONG
VrGetBinaryFileVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileVersionW(VrValueEnum)    VrGetBinaryFileVersionA((PVRVALUE_ENUMW)VrValueEnum)

ULONGLONG
VrGetBinaryProductVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryProductVersionW(VrValueEnum) VrGetBinaryProductVersionA((PVRVALUE_ENUMW)VrValueEnum)

DWORD
VrGetBinaryFileDateLoA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileFileDateLoW(VrValueEnum) VrGetBinaryFileDateLoA((PVRVALUE_ENUMW)VrValueEnum)

DWORD
VrGetBinaryFileDateHiA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileFileDateHiW(VrValueEnum) VrGetBinaryFileDateHiA((PVRVALUE_ENUMW)VrValueEnum)

DWORD
VrGetBinaryOsVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryOsVersionW(VrValueEnum)      VrGetBinaryOsVersionA((PVRVALUE_ENUMW)VrValueEnum)

DWORD
VrGetBinaryFileTypeA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileFileTypeW(VrValueEnum)   VrGetBinaryFileTypeA((PVRVALUE_ENUMW)VrValueEnum)

#ifndef UNICODE

#define VRVALUE_ENUM                    VRVALUE_ENUMA
#define PVRVALUE_ENUM                   PVRVALUE_ENUMA
#define VrCreateEnumStruct              VrCreateEnumStructA
#define VrDestroyEnumStruct             VrDestroyEnumStructA
#define VrEnumFirstValue                VrEnumFirstValueA
#define VrEnumNextValue                 VrEnumNextValueA
#define VrGetBinaryFileVersion          VrGetBinaryFileVersionA
#define VrGetBinaryProductVersion       VrGetBinaryProductVersionA
#define VrGetBinaryFileDateLo           VrGetBinaryFileDateLoA
#define VrGetBinaryFileDateHi           VrGetBinaryFileDateHiA
#define VrGetBinaryOsVersion            VrGetBinaryOsVersionA
#define VrGetBinaryFileType             VrGetBinaryFileTypeA

#else

#define VRVALUE_ENUM                    VRVALUE_ENUMW
#define PVRVALUE_ENUM                   PVRVALUE_ENUMW
#define VrCreateEnumStruct              VrCreateEnumStructW
#define VrDestroyEnumStruct             VrDestroyEnumStructW
#define VrEnumFirstValue                VrEnumFirstValueW
#define VrEnumNextValue                 VrEnumNextValueW
#define VrGetBinaryFileVersion          VrGetBinaryFileVersionW
#define VrGetBinaryProductVersion       VrGetBinaryProductVersionW
#define VrGetBinaryFileDateLo           VrGetBinaryFileDateLoW
#define VrGetBinaryFileDateHi           VrGetBinaryFileDateHiW
#define VrGetBinaryOsVersion            VrGetBinaryOsVersionW
#define VrGetBinaryFileType             VrGetBinaryFileTypeW

#endif

//
// Macro expansion definition
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\wnd.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wnd.h

Abstract:

    The header file for Window utility routines.

Author:

    Jim Schmidt (jimschm) 01-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

HWND
FindWindowInProcessA (
    IN      DWORD ProcessId,
    IN      PCSTR WindowTitle           OPTIONAL
    );

HWND
FindWindowInProcessW (
    IN      DWORD ProcessId,
    IN      PCWSTR WindowTitle         OPTIONAL
    );


//
// Macro expansion definition
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\memdb.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdb.h

Abstract:

    Declares interfaces for memdb, the memory database.  MemDb is
    used throughout the Win9x upgrade project to record OS state
    and to track operations on files and the registry.

    See common\memdb for implementation details.

Author:

    Jim Schmidt (jimschm) 15-Nov-1996

Revision History:

    mvander     13-Aug-1999     many changes
    jimschm     05-Apr-1999     MemDbGetStoredEndPatternValue
    jimschm     18-Jan-1999     Version APIs
    jimschm     23-Sep-1998     Proxy node capability
    jimschm     24-Jun-1998     MemDbMove capability
    jimschm     30-Oct-1997     Temporary hive capability
    jimschm     31-Jul-1997     Hashing for faster access
    jimschm     19-Mar-1997     Binary node capability
    jimschm     28-Feb-1997     Offset access capabilities
    jimschm     20-Dec-1996     Ex routines

--*/

#pragma once

#define INVALID_OFFSET      (~((UINT)0))

#define MEMDB_MAX 2048

//
// My net share flag, used to distinguish user-level security and
// password-level security.  When it is specified, user-level
// security is enabled, and NetShares\<share>\ACL\<list> exists.
//

#define SHI50F_ACLS         0x1000


//
// Dataflags for enuming key data
//

#define DATAFLAG_INSTANCEMASK   0x03
#define DATAFLAG_UNORDERED      0x04
#define DATAFLAG_SINGLELINK     0x08
#define DATAFLAG_DOUBLELINK     0x10
#define DATAFLAG_BINARYMASK     0x1C
#define DATAFLAG_VALUE          0x20
#define DATAFLAG_FLAGS          0x40
#define DATAFLAG_ALL            (DATAFLAG_INSTANCEMASK|DATAFLAG_UNORDERED|DATAFLAG_SINGLELINK|DATAFLAG_DOUBLELINK|DATAFLAG_VALUE|DATAFLAG_FLAGS)

//
// Constant for MemDbKeyFromHandle
//

#define MEMDB_LAST_LEVEL        0xFFFFFFFF

//
// Types
//


typedef UINT KEYHANDLE;
typedef UINT DATAHANDLE;

typedef struct {
    BOOL Valid;
    BOOL Debug;
    UINT Version;
    BOOL CurrentVersion;
} MEMDB_VERSION, *PMEMDB_VERSION;

//
// Flags for enumeration routines
//
#define ENUMFLAG_INSTANCEMASK       0x0003
#define ENUMFLAG_UNORDERED          0x0004
#define ENUMFLAG_SINGLELINK         0x0008
#define ENUMFLAG_DOUBLELINK         0x0010
#define ENUMFLAG_BINARYMASK         0x001C
#define ENUMFLAG_VALUE              0x0020
#define ENUMFLAG_FLAGS              0x0040
#define ENUMFLAG_EMPTY              0x0080
#define ENUMFLAG_ENDPOINTS          0x0100
#define ENUMFLAG_NONENDPOINTS       0x0200

#define ENUMFLAG_ALLDATA        ENUMFLAG_BINARYMASK|ENUMFLAG_VALUE|ENUMFLAG_FLAGS|ENUMFLAG_EMPTY
#define ENUMFLAG_ALLSEGMENTS    ENUMFLAG_ENDPOINTS|ENUMFLAG_NONENDPOINTS

#define ENUMFLAG_ALL            ENUMFLAG_ALLDATA|ENUMFLAG_ALLSEGMENTS

#define ENUMLEVEL_LASTLEVEL         0xFFFFFFFF
#define ENUMLEVEL_ALLLEVELS         0xFFFFFFFF

typedef struct {
    WCHAR FullKeyName[MEMDB_MAX];
    WCHAR KeyName[MEMDB_MAX];
    UINT Value;
    UINT Flags;
    KEYHANDLE KeyHandle;
    BOOL EndPoint;

    // internally maintained members
    BYTE CurrentDatabaseIndex;
    BOOL EnumerationMode;
    UINT EnumFlags;
    PWSTR KeyNameCopy;
    PWSTR PatternCopy;
    PWSTR PatternPtr;
    PWSTR PatternEndPtr;
    UINT CurrentIndex;
    UINT BeginLevel;                   // 0-based first level of keys
    UINT EndLevel;                     // 0-based last level of keys
    UINT CurrentLevel;                 // 1-based level of keys
    GROWBUFFER TreeEnumBuffer;
    UINT TreeEnumLevel;
} MEMDB_ENUMW, *PMEMDB_ENUMW;

typedef struct {
    CHAR FullKeyName[MEMDB_MAX];
    CHAR KeyName[MEMDB_MAX];
    UINT Value;
    UINT Flags;
    KEYHANDLE KeyHandle;
    BOOL EndPoint;

    // internally maintained members
    MEMDB_ENUMW UnicodeEnum;
} MEMDB_ENUMA, *PMEMDB_ENUMA;


//
// Function prototypes
//

BOOL
MemDbInitialize (
    VOID
    );

VOID
MemDbTerminate (
    VOID
    );

PVOID
MemDbGetMemory (
    IN      UINT Size
    );

VOID
MemDbReleaseMemory (
    IN      PCVOID Memory
    );

KEYHANDLE
MemDbAddKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbAddKeyW (
    IN      PCWSTR KeyName
    );

KEYHANDLE
MemDbSetKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbSetKeyW (
    IN      PCWSTR KeyName
    );

BOOL
MemDbDeleteKeyA (
    IN      PCSTR KeyName
    );

BOOL
MemDbDeleteKeyW (
    IN      PCWSTR KeyName
    );

BOOL
MemDbDeleteKeyByHandle (
    IN      KEYHANDLE KeyHandle
    );

BOOL
MemDbDeleteTreeA (
    IN      PCSTR KeyName
    );

BOOL
MemDbDeleteTreeW (
    IN      PCWSTR KeyName
    );

PCSTR
MemDbGetKeyFromHandleA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    );

PCWSTR
MemDbGetKeyFromHandleW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    );

BOOL
MemDbGetKeyFromHandleExA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer
    );

BOOL
MemDbGetKeyFromHandleExW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer
    );

KEYHANDLE
MemDbGetHandleFromKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbGetHandleFromKeyW (
    IN      PCWSTR KeyName
    );

KEYHANDLE
MemDbSetValueAndFlagsExA (
    IN      PCSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

KEYHANDLE
MemDbSetValueAndFlagsExW (
    IN      PCWSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

BOOL
MemDbSetValueAndFlagsByHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

BOOL
MemDbGetValueAndFlagsA (
    IN      PCSTR KeyName,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

BOOL
MemDbGetValueAndFlagsW (
    IN      PCWSTR KeyName,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

BOOL
MemDbGetValueAndFlagsByHandle (
    IN      KEYHANDLE KeyHandle,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

#define MemDbSetValueAndFlagsA(k,v,s,c) MemDbSetValueAndFlagsExA(k,TRUE,v,FALSE,s,c)
#define MemDbSetValueAndFlagsW(k,v,s,c) MemDbSetValueAndFlagsExW(k,TRUE,v,FALSE,s,c)
#define MemDbSetValueAndFlagsByHandle(h,v,s,c) MemDbSetValueAndFlagsByHandleEx(h,TRUE,v,FALSE,s,c)

#define MemDbSetValueA(k,v) MemDbSetValueAndFlagsExA(k,TRUE,v,FALSE,0,0)
#define MemDbSetValueW(k,v) MemDbSetValueAndFlagsExW(k,TRUE,v,FALSE,0,0)
#define MemDbSetValueByHandle(h,v) MemDbSetValueAndFlagsByHandleEx(h,TRUE,v,FALSE,0,0)
#define MemDbGetValueA(k,v) MemDbGetValueAndFlagsA(k,v,NULL)
#define MemDbGetValueW(k,v) MemDbGetValueAndFlagsW(k,v,NULL)
#define MemDbGetValueByHandle(h,v) MemDbGetValueAndFlagsByHandle(h,v,NULL)

#define MemDbTestKeyA(k)  MemDbGetValueAndFlagsA(k,NULL,NULL)
#define MemDbTestKeyW(k)  MemDbGetValueAndFlagsW(k,NULL,NULL)
#define MemDbTestKeyByHandle(h) MemDbGetValueAndFlagsByHandle(h,NULL,NULL)

#define MemDbSetFlagsA(k,s,c) MemDbSetValueAndFlagsExA(k,FALSE,0,FALSE,s,c)
#define MemDbSetFlagsW(k,s,c) MemDbSetValueAndFlagsExW(k,FALSE,0,FALSE,s,c)
#define MemDbSetFlagsByHandle(h,s,c) MemDbSetValueAndFlagsByHandleEx(h,FALSE,0,FALSE,s,c)
#define MemDbReplaceFlagsA(k,f) MemDbSetValueAndFlagsExA(k,FALSE,0,TRUE,f,0)
#define MemDbReplaceFlagsW(k,f) MemDbSetValueAndFlagsExW(k,FALSE,0,TRUE,f,0)
#define MemDbReplaceFlagsByHandle(h,f) MemDbSetValueAndFlagsByHandleEx(h,FALSE,0,TRUE,f,0)
#define MemDbGetFlagsA(k,f) MemDbGetValueAndFlagsA(k,NULL,f)
#define MemDbGetFlagsW(k,f) MemDbGetValueAndFlagsW(k,NULL,f)
#define MemDbGetFlagsByHandle(h,f) MemDbGetValueAndFlagsByHandle(h,NULL,f)

DATAHANDLE
MemDbAddDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbAddDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbAddDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGetDataHandleA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

DATAHANDLE
MemDbGetDataHandleW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

PBYTE
MemDbGetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataExA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataExW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataByDataHandleEx (
    IN      DATAHANDLE DataHandle,
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataByKeyHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbDeleteDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteDataByDataHandle (
    IN      DATAHANDLE DataHandle
    );

BOOL
MemDbDeleteDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance
    );

//
// High-level BLOB functions
//
#define MemDbAddUnorderedBlobA(k,i,d,s)  MemDbAddDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbAddUnorderedBlobW(k,i,d,s)  MemDbAddDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbAddUnorderedBlobByKeyHandle(h,i,d,s) MemDbAddDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobA(k,i,d,s)  MemDbSetDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobW(k,i,d,s)  MemDbSetDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobByDataHandle(h,d,s) MemDbSetDataByDataHandle(h,d,s)
#define MemDbSetUnorderedBlobByKeyHandle(h,i,d,s) MemDbSetDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobA(k,i,d,s)  MemDbGrowDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobW(k,i,d,s)  MemDbGrowDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobByDataHandle(h,d,s) MemDbGrowDataByDataHandle(h,d,s)
#define MemDbGrowUnorderedBlobByKeyHandle(h,i,d,s) MemDbGrowDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGetUnorderedBlobHandleA(k,i) MemDbGetDataHandleA(k,DATAFLAG_UNORDERED,i)
#define MemDbGetUnorderedBlobHandleW(k,i) MemDbGetDataHandleW(k,DATAFLAG_UNORDERED,i)
#define MemDbGetUnorderedBlobA(k,i,s) MemDbGetDataA(k,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobW(k,i,s) MemDbGetDataW(k,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobExA(k,i,b,s) MemDbGetDataExA(k,DATAFLAG_UNORDERED,i,b,s)
#define MemDbGetUnorderedBlobExW(k,i,b,s) MemDbGetDataExW(k,DATAFLAG_UNORDERED,i,b,s)
#define MemDbGetUnorderedBlobByDataHandle(h,s) MemDbGetDataByDataHandle(h,s)
#define MemDbGetUnorderedBlobByDataHandleEx(h,b,s) MemDbGetDataByDataHandle(h,b,s)
#define MemDbGetUnorderedBlobByKeyHandle(h,i,s) MemDbGetDataByKeyHandle(h,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobByKeyHandleEx(h,i,b,s) MemDbGetDataByKeyHandleEx(h,DATAFLAG_UNORDERED,i,b,s)
#define MemDbDeleteUnorderedBlobA(k,i) MemDbDeleteDataA(k,DATAFLAG_UNORDERED,i);
#define MemDbDeleteUnorderedBlobW(k,i) MemDbDeleteDataW(k,DATAFLAG_UNORDERED,i);
#define MemDbDeleteUnorderedBlobByDataHandle(h) MemDbDeleteDataByDataHandle(h)
#define MemDbDeleteUnorderedBlobByKeyHandle(h,i) MemDbDeleteDataByKeyHandle(h,DATAFLAG_UNORDERED,i)

//
// low-level linkage functions
//
DATAHANDLE
MemDbAddLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

BOOL
MemDbDeleteLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

#define MemDbSetLinkageArrayA(k,t,i,d,s) MemDbSetDataA(k,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayW(k,t,i,d,s) MemDbSetDataW(k,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayByKeyHandle(h,t,i,d,s) MemDbSetDataByKeyHandle(h,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayByDataHandle(h,d,s) MemDbSetDataByDataHandle(h,(PCBYTE)d,s)
#define MemDbGetLinkageArrayA(k,t,i,s) (PUINT)MemDbGetDataA(k,t,i,s)
#define MemDbGetLinkageArrayW(k,t,i,s) (PUINT)MemDbGetDataW(k,t,i,s)
#define MemDbGetLinkageArrayByKeyHandle(h,t,i,s) (PUINT)MemDbGetDataByKeyHandle(h,t,i,s)
#define MemDbGetLinkageArrayByKeyHandleEx(h,t,i,b,s) (PUINT)MemDbGetDataByKeyHandleEx(h,t,i,b,s)
#define MemDbGetLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetDataByDataHandle(h,s)
#define MemDbGetLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetDataByDataHandleEx(h,b,s)

BOOL
MemDbTestLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbAddLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbAddLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbAddLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

KEYHANDLE
MemDbGetLinkageA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

KEYHANDLE
MemDbGetLinkageW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

KEYHANDLE
MemDbGetLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

BOOL
MemDbTestLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbTestLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbTestLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

// high-level linkage functions
#define MemDbAddSingleLinkageValueA (k,i,l,a) MemDbAddLinkageValueA(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueW (k,i,l,a) MemDbAddLinkageValueW(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueByKeyHandle(k,i,l,a) MemDbAddLinkageValueByKeyHandle(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueByDataHandle(h,l,a) MemDbAddLinkagaValueByDataHandle(h,l,a)
#define MemDbDeleteSingleLinkageValueA(k,i,l,f) MemDbDeleteLinkageValueA(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueW(k,i,l,f) MemDbDeleteLinkageValueW(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueByKeyHandle(k,i,l,f) MemDbDeleteLinkageValueByKeyHandle(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueByDataHandle(h,l,f) MemDbDeleteLinkagaValueByDataHandle(h,l,f)
#define MemDbSetSingleLinkageArrayA(k,i,d,s) MemDbSetLinkageArrayA(k,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayW(k,i,d,s) MemDbSetLinkageArrayW(k,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayByKeyHandle(h,i,d,s) MemDbSetLinkageArrayByKeyHandle(h,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayByDataHandle(h,d,s) MemDbSetLinkageArrayByDataHandle(h,d,s)
#define MemDbGetSingleLinkageArrayA(k,i,s) (PUINT)MemDbGetLinkageArrayA(k,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayW(k,i,s) (PUINT)MemDbGetLinkageArrayW(k,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayByKeyHandle(h,i,s) (PUINT)MemDbGetLinkageArrayByKeyHandle(h,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayByKeyHandleEx(h,i,b,s) (PUINT)MemDbGetLinkageArrayByKeyHandleEx(h,DATAFLAG_SINGLELINK,i,b,s)
#define MemDbGetSingleLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetLinkageArrayByDataHandle(h,s)
#define MemDbGetSingleLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetLinkageArrayByDataHandleEx(h,b,s)
#define MemDbTestSingleLinkageValueA(k,i,l) MemDbTestLinkageValueA(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueW(k,i,l) MemDbTestLinkageValueW(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueByKeyHandle(h,i,l) MemDbTestLinkageValueByKeyHandle(h,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueByDataHandle(h,l) MemDbTestLinkageValueByDataHandle(h,l)

#define MemDbAddDoubleLinkageValueA (k,i,l,a) MemDbAddLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueW (k,i,l,a) MemDbAddLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueByKeyHandle(k,i,l,a) MemDbAddLinkageValueByKeyHandle(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueByDataHandle(h,l,a) MemDbAddLinkagaValueByDataHandle(h,l,a)
#define MemDbDeleteDoubleLinkageValueA(k,i,l,f) MemDbDeleteLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueW(k,i,l,f) MemDbDeleteLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueByKeyHandle(k,i,l,f) MemDbDeleteLinkageValueByKeyHandle(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueByDataHandle(h,l,f) MemDbDeleteLinkagaValueByDataHandle(h,l,f)
#define MemDbSetDoubleLinkageArrayA(k,i,d,s) MemDbSetLinkageArrayA(k,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayW(k,i,d,s) MemDbSetLinkageArrayW(k,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayByKeyHandle(h,i,d,s) MemDbSetLinkageArrayByKeyHandle(h,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayByDataHandle(h,d,s) MemDbSetLinkageArrayByDataHandle(h,d,s)
#define MemDbGetDoubleLinkageArrayA(k,i,s) (PUINT)MemDbGetLinkageArrayA(k,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayW(k,i,s) (PUINT)MemDbGetLinkageArrayW(k,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayByKeyHandle(h,i,s) (PUINT)MemDbGetLinkageArrayByKeyHandle(h,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayByKeyHandleEx(h,i,b,s) (PUINT)MemDbGetLinkageArrayByKeyHandleEx(h,DATAFLAG_DOUBLELINK,i,b,s)
#define MemDbGetDoubleLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetLinkageArrayByDataHandle(h,s)
#define MemDbGetDoubleLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetLinkageArrayByDataHandleEx(h,b,s)
#define MemDbTestDoubleLinkageValueA(k,i,l) MemDbTestLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueW(k,i,l) MemDbTestLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueByKeyHandle(h,i,l) MemDbTestLinkageValueByKeyHandle(h,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueByDataHandle(h,l) MemDbTestLinkageValueByDataHandle(h,l)

#define MemDbAddSingleLinkageA(k1,k2,i) MemDbAddLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbAddSingleLinkageW(k1,k2,i) MemDbAddLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbAddSingleLinkageByKeyHandle(h1,h2,i) MemDbAddLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageA(k1,k2,i) MemDbDeleteLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageW(k1,k2,i) MemDbDeleteLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageByKeyHandle(h1,h2,i) MemDbDeleteLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)
#define MemDbGetSingleLinkageA(k,i,l) MemDbGetLinkageA(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbGetSingleLinkageW(k,i,l) MemDbGetLinkageW(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbGetSingleLinkageByKeyHandle(h,i,l) MemDbGetLinkageByKeyHandle(h,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageA(k1,k2,i) MemDbTestLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbTestSingleLinkageW(k1,k2,i) MemDbTestLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbTestSingleLinkageByKeyHandle(h1,h2,i) MemDbTestLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)

#define MemDbAddDoubleLinkageA(k1,k2,i) MemDbAddLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbAddDoubleLinkageW(k1,k2,i) MemDbAddLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbAddDoubleLinkageByKeyHandle(h1,h2,i) MemDbAddLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageA(k1,k2,i) MemDbDeleteLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageW(k1,k2,i) MemDbDeleteLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageByKeyHandle(h1,h2,i) MemDbDeleteLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)
#define MemDbGetDoubleLinkageA(k,i,l) MemDbGetLinkageA(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbGetDoubleLinkageW(k,i,l) MemDbGetLinkageW(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbGetDoubleLinkageByKeyHandle(h,i,l) MemDbGetLinkageByKeyHandle(h,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageA(k1,k2,i) MemDbTestLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbTestDoubleLinkageW(k1,k2,i) MemDbTestLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbTestDoubleLinkageByKeyHandle(h1,h2,i) MemDbTestLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)

// enumeration functions
BOOL
MemDbEnumFirstA (
    IN OUT  PMEMDB_ENUMA MemDbEnum,
    IN      PCSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel
    );

BOOL
MemDbEnumFirstW (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel
    );

BOOL
MemDbEnumNextA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    );

BOOL
MemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    );

BOOL
MemDbEnumAbortA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    );

BOOL
MemDbEnumAbortW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    );

BOOL
MemDbSetInsertionOrderedA (
    IN      PCSTR Key
    );

BOOL
MemDbSetInsertionOrderedW (
    IN      PCWSTR Key
    );

BOOL
MemDbSaveA (
    IN      PCSTR szFile
    );

BOOL
MemDbSaveW (
    IN      PCWSTR szFile
    );

BOOL
MemDbLoadA (
    IN      PCSTR szFile
    );

BOOL
MemDbLoadW (
    IN      PCWSTR szFile
    );

BOOL
MemDbValidateDatabase (
    VOID
    );

BOOL
MemDbQueryVersionA (
    IN      PCSTR FileName,
    OUT     PMEMDB_VERSION Version
    );

BOOL
MemDbQueryVersionW (
    IN      PCWSTR FileName,
    OUT     PMEMDB_VERSION Version
    );

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbImportA (
    IN      PCSTR FileName
    );

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    );


#define MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1            0x0001
#define MEMDB_CONVERT_WILD_STAR_TO_ASCII_2              0x0002
#define MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3             0x0002
// other conversion to be implemented when needed

VOID MemDbMakeNonPrintableKeyA (PSTR KeyName, UINT Flags);
VOID MemDbMakeNonPrintableKeyW (PWSTR KeyName, UINT Flags);

VOID MemDbMakePrintableKeyA (PSTR KeyName, UINT Flags);
VOID MemDbMakePrintableKeyW (PWSTR KeyName, UINT Flags);

VOID GetFixedUserNameA (PSTR UserName);
VOID GetFixedUserNameW (PWSTR UserName);


#ifdef DEBUG
extern UINT g_DatabaseCheckLevel;
#define MEMDB_CHECKLEVEL1      0x000001
#define MEMDB_CHECKLEVEL2      0x000002
#define MEMDB_CHECKLEVEL3      0x000003

BOOL MemDbCheckDatabase(UINT Level);
UINT MemDbGetDatabaseSize();
#else
#define MemDbCheckDatabase()
#define MemDbGetDatabaseSize()
#endif

//
// A & W
//

#ifdef UNICODE

#define MEMDB_ENUM MEMDB_ENUMW

#define MemDbAddKey MemDbAddKeyW
#define MemDbSetKey MemDbSetKeyW
#define MemDbTestKey MemDbTestKeyW
#define MemDbDeleteKey MemDbDeleteKeyW
#define MemDbDeleteTree MemDbDeleteTreeW
#define MemDbGetKeyFromHandle MemDbGetKeyFromHandleW
#define MemDbGetKeyFromHandleEx MemDbGetKeyFromHandleExW
#define MemDbGetHandleFromKey MemDbGetHandleFromKeyW
#define MemDbSetValueAndFlagsEx MemDbSetValueAndFlagsExW
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsW
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsW
#define MemDbSetValue MemDbSetValueW
#define MemDbGetValue MemDbGetValueW
#define MemDbSetFlags MemDbSetFlagsW
#define MemDbReplaceFlags MemDbReplaceFlagsW
#define MemDbGetFlags MemDbGetFlagsW
#define MemDbAddData MemDbAddDataW
#define MemDbSetData MemDbSetDataW
#define MemDbGrowData MemDbGrowDataW
#define MemDbGetDataHandle MemDbGetDataHandleW
#define MemDbGetData MemDbGetDataW
#define MemDbGetDataEx MemDbGetDataExW
#define MemDbDeleteData MemDbDeleteDataW
#define MemDbAddUnorderedBlob MemDbAddUnorderedBlobW
#define MemDbSetUnorderedBlob MemDbSetUnorderedBlobW
#define MemDbGrowUnorderedBlob MemDbGrowUnorderedBlobW
#define MemDbGetUnorderedBlob MemDbGetUnorderedBlobW
#define MemDbGetUnorderedBlobEx MemDbGetUnorderedBlobExW
#define MemDbDeleteUnorderedBlob MemDbDeleteUnorderedBlobW
#define MemDbAddLinkageValue MemDbAddLinkageValueW
#define MemDbDeleteLinkageValue MemDbDeleteLinkageValueW
#define MemDbSetLinkageArray MemDbSetLinkageArrayW
#define MemDbGetLinkageArray MemDbGetLinkageArrayW
#define MemDbAddSingleLinkageValue MemDbAddSingleLinkageValueW
#define MemDbDeleteSingleLinkageValue MemDbDeleteSingleLinkageValueW
#define MemDbSetSingleLinkageArray MemDbSetSingleLinkageArrayW
#define MemDbGetSingleLinkageArray MemDbGetSingleLinkageArrayW
#define MemDbAddDoubleLinkageValue MemDbAddDoubleLinkageValueW
#define MemDbDeleteDoubleLinkageValue MemDbDeleteDoubleLinkageValueW
#define MemDbSetDoubleLinkageArray MemDbSetDoubleLinkageArrayW
#define MemDbGetDoubleLinkageArray MemDbGetDoubleLinkageArrayW
#define MemDbTestLinkageValue MemDbTestLinkageValueW
#define MemDbTestSingleLinkageValue MemDbTestSingleLinkageValueW
#define MemDbTestDoubleLinkageValue MemDbTestDoubleLinkageValueW
#define MemDbAddLinkage MemDbAddLinkageW
#define MemDbGetLinkage MemDbGetLinkageW
#define MemDbTestLinkage MemDbTestLinkageW
#define MemDbAddSingleLinkage MemDbAddSingleLinkageW
#define MemDbDeleteSingleLinkage MemDbDeleteSingleLinkageW
#define MemDbGetSingleLinkage MemDbGetSingleLinkageW
#define MemDbTestSingleLinkage MemDbTestSingleLinkageW
#define MemDbAddDoubleLinkage MemDbAddDoubleLinkageW
#define MemDbDeleteDoubleLinkage MemDbDeleteDoubleLinkageW
#define MemDbGetDoubleLinkage MemDbGetDoubleLinkageW
#define MemDbTestDoubleLinkage MemDbTestDoubleLinkageW
#define MemDbEnumFirst MemDbEnumFirstW
#define MemDbEnumNext MemDbEnumNextW
#define MemDbEnumAbort MemDbEnumAbortW
#define MEMDB_ENUM MEMDB_ENUMW

#define MemDbSave MemDbSaveW
#define MemDbLoad MemDbLoadW
#define MemDbQueryVersion MemDbQueryVersionW
#define MemDbExport MemDbExportW
#define MemDbImport MemDbImportW
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyW
#define MemDbMakePrintableKey MemDbMakePrintableKeyW
#define GetFixedUserName GetFixedUserNameW

#define MemDbSetInsertionOrdered MemDbSetInsertionOrderedW


#else

#define MEMDB_ENUM MEMDB_ENUMA

#define MemDbAddKey MemDbAddKeyA
#define MemDbSetKey MemDbSetKeyA
#define MemDbTestKey MemDbTestKeyA
#define MemDbDeleteKey MemDbDeleteKeyA
#define MemDbDeleteTree MemDbDeleteTreeA
#define MemDbGetKeyFromHandle MemDbGetKeyFromHandleA
#define MemDbGetKeyFromHandleEx MemDbGetKeyFromHandleExA
#define MemDbGetHandleFromKey MemDbGetHandleFromKeyA
#define MemDbSetValueAndFlagsEx MemDbSetValueAndFlagsExA
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsA
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsA
#define MemDbSetValue MemDbSetValueA
#define MemDbGetValue MemDbGetValueA
#define MemDbSetFlags MemDbSetFlagsA
#define MemDbReplaceFlags MemDbReplaceFlagsA
#define MemDbGetFlags MemDbGetFlagsA
#define MemDbAddData MemDbAddDataA
#define MemDbSetData MemDbSetDataA
#define MemDbGrowData MemDbGrowDataA
#define MemDbGetDataHandle MemDbGetDataHandleA
#define MemDbGetData MemDbGetDataA
#define MemDbGetDataEx MemDbGetDataExA
#define MemDbDeleteData MemDbDeleteDataA
#define MemDbAddUnorderedBlob MemDbAddUnorderedBlobA
#define MemDbSetUnorderedBlob MemDbSetUnorderedBlobA
#define MemDbGrowUnorderedBlob MemDbGrowUnorderedBlobA
#define MemDbGetUnorderedBlob MemDbGetUnorderedBlobA
#define MemDbGetUnorderedBlobEx MemDbGetUnorderedBlobExA
#define MemDbDeleteUnorderedBlob MemDbDeleteUnorderedBlobA
#define MemDbAddLinkageValue MemDbAddLinkageValueA
#define MemDbDeleteLinkageValue MemDbDeleteLinkageValueA
#define MemDbSetLinkageArray MemDbSetLinkageArrayA
#define MemDbGetLinkageArray MemDbGetLinkageArrayA
#define MemDbAddSingleLinkageValue MemDbAddSingleLinkageValueA
#define MemDbDeleteSingleLinkageValue MemDbDeleteSingleLinkageValueA
#define MemDbSetSingleLinkageArray MemDbSetSingleLinkageArrayA
#define MemDbGetSingleLinkageArray MemDbGetSingleLinkageArrayA
#define MemDbAddDoubleLinkageValue MemDbAddDoubleLinkageValueA
#define MemDbDeleteDoubleLinkageValue MemDbDeleteDoubleLinkageValueA
#define MemDbSetDoubleLinkageArray MemDbSetDoubleLinkageArrayA
#define MemDbGetDoubleLinkageArray MemDbGetDoubleLinkageArrayA
#define MemDbTestLinkageValue MemDbTestLinkageValueA
#define MemDbTestSingleLinkageValue MemDbTestSingleLinkageValueA
#define MemDbTestDoubleLinkageValue MemDbTestDoubleLinkageValueA
#define MemDbAddLinkage MemDbAddLinkageA
#define MemDbGetLinkage MemDbGetLinkageA
#define MemDbTestLinkage MemDbTestLinkageA
#define MemDbAddSingleLinkage MemDbAddSingleLinkageA
#define MemDbDeleteSingleLinkage MemDbDeleteSingleLinkageA
#define MemDbGetSingleLinkage MemDbGetSingleLinkageA
#define MemDbTestSingleLinkage MemDbTestSingleLinkageA
#define MemDbAddDoubleLinkage MemDbAddDoubleLinkageA
#define MemDbDeleteDoubleLinkage MemDbDeleteDoubleLinkageA
#define MemDbGetDoubleLinkage MemDbGetDoubleLinkageA
#define MemDbTestDoubleLinkage MemDbTestDoubleLinkageA
#define MemDbEnumFirst MemDbEnumFirstA
#define MemDbEnumNext MemDbEnumNextA
#define MemDbEnumAbort MemDbEnumAbortA
#define MEMDB_ENUM MEMDB_ENUMA

#define MemDbSave MemDbSaveA
#define MemDbLoad MemDbLoadA
#define MemDbQueryVersion MemDbQueryVersionA
#define MemDbExport MemDbExportA
#define MemDbImport MemDbImportA
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyA
#define MemDbMakePrintableKey MemDbMakePrintableKeyA
#define GetFixedUserName GetFixedUserNameA

#define MemDbSetInsertionOrdered MemDbSetInsertionOrderedA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\poolmem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    poolmem.h

Abstract:

    Declares the pool memory interface.  A pool of memory is a set of
    blocks (typically 8K each) that are used for several allocations,
    and then freed at the end of processing.  See below for routines.

Author:

    Marc R. Whitten (marcw)     02-Feb-1997

Revision History:

    jimschm     04-Feb-1998     Named pools for tracking

--*/

#pragma once

/*++

  Create and destroy routines:

    PMHANDLE
    PmCreatePool (
        VOID
        );

    PMHANDLE
    PmCreateNamedPool (
        IN      PCSTR Name
        );

    VOID
    PmDestroyPool (
        IN      PMHANDLE Handle
        );

  Primitive routines:

    PVOID
    PmGetMemory (
        IN      PMHANDLE Handle,
        IN      DWORD Size
        );

    PVOID
    PmGetAlignedMemory (
        IN      PMHANDLE Handle,
        IN      DWORD Size
        );

    VOID
    PmReleaseMemory (
        IN      PMHANDLE Handle,
        IN      PCVOID Memory
        );

  Performance and debugging control:

    VOID
    PmSetMinimumGrowthSize (
        IN      PMHANDLE Handle,
        IN      DWORD GrowthSize
        );

    VOID
    PmEmptyPool (
        IN      PMHANDLE Handle
        );

    VOID
    PmDisableTracking (
        IN      PMHANDLE Handle
        );

  Allocation and duplication of data types:

    PCTSTR
    PmCreateString (
        IN      PMHANDLE Handle,
        IN      UINT TcharCount
        );

    PCTSTR
    PmCreateDword (
        IN      PMHANDLE Handle
        );

    PBYTE
    PmDuplicateMemory (
        IN      PMHANDLE Handle,
        IN      PBYTE Data,
        IN      UINT DataSize
        );

    PDWORD
    PmDuplciateDword (
        IN      PMHANDLE Handle,
        IN      DWORD Data
        );

    PTSTR
    PmDuplicateString (
        IN      PMHANDLE Handle,
        IN      PCTSTR String
        );

    PTSTR
    PmDuplicateMultiSz (
        IN      PMHANDLE Handle,
        IN      PCTSTR MultiSz
        );


--*/


//
// Default size of memory pool blocks. This can be changed on a per-pool basis
// by calling PmSetMinimumGrowthSize().
//

#define POOLMEMORYBLOCKSIZE 8192

//
// if DEBUG is defined, poolmem keeps a tally of common statistics on all
// pools. These include number of alloc and free requests, number of
// actual allocations and frees, and various size measures.
//
// PoolMem also checks each PmReleaseMemory() call to ensure that the
// address passed is a valid poolmem address that has not yet been freed.
//

PMHANDLE
RealPmCreatePool (
    VOID
    );

#define PmCreatePool()              TRACK_BEGIN(PMHANDLE, PmCreatePool)\
                                    RealPmCreatePool()\
                                    TRACK_END()

#ifdef DEBUG

PMHANDLE
RealPmCreateNamedPool (
    IN      PCSTR Name
    );

#define PmCreateNamedPool(n)        TRACK_BEGIN(PMHANDLE, PmCreateNamedPool)\
                                    RealPmCreateNamedPool(n)\
                                    TRACK_END()
#else

#define PmCreateNamedPool(x) PmCreatePool()

#endif

VOID
PmDestroyPool (
    IN PMHANDLE Handle
    );


//
// Callers should use PmGetMemory or PmGetAlignedMemory. These each decay into
// RealPmGetMemory.
//

PVOID
RealPmGetMemory (
    IN      PMHANDLE Handle,
    IN      SIZE_T Size,
    IN      DWORD AlignSize
    );

#define PmGetMemory(h,s)           TRACK_BEGIN(PVOID, PmGetMemory)\
                                   RealPmGetMemory((h),(s),0)\
                                   TRACK_END()

#define PmGetAlignedMemory(h,s)    TRACK_BEGIN(PVOID, PmGetAlignedMemory)\
                                   RealPmGetMemory((h),(s),sizeof(DWORD))\
                                   TRACK_END()

VOID PmReleaseMemory (IN PMHANDLE Handle, IN PCVOID Memory);
VOID PmSetMinimumGrowthSize(IN PMHANDLE Handle, IN SIZE_T Size);


VOID
PmEmptyPool (
    IN      PMHANDLE Handle
    );


//
// PoolMem created strings are always aligned on DWORD boundaries.
//
#define PmCreateString(h,x) ((LPTSTR) PmGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PmCreateDword(h)    ((PDWORD) PmGetMemory((h),sizeof(DWORD)))


__inline
PBYTE
PmDuplicateMemory (
    IN PMHANDLE Handle,
    IN PCBYTE DataToCopy,
    IN UINT SizeOfData
    )
{
    PBYTE Data;

    Data = (PBYTE) PmGetAlignedMemory (Handle, SizeOfData);
    if (Data) {
        CopyMemory (Data, DataToCopy, SizeOfData);
    }

    return Data;
}


__inline
PDWORD
PmDuplicateDword (
    IN PMHANDLE Handle,
    IN DWORD ValueToCopy
    )
{
    PDWORD rWord;

    rWord = (PDWORD) PmGetMemory (Handle, sizeof (ValueToCopy));
    if (rWord) {
        *rWord = ValueToCopy;
    }

    return rWord;
}


__inline
PSTR
RealPmDuplicateStringA (
    IN PMHANDLE Handle,
    IN PCSTR StringToCopy
    )

{
    PSTR rString = RealPmGetMemory (
                        Handle,
                        SizeOfStringA (StringToCopy),
                        sizeof(WCHAR)
                        );

    if (rString) {

        StringCopyA (rString, StringToCopy);
    }

    return rString;
}

#define PmDuplicateStringA(h,s)    TRACK_BEGIN(PSTR, PmDuplicateStringA)\
                                   RealPmDuplicateStringA(h,s)\
                                   TRACK_END()


__inline
PWSTR
RealPmDuplicateStringW (
    IN PMHANDLE Handle,
    IN PCWSTR StringToCopy
    )

{
    PWSTR rString = RealPmGetMemory (
                        Handle,
                        SizeOfStringW (StringToCopy),
                        sizeof(WCHAR)
                        );

    if (rString) {

        StringCopyW (rString, StringToCopy);
    }

    return rString;
}

#define PmDuplicateStringW(h,s)    TRACK_BEGIN(PWSTR, PmDuplicateStringA)\
                                   RealPmDuplicateStringW(h,s)\
                                   TRACK_END()


__inline
PSTR
RealPmDuplicateStringABA (
    IN PMHANDLE Handle,
    IN PCSTR StringStart,
    IN PCSTR End
    )

{
    PSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = RealPmGetMemory (
                    Handle,
                    // cast is OK, we don't expenct pointers to be far away from each other
                    (DWORD)((UBINT) End - (UBINT) StringStart) + sizeof (CHAR),
                    sizeof(WCHAR)
                    );

    if (rString) {

        StringCopyABA (rString, StringStart, End);
    }

    return rString;
}

#define PmDuplicateStringABA(h,s,e)     TRACK_BEGIN(PSTR, PmDuplicateStringABA)\
                                        RealPmDuplicateStringABA(h,s,e)\
                                        TRACK_END()



__inline
PWSTR
RealPmDuplicateStringABW (
    IN PMHANDLE Handle,
    IN PCWSTR StringStart,
    IN PCWSTR End
    )

{
    PWSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = RealPmGetMemory (
                    Handle,
                    (DWORD)((UBINT) End - (UBINT) StringStart) + sizeof (WCHAR),
                    sizeof(WCHAR)
                    );

    if (rString) {

        StringCopyABW (rString,StringStart,End);
    }

    return rString;
}

#define PmDuplicateStringABW(h,s,e)     TRACK_BEGIN(PSTR, PmDuplicateStringABW)\
                                        RealPmDuplicateStringABW(h,s,e)\
                                        TRACK_END()


PSTR
PmDuplicateMultiSzA (
    IN PMHANDLE Handle,
    IN PCSTR MultiSzToCopy
    );

PWSTR
PmDuplicateMultiSzW (
    IN PMHANDLE Handle,
    IN PCWSTR MultiSzToCopy
    );

#ifdef UNICODE
#define PmDuplicateString  PmDuplicateStringW
#define PmDuplicateMultiSz PmDuplicateMultiSzW
#else
#define PmDuplicateString  PmDuplicateStringA
#define PmDuplicateMultiSz PmDuplicateMultiSzA
#endif

#ifdef DEBUG

VOID
PmDisableTracking (
    IN PMHANDLE Handle
    );

#else

#define PmDisableTracking(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\regenum.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regenum.h

Abstract:

    Set of APIs to enumerate the local registry using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

#define REGENUM_ALL_SUBLEVELS   0xFFFFFFFF

#define REG_ATTRIBUTE_KEY       0x00000001
#define REG_ATTRIBUTE_VALUE     0x00000002

//
// Root enumeration structures
//

typedef struct {
    PCSTR   RegRootName;
    HKEY    RegRootHandle;
    UINT    Index;
} REGROOT_ENUMA, *PREGROOT_ENUMA;

typedef struct {
    PCWSTR  RegRootName;
    HKEY    RegRootHandle;
    UINT    Index;
} REGROOT_ENUMW, *PREGROOT_ENUMW;

//
// Key/Values enumeration structures
//

typedef enum {
    RECF_SKIPKEY                = 0x0001,
    RECF_SKIPSUBKEYS            = 0x0002,
    RECF_SKIPVALUES             = 0x0004,
} REGENUM_CONTROLFLAGS;

typedef enum {
    REIF_RETURN_KEYS            = 0x0001,
    REIF_VALUES_FIRST           = 0x0002,
    REIF_DEPTH_FIRST            = 0x0004,
    REIF_USE_EXCLUSIONS         = 0x0008,
} REGENUMINFOFLAGS;

typedef enum {
    RNS_ENUM_INIT,
    RNS_VALUE_FIRST,
    RNS_VALUE_NEXT,
    RNS_VALUE_DONE,
    RNS_SUBKEY_FIRST,
    RNS_SUBKEY_NEXT,
    RNS_SUBKEY_DONE,
    RNS_ENUM_DONE
} RNS_ENUM_STATE;

typedef enum {
    RES_ROOT_FIRST,
    RES_ROOT_NEXT,
    RES_ROOT_DONE
} RES_ROOT_STATE;


typedef enum {
    RNF_RETURN_KEYS         = 0x0001,
    RNF_KEYNAME_MATCHES     = 0x0002,
    RNF_VALUENAME_INVALID   = 0x0004,
    RNF_VALUEDATA_INVALID   = 0x0008,
} REGNODE_FLAGS;

typedef struct {
    PCSTR   KeyName;
    HKEY    KeyHandle;
    DWORD   ValueCount;
    PSTR    ValueName;
    DWORD   ValueLengthMax;
    DWORD   ValueType;
    PBYTE   ValueData;
    DWORD   ValueDataSize;
    DWORD   ValueDataSizeMax;
    DWORD   SubKeyCount;
    PSTR    SubKeyName;
    DWORD   SubKeyLengthMax;
    DWORD   SubKeyIndex;
    DWORD   ValueIndex;
    DWORD   EnumState;
    DWORD   Flags;
    DWORD   SubLevel;
} REGNODEA, *PREGNODEA;

typedef struct {
    PCWSTR  KeyName;
    HKEY    KeyHandle;
    DWORD   ValueCount;
    PWSTR   ValueName;
    DWORD   ValueLengthMax;
    DWORD   ValueType;
    PBYTE   ValueData;
    DWORD   ValueDataSize;
    DWORD   ValueDataSizeMax;
    DWORD   SubKeyCount;
    PWSTR   SubKeyName;
    DWORD   SubKeyLengthMax;
    DWORD   SubKeyIndex;
    DWORD   ValueIndex;
    DWORD   EnumState;
    DWORD   Flags;
    DWORD   SubLevel;
} REGNODEW, *PREGNODEW;

typedef BOOL (*RPE_ERROR_CALLBACKA)(PREGNODEA);

typedef struct {
    POBSPARSEDPATTERNA      RegPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    RPE_ERROR_CALLBACKA     CallbackOnError;
} REGENUMINFOA, *PREGENUMINFOA;

typedef BOOL (*RPE_ERROR_CALLBACKW)(PREGNODEW);

typedef struct {
    POBSPARSEDPATTERNW      RegPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    RPE_ERROR_CALLBACKW     CallbackOnError;
} REGENUMINFOW, *PREGENUMINFOW;

typedef struct {
    PCSTR           EncodedFullName;
    PCSTR           Name;
    PCSTR           Location;
    CHAR            NativeFullName[MAX_MBCHAR_PATH];
    PBYTE           CurrentValueData;
    DWORD           CurrentValueType;
    HKEY            CurrentKeyHandle;
    DWORD           CurrentLevel;
    DWORD           Attributes;

    //
    // Private members
    //
    DWORD           ControlFlags;
    REGENUMINFOA    RegEnumInfo;
    GROWBUFFER      RegNodes;
    DWORD           RootState;
    PREGROOT_ENUMA  RootEnum;
    PREGNODEA       LastNode;
    PSTR            RegNameAppendPos;
    PSTR            LastWackPtr;
} REGTREE_ENUMA, *PREGTREE_ENUMA;

typedef struct {
    PCWSTR          EncodedFullName;
    PCWSTR          Name;
    PCWSTR          Location;
    WCHAR           NativeFullName[MAX_WCHAR_PATH];
    PBYTE           CurrentValueData;
    DWORD           CurrentValueType;
    HKEY            CurrentKeyHandle;
    DWORD           CurrentLevel;
    DWORD           Attributes;

    //
    // Private members
    //
    DWORD           ControlFlags;
    REGENUMINFOW    RegEnumInfo;
    GROWBUFFER      RegNodes;
    DWORD           RootState;
    PREGROOT_ENUMW  RootEnum;
    PREGNODEW       LastNode;
    PWSTR           RegNameAppendPos;
    PWSTR           LastWackPtr;
} REGTREE_ENUMW, *PREGTREE_ENUMW;


//
// API
//

BOOL
RegEnumInitialize (
    VOID
    );

VOID
RegEnumTerminate (
    VOID
    );

BOOL
RegEnumDefaultCallbackA (
    IN      PREGNODEA RegNode       OPTIONAL
    );

BOOL
RegEnumDefaultCallbackW (
    IN      PREGNODEW RegNode       OPTIONAL
    );

BOOL
EnumFirstRegRootA (
    OUT     PREGROOT_ENUMA EnumPtr
    );

BOOL
EnumFirstRegRootW (
    OUT     PREGROOT_ENUMW EnumPtr
    );

BOOL
EnumNextRegRootA (
    IN OUT  PREGROOT_ENUMA EnumPtr
    );

BOOL
EnumNextRegRootW (
    IN OUT  PREGROOT_ENUMW EnumPtr
    );

BOOL
EnumFirstRegObjectInTreeExA (
    OUT     PREGTREE_ENUMA RegEnum,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      RPE_ERROR_CALLBACKA CallbackOnError     OPTIONAL
    );

#define EnumFirstRegObjectInTreeA(e,p)  EnumFirstRegObjectInTreeExA(e,p,TRUE,TRUE,TRUE,REGENUM_ALL_SUBLEVELS,FALSE,RegEnumDefaultCallbackA)

BOOL
EnumFirstRegObjectInTreeExW (
    OUT     PREGTREE_ENUMW RegEnum,
    IN      PCWSTR EncodedKeyPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      RPE_ERROR_CALLBACKW CallbackOnError     OPTIONAL
    );

#define EnumFirstRegObjectInTreeW(e,p)  EnumFirstRegObjectInTreeExW(e,p,TRUE,TRUE,TRUE,REGENUM_ALL_SUBLEVELS,FALSE,RegEnumDefaultCallbackW)

BOOL
EnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    );

BOOL
EnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    );

VOID
AbortEnumRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    );

VOID
AbortEnumRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    );


//
// Macros
//

#ifdef UNICODE

#define RegEnumDefaultCallback      RegEnumDefaultCallbackW
#define REGROOT_ENUM                REGROOT_ENUMW
#define EnumFirstRegRoot            EnumFirstRegRootW
#define EnumNextRegRoot             EnumNextRegRootW
#define REGNODE                     REGNODEW
#define PREGNODE                    PREGNODEW
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKW
#define REGENUMINFO                 REGENUMINFOW
#define PREGENUMINFO                PREGENUMINFOW
#define REGTREE_ENUM                REGTREE_ENUMW
#define PREGTREE_ENUM               PREGTREE_ENUMW
#define EnumFirstRegObjectInTree    EnumFirstRegObjectInTreeW
#define EnumFirstRegObjectInTreeEx  EnumFirstRegObjectInTreeExW
#define EnumNextRegObjectInTree     EnumNextRegObjectInTreeW
#define AbortEnumRegObjectInTree    AbortEnumRegObjectInTreeW

#else

#define RegEnumDefaultCallback      RegEnumDefaultCallbackA
#define REGROOT_ENUM                REGROOT_ENUMA
#define EnumFirstRegRoot            EnumFirstRegRootA
#define EnumNextRegRoot             EnumNextRegRootA
#define REGNODE                     REGNODEA
#define PREGNODE                    PREGNODEA
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKA
#define REGENUMINFO                 REGENUMINFOA
#define PREGENUMINFO                PREGENUMINFOA
#define REGTREE_ENUM                REGTREE_ENUMA
#define PREGTREE_ENUM               PREGTREE_ENUMA
#define EnumFirstRegObjectInTree    EnumFirstRegObjectInTreeA
#define EnumFirstRegObjectInTreeEx  EnumFirstRegObjectInTreeExA
#define EnumNextRegObjectInTree     EnumNextRegObjectInTreeA
#define AbortEnumRegObjectInTree    AbortEnumRegObjectInTreeA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\objstr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    objstr.h

Abstract:

    Implements a set of APIs to handle the string representation of nodes/leafs of a tree

Author:

    03-Jan-2000 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

/*
                                   +-------+
                                   | root1 |                            Level 1
                                   +-------+
                                      / \
                                    /     \
                          +---------+     (-------)
                          |  node1  |    (  leaf1  )                    Level 2
                          +---------+     (-------)
                          /  |   \  \__________
                        /    |     \           \
               +-------+ +-------+  (-------)   (-------)
               | node2 | | node3 | (  leaf2  ) (  leaf3  )              Level 3
               +-------+ +-------+  (-------)   (-------)
                  / \
                /     \
          +-------+  (-------)
          | node4 | (  leaf4  )                                         Level 4
          +-------+  (-------)
             / \
           /     \
    (-------)   (-------)
   (  leaf5  ) (  leaf6  )                                              Level 5
    (-------)   (-------)


    The string representation of some tree elements above:

    root1
    root1 <leaf1>
    root1\node1
    root1\node1 <leaf2>
    root1\node1 <leaf3>

*/


//
// Types
//

typedef enum {
    OBSPF_EXACTNODE             = 0x0001,
    OBSPF_NODEISROOTPLUSSTAR    = 0x0002,
    OBSPF_OPTIONALNODE          = 0x0004,
    OBSPF_NOLEAF                = 0x0008,
    OBSPF_EXACTLEAF             = 0x0010,
    OBSPF_OPTIONALLEAF          = 0x0020,
} OBSP_FLAGS;

typedef struct {
    PPARSEDPATTERNA     NodePattern;
    PPARSEDPATTERNA     LeafPattern;
    PSTR                ExactRoot;
    DWORD               ExactRootBytes;
    PCSTR               Leaf;
    DWORD               MinNodeLevel;
    DWORD               MaxNodeLevel;
    DWORD               MaxSubLevel;
    DWORD               Flags;
} OBSPARSEDPATTERNA, *POBSPARSEDPATTERNA;

typedef struct {
    PPARSEDPATTERNW     NodePattern;
    PPARSEDPATTERNW     LeafPattern;
    PWSTR               ExactRoot;
    DWORD               ExactRootBytes;
    PCWSTR              Leaf;
    DWORD               MinNodeLevel;
    DWORD               MaxNodeLevel;
    DWORD               MaxSubLevel;
    DWORD               Flags;
} OBSPARSEDPATTERNW, *POBSPARSEDPATTERNW;

//
// APIs
//

BOOL
ObsInitialize (
    VOID
    );

VOID
ObsTerminate (
    VOID
    );

VOID
ObsFreeA (
    IN      PCSTR EncodedObject
    );

VOID
ObsFreeW (
    IN      PCWSTR EncodedObject
    );

BOOL
ObsSplitObjectStringExA (
    IN      PCSTR EncodedObject,
    OUT     PSTR* DecodedNode,          OPTIONAL
    OUT     PSTR* DecodedLeaf,          OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    );

#define ObsSplitObjectStringA(o,n,l)    ObsSplitObjectStringExA(o,n,l,NULL,TRUE)

BOOL
ObsSplitObjectStringExW (
    IN      PCWSTR EncodedObject,
    OUT     PWSTR* DecodedNode,         OPTIONAL
    OUT     PWSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    );

#define ObsSplitObjectStringW(o,n,l)    ObsSplitObjectStringExW(o,n,l,NULL,TRUE)

PSTR
ObsBuildEncodedObjectStringFromPatternA (
    IN      POBSPARSEDPATTERNA Pattern
    );

PWSTR
ObsBuildEncodedObjectStringFromPatternW (
    IN      POBSPARSEDPATTERNW Pattern
    );

PSTR
ObsBuildEncodedObjectStringExA (
    IN      PCSTR DecodedNode,
    IN      PCSTR DecodedLeaf,          OPTIONAL
    IN      BOOL EncodeString
    );

#define ObsBuildEncodedObjectStringA(node,leaf) ObsBuildEncodedObjectStringExA(node,leaf,FALSE)

PWSTR
ObsBuildEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,         OPTIONAL
    IN      BOOL EncodeString
    );

#define ObsBuildEncodedObjectStringW(node,leaf) ObsBuildEncodedObjectStringExW(node,leaf,FALSE)

POBSPARSEDPATTERNA
ObsCreateParsedPatternExA (
    IN      PCSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    );

#define ObsCreateParsedPatternA(obj)        ObsCreateParsedPatternExA (obj,FALSE)

POBSPARSEDPATTERNW
ObsCreateParsedPatternExW (
    IN      PCWSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    );

#define ObsCreateParsedPatternW(obj)        ObsCreateParsedPatternExW (obj,FALSE)

VOID
ObsDestroyParsedPatternA (
    IN      POBSPARSEDPATTERNA ParsedPattern
    );

VOID
ObsDestroyParsedPatternW (
    IN      POBSPARSEDPATTERNW ParsedPattern
    );

BOOL
ObsParsedPatternMatchA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR EncodedObject
    );

BOOL
ObsParsedPatternMatchW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR EncodedObject
    );

BOOL
ObsParsedPatternMatchExA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR Node,
    IN      PCSTR Leaf                          OPTIONAL
    );

BOOL
ObsParsedPatternMatchExW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR Node,
    IN      PCWSTR Leaf                         OPTIONAL
    );

BOOL
ObsPatternMatchA (
    IN      PCSTR ObjectPattern,
    IN      PCSTR ObjectStr
    );

BOOL
ObsPatternMatchW (
    IN      PCWSTR ObjectPattern,
    IN      PCWSTR ObjectStr
    );

BOOL
ObsIsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    );

BOOL
ObsIsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    );

BOOL
ObsGetPatternLevelsA (
    IN      PCSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    );

BOOL
ObsGetPatternLevelsW (
    IN      PCWSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    );

BOOL
ObsPatternIncludesPatternA (
    IN      POBSPARSEDPATTERNA IncludingPattern,
    IN      POBSPARSEDPATTERNA IncludedPattern
    );

BOOL
ObsPatternIncludesPatternW (
    IN      POBSPARSEDPATTERNW IncludingPattern,
    IN      POBSPARSEDPATTERNW IncludedPattern
    );

//
// Macros
//

#ifdef UNICODE

#define ObsFree                                 ObsFreeW
#define ObsSplitObjectString                    ObsSplitObjectStringW
#define ObsSplitObjectStringEx                  ObsSplitObjectStringExW
#define ObsBuildEncodedObjectStringFromPattern  ObsBuildEncodedObjectStringFromPatternW
#define ObsBuildEncodedObjectStringEx           ObsBuildEncodedObjectStringExW
#define ObsBuildEncodedObjectString             ObsBuildEncodedObjectStringW
#define ObsCreateParsedPattern                  ObsCreateParsedPatternW
#define ObsCreateParsedPatternEx                ObsCreateParsedPatternExW
#define ObsDestroyParsedPattern                 ObsDestroyParsedPatternW
#define ObsParsedPatternMatch                   ObsParsedPatternMatchW
#define ObsParsedPatternMatchEx                 ObsParsedPatternMatchExW
#define ObsPatternMatch                         ObsPatternMatchW
#define ObsIsPatternContained                   ObsIsPatternContainedW
#define ObsGetPatternLevels                     ObsGetPatternLevelsW
#define ObsPatternIncludesPattern               ObsPatternIncludesPatternW

#else

#define ObsFree                                 ObsFreeA
#define ObsSplitObjectString                    ObsSplitObjectStringA
#define ObsSplitObjectStringEx                  ObsSplitObjectStringExA
#define ObsBuildEncodedObjectStringFromPattern  ObsBuildEncodedObjectStringFromPatternA
#define ObsBuildEncodedObjectStringEx           ObsBuildEncodedObjectStringExA
#define ObsBuildEncodedObjectString             ObsBuildEncodedObjectStringA
#define ObsCreateParsedPattern                  ObsCreateParsedPatternA
#define ObsCreateParsedPatternEx                ObsCreateParsedPatternExA
#define ObsDestroyParsedPattern                 ObsDestroyParsedPatternA
#define ObsParsedPatternMatch                   ObsParsedPatternMatchA
#define ObsParsedPatternMatchEx                 ObsParsedPatternMatchExA
#define ObsPatternMatch                         ObsPatternMatchA
#define ObsIsPatternContained                   ObsIsPatternContainedA
#define ObsGetPatternLevels                     ObsGetPatternLevelsA
#define ObsPatternIncludesPattern               ObsPatternIncludesPatternA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\reg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg.h

Abstract:

    Implements macros to simplify the registry APIs and to track
    the resource allocations.

Author:

    Jim Schmidt (jimschm) 24-Mar-1997

Revision History:

    jimschm 09-Apr-1997     Expanded Get functionality

--*/

#pragma once

#define HKEY_ROOT   ((HKEY) 0X7FFFFFFF)


//
// APIs to set access mode
//

REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    );

//
// Tracking of registry calls.  These functions are completely
// turned off for non-debug builds and are mapped to the standard
// Win32 APIs via macro definitions.
//

//
// The Track* API take the same params as the Reg* equivalents.
// The Our* API also take the same params as the Reg* equivalents, but
// the debug versions have two extra parameters, File and Line.
//

//
// Use the Track* API set instead of the Reg* API set.
//

#ifndef DEBUG

#define DumpOpenKeys()

#define TrackedRegOpenKey             RegOpenKey
#define TrackedRegCreateKey           RegCreateKey
#define TrackedRegOpenKeyEx           RegOpenKeyEx
#define TrackedRegCreateKeyEx         RegCreateKeyEx

#define TrackedRegOpenKeyA            RegOpenKeyA
#define TrackedRegCreateKeyA          RegCreateKeyA
#define TrackedRegOpenKeyExA          RegOpenKeyExA
#define TrackedRegCreateKeyExA        RegCreateKeyExA

#define TrackedRegOpenKeyW            RegOpenKeyW
#define TrackedRegCreateKeyW          RegCreateKeyW
#define TrackedRegOpenKeyExW          RegOpenKeyExW
#define TrackedRegCreateKeyExW        RegCreateKeyExW

#define OurRegOpenKeyExA            RegOpenKeyExA
#define OurRegCreateKeyExA          RegCreateKeyExA

#define OurRegOpenRootKeyA(a,b)
#define OurRegOpenRootKeyW(a,b)

#define OurRegOpenKeyExW            RegOpenKeyExW
#define OurRegCreateKeyExW          RegCreateKeyExW

#define CloseRegKey                 RealCloseRegKey

#define DEBUG_TRACKING_PARAMS
#define DEBUG_TRACKING_ARGS

#else

extern DWORD g_DontCare;

#define DEBUG_TRACKING_PARAMS       ,PCSTR File,DWORD Line
#define DEBUG_TRACKING_ARGS         , File, Line

VOID
DumpOpenKeys (
    VOID
    );

LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );


VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#ifdef UNICODE
#define OurRegOpenRootKey OurRegOpenRootKeyW
#else
#define OurRegOpenRootKey OurRegOpenRootKeyA
#endif


LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    );

#define CloseRegKey(k) OurCloseRegKey(k,__FILE__,__LINE__)


#define TrackedRegOpenKeyEx(key,subkey,u,sam,res) OurRegOpenKeyEx(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKey(k,sk,rp) OurRegOpenKeyEx(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKey(k,sk,rp) OurRegCreateKeyEx(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExA(key,subkey,u,sam,res) OurRegOpenKeyExA(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyA(k,sk,rp) OurRegOpenKeyExA(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyA(k,sk,rp) OurRegCreateKeyExA(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExW(key,subkey,u,sam,res) OurRegOpenKeyExW(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyW(k,sk,rp) OurRegOpenKeyExW(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyW(K,sk,rp) OurRegCreateKeyExW(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

//
// Undefine the real registry APIs -- using them will throw off the tracking
//

#undef RegOpenKey
#undef RegCreateKey
#undef RegOpenKeyEx
#undef RegCreateKeyEx

#define RegCloseKey USE_CloseRegKey
#define RegOpenKeyA USE_TrackedRegOpenKeyA
#define RegCreateKeyA USE_TrackedRegCreateKeyA
#define RegOpenKeyExA USE_TrackedRegOpenKeyExA
#define RegCreateKeyExA USE_TrackedRegCreateKeyExA
#define RegOpenKeyW USE_TrackedRegOpenKeyw
#define RegCreateKeyW USE_TrackedRegCreateKeyW
#define RegOpenKeyExW USE_TrackedRegOpenKeyExW
#define RegCreateKeyExW USE_TrackedRegCreateKeyExW

#endif


#ifdef UNICODE
#define OurRegOpenKeyEx         OurRegOpenKeyExW
#define OurRegCreateKeyEx       OurRegCreateKeyExW
#else
#define OurRegOpenKeyEx         OurRegOpenKeyExA
#define OurRegCreateKeyEx       OurRegCreateKeyExA
#endif

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    );

PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    );

#define CreateEncodedRegistryStringA(k,v) CreateEncodedRegistryStringExA(k,v,TRUE)
#define CreateEncodedRegistryStringW(k,v) CreateEncodedRegistryStringExW(k,v,TRUE)

VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    );

VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    );


BOOL
DecodeRegistryStringA (
    IN      PCSTR RegString,
    OUT     PSTR KeyBuf,            OPTIONAL
    OUT     PSTR ValueBuf,          OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );

BOOL
DecodeRegistryStringW (
    IN      PCWSTR RegString,
    OUT     PWSTR KeyBuf,           OPTIONAL
    OUT     PWSTR ValueBuf,         OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );


//
// Versions that allow caller to specify allocator, and macro that uses
// MemAllocWrapper
//

typedef PVOID (ALLOCATOR_PROTOTYPE)(DWORD Size);
typedef ALLOCATOR_PROTOTYPE * ALLOCATOR;

ALLOCATOR_PROTOTYPE MemAllocWrapper;

typedef VOID (DEALLOCATOR_PROTOTYPE)(PVOID Mem);
typedef DEALLOCATOR_PROTOTYPE * DEALLOCATOR;

DEALLOCATOR_PROTOTYPE MemFreeWrapper;

BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataA(key,valuename) TRACK_BEGIN(PBYTE, GetRegValueDataA)\
                                        GetRegValueData2A((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        TRACK_END()


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataW(key,valuename) TRACK_BEGIN(PBYTE,GetRegValueDataW)\
                                        GetRegValueData2W((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        TRACK_END()

PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeA(key,valuename,type)  TRACK_BEGIN(PBYTE, GetRegValueDataOfTypeA)\
                                                    GetRegValueDataOfType2A((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    TRACK_END()

PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeW(key,valuename,type)  TRACK_BEGIN(PBYTE, GetRegValueDataOfTypeW)\
                                                    GetRegValueDataOfType2W((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    TRACK_END()

PBYTE
GetRegKeyData2A (
    IN      HKEY hKey,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataA(key,subkey)  TRACK_BEGIN(PBYTE, GetRegKeyDataA)\
                                    GetRegKeyData2A((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

PBYTE
GetRegKeyData2W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataW(key,subkey)  TRACK_BEGIN(PBYTE, GetRegKeyDataW)\
                                    GetRegKeyData2W((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataA(keystr,value) TRACK_BEGIN(PBYTE, GetRegDataA)\
                                  GetRegData2A((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                  TRACK_END()

PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataW(keystr,value)   TRACK_BEGIN(PBYTE, GetRegDataW)\
                                    GetRegData2W((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    );


//
// Reg key create & open
//

HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
RealCloseRegKey (
    IN      HKEY Key
    );


#ifdef DEBUG

#define CreateRegKeyA(a,b) RealCreateRegKeyA(a,b,__FILE__,__LINE__)
#define CreateRegKeyW(a,b) RealCreateRegKeyW(a,b,__FILE__,__LINE__)
#define CreateRegKeyStrA(a) RealCreateRegKeyStrA(a,__FILE__,__LINE__)
#define CreateRegKeyStrW(a) RealCreateRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyStrA(a) RealOpenRegKeyStrA(a,__FILE__,__LINE__)
#define OpenRegKeyStrW(a) RealOpenRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyA(a,b) RealOpenRegKeyA(a,b,__FILE__,__LINE__)
#define OpenRegKeyW(a,b) RealOpenRegKeyW(a,b,__FILE__,__LINE__)

#else

#define CreateRegKeyA RealCreateRegKeyA
#define CreateRegKeyW RealCreateRegKeyW
#define CreateRegKeyStrA RealCreateRegKeyStrA
#define CreateRegKeyStrW RealCreateRegKeyStrW
#define OpenRegKeyStrA RealOpenRegKeyStrA
#define OpenRegKeyStrW RealOpenRegKeyStrW
#define OpenRegKeyA RealOpenRegKeyA
#define OpenRegKeyW RealOpenRegKeyW

#endif


//
// Registry root functions
//

VOID
SetRegRoot (
    IN      HKEY Root
    );

HKEY
GetRegRoot (
    VOID
    );


// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootStringA (PCSTR RootString, PDWORD LengthPtr OPTIONAL);
INT GetOffsetOfRootStringW (PCWSTR RootString, PDWORD LengthPtr OPTIONAL);

// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootKey (HKEY RootKey);

// Given non-zero array offset to root, returns string or NULL if element
// is out of bounds
PCSTR GetRootStringFromOffsetA (INT i);
PCWSTR GetRootStringFromOffsetW (INT i);

// Given non-zero array offset to root, returns registry handle or NULL if
// element is out of bounds
HKEY GetRootKeyFromOffset (INT i);

// Converts the root at the head of RegPath to an HKEY and gives the number
// of characters occupied by the root string (including optional wack)
HKEY ConvertRootStringToKeyA (PCSTR RegPath, PDWORD LengthPtr OPTIONAL);
HKEY ConvertRootStringToKeyW (PCWSTR RegPath, PDWORD LengthPtr OPTIONAL);

// Returns a pointer to a static string for the matching root, or NULL if
// RegRoot does not point to a valid root
PCSTR ConvertKeyToRootStringA (HKEY RegRoot);
PCWSTR ConvertKeyToRootStringW (HKEY RegRoot);



//
// Macros
//

#define GetRegValueStringA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_SZ)
#define GetRegValueBinaryA(key,valuename) (PBYTE) GetRegValueDataOfTypeA((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordA(key,valuename) (PDWORD) GetRegValueDataOfTypeA((key),(valuename),REG_DWORD)

#define GetRegValueStringW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_SZ)
#define GetRegValueBinaryW(key,valuename) (PBYTE) GetRegValueDataOfTypeW((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordW(key,valuename) (PDWORD) GetRegValueDataOfTypeW((key),(valuename),REG_DWORD)

#define GetRegValueString2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_DWORD,alloc,free)

#define GetRegValueString2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeW
#define GetRegValueData                 GetRegValueDataW
#define GetRegValueDataOfType           GetRegValueDataOfTypeW
#define GetRegKeyData                   GetRegKeyDataW
#define GetRegValueData2                GetRegValueData2W
#define GetRegValueDataOfType2          GetRegValueDataOfType2W
#define GetRegKeyData2                  GetRegKeyData2W
#define GetRegValueString               GetRegValueStringW
#define GetRegValueBinary               GetRegValueBinaryW
#define GetRegValueMultiSz              GetRegValueMultiSzW
#define GetRegValueDword                GetRegValueDwordW
#define GetRegValueString2              GetRegValueString2W
#define GetRegValueBinary2              GetRegValueBinary2W
#define GetRegValueMultiSz2             GetRegValueMultiSz2W
#define GetRegValueDword2               GetRegValueDword2W
#define GetRegData2                     GetRegData2W
#define GetRegData                      GetRegDataW

#define CreateRegKey                    CreateRegKeyW
#define CreateRegKeyStr                 CreateRegKeyStrW
#define OpenRegKey                      OpenRegKeyW
#define OpenRegKeyStr                   OpenRegKeyStrW
#define GetOffsetOfRootString           GetOffsetOfRootStringW
#define GetRootStringFromOffset         GetRootStringFromOffsetW
#define ConvertRootStringToKey          ConvertRootStringToKeyW
#define ConvertKeyToRootString          ConvertKeyToRootStringW
#define CreateEncodedRegistryString     CreateEncodedRegistryStringW
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExW
#define FreeEncodedRegistryString       FreeEncodedRegistryStringW
#define DecodeRegistryString            DecodeRegistryStringW


#else

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeA
#define GetRegValueData                 GetRegValueDataA
#define GetRegValueDataOfType           GetRegValueDataOfTypeA
#define GetRegKeyData                   GetRegKeyDataA
#define GetRegValueData2                GetRegValueData2A
#define GetRegValueDataOfType2          GetRegValueDataOfType2A
#define GetRegKeyData2                  GetRegKeyData2A
#define GetRegValueString               GetRegValueStringA
#define GetRegValueBinary               GetRegValueBinaryA
#define GetRegValueMultiSz              GetRegValueMultiSzA
#define GetRegValueDword                GetRegValueDwordA
#define GetRegValueString2              GetRegValueString2A
#define GetRegValueBinary2              GetRegValueBinary2A
#define GetRegValueMultiSz2             GetRegValueMultiSz2A
#define GetRegValueDword2               GetRegValueDword2A
#define GetRegData2                     GetRegData2A
#define GetRegData                      GetRegDataA

#define CreateRegKey                    CreateRegKeyA
#define CreateRegKeyStr                 CreateRegKeyStrA
#define OpenRegKey                      OpenRegKeyA
#define OpenRegKeyStr                   OpenRegKeyStrA
#define GetOffsetOfRootString           GetOffsetOfRootStringA
#define GetRootStringFromOffset         GetRootStringFromOffsetA
#define ConvertRootStringToKey          ConvertRootStringToKeyA
#define ConvertKeyToRootString          ConvertKeyToRootStringA
#define CreateEncodedRegistryString     CreateEncodedRegistryStringA
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExA
#define FreeEncodedRegistryString       FreeEncodedRegistryStringA
#define DecodeRegistryString            DecodeRegistryStringA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inc\strings.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Declares the string utilities implemented in common\migutil.

Author:

    Several

Revision History:

    See SLM log

--*/

#include <mbstring.h>
#include <wchar.h>

typedef PVOID PMHANDLE;

#pragma once

#define MAX_ENCODED_RULE    (256*6)
#define NODE_LEVEL_MAX      ((DWORD)-1)

#define SHIFTRIGHT8(l)  (/*lint --e(506)*/sizeof(l)<=1?0:l>>8)
#define SHIFTRIGHT16(l) (/*lint --e(506)*/sizeof(l)<=2?0:l>>16)
#define SHIFTRIGHT32(l) (/*lint --e(506)*/sizeof(l)<=4?0:l>>32)

extern CHAR EscapedCharsA[];
extern WCHAR EscapedCharsW[];

//
// String sizing routines and unit conversion
//

#define CharCountA(x)   ((DWORD)_mbslen(x))
#define CharCountW(x)   ((DWORD)wcslen(x))

#define SIZEOF(x)       ((DWORD)sizeof(x))

__inline
PSTR
CharCountToPointerA (
    PCSTR String,
    UINT Char
    )
{
    while (Char > 0) {
        MYASSERT (*String != 0);
        Char--;
        String = _mbsinc (String);
    }

    return (PSTR) String;
}

__inline
PWSTR
CharCountToPointerW (
    PCWSTR String,
    UINT Char
    )
{
#ifdef DEBUG
    UINT u;
    for (u = 0 ; u < Char ; u++) {
        MYASSERT (String[u] != 0);
    }
#endif

    return (PWSTR) (&String[Char]);
}


__inline
UINT
CharCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
    register UINT Count;

    Count = 0;
    while (Start < EndPlusOne) {
        MYASSERT (*Start != 0);
        Count++;
        Start = _mbsinc (Start);
    }

    return Count;
}

__inline
UINT
CharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}


__inline
UINT
CharCountInByteRangeA (
    IN      PCSTR Start,
    IN      UINT Bytes
    )
{
    register UINT Count;
    PCSTR EndPlusOne = (PCSTR) ((UBINT) Start + Bytes);

    Count = 0;
    while (Start < EndPlusOne) {
        Count++;
        Start = _mbsinc (Start);
    }

    return Count;
}

__inline
UINT
CharCountInByteRangeW (
    IN      PCWSTR Start,
    IN      UINT Bytes
    )
{
    PCWSTR EndPlusOne = (PCWSTR) ((UBINT) Start + Bytes);

    if (Start < EndPlusOne) {
        //cast is OK, we don't expect pointers to be that far
        return (UINT)(EndPlusOne - Start);
    }

    MYASSERT (FALSE);
    return 0;
}

__inline
UINT
CharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT CharCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = CharCountToPointerA (Start, CharCount);
    //cast is OK, we don't expect pointers to be that far
    return (UINT)(EndPlusOne - Start);
}

__inline
UINT
CharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount * SIZEOF (WCHAR);
}

#define CharCountToTcharsA   CharCountToBytesA

__inline
UINT
CharCountToTcharsW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount;
}


#define ByteCountA(x)       ((DWORD)strlen(x))
#define ByteCountW(x)       ((DWORD)wcslen(x)*SIZEOF(WCHAR))

#define SizeOfStringA(str)  ((DWORD)ByteCountA(str) + SIZEOF (CHAR))
#define SizeOfStringW(str)  ((DWORD)ByteCountW(str) + SIZEOF (WCHAR))

__inline
PSTR
ByteCountToPointerA (
    PCSTR String,
    UINT BytePos
    )
{
    return (PSTR)((UBINT) String + BytePos);
}

__inline
PWSTR
ByteCountToPointerW (
    PCWSTR String,
    UINT BytePos
    )
{
    return (PWSTR)((UBINT) String + BytePos);
}


__inline
UINT
ByteCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCSTR p;
    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

__inline
UINT
ByteCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) * SIZEOF (WCHAR) : 0;
}

__inline
UINT
ByteCountToCharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = Start + ByteCount;
    return CharCountABA (Start, EndPlusOne);
}

__inline
UINT
ByteCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = (PCWSTR) ((UBINT) Start + ByteCount);

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount / SIZEOF (WCHAR);
}

__inline
UINT
ByteCountToTcharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + ByteCount;

    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount;
}

#define ByteCountToTcharsW  ByteCountToCharsW


#define TcharCountA     strlen
#define TcharCountW     wcslen

__inline
PSTR
TcharCountToPointerA (
    PCSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return (PSTR) (String + Tchars);
}

__inline
PWSTR
TcharCountToPointerW (
    PCWSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return (PWSTR) (String + Tchars);
}


#define TcharCountABA       ByteCountABA

__inline
UINT
TcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

#define TcharCountToCharsA      ByteCountToCharsA

__inline
UINT
TcharCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars * SIZEOF (WCHAR);
}

VOID
UBINTtoHexA (
    IN      UBINT Number,
    OUT     PSTR String
    );

VOID
UBINTtoHexW (
    IN      UBINT Number,
    OUT     PWSTR String
    );

VOID
UBINTtoDecA (
    IN      UBINT Number,
    OUT     PSTR String
    );

VOID
UBINTtoDecW (
    IN      UBINT Number,
    OUT     PWSTR String
    );

VOID
BINTtoDecA (
    IN      BINT Number,
    OUT     PSTR String
    );

VOID
BINTtoDecW (
    IN      BINT Number,
    OUT     PWSTR String
    );

#define StackStringCopyA(stackbuf,src)                  StringCopyByteCountA(stackbuf,src,SIZEOF(stackbuf))
#define StackStringCopyW(stackbuf,src)                  StringCopyByteCountW(stackbuf,src,SIZEOF(stackbuf))


//
// String comparison routines
//

#define StringCompareA                                  _mbscmp
#define StringCompareW                                  wcscmp

BOOL
StringMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    );

#define StringMatchW(str1,str2)                         (wcscmp(str1,str2)==0)

#define StringICompareA                                 _mbsicmp
#define StringICompareW                                 _wcsicmp

#define StringIMatchA(str1,str2)                        (_mbsicmp(str1,str2)==0)
#define StringIMatchW(str1,str2)                        (_wcsicmp(str1,str2)==0)

#define StringCompareByteCountA(str1,str2,bytes)        _mbsncmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringCompareByteCountW(str1,str2,bytes)        wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringMatchByteCountA(str1,str2,bytes)          StringMatchABA(str1,str2,(PCSTR)((PBYTE)(str2) + bytes))
#define StringMatchByteCountW(str1,str2,bytes)          (wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringICompareByteCountA(str1,str2,bytes)       _mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringICompareByteCountW(str1,str2,bytes)       _wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringIMatchByteCountA(str1,str2,bytes)         (_mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))==0)
#define StringIMatchByteCountW(str1,str2,bytes)         (_wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringCompareCharCountA(str1,str2,chars)        _mbsncmp(str1,str2,chars)
#define StringCompareCharCountW(str1,str2,chars)        wcsncmp(str1,str2,chars)

#define StringMatchCharCountA(str1,str2,chars)          (_mbsncmp(str1,str2,chars)==0)
#define StringMatchCharCountW(str1,str2,chars)          (wcsncmp(str1,str2,chars)==0)

#define StringICompareCharCountA(str1,str2,chars)       _mbsnicmp(str1,str2,chars)
#define StringICompareCharCountW(str1,str2,chars)       _wcsnicmp(str1,str2,chars)

#define StringIMatchCharCountA(str1,str2,chars)         (_mbsnicmp(str1,str2,chars)==0)
#define StringIMatchCharCountW(str1,str2,chars)         (_wcsnicmp(str1,str2,chars)==0)

#define StringCompareTcharCountA(str1,str2,tchars)      StringMatchByteCountA(str1,str2,TcharCountToCharsA(str1,tchars))
#define StringCompareTcharCountW(str1,str2,tchars)      wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringMatchTcharCountA(str1,str2,tchars)        (_mbsncmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringMatchTcharCountW(str1,str2,tchars)        (wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)

#define StringICompareTcharCountA(str1,str2,tchars)     _mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))
#define StringICompareTcharCountW(str1,str2,tchars)     _wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringIMatchTcharCountA(str1,str2,tchars)       (_mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringIMatchTcharCountW(str1,str2,tchars)       (_wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)


INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

BOOL
StringMatchABA (
    IN      PCSTR String1,
    IN      PCSTR Start,
    IN      PCSTR End
    );

#define StringMatchABW(String,Start,End)                (StringCompareABW(String,Start,End)==0)


// stricmp that takes an end pointer instead of a length
INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

#define StringIMatchABA(String,Start,End)               (StringICompareABA(String,Start,End)==0)
#define StringIMatchABW(String,Start,End)               (StringICompareABW(String,Start,End)==0)



//
// String copy routines
//

VOID
StringCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

VOID
StringCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );

VOID
StringCopyByteCountA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

VOID
StringCopyByteCountW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

VOID
StringCopyByteCountABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

VOID
StringCopyByteCountABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

#define StringCopyCharCountA(str1,str2,chars)           StringCopyByteCountA(str1,str2,CharCountToBytesA(str2,chars))
#define StringCopyCharCountW(str1,str2,chars)           StringCopyByteCountW(str1,str2,CharCountToBytesW(str2,chars))

#define StringCopyTcharCountA(str1,str2,tchars)         StringCopyByteCountA(str1,str2,TcharCountToBytesA(str2,tchars))
#define StringCopyTcharCountW(str1,str2,tchars)         StringCopyByteCountW(str1,str2,TcharCountToBytesW(str2,tchars))

#define StringCopyABA(dest,stra,strb)                   StringCopyByteCountA((dest),(stra),((UINT)((UBINT)(strb)-(UBINT)(stra))+(UINT)SIZEOF(CHAR)))
#define StringCopyABW(dest,stra,strb)                   StringCopyByteCountW((dest),(stra),((UINT)((UBINT)(strb)-(UBINT)(stra))+(UINT)SIZEOF(WCHAR)))

//
// String cat routines
//

PSTR
StringCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

PWSTR
StringCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );


//
// Character search routines
//

#define GetEndOfStringA(s)      strchr(s,0)
#define GetEndOfStringW(s)      wcschr(s,0)

__inline
UINT
SizeOfMultiSzA (
    PCSTR MultiSz
    )
{
    PCSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringA (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((UBINT) MultiSz - (UBINT) Base);
}


__inline
UINT
SizeOfMultiSzW (
    PCWSTR MultiSz
    )
{
    PCWSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringW (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((UBINT) MultiSz - (UBINT) Base);
}


__inline
UINT
MultiSzSizeInCharsA (
    PCSTR MultiSz
    )
{
    UINT Chars = 0;

    while (*MultiSz) {

        do {
            Chars++;
            MultiSz = _mbsinc (MultiSz);
        } while (*MultiSz);

        Chars++;
        MultiSz++;
    }

    Chars++;

    return Chars;
}


#define MultiSzSizeInCharsW(msz)  (SizeOfMultiSzW(msz)/SIZEOF(WCHAR))

PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    );

PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    );

//
// Pool allocation routines
//

PSTR
RealAllocTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      UINT ByteSize
    );

PWSTR
RealAllocTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      UINT WcharSize
    );

#define AllocTextExA(p,s)   TRACK_BEGIN(PSTR, AllocTextExA)\
                            RealAllocTextExA(p,(UINT)(s))\
                            TRACK_END()

#define AllocTextExW(p,s)   TRACK_BEGIN(PWSTR, AllocTextExW)\
                            RealAllocTextExW(p,(UINT)(s))\
                            TRACK_END()

#define AllocTextA(s)       AllocTextExA(NULL,(UINT)(s))
#define AllocTextW(s)       AllocTextExW(NULL,(UINT)(s))



VOID
FreeTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Text          OPTIONAL
    );

VOID
FreeTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    );

#define FreeTextA(t)    FreeTextExA(NULL,t)
#define FreeTextW(t)    FreeTextExW(NULL,t)

PSTR
RealDuplicateTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    );

PWSTR
RealDuplicateTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    );

#define DuplicateTextExA(p,t,c,n)   TRACK_BEGIN(PSTR, DuplicateTextExA)\
                                    RealDuplicateTextExA(p,t,c,n)\
                                    TRACK_END()

#define DuplicateTextExW(p,t,c,n)   TRACK_BEGIN(PWSTR, DuplicateTextExW)\
                                    RealDuplicateTextExW(p,t,c,n)\
                                    TRACK_END()

#define DuplicateTextA(text) DuplicateTextExA(NULL,text,0,NULL)
#define DuplicateTextW(text) DuplicateTextExW(NULL,text,0,NULL)

PSTR
RealJoinTextExA (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR DelimeterString,  OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    );

PWSTR
RealJoinTextExW (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    );

#define JoinTextExA(p,s1,s2,cs,ec,nc)   TRACK_BEGIN(PSTR, JoinTextExA)\
                                        RealJoinTextExA(p,s1,s2,cs,ec,nc)\
                                        TRACK_END()

#define JoinTextExW(p,s1,s2,cs,ec,nc)   TRACK_BEGIN(PWSTR, JoinTextExW)\
                                        RealJoinTextExW(p,s1,s2,cs,ec,nc)\
                                        TRACK_END()

#define JoinTextA(str1,str2) JoinTextExA(NULL,str1,str2,NULL,0,NULL)
#define JoinTextW(str1,str2) JoinTextExW(NULL,str1,str2,NULL,0,NULL)


PSTR
RealExpandEnvironmentTextExA (
    IN PCSTR   InString,
    IN PCSTR * ExtraEnvironmentVariables OPTIONAL
    );

PWSTR
RealExpandEnvironmentTextExW (
    IN PCWSTR   InString,
    IN PCWSTR * ExtraEnvironmentVariables OPTIONAL
    );

#define ExpandEnvironmentTextExA(str,ev)    TRACK_BEGIN(PSTR, ExpandEnvironmentTextExA)\
                                            RealExpandEnvironmentTextExA(str,ev)\
                                            TRACK_END()

#define ExpandEnvironmentTextExW(str,ev)    TRACK_BEGIN(PWSTR, ExpandEnvironmentTextExW)\
                                            RealExpandEnvironmentTextExW(str,ev)\
                                            TRACK_END()

#define ExpandEnvironmentTextA(string) ExpandEnvironmentTextExA(string,NULL)
#define ExpandEnvironmentTextW(string) ExpandEnvironmentTextExW(string,NULL)

//
// Function wraps IsDBCSLeadByte(), which tests ACP. Do not use
// isleadbyte().
//
#define IsLeadByte(b)   IsDBCSLeadByte(b)

//
// Command line routines
//

// Converts ANSI command line to array of args
PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     PUINT NumArgs
    );


//
// Need both MBCS and UNICODE versions
//

// an atoi that supports decimal or hex
DWORD   _mbsnum (IN PCSTR szNum);
DWORD   _wcsnum (IN PCWSTR szNum);

// determines if an entire string is printable chars
int     _mbsisprint (PCSTR szStr);
int     _wcsisprint (PCWSTR szStr);

// case-insensitive strstr
PCSTR  _mbsistr (PCSTR szStr, PCSTR szSubStr);
PCWSTR _wcsistr (PCWSTR szStr, PCWSTR szSubStr);

// copies the first character of str2 to str
void    _copymbchar (PSTR str1, PCSTR str2);
#define _copywchar(dest,src)    (*(dest)=*(src))

// replaces a character in a multi-byte char string and maintains
// the string integrity (may grow string by one byte)
void    _setmbchar  (PSTR str, MBCHAR c);
#define _setwchar(str,c)        (*(str)=(c))

// removes specified character from the end of a string, if it exists
BOOL    _mbsctrim (PSTR str, MBCHAR c);
BOOL    _wcsctrim (PWSTR str, WCHAR c);

// Always adds a backslash, returns ptr to nul terminator
PSTR    AppendWackA (IN PSTR str);
PWSTR   AppendWackW (IN PWSTR str);

// Adds a backslash to the end of a DOS path (unless str is empty
// or is only a drive letter)
PSTR    AppendDosWackA (IN PSTR str);
PWSTR   AppendDosWackW (IN PWSTR str);

// Adds a backslash unless str is empty
PSTR    AppendUncWackA (IN PSTR str);
PWSTR   AppendUncWackW (IN PWSTR str);

// Adds a backslash and identifies the correct naming convention (DOS,
// or UNC)
PSTR    AppendPathWackA (IN PSTR str);
PWSTR   AppendPathWackW (IN PWSTR str);

//
// Joins any number of paths together, allocates string in g_PathsPool if not otherwise specified
// this version checks for wacks at the begin/end of each segment so they are properly joined
//
PSTR
_cdecl
RealJoinPathsInPoolExA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

PWSTR
_cdecl
RealJoinPathsInPoolExW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

#define JoinPathsInPoolExA(x)   TRACK_BEGIN(PSTR, JoinPathsInPoolExA)\
                                RealJoinPathsInPoolExA x\
                                TRACK_END()

#define JoinPathsInPoolExW(x)   TRACK_BEGIN(PWSTR, JoinPathsInPoolExW)\
                                RealJoinPathsInPoolExW x\
                                TRACK_END()

//
// for backwards compatibility, JoinPaths expands to JoinPathsInPoolEx
// and NOT to JoinPathsEx which uses a growbuffer instead
//
#define JoinPathsA(p1,p2)               JoinPathsInPoolExA((NULL,p1,p2,NULL))
#define JoinPathsW(p1,p2)               JoinPathsInPoolExW((NULL,p1,p2,NULL))


BOOL
_cdecl
JoinPathsExA (
    IN OUT      PGROWBUFFER Gb,
    ...
    );

BOOL
_cdecl
JoinPathsExW (
    IN OUT      PGROWBUFFER Gb,
    ...
    );

//
// Joins any number of paths together, allocates string in g_PathsPool if not otherwise specified
// this version does NOT check for wacks at the begin/end of each segment
//
PSTR
_cdecl
RealBuildPathInPoolA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

PWSTR
_cdecl
RealBuildPathInPoolW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

#define BuildPathInPoolA(x)   TRACK_BEGIN(PSTR, BuildPathInPoolA)\
                              RealBuildPathInPoolA x\
                              TRACK_END()

#define BuildPathInPoolW(x)   TRACK_BEGIN(PWSTR, BuildPathInPoolW)\
                              RealBuildPathInPoolW x\
                              TRACK_END()


DWORD
_cdecl
BuildPathA (
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    );

DWORD
_cdecl
BuildPathW (
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    );

BOOL
_cdecl
BuildPathExA (
    IN OUT  PGROWBUFFER Gb,
    ...
    );

BOOL
_cdecl
BuildPathExW (
    IN OUT  PGROWBUFFER Gb,
    ...
    );


// Routine to allocate a 1K buffer for path manipulation, allocated in g_PathsPool
PSTR    RealAllocPathStringA (IN DWORD Tchars);
PWSTR   RealAllocPathStringW (IN DWORD Tchars);
#define DEFSIZE 0

#define AllocPathStringA(chars)     TRACK_BEGIN(PSTR, AllocPathStringA)\
                                    RealAllocPathStringA(chars)\
                                    TRACK_END()

#define AllocPathStringW(chars)     TRACK_BEGIN(PWSTR, AllocPathStringW)\
                                    RealAllocPathStringW(chars)\
                                    TRACK_END()

// Routine to divide path into separate strings, each allocated in g_PathsPool
VOID    RealSplitPathA (IN PCSTR Path, OUT PSTR *Drive, OUT PSTR *Dir, OUT PSTR *File, OUT PSTR *Ext);
VOID    RealSplitPathW (IN PCWSTR Path, OUT PWSTR *Drive, OUT PWSTR *Dir, OUT PWSTR *File, OUT PWSTR *Ext);

#define SplitPathA(path,dv,dir,f,e) TRACK_BEGIN_VOID (VOID, SplitPathA)\
                                    RealSplitPathA(path,dv,dir,f,e)\
                                    TRACK_END()

#define SplitPathW(path,dv,dir,f,e) TRACK_BEGIN_VOID (VOID, SplitPathW)\
                                    RealSplitPathW(path,dv,dir,f,e)\
                                    TRACK_END()

// Routine to extract the file from a path
PCSTR  GetFileNameFromPathA (IN PCSTR Path);
PCWSTR GetFileNameFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path
PCSTR  GetFileExtensionFromPathA (IN PCSTR Path);
PCWSTR GetFileExtensionFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path, including the dot, or the
// end of the string if no extension exists
PCSTR  GetDotExtensionFromPathA (IN PCSTR Path);
PCWSTR GetDotExtensionFromPathW (IN PCWSTR Path);

// Routine to duplicate a path and allocate space for cat processing
PSTR    RealDuplicatePathStringA (IN PCSTR Path, IN DWORD ExtraBytes);
PWSTR   RealDuplicatePathStringW (IN PCWSTR Path, IN DWORD ExtraBytes);

#define DuplicatePathStringA(path,eb)   TRACK_BEGIN(PSTR, DuplicatePathStringA)\
                                        RealDuplicatePathStringA(path,eb)\
                                        TRACK_END()

#define DuplicatePathStringW(path,eb)   TRACK_BEGIN(PWSTR, DuplicatePathStringW)\
                                        RealDuplicatePathStringW(path,eb)\
                                        TRACK_END()

// Routines to enumerate the PATH variable
typedef struct _PATH_ENUMA {
    PSTR  BufferPtr;
    PSTR  PtrNextPath;
    PSTR  PtrCurrPath;
} PATH_ENUMA, *PPATH_ENUMA;

BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    );

#define EnumFirstPathA(e,a,w,s) EnumFirstPathExA(e,a,w,s,TRUE)

BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    );

BOOL
AbortPathEnumA (
    IN OUT  PPATH_ENUMA PathEnum
    );



// Frees a string allocated in g_PathsPool
VOID
FreePathStringExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Path          OPTIONAL
    );

VOID
FreePathStringExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    );

#define FreePathStringA(p) FreePathStringExA(NULL,p)
#define FreePathStringW(p) FreePathStringExW(NULL,p)

// Removes a trailing backslash, if it exists
#define RemoveWackAtEndA(str)  _mbsctrim(str,'\\')
#define RemoveWackAtEndW(str)  _wcsctrim(str,L'\\')

PCSTR
FindLastWackA (
    IN      PCSTR Str
    );

PCWSTR
FindLastWackW (
    IN      PCWSTR Str
    );

BOOL
GetNodePatternMinMaxLevelsA (
    IN          PCSTR NodePattern,
    OUT         PSTR FormattedNode,     OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    );

BOOL
GetNodePatternMinMaxLevelsW (
    IN          PCWSTR NodePattern,
    OUT         PWSTR FormattedNode,    OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    );


// Rule encoding functions used to encode a number of syntax-related
// characters (backslash, brackets, asterisk, etc)
PSTR   EncodeRuleCharsA (PSTR szEncRule, PCSTR szRule);
PWSTR  EncodeRuleCharsW (PWSTR szEncRule, PCWSTR szRule);

// Rule decoding functions used to restore an encoded string
MBCHAR  GetNextRuleCharA (PCSTR *p_szRule, BOOL *p_bFromHex);
WCHAR   GetNextRuleCharW (PCWSTR *p_szRule, BOOL *p_bFromHex);
PSTR   DecodeRuleCharsA (PSTR szRule, PCSTR szEncRule);
PWSTR  DecodeRuleCharsW (PWSTR szRule, PCWSTR szEncRule);
PSTR   DecodeRuleCharsABA (PSTR szRule, PCSTR szEncRuleStart, PCSTR End);
PWSTR  DecodeRuleCharsABW (PWSTR szRule, PCWSTR szEncRuleStart, PCWSTR End);

// Returns a pointer to the next non-space character (uses isspace)
PCSTR  SkipSpaceA (PCSTR szStr);
PCWSTR SkipSpaceW (PCWSTR szStr);

// Returns a pointer to the first space character at the end of a string,
// or a pointer to the terminating nul if no space exists at the end of the
// string.  (Used for trimming space.)
PCSTR  SkipSpaceRA (PCSTR szBaseStr, PCSTR szStr);
PCWSTR SkipSpaceRW (PCWSTR szBaseStr, PCWSTR szStr);

// Truncates a string after the last non-whitepace character
VOID TruncateTrailingSpaceA (IN OUT  PSTR Str);
VOID TruncateTrailingSpaceW (IN OUT  PWSTR Str);


// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchA (PCSTR wstrPattern, PCSTR wstrStr);
BOOL IsPatternMatchW (PCWSTR wstrPattern, PCWSTR wstrStr);

// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchABA (PCSTR Pattern, PCSTR Start, PCSTR End);
BOOL IsPatternMatchABW (PCWSTR Pattern, PCWSTR Start, PCWSTR End);

BOOL IsPatternContainedA (PCSTR Container, PCSTR Contained);
BOOL IsPatternContainedW (PCWSTR Container, PCWSTR Contained);


//
// More powerful pattern matching
//

#define SEGMENTTYPE_UNKNOWN         0
#define SEGMENTTYPE_EXACTMATCH      1
#define SEGMENTTYPE_OPTIONAL        2
#define SEGMENTTYPE_REQUIRED        3

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // optional
        struct {
            UINT MaxLen;                // zero if any length
            PCSTR IncludeSet;           OPTIONAL
            PCSTR ExcludeSet;           OPTIONAL
        } Wildcard;
    };
} SEGMENTA, *PSEGMENTA;

typedef struct {
    UINT SegmentCount;
    PSEGMENTA Segment;
} PATTERNPROPSA, *PPATTERNPROPSA;

typedef struct {
    UINT PatternCount;
    PMHANDLE Pool;
    PPATTERNPROPSA Pattern;
} PARSEDPATTERNA, *PPARSEDPATTERNA;

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCWSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // wildcard
        struct {
            UINT MaxLen;                // zero if any length
            PCWSTR IncludeSet;          OPTIONAL
            PCWSTR ExcludeSet;          OPTIONAL
        } Wildcard;
    };
} SEGMENTW, *PSEGMENTW;

typedef struct {
    UINT SegmentCount;
    PSEGMENTW Segment;
} PATTERNPROPSW, *PPATTERNPROPSW;

typedef struct {
    UINT PatternCount;
    PMHANDLE Pool;
    PPATTERNPROPSW Pattern;
} PARSEDPATTERNW, *PPARSEDPATTERNW;


BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR String
    );

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR String
    );

BOOL
IsPatternMatchExABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    );

BOOL
IsPatternMatchExABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

PPARSEDPATTERNA
ExplodeParsedPatternA (
    IN      PPARSEDPATTERNA Pattern
    );

PPARSEDPATTERNW
ExplodeParsedPatternW (
    IN      PPARSEDPATTERNW Pattern
    );

BOOL
IsPatternContainedExA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    );

BOOL
IsPatternContainedExW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    );

BOOL
IsParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    );

BOOL
IsParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    );

BOOL
IsExplodedParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    );

BOOL
IsExplodedParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    );

PPARSEDPATTERNA
CreateParsedPatternA (
    IN      PCSTR Pattern
    );

PPARSEDPATTERNW
CreateParsedPatternW (
    IN      PCWSTR Pattern
    );

BOOL
WildCharsPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

BOOL
WildCharsPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    );

BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    );

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    );

BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    );

VOID
PrintPattern (
    PCSTR Pattern,
    PPARSEDPATTERNA Struct
    );

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

VOID
DecodeParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DecodeParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

BOOL
PatternIncludesPatternA (
    IN      PPARSEDPATTERNA IncludingPattern,
    IN      PPARSEDPATTERNA IncludedPattern
    );

BOOL
PatternIncludesPatternW (
    IN      PPARSEDPATTERNW IncludingPattern,
    IN      PPARSEDPATTERNW IncludedPattern
    );

VOID
GetParsedPatternMinMaxSizeA (
    IN      PPARSEDPATTERNA ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    );

VOID
GetParsedPatternMinMaxSizeW (
    IN      PPARSEDPATTERNW ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    );

__inline
BOOL
ParsedPatternIsExactMatchA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternIsExactMatchW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternSegmentIsPureOptionalA (
    IN      PSEGMENTA ParsedPatternSegment
    )
{
    return ParsedPatternSegment->Type == SEGMENTTYPE_OPTIONAL &&
           ParsedPatternSegment->Wildcard.MaxLen == 0 &&
           ParsedPatternSegment->Wildcard.IncludeSet == NULL &&
           ParsedPatternSegment->Wildcard.ExcludeSet == NULL;
}

__inline
BOOL
ParsedPatternSegmentIsPureOptionalW (
    IN      PSEGMENTW ParsedPatternSegment
    )
{
    return ParsedPatternSegment->Type == SEGMENTTYPE_OPTIONAL &&
           ParsedPatternSegment->Wildcard.MaxLen == 0 &&
           ParsedPatternSegment->Wildcard.IncludeSet == NULL &&
           ParsedPatternSegment->Wildcard.ExcludeSet == NULL;
}

__inline
BOOL
ParsedPatternIsOptionalA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPatternSegmentIsPureOptionalA (ParsedPattern->Pattern->Segment);
}

__inline
BOOL
ParsedPatternIsOptionalW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPatternSegmentIsPureOptionalW (ParsedPattern->Pattern->Segment);
}

__inline
BOOL
ParsedPatternIsRootPlusStarA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 2 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH &&
           ParsedPatternSegmentIsPureOptionalA (ParsedPattern->Pattern->Segment + 1);
}

__inline
BOOL
ParsedPatternIsRootPlusStarW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 2 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH &&
           ParsedPatternSegmentIsPureOptionalW (ParsedPattern->Pattern->Segment + 1);
}

__inline
BOOL
ParsedPatternHasRootA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount > 0 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternHasRootW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount > 0 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
PCSTR
ParsedPatternGetRootA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (!ParsedPatternHasRootA (ParsedPattern)) {
        return NULL;
    }
    return ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase;
}

__inline
PCWSTR
ParsedPatternGetRootW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (!ParsedPatternHasRootW (ParsedPattern)) {
        return NULL;
    }
    return ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase;
}

__inline
BOOL
ParsedPatternEndsWithStarA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPatternSegmentIsPureOptionalA (
                ParsedPattern->Pattern->Segment + ParsedPattern->Pattern->SegmentCount - 1
                );
}

__inline
BOOL
ParsedPatternEndsWithStarW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPatternSegmentIsPureOptionalW (
                ParsedPattern->Pattern->Segment + ParsedPattern->Pattern->SegmentCount - 1
                );
}

BOOL
ParsedPatternTrimLastCharA (
    IN OUT  PPARSEDPATTERNA ParsedPattern
    );

BOOL
ParsedPatternTrimLastCharW (
    IN OUT  PPARSEDPATTERNW ParsedPattern
    );


// Character counters
UINT CountInstancesOfCharA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharW (PCWSTR String, WCHAR Char);

UINT CountInstancesOfCharIA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharIW (PCWSTR String, WCHAR Char);


//
// Message Functions
//
// An AllocTable is an array of HLOCAL pointers that the message routines
// return.  This table is maintained to allow a single function to clean up
// all strings at once.
//
// All "Ex" functions (ParseMessageEx, GetStringResourceEx, and so on)
// require a valid AllocTable pointer.  A caller obtains this pointer by
// calling CreateAllocTable before processing any message.  The caller
// cleans up the entire table by calling DestroyAllocTable.
//
// A set of macros can be used for short-term strings.  ParseMessage and
// GetStringResource work the same as their Ex counterparts, but operate
// on the process-wide g_ShortTermAllocTable.  Short-term strings are
// freed with FreeStringResource.
//
// A routine that calls ParseMessage and/or GetStringResource several times
// in the same function wrap the calls between BeginMessageProcessing and
// EndMessageProcessing.  Only one thread in the process can do this at a
// time, and when EndMessageProcessing is called, all strings allocated
// by ParseMessage or GetResourceString in the processing section are
// automatically freed.
//

// AllocTable creation/deletion
PGROWBUFFER RealCreateAllocTable (VOID);

#define CreateAllocTable()      TRACK_BEGIN(PGROWBUFFER, CreateAllocTable)\
                                RealCreateAllocTable()\
                                TRACK_END()


VOID DestroyAllocTable (PGROWBUFFER AllocTable);

// The "Ex" functions
// ParseMessageEx retrieves the string resource via FormatMessage
PCSTR ParseMessageExA (PGROWBUFFER AllocTable, PCSTR Template, PCSTR ArgArray[]);
PCWSTR ParseMessageExW (PGROWBUFFER AllocTable, PCWSTR Template, PCWSTR ArgArray[]);

// GetStringResourceEx retrives an argument-less string resource
PCSTR GetStringResourceExA (PGROWBUFFER AllocTable, UINT ID);
PCWSTR GetStringResourceExW (PGROWBUFFER AllocTable, UINT ID);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros
VOID FreeStringResourceExA (PGROWBUFFER AllocTable, PCSTR String);
VOID FreeStringResourceExW (PGROWBUFFER AllocTable, PCWSTR String);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros.
// Tests String first; nulls when freed.
VOID FreeStringResourcePtrExA (PGROWBUFFER AllocTable, PCSTR * String);
VOID FreeStringResourcePtrExW (PGROWBUFFER AllocTable, PCWSTR * String);

// Macros
extern PGROWBUFFER g_ShortTermAllocTable;
#define ParseMessageA(strid,args) ParseMessageExA(g_ShortTermAllocTable, strid, args)
#define ParseMessageW(strid,args) ParseMessageExW(g_ShortTermAllocTable, strid, args)
#define ParseMessageIDA(id,args) ParseMessageExA(g_ShortTermAllocTable, (PCSTR) (id), args)
#define ParseMessageIDW(id,args) ParseMessageExW(g_ShortTermAllocTable, (PCWSTR) (id), args)
#define ParseMessageIDExA(table,id,args) ParseMessageExA(table, (PCSTR) (id), args)
#define ParseMessageIDExW(table,id,args) ParseMessageExW(table, (PCWSTR) (id), args)
#define GetStringResourceA(id) GetStringResourceExA(g_ShortTermAllocTable, id)
#define GetStringResourceW(id) GetStringResourceExW(g_ShortTermAllocTable, id)
#define FreeStringResourceA(str) FreeStringResourceExA(g_ShortTermAllocTable, str)
#define FreeStringResourceW(str) FreeStringResourceExW(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrA(str) FreeStringResourcePtrExA(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrW(str) FreeStringResourcePtrExW(g_ShortTermAllocTable, str)

// Functions for single-threaded message-intensive processing loops
BOOL BeginMessageProcessing (VOID);
VOID EndMessageProcessing (VOID);


//
// The following message functions do not return strings, so they do not
// need cleanup.
//

// An odd variant--obtains message ID from a window's text and replaces
// it with the actual message.  Useful in dialog box initialization.
VOID ParseMessageInWndA (HWND hwnd, PCSTR ArgArray[]);
VOID ParseMessageInWndW (HWND hwnd, PCWSTR ArgArray[]);

// Displays a message box using a message string
INT ResourceMessageBoxA (HWND hwndOwner, UINT ID, UINT Flags, PCSTR ArgArray[]);
INT ResourceMessageBoxW (HWND hwndOwner, UINT ID, UINT Flags, PCWSTR ArgArray[]);


//
// Functions that don't care about UNICODE or MBCS
// and realy shouldn't be in strings.h/.c
//

// Pushes dwError on a global error stack
void    PushNewError (DWORD dwError);

// Pushes the return of GetLastError() on a global error stack
void    PushError (void);

// Pops the last error from the global error stack, calls SetLastError
// and returns the popped error code.
DWORD   PopError (void);

// Returns an int value for chars 0-9, a-f, A-F, and -1 for all others
int     GetHexDigit (IN  int c);


//
// Inline functions
//

// Returns the character at str[pos]
__inline MBCHAR _mbsgetc(PCSTR str, DWORD pos) {
    return (MBCHAR) _mbsnextc(CharCountToPointerA ((PSTR) str, pos));
}

__inline WCHAR _wcsgetc(PCWSTR str, DWORD pos) {
    return *CharCountToPointerW ((PWSTR) str, pos);
}

// Sets the character at str[pos]
// Multibyte version may grow string by one byte.
__inline void _mbssetc(PSTR str, DWORD pos, MBCHAR c) {
    _setmbchar (CharCountToPointerA (str, pos), c);
}

__inline void _wcssetc(PWSTR str, DWORD pos, WCHAR c) {
    *CharCountToPointerW (str, pos) = c;
}

// Bug fix for C Runtime _tcsdec
__inline PWSTR _wcsdec2(PCWSTR base, PCWSTR p) {
    if (base >= p) {
        return NULL;
    }
    return (PWSTR) (p-1);
}

// Bug fix for C Runtime _tcsdec
__inline PSTR _mbsdec2(PCSTR base, PCSTR p) {
    if (base >= p) {
        return NULL;
    }
    return _mbsdec(base,p);
}


// Routine that checks string for a prefix
#define _mbsprefixcmp(str,prefix) _mbsncmp(str,prefix,_mbslen(prefix))
#define _mbsprefixicmp(str,prefix) _mbsnicmp(str,prefix,_mbslen(prefix))
#define _wcsprefixcmp(str,prefix) _wcsncmp(str,prefix,_mbslen(prefix))
#define _wcsprefixicmp(str,prefix) _wcsnicmp(str,prefix,_mbslen(prefix))

//
// Sub String Replacement functions.
//
BOOL StringReplaceW (PWSTR Buffer,DWORD MaxSize,PWSTR ReplaceStartPos,PWSTR ReplaceEndPos,PCWSTR NewString);
BOOL StringReplaceA (PSTR Buffer,DWORD MaxSize,PSTR ReplaceStartPos,PSTR ReplaceEndPos,PCSTR NewString);

//
// String table population from INF section
//

typedef enum {
    CALLBACK_CONTINUE,
    CALLBACK_SKIP,
    CALLBACK_STOP
} CALLBACK_RESULT;

typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEA)(PCSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEW)(PCWSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef ADDINFSECTION_PROTOTYPEA * ADDINFSECTION_PROCA;
typedef ADDINFSECTION_PROTOTYPEW * ADDINFSECTION_PROCW;

BOOL AddInfSectionToHashTableA (PVOID, HINF, PCSTR, DWORD, ADDINFSECTION_PROCA, PVOID);
BOOL AddInfSectionToHashTableW (PVOID, HINF, PCWSTR, DWORD, ADDINFSECTION_PROCW, PVOID);


UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    );

UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    );

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    );

PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    );

typedef struct _MULTISZ_ENUMA {
    PCSTR   Buffer;
    PCSTR   CurrentString;
} MULTISZ_ENUMA, *PMULTISZ_ENUMA;

typedef struct _MULTISZ_ENUMW {
    PCWSTR  Buffer;
    PCWSTR  CurrentString;
} MULTISZ_ENUMW, *PMULTISZ_ENUMW;

BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    );

BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    );

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    );

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    );


VOID
ToggleWacksW (
    IN OUT PWSTR String,
    IN BOOL Operation
    );

VOID
ToggleWacksA (
    IN OUT PSTR String,
    IN BOOL Operation
    );

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    );

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    );

PCSTR
ConvertSBtoDB (
    PCSTR RootPath,
    PCSTR FullPath,
    PCSTR Limit
    );

ULONGLONG
StringToUint64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

#define AToU64(str)     StringToUint64A(str,NULL)

ULONGLONG
StringToUint64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

#define WToU64(str)     StringToUint64W(str,NULL)

LONGLONG
StringToInt64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

#define AToI64(str)     StringToInt64A(str,NULL)

LONGLONG
StringToInt64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

#define WToI64(str)     StringToInt64W(str,NULL)

//
// TCHAR mappings
//

#ifdef UNICODE

#define EscapedChars                EscapedCharsW
#define CharCount                   CharCountW
#define CharCountToPointer          CharCountToPointerW
#define CharCountAB                 CharCountABW
#define CharCountInByteRange        CharCountInByteRangeW
#define CharCountToBytes            CharCountToBytesW
#define CharCountToTchars           CharCountToTcharsW
#define ByteCount                   ByteCountW
#define SizeOfString                SizeOfStringW
#define SizeOfMultiSz               SizeOfMultiSzW
#define MultiSzSizeInChars          MultiSzSizeInCharsW
#define ByteCountToPointer          ByteCountToPointerW
#define ByteCountAB                 ByteCountABW
#define ByteCountToChars            ByteCountToCharsW
#define ByteCountToTchars           ByteCountToTcharsW
#define TcharCount                  TcharCountW
#define TcharCountToPointer         TcharCountToPointerW
#define TcharCountAB                TcharCountABW
#define TcharCountToChars           TcharCountToCharsW
#define TcharCountToBytes           TcharCountToBytesW
#define StackStringCopy             StackStringCopyW
#define StringCompare               StringCompareW
#define StringMatch                 StringMatchW
#define StringICompare              StringICompareW
#define StringIMatch                StringIMatchW
#define StringCompareByteCount      StringCompareByteCountW
#define StringMatchByteCount        StringMatchByteCountW
#define StringICompareByteCount     StringICompareByteCountW
#define StringIMatchByteCount       StringIMatchByteCountW
#define StringCompareCharCount      StringCompareCharCountW
#define StringMatchCharCount        StringMatchCharCountW
#define StringICompareCharCount     StringICompareCharCountW
#define StringIMatchCharCount       StringIMatchCharCountW
#define StringCompareTcharCount     StringCompareTcharCountW
#define StringMatchTcharCount       StringMatchTcharCountW
#define StringICompareTcharCount    StringICompareTcharCountW
#define StringIMatchTcharCount      StringIMatchTcharCountW
#define StringCompareAB             StringCompareABW
#define StringMatchAB               StringMatchABW
#define StringICompareAB            StringICompareABW
#define StringIMatchAB              StringIMatchABW
#define StringCopy                  StringCopyW
#define StringCopyByteCount         StringCopyByteCountW
#define StringCopyCharCount         StringCopyCharCountW
#define StringCopyTcharCount        StringCopyTcharCountW
#define StringCopyAB                StringCopyABW
#define StringCat                   StringCatW
#define GetEndOfString              GetEndOfStringW
#define GetPrevChar                 GetPrevCharW

#define AllocTextEx                 AllocTextExW
#define AllocText                   AllocTextW
#define FreeTextEx                  FreeTextExW
#define FreeText                    FreeTextW
#define DuplicateText               DuplicateTextW
#define DuplicateTextEx             DuplicateTextExW
#define JoinTextEx                  JoinTextExW
#define JoinText                    JoinTextW
#define ExpandEnvironmentText       ExpandEnvironmentTextW
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExW
#define CommandLineToArgv           CommandLineToArgvW

#define _tcsdec2                    _wcsdec2
#define _copytchar                  _copywchar
#define _settchar                   _setwchar
#define _tcsgetc                    _wcsgetc
#define _tcssetc                    _wcssetc
#define _tcsnum                     _wcsnum
#define _tcsappend                  _wcsappend
#define _tcsistr                    _wcsistr
#define _tcsisprint                 _wcsisprint
#define _tcsnzcpy                   _wcsnzcpy
#define _tcssafecpy                 _wcssafecpy
#define _tcsnzcpyab                 _wcsnzcpyab
#define _tcssafecpyab               _wcssafecpyab
#define _tcsprefixcmp               _wcsprefixcmp
#define _tcsprefixicmp              _wcsprefixicmp
#define _tcsctrim                   _wcsctrim

#define AppendWack                  AppendWackW
#define AppendDosWack               AppendDosWackW
#define AppendUncWack               AppendUncWackW
#define AppendPathWack              AppendPathWackW
#define RemoveWackAtEnd             RemoveWackAtEndW
#define JoinPaths                   JoinPathsW
#define JoinPathsInPoolEx           JoinPathsInPoolExW
#define JoinPathsEx                 JoinPathsExW
#define BuildPathInPool             BuildPathInPoolW
#define BuildPath                   BuildPathW
#define BuildPathEx                 BuildPathExW
#define AllocPathString             AllocPathStringW
#define SplitPath                   SplitPathW
#define GetFileNameFromPath         GetFileNameFromPathW
#define GetFileExtensionFromPath    GetFileExtensionFromPathW
#define GetDotExtensionFromPath     GetDotExtensionFromPathW
#define DuplicatePathString         DuplicatePathStringW
#define FreePathStringEx            FreePathStringExW
#define FreePathString              FreePathStringW
#define FindLastWack                FindLastWackW
#define GetNodePatternMinMaxLevels  GetNodePatternMinMaxLevelsW

#define GetNextRuleChar             GetNextRuleCharW
#define DecodeRuleChars             DecodeRuleCharsW
#define DecodeRuleCharsAB           DecodeRuleCharsABW
#define EncodeRuleChars             EncodeRuleCharsW

#define SkipSpace                   SkipSpaceW
#define SkipSpaceR                  SkipSpaceRW
#define TruncateTrailingSpace       TruncateTrailingSpaceW
#define IsPatternMatch              IsPatternMatchW
#define IsPatternMatchAB            IsPatternMatchABW
#define IsPatternContained          IsPatternContainedW

#define PPARSEDPATTERN              PPARSEDPATTERNW
#define PARSEDPATTERN               PARSEDPATTERNW
#define CreateParsedPattern         CreateParsedPatternW
#define WildCharsPattern            WildCharsPatternW
#define IsPatternMatchEx            IsPatternMatchExW
#define IsPatternMatchExAB          IsPatternMatchExABW
#define ExplodeParsedPattern        ExplodeParsedPatternW
#define IsPatternContainedEx        IsPatternContainedExW
#define IsParsedPatternContainedEx  IsParsedPatternContainedExW
#define IsExplodedParsedPatternContainedEx  IsExplodedParsedPatternContainedExW
#define TestParsedPattern           TestParsedPatternW
#define TestParsedPatternAB         TestParsedPatternABW
#define DestroyParsedPattern        DestroyParsedPatternW
#define DestroyParsedPattern        DestroyParsedPatternW
#define DecodeParsedPattern         DecodeParsedPatternW
#define PatternIncludesPattern      PatternIncludesPatternW
#define GetParsedPatternMinMaxSize  GetParsedPatternMinMaxSizeW
#define ParsedPatternIsExactMatch   ParsedPatternIsExactMatchW
#define ParsedPatternIsOptional     ParsedPatternIsOptionalW
#define ParsedPatternIsRootPlusStar ParsedPatternIsRootPlusStarW
#define ParsedPatternHasRoot        ParsedPatternHasRootW
#define ParsedPatternGetRoot        ParsedPatternGetRootW
#define ParsedPatternSegmentIsPureOptional ParsedPatternSegmentIsPureOptionalW
#define ParsedPatternEndsWithStar   ParsedPatternEndsWithStarW
#define ParsedPatternTrimLastChar   ParsedPatternTrimLastCharW

#define CountInstancesOfChar        CountInstancesOfCharW
#define CountInstancesOfCharI       CountInstancesOfCharIW
#define StringReplace               StringReplaceW
#define CountInstancesOfSubString   CountInstancesOfSubStringW
#define StringSearchAndReplace      StringSearchAndReplaceW
#define MULTISZ_ENUM                MULTISZ_ENUMW
#define EnumFirstMultiSz            EnumFirstMultiSzW
#define EnumNextMultiSz             EnumNextMultiSzW

#define ParseMessage                ParseMessageW
#define ParseMessageEx              ParseMessageExW
#define ParseMessageID              ParseMessageIDW
#define ParseMessageIDEx            ParseMessageIDExW
#define GetStringResource           GetStringResourceW
#define GetStringResourceEx         GetStringResourceExW
#define FreeStringResource          FreeStringResourceW
#define ParseMessageInWnd           ParseMessageInWndW
#define ResourceMessageBox          ResourceMessageBoxW

#define AddInfSectionToHashTable    AddInfSectionToHashTableW
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCW

#define ReplaceWacks(f)             ToggleWacksW(f,FALSE)
#define RestoreWacks(f)             ToggleWacksW(f,TRUE)

#define SanitizePath                SanitizePathW

#define StringToUint64              StringToUint64W
#define TToU64                      WToU64
#define StringToInt64               StringToInt64W
#define TToI64                      WToI64

#else

#define EscapedChars                EscapedCharsA
#define CharCount                   CharCountA
#define CharCountToPointer          CharCountToPointerA
#define CharCountAB                 CharCountABA
#define CharCountInByteRange        CharCountInByteRangeA
#define CharCountToBytes            CharCountToBytesA
#define CharCountToTchars           CharCountToTcharsA
#define ByteCount                   ByteCountA
#define SizeOfString                SizeOfStringA
#define SizeOfMultiSz               SizeOfMultiSzA
#define MultiSzSizeInChars          MultiSzSizeInCharsA
#define ByteCountToPointer          ByteCountToPointerA
#define ByteCountAB                 ByteCountABA
#define ByteCountToChars            ByteCountToCharsA
#define ByteCountToTchars           ByteCountToTcharsA
#define TcharCount                  TcharCountA
#define TcharCountToPointer         TcharCountToPointerA
#define TcharCountAB                TcharCountABA
#define TcharCountToChars           TcharCountToCharsA
#define TcharCountToBytes           TcharCountToBytesA
#define StackStringCopy             StackStringCopyA
#define StringCompare               StringCompareA
#define StringMatch                 StringMatchA
#define StringICompare              StringICompareA
#define StringIMatch                StringIMatchA
#define StringCompareByteCount      StringCompareByteCountA
#define StringMatchByteCount        StringMatchByteCountA
#define StringICompareByteCount     StringICompareByteCountA
#define StringIMatchByteCount       StringIMatchByteCountA
#define StringCompareCharCount      StringCompareCharCountA
#define StringMatchCharCount        StringMatchCharCountA
#define StringICompareCharCount     StringICompareCharCountA
#define StringIMatchCharCount       StringIMatchCharCountA
#define StringCompareTcharCount     StringCompareTcharCountA
#define StringMatchTcharCount       StringMatchTcharCountA
#define StringICompareTcharCount    StringICompareTcharCountA
#define StringIMatchTcharCount      StringIMatchTcharCountA
#define StringCompareAB             StringCompareABA
#define StringMatchAB               StringMatchABA
#define StringICompareAB            StringICompareABA
#define StringIMatchAB              StringIMatchABA

#define StringCopy                  StringCopyA
#define StringCopyByteCount         StringCopyByteCountA
#define StringCopyCharCount         StringCopyCharCountA
#define StringCopyTcharCount        StringCopyTcharCountA
#define StringCopyAB                StringCopyABA
#define StringCat                   StringCatA
#define GetEndOfString              GetEndOfStringA
#define GetPrevChar                 GetPrevCharA

#define AllocTextEx                 AllocTextExA
#define AllocText                   AllocTextA
#define FreeTextEx                  FreeTextExA
#define FreeText                    FreeTextA
#define DuplicateText               DuplicateTextA
#define DuplicateTextEx             DuplicateTextExA
#define JoinTextEx                  JoinTextExA
#define JoinText                    JoinTextA
#define ExpandEnvironmentText       ExpandEnvironmentTextA
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExA
#define CommandLineToArgv           CommandLineToArgvA

#define _tcsdec2                    _mbsdec2
#define _copytchar                  _copymbchar
#define _settchar                   _setmbchar
#define _tcsgetc                    _mbsgetc
#define _tcssetc                    _mbssetc
#define _tcsnum                     _mbsnum
#define _tcsappend                  _mbsappend
#define _tcsistr                    _mbsistr
#define _tcsisprint                 _mbsisprint
#define _tcsnzcpy                   _mbsnzcpy
#define _tcssafecpy                 _mbssafecpy
#define _tcsnzcpyab                 _mbsnzcpyab
#define _tcssafecpyab               _mbssafecpyab
#define _tcsprefixcmp               _mbsprefixcmp
#define _tcsprefixicmp              _mbsprefixicmp
#define _tcsctrim                   _mbsctrim

#define AppendWack                  AppendWackA
#define AppendDosWack               AppendDosWackA
#define AppendUncWack               AppendUncWackA
#define AppendPathWack              AppendPathWackA
#define RemoveWackAtEnd             RemoveWackAtEndA
#define JoinPaths                   JoinPathsA
#define JoinPathsInPoolEx           JoinPathsInPoolExA
#define JoinPathsEx                 JoinPathsExA
#define BuildPathInPool             BuildPathInPoolA
#define BuildPath                   BuildPathA
#define BuildPathEx                 BuildPathExA
#define AllocPathString             AllocPathStringA
#define SplitPath                   SplitPathA
#define GetFileNameFromPath         GetFileNameFromPathA
#define GetFileExtensionFromPath    GetFileExtensionFromPathA
#define GetDotExtensionFromPath     GetDotExtensionFromPathA
#define DuplicatePathString         DuplicatePathStringA
#define FindLastWack                FindLastWackA
#define GetNodePatternMinMaxLevels  GetNodePatternMinMaxLevelsA

#define PATH_ENUM                   PATH_ENUMA
#define PPATH_ENUM                  PPATH_ENUMA
#define EnumFirstPathEx             EnumFirstPathExA
#define EnumFirstPath               EnumFirstPathA
#define EnumNextPath                EnumNextPathA
#define EnumPathAbort               EnumPathAbortA
#define FreePathStringEx            FreePathStringExA
#define FreePathString              FreePathStringA

#define GetNextRuleChar             GetNextRuleCharA
#define DecodeRuleChars             DecodeRuleCharsA
#define DecodeRuleCharsAB           DecodeRuleCharsABA
#define EncodeRuleChars             EncodeRuleCharsA

#define SkipSpace                   SkipSpaceA
#define SkipSpaceR                  SkipSpaceRA
#define TruncateTrailingSpace       TruncateTrailingSpaceA
#define IsPatternMatch              IsPatternMatchA
#define IsPatternMatchAB            IsPatternMatchABA
#define IsPatternContained          IsPatternContainedA

#define PPARSEDPATTERN              PPARSEDPATTERNA
#define PARSEDPATTERN               PARSEDPATTERNA
#define CreateParsedPattern         CreateParsedPatternA
#define WildCharsPattern            WildCharsPatternA
#define IsPatternMatchEx            IsPatternMatchExA
#define IsPatternMatchExAB          IsPatternMatchExABA
#define ExplodeParsedPattern        ExplodeParsedPatternA
#define IsPatternContainedEx        IsPatternContainedExA
#define IsParsedPatternContainedEx  IsParsedPatternContainedExA
#define IsExplodedParsedPatternContainedEx  IsExplodedParsedPatternContainedExA
#define TestParsedPattern           TestParsedPatternA
#define TestParsedPatternAB         TestParsedPatternABA
#define DestroyParsedPattern        DestroyParsedPatternA
#define DecodeParsedPattern         DecodeParsedPatternA
#define PatternIncludesPattern      PatternIncludesPatternA
#define GetParsedPatternMinMaxSize  GetParsedPatternMinMaxSizeA
#define ParsedPatternIsExactMatch   ParsedPatternIsExactMatchA
#define ParsedPatternIsOptional     ParsedPatternIsOptionalA
#define ParsedPatternIsRootPlusStar ParsedPatternIsRootPlusStarA
#define ParsedPatternHasRoot        ParsedPatternHasRootA
#define ParsedPatternGetRoot        ParsedPatternGetRootA
#define ParsedPatternSegmentIsPureOptional ParsedPatternSegmentIsPureOptionalA
#define ParsedPatternEndsWithStar   ParsedPatternEndsWithStarA
#define ParsedPatternTrimLastChar   ParsedPatternTrimLastCharA

#define CountInstancesOfChar        CountInstancesOfCharA
#define CountInstancesOfCharI       CountInstancesOfCharIA
#define StringReplace               StringReplaceA
#define CountInstancesOfSubString   CountInstancesOfSubStringA
#define StringSearchAndReplace      StringSearchAndReplaceA
#define MULTISZ_ENUM                MULTISZ_ENUMA
#define EnumFirstMultiSz            EnumFirstMultiSzA
#define EnumNextMultiSz             EnumNextMultiSzA

#define ParseMessage                ParseMessageA
#define ParseMessageEx              ParseMessageExA
#define ParseMessageID              ParseMessageIDA
#define ParseMessageIDEx            ParseMessageIDExA
#define GetStringResource           GetStringResourceA
#define GetStringResourceEx         GetStringResourceExA
#define FreeStringResource          FreeStringResourceA
#define ParseMessageInWnd           ParseMessageInWndA
#define ResourceMessageBox          ResourceMessageBoxA

#define AddInfSectionToHashTable    AddInfSectionToHashTableA
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCA

#define ReplaceWacks(f)             ToggleWacksA(f,FALSE)
#define RestoreWacks(f)             ToggleWacksA(f,TRUE)

#define SanitizePath                SanitizePathA

#define StringToUint64              StringToUint64A
#define TToU64                      AToU64
#define StringToInt64               StringToInt64A
#define TToI64                      AToI64

#endif

//
// MessageBox macros
//

#define YesNoBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNO|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define YesNoCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNOCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define OkBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OK|MB_ICONINFORMATION|MB_SETFOREGROUND,NULL)
#define OkCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OKCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define RetryCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_RETRYCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\basereg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    <filename>

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\ini\ini.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ini.c

Abstract:

    Provides wrappers for commonly used INI file handling routines.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_INILIB      "IniLib"

//
// Strings
//

// None

//
// Constants
//

#define INITIAL_BUFFER_CHAR_COUNT   256

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_IniLibPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
Ini_Init (
    VOID
    )

/*++

Routine Description:

    Ini_Init initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_IniLibPool = PmCreateNamedPool ("IniLib");
    return g_IniLibPool != NULL;
}


VOID
Ini_Exit (
    VOID
    )

/*++

Routine Description:

    Ini_Exit is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    if (g_IniLibPool) {
        PmDestroyPool (g_IniLibPool);
        g_IniLibPool = NULL;
    }
}


PBYTE
pAllocateSpace (
    IN      DWORD Size
    )

/*++

Routine Description:

    pAllocateSpace is a private function that allocates space from the module's private pool

Arguments:

    Size - The size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if no memory could be allocated.

--*/

{
    MYASSERT (g_IniLibPool);
    MYASSERT (Size);
    return PmGetMemory (g_IniLibPool, Size);
}


VOID
pFreeSpace (
    IN      PVOID Buffer
    )

/*++

Routine Description:

    pFreeSpace is a private function that frees space allocated from the module's private pool

Arguments:

    Buffer - Pointer to buffer to free.

Return Value:

    none

--*/

{
    MYASSERT (g_IniLibPool);
    PmReleaseMemory (g_IniLibPool, Buffer);
}


/*++

Routine Description:

    RealIniFileOpen validates the args passed in and then
    initializes IniFile struct with info used in subsequent calls to INI functions.

Arguments:

    IniFile - Receives INI file attributes if open is successful

    IniFileSpec - Specifies the file name; if not full path,
                  current drive and/or dir are prefixed

    FileMustExist - Specifies TRUE if file must exist for open to succeed

Return Value:

    TRUE if open succeeded; IniFile is valid for subsequent calls to other INI APIs;
         IniFileClose must be called when this handle is no longer needed.
    FALSE if not

--*/

BOOL
RealIniFileOpenA (
    OUT     PINIFILEA IniFile,
    IN      PCSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    )
{
    CHAR fullPath[MAX_MBCHAR_PATH];

    if (!GetFullPathNameA (IniFileSpec, MAX_MBCHAR_PATH, fullPath, NULL)) {

        DEBUGMSGA ((
            DBG_ERROR,
            "IniFileOpenA: GetFullPathNameA failed on <%s>",
            IniFileSpec
            ));
        return FALSE;
    }

    DEBUGMSGA_IF ((
        !StringIMatchA (IniFileSpec, fullPath),
        DBG_INILIB,
        "IniFileOpenA: IniFileSpec supplied: <%s>; full path defaulting to <%s>",
        IniFileSpec,
        fullPath
        ));

    if (PathIsDirectoryA (fullPath)) {
        DEBUGMSGA ((
            DBG_INILIB,
            "IniFileOpenA: <%s> is a directory",
            fullPath
            ));
        return FALSE;
    }
    if (FileMustExist && !DoesFileExistA (fullPath)) {
        DEBUGMSGA ((
            DBG_INILIB,
            "IniFileOpenA: file not found: <%s>",
            fullPath
            ));
        return FALSE;
    }

    IniFile->IniFilePath = DuplicateTextExA (g_IniLibPool, fullPath, 0, NULL);
    IniFile->OriginalAttributes = GetFileAttributesA (fullPath);

    if (IniFile->OriginalAttributes != (DWORD)-1) {
        //
        // set working attributes
        //
        SetFileAttributesA (fullPath, FILE_ATTRIBUTE_NORMAL);
    }

    return TRUE;
}


BOOL
RealIniFileOpenW (
    OUT     PINIFILEW IniFile,
    IN      PCWSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    )
{
    WCHAR fullPath[MAX_MBCHAR_PATH];

    if (!GetFullPathNameW (IniFileSpec, MAX_WCHAR_PATH, fullPath, NULL)) {

        DEBUGMSGW ((
            DBG_ERROR,
            "IniFileOpenW: GetFullPathNameW failed on <%s>",
            IniFileSpec
            ));
        return FALSE;
    }

    DEBUGMSGW_IF ((
        !StringIMatchW (IniFileSpec, fullPath),
        DBG_INILIB,
        "IniFileOpenW: IniFileSpec supplied: <%s>; full path defaulting to <%s>",
        IniFileSpec,
        fullPath
        ));

    if (PathIsDirectoryW (fullPath)) {
        DEBUGMSGW ((
            DBG_INILIB,
            "IniFileOpenW: <%s> is a directory",
            fullPath
            ));
        return FALSE;
    }
    if (FileMustExist && !DoesFileExistW (fullPath)) {
        DEBUGMSGW ((
            DBG_INILIB,
            "IniFileOpenW: file not found: <%s>",
            fullPath
            ));
        return FALSE;
    }

    IniFile->IniFilePath = DuplicateTextExW (g_IniLibPool, fullPath, 0, NULL);
    IniFile->OriginalAttributes = GetFileAttributesW (fullPath);

    if (IniFile->OriginalAttributes != (DWORD)-1) {
        //
        // set working attributes
        //
        SetFileAttributesW (fullPath, FILE_ATTRIBUTE_NORMAL);
    }

    return TRUE;
}


/*++

Routine Description:

    IniFileClose frees resources and restores INI's initial attributes

Arguments:

    IniFile - Specifies a handle to an open INI file

Return Value:

    none

--*/

VOID
IniFileCloseA (
    IN      PINIFILEA IniFile
    )
{
    if (IniFile->OriginalAttributes != (DWORD)-1) {
        SetFileAttributesA (IniFile->IniFilePath, IniFile->OriginalAttributes);
    }
    FreeTextExA (g_IniLibPool, IniFile->IniFilePath);
}


VOID
IniFileCloseW (
    IN      PINIFILEW IniFile
    )
{
    if (IniFile->OriginalAttributes != (DWORD)-1) {
        SetFileAttributesW (IniFile->IniFilePath, IniFile->OriginalAttributes);
    }
    FreeTextExW (g_IniLibPool, IniFile->IniFilePath);
}


/*++

Routine Description:

    EnumFirstIniSection returns the first section of the given INI file, if any.

Arguments:

    IniSectEnum - Receives the first section

    IniFile - Specifies a handle to an open INI file

Return Value:

    TRUE if there is a section
    FALSE if not

--*/

BOOL
EnumFirstIniSectionA (
    OUT     PINISECT_ENUMA IniSectEnum,
    IN      PINIFILEA IniFile
    )
{
    PSTR sections;
    DWORD allocatedChars;
    DWORD chars;

    sections = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (sections) {
            pFreeSpace (sections);
        }
        allocatedChars *= 2;
        sections = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!sections) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionNamesA (
                    sections,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*sections) {
        pFreeSpace (sections);
        return FALSE;
    }

    IniSectEnum->Sections = sections;
    IniSectEnum->CurrentSection = sections;
    return TRUE;
}


BOOL
EnumFirstIniSectionW (
    OUT     PINISECT_ENUMW IniSectEnum,
    IN      PINIFILEW IniFile
    )
{
    PWSTR sections;
    DWORD allocatedChars;
    DWORD chars;

    sections = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (sections) {
            pFreeSpace (sections);
        }
        allocatedChars *= 2;
        sections = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!sections) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionNamesW (
                    sections,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*sections) {
        pFreeSpace (sections);
        return FALSE;
    }

    IniSectEnum->Sections = sections;
    IniSectEnum->CurrentSection = sections;
    return TRUE;
}


/*++

Routine Description:

    EnumNextIniSection returns the next section, if any.

Arguments:

    IniSectEnum - Specifies the prev section/receives the next section

Return Value:

    TRUE if there is a next section
    FALSE if not

--*/

BOOL
EnumNextIniSectionA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    )
{
    if (IniSectEnum->CurrentSection && *IniSectEnum->CurrentSection != 0) {
        //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
        //CurrentKeyValuePtr (because GetEndOfStringA will return a valid pointer) so...
        //lint --e(613)
        IniSectEnum->CurrentSection = GetEndOfStringA (IniSectEnum->CurrentSection) + 1;
        if (*IniSectEnum->CurrentSection != 0) {
            return TRUE;
        }
    }

    AbortIniSectionEnumA (IniSectEnum);
    return FALSE;
}


BOOL
EnumNextIniSectionW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    )
{
    if (IniSectEnum->CurrentSection && *IniSectEnum->CurrentSection != 0) {
        //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
        //CurrentKeyValuePtr (because GetEndOfStringW will return a valid pointer) so...
        //lint --e(613)
        IniSectEnum->CurrentSection = GetEndOfStringW (IniSectEnum->CurrentSection) + 1;
        if (*IniSectEnum->CurrentSection != 0) {
            return TRUE;
        }
    }

    AbortIniSectionEnumW (IniSectEnum);
    return FALSE;
}


/*++

Routine Description:

    AbortIniSectionEnum aborts section enumeration

Arguments:

    IniSectEnum - Specifies the section enumeration handle/receives NULLs

Return Value:

    none

--*/

VOID
AbortIniSectionEnumA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    )
{
    pFreeSpace ((PVOID)IniSectEnum->Sections);
    IniSectEnum->Sections = NULL;
    IniSectEnum->CurrentSection = NULL;
}


VOID
AbortIniSectionEnumW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    )
{
    pFreeSpace ((PVOID)IniSectEnum->Sections);
    IniSectEnum->Sections = NULL;
    IniSectEnum->CurrentSection = NULL;
}


/*++

Routine Description:

    EnumFirstIniKeyValue returns the first key/value pair of
    the given INI file/section name, if any.

Arguments:

    IniKeyValueEnum - Receives the first section

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to enumearte

Return Value:

    TRUE if there is a key/value pair
    FALSE if not

--*/

BOOL
EnumFirstIniKeyValueA (
    OUT     PINIKEYVALUE_ENUMA IniKeyValueEnum,
    IN      PINIFILEA IniFile,
    IN      PCSTR Section
    )
{
    PSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section);
    if (!Section) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionA (
                    Section,
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*buffer) {
        pFreeSpace (buffer);
        return FALSE;
    }

    IniKeyValueEnum->KeyValuePairs = buffer;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->Private = NULL;
    return EnumNextIniKeyValueA (IniKeyValueEnum);
}


BOOL
EnumFirstIniKeyValueW (
    OUT     PINIKEYVALUE_ENUMW IniKeyValueEnum,
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section
    )
{
    PWSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section);
    if (!Section) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionW (
                    Section,
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*buffer) {
        pFreeSpace (buffer);
        return FALSE;
    }

    IniKeyValueEnum->KeyValuePairs = buffer;
    IniKeyValueEnum->Private = NULL;
    return EnumNextIniKeyValueW (IniKeyValueEnum);
}


/*++

Routine Description:

    EnumNextIniKeyValue returns the first key/value pair of
    the given INI file/section name, if any.

Arguments:

    IniKeyValueEnum - Specifies the prev key/value pair / receives the next pair

Return Value:

    TRUE if there is a next pair
    FALSE if not

--*/

BOOL
EnumNextIniKeyValueA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    )
{
    //
    // restore from saved position
    //
    IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->Private;
    //
    // skip commented lines
    //
    do {
        if (IniKeyValueEnum->CurrentKeyValuePair) {
            //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
            //CurrentKeyValuePtr (because GetEndOfStringA will return a valid pointer) so...
            //lint --e(613)
            IniKeyValueEnum->CurrentKeyValuePair = GetEndOfStringA (IniKeyValueEnum->CurrentKeyValuePair) + 1;
        } else {
            IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->KeyValuePairs;
        }

        MYASSERT (IniKeyValueEnum->CurrentKeyValuePair);
        if (!(*IniKeyValueEnum->CurrentKeyValuePair)) {
            AbortIniKeyValueEnumA (IniKeyValueEnum);
            return FALSE;
        }
        IniKeyValueEnum->CurrentKey = IniKeyValueEnum->CurrentKeyValuePair;
        IniKeyValueEnum->CurrentValue = _mbschr (IniKeyValueEnum->CurrentKey, '=');
    }  while (*IniKeyValueEnum->CurrentKeyValuePair == ';' || !IniKeyValueEnum->CurrentValue);

    MYASSERT (*IniKeyValueEnum->CurrentKeyValuePair);
    MYASSERT (*IniKeyValueEnum->CurrentValue == '=');
    //
    // remember position for next iteration
    //
    IniKeyValueEnum->Private = GetEndOfStringA (IniKeyValueEnum->CurrentValue);
    //
    // modify buffer to get KEY and VALUE
    //
    *(PSTR)IniKeyValueEnum->CurrentValue = 0;
    IniKeyValueEnum->CurrentValue++;
    TruncateTrailingSpaceA ((PSTR)IniKeyValueEnum->CurrentKey);
    return TRUE;
}


BOOL
EnumNextIniKeyValueW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    )
{
    //
    // restore from saved position
    //
    IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->Private;
    //
    // skip commented lines
    //
    do {
        if (IniKeyValueEnum->CurrentKeyValuePair) {
            //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
            //CurrentKeyValuePtr (because GetEndOfStringW will return a valid pointer) so...
            //lint --e(613)
            IniKeyValueEnum->CurrentKeyValuePair = GetEndOfStringW (IniKeyValueEnum->CurrentKeyValuePair) + 1;
        } else {
            IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->KeyValuePairs;
        }

        MYASSERT (IniKeyValueEnum->CurrentKeyValuePair);
        if (!(*IniKeyValueEnum->CurrentKeyValuePair)) {
            AbortIniKeyValueEnumW (IniKeyValueEnum);
            return FALSE;
        }
        IniKeyValueEnum->CurrentKey = IniKeyValueEnum->CurrentKeyValuePair;
        IniKeyValueEnum->CurrentValue = wcschr (IniKeyValueEnum->CurrentKey, L'=');
    }  while (*IniKeyValueEnum->CurrentKeyValuePair == L';' || !IniKeyValueEnum->CurrentValue);

    MYASSERT (*IniKeyValueEnum->CurrentKeyValuePair);
    MYASSERT (*IniKeyValueEnum->CurrentValue == L'=');
    //
    // remember position for next iteration
    //
    IniKeyValueEnum->Private = GetEndOfStringW (IniKeyValueEnum->CurrentValue);
    //
    // modify buffer to get KEY and VALUE
    //
    *(PWSTR)IniKeyValueEnum->CurrentValue = 0;
    IniKeyValueEnum->CurrentValue++;
    TruncateTrailingSpaceW ((PWSTR)IniKeyValueEnum->CurrentKey);
    return TRUE;
}


/*++

Routine Description:

    AbortIniKeyValueEnum aborts key/value pairs enumeration

Arguments:

    IniKeyValueEnum - Specifies the key/value pair enumeration handle/receives NULLs

Return Value:

    none

--*/

VOID
AbortIniKeyValueEnumA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    )
{
    pFreeSpace ((PVOID)IniKeyValueEnum->KeyValuePairs);
    IniKeyValueEnum->KeyValuePairs = NULL;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->CurrentKey = NULL;
    IniKeyValueEnum->CurrentValue = NULL;
}


VOID
AbortIniKeyValueEnumW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    )
{
    pFreeSpace ((PVOID)IniKeyValueEnum->KeyValuePairs);
    IniKeyValueEnum->KeyValuePairs = NULL;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->CurrentKey = NULL;
    IniKeyValueEnum->CurrentValue = NULL;
}


/*++

Routine Description:

    IniReadValue returns the value of a specified key in a specified section
    from the given INI file. The buffer returned must be freed using IniFreeReadValue

Arguments:

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to read from

    Key - Specifies the key

    Value - Receives a pointer to an allocated buffer containing the read value,
            if function is successful; optional

    Chars - Receives the number of chars (not bytes) the value has,
            excluding the NULL terminator; optional

Return Value:

    TRUE if there is a value for the specified section/key
    FALSE if not

--*/

BOOL
IniReadValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    OUT     PSTR* Value,            OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    )
{
    PSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section && Key);
    if (!Section || !Key) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileStringA (
                    Section,
                    Key,
                    "",
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 1);

    if (Chars) {
        *Chars = chars;
    }

    if (Value) {
        if (*buffer) {
            *Value = buffer;
        } else {
            *Value = NULL;
        }
    }

    if (!(Value && *Value)) {
        //
        // buffer no longer needed
        //
        pFreeSpace (buffer);
    }

    return chars > 0;
}

BOOL
IniReadValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR* Value,           OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    )
{
    PWSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section && Key);
    if (!Section || !Key) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileStringW (
                    Section,
                    Key,
                    L"",
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 1);

    if (Chars) {
        *Chars = chars;
    }

    if (Value) {
        if (*buffer) {
            *Value = buffer;
        } else {
            *Value = NULL;
        }
    }

    if (!(Value && *Value)) {
        //
        // buffer no longer needed
        //
        pFreeSpace (buffer);
    }

    return chars > 0;
}


/*++

Routine Description:

    IniFreeReadValue is used to free the buffer allocated by IniReadValue
    and stored in Value, if specified.

Arguments:

    Value - Specifies a pointer to the string to be freed

Return Value:

    none

--*/

VOID
IniFreeReadValueA (
    IN      PCSTR Value
    )
{
    pFreeSpace ((PVOID)Value);
}


VOID
IniFreeReadValueW (
    IN      PCWSTR Value
    )
{
    pFreeSpace ((PVOID)Value);
}


/*++

Routine Description:

    IniWriteValue writes the key/value pair in the specified section

Arguments:

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to write to

    Key - Specifies the key

    Value - Spcifies the value

Return Value:

    TRUE if write was successful, FALSE if not

--*/

BOOL
IniWriteValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    IN      PCSTR Value
    )
{
    return WritePrivateProfileStringA (
                    Section,
                    Key,
                    Value,
                    IniFile->IniFilePath
                    );
}


BOOL
IniWriteValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    IN      PCWSTR Value
    )
{
    return WritePrivateProfileStringW (
                    Section,
                    Key,
                    Value,
                    IniFile->IniFilePath
                    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inf\infparse.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  infparse.c

Abstract:

  The code in this file read in an INF file, organizing it into a data
  structure that can be manipulated.

  The entry points are:

  OpenInfFile - Parses the INF associated with the STF file.

  InfParse_WriteInfToDisk - Writes the INF memory structure to disk

  AddInfSectionToTable - Adds a new section to the INF memory structure

  AddInfLineToTable - Adds a new line to a section's memory structure

  FindInfSectionInTable - Performs a sequential search for a specific
                          section name

  FindLineInInfSection - Locates a line given a specific key

  DeleteLineInInfSection - Removes a line from an INF section

  DeleteSectionInInfFile - Removes a complete section from the INF memory
                           structure

  GetInfSectionLineCount - Returns the number of lines in a section

  GetFirstLineInSectionStruct - Begins a line enumeration given an INF
                                section ptr

  GetFirstLineInSectionStr - Begins a line enumeration given an INF
                             section string

  GetNextLineInSection - Continues a line enumeration

Author:

  Jim Schmidt (jimschm) 20-Sept-1997

Revision History:

--*/

#include "pch.h"


//
// Globals to manage INF file reading
//

static PBYTE g_Buf1, g_Buf2;
static DWORD g_Buf1Start, g_Buf2Start;
static DWORD g_Buf1End, g_Buf2End;

#define INF_BUFFER_SIZE 32768

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    );

PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    );


typedef struct {
    HANDLE SourceInfFile;
    HANDLE DestInfFile;
    PMHANDLE InfPool;             // A pool for appended INF data
    PINFSECTION FirstInfSection;    // The first section of the parsed INF
    PINFSECTION LastInfSection;     // The last section of the parsed INF
    BOOL InfIsUnicode;
} INFFILE, *PINFFILE;



BOOL
pReadInfIntoTable (
    IN OUT  PINFFILE InfFile,
    IN PWSTR SectionList,
    IN BOOL KeepComments
    )

/*++

Routine Description:

  Reads the specified file into memory, parsing the lines according to basic
  INF structure.

Arguments:

  InfFile - Specifies the structure initilized with the INF file handle.
            Receives the complete INF structure.

Return Value:

  TRUE if parsing was successful, or FALSE if parsing failed.

--*/

{
    WCHAR ch;
    BOOL Error;
    GROWBUFFER LineBuf = INIT_GROWBUFFER;
    PCWSTR Text;
    DWORD Pos;
    PCWSTR Key, Data;
    PWSTR p, q;
    DWORD i;
    PINFSECTION Section = NULL;
    DWORD LineFlags;
    BOOL Result = FALSE;
    HASHTABLE ht = NULL;
    BOOL neededSection = FALSE;
    PWSTR list;


    Section = AddInfSectionToTableW (InfFile, L"");
    if (!Section) {
        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add comment section"));
        return FALSE;
    }


    //
    // If we have a list of sections to fill, add them to a ht, for faster retrieval.
    //
    if (SectionList) {
        list = PmDuplicateStringW (InfFile->InfPool, SectionList);
        ht = HtAllocW ();
        if (ht) {
            while (list) {

                p = wcschr (list, L',');

                if (p) {
                    *p = 0;
                }

                HtAddStringW (ht, SkipSpaceW(list));

                if (p) {
                    *p = L',';
                    list = p + 1;
                }
                else {
                    list = p;
                }
            }
        }
        else {

            LOG ((LOG_ERROR, "Read Inf Into Table: Could not allocate section hash table."));
            return FALSE;
        }

    }


    g_Buf1Start = 0;
    g_Buf2Start = 0;
    g_Buf1End   = 0;
    g_Buf2End   = 0;

    g_Buf1 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);
    g_Buf2 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);

    __try {

        //
        // Determine if this file is UNICODE
        //

        ch = pGetInfFileWchar (InfFile->SourceInfFile, 0, &Error);
        InfFile->InfIsUnicode = (ch == 0xfeff) && !Error;

        //
        // Parse each line.
        //

        Pos = 0;

        for (;;) {
            //
            // Get the line
            //

            Text = pGetNextInfLine (
                        InfFile->SourceInfFile,
                        &LineBuf,
                        &Pos,
                        InfFile->InfIsUnicode
                        );

            if (!Text) {
                break;
            }

            //
            // If a comment line or blank line, skip it
            //

            p = (PWSTR) SkipSpaceW (Text);
            if (!p[0] || p[0] == L';') {
                if (KeepComments && !AddInfLineToTableW (InfFile, Section, NULL, Text, LINEFLAG_ALL_COMMENTS)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line comments to table", Text));
                    __leave;
                }

                continue;
            }

            //
            // If a section line, start the new section
            //

            if (p[0] == L'[') {
                p++;
                q = wcschr (p, L']');
                if (!q) {
                    q = GetEndOfStringW (p);
                } else {
                    *q = 0;
                }

                if (!ht || HtFindStringW (ht, p)) {

                    Section = AddInfSectionToTableW (InfFile, p);
                    neededSection = TRUE;
                    if (!Section) {
                        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add section %s", p));
                        __leave;
                    }
                }
                else {

                    //
                    // We must not care about this section. Make sure we don't add any lines.
                    //
                    neededSection = FALSE;
                }
            }

            //
            // Otherwise it must be a valid line
            //

            else {
                if (!Section) {
                    DEBUGMSG ((DBG_WARNING, "InfParse_ReadInfIntoTable: Ignoring unrecognized line %s", p));
                    continue;
                }

                if (!neededSection) {
                    continue;
                }

                //
                // Split key and line: Skip key that is surrounded by quotes, then
                // find the first
                //

                LineFlags = 0;

                q = p;
                Key = NULL;
                Data = Text;

                while (q[0] == L'\"') {
                    q = wcschr (q + 1, L'\"');
                    if (!q) {
                        q = p;
                        break;
                    } else {
                        q++;
                    }
                }

                i = (DWORD)wcscspn (q, L"\"=");

                if (q[i] == L'=') {
                    q += i;

                    Data = SkipSpaceW (q + 1);
                    *q = 0;
                    q = (PWSTR) SkipSpaceRW (Text, q);
                    if (q && *q) {
                        q++;
                        *q = 0;
                    }

                    Key = p;

                    if (Key[0] == L'\"') {

                        LineFlags |= LINEFLAG_KEY_QUOTED;
                        Key++;

                        p = GetEndOfStringW (Key);
                        p = (PWSTR) SkipSpaceRW (Key, p);

                        if (p && *p) {
                            if (p[0] != L'\"') {
                                p++;
                            }

                            *p = 0;
                        }
                    }
                }

                if (!AddInfLineToTableW (InfFile, Section, Key, Data, LineFlags)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line %s to table", Text));
                    __leave;
                }
            }
        }

        if (Pos != GetFileSize (InfFile->SourceInfFile, NULL)) {
            LOG ((LOG_ERROR, "Read Inf Into Table: Could not read entire INF"));
            __leave;
        }

        Result = TRUE;
    }
    __finally {
        MemFree (g_hHeap, 0, g_Buf1);
        MemFree (g_hHeap, 0, g_Buf2);
        GbFree (&LineBuf);
        if (ht) {
            HtFree (ht);
        }
    }

    return Result;
}


VOID
CloseInfFile (
    HINF InfFile
    )
{
    PINFFILE inf = (PINFFILE) InfFile;

    PmDestroyPool (inf->InfPool);
    MemFree (g_hHeap, 0, inf);

}


HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;
    PWSTR wSectionList = NULL;


    if (SectionList) {
        wSectionList = (PWSTR) ConvertAtoW (SectionList);
    }



    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileA (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PmCreateNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, wSectionList, KeepComments);
    }

    if (wSectionList) {
        FreeConvertedStr (wSectionList);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PmDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle (InfFile->SourceInfFile);
    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;

    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileW (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PmCreateNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, SectionList, KeepComments);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PmDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle (InfFile->SourceInfFile);
    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


BOOL
pSaveInfToFile (
    IN      PINFFILE InfFile
    )

/*++

Routine Description:

  InfParse_WriteInfToDisk writes the INF represented by the given memory
  image to disk.  This is done by enumerating the INF data structures in
  the INF.

Arguments:

  InfFile - Specifies the table to process

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    PINFSECTION Section;
    PINFLINE Line;
    BYTE UnicodeHeader[] = { 0xff, 0xfe };
    DWORD DontCare;
    PCSTR AnsiStr = NULL;
    BOOL b = TRUE;

    MYASSERT (InfFile->SourceInfFile == INVALID_HANDLE_VALUE);
    MYASSERT (InfFile->DestInfFile != INVALID_HANDLE_VALUE);

    //
    // Write the INF as we have it in memory
    //

    __try {
        if (InfFile->InfIsUnicode) {
            if (!WriteFile (InfFile->DestInfFile, UnicodeHeader, sizeof (UnicodeHeader), &DontCare, NULL)) {
                __leave;
            }

            if (!WriteFileStringW (InfFile->DestInfFile, L"\r\n")) {
                __leave;
            }

        } else {

            if (!WriteFileStringA (InfFile->DestInfFile, "\r\n")) {
                __leave;
            }

        }

        Section = InfFile->FirstInfSection;

        while (Section) {
            if (Section->Name[0]) {

                if (InfFile->InfIsUnicode) {

                    if (!WriteFileStringW (InfFile->DestInfFile, L"[") ||
                        !WriteFileStringW (InfFile->DestInfFile, Section->Name) ||
                        !WriteFileStringW (InfFile->DestInfFile, L"]\r\n")
                        ) {
                        __leave;
                    }
                } else {

                    AnsiStr = ConvertWtoA (Section->Name);

                    if (!WriteFileStringA (InfFile->DestInfFile, "[") ||
                        !WriteFileStringA (InfFile->DestInfFile, AnsiStr) ||
                        !WriteFileStringA (InfFile->DestInfFile, "]\r\n")
                        ) {
                        __leave;
                    }

                    FreeConvertedStr (AnsiStr);
                    AnsiStr = NULL;
                }
            }

            Line = Section->FirstLine;

            while (Line) {
                if (Line->Key) {
                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (!WriteFile (InfFile->DestInfFile, L"\"", InfFile->InfIsUnicode ? 2 : 1, &DontCare, NULL)) {
                            __leave;
                        }

                    }

                    if (InfFile->InfIsUnicode) {

                        if (!WriteFileStringW (InfFile->DestInfFile, Line->Key)) {
                            __leave;
                        }

                    } else {

                        AnsiStr = ConvertWtoA (Line->Key);

                        if (!WriteFileStringA (InfFile->DestInfFile, AnsiStr)) {
                            __leave;
                        }

                        FreeConvertedStr (AnsiStr);
                        AnsiStr = NULL;
                    }

                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (!WriteFile (InfFile->DestInfFile, L"\"", InfFile->InfIsUnicode ? 2 : 1, &DontCare, NULL)) {
                            __leave;
                        }

                    }

                    if (InfFile->InfIsUnicode) {

                        if (!WriteFileStringW (InfFile->DestInfFile, L" = ")) {
                            __leave;
                        }

                    } else {

                        if (!WriteFileStringA (InfFile->DestInfFile, " = ")) {
                            __leave;
                        }
                    }
                }

                if (InfFile->InfIsUnicode) {

                    if (!WriteFileStringW (InfFile->DestInfFile, Line->Data) ||
                        !WriteFileStringW (InfFile->DestInfFile, L"\r\n")
                        ) {

                        __leave;
                    }

                } else {

                    AnsiStr = ConvertWtoA (Line->Data);

                    if (!WriteFileStringA (InfFile->DestInfFile, AnsiStr) ||
                        !WriteFileStringA (InfFile->DestInfFile, "\r\n")
                        ) {
                        __leave;
                    }

                    FreeConvertedStr (AnsiStr);
                    AnsiStr = NULL;

                }

                Line = Line->Next;
            }

            if (InfFile->InfIsUnicode) {

                if (!WriteFileStringW (InfFile->DestInfFile, L"\r\n")) {
                    __leave;
                }
            } else {

                if (!WriteFileStringA (InfFile->DestInfFile, "\r\n")) {
                    __leave;
                }
            }

            Section = Section->Next;
        }
    }
    __finally {
        if (AnsiStr) {
            FreeConvertedStr (AnsiStr);
        }

        DEBUGMSG_IF((!b, DBG_ERROR, "Write Inf To Disk: Cannot write INF"));
    }

    return b;
}


BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileA (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileA (SaveToFileSpec);
    }

    return b;
}


BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileW (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileW (SaveToFileSpec);
    }

    return b;
}


PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION SectionPtr;
    PCWSTR UnicodeSectionName;

    UnicodeSectionName = ConvertAtoW (SectionName);

    SectionPtr = AddInfSectionToTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (SectionName);

    return SectionPtr;
}


PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Creates a new section in our linked list structure if necessary.
  The return structure can be used to add lines to the section.

Arguments:

  Inf - Specifies the INF to add the section to

  SectionName - Specifies the name of the new section

Return Value:

  A pointer to the new INF section struct, or NULL if an
  error occurred.

--*/

{
    PINFSECTION NewSection;
    PINFFILE InfFile = (PINFFILE) Inf;

    //
    // Return early if this section already exists
    //

    NewSection = FindInfSectionInTableW (InfFile, SectionName);
    if (NewSection) {
        return NewSection;
    }

    //
    // Allocate a section struct
    //

    NewSection = (PINFSECTION) PmGetAlignedMemory (
                                    InfFile->InfPool,
                                    sizeof (INFSECTION)
                                    );

    if (!NewSection) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewSection, sizeof (INFSECTION));

    NewSection->Name = PmDuplicateStringW (
                            InfFile->InfPool,
                            SectionName
                            );

    if (!NewSection->Name) {
        return NULL;
    }

    NewSection->Prev = InfFile->LastInfSection;
    if (NewSection->Prev) {
        NewSection->Prev->Next = NewSection;
    } else {
        InfFile->FirstInfSection = NewSection;
    }

    InfFile->LastInfSection = NewSection;

    return NewSection;
}


PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    )
{
    PCWSTR UnicodeKey;
    PCWSTR UnicodeData;
    PINFLINE Line;

    if (Key) {
        UnicodeKey = ConvertAtoW (Key);
    } else {
        UnicodeKey = NULL;
    }

    UnicodeData = ConvertAtoW (Data);

    Line = AddInfLineToTableW (Inf, SectionPtr, UnicodeKey, UnicodeData, LineFlags);

    if (Key) {
        FreeConvertedStr (UnicodeKey);
    }

    FreeConvertedStr (UnicodeData);

    return Line;
}


PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    )

/*++

Routine Description:

  Adds a line to the specified section.  The caller specifies the
  full formatted data, and an optional key.  The caller does NOT
  supply the equals sign between the key and data.

Arguments:

  InfFile - Specifies the table to add the INF line to

  SectionName - Specifies the name of the section to add the line to

  Key - If specified, supplies the left-hand side of the equals line

  Data - Specifies the text for the line, or the right-hand side of
         the key = value expression.

  LineFlags - Specifies the flags for the INF line (see LINEFLAG_*)

Return Value:

  TRUE if the line was added to the structure, or FALSE if not.

--*/

{
    PINFLINE NewLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    //
    // Allocate line struct
    //

    NewLine = (PINFLINE) PmGetAlignedMemory (
                              InfFile->InfPool,
                              sizeof (INFLINE)
                              );


    if (!NewLine) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewLine, sizeof (INFLINE));

    if (Key) {
        NewLine->Key = PmDuplicateStringW (
                            InfFile->InfPool,
                            Key
                            );

        if (!NewLine->Key) {
            return NULL;
        }
    }

    NewLine->Data = PmDuplicateStringW (
                        InfFile->InfPool,
                        Data
                        );

    if (!NewLine->Data) {
        return NULL;
    }

    NewLine->Next = NULL;
    NewLine->Prev = SectionPtr->LastLine;
    NewLine->Section = SectionPtr;
    NewLine->LineFlags = LineFlags;

    if (NewLine->Prev) {
        NewLine->Prev->Next = NewLine;
    } else {
        SectionPtr->FirstLine = NewLine;
    }

    SectionPtr->LastLine = NewLine;
    SectionPtr->LineCount++;

    return NewLine;
}


PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION InfSectionPtr;
    PCWSTR UnicodeSectionName;

    UnicodeSectionName = ConvertAtoW (SectionName);

    InfSectionPtr = FindInfSectionInTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (UnicodeSectionName);

    return InfSectionPtr;
}


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Scans the INF for a specific section.  This routine scans
  the INF structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  SectionName - Specifies the name of the section to find

Return Value:

  A pointer to the matching INF section struct, or NULL if
  the section was not found.

--*/

{
    PINFSECTION Section;
    PINFFILE InfFile = (PINFFILE) Inf;

    Section = InfFile->FirstInfSection;
    while (Section) {
        if (StringIMatchW (Section->Name, SectionName)) {
            return Section;
        }

        Section = Section->Next;
    }

    return NULL;
}


PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    )
{

    PINFFILE InfFile = (PINFFILE) Inf;

    if (InfFile) {
        return InfFile->FirstInfSection;
    }

    return NULL;
}

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    )
{

    if (Section) {
        return Section->Next;
    }

    return NULL;
}




PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    )

{
    PCWSTR UnicodeKey;
    PINFLINE LinePtr;

    UnicodeKey = ConvertAtoW (Key);

    LinePtr = FindLineInInfSectionW (Inf, Section, UnicodeKey);

    FreeConvertedStr (UnicodeKey);

    return LinePtr;
}


PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    )

/*++

Routine Description:

  Scans the specified INF section for a specific key.  This routine
  scans the INF line structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  Section - Specifies the section to search

  Key - Specifies the key to find

Return Value:

  A pointer to the matching INF line struct, or NULL if
  the section was not found.

--*/

{
    PINFLINE Line;

    Line = Section->FirstLine;
    while (Line) {
        if (Line->Key && StringIMatchW (Line->Key, Key)) {
            return Line;
        }

        Line = Line->Next;
    }

    return NULL;
}


PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

  This routine does not return lines consisting only of comments.

Arguments:

  Section - Specifies the section structure to enumerate lines frmo

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    if (!Section->FirstLine) {
        return NULL;
    }

    if (Section->FirstLine->LineFlags & LINEFLAG_ALL_COMMENTS) {
        return GetNextLineInSection (Section->FirstLine);
    }

    return Section->FirstLine;
}


PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    )

/*++

Routine Description:

  GetNextLineInSection returns the next INFLINE pointer for the
  section, based on the previous line, or NULL if no lines exist.

  This routine does not return lines with comments.

Arguments:

  PrevLine - Specifies previous line (returned from
             GetFirstLineInSectionStruct or GetFirstLineInSectionStr).

Return Value:

  This routine does not return lines consisting only of comments.

--*/

{
    while (PrevLine) {
        PrevLine = PrevLine->Next;
        if (!PrevLine || !(PrevLine->LineFlags & LINEFLAG_ALL_COMMENTS)) {
            break;
        }
    }

    return PrevLine;
}


PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PCWSTR UnicodeSection;
    PINFLINE LinePtr;

    UnicodeSection = ConvertAtoW (Section);

    LinePtr = GetFirstLineInSectionStrW (Inf, UnicodeSection);

    FreeConvertedStr (UnicodeSection);

    return LinePtr;
}


PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PINFSECTION SectionPtr;
    PINFFILE Table = (PINFFILE) Inf;

    SectionPtr = FindInfSectionInTableW (Table, Section);
    if (!SectionPtr) {
        return NULL;
    }

    return GetFirstLineInSectionStruct (SectionPtr);
}


INT
pGetInfFileByte (
    IN      HANDLE File,
    IN      DWORD Pos
    )

/*++

Routine Description:

  Returns the byte at the specified position, or -1 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

Return Value:

  The byte at the specified position, or -1 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)

--*/

{
    DWORD Read;
    PBYTE BufSwap;

    //
    // If we read the buffer previously, then return data in our buffer
    //

    if (Pos >= g_Buf1Start && Pos < g_Buf1End) {
        return g_Buf1[Pos - g_Buf1Start];
    }

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    //
    // Buffer not available; move buffer 2 to buffer 1, then read buffer 2
    //

    g_Buf1Start = g_Buf2Start;
    g_Buf1End = g_Buf2End;
    BufSwap = g_Buf1;
    g_Buf1 = g_Buf2;
    g_Buf2 = BufSwap;

    g_Buf2Start = Pos - (Pos % 256);

    SetFilePointer (File, (LONG)g_Buf2Start, NULL, FILE_BEGIN);
    if (!ReadFile (File, g_Buf2, INF_BUFFER_SIZE, &Read, NULL)) {
        return -1;
    }

    g_Buf2End = g_Buf2Start + Read;

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    return -1;
}

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    )

/*++

Routine Description:

  Returns the WCHAR at the specified position, or 0 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  Error - Receives TRUE if an error was encountered, or FALSE if an
          error was not encountered.

Return Value:

  The WCHAR at the specified position, or 0 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)
  If an error was encountered, the Error variable is also set to TRUE.

--*/

{
    INT c;
    WCHAR ch;

    c = pGetInfFileByte (File, Pos);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return (WORD) c;
    }

    ch = (WORD) c;

    c = pGetInfFileByte (File, Pos + 1);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return 0;
    }

    // pGetInfFileByte return a byte value or -1.
    // Since we checked for -1 the next cast is valid.
    ch += (WORD)(c * 256);
    *Error = FALSE;

    return ch;
}


PCSTR
pGetInfLineA (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a DBCS string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the DBCS string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    INT c;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;

    EndPos = StartPos;
    for (;;) {
        c = pGetInfFileByte (File, EndPos);
        if (c == -1 || c == 26) {
            break;
        }

        if (IsDBCSLeadByte ((BYTE) c)) {
            EndPos++;
            c = pGetInfFileByte (File, EndPos);
            if (c == -1 || c == 26) {
                break;
            }
            ByteLen++;
        } else {
            if (c == '\r' || c == '\n') {
                EndPos++;
                if (c == '\r') {
                    c = pGetInfFileByte (File, EndPos);
                    if (c == '\n') {
                        EndPos++;
                    }
                }

                break;
            }
        }

        EndPos++;
        ByteLen++;
    }

    //
    // NOTE: If you make a change here, make one below in W version
    //

    // Ctrl+Z ends the file
    if (c == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer, caller frees
    LineBuf->End = 0;
    Data = GbGrow (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && c != '\r' && c != '\n') {
        return NULL;
    }

    // Copy line to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    return (PCSTR) Data;
}


PCWSTR
pGetInfLineW (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a UNICODE string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the UNICODE string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;
    WCHAR ch;
    BOOL Error;

    EndPos = StartPos;
    for (;;) {

        ch = pGetInfFileWchar (File, EndPos, &Error);

        if (Error) {
            break;
        }

        if (ch == L'\r' || ch == L'\n') {
            EndPos += 2;
            if (ch == L'\r') {
                ch = pGetInfFileWchar (File, EndPos, &Error);
                if (ch == '\n') {
                    EndPos += 2;
                }
            }

            break;
        }

        EndPos += 2;
        ByteLen += 2;
    }

    //
    // NOTE: If you make a change here, make one above in A version
    //

    // Ctrl+Z ends the file
    if (ch == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer
    LineBuf->End = 0;
    Data = GbGrow (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && ch != L'\r' && ch != L'\n') {
        return NULL;
    }

    // Copy to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    return (PCWSTR) Data;
}


PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    )

/*++

Routine Description:

  Returns a string supplying the line.  This string can be any length and
  is nul-terminated.  It does not include the \r or \n characters.

Arguments:

  File - Specifies the file to read

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

  Pos - Specifies the byte offset to the start of the line.  Receives
        the byte offset to the next line.

  UnicodeMode - Specifies TRUE if the file being read is a UNICODE file,
                or FALSE if the file being read is a DBCS file.

Return Value:

  A pointer to the string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    PCSTR AnsiStr = NULL;
    PCWSTR UnicodeStr = NULL;
    PCWSTR FinalStr;
    BOOL Converted = FALSE;

    //
    // Obtain the text from the file
    //

    if (UnicodeMode) {
        UnicodeStr = pGetInfLineW (File, *Pos, Pos, LineBuf);
        if (!UnicodeStr) {
            return NULL;
        }
    } else {
        AnsiStr = pGetInfLineA (File, *Pos, Pos, LineBuf);
        if (!AnsiStr) {
            return NULL;
        }
    }

    if (AnsiStr) {
        UnicodeStr = ConvertAtoW (AnsiStr);
        if (!UnicodeStr) {
            return NULL;
        }

        Converted = TRUE;
    }

    FinalStr = UnicodeStr;

    //
    // Copy converted string into line buffer
    //

    if (Converted) {
        LineBuf->End = 0;
        Converted = GbMultiSzAppendW (LineBuf, FinalStr);
        FreeConvertedStr (FinalStr);

        if (!Converted) {
            return NULL;
        }
    }

    return (PCWSTR) LineBuf->Buf;
}


BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    )

/*++

Routine Description:

  DeleteLineInInfSection removes the specified InfLine from its section,
  cleaning up memory used by the line.

Arguments:

  Inf - Specifies the INF to modify

  InfLine - Specifies the line to delete

Return Value:

  TRUE if the line was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFFILE InfFile = (PINFFILE) Inf;

    if (InfLine->Prev) {
        InfLine->Prev->Next = InfLine->Next;
    } else {
        InfLine->Section->FirstLine = InfLine->Next;
    }

    if (InfLine->Next) {
        InfLine->Next->Prev = InfLine->Prev;
    } else {
        InfLine->Section->LastLine = InfLine->Prev;
    }

    if (InfLine->Key) {
        PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Key);
    }

    if (InfLine->Data) {
        PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Data);
    }

    InfLine->Section->LineCount--;

    PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine);
    return TRUE;
}


BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  DeleteSectionInInfFile removes the specified section from the INF
  data structure, removing all lines cleaning up
  memory used by the section.

Arguments:

  InfFile - Specifies the table owning the INF line

  Section - Specifies the section to delete

Return Value:

  TRUE if the section was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFLINE InfLine;
    PINFLINE DelInfLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    InfLine = Section->FirstLine;
    while (InfLine) {
        DelInfLine = InfLine;
        InfLine = InfLine->Next;

        if (!DeleteLineInInfSection (InfFile, DelInfLine)) {
            return FALSE;
        }
    }

    if (Section->Prev) {
        Section->Prev->Next = Section->Next;
    } else {
        InfFile->FirstInfSection = Section->Next;
    }

    if (Section->Next) {
        Section->Next->Prev = Section->Prev;
    } else {
        InfFile->LastInfSection = Section->Prev;
    }

    PmReleaseMemory (InfFile->InfPool, (PVOID) Section->Name);
    PmReleaseMemory (InfFile->InfPool, (PVOID) Section);

    return TRUE;
}


UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetInfSectionLineCount returns the number of lines in the specified
  INF section.

Arguments:

  Section - Specifies the section to query

Return Value:

  The number of lines, or zero if the section has no lines.

--*/

{
    return Section->LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\inf\inf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    inf.c

Abstract:

    Provides wrappers for commonly used INF file handling routines. The wrappers provide, amount
    other things, easy memory allocation using a user supplied GROWBUFFER or PMHANDLE

Author:

    09-Jul-1997 Marc R. Whitten (marcw) - File creation.

Revision History:

    22-Oct-1998  marcw    Added capability to replace/append inf files.
    08-Oct-1997  jimschm  OEM version of SetupGetStringField

--*/

#include "pch.h"

#define INF_UNDEFINED   0
#define INF_REPLACE     1
#define INF_APPEND      2

#define S_VERSION_W L"Version"
#define S_LANGUAGE_W L"Language"
#define S_STRINGS_W L"Strings"
#define INF_INVALID_VERSION 0xffff
#define INF_ANY_LANGUAGE 0x061293

VOID pInitInfReplaceTable (VOID);
UINT pGetLanguage (IN PCSTR File);


typedef struct _tagINFMOD {
    DWORD Version;
    PCSTR ActualInfName;
    PCSTR TargetInfNames;
    BOOL ReplacementFile;
    struct _tagINFMOD *Left, *Right;
} INFMOD, *PINFMOD;


PINFMOD g_RootInfMod;
PMHANDLE g_InfModPool;


VOID
InfGlobalInit (
    IN  BOOL Terminate
    )
{
    if (!Terminate) {
        g_InfModPool = PmCreateNamedPool ("INF Modifications");
    } else {
        PmDestroyPool (g_InfModPool);
        g_RootInfMod = NULL;
    }
}


PBYTE
pAllocateSpace (
    IN PINFSTRUCT Context,
    IN UINT      Size
    )

/*++

Routine Description:

    pAllocateSpace is a private function that allocates space using the user specified allocator.

Arguments:

    Context - A valid INFSTRUCT which has been initialized either by a call to InitInfStruct or
              by using one of the static initializers (INITINFSTRUCT_GROWBUFFER or
              INITINFSTRUCT_PMHANDLE)

    Size    - The size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if no memory could be allocated.

--*/

{

    PBYTE rBytes = NULL;

    switch (Context -> Allocator) {
    case INF_USE_PMHANDLE:
        //
        // Allocate space using Poolmem.
        //
        rBytes = PmGetMemory(Context -> PoolHandle, Size);
        break;

    case INF_USE_GROWBUFFER:
    case INF_USE_PRIVATE_GROWBUFFER:
        //
        // Allocate space using Growbuf.
        //
        Context->GrowBuffer.End = 0;
        rBytes = GbGrow (&(Context -> GrowBuffer), Size);
        break;

    case INF_USE_PRIVATE_PMHANDLE:
        //
        // Allocate space using private growbuffer.
        //
        if (!Context -> PoolHandle) {
            Context -> PoolHandle = PmCreateNamedPool ("INF Pool");
        }
        if (Context -> PoolHandle) {
            rBytes = PmGetMemory(Context -> PoolHandle, Size);
        }
        break;
    }

    return rBytes;
}


VOID
InitInfStruct (
    OUT PINFSTRUCT Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  PMHANDLE PoolHandle   OPTIONAL
    )

/*++

Routine Description:

    This function initializes an INFSTRUCT with the user supplied allocator. It is used when
    user of the INF wrapper routines wishes to manage his own memory (i.e. such as when he
    already has a suitable allocator with sufficient scope created, etc.)

    There is no need to call this function if the user wishes to have the INF wrapper routines
    manage there own memory. Initialize your Init structure with one of either

    INITINFSTRUCT_POOLMEM or INITINFSTRUCT_GROWBUFFER, depending on your preference and needs
    for an allocator.



Arguments:

    Context      - Recieves the initialized INFSTRUCT.
    GrowBuffer   - An optional parameter containing a user supplied and initialized GROWBUFFER.
                   If this parameter is non-NULL, then PoolHandle should be NULL.
    PoolHandle   - An optional parameter containing a user supplied and initialized POOLHANDLE.
                   If this parameter is non-NULL, then GrowBuffer should be NULL.

    One of either GrowBuffer or PoolHandle *must* be specified.

Return Value:

    None.

--*/
{
    ZeroMemory(Context,sizeof(INFSTRUCT));

    if (!PoolHandle && !GrowBuffer) {
        Context  -> Allocator = INF_USE_PRIVATE_PMHANDLE;
    }

    if (PoolHandle) {
        Context  -> PoolHandle = PoolHandle;
        Context  -> Allocator = INF_USE_PMHANDLE;
    }
    if (GrowBuffer) {
        Context -> GrowBuffer = *GrowBuffer;
        Context -> Allocator = INF_USE_GROWBUFFER;
    }

}

VOID
InfCleanUpInfStruct (
    IN OUT PINFSTRUCT Context
    )

/*++

Routine Description:

    InfCleanupInfStruct is responsible for cleaning up the data associated
    with an INFSTRUCT.  This is a mandatory call, unless the INFSTRUCT
    was initialized with InitInfStruct, called with a non-NULL grow buffer or
    pool handle.

    This routine can be called no matter how the INFSTRUCT was initialized.
    However, it will NOT free caller-owned grow buffers or pools.

Arguments:

    Context - Receives the properly cleaned up INFSTRUCT, ready to be
              reused.


Return Value:

     none

--*/

{
    if (Context -> Allocator == INF_USE_PRIVATE_GROWBUFFER) {
        GbFree (&(Context -> GrowBuffer));
    }
    else if (Context -> Allocator == INF_USE_PRIVATE_PMHANDLE && Context -> PoolHandle) {
        PmDestroyPool(Context -> PoolHandle);
    }

    InitInfStruct (Context, NULL, NULL);
}


VOID
InfResetInfStruct (
    IN OUT PINFSTRUCT Context
    )

/*++

Routine Description:

  InfResetInfStruct resets the pool so memory can be recycled.  The intent is
  to allow a caller to reset the INFSTRUCT in order to release the memory
  obtained from getting INF fields.  This is useful in a loop of InfFindFirstLine/
  InfFindNextLine, where two or more fields are processed for each line.

  If only one field is processed in an InfFindFirstLine/InfFindNextLine loop,
  a grow buffer should be used instead.

  This routine empties the active pool block, a block that is 8K by default.  If
  more than the block size has been allocated, other memory blocks besides the
  active block will exist.  Because only the active block is reset, the pool will
  grow.

  If the caller expects more than the block size during one iteration, it should call
  InfCleanupInfStruct to free the pool completely.

Arguments:

  Context - Specifies the struct to reset


Return Value:

  none

--*/

{
    switch (Context -> Allocator) {
    case INF_USE_PMHANDLE:
    case INF_USE_PRIVATE_PMHANDLE:
        if (Context->PoolHandle) {
            PmEmptyPool (Context->PoolHandle);
        }
        break;
    //for some reason lint thought we forgot about INF_USE_GROWBUFFER and
    //INF_USE_PRIVATE_GROWBUFFER. This is not the case so...
    //lint -e(787)
    }
}


PINFMOD
pFindInfMod (
    IN      PCSTR ActualInfName,
    OUT     PINFMOD *Parent         OPTIONAL
    )
{
    PINFMOD Node;
    INT i;

    Node = g_RootInfMod;

    if (Parent) {
        *Parent = NULL;
    }

    while (Node) {
        if (Parent) {
            *Parent = Node;
        }

        i = StringICompare (Node->ActualInfName, ActualInfName);

        if (i < 0) {
            Node = Node->Left;
        } else if (i > 0) {
            Node = Node->Right;
        } else {
            break;
        }
    }

    return Node;
}


BOOL
pInsertInfMod (
    DWORD Version,
    PCSTR ActualInfName,
    PCSTR TargetInfName,
    BOOL ReplacementFile
    )
{
    PINFMOD Node;
    GROWBUFFER Buffer = INIT_GROWBUFFER;
    UINT Size;
    PBYTE Data;
    BOOL Update = FALSE;
    PINFMOD Parent;

    //
    // Update an existing node if one exists
    //

    Node = pFindInfMod (ActualInfName, &Parent);

    if (Node) {

        if (Node->Version <= Version) {

            Update = FALSE;

            if (ReplacementFile) {

                if (!Node->ReplacementFile || Version > Node->Version) {
                    Node->ReplacementFile = ReplacementFile;
                    (VOID)GbMultiSzAppendA (&Buffer, TargetInfName);
                    Update = TRUE;
                }

            } else {

                if (!Node->ReplacementFile || Version > Node->Version) {
                    Size = SizeOfMultiSzA (Node->TargetInfNames);
                    Data = GbGrow (&Buffer, Size);
                    MYASSERT (Data);
                    CopyMemory (Data, Node->TargetInfNames, Size);
                    Buffer.End -= sizeof (CHAR);
                    Update = TRUE;
                }
            }

            if (Update) {
                Node->Version = Version;
                (VOID)GbMultiSzAppendA (&Buffer, TargetInfName);
                (VOID)GbMultiSzAppendA (&Buffer, "");

                Node->TargetInfNames = PmDuplicateMultiSz (g_InfModPool, (PCSTR) Buffer.Buf);
            }
        }
    }

    //
    // Otherwise create a new node
    //

    else {
        Update = TRUE;

        (VOID)GbMultiSzAppendA (&Buffer, TargetInfName);
        (VOID)GbMultiSzAppendA (&Buffer, "");

        Node = (PINFMOD) PmGetAlignedMemory (g_InfModPool, sizeof (INFMOD));
        Node->Left = NULL;
        Node->Right = NULL;
        Node->Version = Version;
        Node->ActualInfName = PmDuplicateString (g_InfModPool, ActualInfName);
        Node->TargetInfNames = PmDuplicateMultiSz (g_InfModPool, (PCSTR) Buffer.Buf);
        Node->ReplacementFile = ReplacementFile;

        if (!Parent) {
            g_RootInfMod = Node;
        } else {
            if (StringICompare (Parent->ActualInfName, ActualInfName) < 0) {
                Parent->Left = Node;
            } else {
                Parent->Right = Node;
            }
        }
    }

    return Update;
}


BOOL
pAddReplacementInfToTable (
    IN PSTR InfToReplace,
    IN PCSTR TargetInf,
    IN UINT Version,
    IN UINT Language,
    IN DWORD Operation
    )
{
    CHAR DecoratedName[MAX_MBCHAR_PATH + 3 * sizeof (UINT) + 2];

    wsprintfA (DecoratedName, "%u:%s", Language, InfToReplace);

    if (Operation == INF_REPLACE) {

        return pInsertInfMod (Version, DecoratedName, TargetInf, TRUE);

    }

    if (Operation == INF_APPEND) {

        return pInsertInfMod (Version, DecoratedName, TargetInf, FALSE);

    }

    return FALSE;
}


BOOL
pGetInfModificationListA (
    IN OUT  PGROWBUFFER Buffer,         OPTIONAL
    IN      UINT LanguageId,
    IN      PCSTR ActualInfName,
    IN      BOOL Replacement
    )
{
    CHAR DecoratedName[MAX_MBCHAR_PATH + sizeof (UINT) * 3 + 2];
    PINFMOD Node;
    UINT Size;
    PBYTE Data;

    wsprintfA (DecoratedName, "%u:%s", LanguageId, ActualInfName);
    if (Buffer) {
        Buffer->End = 0;
    }

    Node = pFindInfMod (DecoratedName, NULL);
    if (!Node || Node->ReplacementFile != Replacement) {
        return FALSE;
    }

    if (Buffer) {
        Size = SizeOfMultiSz (Node->TargetInfNames);
        Data = GbGrow (Buffer, Size);
        CopyMemory (Data, Node->TargetInfNames, Size);
    }

    return TRUE;
}


/*++

Routine Description:

    InfOpenInfFileA and InfOpenInfFileW are wrappers for the SetupOpenInfFile function.
    They cut down the number of parameters necessary to open an INF file by supplying
    the most common options for non-user specified parameters.

    A call to one of these functions is equivelant to
    SetupOpenInfFile(<FileName>,NULL,INF_STYLE_WIN4,NULL)

Arguments:

    FileName - Contains the name of the INF file to open. See the help for SetupOpenInfFile
               for special details concerning this parameter.

Return Value:

    If the INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
RealInfOpenInfFileA (
    IN PCSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )


{
    PCSTR p;
    HINF rInf;
    UINT language;
    CHAR replacePath[MAX_MBCHAR_PATH + sizeof (UINT) * 3 + 2];
    static BOOL firstCall = TRUE;
    GROWBUFFER AppendList = INIT_GROWBUFFER;
    MULTISZ_ENUM e;

    MYASSERT(FileSpec);

    if (firstCall) {

        //
        // Generate the necessary memdb sections for the replace/adds.
        //
        pInitInfReplaceTable ();
        firstCall = FALSE;
    }

    //
    // gather info we'll need to determine if there are infs to replace/append
    // this inf.
    //
    p = GetFileNameFromPathA (FileSpec);

    language = pGetLanguage (FileSpec);

    if (pGetInfModificationListA (&AppendList, language, p, TRUE)) {
        StringCopyA (replacePath, (PCSTR) AppendList.Buf);
    } else {
        *replacePath = 0;
    }

    //
    // Open the main inf.
    //
    rInf = SetupOpenInfFileA (
                *replacePath ? replacePath : FileSpec,
                NULL,
                INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                NULL
                );


    //
    // Append language-specific .add files.
    //
    if (rInf != INVALID_HANDLE_VALUE) {
        if (pGetInfModificationListA (&AppendList, language, p, FALSE)) {

            if (EnumFirstMultiSz (&e, (PCSTR) AppendList.Buf)) {
                do {

                    if (!SetupOpenAppendInfFileA (e.CurrentString, rInf, NULL)) {
                        DEBUGMSGA ((
                            DBG_ERROR,
                            "Unable to append %s to %s.",
                            e.CurrentString,
                            FileSpec
                            ));
                    }

                } while (EnumNextMultiSz (&e));
            }
        }
    }

    GbFree (&AppendList);

    //
    // Append non-language specific .add files.
    //
    if (rInf != INVALID_HANDLE_VALUE) {
        if (pGetInfModificationListA (&AppendList, INF_ANY_LANGUAGE, p, FALSE)) {

            if (EnumFirstMultiSz (&e, (PCSTR) AppendList.Buf)) {
                do {

                    if (!SetupOpenAppendInfFileA (e.CurrentString, rInf, NULL)) {
                        DEBUGMSGA ((
                            DBG_ERROR,
                            "Unable to append %s to %s.",
                            e.CurrentString,
                            FileSpec
                            ));
                    }

                } while (EnumNextMultiSz (&e));
            }
        }
    }

    DebugRegisterAllocation (INF_HANDLE, (PVOID) rInf, File, Line);
    GbFree (&AppendList);

    return rInf;
}


HINF
RealInfOpenInfFileW (
    IN PCWSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )
{
    PCSTR AnsiFileSpec;
    HINF rInf;

    AnsiFileSpec = ConvertWtoA (FileSpec);

    MYASSERT (AnsiFileSpec);

    rInf = InfOpenInfFileA (AnsiFileSpec);

    FreeConvertedStr (AnsiFileSpec);

    return rInf;
}


VOID
InfCloseInfFile (
    HINF Inf
    )
{

    DebugUnregisterAllocation (INF_HANDLE, Inf);


    SetupCloseInfFile (Inf);
}



/*++

Routine Description:

    InfOpenInfInAllSourcesA and InfOpenInfInAllSourcesW are special inf open routines that
    are capable of opening multiple versions of the same inf file that may be spread out across
    installation directories. The first INF file found will be opened with a call to
    SetupOpenInfFile. Additional files will be opened with SetupOpenAppendInfFile.

Arguments:

    InfSpecifier - Contains the source directory indepent portion of the path to a particular inf file.
                   For files located in the root of the source directory, this will simply be the name
                   of the file. For files located in a sub-directory of the source directory, this will
                   be a partial path.

    SourceCount  - Contains the number of source directories

    SourceDirectories - Contains an array of all the source directories.


Return Value:

    If any INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    )
{
    DWORD           index;
    HINF            rInf = INVALID_HANDLE_VALUE;
    PSTR            curPath;
    BOOL            atLeastOneInfOpened = FALSE;
    PCSTR           p;
    UINT            language;

    MYASSERT(InfSpecifier && SourceDirectories);


    //
    //  We must first look to see if someone has specified a
    //  replacement for this file. If so, we are going to use
    //  the replacement instead (simply call InfOpenInfFile..)
    //
    curPath = JoinPathsA (SourceDirectories[0], InfSpecifier);
    p = GetFileNameFromPathA (curPath);

    language = pGetLanguage (curPath);



    if (pGetInfModificationListA (NULL, language, p, TRUE)) {

        rInf = InfOpenInfFileA (curPath);
    }

    FreePathStringA (curPath);
    if (rInf != INVALID_HANDLE_VALUE) {
        return rInf;
    }
    //
    // No replacement for this file, so we are ok. Simply
    // open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsA(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistA (curPath)) {

            //
            // Open the INF file.
            //
            if (!atLeastOneInfOpened) {
                //
                // Since we have not (successfully) opened any INF file yet, use SetupOpenInfFile.
                //
                rInf = InfOpenInfFileA(curPath);
                atLeastOneInfOpened = rInf != INVALID_HANDLE_VALUE;
                if (rInf == INVALID_HANDLE_VALUE) {
                    LOGA ((LOG_ERROR, "Error opening INF %s.", curPath));
                }
            }
            else {
                //
                // Open and append this INF file.
                //
                if (!SetupOpenAppendInfFileA(curPath,rInf,NULL)) {
                    LOGA ((LOG_ERROR,"Error opening INF %s.",curPath));
                }
            }
        }

        //
        // Free this string.
        //
        FreePathStringA(curPath);
    }

    return rInf;
}



HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    )
{
    DWORD index;
    HINF rInf = INVALID_HANDLE_VALUE;
    PWSTR curPath;
    BOOL atLeastOneInfOpened = FALSE;
    PCSTR p;
    UINT language;
    PCSTR AnsiPath;



    MYASSERT(InfSpecifier && SourceDirectories);

    //
    //  We must first look to see if someone has specified a
    //  replacement for this file. If so, we are going to use
    //  the replacement instead (simply call InfOpenInfFile..)
    //
    curPath = JoinPathsW (SourceDirectories[0], InfSpecifier);

    AnsiPath = ConvertWtoA (curPath);
    p = GetFileNameFromPathA (AnsiPath);

    language = pGetLanguage (AnsiPath);

    if (pGetInfModificationListA (NULL, language, p, TRUE)) {

        rInf = InfOpenInfFileW (curPath);
    }

    FreeConvertedStr (AnsiPath);
    FreePathStringW(curPath);

    if (rInf != INVALID_HANDLE_VALUE) {
        return rInf;
    }

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsW(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistW (curPath)) {

            //
            // Open the INF file.
            //
            if (!atLeastOneInfOpened) {
                //
                // Since we have not (successfully) opened any INF file yet, use SetupOpenInfFile.
                //
                rInf = InfOpenInfFileW(curPath);
                atLeastOneInfOpened = rInf != INVALID_HANDLE_VALUE;
                if (rInf == INVALID_HANDLE_VALUE) {
                    LOGW ((LOG_ERROR, "OpenInfInAllSources: Error opening INF %s.", curPath));
                }
            }
            else {
                //
                // Open and append this INF file.
                //
                if (!SetupOpenAppendInfFileW(curPath,rInf,NULL)) {
                    LOGW ((LOG_ERROR,"OpenInfInAllSources: Error opening INF %s.",curPath));
                }
            }
        }

        //
        // Free this string.
        //
        FreePathStringW(curPath);
    }

    return rInf;
}



/*++

Routine Description:

    InfGetLineTextA and InfGetLineTextW are wrappers for the SetupGetLineText function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/
PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCT Context
    )

{
    PSTR    rLine = NULL;
    DWORD   requiredSize;


    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextA(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextA(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetLineTextA: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}

PWSTR
InfGetLineTextW (
    IN OUT PINFSTRUCT Context
    )
{
    PWSTR rLine = NULL;
    DWORD requiredSize;


    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextW(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextW(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetLineTextW: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}


/*++

Routine Description:

    InfGetMultiSzFieldA and InfGetMultiSzFieldW are wrappers for the SetupGetMultiSzField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated fields or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    )
{

    DWORD   requiredSize;
    PSTR    rFields = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldA(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetMultiSzFieldA: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    )
{

    DWORD   requiredSize;
    PWSTR   rFields = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldW(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetMultiSzFieldW: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

/*++

Routine Description:

    InfGetStringFieldA and InfGetStringFieldW are wrappers for the SetupGetStringField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetStringFieldA (
    IN OUT  PINFSTRUCT Context,
    IN      UINT FieldIndex
    )
{

    DWORD   requiredSize;
    PSTR    rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldA(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetStringFieldA: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCT    Context,
    IN     UINT       FieldIndex
    )
{

    DWORD requiredSize;
    PWSTR rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldW(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetStringFieldW: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}


BOOL
InfGetIntField (
    IN PINFSTRUCT Context,
    IN UINT    FieldIndex,
    IN PINT     Value
    )
/*++

Routine Description:

    InfGetIntField is a wrapper for SetupGetIntField. It is virtually identical to this function
    except that it takes care of getting the INFCONTEXT out of the INFSTRUCT structure.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line from which to retrieve the field.

    Value   - Recieves the value of the requested Int field.

Return Value:

     TRUE if the field was successfully retrieved, FALSE otherwise. Use GetLastError() To receive
     extended error information.

--*/
{
    return SetupGetIntField (&(Context -> Context), FieldIndex, Value);
}

PBYTE
InfGetBinaryField (
    IN  PINFSTRUCT    Context,
    IN  UINT       FieldIndex
    )
/*++

Routine Description:

    InfGetBinaryField is a wrapper for the SetupGetBinaryField function. It reduces
    the number of parameters required to get the line text and takes care of
    allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.
    FieldIndex - the index within the line of the desired binary information.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/
{

    DWORD requiredSize;
    PBYTE rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetBinaryField(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = pAllocateSpace(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetBinaryField(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetBinaryField: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

/*++

Routine Description:

  InfGetIndexByLine is a straight wrapper for SetupGetLineByIndex. The only
  difference is the use of an PINFSTRUCT instead of a PINFCONTEXT.

Arguments:

  InfHandle - Contains a valid HINF.

  Section   - Contains the name of the section within the InfFile.

  Index     - Contains the index within the section of the line in question.

  Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

  TRUE if the function was called successfully, FALSE otherwise.

--*/


BOOL
InfGetLineByIndexA(
    IN HINF InfHandle,
    IN PCSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
)
{
    return SetupGetLineByIndexA(InfHandle,Section,Index,&(Context -> Context));
}

BOOL
InfGetLineByIndexW(
    IN HINF InfHandle,
    IN PCWSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
)
{
    return SetupGetLineByIndexW(InfHandle,Section,Index,&(Context -> Context));
}





/*++

Routine Description:

    InfFindFirstLineA and InfFindFirstLineW are wrappers for the SetupFindFirstLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS.

Arguments:


    InfHandle - Contains a valid HINF.

    Section   - Contains the name of the section within the InfFile.

    Key       - An optional parameter containing the name of the key within the section to find.
                If NULL, these routines will return the first line in the section.

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if lines exist in the section, FALSE otherwise.

--*/
BOOL
InfFindFirstLineA (
    IN  HINF         InfHandle,
    IN  PCSTR        Section,
    IN  PCSTR        Key, OPTIONAL
    OUT PINFSTRUCT    Context
    )
{

    return SetupFindFirstLineA (
        InfHandle,
        Section,
        Key,
        &(Context -> Context)
        );
}

BOOL
InfFindFirstLineW (
    IN      HINF InfHandle,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PINFSTRUCT Context
    )
{

    return SetupFindFirstLineW (
        InfHandle,
        Section,
        Key,
        &(Context -> Context)
        );
}

/*++

Routine Description:

    InfFindNextLineA and InfFindNextLineW are wrappers for the SetupFindFirstLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS and
    need only one INFSTRUCT parameter.

Arguments:

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if there is another line in the section, FALSE otherwise.

--*/
BOOL
InfFindNextLine (
    IN OUT PINFSTRUCT    Context
    )
{

    return SetupFindNextLine (&(Context -> Context),&(Context -> Context));
}

UINT
InfGetFieldCount (
    IN PINFSTRUCT Context
    )
{
    return SetupGetFieldCount(&(Context  -> Context));
}



PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCT Context,
    IN      UINT Field
    )

/*++

Routine Description:

  InfGetOemStringField returns a string field in the OEM character set.
  This routine is used when accessing txtsetup.sif.  It is implemented
  only in the A version because UNICODE does not have a concept of OEM
  characters.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Field - Specifies the field number

Return Value:

  A pointer to the OEM string, or NULL if an error occurred.

--*/

{
    PCSTR Text;
    PSTR OemText;
    UINT Size;

    Text = InfGetStringFieldA (Context, Field);
    if (!Text) {
        return NULL;
    }

    Size = SizeOfStringA (Text);

    OemText = (PSTR) pAllocateSpace (Context, Size);
    if (!OemText) {
        return NULL;
    }

    //
    // We leave Text allocated because the caller will free everything
    // when they clean up Context.  Note the assumption that the conversion
    // doesn't change string length.
    //

    OemToCharBuffA (Text, OemText, Size);

    return OemText;
}


BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PTSTR ReturnBuffer,                 OPTIONAL
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize                 OPTIONAL
    )

/*++

Routine Description:

  SetupGetOemStringFieldA is a SetupGetStringField that converts the
  return text to the OEM character set.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Index - Specifies the field number

  ReturnBuffer - Specifies the buffer to fill the text into

  ReturnBufferSize - Specifies the size of ReturnBuffer in bytes

  RequiredSize - Receives the size of the buffer needed

Return Value:

  TRUE if successful, FALSE if failure.

--*/

{
    PSTR OemBuf;

    UINT Size;

    if (!SetupGetStringFieldA (
            Context,
            Index,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
            )) {
        return FALSE;
    }

    if (!ReturnBuffer) {
        return TRUE;
    }

    Size = SizeOfStringA (ReturnBuffer);

    OemBuf = (PSTR) MemAlloc (g_hHeap, 0, Size);

    OemToCharBuffA (ReturnBuffer, OemBuf, Size);
    StringCopyA (ReturnBuffer, OemBuf);
    MemFree (g_hHeap, 0, OemBuf);

    return TRUE;
}


UINT
pGetLanguage (
    IN PCSTR File
    )
{

    HINF inf = INVALID_HANDLE_VALUE;
    PINFSECTION section;
    PINFLINE line;
    PWSTR start, end;
    UINT rLanguage = INF_INVALID_VERSION;
    WCHAR envvar[MAX_MBCHAR_PATH];

    *envvar = 0;

    //
    // Use the infparse rourtines to get this information. They
    // are more reliable than the *privateprofile* apis.
    //

    inf = OpenInfFileExA (File, "version, strings", FALSE);
    if (inf == INVALID_HANDLE_VALUE) {
        return rLanguage;
    }
    section = FindInfSectionInTableW (inf, S_VERSION_W);

    if (section) {
        line = FindLineInInfSectionW (inf, section, S_LANGUAGE_W);

        if (line && line->Data) {

            start = wcschr (line->Data, L'%');
            if (start) {
                end = wcschr (start + 1, L'%');

                if (end) {
                    StringCopyABW(envvar, start+1, end);
                }
            }
            else {

                if (*line->Data == L'*') {

                    rLanguage = INF_ANY_LANGUAGE;
                }
                else {
                    rLanguage = _wcsnum (line->Data);
                }
            }
        }
    }

    if (*envvar) {
        //
        // Get the data from the strings section.
        //
        section = FindInfSectionInTableW (inf, S_STRINGS_W);
        if (section) {

            line = FindLineInInfSectionW (inf, section, envvar);

            if (line && line->Data) {

                if (*line->Data == L'*') {

                    rLanguage = INF_ANY_LANGUAGE;
                }
                else {
                    rLanguage = _wcsnum (line->Data);
                }
            }
        }
    }

    if (inf != INVALID_HANDLE_VALUE) {
        CloseInfFile (inf);
    }
    return rLanguage;
}



VOID
pInitInfReplaceTable (
    VOID
    )
{
/*
    CHAR systemPath[MAX_MBCHAR_PATH];
    CHAR buffer[MAX_MBCHAR_PATH];
    PSTR upginfsDir;
    BOOL validFile = FALSE;
    FILETREE_ENUMA e;
    UINT version = INF_INVALID_VERSION;
    UINT language = INF_INVALID_VERSION;
    DWORD operation = INF_UNDEFINED;


    //
    // Look in the special directory %windir%\upginfs for anything to add
    // to our list.
    //
    if (GetWindowsDirectoryA (systemPath, MAX_MBCHAR_PATH)) {

        upginfsDir = JoinPathsA (systemPath, "UpgInfs\\* <*>");

        if (EnumFirstFileInTreeA (&e, upginfsDir)) {

            do {

                //
                // we only care about *.rep and *.add files. Ignore everything
                // else.
                //
                if ((!(e.Attributes & FILE_ATTRIBUTE_DIRECTORY)) &&
                    (IsPatternMatchA ("*.rep", e.Name) ||
                     IsPatternMatchA ("*.add", e.Name))
                    ) {

                    __try {

                        validFile = TRUE;

                        operation = IsPatternMatchA ("*.rep", e.Name) ? INF_REPLACE :
                                                                        INF_APPEND;

                        GetPrivateProfileStringA (
                            "Version",
                            "TargetInf",
                            "",
                            buffer,
                            MAX_MBCHAR_PATH,
                            e.NativeFullName
                            );

                        if (!*buffer) {
                            validFile = FALSE;
                            __leave;
                        }

                        version = GetPrivateProfileIntA (
                                        "Version",
                                        "Version",
                                        INF_INVALID_VERSION,
                                        e.NativeFullName
                                        );


                        //
                        // version is only needed on replace files.
                        //
                        if (version == INF_INVALID_VERSION && operation == INF_REPLACE) {
                            validFile = FALSE;
                            __leave;
                        }

                        language = pGetLanguage (e.NativeFullName);

                        if (language == INF_INVALID_VERSION) {
                            validFile = FALSE;
                            __leave;
                        }

                    }
                    __finally {

                        if (!validFile || !pAddReplacementInfToTable (buffer, e.NativeFullName, version, language, operation)) {
                            DEBUGMSGA ((DBG_WARNING,"Invalid Replace or Add file found in %s.",upginfsDir));
                        }
                    }
                }

                DEBUGMSGA_IF ((
                    (!(e.Attributes & FILE_ATTRIBUTE_DIRECTORY)) && !IsPatternMatchA ("*.rep", e.Name) && !IsPatternMatchA ("*.add",e.Name),
                    DBG_WARNING,
                    "Non .rep or .add file found in %s directory! Unexpected.",
                    upginfsDir
                    ));


            } while (EnumNextFileInTreeA (&e));
        }
        ELSE_DEBUGMSGA ((DBG_VERBOSE, "InfInitialize: No infs in %s directory.", upginfsDir));

        FreePathStringA (upginfsDir);
    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\ipc\ipc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ipc.c

Abstract:

  The routines in this source file implement an interprocess communication
  mechanism to allow migration DLLs to be isolated into a separate process
  ("sandboxing").  This is done so that no DLL can affect the results of
  any other DLL or Setup.

  The IPC mechanism used here is memory mapped files.  Writes to the
  memory mapped file are synchronized by two events, one for the receiver
  and one by the host.

Author:

    Jim Schmidt (jimschm) 22-Mar-1997

Revision History:

    marcw       07-Feb-2000 Ported to migdlls project.

    jimschm     02-Jun-1999 Added IPC-based DVD check
    jimschm     21-Sep-1998 Converted from mailslots to memory mapped files.
                            (There are bugs in both Win9x and NT mailslots
                            that broke the original design.)
    jimschm     19-Jan-1998  Added beginings of WinVerifyTrust calls

    jimschm     15-Jul-1997  Added many workarounds for Win95 bugs.

--*/


#include "pch.h"
#include "ipc.h"


#include <softpub.h>

#ifdef UNICODE
#error Build must be ANSI
#endif

#define DBG_IPC "Ipc"




typedef struct {
    HANDLE Mapping;
    HANDLE DoCommand;
    HANDLE GetResults;
} IPCDATA, *PIPCDATA;

static PCTSTR g_Mode;
static HANDLE g_ProcessHandle;
static BOOL g_Host;
static IPCDATA g_IpcData;

VOID
pIpcCloseData (
    VOID
    );

BOOL
pIpcOpenData (
    VOID
    );

BOOL
pIpcCreateData (
    IN      PSECURITY_ATTRIBUTES psa
    );

typedef struct {
    DWORD   Command;
    DWORD   Result;
    DWORD   TechnicalLogId;
    DWORD   GuiLogId;
    DWORD   DataSize;
    BYTE    Data[];
} MAPDATA, *PMAPDATA;



BOOL
IpcOpenA (
    IN      BOOL Win95Side,
    IN      PCSTR ExePath,                  OPTIONAL
    IN      PCSTR RemoteArg,                OPTIONAL
    IN      PCSTR WorkingDir                OPTIONAL
    )

/*++

Routine Description:

  IpcOpen has two modes of operation, depending on who the caller is.  If the
  caller is w95upg.dll or w95upgnt.dll, then the IPC mode is called "host mode."
  If the caller is migisol.exe, then the IPC mode is called "remote mode."

  In host mode, IpcOpen creates all of the objects necessary to implement
  the IPC.  This includes two events, DoCommand and GetResults, and a
  file mapping.  After creating the objects, the remote process is launched.

  In remote mode, IpcOpen opens the existing objects that have already
  been created.

Arguments:

  Win95Side - Used in host mode only.  Specifies that w95upg.dll is running
              when TRUE, or that w95upgnt.dll is running when FALSE.

  ExePath   - Specifies the command line for migisol.exe.  Specifies NULL
              to indicate remote mode.

  RemoteArg - Used in host mode only.  Specifies the migration DLL
              path or DVD flag.  Ignored in remote mode.

  WorkingDir - Used in host mode only.  Specifies the working directory path
               for the migration DLL.  Ignored in remote mode.

Return value:

  TRUE if the IPC channel was opened.  If host mode, TRUE indicates that
  migisol.exe is up and running.  If remote mode, TRUE indicates that
  migisol is ready for commands.

--*/

{
    CHAR CmdLine[MAX_CMDLINE];
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    BOOL ProcessResult;
    HANDLE SyncEvent = NULL;
    HANDLE ObjectArray[2];
    DWORD rc;
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_ATTRIBUTES sa, *psa;
    BOOL Result = FALSE;

#ifdef DEBUG
    g_Mode = ExePath ? TEXT("host") : TEXT("remote");
#endif

    __try {

        g_ProcessHandle = NULL;

        g_Host = (ExePath != NULL);

        if (ISNT()) {
            //
            // Create nul DACL for NT
            //

            ZeroMemory (&sa, sizeof (sa));

            psd = (PSECURITY_DESCRIPTOR) MemAlloc (g_hHeap, 0, SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION)) {
                __leave;
            }

            if (!SetSecurityDescriptorDacl (psd, TRUE, (PACL) NULL, FALSE)) {
                 __leave;
            }

            sa.nLength = sizeof (sa);
            sa.lpSecurityDescriptor = psd;

            psa = &sa;

        } else {
            psa = NULL;
        }

        if (g_Host) {
            //
            // Create the IPC objects
            //

            if (!pIpcCreateData (psa)) {
                DEBUGMSG ((DBG_ERROR, "Cannot create IPC channel"));
                __leave;
            }

            MYASSERT (RemoteArg);

            SyncEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("win9xupg"));
            MYASSERT (SyncEvent);

            //
            // Create the child process
            //

            wsprintfA (
                CmdLine,
                "\"%s\" %s \"%s\"",
                ExePath,
                Win95Side ? "-r" : "-m",
                RemoteArg
                );

            ZeroMemory (&si, sizeof (si));
            si.cb = sizeof (si);
            si.dwFlags = STARTF_FORCEOFFFEEDBACK;

            ProcessResult = CreateProcessA (
                                NULL,
                                CmdLine,
                                NULL,
                                NULL,
                                FALSE,
                                CREATE_DEFAULT_ERROR_MODE,
                                NULL,
                                WorkingDir,
                                &si,
                                &pi
                                );

            if (ProcessResult) {
                CloseHandle (pi.hThread);
            } else {
                LOG ((LOG_ERROR, "Cannot start %s", CmdLine));
                __leave;
            }

            //
            // Wait for process to fail or wait for it to set the win95upg event
            //

            ObjectArray[0] = SyncEvent;
            ObjectArray[1] = pi.hProcess;
            rc = WaitForMultipleObjects (2, ObjectArray, FALSE, 60000);
            g_ProcessHandle = pi.hProcess;

            if (rc != WAIT_OBJECT_0) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "Process %x did not signal 'ready'. Wait timed out. (%s)",
                    g_ProcessHandle,
                    g_Mode
                    ));

                LOG ((LOG_ERROR, "Upgrade pack failed during process creation."));

                __leave;
            }

            DEBUGMSG ((DBG_IPC, "Process %s is running (%s)", CmdLine, g_Mode));

        } else {        // !g_Host
            //
            // Open the IPC objects
            //

            if (!pIpcOpenData()) {
                DEBUGMSG ((DBG_ERROR, "Cannot open IPC channel"));
                __leave;
            }

            //
            // Set event notifying setup that we've created our mailslot
            //

            SyncEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("win9xupg"));
            SetEvent (SyncEvent);
        }

        Result = TRUE;
    }

    __finally {
        //
        // Cleanup code
        //

        PushError();

        if (!Result) {
            IpcClose();
        }

        if (SyncEvent) {
            CloseHandle (SyncEvent);
        }

        if (psd) {
            MemFree (g_hHeap, 0, psd);
        }

        PopError();
    }

    return Result;

}


BOOL
IpcOpenW (
    IN      BOOL Win95Side,
    IN      PCWSTR ExePath,                 OPTIONAL
    IN      PCWSTR RemoteArg,               OPTIONAL
    IN      PCWSTR WorkingDir               OPTIONAL
    )
{
    PCSTR AnsiExePath, AnsiRemoteArg, AnsiWorkingDir;
    BOOL b;

    if (ExePath) {
        AnsiExePath = ConvertWtoA (ExePath);
    } else {
        AnsiExePath = NULL;
    }

    if (RemoteArg) {
        AnsiRemoteArg = ConvertWtoA (RemoteArg);
    } else {
        AnsiRemoteArg = NULL;
    }

    if (WorkingDir) {
        AnsiWorkingDir = ConvertWtoA (WorkingDir);
    } else {
        AnsiWorkingDir = NULL;
    }

    b = IpcOpenA (Win95Side, AnsiExePath, AnsiRemoteArg, AnsiWorkingDir);

    FreeConvertedStr (AnsiExePath);
    FreeConvertedStr (AnsiRemoteArg);
    FreeConvertedStr (AnsiWorkingDir);

    return b;
}


VOID
IpcClose (
    VOID
    )

/*++

  Routine Description:

    Tells migisol.exe process to terminate, and then cleans up all resources
    opened by IpcOpen.

  Arguments:

    none

  Return Value:

    none

--*/

{
    if (g_Host) {
        // Tell migisol.exe to terminate
        if (!IpcSendCommand (IPC_TERMINATE, NULL, 0)) {
            IpcKillProcess();
        }

        WaitForSingleObject (g_ProcessHandle, 10000);
    }

    pIpcCloseData();

    if (g_ProcessHandle) {
        CloseHandle (g_ProcessHandle);
        g_ProcessHandle = NULL;
    }
}


VOID
pIpcCloseData (
    VOID
    )
{
    if (g_IpcData.DoCommand) {
        CloseHandle (g_IpcData.DoCommand);
    }

    if (g_IpcData.GetResults) {
        CloseHandle (g_IpcData.GetResults);
    }

    if (g_IpcData.Mapping) {
        CloseHandle (g_IpcData.Mapping);
    }
}


BOOL
pIpcCreateData (
    IN      PSECURITY_ATTRIBUTES psa
    )

/*++

Routine Description:

  pIpcCreateData creates the objects necessary to transfer data between
  migisol.exe and w95upg*.dll.  This function is called in host mode (i.e.,
  from w95upg.dll or w95upgnt.dll).

Arguments:

  psa - Specifies NT nul DACL, or NULL on Win9x

Return Value:

  TRUE if the objects were created properly, or FALSE if not.

--*/

{
    ZeroMemory (&g_IpcData, sizeof (g_IpcData));

    g_IpcData.DoCommand  = CreateEvent (psa, FALSE, FALSE, TEXT("Setup.DoCommand"));
    g_IpcData.GetResults = CreateEvent (psa, FALSE, FALSE, TEXT("Setup.GetResults"));

    g_IpcData.Mapping = CreateFileMapping (
                            INVALID_HANDLE_VALUE,
                            psa,
                            PAGE_READWRITE,
                            0,
                            0x10000,
                            TEXT("Setup.IpcData")
                            );

    if (!g_IpcData.DoCommand ||
        !g_IpcData.GetResults ||
        !g_IpcData.Mapping
        ) {
        pIpcCloseData();
        return FALSE;
    }

    return TRUE;
}


BOOL
pIpcOpenData (
    VOID
    )

/*++

Routine Description:

  pIpcOpenData opens objects necessary to transfer data between migisol.exe
  and w95upg*.dll.  This funciton is called in remote mode (i.e., by
  migisol.exe).  This function must be called after the host has created the
  objects with pIpcCreateData.

Arguments:

  None.

Return Value:

  TRUE of the objects were opened successfully, FALSE otherwise.

--*/

{
    ZeroMemory (&g_IpcData, sizeof (g_IpcData));

    g_IpcData.DoCommand  = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("Setup.DoCommand"));
    g_IpcData.GetResults = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("Setup.GetResults"));

    g_IpcData.Mapping = OpenFileMapping (
                            FILE_MAP_READ|FILE_MAP_WRITE,
                            FALSE,
                            TEXT("Setup.IpcData")
                            );

    if (!g_IpcData.DoCommand ||
        !g_IpcData.GetResults ||
        !g_IpcData.Mapping
        ) {
        pIpcCloseData();
        return FALSE;
    }

    return TRUE;
}


BOOL
IpcProcessAlive (
    VOID
    )

/*++

Routine Description:

  IpcProcessAlive checks for the presense of migisol.exe.  This function is
  intended only for host mode.

Arguments:

  None.

Return Value:

  TRUE if migisol.exe is still running, FALSE otherwise.

--*/

{
    if (!g_ProcessHandle) {
        return FALSE;
    }

    if (WaitForSingleObject (g_ProcessHandle, 0) == WAIT_OBJECT_0) {
        return FALSE;
    }

    return TRUE;
}


VOID
IpcKillProcess (
    VOID
    )

/*++

Routine Description:

  IpcKillProcess forcefully terminates an open migisol.exe process.  This is
  used in GUI mode when the DLL refuses to die.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PushError();

    if (IpcProcessAlive()) {
        TerminateProcess (g_ProcessHandle, 0);
    }

    PopError();
}


DWORD
IpcCheckForWaitingData (
    IN      HANDLE Slot,
    IN      DWORD MinimumSize,
    IN      DWORD Timeout
    )

/*++

Routine Description:

  IpcCheckForWaitingData waits for data to be received by a mailslot.

  If the data does not arrive within the specified timeout, then zero is
  returned, and ERROR_SEM_TIMEOUT is set as the last error.

  If the data arrives within the specified timeout, then the number of
  waiting bytes are returned to the caller.

  This routine works around a Win95 bug with GetMailslotInfo.  Please
  change with caution.

Arguments:

  Slot - Specifies handle to inbound mailslot

  MinimumSize - Specifies the number of bytes that must be available before
                the routine considers the data to be available.  NOTE: If
                a message smaller than MinimumSize is waiting, this
                routine will be blocked until the timeout expires.
                This parameter must be greater than zero.

  Timeout - Specifies the number of milliseconds to wait for the message.

Return value:

  The number of bytes waiting in the mailslot, or 0 if the timeout was
  reached.

--*/

{
    DWORD WaitingSize;
    DWORD UnreliableTimeout;
    DWORD End;

    MYASSERT (MinimumSize > 0);

    End = GetTickCount() + Timeout;

    //
    // The wrap case -- this is really rare (once every 27 days),
    // so just let the tick count go back to zero
    //

    if (End < GetTickCount()) {
        while (End < GetTickCount()) {
            Sleep (100);
        }
        End = GetTickCount() + Timeout;
    }

    do {
        if (!GetMailslotInfo (Slot, NULL, &WaitingSize, NULL, &UnreliableTimeout)) {
            DEBUGMSG ((DBG_ERROR, "IpcCheckForWaitingData: GetMailslotInfo failed (%s)", g_Mode));
            return 0;
        }

        //
        // BUGBUG: Win95 doesn't always return 0xffffffff when there is no data
        // available.  On some machines, Win9x has returned 0xc0ffffff.
        //

        WaitingSize = LOWORD(WaitingSize);

        if (WaitingSize < 0xffff && WaitingSize >= MinimumSize) {
            return WaitingSize;
        }
    } while (GetTickCount() < End);

    SetLastError (ERROR_SEM_TIMEOUT);
    return 0;
}



BOOL
pIpcWriteData (
    IN      HANDLE Mapping,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize,
    IN      DWORD Command,
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId
    )

/*++

Routine Description:

  pIpcWriteData puts data in the memory mapped block that migisol.exe and
  w95upg*.dll share.  The OS takes care of the synchronization for us.

Arguments:

  Mapping        - Specifies the open mapping object

  Data           - Specifies binary data to write

  DataSize       - Specifies the number of bytes in Data, or 0 if Data is NULL

  Command        - Specifies a command DWORD, or 0 if not required

  ResultCode     - Specifies the result code of the last command, or 0 if not
                   applicable

  TechnicalLogId - Specifies the message constant ID (MSG_*) to be added to
                   setupact.log, or 0 if not applicable

  GuiLogId       - Specifies the message constant (MSG_*) of the message to
                   be presented via a popup, or 0 if not applicable

Return Value:

  TRUE if the data was written, FALSE if a sharing violation or other error
  occurs

--*/

{
    PMAPDATA MapData;

    MapData = (PMAPDATA) MapViewOfFile (Mapping, FILE_MAP_WRITE, 0, 0, 0);
    if (!MapData) {
        return FALSE;
    }

    if (!Data) {
        DataSize = 0;
    }

    MapData->Command        = Command;
    MapData->Result         = ResultCode;
    MapData->TechnicalLogId = TechnicalLogId;
    MapData->GuiLogId       = GuiLogId;
    MapData->DataSize       = DataSize;

    if (DataSize) {
        CopyMemory (MapData->Data, Data, DataSize);
    }

    UnmapViewOfFile (MapData);

    return TRUE;
}


BOOL
pIpcReadData (
    IN      HANDLE Mapping,
    OUT     PBYTE *Data,            OPTIONAL
    OUT     PDWORD DataSize,        OPTIONAL
    OUT     PDWORD Command,         OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    )

/*++

Routine Description:

  pIpcReadData retrieves data put in the shared memory block.  The OS takes
  care of synchronization for us.

Arguments:

  Mapping        - Specifies the memory mapping object

  Data           - Receives the inbound binary data, if any is available, or
                   NULL if no data is available.  The caller must free this
                   data with MemFree.

  DataSize       - Receives the number of bytes in Data

  Command        - Receives the inbound command, or 0 if no command was
                   specified

  ResultCode     - Receives the command result code, or 0 if not applicable

  TechnicalLogId - Receives the message constant (MSG_*) of the message to be
                   logged to setupact.log, or 0 if no message is to be logged

  GuiLogId       - Receives the message constant (MSG_*) of the message to be
                   presented in a popup, or 0 if no message is to be presented

Return Value:

  TRUE if data was read, or FALSE if a sharing violation or other error occurs

--*/

{
    PMAPDATA MapData;

    MapData = (PMAPDATA) MapViewOfFile (Mapping, FILE_MAP_READ, 0, 0, 0);
    if (!MapData) {
        return FALSE;
    }

    if (Data) {
        if (MapData->DataSize) {
            *Data = MemAlloc (g_hHeap, 0, MapData->DataSize);
            MYASSERT (*Data);
            CopyMemory (*Data, MapData->Data, MapData->DataSize);
        } else {
            *Data = NULL;
        }
    }

    if (DataSize) {
        *DataSize = MapData->DataSize;
    }

    if (Command) {
        *Command = MapData->Command;
    }

    if (ResultCode) {
        *ResultCode = MapData->Result;
    }

    if (TechnicalLogId) {
        *TechnicalLogId = MapData->TechnicalLogId;
    }

    if (GuiLogId) {
        *GuiLogId = MapData->GuiLogId;
    }

    UnmapViewOfFile (MapData);

    return TRUE;
}


BOOL
IpcSendCommand (
    IN      DWORD Command,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    )

/*++

Routine Description:

  IpcSendCommand puts a command and optional binary data in the shared memory
  block.  It then sets the DoCommand event, triggering the other process to
  read the shared memory.  It is required that a command result is sent
  before the next IpcSendCommand.  See IpcSendCommandResult.

Arguments:

  Command  - Specifies the command to be executed by migisol.exe

  Data     - Specifies the data associated with the command

  DataSize - Specifies the number of bytes in Data, or 0 if Data is NULL

Return Value:

  TRUE if the command was placed in the shared memory block, FALSE otherwise

--*/

{
    if (!pIpcWriteData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            Command,
            0,
            0,
            0
            )) {
        DEBUGMSG ((DBG_ERROR, "IpcSendCommand: Can't send the command to the remote process"));
        return FALSE;
    }

    SetEvent (g_IpcData.DoCommand);

    return TRUE;
}


BOOL
IpcGetCommandResults (
    IN      DWORD Timeout,
    OUT     PBYTE *ReturnData,      OPTIONAL
    OUT     PDWORD ReturnDataSize,  OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    )

/*++

Routine Description:

  IpcGetCommandResults reads the shared memory block and returns the
  available data.

Arguments:

  Timeout        - Specifies the amount of time to wait for a command result
                   (in ms), or INFINITE to wait forever.

  ReturnData     - Receives the binary data associated with the command
                   result, or NULL if no data is associated with the result.
                   The caller must free this data with MemFree.

  ReturnDataSize - Receives the number of bytes in ReturnData, or 0 if
                   ReturnData is NULL.

  ResultCode     - Receives the command result code

  TechnicalLogId - Receives the message constant (MSG_*) to be logged in
                   setupact.log, or 0 if no message is specified

  GuiLogId       - Receives the message constant (MSG_*) of the message to be
                   presented in a popup, or 0 if no message is to be presented

Return Value:

  TRUE if command results were obtained, or FALSE if the wait timed out or
  the IPC connection crashed

--*/

{
    DWORD rc;
    BOOL b;

    rc = WaitForSingleObject (g_IpcData.GetResults, Timeout);

    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_NO_DATA);
        return FALSE;
    }

    b = pIpcReadData (
            g_IpcData.Mapping,
            ReturnData,
            ReturnDataSize,
            NULL,
            ResultCode,
            TechnicalLogId,
            GuiLogId
            );

    return b;
}


BOOL
IpcGetCommand (
    IN      DWORD Timeout,
    IN      PDWORD Command,         OPTIONAL
    IN      PBYTE *Data,            OPTIONAL
    IN      PDWORD DataSize         OPTIONAL
    )

/*++

Routine Description:

  IpcGetCommand obtains the command that needs to be processed.  This routine
  is called by migisol.exe (the remote process).

Arguments:

  Timeout  - Specifies the amount of time (in ms) to wait for a command, or
             INFINITE to wait forever

  Command  - Receives the command that needs to be executed

  Data     - Receives the data associated with the command.  The caller must
             free this block with MemFree.

  DataSize - Receives the number of bytes in Data, or 0 if Data is NULL.

Return Value:

  TRUE if a command was received, FALSE otherwise.

--*/

{
    DWORD rc;
    BOOL b;

    rc = WaitForSingleObject (g_IpcData.DoCommand, Timeout);

    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_NO_DATA);
        return FALSE;
    }

    b = pIpcReadData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            Command,
            NULL,
            NULL,
            NULL
            );

    return b;
}


BOOL
IpcSendCommandResults (
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    )

/*++

Routine Description:

  IpcSendCommandResults puts the command results in the shared memory block.
  This routine is called by migisol.exe (the remote process).

Arguments:

  ResultCode     - Specifies the result code of the command.

  TechnicalLogId - Specifies the message constant (MSG_*) of the message to
                   be logged in setupact.log, or 0 if no message is to be
                   logged

  GuiLogId       - Specifies the message constant (MSG_*) of the message to
                   be presented in a popup to the user, or 0 if no message
                   needs to be presented

  Data           - Specifies the binary data to pass as command results, or
                   NULL of no binary data is required

  DataSize       - Specifies the number of bytes in Data, or 0 if Data is NULL

Return Value:

  TRUE if the command results were placed in shared memory, FALSE otherwise.

--*/

{
    BOOL b;

    b = pIpcWriteData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            0,
            ResultCode,
            TechnicalLogId,
            GuiLogId
            );

    if (!b) {
        DEBUGMSG ((DBG_ERROR, "Can't write command results to IPC buffer"));
        return FALSE;
    }

    SetEvent (g_IpcData.GetResults);

    return TRUE;
}




BOOL
IsDllSignedA (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCSTR DllSpec
    )
{
    PCWSTR UnicodeStr;
    BOOL b;

    UnicodeStr = CreateUnicode (DllSpec);
    if (!UnicodeStr) {
        return FALSE;
    }

    b = IsDllSignedW (WinVerifyTrustApi, UnicodeStr);

    DestroyUnicode (UnicodeStr);

    return b;
}


BOOL
IsDllSignedW (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCWSTR DllSpec
    )
{
    GUID VerifyGuid = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA WinTrustData;
    WINTRUST_FILE_INFO WinTrustFileInfo;
    LONG rc;

    if (!WinVerifyTrustApi) {
        return TRUE;
    }

    ZeroMemory (&WinTrustData, sizeof (WinTrustData));
    ZeroMemory (&WinTrustFileInfo, sizeof (WinTrustFileInfo));

    WinTrustData.cbStruct       = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice     = WTD_UI_NONE;
    WinTrustData.dwUnionChoice  = WTD_CHOICE_FILE;
    WinTrustData.pFile          = &WinTrustFileInfo;

    WinTrustFileInfo.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    WinTrustFileInfo.hFile         = INVALID_HANDLE_VALUE;
    WinTrustFileInfo.pcwszFilePath = DllSpec;

    rc = WinVerifyTrustApi (
            INVALID_HANDLE_VALUE,
            &VerifyGuid,
            &WinTrustData
            );

    return rc == ERROR_SUCCESS;
}





BOOL
IsolatedIsDvdPresentA (
    PCSTR ExePath
    )

/*++

Routine Description:

  IsolatedIsDvdPresent checks for a DVD player by testing in migisol.exe.
  This way if a blue screen occurs, only migisol.exe dies, not setup.

Arguments:

  ExePath - Specifies the full path to migisol.exe.

Return Value:

  TRUE if a DVD player is present, FALSE otherwise.

--*/

{
    BOOL b;
    DWORD rc;

    if (!IpcOpenA (TRUE, ExePath, "-DVD", NULL)) {
        return FALSE;
    }

    b = IpcSendCommand (IPC_DVDCHECK, NULL, 0);

    if (b) {
        b = IpcGetCommandResults (2000, NULL, NULL, &rc, NULL, NULL);
    }

    IpcClose();

    return b && rc != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\dbgtrack.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgtrack.c

Abstract:

    Allocation tracking implementation. From old debug.c

Author:

    Marc R. Whitten  (marcw) 09-Sept-1999

Revision History:

--*/

//
// Includes
//

#include "pch.h"

//
// NOTE: No code should appear outside the #ifdef DEBUG
//

#ifdef DEBUG

#pragma message("DEBUG macros enabled")



//
// Strings
//

// None

//
// Constants
//

#define TRACK_BUCKETS           1501
#define BUCKET_ITEMS_PER_POOL   8192




//
// Macros
//

// None

//
// Types
//

typedef UBINT ALLOCATION_ITEM_OFFSET;

typedef struct _tagTRACKBUCKETITEM {
    struct _tagTRACKBUCKETITEM *Next;
    struct _tagTRACKBUCKETITEM *Prev;
    ALLOCTYPE Type;
    PVOID Ptr;
    ALLOCATION_ITEM_OFFSET ItemOffset;
} TRACKBUCKETITEM, *PTRACKBUCKETITEM;

typedef struct _tagBUCKETPOOL {
    UINT Count;
    TRACKBUCKETITEM Items[BUCKET_ITEMS_PER_POOL];
} TRACKBUCKETPOOL, *PTRACKBUCKETPOOL;


typedef struct {
    ALLOCTYPE Type;
    PVOID Ptr;
    PCSTR FileName;
    UINT Line;
} ALLOCATION_ITEM, *PALLOCATION_ITEM;




//
// Globals
//

PTRACKBUCKETITEM g_TrackBuckets[TRACK_BUCKETS];
PTRACKBUCKETITEM g_TrackPoolDelHead;
PTRACKBUCKETPOOL g_TrackPool;

//
// The following pointer can be used to help identify memory leak sources.
// It is copied to the memory tracking log.
//
PCSTR g_TrackComment;
PCSTR g_TrackFile;
UINT g_TrackLine;
INT g_UseCount;
UINT g_DisableTrackComment = 0;
GROWBUFFER g_AllocationList;
PVOID g_FirstDeletedAlloc;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
DisableTrackComment (
    VOID
    )
{
    g_DisableTrackComment ++;
}

VOID
EnableTrackComment (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        g_DisableTrackComment --;
    }
}



PBYTE
pOurTrackedGbGrow (
    IN      PGROWBUFFER Buffer,
    IN      UINT Bytes
    )
{
    PBYTE p;
    BOOL trackMsg = FALSE;

    //
    // Because grow buffers themselves cause tracking, we have to
    // call the untracked version.  To eliminate confusion, we
    // give a helpful note.
    //

    if (!g_TrackFile) {
        trackMsg = TRUE;
        g_TrackFile = TEXT("<allocation tracking in dbgtrack.c, not a real leak>");
        g_TrackLine = __LINE__;
    }

    p = (PSTR) RealGbGrow (Buffer, Bytes);

    if (trackMsg) {
        g_TrackFile = NULL;
    }

    return p;
}


INT
TrackPush (
    PCSTR Msg,
    PCSTR File,
    UINT Line
    )
{
    static CHAR Buffer[1024];
    static CHAR FileCopy[1024];

    if (g_DisableTrackComment > 0) {
        return 0;
    }

    if (g_UseCount > 0) {
        g_UseCount++;
        return 0;
    }

    if (Msg) {
        wsprintfA (Buffer, "%s", Msg);
    } else {
        wsprintfA (Buffer, "%s line %u", File, Line);
    }

    StringCopyA (FileCopy, File);
    g_TrackFile = FileCopy;
    g_TrackLine = Line;

    g_TrackComment = Buffer;
    g_UseCount = 1;

    return 0;
}


INT
TrackPop (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        return 0;
    }

    g_UseCount--;

    if (!g_UseCount) {
        g_TrackComment = NULL;
        g_TrackFile = NULL;
    }

    return 0;
}


VOID
InitAllocationTracking (
    VOID
    )
{
    ZeroMemory (&g_AllocationList, sizeof (g_AllocationList));
    g_AllocationList.GrowSize = 65536;
    g_FirstDeletedAlloc = NULL;
}


VOID
FreeAllocationTracking (
    VOID
    )
{
    UINT Size;
    UINT u;
    PALLOCATION_ITEM Item;
    GROWBUFFER Msg = INIT_GROWBUFFER;
    CHAR Text[1024];
    PSTR p;
    UINT Bytes;

    Size = g_AllocationList.End / sizeof (ALLOCATION_ITEM);;

    for (u = 0 ; u < Size ; u++) {
        Item = (PALLOCATION_ITEM) g_AllocationList.Buf + u;
        if (!Item->FileName) {
            continue;
        }

        Bytes = (UINT) wsprintfA (Text, "%s line %u\r\n", Item->FileName, Item->Line);
        p = (PSTR) pOurTrackedGbGrow (&Msg, Bytes);

        if (p) {
            CopyMemory (p, Text, Bytes);
        }
    }

    if (Msg.End) {

        p = (PSTR) pOurTrackedGbGrow (&Msg, 1);
        if (p) {
            *p = 0;
            DEBUGMSGA (("Leaks", "%s", Msg.Buf));
        }

        GbFree (&Msg);
    }

    GbFree (&g_AllocationList);
    g_FirstDeletedAlloc = NULL;

    // Intentional leak -- who cares about track memory
    g_TrackPoolDelHead = NULL;
    g_TrackPool = NULL;
}


PTRACKBUCKETITEM
pAllocTrackBucketItem (
    VOID
    )
{
    PTRACKBUCKETITEM BucketItem;

    if (g_TrackPoolDelHead) {
        BucketItem = g_TrackPoolDelHead;
        g_TrackPoolDelHead = BucketItem->Next;
    } else {

        if (!g_TrackPool || g_TrackPool->Count == BUCKET_ITEMS_PER_POOL) {
            g_TrackPool = (PTRACKBUCKETPOOL) SafeHeapAlloc (g_hHeap, 0, sizeof (TRACKBUCKETPOOL));
            if (!g_TrackPool) {
                return NULL;
            }

            g_TrackPool->Count = 0;
        }

        BucketItem = g_TrackPool->Items + g_TrackPool->Count;
        g_TrackPool->Count++;
    }

    return BucketItem;
}

VOID
pFreeTrackBucketItem (
    PTRACKBUCKETITEM BucketItem
    )
{
    BucketItem->Next = g_TrackPoolDelHead;
    g_TrackPoolDelHead = BucketItem;
}



DWORD
pComputeTrackHashVal (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    DWORD Hash;

    Hash = (DWORD) ((DWORD)Type << 16) ^ (DWORD)(UBINT)Ptr;
    return Hash % TRACK_BUCKETS;
}


VOID
pTrackHashTableInsert (
    IN      PBYTE Base,
    IN      ALLOCATION_ITEM_OFFSET ItemOffset
    )
{
    DWORD Hash;
    PTRACKBUCKETITEM BucketItem;
    PALLOCATION_ITEM Item;

    Item = (PALLOCATION_ITEM) (Base + ItemOffset);

    Hash = pComputeTrackHashVal (Item->Type, Item->Ptr);

    BucketItem = pAllocTrackBucketItem();

    if (!BucketItem) {
        DEBUGMSG ((DBG_WHOOPS, "pTrackHashTableInsert failed to alloc memory"));
        return;
    }

    BucketItem->Prev = NULL;
    BucketItem->Next = g_TrackBuckets[Hash];
    BucketItem->Type = Item->Type;
    BucketItem->Ptr  = Item->Ptr;
    BucketItem->ItemOffset = ItemOffset;

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem;
    }

    g_TrackBuckets[Hash] = BucketItem;
}

VOID
pTrackHashTableDelete (
    IN      PTRACKBUCKETITEM BucketItem
    )
{
    DWORD Hash;

    Hash = pComputeTrackHashVal (BucketItem->Type, BucketItem->Ptr);

    if (BucketItem->Prev) {
        BucketItem->Prev->Next = BucketItem->Next;
    } else {
        g_TrackBuckets[Hash] = BucketItem->Next;
    }

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem->Prev;
    }

    pFreeTrackBucketItem (BucketItem);
}

PTRACKBUCKETITEM
pTrackHashTableFind (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PTRACKBUCKETITEM BucketItem;
    DWORD Hash;

    Hash = pComputeTrackHashVal (Type, Ptr);

    BucketItem = g_TrackBuckets[Hash];
    while (BucketItem) {
        if (BucketItem->Type == Type && BucketItem->Ptr == Ptr) {
            return BucketItem;
        }

        BucketItem = BucketItem->Next;
    }

    return NULL;
}


VOID
DebugRegisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line
    )
{
    PALLOCATION_ITEM Item;

    MYASSERT (File);

    if (!g_FirstDeletedAlloc) {
        Item = (PALLOCATION_ITEM) pOurTrackedGbGrow (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        Item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item->Ptr;
    }

    if (Item) {
        Item->Type = Type;
        Item->Ptr = Ptr;
        Item->FileName = File;
        Item->Line = Line;

        pTrackHashTableInsert (
            g_AllocationList.Buf,
            (ALLOCATION_ITEM_OFFSET) ((PBYTE) Item - g_AllocationList.Buf)
            );
    }
}


VOID
DebugUnregisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PALLOCATION_ITEM Item;
    PTRACKBUCKETITEM BucketItem;

    BucketItem = pTrackHashTableFind (Type, Ptr);
    if (!g_AllocationList.Buf) {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Allocation buffer already freed"));
        return;
    }

    if (BucketItem) {
        Item = (PALLOCATION_ITEM) (g_AllocationList.Buf + BucketItem->ItemOffset);

        Item->FileName = NULL;
        Item->Type = (ALLOCTYPE) -1;
        Item->Ptr = g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item;

        pTrackHashTableDelete (BucketItem);

    } else {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Pointer not registered"));
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\basemem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    basemem.c

Abstract:

    Implements macros and declares functions for basic allocation functions.
    Consolidated into this file from debug.c and main.c

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:

--*/


#include "pch.h"


//
// Includes
//

#include "utilsp.h"


//
// Constants
//

#ifdef DEBUG

#define TRAIL_SIG               0x708aa210
#define TRACK_SIGNATURE         0x30405060

#endif

//
// Macros
//

#define REUSE_SIZE_PTR(ptr) ((PDWORD) ((PBYTE) ptr - sizeof (DWORD)))
#define REUSE_TAG_PTR(ptr)  ((PDWORD) ((PBYTE) ptr + (*REUSE_SIZE_PTR(ptr))))


//
// Types
//

#ifdef DEBUG

typedef struct _tagTRACKSTRUCT {

    DWORD Signature;
    PCSTR File;
    DWORD Line;
    SIZE_T Size;
    PSTR Comment;
    PCSTR CallerFile;
    DWORD CallerLine;
    struct _tagTRACKSTRUCT *PrevAlloc;
    struct _tagTRACKSTRUCT *NextAlloc;

} TRACKSTRUCT, *PTRACKSTRUCT;

#endif

//
// Globals
//

#ifdef DEBUG

PTRACKSTRUCT g_TrackHead = NULL;

#endif

//
// Heap debug statistics
//

static SIZE_T g_TotalBytesAllocated = 0;
static SIZE_T g_MaxBytesInUse = 0;
static SIZE_T g_HeapAllocs = 0;
static SIZE_T g_HeapReAllocs = 0;
static SIZE_T g_HeapFrees = 0;
static SIZE_T g_HeapAllocFails = 0;
static SIZE_T g_HeapReAllocFails = 0;
static SIZE_T g_HeapFreeFails = 0;

//
// Out of memory string -- loaded at initialization
//
PCSTR g_OutOfMemoryString = NULL;
PCSTR g_OutOfMemoryRetry = NULL;
HWND g_OutOfMemoryParentWnd;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

#ifdef DEBUG

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );



VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    );

VOID
pTrackDelete (
    PTRACKSTRUCT p
    );

VOID
pWriteTrackLog (
    VOID
    );

#endif

//
// Macro expansion definition
//

// None

//
// Code
//



void
HeapCallFailed (
    PCSTR Msg,
    PCSTR File,
    DWORD Line
    )
{
    CHAR Msg2[2048];

    wsprintfA (Msg2, "Error in %s line %u\n\n", File, Line);
    strcat (Msg2, Msg);
    strcat (Msg2, "\n\nBreak execution now?");

    if (IDYES == MessageBoxA (GetFocus(), Msg2, "Heap Call Failed", MB_YESNO|MB_APPLMODAL)) {
        DebugBreak ();
    }
}

#ifdef DEBUG

SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T rc;

    EnterOurCriticalSection (&g_MemAllocCs);

    rc = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);

    LeaveOurCriticalSection (&g_MemAllocCs);

    return rc;
}

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T size;
    PCVOID RealPtr;
    SIZE_T SizeAdjust;

    SizeAdjust = sizeof (TRACKSTRUCT);
    RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);

    if (IsBadWritePtr ((PBYTE) RealPtr - 8, 8)) {
        CHAR BadPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  This address is not valid.",
            (DWORD)((UBINT)CallerPtr >> 32),
            (DWORD)(UBINT)CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    size = HeapSize (hHeap, 0, RealPtr);
    if (size == (SIZE_T)-1) {
        CHAR BadPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  "
                "This address is not the start of a memory block.",
            (DWORD)((UBINT)CallerPtr >> 32),
            (DWORD)(UBINT)CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    return size;
}

PVOID
DebugHeapAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    SIZE_T BytesToAlloc
    )
{
    PVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD TrackStructSize;
    DWORD OrgError;

    EnterOurCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapAllocFails++;
            __leave;
        }

        RealPtr = SafeHeapAlloc(hHeap, Flags, BytesToAlloc + SizeAdjust);
        if (RealPtr) {
            g_HeapAllocs++;
            g_TotalBytesAllocated += HeapSize (hHeap, 0, RealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) RealPtr);
            *((PDWORD) ((PBYTE) RealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_HeapAllocFails++;
        }

        if (RealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) RealPtr + TrackStructSize);
        }

        if (ReturnPtr && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory (ReturnPtr, BytesToAlloc, 0xAA);
        }

        if (RealPtr) {
            SetLastError(OrgError);
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

PVOID
DebugHeapReAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr,
    SIZE_T BytesToAlloc
    )
{
    UBINT lastSize;
    PVOID NewRealPtr;
    PCVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD OrgError;
    DWORD TrackStructSize;
    SIZE_T OrgSize;
    PTRACKSTRUCT pts = NULL;

    EnterOurCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - TrackStructSize);
        pts = (PTRACKSTRUCT) RealPtr;
        OrgSize = pts->Size;

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapReAllocFails++;
            __leave;
        }

        lastSize = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (lastSize == (UBINT)INVALID_PTR) {
            g_HeapReAllocFails++;
            __leave;
        }

        pTrackDelete (pts);

        NewRealPtr = SafeHeapReAlloc (hHeap, Flags, (PVOID) RealPtr, BytesToAlloc + SizeAdjust);
        if (NewRealPtr) {
            g_HeapReAllocs++;
            g_TotalBytesAllocated -= lastSize;
            g_TotalBytesAllocated += HeapSize (hHeap, 0, NewRealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) NewRealPtr);
            *((PDWORD) ((PBYTE) NewRealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_HeapReAllocFails++;

            // Put original address back in
            pTrackInsert (
                pts->File,
                pts->Line,
                pts->Size,
                pts
                );

        }

        if (NewRealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) NewRealPtr + TrackStructSize);
        }

        if (ReturnPtr && BytesToAlloc > OrgSize && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory ((PBYTE) ReturnPtr + OrgSize, BytesToAlloc - OrgSize, 0xAA);
        }

        if (ReturnPtr) {
            SetLastError (OrgError);
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

BOOL
DebugHeapFree (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr
    )
{
    UBINT size;
    PCVOID RealPtr;
    DWORD SizeAdjust;
    DWORD OrgError;
    BOOL Result = FALSE;
    PTRACKSTRUCT pts = NULL;

    EnterOurCriticalSection (&g_MemAllocCs);

    __try {
        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);
        pts = (PTRACKSTRUCT) RealPtr;

        if (*((PDWORD) ((PBYTE) CallerPtr + pts->Size)) != TRAIL_SIG) {
            HeapCallFailed ("Heap tag was overwritten!", File, Line);
            __leave;
        }

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        size = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (size == (UBINT)INVALID_PTR) {
            g_HeapFreeFails++;
            __leave;
        }

        pTrackDelete ((PTRACKSTRUCT) RealPtr);

        if (!HeapFree (hHeap, Flags, (PVOID) RealPtr)) {
            CHAR BadPtrMsg[256];

            wsprintf (BadPtrMsg,
                      "Attempt to free memory at 0x%08x with flags 0x%08x.  "
                      "HeapFree() failed.",
                      CallerPtr, Flags);

            HeapCallFailed (BadPtrMsg, File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        g_HeapFrees++;
        if (g_TotalBytesAllocated < size) {
            DEBUGMSG ((DBG_WARNING, "Total bytes allocated is less than amount being freed.  "
                                    "This suggests memory corruption."));
            g_TotalBytesAllocated = 0;
        } else {
            g_TotalBytesAllocated -= size;
        }

        SetLastError (OrgError);
        Result = TRUE;
    }
    __finally {
        LeaveOurCriticalSection (&g_MemAllocCs);
    }

    return Result;

}

VOID
DumpHeapStats (
    VOID
    )
{
    CHAR OutputMsg[4096];

    pWriteTrackLog();

    wsprintfA (OutputMsg,
               "Bytes currently allocated: %u\n"
               "Peak bytes allocated: %u\n"
               "Allocation count: %u\n"
               "Reallocation count: %u\n"
               "Free count: %u\n",
               g_TotalBytesAllocated,
               g_MaxBytesInUse,
               g_HeapAllocs,
               g_HeapReAllocs,
               g_HeapFrees
               );

    if (g_HeapAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Allocation failures: %u\n",
                   g_HeapAllocFails);
    }
    if (g_HeapReAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Reallocation failures: %u\n",
                   g_HeapReAllocFails);
    }
    if (g_HeapFreeFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Free failures: %u\n",
                   g_HeapFreeFails);
    }

    DEBUGMSG ((DBG_STATS, "%s", OutputMsg));

#ifdef CONSOLE
    printf ("%s", OutputMsg);
#endif // #ifndef CONSOLE
}

void
DebugHeapCheck (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap
    )
{
    EnterOurCriticalSection (&g_MemAllocCs);

    if (!HeapValidate (hHeap, 0, NULL)) {
        HeapCallFailed ("HeapCheck failed: Heap is corrupt!", File, Line);
    }

    LeaveOurCriticalSection (&g_MemAllocCs);
}

#endif

PVOID
ReuseAlloc (
    HANDLE Heap,
    PVOID OldPtr,
    DWORD SizeNeeded
    )
{
    DWORD CurrentSize;
    PVOID Ptr = NULL;
    UINT AllocAdjustment = sizeof(DWORD);

    //
    // HeapSize is a bad thing, so while it may look good, don't
    // use it.
    //

#ifdef DEBUG
    AllocAdjustment += sizeof (DWORD);
#endif

    if (!OldPtr) {
        Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
    } else {

        CurrentSize = *REUSE_SIZE_PTR(OldPtr);

#ifdef DEBUG
        if (*REUSE_TAG_PTR(OldPtr) != 0x10a28a70) {
            DEBUGMSG ((DBG_WHOOPS, "MemReuse detected corruption!"));
            Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
        } else
#endif

        if (SizeNeeded > CurrentSize) {
            SizeNeeded += 1024 - (SizeNeeded & 1023);

            Ptr = MemReAlloc (Heap, 0, REUSE_SIZE_PTR(OldPtr), SizeNeeded + AllocAdjustment);
            OldPtr = NULL;
        }
    }

    if (Ptr) {
        *((PDWORD) Ptr) = SizeNeeded;
        Ptr = (PVOID) ((PBYTE) Ptr + sizeof (DWORD));

#ifdef DEBUG
        *REUSE_TAG_PTR(Ptr) = 0x10a28a70;
#endif
    }

    return Ptr ? Ptr : OldPtr;
}

VOID
ReuseFree (
    HANDLE Heap,
    PVOID Ptr
    )
{
    if (Ptr) {
        MemFree (Heap, 0, REUSE_SIZE_PTR(Ptr));
    }
}


VOID
SetOutOfMemoryParent (
    HWND hwnd
    )
{
    g_OutOfMemoryParentWnd = hwnd;
}


VOID
OutOfMemory_Terminate (
    VOID
    )
{
    MessageBox (
        g_OutOfMemoryParentWnd,
        g_OutOfMemoryString,
        NULL,
        MB_OK|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
        );

    ExitProcess (0);
    //
    // Not needed, will never get here
    //
    // TerminateProcess (GetModuleHandle (NULL), 0);
}

VOID
pValidateBlock (
    PVOID Block,
    SIZE_T Size
    )

/*++

Routine Description:

  pValidateBlock makes sure Block is non-NULL.  If it is NULL, then the user
  is given a popup, unless the request size is bogus.

  There are two cases for the popup.

   - If g_OutOfMemoryParentWnd was set with SetOutOfMemoryParent,
     then the user is asked to close other programs, and is given a retry
     option.

   - If there is no out of memory parent, then the user is told they
     need to get more memory.

  In either case, Setup is terminated.  In GUI mode, Setup will be
  stuck and the machine will be unbootable.

Arguments:

  Block - Specifies the block to validate.
  Size - Specifies the request size

Return Value:

  none

--*/

{
    LONG rc;

    if (!Block && Size < 0x2000000) {
        if (g_OutOfMemoryParentWnd) {
            rc = MessageBox (
                    g_OutOfMemoryParentWnd,
                    g_OutOfMemoryRetry,
                    NULL,
                    MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                    );

            if (rc == IDCANCEL) {
                OutOfMemory_Terminate();
            }
        } else {
            OutOfMemory_Terminate();
        }
    }
}

PVOID
SafeHeapAlloc (
    HANDLE Heap,
    DWORD Flags,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapAlloc (Heap, Flags, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

PVOID
SafeHeapReAlloc (
    HANDLE Heap,
    DWORD Flags,
    PVOID OldBlock,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapReAlloc (Heap, Flags, OldBlock, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

#ifdef DEBUG

VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    )
{
    p->Signature = TRACK_SIGNATURE;
    p->File      = File;
    p->Line      = Line;
    p->Size      = Size;
    p->Comment   = g_TrackComment ? SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (g_TrackComment)) : NULL;
    p->PrevAlloc = NULL;
    p->NextAlloc = g_TrackHead;
    p->CallerFile = g_TrackFile;
    p->CallerLine = g_TrackLine;

    if (p->Comment) {
        StringCopyA (p->Comment, g_TrackComment);
    }

    if (g_TrackHead) {
        g_TrackHead->PrevAlloc = p;
    }

    g_TrackHead = p;
}

VOID
pTrackDelete (
    PTRACKSTRUCT p
    )
{
    if (p->Signature != TRACK_SIGNATURE) {
        DEBUGMSG ((DBG_WARNING, "A tracking signature is invalid.  "
                                "This suggests memory corruption."));
        return;
    }

    if (p->PrevAlloc) {
        p->PrevAlloc->NextAlloc = p->NextAlloc;
    } else {
        g_TrackHead = p->NextAlloc;
    }

    if (p->NextAlloc) {
        p->NextAlloc->PrevAlloc = p->PrevAlloc;
    }
}

VOID
pWriteTrackLog (
    VOID
    )
{
    HANDLE File;
    CHAR LineBuf[2048];
    PTRACKSTRUCT p;
    DWORD DontCare;
    DWORD Count;
    BOOL BadMem = FALSE;
    CHAR TempPath[MAX_TCHAR_PATH];
    CHAR memtrackLogPath[] = "?:\\memtrack.log";

    if (!g_TrackHead) {
        return;
    }

    GetSystemDirectory(TempPath, MAX_TCHAR_PATH);
    memtrackLogPath[0] = TempPath[0];

    File = CreateFileA (memtrackLogPath, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
                        );

    if (File != INVALID_HANDLE_VALUE) {
        Count = 0;
        __try {
            for (p = g_TrackHead ; p ; p = p->NextAlloc) {
                Count++;
                __try {
                    if (p->Comment) {
                        if (p->CallerFile) {
                            wsprintfA (
                                LineBuf,
                                "%s line %u\r\n"
                                    "  %s\r\n"
                                    "  Caller: %s line %u\r\n"
                                    "\r\n",
                                p->File,
                                p->Line,
                                p->Comment,
                                p->CallerFile,
                                p->CallerLine
                                );
                        } else {
                            wsprintfA (LineBuf, "%s line %u\r\n  %s\r\n\r\n", p->File, p->Line, p->Comment);
                        }
                    } else {
                        if (p->CallerFile) {
                            wsprintfA (
                                LineBuf,
                                "%s line %u\r\n"
                                    "  Caller: %s line %u\r\n"
                                    "\r\n",
                                p->File,
                                p->Line,
                                p->CallerFile,
                                p->CallerLine
                                );
                        } else {
                            wsprintfA (LineBuf, "(direct alloc) %s line %u\r\n\r\n", p->File, p->Line);
                        }
                    }

                }
                __except (TRUE) {
                    wsprintfA (LineBuf, "Address %Xh was freed, but not by MemFree!!\r\n", p);
                    BadMem = TRUE;
                }
                WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);

                //lint --e(774)
                if (BadMem) {
                    break;
                }
            }
        }
        __except (TRUE) {
        }

        wsprintfA (LineBuf, "\r\n%i item%s allocated but not freed.\r\n", Count, Count == 1 ? "":"s");
        WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);

        CloseHandle (File);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\basefile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    basefile.c

Abstract:

    Contains simple wrappers for commonly used file i/o functions.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_BASEFILE     "File Utils"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  Writes a DBCS string to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the nul-terminated string to write to the file.

Return Value:

  TRUE if successful, FALSE if an error occurred.  Call GetLastError
  for error condition.

--*/

{
    DWORD DontCare;

    return WriteFile (File, String, ByteCountA (String), &DontCare, NULL);
}


BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS, then Writes it to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the UNICODE nul-terminated string to convert and
           write to the file.

Return Value:

 TRUE if successful, FALSE if an error occurred.  Call GetLastError for
 error condition.

--*/

{
    DWORD DontCare;
    PCSTR AnsiVersion;
    BOOL b;

    AnsiVersion = ConvertWtoA (String);
    if (!AnsiVersion) {
        return FALSE;
    }

    b = WriteFile (File, AnsiVersion, ByteCountA (AnsiVersion), &DontCare, NULL);

    FreeConvertedStr (AnsiVersion);

    return b;
}

BOOL
DoesFileExistExA(
    IN      PCSTR FileName,
    OUT     PWIN32_FIND_DATAA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAA ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        return GetFileAttributesA (FileName) != 0xffffffff;
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileA(FileName, &ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
DoesFileExistExW (
    IN      PCWSTR FileName,
    OUT     PWIN32_FIND_DATAW FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAW ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        return GetFileAttributesW (FileName) != 0xffffffff;
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileW(FileName,&ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


/*++

Routine Description:

    PathIsDirectory determines if a path identifies an accessible directory.

Arguments:

    PathSpec - Specifies the full path.

Return Value:

    TRUE if the path identifies a directory.
    FALSE if not. GetLastError() returns extended error info.

--*/

BOOL
PathIsDirectoryA (
    IN      PCSTR PathSpec
    )
{
    DWORD attribs;

    MYASSERT (PathSpec);
    if (!PathSpec) {
        return FALSE;
    }
    attribs = GetFileAttributesA (PathSpec);
    return attribs != (DWORD)-1 && (attribs & FILE_ATTRIBUTE_DIRECTORY);
}

BOOL
PathIsDirectoryW (
    IN      PCWSTR PathSpec
    )
{
    DWORD attribs;

    MYASSERT (PathSpec);
    if (!PathSpec) {
        return FALSE;
    }
    attribs = GetFileAttributesW (PathSpec);
    return attribs != (DWORD)-1 && (attribs & FILE_ATTRIBUTE_DIRECTORY);
}


PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileA (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingA (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileW (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingW (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}

#if 0
BOOL
UnmapFile (
    IN PCVOID FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    )

/*++

Routine Description:

  UnmapFile is used to release all resources allocated by MapFileIntoMemory.

Arguments:

  FileImage - image of the mapped file as returned by MapFileIntoMemory
  MapHandle - handle of the mapping object as returned by MapFileIntoMemory
  FileHandle - handle of the file as returned by MapFileIntoMemory

Return Value:

  TRUE if successfull, FALSE if not

--*/

{
    BOOL result = TRUE;

    //if FileImage is a valid pointer then try to unmap file
    if (FileImage != NULL) {
        if (UnmapViewOfFile (FileImage) == 0) {
            result = FALSE;
        }
    }

    //if mapping object is valid then try to delete it
    if (MapHandle != NULL) {
        if (CloseHandle (MapHandle) == 0) {
            result = FALSE;
        }
    }

    //if file handle is valid then try to close the file
    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (CloseHandle (FileHandle) == 0) {
            result = FALSE;
        }
    }

    return result;
}
#endif

BOOL
BfGetTempFileNameA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars
    )
{
    CHAR tempPath[MAX_MBCHAR_PATH];
    CHAR tempFile[MAX_MBCHAR_PATH];
    UINT tchars;

    if (!GetTempPathA (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    if (BufferTchars >= MAX_PATH) {
        if (!GetTempFileNameA (tempPath, "tmp", 0, Buffer)) {
            return FALSE;
        }
    } else {
        if (!GetTempFileNameA (tempPath, "tmp", 0, tempFile)) {
            return FALSE;
        }

        tchars = TcharCountA (tempFile);

        if (tchars > BufferTchars) {
            DEBUGMSG ((DBG_ERROR, "Can't get temp file name -- buffer too small"));
            return FALSE;
        }

        CopyMemory (Buffer, tempFile, tchars * sizeof (CHAR));
    }

    return TRUE;
}


BOOL
BfGetTempFileNameW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars
    )
{
    WCHAR tempPath[MAX_WCHAR_PATH];
    WCHAR tempFile[MAX_WCHAR_PATH];
    UINT tchars;

    if (!GetTempPathW (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    if (BufferTchars >= MAX_PATH) {
        if (!GetTempFileNameW (tempPath, L"tmp", 0, Buffer)) {
            return FALSE;
        }
    } else {
        if (!GetTempFileNameW (tempPath, L"tmp", 0, tempFile)) {
            return FALSE;
        }

        tchars = TcharCountW (tempFile);

        if (tchars > BufferTchars) {
            DEBUGMSG ((DBG_ERROR, "Can't get temp file name -- buffer too small"));
            return FALSE;
        }

        CopyMemory (Buffer, tempFile, tchars * sizeof (WCHAR));
    }

    return TRUE;
}


HANDLE
BfGetTempFile (
    VOID
    )
{
    CHAR tempFile[MAX_MBCHAR_PATH];
    HANDLE file;

    if (!BfGetTempFileNameA (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }

    file = CreateFile (
                tempFile,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL|FILE_FLAG_DELETE_ON_CLOSE,
                NULL
                );

    if (file == INVALID_HANDLE_VALUE) {
        file = NULL;
    }

    return file;
}


BOOL
BfSetFilePointer (
    IN      HANDLE File,
    IN      LONGLONG Offset
    )
{
    LARGE_INTEGER li;

    li.QuadPart = Offset;

    li.LowPart = SetFilePointer (File, li.LowPart, &li.HighPart, FILE_BEGIN);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    }

    return li.QuadPart != -1;
}


HANDLE
BfOpenFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


HANDLE
BfOpenFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle =  CreateFileA (
                    FileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;

}

HANDLE
BfCreateFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateSharedFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateSharedFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


BOOL
BfSetSizeOfFile (
    HANDLE File,
    LONGLONG Size
    )
{
    if (!BfSetFilePointer (File, Size)) {
        return FALSE;
    }

    return SetEndOfFile (File);
}


BOOL
BfGoToEndOfFile (
    IN      HANDLE File,
    OUT     PLONGLONG FileSize      OPTIONAL
    )
{
    LARGE_INTEGER li;

    li.HighPart = 0;
    li.LowPart = SetFilePointer (File, 0, &li.HighPart, FILE_END);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    } else if (FileSize) {
        *FileSize = li.QuadPart;
    }

    return li.QuadPart != -1;
}


BOOL
BfGetFilePointer (
    IN      HANDLE File,
    OUT     PLONGLONG FilePointer       OPTIONAL
    )
{
    LARGE_INTEGER li;

    li.HighPart = 0;
    li.LowPart = SetFilePointer (File, 0, &li.HighPart, FILE_CURRENT);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    } else if (FilePointer) {
        *FilePointer = li.QuadPart;
    }

    return li.QuadPart != -1;
}


BOOL
BfReadFile (
    IN      HANDLE File,
    OUT     PBYTE Buffer,
    IN      UINT BytesToRead
    )
{
    DWORD bytesRead;

    if (!ReadFile (File, Buffer, BytesToRead, &bytesRead, NULL)) {
        return FALSE;
    }

    return bytesRead == BytesToRead;
}


BOOL
BfWriteFile (
    IN      HANDLE File,
    OUT     PCBYTE Buffer,
    IN      UINT BytesToWrite
    )
{
    DWORD bytesWritten;

    if (!WriteFile (File, Buffer, BytesToWrite, &bytesWritten, NULL)) {
        return FALSE;
    }

    return bytesWritten == BytesToWrite;
}


BOOL
BfCreateDirectoryA (
    IN      PCSTR FullPath
    )
{
    PSTR pathCopy;
    PSTR p;
    BOOL b = TRUE;

    pathCopy = DuplicatePathStringA (FullPath, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == ':' && pathCopy[2] == '\\') {
        //
        // <drive>:\ case
        //

        p = _mbschr (&pathCopy[3], '\\');

    } else if (pathCopy[0] == '\\' && pathCopy[1] == '\\') {

        //
        // UNC case
        //

        p = _mbschr (pathCopy + 2, '\\');
        if (p) {
            p = _mbschr (p + 1, '\\');
            if (p) {
                p++;
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = _mbschr (pathCopy, '\\');
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectoryA (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            break;
        }

        *p = '\\';
        p = _mbschr (p + 1, '\\');
    }

    //
    // At last, make the FullPath directory
    //

    if (b) {
        b = CreateDirectoryA (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    FreePathStringA (pathCopy);

    return b;
}


BOOL
BfCreateDirectoryW (
    IN      PCWSTR FullPath
    )
{
    PWSTR pathCopy;
    PWSTR p;
    BOOL b = TRUE;

    pathCopy = DuplicatePathStringW (FullPath, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == L':' && pathCopy[2] == L'\\') {
        //
        // <drive>:\ case
        //

        p = wcschr (&pathCopy[3], L'\\');

    } else if (pathCopy[0] == L'\\' && pathCopy[1] == L'\\') {

        //
        // UNC case
        //

        p = wcschr (pathCopy + 2, L'\\');
        if (p) {
            p = wcschr (p + 1, L'\\');
            if (p) {
                p++;
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = wcschr (pathCopy, L'\\');
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectoryW (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            break;
        }

        *p = L'\\';
        p = wcschr (p + 1, L'\\');
    }

    //
    // At last, make the FullPath directory
    //

    if (b) {
        b = CreateDirectoryW (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    FreePathStringW (pathCopy);

    return b;
}


LONGLONG
BfGetFileSizeA (
    IN      PCSTR FileName
    )
{
    WIN32_FIND_DATAA fd;
    LONGLONG l;

    if (!DoesFileExistExA (FileName, &fd)) {
        return 0;
    }

    l = ((LONGLONG) fd.nFileSizeHigh << 32) | fd.nFileSizeLow;

    return l;
}

PSTR
pGetFirstSegA (
    IN      PCSTR SrcFileName
    )
{
    if (SrcFileName [0] == '\\') {
        SrcFileName ++;
        if (SrcFileName [0] == '\\') {
            SrcFileName ++;
        }
        return (_mbschr (SrcFileName, '\\'));
    } else {
        return (_mbschr (SrcFileName, '\\'));
    }
}

BOOL
pGetLongFileNameWorkerA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuf
    )
{
    PSTR beginSegPtr;
    PSTR endSegPtr;
    WIN32_FIND_DATAA findData;
    CHAR savedChar;

    beginSegPtr = pGetFirstSegA (SrcFileName);

    if (!beginSegPtr) {
        GbAppendStringA (GrowBuf, SrcFileName);
        return TRUE;
    }
    beginSegPtr = _mbsinc (beginSegPtr);

    GbAppendStringABA (GrowBuf, SrcFileName, beginSegPtr);

    while (beginSegPtr) {
        endSegPtr = _mbschr (beginSegPtr, '\\');
        if (!endSegPtr) {
            endSegPtr = GetEndOfStringA (beginSegPtr);
            MYASSERT (endSegPtr);
        }
        savedChar = *endSegPtr;
        *endSegPtr = 0;
        if (DoesFileExistExA (SrcFileName, &findData)) {
            GbAppendStringA (GrowBuf, findData.cFileName);
        } else {
            GbAppendStringABA (GrowBuf, beginSegPtr, endSegPtr);
        }
        *endSegPtr = savedChar;
        if (savedChar) {
            beginSegPtr = _mbsinc (endSegPtr);
            GbAppendStringABA (GrowBuf, endSegPtr, beginSegPtr);
        } else {
            beginSegPtr = NULL;
        }
    }
    return TRUE;
}

PCSTR
BfGetLongFileNameA (
    IN      PCSTR SrcFileName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PSTR srcFileName;
    PCSTR result = NULL;

    srcFileName = (PSTR)SanitizePathA (SrcFileName);
    if (pGetLongFileNameWorkerA (srcFileName, &growBuf)) {
        result = DuplicatePathStringA (growBuf.Buf, 0);
        GbFree (&growBuf);
    }
    FreePathStringA (srcFileName);
    return result;
}

BOOL
BfGetLongFileNameExA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    )
{
    PSTR srcFileName;
    BOOL result;

    srcFileName = (PSTR)SanitizePathA (SrcFileName);
    result = pGetLongFileNameWorkerA (srcFileName, GrowBuff);
    FreePathStringA (srcFileName);

    return result;
}

PWSTR
pGetFirstSegW (
    IN      PCWSTR SrcFileName
    )
{
    if (SrcFileName [0] == L'\\') {
        SrcFileName ++;
        if (SrcFileName [0] == L'\\') {
            SrcFileName ++;
        }
        return (wcschr (SrcFileName, L'\\'));
    } else {
        return (wcschr (SrcFileName, L'\\'));
    }
}

BOOL
pGetLongFileNameWorkerW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuf
    )
{
    PWSTR beginSegPtr;
    PWSTR endSegPtr;
    WIN32_FIND_DATAW findData;
    WCHAR savedChar;

    beginSegPtr = pGetFirstSegW (SrcFileName);

    if (!beginSegPtr) {
        GbAppendStringW (GrowBuf, SrcFileName);
        return TRUE;
    }
    beginSegPtr ++;

    GbAppendStringABW (GrowBuf, SrcFileName, beginSegPtr);

    while (beginSegPtr) {
        endSegPtr = wcschr (beginSegPtr, L'\\');
        if (!endSegPtr) {
            endSegPtr = GetEndOfStringW (beginSegPtr);
            MYASSERT (endSegPtr);
        }
        savedChar = *endSegPtr;
        *endSegPtr = 0;
        if (DoesFileExistExW (SrcFileName, &findData)) {
            GbAppendStringW (GrowBuf, findData.cFileName);
        } else {
            GbAppendStringABW (GrowBuf, beginSegPtr, endSegPtr);
        }
        *endSegPtr = savedChar;
        if (savedChar) {
            beginSegPtr = endSegPtr + 1;
            GbAppendStringABW (GrowBuf, endSegPtr, beginSegPtr);
        } else {
            beginSegPtr = NULL;
        }
    }
    return TRUE;
}

PCWSTR
BfGetLongFileNameW (
    IN      PCWSTR SrcFileName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PWSTR srcFileName;
    PCWSTR result = NULL;

    srcFileName = (PWSTR)SanitizePathW (SrcFileName);
    if (pGetLongFileNameWorkerW (srcFileName, &growBuf)) {
        result = DuplicatePathStringW ((PCWSTR)growBuf.Buf, 0);
        GbFree (&growBuf);
    }
    FreePathStringW (srcFileName);
    return result;
}

BOOL
BfGetLongFileNameExW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    )
{
    PWSTR srcFileName;
    BOOL result;

    srcFileName = (PWSTR)SanitizePathW (SrcFileName);
    result = pGetLongFileNameWorkerW (srcFileName, GrowBuff);
    FreePathStringW (srcFileName);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\blobs.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    blobs.c

Abstract:

    Implements a set of APIs to manage BLOBS and arrays of BLOBS.

Author:

    Ovidiu Temereanca (ovidiut)   24-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_BLOBS       "Blobs"

//
// Strings
//

// None

//
// Constants
//

#define BLOB_SIGNATURE              0x79563442
#define BLOB_GROWDATASIZE_DEFAULT   1024
#define BLOBS_GROWCOUNT_DEFAULT     64
#define BLOBS_SIGNATURE             0x12567841

//
// Macros
//

// None

//
// Types
//

typedef struct {
    DWORD       BlobSignature;
    DWORD       DataSize;
    DWORD       Flags;
} BLOBHDR, *PBLOBHDR;

typedef struct {
    DWORD       BlobsArraySignature;
    DWORD       BlobsCount;
} BLOBSARRAYHDR, *PBLOBSARRAYHDR;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


#ifdef DEBUG

#define ASSERT_VALID_BLOB(b)            MYASSERT (pIsValidBlob (b))
#define ASSERT_VALID_BLOBS_ARRAY(a)     MYASSERT (pIsValidBlobsArray (a))

BOOL
pIsValidBlob (
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    pIsValidBlob checks if the passed-in blob points to a valid OURBLOB blob structure

Arguments:

    Blob - Specifies a pointer to the blob to be checked

Return Value:

    TRUE if the check was successful.
    FALSE if not.

--*/

{
    BOOL b = TRUE;

    if (!Blob) {
        return FALSE;
    }

    __try {
        b = !Blob->Data && !Blob->End && !Blob->Index && !Blob->AllocSize ||
            Blob->Data && Blob->AllocSize && Blob->End <= Blob->AllocSize && Blob->Index <= Blob->AllocSize;
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

BOOL
pIsValidBlobsArray (
    IN      PBLOBS BlobsArray
    )

/*++

Routine Description:

    pIsValidBlobsArray checks if the passed-in bloba array points to a valid BLOBS array structure

Arguments:

    BlobsArray - Specifies a pointer to the blobs array to be checked

Return Value:

    TRUE if the check was successful.
    FALSE if not.

--*/

{
    BOOL b = TRUE;

    if (!BlobsArray) {
        return FALSE;
    }

    __try {
        b = !BlobsArray->Blobs && !BlobsArray->BlobsCount && !BlobsArray->BlobsAllocated ||
            BlobsArray->Signature == BLOBS_SIGNATURE &&
            BlobsArray->Blobs &&
            BlobsArray->BlobsAllocated &&
            BlobsArray->BlobsGrowCount &&
            BlobsArray->BlobsCount <= BlobsArray->BlobsAllocated;
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#else

#define ASSERT_VALID_BLOB(b)
#define ASSERT_VALID_BLOBS_ARRAY(a)

#endif


PVOID
pBlobAllocateMemory (
    IN      DWORD Size
    )

/*++

Routine Description:

    pBlobAllocateMemory is a private function that allocates space from the process heap

Arguments:

    Size - Specifies the size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if not enough memory

--*/

{
    MYASSERT (Size);
    return HeapAlloc (g_hHeap, 0, Size);
}


static
PVOID
pReAllocateMemory (
    IN      PVOID OldBuffer,
    IN      DWORD NewSize
    )

/*++

Routine Description:

    pReAllocateMemory is a private function that re-allocates space from the process heap

Arguments:

    OldBuffer - Specifies the buffer to be re-allocated
    Size - Specifies the size (in bytes) to allocate.

Return Value:

    A pointer to the successfully re-allocated memory or NULL if not enough memory

--*/

{
    MYASSERT (OldBuffer);
    MYASSERT (NewSize);
    return HeapReAlloc (g_hHeap, 0, OldBuffer, NewSize);
}


VOID
pBlobFreeMemory (
    IN      PVOID Buffer
    )

/*++

Routine Description:

    pBlobFreeMemory is a private function that frees space allocated from the process heap

Arguments:

    Buffer - Specifies a pointer to buffer to free.

Return Value:

    none

--*/

{
    MYASSERT (Buffer);
    HeapFree (g_hHeap, 0, Buffer);
}


POURBLOB
BlobCreate (
    VOID
    )
{
    POURBLOB newBlob;

    newBlob = pBlobAllocateMemory (DWSIZEOF (OURBLOB));
    if (newBlob) {
        ZeroMemory (newBlob, DWSIZEOF (OURBLOB));
    }
    return newBlob;
}


POURBLOB
BlobDuplicate (
    IN      POURBLOB SourceBlob
    )

/*++

Routine Description:

    BlobDuplicate duplicates the data in the source blob, so the resulting blob will
    have an identical copy of data

Arguments:

    SourceBlob - Specifies the blob source of data

Return Value:

    Pointer to the new blob if duplicate was successful; NULL if not enough memory

--*/

{
    POURBLOB newBlob;
    DWORD dataSize;

    newBlob = BlobCreate ();
    if (newBlob && SourceBlob->Data) {
        dataSize = BlobGetDataSize (SourceBlob);
        newBlob->Data = pBlobAllocateMemory (dataSize);
        if (!newBlob->Data) {
            BlobDestroy (newBlob);
            return NULL;
        }
        newBlob->AllocSize = dataSize;
        newBlob->End = dataSize;
        CopyMemory (newBlob->Data, SourceBlob->Data, dataSize);
        newBlob->Flags = SourceBlob->Flags;
    }
    return newBlob;
}


VOID
BlobClear (
    IN OUT  POURBLOB Blob
    )

/*++

Routine Description:

    BlobClear clears the specified blob (frees its associated data)

Arguments:

    Blob - Specifies the blob to clear

Return Value:

    none

--*/

{
    if (Blob && Blob->Data) {
        pBlobFreeMemory (Blob->Data);
        ZeroMemory (Blob, DWSIZEOF (OURBLOB));
    }
}


VOID
BlobDestroy (
    IN OUT  POURBLOB Blob
    )

/*++

Routine Description:

    BlobDestroy destroys the specified blob (frees its associated data and the blob itself)

Arguments:

    Blob - Specifies the blob to destroy

Return Value:

    none

--*/

{
    if (Blob) {
        BlobClear (Blob);
        pBlobFreeMemory (Blob);
    }
}


BOOL
BlobSetIndex (
    IN OUT  POURBLOB Blob,
    IN      DWORD Index
    )

/*++

Routine Description:

    BlobSetIndex sets the current read/write pointer

Arguments:

    Blob - Specifies the blob
    Index - Specifies the new index value

Return Value:

    TRUE if the index move was successful

--*/

{
    ASSERT_VALID_BLOB (Blob);

    if (Index > Blob->End) {
        DEBUGMSG ((DBG_BLOBS, "BlobSetIndex: invalid Index specified (%lu)", Index));
        MYASSERT (FALSE);   //lint !e506
        return FALSE;
    }

    Blob->Index = Index;
    return TRUE;
}


DWORD
BlobGetRecordedDataType (
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    BlobGetRecordedDataType returns the data type recorded at current read position

Arguments:

    Blob - Specifies the blob

Return Value:

    The current data type if the blob records data type and the read position is valid;
    BDT_NONE otherwise

--*/

{
    PBYTE p;

    if (BlobRecordsDataType (Blob)) {
        p = BlobGetPointer (Blob);
        if (p) {
            return *(DWORD*)p;
        }
    }
    return BDT_NONE;
}


BOOL
BlobWriteEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD DataType,         OPTIONAL
    IN      BOOL RecordDataSize,
    IN      DWORD DataSize,
    IN      PCVOID Data
    )

/*++

Routine Description:

    BlobWriteEx writes data at the current index position, growing the blob if necessary
    and adjusting it's size.

Arguments:

    Blob - Specifies the blob
    DataType - Specifies the type of data to be stored; can be zero only if the blob
               doesn't record data types
    RecordDataSize - Specifies TRUE if this size has to be recorded in the blob
    DataSize - Specifies the size, in bytes, of the data to be stored
    Data - Specifies the data

Return Value:

    TRUE if write was successful; FALSE if not enough memory

--*/

{
    PBYTE p;
    DWORD totalDataSize;
    DWORD growTo;
    DWORD d;

    ASSERT_VALID_BLOB (Blob);
    MYASSERT (DataSize);

    MYASSERT (DataType || !BlobRecordsDataType (Blob));
    if (!DataType && BlobRecordsDataType (Blob)) {
        return FALSE;
    }

    if (!Blob->GrowSize) {
        Blob->GrowSize = BLOB_GROWDATASIZE_DEFAULT;
    }

    totalDataSize = Blob->Index + DataSize;
    if (BlobRecordsDataType (Blob)) {
        //
        // add the size of a DWORD
        //
        totalDataSize += DWSIZEOF (DWORD);
    }
    if (BlobRecordsDataSize (Blob) || RecordDataSize) {
        //
        // add the size of a DWORD
        //
        totalDataSize += DWSIZEOF (DWORD);
    }
    if (totalDataSize > Blob->AllocSize) {
        d = totalDataSize + Blob->GrowSize - 1;
        growTo = d - d % Blob->GrowSize;
    } else {
        growTo = 0;
    }

    if (!Blob->Data) {
        Blob->Data = (PBYTE) pBlobAllocateMemory (growTo);
        if (!Blob->Data) {
            DEBUGMSG ((DBG_ERROR, "BlobWriteEx: pBlobAllocateMemory (%lu) failed", growTo));
            return FALSE;
        }

        Blob->AllocSize = growTo;
    } else if (growTo) {
        p = pReAllocateMemory (Blob->Data, growTo);
        if (!p) {
            DEBUGMSG ((DBG_ERROR, "BlobWriteEx: pReAllocateMemory (%lu) failed", growTo));
            return FALSE;
        }

        Blob->AllocSize = growTo;
        Blob->Data = p;
    }

    p = BlobGetPointer (Blob);

    if (BlobRecordsDataType (Blob)) {
        *(PDWORD)p = DataType;
        p += DWSIZEOF (DWORD);
        Blob->Index += DWSIZEOF (DWORD);
    }
    if (BlobRecordsDataSize (Blob) || RecordDataSize) {
        *(PDWORD)p = DataSize;
        p += DWSIZEOF (DWORD);
        Blob->Index += DWSIZEOF (DWORD);
    }

    CopyMemory (p, Data, DataSize);
    Blob->Index += DataSize;

    //
    // adjust EOF
    //
    if (Blob->Index > Blob->End) {
        Blob->End = Blob->Index;
    }

    return TRUE;
}


PBYTE
BlobReadEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD ExpectedDataType,     OPTIONAL
    IN      DWORD ExpectedDataSize,     OPTIONAL
    IN      BOOL RecordedDataSize,
    OUT     PDWORD ActualDataSize,      OPTIONAL
    OUT     PVOID Data,                 OPTIONAL
    IN      PMHANDLE Pool               OPTIONAL
    )

/*++

Routine Description:

    BlobReadEx reads data from the specified blob, at the current index position

Arguments:

    Blob - Specifies the blob to read from
    ExpectedDataType - Specifies the expected data type; optional
    ExpectedDataSize - Specifies the expected data size; optional
    RecordedDataSize - Specifies TRUE if the data size was recorded in the blob
    ActualDataSize - Receives the actual data size; optional
    Data - Receives the actual data; optional; if NULL, a buffer will be allocated
    Pool - Specifies the pool to use for memory allocations; optional;
           if NULL, the process heap will be used

Return Value:

    A pointer to the buffer containing the data; NULL if an error occured
    or some data conditions don't match

--*/

{
    DWORD initialIndex;
    PBYTE readPtr;
    DWORD actualDataType;
    DWORD actualDataSize = 0;

    ASSERT_VALID_BLOB (Blob);

    readPtr = BlobGetPointer (Blob);
    if (!readPtr) {
        return NULL;
    }

    //
    // data size must be available some way
    //
    MYASSERT (BlobRecordsDataSize (Blob) || RecordedDataSize || ExpectedDataSize);

    initialIndex = BlobGetIndex (Blob);

    if (BlobRecordsDataType (Blob)) {

        if (readPtr + DWSIZEOF (DWORD) > BlobGetEOF (Blob)) {
            return NULL;
        }
        //
        // check actual data type
        //
        actualDataType = *(DWORD*)readPtr;

        if (ExpectedDataType && ExpectedDataType != actualDataType) {

            DEBUGMSG ((
                DBG_ERROR,
                "BlobReadEx: Actual data type (%lu) different than expected data type (%lu)",
                actualDataType,
                ExpectedDataType
                ));

            return NULL;
        }

        Blob->Index += DWSIZEOF (DWORD);
        readPtr += DWSIZEOF (DWORD);
    }

    if (BlobRecordsDataSize (Blob) || RecordedDataSize) {

        if (readPtr + DWSIZEOF (DWORD) > BlobGetEOF (Blob)) {
            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }
        //
        // read actual data size
        //
        actualDataSize = *(DWORD*)readPtr;

        if (ExpectedDataSize && ExpectedDataSize != actualDataSize) {

            DEBUGMSG ((
                DBG_ERROR,
                "BlobReadEx: Actual data size (%lu) different than expected data size (%lu)",
                actualDataSize,
                ExpectedDataSize
                ));

            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }

        Blob->Index += DWSIZEOF (DWORD);
        readPtr += DWSIZEOF (DWORD);

    } else {
        actualDataSize = ExpectedDataSize;
    }

    if (!actualDataSize) {
        BlobSetIndex (Blob, initialIndex);
        return NULL;
    }

    if (ActualDataSize) {
        *ActualDataSize = actualDataSize;
    }

    //
    // don't read over end of file
    //
    if (readPtr + actualDataSize > BlobGetEOF (Blob)) {
        //
        // corrupt blob; undo anyway
        //
        MYASSERT (FALSE);   //lint !e506
        BlobSetIndex (Blob, initialIndex);
        return NULL;
    }

    if (!Data) {

        if (Pool) {
            Data = PmGetMemory (Pool, actualDataSize);
        } else {
            Data = pBlobAllocateMemory (actualDataSize);
        }

        if (!Data) {
            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }
    }

    CopyMemory (Data, readPtr, actualDataSize);

    Blob->Index += actualDataSize;

    return Data;
}


BOOL
BlobWriteDword (
    IN OUT  POURBLOB Blob,
    IN      DWORD Data
    )

/*++

Routine Description:

    BlobWriteDword writes a DWORD at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the DWORD

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_DWORD, FALSE, DWSIZEOF (DWORD), &Data);
}


BOOL
BlobReadDword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORD Data
    )

/*++

Routine Description:

    BlobReadDword reads a DWORD from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives the DWORD

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    return BlobReadEx (Blob, BDT_DWORD, DWSIZEOF (DWORD), FALSE, NULL, Data, NULL) != NULL;
}


BOOL
BlobWriteQword (
    IN OUT  POURBLOB Blob,
    IN      DWORDLONG Data
    )

/*++

Routine Description:

    BlobWriteQword writes a DWORDLONG at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the DWORDLONG

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_QWORD, FALSE, DWSIZEOF (DWORDLONG), &Data);
}


BOOL
BlobReadQword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORDLONG Data
    )

/*++

Routine Description:

    BlobReadQword reads a DWORDLONG from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives the DWORDLONG

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    return BlobReadEx (Blob, BDT_QWORD, DWSIZEOF (DWORDLONG), FALSE, NULL, Data, NULL) != NULL;
}


/*++

Routine Description:

    BlobWriteString writes a string at the current writing position in the specified blob;
    the string is stored in UNICODE inside the blob if BF_UNICODESTRINGS is set

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the string

Return Value:

    TRUE if data was successfully stored in the blob

--*/

BOOL
BlobWriteStringA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    )
{
    PCWSTR unicodeString;
    BOOL b;

    if (BlobRecordsUnicodeStrings (Blob)) {
        unicodeString = ConvertAtoW (Data);
        b = BlobWriteStringW (Blob, unicodeString);
        FreeConvertedStr (unicodeString);
        return b;
    }
    return BlobWriteEx (Blob, BDT_SZA, TRUE, SizeOfStringA (Data), Data);
}


BOOL
BlobWriteStringW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    )
{
    return BlobWriteEx (Blob, BDT_SZW, TRUE, SizeOfStringW (Data), Data);
}


/*++

Routine Description:

    BlobReadString reads a string from the current reading position in the specified blob;
    the string may be converted to the ANSI/UNICODE format.
    If the blob doesn't store data types, this is assumed to be BDT_SZA for the ANSI version
    and BDT_SZW for the UNICODE version of this function

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated string
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

BOOL
BlobReadStringA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PSTR ansiString;
    PCWSTR unicodeString;
    DWORD dataType;
    DWORD index;
    DWORD length = 0;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    ansiString = NULL;
    unicodeString = NULL;

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_SZA) {

            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_SZW) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, &length, NULL, Pool);

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadStringA: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        if (BlobRecordsUnicodeStrings (Blob)) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, &length, NULL, Pool);

        } else {
            //
            // assume an ANSI string is stored there
            //
            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, NULL, NULL, Pool);
        }
    }

    if (!ansiString) {

        if (!unicodeString) {
            return FALSE;
        }

        if (Pool) {
            ansiString = PmGetMemory (Pool, length);
        } else {
            ansiString = pBlobAllocateMemory (length);
        }

        if (ansiString) {
            DirectUnicodeToDbcsN (ansiString, unicodeString, length);
        }

        if (Pool) {
            PmReleaseMemory (Pool, (PVOID)unicodeString);
        } else {
            pBlobFreeMemory ((PVOID)unicodeString);
        }

        if (!ansiString) {
            //
            // recover prev state
            //
            BlobSetIndex (Blob, index);

            return FALSE;
        }
    }

    *Data = ansiString;
    return TRUE;
}

BOOL
BlobReadStringW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PWSTR unicodeString;
    PCSTR ansiString;
    DWORD dataType;
    DWORD index;
    DWORD length;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_SZW) {

            unicodeString = (PWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_SZA) {

            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, &length, NULL, Pool);

            if (!ansiString) {
                return FALSE;
            }

            if (Pool) {
                unicodeString = PmGetMemory (Pool, length * DWSIZEOF (WCHAR));
            } else {
                unicodeString = pBlobAllocateMemory (length * DWSIZEOF (WCHAR));
            }
            if (unicodeString) {
                DirectDbcsToUnicodeN (unicodeString, ansiString, length);
            }

            if (Pool) {
                PmReleaseMemory (Pool, (PVOID)ansiString);
            } else {
                pBlobFreeMemory ((PVOID)ansiString);
            }

            if (!unicodeString) {
                //
                // recover prev state
                //
                BlobSetIndex (Blob, index);
                return FALSE;
            }

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadStringW: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        //
        // assume an UNICODE string is stored there
        //
        unicodeString = (PWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, NULL, NULL, Pool);
    }

    if (!unicodeString) {
        return FALSE;
    }

    *Data = unicodeString;
    return TRUE;
}


/*++

Routine Description:

    BlobWriteMultiSz writes a multisz at the current writing position in the specified blob;
    the multisz is stored in UNICODE inside the blob if BF_UNICODESTRINGS is set

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the multisz

Return Value:

    TRUE if data was successfully stored in the blob

--*/

BOOL
BlobWriteMultiSzA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    )
{
    PWSTR unicodeString;
    BOOL b;
    DWORD stringSize = SizeOfMultiSzA (Data);

    if (BlobRecordsUnicodeStrings (Blob)) {
        unicodeString = AllocTextW (stringSize);
        DirectDbcsToUnicodeN (unicodeString, Data, stringSize);
        b = BlobWriteMultiSzW (Blob, unicodeString);
        FreeTextW (unicodeString);
        return b;
    }

    return BlobWriteEx (Blob, BDT_MULTISZA, TRUE, stringSize, Data);
}

BOOL
BlobWriteMultiSzW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    )
{
    return BlobWriteEx (Blob, BDT_MULTISZW, TRUE, SizeOfMultiSzW (Data), Data);
}



/*++

Routine Description:

    BlobReadMultiSz reads a multisz from the current reading position in the specified blob;
    the string may be converted to the ANSI/UNICODE format.
    If the blob doesn't store data types, this is assumed to be BDT_MULTISZA for the ANSI version
    and BDT_MULTISZW for the UNICODE version of this function

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated multisz
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

BOOL
BlobReadMultiSzA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PSTR ansiString;
    PCWSTR unicodeString;
    DWORD dataType;
    DWORD index;
    DWORD length = 0;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    ansiString = NULL;
    unicodeString = NULL;

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_MULTISZA) {

            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_MULTISZW) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, &length, NULL, Pool);

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadMultiSzA: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        if (BlobRecordsUnicodeStrings (Blob)) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, &length, NULL, Pool);

        } else {
            //
            // assume an ANSI string is stored there
            //
            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, NULL, NULL, Pool);
        }
    }

    if (!ansiString) {
        if (!unicodeString) {
            return FALSE;
        }

        if (Pool) {
            ansiString = PmGetMemory (Pool, length);
        } else {
            ansiString = pBlobAllocateMemory (length);
        }

        if (ansiString) {
            DirectUnicodeToDbcsN (ansiString, unicodeString, length);
        }

        if (Pool) {
            PmReleaseMemory (Pool, (PVOID)unicodeString);
        } else {
            pBlobFreeMemory ((PVOID)unicodeString);
        }

        if (!ansiString) {
            //
            // recover prev state
            //
            BlobSetIndex (Blob, index);
            return FALSE;
        }
    }

    *Data = ansiString;
    return TRUE;
}

BOOL
BlobReadMultiSzW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PWSTR unicodeString;
    PCSTR ansiString;
    DWORD dataType;
    DWORD index;
    DWORD length;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_MULTISZW) {

            unicodeString = (PWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_MULTISZA) {

            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, &length, NULL, Pool);

            if (!ansiString) {
                return FALSE;
            }

            if (Pool) {
                unicodeString = PmGetMemory (Pool, length * DWSIZEOF (WCHAR));
            } else {
                unicodeString = pBlobAllocateMemory (length * DWSIZEOF (WCHAR));
            }

            if (unicodeString) {
                DirectDbcsToUnicodeN (unicodeString, ansiString, length);
            }

            if (Pool) {
                PmReleaseMemory (Pool, (PVOID)ansiString);
            } else {
                pBlobFreeMemory ((PVOID)ansiString);
            }

            if (!unicodeString) {
                //
                // recover prev state
                //
                BlobSetIndex (Blob, index);

                return FALSE;
            }

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadMultiSzW: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        //
        // assume an UNICODE string is stored there
        //
        unicodeString = (PWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, NULL, NULL, Pool);
    }

    if (!unicodeString) {
        return FALSE;
    }

    *Data = unicodeString;
    return TRUE;
}


BOOL
BlobWriteBinaryEx (
    IN OUT  POURBLOB Blob,
    IN      PBYTE Data,
    IN      DWORD Size,
    IN      BOOL RecordDataSize
    )

/*++

Routine Description:

    BlobWriteBinary writes a buffer at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the source buffer
    Size - Specifies the size of the buffer
    RecordDataSize - Specifies TRUE if data size should be recorded, too

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_BINARY, RecordDataSize, Size, Data);
}


BOOL
BlobReadBinary (
    IN OUT  POURBLOB Blob,
    OUT     PBYTE* Data,
    OUT     PDWORD Size,
    IN      PMHANDLE Pool       OPTIONAL
    )

/*++

Routine Description:

    BlobReadBinary reads a buffer from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated buffer
    Size - Receives the size of the buffer
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    *Data = BlobReadEx (Blob, BDT_BINARY, 0, TRUE, Size, NULL, Pool);
    return *Data != NULL;
}


BOOL
BlobWriteToFile (
    IN      POURBLOB Blob,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobWriteToFile writes the specified blob to the given file

Arguments:

    Blob - Specifies the blob to save
    File - Specifies the handle of the file to write the blob to

Return Value:

    TRUE if blob was successfully written to the file

--*/

{
    BLOBHDR header;
    DWORD d;

    if (!Blob->End) {
        DEBUGMSG ((DBG_BLOBS, "BlobWriteToFile: Did not write empty blob to file"));
        return FALSE;
    }

    //
    // save blob's Flags and End position
    //
    header.BlobSignature = BLOB_SIGNATURE;
    header.DataSize = Blob->End;
    header.Flags = Blob->Flags;

    if (!WriteFile (File, &header, DWSIZEOF (BLOBHDR), &d, NULL) || d != DWSIZEOF (BLOBHDR)) {
        DEBUGMSG ((DBG_ERROR, "BlobWriteToFile: Error writing blob header!"));
        return FALSE;
    }
    if (!WriteFile (File, Blob->Data, Blob->End, &d, NULL) || d != Blob->End) {
        DEBUGMSG ((DBG_ERROR, "BlobWriteToFile: Error writing blob data!"));
        return FALSE;
    }
    return TRUE;
}


BOOL
BlobReadFromFile (
    OUT     POURBLOB Blob,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobReadFromFile reads data from the given file in the specified blob

Arguments:

    Blob - Receives the data
    File - Specifies the handle of the file to read from

Return Value:

    TRUE if blob was successfully read from the file

--*/

{
    BLOBHDR header;
    DWORD d;

    //
    // read blob's Flags and End position
    //
    if (!ReadFile (File, &header, DWSIZEOF (BLOBHDR), &d, NULL) || d != DWSIZEOF (BLOBHDR)) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Error reading blob header!"));
        return FALSE;
    }

    if (header.BlobSignature != BLOB_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Not a valid blob signature!"));
        return FALSE;
    }

    Blob->Data = pBlobAllocateMemory (header.DataSize);
    if (!Blob->Data) {
        return FALSE;
    }

    if (!ReadFile (File, Blob->Data, header.DataSize, &d, NULL) || d != header.DataSize) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Error reading blob data!"));
        pBlobFreeMemory (Blob->Data);
        Blob->Data = NULL;
        return FALSE;
    }

    Blob->AllocSize = header.DataSize;
    Blob->End = header.DataSize;
    Blob->Flags = header.Flags;
    Blob->Index = 0;
    return TRUE;
}


BOOL
BlobsAdd (
    IN OUT  PBLOBS BlobsArray,
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    BlobsAdd adds the specified Blob to a blobs array

Arguments:

    BlobsArray - Specifies the array to add to
    Blob - Specifies the blob to add

Return Value:

    TRUE if the new blob pointer was added successfully

--*/

{
    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    if (!BlobsArray->BlobsGrowCount) {
        BlobsArray->BlobsGrowCount = BLOBS_GROWCOUNT_DEFAULT;
    }

    if (!BlobsArray->Blobs) {

        BlobsArray->Blobs = (POURBLOB*)pBlobAllocateMemory (
                                        BlobsArray->BlobsGrowCount * DWSIZEOF (POURBLOB)
                                        );
        if (!BlobsArray->Blobs) {
            DEBUGMSG ((DBG_ERROR, "BlobsAddE: Initial alloc failed"));
            return FALSE;
        }
        BlobsArray->Signature = BLOBS_SIGNATURE;
        BlobsArray->BlobsAllocated = BlobsArray->BlobsGrowCount;
        BlobsArray->BlobsCount = 0;

    } else if (BlobsArray->BlobsCount == BlobsArray->BlobsAllocated) {

        BlobsArray->BlobsAllocated += BlobsArray->BlobsGrowCount;
        BlobsArray->Blobs = (POURBLOB*)pReAllocateMemory (
                                        BlobsArray->Blobs,
                                        BlobsArray->BlobsAllocated * DWSIZEOF (POURBLOB)
                                        );
        if (!BlobsArray->Blobs) {
            BlobsArray->BlobsAllocated -= BlobsArray->BlobsGrowCount;
            DEBUGMSG ((DBG_ERROR, "BlobsAdd: Realloc failed"));
            return FALSE;
        }
    }

    *(BlobsArray->Blobs + BlobsArray->BlobsCount) = Blob;
    BlobsArray->BlobsCount++;

    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);
    return TRUE;
}


VOID
BlobsFree (
    IN OUT  PBLOBS BlobsArray,
    IN      BOOL DestroyBlobs
    )

/*++

Routine Description:

    BlobsFree destroys the array and optionally destroys all blobs in it

Arguments:

    BlobsArray - Specifies the array to delete
    DestroyBlobs - Specifies TRUE if the component blobs are to be deleted, too

Return Value:

    none

--*/

{
    BLOB_ENUM e;

    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    if (DestroyBlobs) {
        if (EnumFirstBlob (&e, BlobsArray)) {
            do {
                BlobDestroy (e.CurrentBlob);
            } while (EnumNextBlob (&e));
        }
    }

    pBlobFreeMemory (BlobsArray->Blobs);
    ZeroMemory (BlobsArray, DWSIZEOF (BLOBS));
}


BOOL
EnumFirstBlob (
    OUT     PBLOB_ENUM BlobEnum,
    IN      PBLOBS BlobsArray
    )

/*++

Routine Description:

    EnumFirstBlob enumerates the first blob in the given array

Arguments:

    BlobEnum - Receives enum info
    BlobsArray - Specifies the array to enum from

Return Value:

    TRUE if a first blob was found; FALSE if array is empty

--*/

{
    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    BlobEnum->Index = 0;
    BlobEnum->Array = BlobsArray;
    return EnumNextBlob (BlobEnum);
}


BOOL
EnumNextBlob (
    IN OUT  PBLOB_ENUM BlobEnum
    )

/*++

Routine Description:

    EnumNextBlob enumerates the next blob in the given array

Arguments:

    BlobEnum - Specifies/receives enum info

Return Value:

    TRUE if a next blob was found; FALSE if no more blobs

--*/

{
    if (BlobEnum->Index >= BlobEnum->Array->BlobsCount) {
        return FALSE;
    }

    BlobEnum->CurrentBlob = *(BlobEnum->Array->Blobs + BlobEnum->Index);
    BlobEnum->Index++;
    return TRUE;
}


BOOL
BlobsWriteToFile (
    IN      PBLOBS BlobsArray,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobsWriteToFile writes the specified blobs array to the given file

Arguments:

    BlobsArray - Specifies the blobs array to save
    File - Specifies the handle of the file to write the array to

Return Value:

    TRUE if array was successfully written to the file

--*/

{
    BLOBSARRAYHDR header;
    DWORD d;
    POURBLOB* blob;

    if (!BlobsArray->BlobsCount) {
        DEBUGMSG ((DBG_BLOBS, "BlobsWriteToFile: Did not write empty blobs array to file"));
        return FALSE;
    }

    //
    // save blobs count
    //
    header.BlobsArraySignature = BLOBS_SIGNATURE;
    header.BlobsCount = BlobsArray->BlobsCount;

    if (!WriteFile (File, &header, DWSIZEOF (BLOBSARRAYHDR), &d, NULL) ||
        d != DWSIZEOF (BLOBSARRAYHDR)
        ) {
        DEBUGMSG ((DBG_ERROR, "BlobsWriteToFile: Error writing blobs array header!"));
        return FALSE;
    }
    for (blob = BlobsArray->Blobs; blob < BlobsArray->Blobs + BlobsArray->BlobsCount; blob++) {
        if (!BlobWriteToFile (*blob, File)) {
            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsWriteToFile: Error writing blob # %lu to file",
                blob - BlobsArray->Blobs
                ));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
BlobsReadFromFile (
    OUT     PBLOBS BlobsArray,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobsReadFromFile reads data from the given file in the specified blobs array

Arguments:

    BlobsArray - Receives the data
    File - Specifies the handle of the file to read from

Return Value:

    TRUE if array was successfully read from the file

--*/

{
    BLOBSARRAYHDR header;
    DWORD d;
    UINT u;
    POURBLOB blob;

    //
    // read blobs count
    //
    if (!ReadFile (File, &header, DWSIZEOF (BLOBSARRAYHDR), &d, NULL) ||
        d != DWSIZEOF (BLOBSARRAYHDR)
        ) {
        DEBUGMSG ((DBG_ERROR, "BlobsReadFromFile: Error reading blobs array header!"));
        return FALSE;
    }

    if (header.BlobsArraySignature != BLOBS_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "BlobsReadFromFile: Not a valid blobs array signature!"));
        return FALSE;
    }

    BlobsArray->Blobs = (POURBLOB*)pBlobAllocateMemory (header.BlobsCount * DWSIZEOF (POURBLOB*));
    if (!BlobsArray->Blobs) {
        return FALSE;
    }

    ZeroMemory (BlobsArray->Blobs, header.BlobsCount * DWSIZEOF (POURBLOB));

    BlobsArray->Signature = BLOBS_SIGNATURE;
    BlobsArray->BlobsAllocated = header.BlobsCount;
    BlobsArray->BlobsCount = 0;
    BlobsArray->BlobsGrowCount = BLOBS_GROWCOUNT_DEFAULT;

    for (u = 0; u < header.BlobsCount; u++) {

        blob = BlobCreate ();
        if (!blob) {
            return FALSE;
        }

        if (!BlobReadFromFile (blob, File)) {

            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsReadFromFile: Error reading blob # %lu from file",
                u
                ));

            BlobsFree (BlobsArray, TRUE);
            return FALSE;
        }

        if (!BlobsAdd (BlobsArray, blob)) {
            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsReadFromFile: Error adding blob # %lu to array",
                u
                ));

            BlobsFree (BlobsArray, TRUE);
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\exclist.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    exclist.c

Abstract:

    Implements a set of APIs to manage exclusion lists of objects
    of various well-known types.

Author:

    Ovidiu Temereanca (ovidiut)   23-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_EXCLIST         "ExcList"

//
// Strings
//

#define S_EXCLUSIONLIST     "ExcList"

//
// Constants
//

// None

//
// Macros
//

#define pAllocateMemory(Size)   PmGetMemory (g_ElPool,Size)

#define pFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_ElPool, (PVOID)Buffer)


//
// Types
//

typedef struct {
    EL_TYPE TypeId;
    PCSTR   TypeName;
    BOOL    Compound;
} EXCLISTPROPS, *PEXCLISTPROPS;


//
// Globals
//

PMHANDLE    g_ElPool;
GROWLIST*   g_ElTypeLists;

//
// Macro expansion list
//

// Defined in exclist.h

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

#define DEFMAC(TypeId,TypeName,Compound)     TypeId, TypeName, Compound,

EXCLISTPROPS g_ExcListProps [] = {
    EXCLUSIONLIST_TYPES     /* , */
    ELT_UNKNOWN, NULL, FALSE
};

#undef DEFMAC


//
// Code
//


BOOL
ElInitialize (
    VOID
    )

/*++

Routine Description:

    ElInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    MYASSERT (!g_ElPool);
    g_ElPool = PmCreateNamedPool (S_EXCLUSIONLIST);
    if (!g_ElPool) {
        return FALSE;
    }

    MYASSERT (!g_ElTypeLists);
    g_ElTypeLists = pAllocateMemory (ELT_UNKNOWN * DWSIZEOF (GROWLIST));
    MYASSERT (g_ElTypeLists);
    ZeroMemory (g_ElTypeLists, ELT_UNKNOWN * DWSIZEOF (GROWLIST));

    return TRUE;
}


VOID
ElTerminate (
    VOID
    )

/*++

Routine Description:

    ElTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    UINT u;

    //
    // did you forget to call ElRemoveAllA/W ?
    //
    for (u = 0; u < ELT_UNKNOWN; u++) {
        MYASSERT (g_ElTypeLists[u].ListArray.Buf == NULL && g_ElTypeLists[u].ListData == NULL);
    }

    if (g_ElTypeLists) {
        pFreeMemory (g_ElTypeLists);
        g_ElTypeLists = NULL;
    }

    if (g_ElPool) {
        PmDestroyPool (g_ElPool);
        g_ElPool = NULL;
    }
}


/*++

Routine Description:

    ElGetTypeId returns the TypeId of a type given by name

Arguments:

    TypeName - Specifies the name

Return Value:

    One of EL_TYPE enumeration values

--*/

EL_TYPE
ElGetTypeId (
    IN      PCSTR TypeName
    )
{
    UINT u;

    if (TypeName) {
        for (u = 0; g_ExcListProps[u].TypeName; u++) {
            if (StringIMatchA (g_ExcListProps[u].TypeName, TypeName)) {
                return g_ExcListProps[u].TypeId;
            }
        }
    }

    return ELT_UNKNOWN;
}


/*++

Routine Description:

    ElGetTypeName returns the type name of a type given by TypeId

Arguments:

    TypeId - Specifies the ID

Return Value:

    A pointer to one of the known type names or NULL if TypeId is unknown

--*/

PCSTR
ElGetTypeName (
    IN      EL_TYPE TypeId
    )
{
    MYASSERT (TypeId < ELT_UNKNOWN);
    if (TypeId >= ELT_UNKNOWN) {
        return NULL;
    }
    return g_ExcListProps[TypeId].TypeName;
}


/*++

Routine Description:

    ElAdd adds the given object of the given type to the exclusion list. The object
    is first parsed so that the decision if a given string matches this pattern is faster.

Arguments:

    ObjectType - Specifies the object type
    ObjectName - Specifies the object pattern string

Return Value:

    TRUE if the string pattern was successfully parsed and added to the list

--*/

BOOL
ElAddA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR ObjectName
    )
{
    PPARSEDPATTERNA pp1;
    POBSPARSEDPATTERNA pp2;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (ObjectName);

    //
    // add each object in its own type list
    //
    if (g_ExcListProps[ObjectType].Compound) {
        pp2 = ObsCreateParsedPatternExA (ObjectName, ObjectType == ELT_PATH);
        if (!pp2) {
            DEBUGMSGA ((
                DBG_EXCLIST,
                "ElAddA: Bad ObjectName: %s (type %s)",
                ObjectName,
                ElGetTypeName (ObjectType)
                ));
            return FALSE;
        }

        //
        // add the pointer to the list
        //
        GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp2, DWSIZEOF (pp2));
    } else {
        pp1 = CreateParsedPatternA (ObjectName);
        if (!pp1) {
            DEBUGMSGA ((
                DBG_EXCLIST,
                "ElAddA: Bad ObjectName: %s (type %s)",
                ObjectName,
                ElGetTypeName (ObjectType)
                ));
            return FALSE;
        }

        //
        // add the pointer to the list
        //
        GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp1, DWSIZEOF (pp1));
    }

    DEBUGMSGA ((
        DBG_EXCLIST,
        "ElAddA: Added excluded %s as type %s",
        ObjectName,
        ElGetTypeName (ObjectType)
        ));
    return TRUE;
}


BOOL
ElAddW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR ObjectName
    )
{
    PPARSEDPATTERNW pp1;
    POBSPARSEDPATTERNW pp2;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (ObjectName);

    //
    // add each object in its own type list
    //
    if (g_ExcListProps[ObjectType].Compound) {
        pp2 = ObsCreateParsedPatternExW (ObjectName, ObjectType == ELT_PATH);
        if (!pp2) {
            DEBUGMSGW ((
                DBG_EXCLIST,
                "ElAddW: Bad ObjectName: %s (type %hs)",
                ObjectName,
                ElGetTypeName (ObjectType)
                ));
            return FALSE;
        }

        //
        // add the pointer to the list
        //
        GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp2, DWSIZEOF (pp2));
    } else {
        pp1 = CreateParsedPatternW (ObjectName);
        if (!pp1) {
            DEBUGMSGW ((
                DBG_EXCLIST,
                "ElAddW: Bad ObjectName: %s (type %hs)",
                ObjectName,
                ElGetTypeName (ObjectType)
                ));
            return FALSE;
        }

        //
        // add the pointer to the list
        //
        GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp1, DWSIZEOF (pp1));
    }

    DEBUGMSGW ((
        DBG_EXCLIST,
        "ElAddW: Added excluded %s as type %hs",
        ObjectName,
        ElGetTypeName (ObjectType)
        ));
    return TRUE;
}


/*++

Routine Description:

    ElRemoveAll removes all object patterns from the exclusion list.

Arguments:

    none

Return Value:

    none

--*/

VOID
ElRemoveAllA (
    VOID
    )
{
    PGROWLIST gl;
    UINT u;
    UINT i;

    if (g_ElTypeLists) {

        for (u = 0; u < ELT_UNKNOWN; u++) {
            gl = &g_ElTypeLists[u];

            if (g_ExcListProps[u].Compound) {
                for (i = GlGetSize (gl); i > 0; i--) {
                    ObsDestroyParsedPatternA (*(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1));
                    GlDeleteItem (gl, i - 1);
                }
            } else {
                for (i = GlGetSize (gl); i > 0; i--) {
                    DestroyParsedPatternA (*(PPARSEDPATTERNA*) GlGetItem (gl, i - 1));
                    GlDeleteItem (gl, i - 1);
                }
            }

            GlFree (gl);
        }

        ZeroMemory (g_ElTypeLists, ELT_UNKNOWN * DWSIZEOF (GROWLIST));
    }
}

VOID
ElRemoveAllW (
    VOID
    )
{
    PGROWLIST gl;
    UINT u;
    UINT i;

    if (g_ElTypeLists) {

        for (u = 0; u < ELT_UNKNOWN; u++) {
            gl = &g_ElTypeLists[u];
            if (g_ExcListProps[u].Compound) {
                for (i = GlGetSize (gl); i > 0; i--) {
                    ObsDestroyParsedPatternW (*(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1));
                    GlDeleteItem (gl, i - 1);
                }
            } else {
                for (i = GlGetSize (gl); i > 0; i--) {
                    DestroyParsedPatternW (*(PPARSEDPATTERNW*) GlGetItem (gl, i - 1));
                    GlDeleteItem (gl, i - 1);
                }
            }

            GlFree (gl);
        }

        ZeroMemory (g_ElTypeLists, ELT_UNKNOWN * DWSIZEOF (GROWLIST));
    }
}


/*++

Routine Description:

    ElIsExcluded decides if the given object string is excluded (if it matches one of the
    patterns added previously).

Arguments:

    ObjectType - Specifies the object type
    Object - Specifies the object string

Return Value:

    TRUE if the string is excluded

--*/

BOOL
ElIsExcludedA (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Object
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNA pp;
    UINT i;
    PSTR node;
    PSTR leaf;
    BOOL b = FALSE;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Object);
    if (!Object) {
        return FALSE;
    }

    //
    // lookup each object in its own type list
    //
    gl = &g_ElTypeLists[ObjectType];

    if (g_ExcListProps[ObjectType].Compound) {

        if (!ObsSplitObjectStringExA (Object, &node, &leaf, g_ElPool, FALSE)) {
            DEBUGMSGA ((DBG_EXCLIST, "ElIsExcludedA: invalid Object: \"%s\"", Object));
            return FALSE;
        }
        MYASSERT (node);

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && leaf || pp->LeafPattern && !leaf) {
                continue;
            }
            if (leaf) {
                MYASSERT (pp->LeafPattern);
                if (!TestParsedPatternA (pp->LeafPattern, leaf)) {
                    continue;
                }
            }
            if (!TestParsedPatternA (pp->NodePattern, node)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        pFreeMemory (node);
        pFreeMemory (leaf);

    } else {

        for (i = GlGetSize (gl); i > 0; i--) {
            if (TestParsedPatternA (*(PPARSEDPATTERNA*) GlGetItem (gl, i - 1), Object)) {
                return TRUE;
            }
        }
    }

    return b;
}

BOOL
ElIsExcludedW (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Object
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNW pp;
    UINT i;
    PWSTR node;
    PWSTR leaf;
    BOOL b = FALSE;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Object);
    if (!Object) {
        return FALSE;
    }

    //
    // lookup each object in its own type list
    //
    gl = &g_ElTypeLists[ObjectType];

    if (g_ExcListProps[ObjectType].Compound) {

        if (!ObsSplitObjectStringExW (Object, &node, &leaf, g_ElPool, FALSE)) {
            DEBUGMSGW ((DBG_EXCLIST, "ElIsExcludedW: invalid Object: \"%s\"", Object));
            return FALSE;
        }
        MYASSERT (node);

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && leaf || pp->LeafPattern && !leaf) {
                continue;
            }
            if (leaf) {
                MYASSERT (pp->LeafPattern);
                if (!TestParsedPatternW (pp->LeafPattern, leaf)) {
                    continue;
                }
            }
            if (!TestParsedPatternW (pp->NodePattern, node)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        pFreeMemory (node);
        pFreeMemory (leaf);

    } else {

        for (i = GlGetSize (gl); i > 0; i--) {
            if (TestParsedPatternW (*(PPARSEDPATTERNW*) GlGetItem (gl, i - 1), Object)) {
                return TRUE;
            }
        }
    }

    return b;
}


/*++

Routine Description:

    ElIsExcluded2 decides if the object given by its 2 components is excluded
    (if it matches one of the patterns added previously).

Arguments:

    ObjectType - Specifies the object type
    Node - Specifies the node part of the object
    Leaf - Specifies the leaf part of the object; optional

Return Value:

    TRUE if the string is excluded

--*/

BOOL
ElIsExcluded2A (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Node,
    IN      PCSTR Leaf              OPTIONAL
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNA *ppp;
    POBSPARSEDPATTERNA pp;
    UINT i;

    //
    // validate params
    //
    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];

    if (!g_ExcListProps[ObjectType].Compound) {
        DEBUGMSGA ((
            DBG_EXCLIST,
            "ElIsExcluded2A: Invalid ObjectType (%s=%d), must use a type that has a node spec",
            ElGetTypeName (ObjectType),
            (INT)ObjectType
            ));
        return FALSE;
    }

    MYASSERT (Node);
    if (!Node) {
        return FALSE;
    }

    for (i = GlGetSize (gl); i > 0; i--) {

        ppp = (POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);
        MYASSERT (ppp);
        if (!ppp)
	    continue;
        pp = *ppp;

        if (!pp->LeafPattern && Leaf || pp->LeafPattern && !Leaf) {
            continue;
        }
        if (Leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternA (pp->LeafPattern, Leaf)) {
                continue;
            }
        }
        if (!TestParsedPatternA (pp->NodePattern, Node)) {
            continue;
        }
        //
        // the patterns match!
        //
        return TRUE;
    }

    return FALSE;
}

BOOL
ElIsExcluded2W (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Node,
    IN      PCWSTR Leaf             OPTIONAL
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNW *ppp;
    POBSPARSEDPATTERNW pp;
    UINT i;

    //
    // validate params
    //
    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];

    if (!g_ExcListProps[ObjectType].Compound) {
        DEBUGMSGW ((
            DBG_EXCLIST,
            "ElIsExcluded2W: Invalid ObjectType (%hs=%d), must use a type that has a node spec",
            ElGetTypeName (ObjectType),
            (INT)ObjectType
            ));
        return FALSE;
    }

    MYASSERT (Node);
    if (!Node) {
        return FALSE;
    }

    for (i = GlGetSize (gl); i > 0; i--) {

        ppp = (POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);
        MYASSERT (ppp);
        if (!ppp)
	    continue;
        pp = *ppp;

        if (!pp->LeafPattern && Leaf || pp->LeafPattern && !Leaf) {
            continue;
        }
        if (Leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternW (pp->LeafPattern, Leaf)) {
                continue;
            }
        }
        if (!TestParsedPatternW (pp->NodePattern, Node)) {
            continue;
        }
        //
        // the patterns match!
        //
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

    ElIsTreeExcluded2 decides if the object given by its 2 components and representing the
    whole tree beneath it (as a root) is excluded; i.e. if any child of the given object
    is excluded

Arguments:

    ObjectType - Specifies the object type
    Root - Specifies the root of the tree
    LeafPattern - Specifies the leaf pattern to be used for this decision; optional;
                  if NULL, no leaf pattern matching will be attempted

Return Value:

    TRUE if the tree is excluded, given the leaf pattern

--*/

BOOL
ElIsTreeExcluded2A (
    IN      EL_TYPE ObjectType,
    IN      PCSTR Root,
    IN      PCSTR LeafPattern           OPTIONAL
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNA pp;
    PCSTR subTreePattern;
    PPARSEDPATTERNA stpp;
    PPARSEDPATTERNA lpp;
    BOOL b;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Root);
    if (!Root) {
        return FALSE;
    }

    MYASSERT (g_ExcListProps[ObjectType].Compound);
    if (!g_ExcListProps[ObjectType].Compound) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    if (GlGetSize (gl) == 0) {
        return FALSE;
    }

    if (LeafPattern) {
        lpp = CreateParsedPatternA (LeafPattern);
        if (!lpp) {
            DEBUGMSGA ((DBG_EXCLIST, "ElIsTreeExcluded2A: invalid LeafPattern: %s", LeafPattern));
            return FALSE;
        }
    } else {
        lpp = NULL;
    }

    //
    // look if Root ends with "\*"
    //
    subTreePattern = FindLastWackA (Root);
    if (!subTreePattern || subTreePattern[1] != '*' || subTreePattern[2] != 0) {
        subTreePattern = JoinPathsInPoolExA ((g_ElPool, Root, "*", NULL));
    } else {
        subTreePattern = Root;
    }

    b = FALSE;

    stpp = CreateParsedPatternA (subTreePattern);
    if (stpp) {

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && LeafPattern || pp->LeafPattern && !LeafPattern) {
                continue;
            }
            if (LeafPattern) {
                MYASSERT (pp->LeafPattern);
                if (!PatternIncludesPatternA (pp->LeafPattern, lpp)) {
                    continue;
                }
            }
            if (!PatternIncludesPatternA (pp->NodePattern, stpp)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        DestroyParsedPatternA (stpp);
    }
    ELSE_DEBUGMSGA ((DBG_EXCLIST, "ElIsTreeExcluded2A: invalid Root: %s", Root));

    if (subTreePattern != Root) {
        pFreeMemory (subTreePattern);
    }
    if (lpp) {
        DestroyParsedPatternA (lpp);
    }

    return b;
}

BOOL
ElIsTreeExcluded2W (
    IN      EL_TYPE ObjectType,
    IN      PCWSTR Root,
    IN      PCWSTR LeafPattern          OPTIONAL
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNW pp;
    PCWSTR subTreePattern;
    PPARSEDPATTERNW stpp;
    PPARSEDPATTERNW lpp;
    BOOL b;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Root);
    if (!Root) {
        return FALSE;
    }

    MYASSERT (g_ExcListProps[ObjectType].Compound);
    if (!g_ExcListProps[ObjectType].Compound) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    if (GlGetSize (gl) == 0) {
        return FALSE;
    }

    if (LeafPattern) {
        lpp = CreateParsedPatternW (LeafPattern);
        if (!lpp) {
            DEBUGMSGW ((DBG_EXCLIST, "ElIsTreeExcluded2W: invalid LeafPattern: %s", LeafPattern));
            return FALSE;
        }
    } else {
        lpp = NULL;
    }

    //
    // look if Root ends with "\*"
    //
    subTreePattern = FindLastWackW (Root);
    if (!subTreePattern || subTreePattern[1] != L'*' || subTreePattern[2] != 0) {
        subTreePattern = JoinPathsInPoolExW ((g_ElPool, Root, L"*", NULL));
    } else {
        subTreePattern = Root;
    }

    b = FALSE;

    stpp = CreateParsedPatternW (subTreePattern);
    if (stpp) {

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && LeafPattern || pp->LeafPattern && !LeafPattern) {
                continue;
            }
            if (LeafPattern) {
                MYASSERT (pp->LeafPattern);
                if (!PatternIncludesPatternW (pp->LeafPattern, lpp)) {
                    continue;
                }
            }
            if (!PatternIncludesPatternW (pp->NodePattern, stpp)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        DestroyParsedPatternW (stpp);
    }
    ELSE_DEBUGMSGW ((DBG_EXCLIST, "ElIsTreeExcluded2W: invalid Root: %s", Root));

    if (subTreePattern != Root) {
        pFreeMemory (subTreePattern);
    }
    if (lpp) {
        DestroyParsedPatternW (lpp);
    }

    return b;
}


/*++

Routine Description:

    ElIsObsPatternExcluded decides if the object given by its parsed pattern is excluded;
    i.e. if any object matching this pattern is excluded

Arguments:

    ObjectType - Specifies the object type
    Pattern - Specifies the parsed pattern to be used for this decision

Return Value:

    TRUE if the object is excluded

--*/

BOOL
ElIsObsPatternExcludedA (
    IN      EL_TYPE ObjectType,
    IN      POBSPARSEDPATTERNA Pattern
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNA *ppp;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Pattern);
    if (!Pattern) {
        return FALSE;
    }

    MYASSERT (g_ExcListProps[ObjectType].Compound);
    if (!g_ExcListProps[ObjectType].Compound) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    for (i = GlGetSize (gl); i > 0; i--) {
        ppp = (POBSPARSEDPATTERNA*) GlGetItem (gl, i-1);
        MYASSERT (ppp);
        if (!ppp)
	    continue;
        if (ObsPatternIncludesPatternA (*ppp, Pattern)) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
ElIsObsPatternExcludedW (
    IN      EL_TYPE ObjectType,
    IN      POBSPARSEDPATTERNW Pattern
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNW *ppp;

    MYASSERT (ObjectType < ELT_UNKNOWN);
    if (ObjectType >= ELT_UNKNOWN) {
        return FALSE;
    }

    MYASSERT (Pattern);
    if (!Pattern) {
        return FALSE;
    }

    MYASSERT (g_ExcListProps[ObjectType].Compound);
    if (!g_ExcListProps[ObjectType].Compound) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    for (i = GlGetSize (gl); i > 0; i--) {
        ppp = (POBSPARSEDPATTERNW*) GlGetItem (gl, i-1);
        MYASSERT (ppp);
        if (!ppp)
	    continue;
        if (ObsPatternIncludesPatternW (*ppp, Pattern)) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\growbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growbuf.c

Abstract:

    Simple buffer management functions that allow variable blocks to
    be added as an array.  (Initially used to build a SID array, where
    each SID can be a different size.)

Author:

    Jim Schmidt (jimschm)   05-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     11-Aug-1998 Added GrowBufAppendString
    calinn      15-Jan-1998 modified MultiSzAppend


--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_GROWBUF     "GrowBuffer"

//
// Strings
//

// None

//
// Constants
//

#define DEFAULT_GROW_SIZE 8192

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  GrowBuffer makes sure there is enough bytes in the buffer
  to accomodate SpaceNeeded.  It allocates an initial buffer
  when no buffer is allocated, and it reallocates the buffer
  in increments of GrowBuf->Size (or DEFAULT_GROW_SIZE) when
  needed.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE NewBuffer;
    DWORD TotalSpaceNeeded;
    DWORD GrowTo;

    MYASSERT(SpaceNeeded);

    if (!GrowBuf->Buf) {
        GrowBuf->Size = 0;
        GrowBuf->End = 0;
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = DEFAULT_GROW_SIZE;
    }

    TotalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (TotalSpaceNeeded > GrowBuf->Size) {
        GrowTo = (TotalSpaceNeeded + GrowBuf->GrowSize) - (TotalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        GrowTo = 0;
    }

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAlloc (g_hHeap, 0, GrowTo);
        if (!GrowBuf->Buf) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Initial alloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
    } else if (GrowTo) {
        NewBuffer = MemReAlloc (g_hHeap, 0, GrowBuf->Buf, GrowTo);
        if (!NewBuffer) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Realloc failed"));
            return NULL;
        }
        DEBUGMSG_IF ((
            GrowBuf->Buf != NewBuffer,
            DBG_WARNING,
            "GbGrow: Realloc caused growbuffer to move location; "
            "any pointers inside old buffer are now invalid!"
            ));

        GrowBuf->Size = GrowTo;
        GrowBuf->Buf = NewBuffer;
    }

    NewBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

    return NewBuffer;
}


VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  FreeGrowBuffer frees a buffer allocated by GrowBuffer.

Arguments:

  GrowBuf  - A pointer to the same structure passed to GrowBuffer

Return Value:

  none

--*/


{
    MYASSERT(GrowBuf);

    if (GrowBuf->Buf) {
        MemFree (g_hHeap, 0, GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}


/*++

Routine Descriptions:

  MultiSzAppend
    This function is a general-purpose function to append a string
    to a grow buffer.

  MultiSzAppendVal
    This function adds a key=decimal_val string, where key is a
    specified string, and decimal_val is a specified DWORD.

  MultiSzAppendString
    This function adds key=string to the grow buffer, where key
    is a specified string, and string is a specified string value.

Arguments:

  GrowBuf  - The buffer to append the string or key/value pair
  Key      - The key part of the key=val pair
  Val      - The val part of the key=val pair

Return Value:

  TRUE if the function succeeded, or FALSE if a memory allocation
  failure occurred.

--*/


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    PSTR p;

    p = (PSTR) GbGrow (GrowBuf, SizeOfStringA (String) + sizeof(CHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyA (p, String);
    GrowBuf->End -= sizeof (CHAR);
    GrowBuf->Buf[GrowBuf->End] = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    )
{
    CHAR KeyValPair[256];

    wsprintfA (KeyValPair, "%s=%u", Key, Val);
    return GbMultiSzAppendA (GrowBuf, KeyValPair);
}

BOOL
RealGbMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    )
{
    CHAR KeyValPair[1024];

    wsprintfA (KeyValPair, "%s=%s", Key, Val);
    return GbMultiSzAppendA (GrowBuf, KeyValPair);
}


BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    )
{
    PWSTR p;

    p = (PWSTR) GbGrow (GrowBuf, SizeOfStringW (String) + sizeof(WCHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyW (p, String);
    GrowBuf->End -= sizeof (WCHAR);
    *((PWCHAR) (GrowBuf->Buf + GrowBuf->End)) = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    )
{
    WCHAR KeyValPair[256];

    wsprintfW (KeyValPair, L"%s=%u", Key, Val);
    return GbMultiSzAppendW (GrowBuf, KeyValPair);
}

BOOL
RealGbMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    )
{
    WCHAR KeyValPair[1024];

    wsprintfW (KeyValPair, L"%s=%s", Key, Val);
    return GbMultiSzAppendW (GrowBuf, KeyValPair);
}


BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    )
{
    PDWORD p;

    p = (PDWORD) GbGrow (GrowBuf, sizeof (DWORD));
    if (!p) {
        return FALSE;
    }

    *p = d;

    return TRUE;
}


BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID Ptr
    )
{
    PCVOID *p;

    p = (PVOID *) GbGrow (GrowBuf, sizeof (PVOID));
    if (!p) {
        return FALSE;
    }

    *p = Ptr;

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendString copies the specified string to the end of the grow
  buffer.  This is the equivalent of strcat.  The grow buffer is
  automatically expanded as necessary.

Arguments:

  GrowBuf - Specifies the destination grow buffer
  String  - Specifies the string to append

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringA (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        StringCopyA (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


BOOL
RealGbAppendStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringW (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        StringCopyW (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendStringAB copies the specified string range to the
  end of the grow buffer.  This concatenates the string to the
  existing buffer contents, and keeps the buffer terminated.

Arguments:

  GrowBuf    - Specifies the destination grow buffer
  Start      - Specifies the start of string to append
  EndPlusOne - Specifies one logical character beyond the end of
               the string, and can point to a nul.

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringABA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT)((UBINT) EndPlusOne - (UBINT) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (CHAR));

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (CHAR);
    }

    return TRUE;
}


BOOL
RealGbAppendStringABW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT)((UBINT) EndPlusOne - (UBINT) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd > sizeof (WCHAR)) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (WCHAR));

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PWSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (WCHAR);
    }

    return TRUE;
}



/*++

Routine Description:

  GrowBufCopyString copies the specified string to the end of the grow buffer.

Arguments:

  GrowBuf - Specifies the grow buffer to add to, receives the updated buffer

  String - Specifies the string to add to GrowBuf

Return Value:



--*/

BOOL
RealGbCopyStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringA (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}


BOOL
RealGbCopyStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringW (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\regtrack.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regtrack.c

Abstract:

  Routines to track calls to registry APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  02-Sept-1997

Revisions:

  marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/


#include "pch.h"
#include "utilsp.h"

#ifdef DEBUG


#undef RegOpenKeyExA
#undef RegCreateKeyExA
#undef RegOpenKeyExW
#undef RegCreateKeyExW

#define DBG_REGTRACK "RegTrack"

#define NO_MATCH        0xffffffff

DWORD g_DontCare;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList = GROWLIST_INIT;

DWORD
pFindKeyReference (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
pAddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    Size = sizeof (KEYTRACK) + SizeOfString (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;
    StringCopy (KeyTrack->SubKey, SubKey);

    GrowListAppend (&g_KeyTrackList, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
pAddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    AnsiSubKey = ConvertWtoA (SubKey);
    pAddKeyReferenceA (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference (Key);
    if (Index != NO_MATCH) {
        GrowListDeleteItem (&g_KeyTrackList, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList, d);
        DEBUGMSG ((DBG_REGTRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }
}

VOID
RegTrackTerminate (
    VOID
    )
{
    FreeGrowList (&g_KeyTrackList);
}

VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReferenceA (Key, SubKey, File, Line);
}


VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReferenceW (Key, SubKey, File, Line);
}


LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference (Key)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Reg key handle closed via CloseRegKey, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExA (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExW (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\growlist.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growlist.c

Abstract:

    Simple buffer management functions that maintenence of a list of
    binary objects.

Author:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    08-Aug-1997   jimschm     Created

Revision History:

--*/

#include "pch.h"

#define INSERT_LAST     0xffffffff

PBYTE
pGlAdd (
    IN OUT  PGROWLIST GrowList,
    IN      UINT InsertBefore,
    IN      PBYTE DataToAdd,            OPTIONAL
    IN      UINT SizeOfData,
    IN      UINT NulBytesToAdd
    )

/*++

Routine Description:

  pGlAdd allocates memory for a binary block by using a pool, and
  then expands an array of pointers, maintaining a quick-access list.

Arguments:

  GrowList - Specifies the list to add the entry to

  InsertBefore - Specifies the index of the array element to insert
                 before, or INSERT_LIST to append.

  DataToAdd - Specifies the binary block of data to add.

  SizeOfData - Specifies the size of data.

  NulBytesToAdd - Specifies the number of nul bytes to add to the buffer

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    PBYTE *Item;
    PBYTE *InsertAt;
    PBYTE Data;
    UINT OldEnd;
    UINT Size;
    UINT TotalSize;

    TotalSize = SizeOfData + NulBytesToAdd;

    MYASSERT (TotalSize || !DataToAdd);

    //
    // Allocate pool if necessary
    //

    if (!GrowList->ListData) {
        GrowList->ListData = PmCreateNamedPool ("GrowList");
        if (!GrowList->ListData) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate pool"));
            return NULL;
        }

        PmDisableTracking (GrowList->ListData);
    }

    //
    // Expand list array
    //

    OldEnd = GrowList->ListArray.End;
    Item = (PBYTE *) GbGrow (&GrowList->ListArray, sizeof (PBYTE));
    if (!Item) {
        DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate array item"));
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToAdd || NulBytesToAdd) {
        Data = PmGetAlignedMemory (GrowList->ListData, TotalSize);
        if (!Data) {
            GrowList->ListArray.End = OldEnd;
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block"));
            return NULL;
        }

        if (DataToAdd) {
            CopyMemory (Data, DataToAdd, SizeOfData);
        }
        if (NulBytesToAdd) {
            ZeroMemory (Data + SizeOfData, NulBytesToAdd);
        }
    } else {
        Data = NULL;
    }

    //
    // Adjust array
    //

    Size = GlGetSize (GrowList);

    if (InsertBefore >= Size) {
        //
        // Append mode
        //

        *Item = Data;

    } else {
        //
        // Insert mode
        //

        InsertAt = (PBYTE *) (GrowList->ListArray.Buf) + InsertBefore;
        MoveMemory (&InsertAt[1], InsertAt, (Size - InsertBefore) * sizeof (PBYTE));
        *InsertAt = Data;
    }

    return Data ? Data : (PBYTE) 1;
}


VOID
GlFree (
    IN  PGROWLIST GrowList
    )

/*++

Routine Description:

  GlFree frees the resources allocated by a GROWLIST.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    GbFree (&GrowList->ListArray);
    if (GrowList->ListData) {
        PmDestroyPool (GrowList->ListData);
    }

    ZeroMemory (GrowList, sizeof (GROWLIST));
}


PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlGetItem returns a pointer to the block of data
  for item specified by Index.

Arguments:

  GrowList - Specifies the list to access

  Index - Specifies zero-based index of item in list to access

Return Value:

  A pointer to the item's data, or NULL if the Index does not
  represent an actual item.

--*/

{
    PBYTE *ItemPtr;
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    ItemPtr = (PBYTE *) (GrowList->ListArray.Buf);


    return ItemPtr ? ItemPtr[Index] : NULL;
}


UINT
GlGetSize (
    IN      PGROWLIST GrowList
    )

/*++

Routine Description:

  GlGetSize calculates the number of items in the list.

Arguments:

  GrowList - Specifies the list to calculate the size of

Return Value:

  The number of items in the list, or zero if the list is empty.

--*/

{
    return GrowList->ListArray.End / sizeof (PBYTE);
}


PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item.

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 0);
}


PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item and
  appends two zero bytes (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 2);
}


PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a black of data as a new list item,
  before the specified Index.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 0);
}


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a block of data as a new list item,
  before the specified Index.  Two zero bytes are appended to
  the block of data (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 2);
}


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlDeleteItem removes an item from the list.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

Return Value:

  TRUE if the data block was removed from the list, or FALSE if
  Index is invalid.

--*/

{
    UINT Size;
    PBYTE *DeleteAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    DeleteAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*DeleteAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*DeleteAt));
    }

    Size--;
    if (Size > Index) {
        MoveMemory (DeleteAt, &DeleteAt[1], (Size - Index) * sizeof (PBYTE));
    }

    if (Size) {
        GrowList->ListArray.End = Size * sizeof (PBYTE);
    } else {
        GlFree (GrowList);
    }

    return TRUE;
}


BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlResetItem sets the list pointer of the specified item
  to NULL, freeing the memory associated with the item's data.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to reset.

Return Value:

  TRUE if the data block was freed and the list element was nulled,
  or FALSE if Index is invalid.

--*/

{
    UINT Size;
    PBYTE *ResetAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    ResetAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ResetAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*ResetAt));
    }

    *ResetAt = NULL;

    return TRUE;
}


PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToCopy,
    IN      UINT DataSize
    )

/*++

Routine Description:

  GlSetItem replaces the data associated with a list item.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

  DataToCopy - Specifies data to associate with the list item

  DataSize - Specifies the size of Data

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;
    PBYTE *ReplaceAt;
    PBYTE Data;

    MYASSERT (DataSize || !DataToCopy);

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToCopy) {
        Data = PmGetAlignedMemory (GrowList->ListData, DataSize);
        if (!Data) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block (2)"));
            return NULL;
        }

        CopyMemory (Data, DataToCopy, DataSize);
    } else {
        Data = NULL;
    }

    //
    // Update list pointer
    //

    ReplaceAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ReplaceAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*ReplaceAt));
    }
    *ReplaceAt = Data;

    return Data ? Data : (PBYTE) 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\utilsp.h ===
#ifndef MSG_MESSAGEBOX_TITLE
#define MSG_MESSAGEBOX_TITLE        10000
#endif

//lint -save -e757

extern PCSTR g_OutOfMemoryString;
extern PCSTR g_OutOfMemoryRetry;

extern PMHANDLE g_RegistryApiPool;
extern PMHANDLE g_PathsPool;
extern OUR_CRITICAL_SECTION g_PmCs;
extern OUR_CRITICAL_SECTION g_MemAllocCs;

//lint -restore
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\log.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Tools for logging problems for the user.


Author:

    Jim Schmidt (jimschm)  23-Jan-1997

Revisions:

    ovidiut     08-Oct-1999 Updated for new coding conventions and Win64 compliance
    ovidiut     23-Oct-1998 Implemented a new log mechanism and added new logging capabilities
    marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/


#include "pch.h"

//
// Includes
//

// None

//
// Strings
//

#define S_COLUMNDOUBLELINEA     ":\r\n\r\n"
#define S_COLUMNDOUBLELINEW     L":\r\n\r\n"
#define S_NEWLINEA              "\r\n"
#define S_NEWLINEW              L"\r\n"
#define DEBUG_SECTION           "Debug"
#define ENTRY_ALL               "All"
#define ENTRY_DEFAULTOVERRIDE   "DefaultOverride"

//
// Constants
//

#define OUTPUT_BUFSIZE_LARGE    8192
#define OUTPUT_BUFSIZE_SMALL    128
#define MAX_MSGTITLE_LEN        14
#define MSGBODY_INDENT          12
#define SCREEN_WIDTH            80
#define MAX_TYPE                64

//
// Macros
//

#define OUT_UNDEFINED(OutDest)      (OutDest == OD_UNDEFINED)
#define OUT_DEBUGLOG(OutDest)       ((OutDest & OD_DEBUGLOG) != 0)
#define OUT_SUPPRESSED(OutDest)     ((OutDest & OD_SUPPRESS) != 0)
#define OUT_NO_OUTPUT(OutDest)      (OUT_UNDEFINED(OutDest) || OUT_SUPPRESSED(OutDest))
#define OUT_ERROR(OutDest)          ((OutDest & OD_ERROR) != 0)
#define OUT_LOGFILE(OutDest)        ((OutDest & OD_LOGFILE) != 0)
#define OUT_DEBUGGER(OutDest)       ((OutDest & OD_DEBUGGER) != 0)
#define OUT_CONSOLE(OutDest)        ((OutDest & OD_CONSOLE) != 0)
#define OUT_POPUP(OutDest)          ((OutDest & (OD_POPUP|OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define OUT_POPUP_CANCEL(OutDest)   ((OutDest & (OD_POPUP_CANCEL|OD_FORCE_POPUP)) == OD_POPUP_CANCEL)
#define OUT_FORCED_POPUP(OutDest)   ((OutDest & (OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define MUST_BE_LOCALIZED(OutDest)  ((OutDest & OD_MUST_BE_LOCALIZED) == OD_MUST_BE_LOCALIZED)
#define OUT_ASSERT(OutDest)         ((OutDest & OD_ASSERT) != 0)
#define OUT_CONFIG(OutDest)         ((OutDest & OD_CONFIG) != 0)

#define LOGSEVERITY             LogSeverity

#define LOGSEV_FATAL_ERROR      LogSevFatalError
#define LOGSEV_ERROR            LogSevError
#define LOGSEV_WARNING          LogSevWarning
#define LOGSEV_INFORMATION      LogSevInformation

#ifdef DEBUG
    #define DEFAULT_ERROR_FLAGS  (OD_DEBUGLOG | OD_LOGFILE | OD_POPUP | OD_ERROR | OD_UNATTEND_POPUP | OD_ASSERT)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#else
    #define DEFAULT_ERROR_FLAGS  (OD_LOGFILE | OD_POPUP | OD_ERROR | OD_MUST_BE_LOCALIZED)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#endif

#define END_OF_BUFFER(buf)      ((buf) + (sizeof(buf) / sizeof(buf[0])) - 1)

// This constant sets the default output
#ifndef DEBUG
    #define NORMAL_DEFAULT      OD_LOGFILE
#else
    #define NORMAL_DEFAULT      OD_DEBUGLOG
#endif

#ifdef DEBUG
    #define PRIVATE_ASSERT(expr)        pPrivateAssert(expr,#expr,__LINE__);
#else
    #define PRIVATE_ASSERT(expr)
#endif // DEBUG

#define NEWLINE_CHAR_COUNTA  (sizeof (S_NEWLINEA) / sizeof (CHAR) - 1)
#define NEWLINE_CHAR_COUNTW  (sizeof (S_NEWLINEW) / sizeof (WCHAR) - 1)

//
// Types
//

typedef enum {
    OD_UNDEFINED = 0x00,            // undefined output dest
    OD_DEBUGLOG = 0x01,             // debuglog used
    OD_SUPPRESS = 0x02,             // don't log to any device
    OD_ERROR = 0x04,                // automatically append GetLastError() to the message
    OD_LOGFILE = 0x08,              // messages go to logfile
    OD_DEBUGGER = 0x10,             // messages go to debugger
    OD_CONSOLE = 0x20,              // messages go to console
    OD_POPUP = 0x40,                // display a popup dialog
    OD_POPUP_CANCEL = 0x80,         // do not display a popup dialog (cancelled by user)
    OD_FORCE_POPUP = 0x100,         // force the popup to be displayed always
    OD_MUST_BE_LOCALIZED = 0x200,   // used for LOG() that will generate a popup
    OD_UNATTEND_POPUP = 0x400,      // force the popup to be displayed in unattend mode
    OD_ASSERT = 0x800,              // give DebugBreak option in popup
    OD_CONFIG = 0x1000              // output to config.dmp
} OUTPUT_DESTINATION;

typedef DWORD   OUTPUTDEST;

typedef struct {
    PCSTR Value;               // string value entered by the user (LOG,POPUP,SUPPRESS etc.)
    OUTPUTDEST OutDest;        // any combination of OutDest flags
} STRING2BINARY, *PSTRING2BINARY;

typedef struct {
    PCSTR Type;
    DWORD Flags;
} DEFAULT_DESTINATION, *PDEFAULT_DESTINATION;


//
// Globals
//

const STRING2BINARY g_String2Binary[] = {
    "SUPPRESS", OD_SUPPRESS,
    "LOG",      OD_LOGFILE,
    "POPUP",    OD_POPUP,
    "DEBUGGER", OD_DEBUGGER,
    "CONSOLE",  OD_CONSOLE,
    "ERROR",    OD_ERROR,
    "NOCANCEL", OD_FORCE_POPUP,
    "ASSERT",   OD_ASSERT
};

const PCSTR g_IgnoreKeys[] = {
    "Debug",
    "KeepTempFiles"
};

// a window handle for popup parent
HWND g_LogPopupParentWnd = NULL;
// thread id that set this window handle
DWORD g_InitThreadId = 0;


OUTPUTDEST g_OutDestAll = OD_UNDEFINED;
OUTPUTDEST g_OutDestDefault = NORMAL_DEFAULT;
PVOID g_TypeSt = NULL;
BOOL g_HasTitle = FALSE;
CHAR g_LastType [MAX_TYPE];
BOOL g_SuppressAllPopups = FALSE;
CHAR g_ConfigDmpPathBufA[MAX_MBCHAR_PATH];
BOOL g_ResetLog = FALSE;
#ifdef PROGRESS_BAR
    HANDLE g_ProgressBarLog = INVALID_HANDLE_VALUE;
#endif //PROGRESS_BAR

#ifdef DEBUG
    CHAR g_DebugInfPathBufA[] = "C:\\debug.inf";
    WCHAR g_DebugInfPathBufW[] = L"C:\\debug.inf";
    CHAR g_Debug9xLogPathBufA[] = "C:\\debug9x.log";
    CHAR g_DebugNtLogPathBufA[] = "C:\\debugnt.log";
    PCSTR g_DebugLogPathA = NULL;
    // If g_DoLog is TRUE, then, debug logging is enabled in the
    // checked build even if there is no debug.inf.
    // This variable can be enabled via the /#U:DOLOG command line directive...
    BOOL g_DoLog = FALSE;
#endif // DEBUG

#if defined(PROGRESS_BAR) || defined(DEBUG)
DWORD g_FirstTickCount = 0;
DWORD g_LastTickCount  = 0;
#endif

//
// Macro expansion list
//

#ifndef DEBUG

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_ACCOUNTS, OD_LOGFILE)                                        \
        DEFMAC(LOG_CONFIG, OD_CONFIG)                                           \

#else

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(DBG_WHOOPS,  DEFAULT_ERROR_FLAGS)                                \
        DEFMAC(DBG_WARNING, OD_LOGFILE|OD_DEBUGGER)                             \
        DEFMAC(DBG_ASSERT,DEFAULT_ERROR_FLAGS|OD_FORCE_POPUP|OD_UNATTEND_POPUP) \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_ACCOUNTS, OD_LOGFILE)                                        \
        DEFMAC(LOG_CONFIG, OD_CONFIG)                                           \

#endif


//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

/*++

Macro Expansion List Description:

  TYPE_DEFAULTS specify the default destination for the frequently used types,
  such as LOG_ERROR, LOG_FATAL_ERROR, and so on.

Line Syntax:

   DEFMAC(TypeString, Flags)

Arguments:

   TypeString - Specifies the LOG_ constant as defined in log.h

   Flags - One or more of:

           DEFAULT_ERROR_FLAGS - Specifies debug log, setup log, debugger,
                                 popup, and the value of GetLastError.

           OD_DEBUGLOG - Specifies the debug log

           OD_ERROR - Specifies type is an error (gets value of
                      GetLastError)

           OD_SUPPRESS - Suppresses all output for the type

           OD_LOGFILE - Specifies the setup log

           OD_DEBUGGER - Specifies the debugger (i.e., VC or remote debugger)

           OD_CONSOLE - Specifies the console (via printf)

           OD_POPUP - Specifies a message box

           OD_FORCE_POPUP - Specifies a message box, even if debug message
                            was turned off via a click on Cancel

           OD_MUST_BE_LOCALIZED - Indicates the type must originate from a
                                  localized message; used for LOG() calls that
                                  generate popups.  (So English messages
                                  don't sneak into the project.)

           OD_UNATTEND_POPUP - Causes popup even in unattend mode

           OD_ASSERT - Give DebugBreak option in popup

Variables Generated From List:

    g_DefaultDest

--*/

#define DEFMAC(typestr, flags)      {typestr, (flags)},

DEFAULT_DESTINATION g_DefaultDest[] = {TYPE_DEFAULTS /* , */ {NULL, 0}};

#undef DEFMAC


//
// Code
//


#ifdef DEBUG

VOID
pPrivateAssert (
    IN      BOOL Expr,
    IN      PCSTR StringExpr,
    IN      UINT Line
    )
{
    CHAR buffer[256];

    if (Expr) {
        return;
    }

    wsprintfA (buffer, "LOG FAILURE: %s (log.c line %u)", StringExpr, Line);
    MessageBox (NULL, buffer, NULL, MB_OK);
}

#endif


BOOL
pIgnoreKey (
    IN      PCSTR Key
    )

/*++

Routine Description:

  pIgnoreKey decides if a key from [debug] section of DEBUG.INF
  should be ignored for our purposes (we are only looking for
  <All>, <DefaultOverride> and log/debug types).
  Specifically, we ignore all keywords in <g_IgnoreKeys> table.

Arguments:

  Key - Specifies the key from [debug] section of DEBUG.INF

Return Value:

  TRUE if the key should be ignored, or FALSE if it will be taken into consideration.

--*/

{
    UINT i;

    for (i = 0; i < sizeof (g_IgnoreKeys) / sizeof (PCSTR); i++) {
        if (StringIMatchA (Key, g_IgnoreKeys[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


OUTPUTDEST
pConvertToOutputType (
    IN      PCSTR Value
    )

/*++

Routine Description:

  pConvertToOutputType converts a text value entered by the user in
  DEBUG.INF file, associated with a type (e.g. "LOG", "POPUP" etc.).

Arguments:

  Value - Specifies the text value

Return Value:

  The OUTPUT_DESTINATION value associated with the given value or
  OD_UNDEFINED if the value is not valid.

--*/

{
    UINT i;

    for (i = 0; i < sizeof (g_String2Binary) / sizeof (STRING2BINARY); i++) {
        if (StringIMatchA (Value, g_String2Binary[i].Value)) {
            return g_String2Binary[i].OutDest;
        }
    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDestFromTable (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDestFromTable returns the output destination associated
  with the specified type in the global table

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];
    OUTPUTDEST outDest;

    if (g_TypeSt == NULL) {
        //
        // sorry, log is closed
        //
        return OD_UNDEFINED;
    }

    if(ISNT()) {
        // convert the ASCII string to UNICODE on NT platforms
        KnownSizeAtoW (typeW, Type);
    } else {
        StringCopyA ((PSTR)typeW, Type);
    }
#if 0
    if (-1 != StringTableLookUpStringEx (
                    g_TypeSt,
                    (PSTR)typeW,
                    STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                    &outDest,
                    sizeof (outDest)
                    )) {

#ifdef DEBUG
        if (g_DoLog) {
            outDest |= OD_DEBUGLOG;
        }
#endif
        return outDest;

    }
#endif

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDest (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDest returns the default output
  destination for the specified type.

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST outDest;

    //
    // first check for ALL
    //

    if (!OUT_UNDEFINED (g_OutDestAll)) {
        outDest = g_OutDestAll;
    } else {

        //
        // otherwise try to get it from the table
        //

        outDest = pGetTypeOutputDestFromTable (Type);
        if (OUT_UNDEFINED (outDest)) {

            //
            // just return the default
            //

            outDest = g_OutDestDefault;
        }
    }

#ifdef DEBUG
    if (g_DoLog) {
        outDest |= OD_DEBUGLOG;
    }
#endif


    return outDest;
}


BOOL
pIsPopupEnabled (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pIsPopupEnabled decides if the type should produce a popup output. The user may
  disable popup display for a type.

Arguments:

  Type - Specifies the type

Return Value:

  TRUE if the type should display a popup message.

--*/

{
    OUTPUTDEST outDest;

#ifdef DEBUG
    //
    // if this is an ASSERT, always show it to developer
    //
    if (!_stricmp (Type, DBG_ASSERT)) {
        return TRUE;
    }
#endif

    //
    // first check if any specific output is available for this type,
    // and if so, check if the OUT_POPUP_CANCEL flag is not set
    //

    if (g_SuppressAllPopups) {
        return FALSE;
    }

    outDest = pGetTypeOutputDestFromTable (Type);
    if (OUT_POPUP_CANCEL (outDest)) {
        return FALSE;
    }

    // just return the popup type of ALL of DefaultOverride
    return OUT_POPUP (pGetTypeOutputDest (Type));
}


LOGSEVERITY
pGetSeverityFromType (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetSeverityFromType converts a type to a default severity
  that will be used by the debug log system.

Arguments:

  Type - Specifies the type

Return Value:

  The default log severity associated with the given type; if the specified
  type is not found, it returns LOGSEV_INFORMATION.

--*/

{
    if (OUT_ERROR (pGetTypeOutputDest (Type))) {
        return LOGSEV_ERROR;
    }

    return LOGSEV_INFORMATION;
}


BOOL
pTableAddType (
    IN      PCSTR Type,
    IN      OUTPUTDEST OutDest
    )

/*++

Routine Description:

  pTableAddType adds a <Type, OutDest> association
  to the table g_TypeSt. If an association of Type already exists,
  it is modified to reflect the new association.

Arguments:

  Type - Specifies the log/debug type string

  OutDest - Specifies what new destination(s) are associated with the type

Return Value:

  TRUE if the association was successful and the Type is now in the table

--*/

{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];

    if(ISNT()) {
        // convert the ASCII string to UNICODE on NT platforms
        KnownSizeAtoW (typeW, Type);
    } else {
        StringCopyA ((PSTR)typeW, Type);
    }

    PRIVATE_ASSERT (g_TypeSt != NULL);
#if 0
    return -1 != StringTableAddStringEx(
                    g_TypeSt,
                    (PSTR)typeW,
                    STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE | STRTAB_NEW_EXTRADATA,
                    &OutDest,
                    sizeof(OutDest)
                    );
#else
    return TRUE;

#endif

}


OUTPUTDEST
pGetAttributes (
    IN OUT  PINFCONTEXT InfContext
    )

/*++

Routine Description:

  pGetAttributes converts the text values associated with the key on
  the line specified by the given context. If multiple values are
  specified, the corresponding OUTPUT_DESTINATION values are ORed together
  in the return value.

Arguments:

  InfContext - Specifies the DEBUG.INF context of the key whose values
               are being converted and receives the updated context
               after this processing is done

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given key.

--*/

{
    OUTPUTDEST outDest = OD_UNDEFINED;
    CHAR value[OUTPUT_BUFSIZE_SMALL];
    UINT field;

#if 0
    for (field = SetupGetFieldCount (InfContext); field > 0; field--) {
        if (SetupGetStringFieldA (
                InfContext,
                field,
                value,
                OUTPUT_BUFSIZE_SMALL,
                NULL
                )) {
            outDest |= pConvertToOutputType(value);
        }
    }
#endif
    return outDest;
}


BOOL
pGetUserPreferences (
    IN      HINF Inf
    )

/*++

Routine Description:

  pGetUserPreferences converts user's options specified in the given Inf file
  (usually DEBUG.INF) and stores them in g_TypeSt table. If <All> and
  <DefaultOverride> entries are found, their values are stored in OutputTypeAll
  and OutputTypeDefault, respectivelly, if not NULL.

Arguments:

  Inf - Specifies the open inf file hanlde to process

  OutputTypeAll - Receives the Output Dest for the special <All> entry

  OutputTypeDefault - Receives the Output Dest for the special <DefaultOverride> entry

Return Value:

  TRUE if the processing of the INF file was OK.

--*/

{
    INFCONTEXT infContext;
    OUTPUTDEST outDest;
    CHAR key[OUTPUT_BUFSIZE_SMALL];
/*
    if (SetupFindFirstLineA (Inf, DEBUG_SECTION, NULL, &infContext)) {

        do {
            // check to see if this key is not interesting
            if (!SetupGetStringFieldA (
                    &infContext,
                    0,
                    key,
                    OUTPUT_BUFSIZE_SMALL,
                    NULL
                    )) {
                continue;
            }
            if (pIgnoreKey (key)) {
                continue;
            }

            // check for special cases
            if (StringIMatchA (key, ENTRY_ALL)) {
                g_OutDestAll = pGetAttributes (&infContext);
                // no reason to continue since ALL types will take this setting...
                break;
            } else {
                if (StringIMatchA (key, ENTRY_DEFAULTOVERRIDE)) {
                    g_OutDestDefault = pGetAttributes(&infContext);
                } else {
                    outDest = pGetAttributes(&infContext);
                    // lines like <Type>=   or like <Type>=<not a keyword(s)>  are ignored
                    if (!OUT_UNDEFINED (outDest)) {
                        if (!pTableAddType (key, outDest)) {
                            return FALSE;
                        }
                    }
                }
            }
        } while (SetupFindNextLine (&infContext, &infContext));
    }
*/
    return TRUE;
}


/*++

Routine Description:

  pPadTitleA and pPadTitleW append to Title a specified number of spaces.

Arguments:

  Title - Specifies the title (it will appear on the left column).
          The buffer must be large enough to hold the additional spaces
  Indent  - Specifies the indent of the message body. If necessary,
            spaces will be appended to the Title to get to Indent column.

Return Value:

  none

--*/

VOID
pPadTitleA (
    IN OUT  PSTR Title,
    IN      UINT Indent
    )

{
    UINT i;
    PSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = ByteCountA (Title), p = GetEndOfStringA (Title); i < Indent; i++) {
        *p++ = ' '; //lint !e613 !e794
    }

    *p = 0; //lint !e613 !e794
}


VOID
pPadTitleW (
    IN OUT  PWSTR Title,
    IN      UINT  Indent
    )
{
    UINT i;
    PWSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = CharCountW (Title), p = GetEndOfStringW (Title); i < Indent; i++) {
        *p++ = L' ';    //lint !e613
    }

    *p = 0; //lint !e613
}


/*++

Routine Description:

  pFindNextLineA and pFindNextLineW return the position where
  the next line begins

Arguments:

  Line - Specifies the current line

  Indent  - Specifies the indent of the message body. The next line
            will start preferably after a newline or a white space,
            but no further than the last column, which is
            SCREEN_WIDTH - Indent.

Return Value:

  The position of the first character on the next line.

--*/

PCSTR
pFindNextLineA (
    IN      PCSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCSTR lastSpace = NULL;
    PCSTR prevLine = Line;
    UINT ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = _mbsnextc (Line)) != 0 && column < columnMax) {

        if (ch == '\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
            column++;
        } else {
            if (_ismbcspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line = _mbsinc (Line);
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space or 2-byte char was found
        lastSpace = prevLine;
    }

    if (ch != '\n') {
        *TrimLeadingSpace = TRUE;
    }

    return _mbsinc (lastSpace);
}


PCWSTR
pFindNextLineW (
    IN      PCWSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCWSTR lastSpace = NULL;
    PCWSTR prevLine = Line;
    WCHAR ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = *Line) != 0 && column < columnMax) {

        if (ch == L'\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
        } else {
            if (iswspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line++;
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space was found
        lastSpace = prevLine;
    }

    if (ch != L'\n') {
        *TrimLeadingSpace = TRUE;
    }

    return lastSpace + 1;
}


/*++

Routine Description:

  pHangingIndentA and pHangingIndentW break in lines and indent
  the text in buffer, which is no larger than Size.

Arguments:

  buffer - Specifies the buffer containing text to format. The resulting
           text will be put in the same buffer

  Size  - Specifies the size of this buffer, in bytes

  Indent  - Specifies the indent to be used by all new generated lines.

Return Value:

  none

--*/

VOID
pHangingIndentA (
    IN OUT  PSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    CHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCSTR nextLine;
    PCSTR s;
    PSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 3;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PSTR)pFindNextLineA (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case '\r':
                s++;
                if (*s == '\r') {
                    continue;
                } else if (*s != '\n') {
                    s--;
                }

                // fall through

            case '\n':
                *d++ = '\r';
                *d++ = '\n';
                s++;
                break;

            default:
                if (isleadbyte (*s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == ' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = ' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyByteCountA (buffer, indentBuffer, Size);
}


VOID
pHangingIndentW (
    IN OUT  PWSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    WCHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCWSTR nextLine;
    PCWSTR s;
    PWSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCWSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 1;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PWSTR)pFindNextLineW (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case L'\r':
                s++;
                if (*s == L'\r') {
                    continue;
                } else if (*s != L'\n') {
                    s--;
                }

                // fall through

            case L'\n':
                *d++ = L'\r';
                *d++ = L'\n';
                s++;
                break;

            default:
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == L' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = L' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyCharCountW (buffer, indentBuffer, Size);
}


/*++

Routine Description:

  pAppendLastErrorA and pAppendLastErrorW append the specified error code
  to the Message and writes the output to the MsgWithErr buffer.

Arguments:

  MsgWithErr  - Receives the formatted message. This buffer
                is supplied by caller

  BufferSize  - Specifies the size of the buffer, in bytes

  Message  - Specifies the body of the message

  LastError  - Specifies the error code that will be appended

Return Value:

  none

--*/

VOID
pAppendLastErrorA (
    OUT     PSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCSTR Message,
    IN      DWORD LastError
    )
{
    PSTR append;
    DWORD errMsgLen;

    StringCopyByteCountA (MsgWithErr, Message, BufferSize);
    append = GetEndOfStringA (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + BufferSize - append);  //lint !e613

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snprintf (append, errMsgLen, " [ERROR=%lu]", LastError);
        } else {
            _snprintf (append, errMsgLen, " [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


VOID
pAppendLastErrorW (
    OUT     PWSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCWSTR Message,
    IN      DWORD LastError
    )
{
    PWSTR append;
    DWORD errMsgLen;

    StringCopyCharCountW (MsgWithErr, Message, BufferSize / sizeof(WCHAR));
    append = GetEndOfStringW (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + (BufferSize / sizeof(WCHAR)) - append);

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu]", LastError);
        } else {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


/*++

Routine Description:

  pIndentMessageA and pIndentMessageW format the specified message
  with the type in the left column and body of the message in the right.

Arguments:

  formattedMsg  - Receives the formatted message. This buffer
                  is supplied by caller

  BufferSize  - Specifies the size of the buffer

  Type  - Specifies the type of the message

  Body  - Specifies the body of the message

  Indent  - Specifies the column to indent to

  LastError  - Specifies the last error code if different than ERROR_SUCCESS;
               in this case it will be appended to the message

Return Value:

  none

--*/

VOID
pIndentMessageA (
    OUT     PSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    CHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR myMsgBody;
    PSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorA (bodyWithErr, sizeof (bodyWithErr), Body, LastError);
    }

    StringCopyByteCountA (formattedMsg, Type, MAX_MSGTITLE_LEN);
    pPadTitleA (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    StringCopyByteCountA (currentPos, myMsgBody, remaining);
    pHangingIndentA (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = GetEndOfStringA (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTA + 1 < formattedMsg + BufferSize) { //lint !e613
        *currentPos++ = '\r';   //lint !e613
        *currentPos++ = '\n';   //lint !e613
        *currentPos = 0;        //lint !e613
    }
}


VOID
pIndentMessageW (
    OUT     PWSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCWSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];
    WCHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR myMsgBody;
    PWSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorW (bodyWithErr, sizeof (bodyWithErr), Body, LastError);
    }

    KnownSizeAtoW (typeW, Type);

    StringCopyCharCountW (formattedMsg, typeW, MAX_MSGTITLE_LEN);
    pPadTitleW (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    StringCopyCharCountW (currentPos, myMsgBody, remaining);
    pHangingIndentW (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = GetEndOfStringW (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTW + 1 < formattedMsg + BufferSize) {
        *currentPos++ = L'\r';
        *currentPos++ = L'\n';
        *currentPos = 0;
    }
}


/*++

Routine Description:

  pWriteToSetupLogA and pWriteToSetupLogW log the specified message
  to the setup log using Setup API functions.

Arguments:

  Severity  - Specifies the severity of the message, as defined by the Setup API

  formattedMsg  - Specifies the message

Return Value:

  none

--*/


VOID
pWriteToSetupLogA (
    IN      LOGSEVERITY Severity,
    IN      PCSTR formattedMsg
    )
{
/*
    if (!SetupOpenLog (FALSE)) {
        PRIVATE_ASSERT (FALSE);
        return;
    }
    if (!SetupLogErrorA (formattedMsg, Severity)) {
        PRIVATE_ASSERT (FALSE);
    }

    //SetupCloseLog();
*/
}


VOID
pWriteToSetupLogW (
    IN      LOGSEVERITY Severity,
    IN      PCWSTR formattedMsg
    )
{
/*
    if (!SetupOpenLog (FALSE)) {
        PRIVATE_ASSERT (FALSE);
        return;
    }

    if (!SetupLogErrorW (formattedMsg, Severity)) {
        PRIVATE_ASSERT (FALSE);
    }

    //SetupCloseLog();
*/
}


/*++

Routine Description:

  pDisplayPopupA and pDisplayPopupW displays the specified message to
  a popup window, if <g_LogPopupParentWnd> is not NULL (attended mode).

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

  LastError  - Specifies the last error; it will be printed if != ERROR_SUCCESS

  Forced - Specifies TRUE to force the popup, even in unattended mode

Return Value:

  none

--*/

VOID
pDisplayPopupA (
    IN      PCSTR Type,
    IN      PCSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
#ifdef DEBUG
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    CHAR buffer[OUTPUT_BUFSIZE_SMALL];
    PSTR currentPos = buffer;
#endif
    UINT mbStyle;
    LONG rc;
    OUTPUTDEST outDest;
    HWND parentWnd;
    PCSTR displayMessage = Msg;
    LOGSEVERITY severity = pGetSeverityFromType (Type);

    outDest = pGetTypeOutputDest (Type);

    if (g_LogPopupParentWnd || Forced) {

#ifdef DEBUG
        if (LastError != ERROR_SUCCESS) {
            if (LastError < 10) {
                currentPos += wsprintfA (buffer, " [ERROR=%u]", LastError);
            } else {
                currentPos += wsprintfA (buffer, " [ERROR=%u (%Xh)]", LastError, LastError);
            }
        }

        if (OUT_ASSERT (outDest)) {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\nBreak now? (Hit Yes to break, No to continue, or Cancel to disable '%s' message boxes)",
                            Type
                            );
        } else {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\n(Hit Cancel to disable '%s' message boxes)",
                            Type
                            );
        }

        if (currentPos > buffer) {

            //
            // the displayed message should be modified to include additional info
            //

            displayMessage = formattedMsg;
            StringCopyByteCountA (
                formattedMsg,
                Msg,
                (UINT) (sizeof (formattedMsg) / sizeof (CHAR) - ((UBINT)currentPos - (UBINT)buffer))
                );
            StringCatA (formattedMsg, buffer);
        }
#endif

        switch (severity) {

        case LOGSEV_FATAL_ERROR:
            mbStyle = MB_ICONSTOP;
            break;

        case LOGSEV_ERROR:
            mbStyle = MB_ICONERROR;
            break;

        case LOGSEV_WARNING:
            mbStyle = MB_ICONEXCLAMATION;
            break;

        default:
            mbStyle = MB_ICONINFORMATION;

        }
        mbStyle |= MB_SETFOREGROUND;

#ifdef DEBUG
        if (OUT_ASSERT (outDest)) {
            mbStyle |= MB_YESNOCANCEL|MB_DEFBUTTON2;
        } else {
            mbStyle |= MB_OKCANCEL;
        }
#else
        mbStyle |= MB_OK;
#endif

        //
        // check current thread id; if different than thread that initialized
        // parent window handle, set parent to NULL
        //
        if (GetCurrentThreadId () == g_InitThreadId) {

            parentWnd = g_LogPopupParentWnd;

        } else {

            parentWnd = NULL;

        }

        rc = MessageBoxA (parentWnd, displayMessage, Type, mbStyle);

#ifdef DEBUG

        if (rc == IDCANCEL) {
            //
            // cancel this type of messages
            //

            pTableAddType (Type, outDest | OD_POPUP_CANCEL);

        } else if (rc == IDYES) {

            //
            // If Yes was clicked, call DebugBreak to get assert behavoir
            //

            DebugBreak();

        }
#endif

    }
}


VOID
pDisplayPopupW (
    IN      PCSTR Type,
    IN      PWSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
    PCSTR msgA;

    //
    // call the ANSI version because wsprintfW is not properly implemented on Win9x
    //
    msgA = ConvertWtoA (Msg);
    pDisplayPopupA (Type, msgA, LastError, Forced);
    FreeConvertedStr (msgA);
}


/*++

Routine Description:

  pRawWriteLogOutputA and pRawWriteLogOutputW output specified message
  to all character devices implied by the type. The message is not
  formatted in any way

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

Return Value:

  none

--*/

VOID
pRawWriteLogOutputA (
    IN      PCSTR Type,
    IN      PCSTR Message,
    IN      PCSTR formattedMsg
    )
{
    OUTPUTDEST outDest;
    HANDLE handle;
    DWORD lastError;
    CHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR logMessage;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (OUT_LOGFILE (outDest)) {

        //
        // determine the severity of the message
        //

        if (OUT_ERROR (outDest)) {

            if (Message) {

                logMessage = Message;

                lastError = GetLastError ();

                if (lastError != ERROR_SUCCESS) {

                    pAppendLastErrorA (bodyWithErr, sizeof (bodyWithErr), Message, lastError);

                    logMessage = bodyWithErr;
                }

                pWriteToSetupLogA (LOGSEV_INFORMATION, "Error:\r\n");
                pWriteToSetupLogA (LOGSEV_ERROR, logMessage);
                pWriteToSetupLogA (LOGSEV_INFORMATION, "\r\n\r\n");

            } else {
                PRIVATE_ASSERT (FALSE);
            }

        } else {
            pWriteToSetupLogA (LOGSEV_INFORMATION, formattedMsg);
        }
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringA (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fprintf (stderr, "%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                            g_DebugLogPathA,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringA (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif

    if (OUT_CONFIG (outDest)) {

        handle = CreateFileA (
                        g_ConfigDmpPathBufA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringA (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
}


VOID
pRawWriteLogOutputW (
    IN      PCSTR Type,
    IN      PCWSTR Message,
    IN      PCWSTR formattedMsg
    )
{
    OUTPUTDEST outDest;
    HANDLE handle;
    DWORD lastError;
    WCHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR logMessage;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (OUT_LOGFILE (outDest)) {

        //
        // determine the severity of the message
        //

        if (OUT_ERROR (outDest)) {

            if (Message) {

                logMessage = Message;

                lastError = GetLastError ();

                if (lastError != ERROR_SUCCESS) {

                    pAppendLastErrorW (bodyWithErr, sizeof (bodyWithErr), Message, lastError);

                    logMessage = bodyWithErr;
                }
                pWriteToSetupLogW (LOGSEV_INFORMATION, L"Error:\r\n");
                pWriteToSetupLogW (LOGSEV_ERROR, logMessage);
                pWriteToSetupLogW (LOGSEV_INFORMATION, L"\r\n\r\n");

            } else {
                PRIVATE_ASSERT (FALSE);
            }

        } else {
            pWriteToSetupLogW (LOGSEV_INFORMATION, formattedMsg);
        }
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringW (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fwprintf (stderr, L"%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                        g_DebugLogPathA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringW (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif

    if (OUT_CONFIG (outDest)) {

        handle = CreateFileA (
                        g_ConfigDmpPathBufA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringW (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
}


/*++

Routine Description:

  pFormatAndWriteMsgA and pFormatAndWriteMsgW format the message
  specified by the Format argument and outputs it to all destinations
  specified in OutDest. If no destination for the message,
  no action is performed.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  args  - Specifies a list of arguments to be used when formatting
          the message. If a message ID is used for Format, args
          is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
pFormatAndWriteMsgA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((UBINT)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageA (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)(UBINT) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID"));
            return;
        }
    } else {

        //
        // format given string using printf style
        //

        _vsnprintf(output, OUTPUT_BUFSIZE_LARGE, Format, args);
    }

    pIndentMessageA (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputA (Type, output, formattedMsg);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (SHIFTRIGHT16((UBINT)Format) == 0);
        }

        pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((UBINT)Format) == 0) {
            pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


VOID
pFormatAndWriteMsgW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    WCHAR formatW[OUTPUT_BUFSIZE_LARGE];
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((UBINT)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)(UBINT) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID"));
            return;
        }
    } else {
        KnownSizeAtoW (formatW, Format);

        //
        // format given string using printf style
        //

        _vsnwprintf(output, OUTPUT_BUFSIZE_LARGE, formatW, args);
    }

    pIndentMessageW (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputW (Type, output, formattedMsg);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (SHIFTRIGHT16((UBINT)Format) == 0);
        }

        pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((UBINT)Format) == 0) {
            pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


BOOL
pInitLog (
    IN      HWND *LogPopupParentWnd,    OPTIONAL
    OUT     HWND *OrgPopupParentWnd,    OPTIONAL
    IN      BOOL FirstTimeInit
    )

/*++

Routine Description:

  pInitLog actually initializes the log system.

Arguments:

  LogPopupParentWnd  - Specifies the parent window to be used by the
                       popups, or NULL if popups are to be suppressed.
                       This value is optional only if FirstTimeInit
                       is FALSE.

  OrgPopupParentWnd  - Receives the original parent window.

  FirstTimeInit  - Specifies TRUE for the first log initialization,
                   or FALSE for reinitialization

Return Value:

  TRUE if log system successfully initialized

--*/

{
    HINF hInf = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;
    PDEFAULT_DESTINATION dest;
#ifdef DEBUG
    CHAR tempPath[MAX_MBCHAR_PATH];
#endif

    PRIVATE_ASSERT (!FirstTimeInit || LogPopupParentWnd);

    __try {

        if (FirstTimeInit) {
            PRIVATE_ASSERT (!g_TypeSt);
/*
            g_TypeSt = StringTableInitializeEx(sizeof (OUTPUTDEST), 0);

            if (!g_TypeSt) {
                __leave;
            }

            dest = g_DefaultDest;

            while (dest->Type) {
                pTableAddType (dest->Type, dest->Flags);
                dest++;
            }
*/
            if (!GetWindowsDirectoryA (g_ConfigDmpPathBufA, MAX_MBCHAR_PATH))
	        __leave;
            StringCopyA (AppendWackA (g_ConfigDmpPathBufA), TEXT("config.dmp"));

#ifdef PROGRESS_BAR
            PRIVATE_ASSERT (g_ProgressBarLog == INVALID_HANDLE_VALUE);
            g_ProgressBarLog = CreateFile (
                                ISNT() ? TEXT("C:\\pbnt.txt") : TEXT("C:\\pb9x.txt"),
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
            if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
                SetFilePointer (g_ProgressBarLog, 0, NULL, FILE_END);
            }
#endif
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_ConfigDmpPathBufA, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_ConfigDmpPathBufA);
        }

#ifdef DEBUG
        if (FirstTimeInit) {
            GetSystemDirectoryA (tempPath, ARRAYSIZE (tempPath));

            // replace C with the actual sys drive letter
            g_DebugNtLogPathBufA[0] = g_Debug9xLogPathBufA[0] = tempPath[0];
            g_DebugInfPathBufA[0] = tempPath[0];

            //
            // only the first byte is important because drive letters are not double-byte chars
            //
            g_DebugInfPathBufW[0] = (WCHAR)tempPath[0];

            //
            // now get user's preferences
            //

            //hInf = SetupOpenInfFileA (g_DebugInfPathBufA, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
            //if (INVALID_HANDLE_VALUE != hInf && pGetUserPreferences(hInf)) {
            //    g_DoLog = TRUE;
            //}
        }

        if (g_DebugLogPathA == NULL) {

            g_DebugLogPathA = ISNT() ? g_DebugNtLogPathBufA : g_Debug9xLogPathBufA;
        }

        if (g_ResetLog) {

            SetFileAttributesA (g_DebugLogPathA, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogPathA);
        }
#endif

        if (OrgPopupParentWnd) {
            *OrgPopupParentWnd = g_LogPopupParentWnd;
        }

        if (LogPopupParentWnd) {
            g_LogPopupParentWnd = *LogPopupParentWnd;
            g_InitThreadId = GetCurrentThreadId ();
        }

        result = TRUE;
    }
    __finally {

        if (hInf != INVALID_HANDLE_VALUE) {
            //SetupCloseInfFile (hInf);
        }

        if (!result) {  //lint !e774

            if (g_TypeSt) {
                //StringTableDestroy(g_TypeSt);
                g_TypeSt = NULL;
            }

            g_OutDestAll = OD_UNDEFINED;
            g_OutDestDefault = OD_UNDEFINED;

#ifdef DEBUG
            g_DoLog = FALSE;
#endif

#ifdef PROGRESS_BAR
            if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
                CloseHandle (g_ProgressBarLog);
                g_ProgressBarLog = INVALID_HANDLE_VALUE;
            }
#endif
        }
    }

    return result;
}


BOOL
Init_Log (
    HWND Parent
    )

/*++

Routine Description:

  Init_Log initializes the log system calling the worker pInitLog. This function
  should be only called once

Arguments:

  Parent  - Specifies the initial parent window for all popups.  If NULL,
            the popups are suppressed.  Callers can use LogReInit to change
            the parent window handle at any time.

Return Value:

  TRUE if log system successfully initialized

--*/

{
    return pInitLog (&Parent, NULL, TRUE);
}


BOOL
LogReInit (
    IN      HWND *NewParent,           OPTIONAL
    OUT     HWND *OrgParent            OPTIONAL
    )

/*++

Routine Description:

  LogReInit re-initializes the log system calling the worker pInitLog.
  This function may be called any number of times, but only after Init_Log

Arguments:

  NewParent - Specifies the new parent handle.

  OrgParent - Receives the old parent handle.

Return Value:

  TRUE if log system was successfully re-initialized

--*/

{
    return pInitLog (NewParent, OrgParent, FALSE);
}


VOID
Exit_Log (
    VOID
    )

/*++

Routine Description:

  Exit_Log cleans up any resources used by the log system

Arguments:

  none

Return Value:

  none

--*/

{

#ifdef DEBUG

    if (g_DebugLogPathA) {
        g_DebugLogPathA = NULL;
    }

#endif

#ifdef PROGRESS_BAR
    if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
        CloseHandle (g_ProgressBarLog);
        g_ProgressBarLog = INVALID_HANDLE_VALUE;
    }
#endif

    if (g_TypeSt) {
        //StringTableDestroy(g_TypeSt);
        g_TypeSt = NULL;
    }

    g_OutDestAll = OD_UNDEFINED;
    g_OutDestDefault = OD_UNDEFINED;
}


/*++

Routine Description:

  LogA and LogW preserve the last error code; they call the helpers
  pFormatAndWriteMsgA and pFormatAndWriteMsgW respectivelly.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgA (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgW (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!Condition) {
        return;
    }

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgA (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!Condition) {
        return;
    }

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgW (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title         OPTIONAL
    )
{
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];

    StringCopyByteCountA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        Title = Type;
    }

    StringCopyByteCountA (formattedMsg, Title, sizeof (formattedMsg) - sizeof (S_COLUMNDOUBLELINEA));
    StringCatA (formattedMsg, S_COLUMNDOUBLELINEA);

    pRawWriteLogOutputA (Type, NULL, formattedMsg);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title        OPTIONAL
    )
{
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];

    StringCopyCharCountA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        KnownSizeAtoW (typeW, Type);
        Title = typeW;
    }

    StringCopyCharCountW (formattedMsg, Title, sizeof (formattedMsg) - sizeof (S_COLUMNDOUBLELINEW));
    StringCatW (formattedMsg, S_COLUMNDOUBLELINEW);

    pRawWriteLogOutputW (Type, NULL, formattedMsg);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogLineA (
    IN      PCSTR Line
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCSTR p;

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyByteCountA (output, Line, sizeof (output) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = _mbsstr (output, S_NEWLINEA); p; p = _mbsstr (p + NEWLINE_CHAR_COUNTA, S_NEWLINEA)) {
        if (p[NEWLINE_CHAR_COUNTA] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        StringCatA (output, S_NEWLINEA);
    }

    pRawWriteLogOutputA (g_LastType, NULL, output);
}


VOID
LogLineW (
    IN      PCWSTR Line
    )
{
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCWSTR p;

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyCharCountW (output, Line, sizeof (output) / sizeof (WCHAR) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = wcsstr (output, S_NEWLINEW); p; p = wcsstr (p + NEWLINE_CHAR_COUNTW, S_NEWLINEW)) {
        if (p[NEWLINE_CHAR_COUNTW] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        StringCatW (output, S_NEWLINEW);
    }

    pRawWriteLogOutputW (g_LastType, NULL, output);
}


VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text);
}


VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text);
}


VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    )
{
    g_SuppressAllPopups = SuppressOn;
}


#ifdef PROGRESS_BAR

VOID
_cdecl
LogTime (
    IN      PCSTR Format,
    ...
    )
{
    DWORD currentTickCount;
    CHAR msg[OUTPUT_BUFSIZE_LARGE];
    PSTR appendPos;
    va_list args;

    PushError();

    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    appendPos = msg + vsprintf (msg, Format, args);
    va_end (args);
    sprintf (
        appendPos,
        "\t%lu\t%lu\r\n",
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
        WriteFileStringA (g_ProgressBarLog, msg);
    }

    g_LastTickCount = currentTickCount;

    PopError();
}

#else // !PROGRESS_BAR

#ifdef DEBUG

/*++

Routine Description:

  DebugLogTimeA and DebugLogTimeW preserve the last error code;
  they append the current date and time to the formatted message,
  then call LogA and LogW to actually process the message.

Arguments:

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    )
{
    CHAR msg[OUTPUT_BUFSIZE_LARGE];
    CHAR date[OUTPUT_BUFSIZE_SMALL];
    CHAR ttime[OUTPUT_BUFSIZE_SMALL];
    PSTR appendPos, end;
    DWORD currentTickCount;
    va_list args;

    if (!g_DoLog) {
        return;
    }

    PushError();

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            date,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (date,"** Error retrieving date. **");
    }

    if (!GetTimeFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            ttime,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (ttime,"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }


    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    appendPos = msg + _vsnprintf (msg, OUTPUT_BUFSIZE_LARGE, Format, args);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    end = msg + OUTPUT_BUFSIZE_LARGE;
    _snprintf(
        appendPos,
        ((UBINT)end - (UBINT)appendPos) / (sizeof (CHAR)),
        "\nCurrent Date and Time: %s %s\n"
        "Milliseconds since last DEBUGLOGTIME call : %u\n"
        "Milliseconds since first DEBUGLOGTIME call: %u\n",
        date,
        ttime,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogA (DBG_TIME, "%s", msg);

    PopError();
}


VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    )
{
    WCHAR msgW[OUTPUT_BUFSIZE_LARGE];
    WCHAR dateW[OUTPUT_BUFSIZE_SMALL];
    WCHAR timeW[OUTPUT_BUFSIZE_SMALL];
    PCWSTR formatW;
    PWSTR appendPosW, endW;
    DWORD currentTickCount;
    va_list args;

    if (!g_DoLog) {
        return;
    }

    PushError();

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            dateW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (dateW, L"** Error retrieving date. **");
    }

    if (!GetTimeFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            timeW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (timeW, L"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    formatW = ConvertAtoW (Format);
    appendPosW = msgW + _vsnwprintf (msgW, OUTPUT_BUFSIZE_LARGE, formatW, args);
    FreeConvertedStr (formatW);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    endW = msgW + OUTPUT_BUFSIZE_LARGE;
    _snwprintf(
        appendPosW,
        ((UBINT)endW - (UBINT)appendPosW) / (sizeof (WCHAR)),
        L"\nCurrent Date and Time: %s %s\n"
        L"Milliseconds since last DEBUGLOGTIME call : %u\n"
        L"Milliseconds since first DEBUGLOGTIME call: %u\n",
        dateW,
        timeW,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogW (DBG_TIME, "%s", msgW);

    PopError();
}

#endif // DEBUG

#endif // PROGRESS_BAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\hash.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    jimschm     23-Nov-1999  Removed setup api compatibility, fixed enum
                             to be insertion order
    ovidiut     14-Oct-1999  New coding conventions + Win64 compliance.
    marcw        2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_HASH    "HashTable"

//
// Strings
//

#define S_HASHTABLE "HashTable"

//
// Constants
//

#define BUCKETS                 1009
#define HASHTABLE_SIGNATURE     0x122398ff

//
// Macros
//

#ifdef DEBUG
    #define ASSERT_TABLE_IS_VALID(table)        MYASSERT(pTableIsValid(table))
#else
    #define ASSERT_TABLE_IS_VALID(table)
#endif

//
// Types
//

typedef struct _tagBUCKETITEM {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    WORD StringSize;
    // string follows StringSize
    // optional data follows string
} BUCKETITEM, *PBUCKETITEM;

typedef struct {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    PVOID String;
    // optional data follows struct
} BUCKETITEM_EXTERN_STR, *PBUCKETITEM_EXTERN_STR;

typedef struct {
    DWORD Signature;
    BOOL Unicode;
    BOOL ExternalStrings;
    PMHANDLE Pool;
    PBUCKETITEM *Bucket;
    PBUCKETITEM FirstLink;
    PBUCKETITEM LastLink;
    UINT ExtraDataSize;
    UINT MinimumStringBytes;
    UINT MaximumStringBytes;
    UINT Buckets;
} HASHTABLESTRUCT, *PHASHTABLESTRUCT;


//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



#ifdef DEBUG

BOOL
pTableIsValid (
    IN      HASHTABLE Table
    )
{
    BOOL b = TRUE;

    if (!Table) {
        return FALSE;
    }

    __try {
        if (((PHASHTABLESTRUCT) Table)->Signature != HASHTABLE_SIGNATURE) {
            b = FALSE;
        }
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#endif


/*++

Routine Description:

  pComputeHashValue adds all the character values of the string, shifting to
  maintain order.

Arguments:

  String - Specifies the string to compute the hash value for

Return Value:

  The hash value, within the range of 0 to BUCKETS - 1.

--*/

UINT
pComputeHashValueA (
    IN      PCSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputeHashValueW (
    IN      PCWSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueA (
    IN      PCSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCSTR end;

    end = (PCSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueW (
    IN      PCWSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


HASHTABLE
HtAllocExAW (
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT Buckets
    )

/*++

Routine Description:

  AllocateHashTableEx creates a hash table.  If ExtraDataSize is non-zero,
  each hash table entry gets an allocation of ExtraDataSize added to it.

Arguments:

  Unicode - Specifies TRUE to allocate a UNICODE hash table, or FALSE to
            allocate an ANSI table.  None of the routines in this file do any
            sort of UNICODE/ANSI converstion.

  ExternalStrings - Specifies TRUE if the strings belong to memory maintained
                    by the caller

  ExtraDataSize - Specifies the size of binary data associated with the
                  table item, or 0 for none.

Return Value:

  A handle to the string table.

--*/

{
    PHASHTABLESTRUCT hashTable;
    PMHANDLE pool;

    if (!Buckets) {
        Buckets = BUCKETS;
    }

    pool = PmCreateNamedPool (S_HASHTABLE);
    MYASSERT (pool);

    hashTable = (PHASHTABLESTRUCT) PmGetAlignedMemory (
                                        pool,
                                        sizeof (HASHTABLESTRUCT) + (sizeof (PBUCKETITEM) * Buckets)
                                        );
    MYASSERT (hashTable);

    hashTable->Signature = HASHTABLE_SIGNATURE;
    hashTable->Unicode = Unicode;
    hashTable->ExternalStrings = ExternalStrings;
    hashTable->Pool = pool;
    hashTable->Bucket = (PBUCKETITEM *) ((PBYTE) hashTable + sizeof (HASHTABLESTRUCT));
    hashTable->FirstLink = NULL;
    hashTable->LastLink = NULL;
    hashTable->ExtraDataSize = ExtraDataSize;
    hashTable->MinimumStringBytes = (UINT) -1;
    hashTable->MaximumStringBytes = 0;
    hashTable->Buckets = Buckets;

    //
    // Zero out all of the bucket structures.
    //
    ZeroMemory (hashTable->Bucket, sizeof (PBUCKETITEM) * Buckets);

    return (HASHTABLE) hashTable;
}


VOID
HtFree (
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  HtFree releases all resources associated with a string table.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    if (table) {
        ASSERT_TABLE_IS_VALID (HashTable);
        PmDestroyPool (table->Pool);
    }
}


PBUCKETITEM
pHtFindStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindString implements the hash table lookup routine.  It returns the
  pointer to the bucket item or NULL if the item was not found.

Arguments:

  HashTable     - Specifies the handle to the hash table
  String        - Specifies the string to find.  If this string is
                  case-insensitive but has already been lowercased, then make
                  sure to pass TRUE in the CaseSensitive argument.
  ExtraData     - Specifies the bytes to be copied to the hash table entry.
  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  otherwise.
  OutHashValue  - Receives the hash value.  This is non optional for
                  efficiency.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!CaseSensitive) {
        dupStr = DuplicateTextA (String);
        (void) _mbslwr (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueA (String, table->Buckets);

    item = table->Bucket[hashValue];

    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        item = item->Next;
    }

    if (item && ExtraData) {
        (void) HtGetStringData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraData,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCWSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!CaseSensitive) {
        dupStr = DuplicateTextW (String);
        (void) _wcslwr (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueW (String, table->Buckets);

    item = table->Bucket[hashValue];
    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        item = item->Next;
    }

    if (item && ExtraData) {
        (void) HtGetStringData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraData,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindPrefix implements a hash table lookup routine that tests each hash
  table entry, character-by-character, until a match is found, or until the
  hash table maximum is reached.  It returns the pointer to the bucket item or
  NULL if the item was not found.

Arguments:

  HashTable     - Specifies the handle to the hash table
  String        - Specifies the string to find.  If this string is
                  case-insensitive but has already been lowercased, then make
                  sure to pass TRUE in the CaseSensitive argument.
  BufferEnd     - Specifies the end of the string buffer, which may be longer
                  than all entries in the hash table, or it may be shorter.
  ExtraData     - Specifies the bytes to be copied to the hash table entry.
  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  otherwise.
  OutHashValue  - Receives the hash value.  This is non optional for
                  efficiency.  If pHtFindPrefix does not find a match,
                  this value will be set to zero.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCSTR p1, p2;
    PCSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    UINT currentBytes;
    PCSTR shortestEnd;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!CaseSensitive) {
        dupStr = AllocTextA (maxBytes / sizeof (CHAR));
        StringCopyByteCountA (dupStr, String, maxBytes + sizeof (CHAR));
        _mbslwr (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd = _mbsinc (shortestEnd);
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueA (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (CHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd = _mbsdec2 (String, BufferEnd);
    }

    if (item && ExtraData) {
        (void) HtGetStringData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraData,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCWSTR p1, p2;
    PCWSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    PCWSTR shortestEnd;
    UINT currentBytes;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!CaseSensitive) {
        dupStr = AllocTextW (maxBytes / sizeof (WCHAR));
        StringCopyByteCountW (dupStr, String, maxBytes + sizeof (WCHAR));
        _wcslwr (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCWSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCWSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd++;
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueW (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (WCHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCWSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd--;
    }

    if (item && ExtraData) {
        (void) HtGetStringData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraData,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL CaseSensitive
    )

/*++

Routine Description:

  HtAddStringEx adds a string to the hash table, and copies ExtraData to the
  new hash table entry.  If String is already in the hash table, the ExtraData
  is updated.

Arguments:

  HashTable     - Specifies the handle to the hash table, as returned from
                  AllocateHashTable.
  String        - Specifies the string to add to the table
  ExtraData     - Specifies the source binary data to be copied to the hash
                  table entry
  CaseSensitive - Specifies TRUE if the string compares are case-sensitive,
                  or FALSE if they are case-insensitive.

Return Value:

  Returns the pointer to the bucket item allocated or update.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!CaseSensitive) {
        dupStr = DuplicateTextA (String);
        _mbslwr (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringA (HashTable, String, NULL, TRUE, &hashValue);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringA (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }
            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (CHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetStringData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    return rc;
}


HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PWSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!CaseSensitive) {
        dupStr = DuplicateTextW (String);
        _wcslwr (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringW (HashTable, String, NULL, TRUE, &hashValue);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringW (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR)  PmGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (WCHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetStringData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    return rc;
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable     - Specifies the hash table handle, as returned by
                  AllocateHashTable.
  String        - Specifies the string to find
  ExtraData     - Receives the extra data associated with the found item
  CaseSensitive - Specifies TRUE if the find should be case-sensitive, FALSE
                  if it should be case-insensitive.

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindStringA (HashTable, String, ExtraData, CaseSensitive, &dontCare);
}


HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindStringW (HashTable, String, ExtraData, CaseSensitive, &dontCare);
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable     - Specifies the hash table handle, as returned by
                  AllocateHashTable.
  String        - Specifies the string to find
  BufferEnd     - Specifies the end of the buffer for String
  ExtraData     - Receives the extra data associated with the found item
  CaseSensitive - Specifies TRUE if the find should be case-sensitive, FALSE
                  if it should be case-insensitive.

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixA (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraData,
                            CaseSensitive,
                            &dontCare
                            );
}


HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL CaseSensitive
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixW (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraData,
                            CaseSensitive,
                            &dontCare
                            );
}


BOOL
HtGetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    )

/*++

Routine Description:

  HtGetStringData gets the extra data associated with a bucket item.
  The caller must supply the ID as returned from HtFindStringEx or
  HtAddStringEx.  This routine is useful when ExtraData is large, and
  the normal find routine would be slow because of the CopyMemory code path.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data pointer (it does NOT copy the data to
              the buffer).

Return Value:

  TRUE if ExtraData was set, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externStrItem;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!Index) {
        return FALSE;
    }

    if (table->ExternalStrings) {

        externStrItem = (PBUCKETITEM_EXTERN_STR) Index;
        *ExtraData = (PCVOID) ((PBYTE) externStrItem + sizeof (PBUCKETITEM_EXTERN_STR));

    } else {

        item = (PBUCKETITEM) Index;
        *ExtraData = (PCVOID) ((PBYTE) item + sizeof (BUCKETITEM) + item->StringSize);

    }

    return TRUE;
}


BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    )

/*++

Routine Description:

  HtCopyStringData gets the extra data associated with a bucket item
  and copies it to the caller's buffer.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data

Return Value:

  TRUE if ExtraData was copied, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetStringData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) ExtraData,
        (PBYTE) storedDataPtr,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    )

/*++

Routine Description:

  HtSetStringData copies new extra data to the specified hash table entry.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Specifies the extra data

Return Value:

  TRUE if the item was updated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetStringData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) storedDataPtr,
        (PBYTE) ExtraData,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  EnumFirstHashTableString begins an enumeration of the hash table structure.
  The return order is random.  Also, do not modify the hash table while an
  enumeration is active.

Arguments:

  EnumPtr   - Receives the string, extra data and offset for the first item
              in the hash table.
  HashTable - Specifies the handle of the hash table to enumerate.

Return Value:

  TRUE if an item was enumerated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum UNICODE table with ANSI wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringA (EnumPtr);
}


BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum ANSI table with UNICODE wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringW (EnumPtr);
}


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextHashTableString continues an enumeration started by
  EnumFirstHashTableString.  Call the routine until it returns FALSE.

Arguments:

  EnumPtr - Specifies the structure of an active enumeration.  Receives
            updated string, extra data and offset members.

Return Value:

  TRUE if another item was enumerated, FALSE if no items remain.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetStringData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCWSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetStringData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  EnumHashTableWithCallback implements a setupapi-style enumerator.  The
  callback routine is called for each item in the string table, and if the
  callback routine returns FALSE, the enumeration ends.

Arguments:

  HashTable - Specifies the handle to the table to enumerate
  Proc      - Specifies the callback procedure address
  lParam    - Specifies a value to pass to the callback, and is intended only
              for use by the caller.

Return Value:

  Always TRUE.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMA e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringA (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                break;
            }
        } while (EnumNextHashTableStringA (&e));
    }

    return TRUE;
}


BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMW e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringW (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                break;
            }
        } while (EnumNextHashTableStringW (&e));
    }

    return TRUE;
}


PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCWSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\wnd.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wnd.c

Abstract:

    Utilities for window management

Author:

    Jim Schmidt (jimschm)   01-Feb-2000

Revision History:


--*/

//
// Includes
//

#include "pch.h"


#define DBG_WND         "Wnd"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCTA, *PFINDWINDOW_STRUCTA;

typedef struct {
    PCWSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCTW, *PFINDWINDOW_STRUCTW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
CALLBACK
pEnumWndProcA (
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

  A callback that is called for every top level window on the system.
  It is used with pFindParentWindow to locate a specific window.

Arguments:

  hwnd      - Specifies the handle of the current enumerated window
  lParam    - Specifies a pointer to a FINDWINDOW_STRUCTA variable that
              holds WindowTitle and ProcessId, and receives the
              handle if a match is found.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    CHAR title[MAX_MBCHAR_PATH];
    DWORD processId;
    PFINDWINDOW_STRUCTA p;
    BOOL match = FALSE;

    p = (PFINDWINDOW_STRUCTA) lParam;

    if (!GetWindowThreadProcessId (hwnd, &processId)) {
        DEBUGMSG ((DBG_WND, "Enumerated hwnd no longer valid"));
        return TRUE;
    }

    if (processId == p->ProcessId) {
        match = TRUE;
    }

    if (p->WindowTitle) {

        GetWindowTextA (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Testing window: %s, ID=%08Xh against %s, %08Xh",
            title,
            processId,
            p->WindowTitle,
            p->ProcessId
            ));

        match = match && StringMatchA (title, p->WindowTitle);
    }
    ELSE_DEBUGMSGA ((
        DBG_NAUSEA,
        "Testing window: Process ID=%08Xh against %08Xh",
        processId,
        p->ProcessId
        ));


    if (match) {
        p->Match = hwnd;

#ifdef DEBUG
        //
        // Get the window title for the following debug message
        //

        GetWindowTextA (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Window found: %s, ID=%u",
            title,
            processId
            ));
#endif

        return FALSE;           // stop enum

    }

    return TRUE;        // continue enum
}


BOOL
CALLBACK
pEnumWndProcW (
    HWND hwnd,
    LPARAM lParam
    )

{
    WCHAR title[MAX_MBCHAR_PATH];
    DWORD processId;
    PFINDWINDOW_STRUCTW p;
    BOOL match = FALSE;

    p = (PFINDWINDOW_STRUCTW) lParam;

    if (!GetWindowThreadProcessId (hwnd, &processId)) {
        DEBUGMSG ((DBG_WND, "Enumerated hwnd no longer valid"));
        return TRUE;
    }

    if (processId == p->ProcessId) {
        match = TRUE;
    }

    if (p->WindowTitle) {

        GetWindowTextW (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGW ((
            DBG_NAUSEA,
            "Testing window: %s, ID=%08Xh against %s, %08Xh",
            title,
            processId,
            p->WindowTitle,
            p->ProcessId
            ));

        match = match && StringMatchW (title, p->WindowTitle);
    }
    ELSE_DEBUGMSGW ((
        DBG_NAUSEA,
        "Testing window: Process ID=%08Xh against %08Xh",
        processId,
        p->ProcessId
        ));


    if (match) {
        p->Match = hwnd;

#ifdef DEBUG
        //
        // Get the window title for the following debug message
        //

        GetWindowTextW (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Window found: %s, ID=%u",
            title,
            processId
            ));
#endif

        return FALSE;           // stop enum

    }

    return TRUE;        // continue enum
}


HWND
FindWindowInProcessA (
    IN      DWORD ProcessId,
    IN      PCSTR WindowTitle          OPTIONAL
    )

/*++

Routine Description:

  Finds a window by enumerating all top-level windows, and checking the
  process id. The first one to match the optionally supplied title is used.

Arguments:

  ProcessId     - Specifies the ID of the process who owns the window.  If
                  zero is specified, NULL is returned.
  WindowTitle   - Specifies the name of the window to find.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    FINDWINDOW_STRUCTA findWndStruct;

    //
    // If no process ID, we cannot have a match
    //

    if (!ProcessId) {
        DEBUGMSG ((DBG_WND, "ProcessId == 0"));
        return NULL;
    }

    ZeroMemory (&findWndStruct, sizeof (findWndStruct));

    findWndStruct.WindowTitle = WindowTitle;
    findWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProcA, (LPARAM) &findWndStruct);

    return findWndStruct.Match;
}


HWND
FindWindowInProcessW (
    IN      DWORD ProcessId,
    IN      PCWSTR WindowTitle         OPTIONAL
    )
{
    FINDWINDOW_STRUCTW findWndStruct;

    //
    // If no process ID, we cannot have a match
    //

    if (!ProcessId) {
        DEBUGMSG ((DBG_WND, "ProcessId == 0"));
        return NULL;
    }

    ZeroMemory (&findWndStruct, sizeof (findWndStruct));

    findWndStruct.WindowTitle = WindowTitle;
    findWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProcW, (LPARAM) &findWndStruct);

    return findWndStruct.Match;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\unicode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    unicode.c

Abstract:

    Simplified Unicode-Ansi conversion functions.

    Externally exposed routines:
      In-Place Conversion:
        KnownSizeDbcsToUnicodeN
        KnownSizeUnicodeToDbcsN
        KnownSizeWtoA
        KnownSizeAtoW

      In-Place Conversion without nul checks:
        DirectDbcsToUnicodeN
        DirectUnicodeToDbcsN
        DirectAtoW
        DirectWtoA

      Length/pool options:
        DbcsToUnicodeN
        UnicodeToDbcsN
        DbcsToUnicode
        UnicodeToDbcs
        FreeConvertedPoolStr

      Simplified type conversions:
        ConvertWtoA
        ConvertAtoW
        FreeConvertedStr

      TCHAR routines that can be compiled both ways:
        CreateDbcs
        CreateUnicode
        DestroyDbcs
        DestroyUnicode

Author:

    Jim Schmidt (jimschm)   04-Aug-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.

    jimschm     15-Feb-1999 Eliminated MikeCo's routines, since they are
                            broken on FE
    jimschm     23-Sep-1998 Added in-place routines

--*/

#include "pch.h"
#include <locale.h>

extern PMHANDLE g_TextPool;
extern DWORD g_MigutilWCToMBFlags;

WORD g_GlobalCodePage = CP_ACP;

typedef VOID(WINAPI SETACP)(WORD CodePage);
typedef SETACP * PSETACP;

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    )
{
    PSETACP SetACP;
    HANDLE Lib;

    g_GlobalCodePage = CodePage;


    if (ISNT()) {
        Lib = LoadLibrary (TEXT("kernel32.dll"));
        if (Lib) {
            SetACP = (PSETACP) GetProcAddress (Lib, "SetCPGlobal");
            if (SetACP) {
                SetACP (CodePage);
            }

            FreeLibrary (Lib);
        }
    }

    SetThreadLocale (Locale);
    setlocale(LC_ALL,"");
}


VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    )
{
    if (CodePage) {
        if (g_GlobalCodePage == CP_ACP) {
            *CodePage = (WORD) GetACP();
        } else {
            *CodePage = g_GlobalCodePage;
        }
    }

    if (Locale) {
        *Locale = GetThreadLocale();
    }
}


PCSTR
RealUnicodeToDbcsN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS.

  BUGBUG: Currently supports the ANSI code page only.  Later we can fix this.

Arguments:

  Pool  - Specifies the pool where memory is allocated from.  If not specified,
          g_TextPool is used instead.

  StrIn - Specifies the inbound UNICODE string

  Chars - Specifies the number of characters, excluding the nul, to
          convert.

Return Value:

  A pointer to the ANSI string, or NULL if an error occurred.

--*/

{
    PSTR DbcsStr;
    DWORD Size;
    DWORD rc;

    if (!Pool) {
        Pool = g_TextPool;
    }

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    Size = (Chars + 1) * sizeof (WCHAR);

    DbcsStr = (PSTR) PmGetAlignedMemory (Pool, Size);
    if (!DbcsStr) {
        DEBUGMSG ((DBG_ERROR, "UnicodeToDbcsN could not allocate string"));
        return NULL;
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) Chars,           // wc input count
                     DbcsStr,
                     (INT) Size,
                     NULL,
                     NULL
                     );

    // Report error returns from WideCharToMultiByte
    if (!rc && Chars) {
        PushError();
        PmReleaseMemory (Pool, DbcsStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "UnicodeToDbcsN error caused memory to be released in pool; may cause harmless PoolMem warnings."
            ));

        return NULL;
    }

    *CharCountToPointerA (DbcsStr, Chars) = 0;

    return DbcsStr;
}


PCWSTR
RealDbcsToUnicodeN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a DBCS string to UNICODE.

  BUGBUG: Currently supports the ANSI code page only.  Later we can fix this.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string to be converted

  Chars     - Specifies the number of multibyte characters, excluding the nul,
              to convert.  If -1, all of StrIn will be converted.

Return Value:

  A pointer to the converted UNICODE string, or NULL if an error ocurred.

--*/

{
    PWSTR UnicodeStr;
    DWORD UnicodeStrBufLenBytes;
    DWORD WcharsConverted;
    DWORD StrInBytesToConvert;

    //
    // Find number of multi-byte characters to convert. Punt on case where
    // caller asks for more chars than available.
    //
    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountA (StrIn);
    }

    //
    // Count bytes to convert from the input string (excludes delimiter)
    //
    StrInBytesToConvert = (DWORD)(CharCountToPointerA(StrIn, Chars) - StrIn);

    //
    // Get output buffer size, in bytes, including delimiter
    //
    UnicodeStrBufLenBytes = (Chars + 1) * sizeof (WCHAR);

    if (!Pool) {
        Pool = g_TextPool;
    }

    //
    // Get buffer
    //
    UnicodeStr = (PWSTR) PmGetAlignedMemory (Pool, UnicodeStrBufLenBytes);
    if (!UnicodeStr) {
        DEBUGMSG ((DBG_ERROR, "DbcsToUnicodeN could not allocate string"));
        return NULL;
    }

    //
    // Convert
    //
    WcharsConverted = (DWORD) MultiByteToWideChar (
                                 g_GlobalCodePage,
                                 0,
                                 StrIn,
                                 (INT) StrInBytesToConvert,
                                 UnicodeStr,
                                 (INT) UnicodeStrBufLenBytes
                                 );

    //
    // Check for conversion error (>0 chars in, 0 chars out)
    //
    if (0 == WcharsConverted && 0 != Chars) {
        PushError();
        PmReleaseMemory (Pool, UnicodeStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "DbcsToUnicodeN error caused memory to be released in pool; may cause harmless	 warnings."
            ));

        return NULL;
    }

    //
    // Write delimiter on the output string
    //
    UnicodeStr[WcharsConverted] = 0;

    return UnicodeStr;
}


VOID
FreeConvertedPoolStr (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    )

/*++

Routine Description:

  Frees the memory allocated by UnicodeToDbcsN or DbcsToUnicodeN.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string that was returned by UnicodeToDebcsN or
              DbcsToUnicodeN.

Return Value:

  none

--*/

{
    if (!StrIn) {
        return;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    PmReleaseMemory (Pool, (PVOID) StrIn);
}


PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) Chars,               // wc input count
                     StrOut,
                     (INT) Chars * 2,
                     NULL,
                     NULL
                     );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeUnicodeToDbcsN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;
    DWORD StrInBytesToConvert;

    if (INVALID_CHAR_COUNT == Chars) {
        StrInBytesToConvert = ByteCountA (StrIn);
    } else {
        StrInBytesToConvert = (DWORD)(CharCountToPointerA (StrIn, Chars) - StrIn);
    }

    rc = (DWORD) MultiByteToWideChar (
                     g_GlobalCodePage,
                     0, // MB_ERR_INVALID_CHARS,
                     StrIn,
                     (INT) StrInBytesToConvert,
                     StrOut,
                     (INT) StrInBytesToConvert * 2
                     );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeDbcsToUnicodeN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the
  string.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountW (StrIn);
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) (Bytes / sizeof (WCHAR)),
                     StrOut,
                     (INT) Bytes,
                     NULL,
                     NULL
                     );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectUnicodeToDbcsN failed."
        ));

    return StrOut + rc;
}


PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the string.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountA (StrIn);
    }

    rc = (DWORD) MultiByteToWideChar (
                     g_GlobalCodePage,
                     0, // MB_ERR_INVALID_CHARS,
                     StrIn,
                     (INT) Bytes,
                     StrOut,
                     (INT) Bytes * 2
                     );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectDbcsToUnicodeN failed."
        ));

    return StrOut + rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\strings.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    A number of string utilities useful for any project

Author:

    Jim Schmidt (jimschm)   12-Sept-1996

Revisions:

    ovidiut     12-Jan-2000 Added GetNodePatternMinMaxLevels,PatternIncludesPattern
    ovidiut     14-Sep-1999 Updated for new coding conventions and Win64 compliance
    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     08-Jul-1999 IsPatternMatchEx
    jimschm     07-Jan-1999 GetFileExtensionFromPath fixed again, added
                            GetDotExtensionFromPath
    calinn      23-Sep-1998 GetFileExtensionFromPath bug fix
    calinn      29-Jan-1998 Fixed a bug in EnumNextMultiSz.
    calinn      11-Jan-1998 Added EnumFirstMultiSz and EnumNextMultiSz functions.
    marcw       15-Dec-1997 Added ExpandEnvironmentTextEx functions.
    marcw       14-Nov-1997 SlightJoinText revisions.
    jimschm     21-May-1997 AppendWack revisions
    marcw       24-Mar-1997 StringReplace functions.
    jimschm     14-Mar-1997 New critical section stuff, enhanced message resource
                            routines, C runtime extensions, registry root utils
    jimschm     26-Nov-1996 Added message resource tools.
    mikeco      01-Jul-1997 Add FreeStringResourcePtr Fns
    mikeco      29-Sep-1997 IsLeadByte wrapper for IsDBCSLeadByte


--*/


#include "pch.h"

//
// Includes
//

#include "utilsp.h"

#define DBG_STRINGS     "Strings"

//
// Strings
//

// None

//
// Constants
//

// Error stack size (normally only one or two, so 32 is relatively huge)
#define MAX_STACK           32
#define WACK_REPLACE_CHAR   0x02
#define DWORD_MAX           0xFFFFFFFFu

//
// Macros
//

// None

//
// Types
//

typedef enum {
    BEGIN_PATTERN,
    BEGIN_COMPOUND_PATTERN,
    BEGIN_PATTERN_EXPR,
    SAVE_EXACT_MATCH,
    SAVE_SEGMENT,
    LOOK_FOR_NUMBER,
    LOOK_FOR_INCLUDE,
    LOOK_FOR_EXCLUDE,
    ADVANCE_TO_END_OF_EXPR,
    PARSE_CHAR_EXPR_OR_END,
    SKIP_EXCLUDE_SET,
    CONDENSE_SET,
    PARSE_END_FOUND,
    SKIP_INCLUDE_SET,
    END_PATTERN_EXPR,
    PATTERN_DONE,
    PATTERN_ERROR
} PATTERNSTATE;


typedef struct {
    UINT char1;
    UINT char2;
    UINT result;
} DHLIST, *PDHLIST;

//
// Globals
//

CHAR EscapedCharsA[] = "?*\020<>,^";
WCHAR EscapedCharsW[] = L"?*\020<>,^";

DWORD g_dwErrorStack[MAX_STACK];
DWORD g_dwStackPos = 0;
DHLIST g_DHList[] = {{0xB3, 0xDE, 0x8394},
                     {0xB6, 0xDE, 0x834B},
                     {0xB7, 0xDE, 0x834D},
                     {0xB8, 0xDE, 0x834F},
                     {0xB9, 0xDE, 0x8351},
                     {0xBA, 0xDE, 0x8353},
                     {0xBB, 0xDE, 0x8355},
                     {0xBC, 0xDE, 0x8357},
                     {0xBD, 0xDE, 0x8359},
                     {0xBE, 0xDE, 0x835B},
                     {0xBF, 0xDE, 0x835D},
                     {0xC0, 0xDE, 0x835F},
                     {0xC1, 0xDE, 0x8361},
                     {0xC2, 0xDE, 0x8364},
                     {0xC3, 0xDE, 0x8366},
                     {0xC4, 0xDE, 0x8368},
                     {0xCA, 0xDE, 0x836F},
                     {0xCB, 0xDE, 0x8372},
                     {0xCC, 0xDE, 0x8375},
                     {0xCD, 0xDE, 0x8378},
                     {0xCE, 0xDE, 0x837B},
                     {0xCA, 0xDF, 0x8370},
                     {0xCB, 0xDF, 0x8373},
                     {0xCC, 0xDF, 0x8376},
                     {0xCD, 0xDF, 0x8379},
                     {0xCE, 0xDF, 0x837C},
                     {0x00, 0x00, 0x0000}};
extern OUR_CRITICAL_SECTION g_MessageCs;        // in main.c
extern PMHANDLE g_TextPool;                     // in main.c
PGROWBUFFER g_LastAllocTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    );

BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    );

//
// Macro expansion definition
//

// None

//
// Code
//

/*++

Routine Description:

  StringCopy implements lstrcpyA and a UNICODE version. We don't use the Win32
  api because of speed and because we want to compile lint-free.

Arguments:

  Destination - Receivies the string copy
  Source      - Specifies the string to copy

Return Value:

  None.

--*/

VOID
StringCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    PCSTR current = Source;
    PCSTR end;

    while (*current) {
        *Destination++ = *current++;
    }

    //
    // Make sure DBCS string is properly terminated
    //

    end = current;
    current--;

    while (current >= Source) {

        if (!IsLeadByte (*current)) {
            //
            // destEnd is correct
            //
            break;
        }

        current--;
    }

    if (!((end - current) & 1)) {
        Destination--;
    }

    *Destination = 0;
}


VOID
StringCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )
{
    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;
}


/*++

Routine Description:

  StringCopyByteCount implements lstrcpynA and a UNICODE version. We don't
  use the Win32 api because of speed and because we want to compile lint-free.

Arguments:

  Destination - Receivies the string copy
  Source      - Specifies the string to copy
  Count       - Specifies the maximum number of bytes to copy, including the
                nul terminator. If Count is zero, then not even a nul
                terminator is written.

Return Value:

  None.

--*/

VOID
StringCopyByteCountA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT Count
    )
{
    PCSTR end;
    PCSTR current;
    PSTR destEnd;

    if (Count >= sizeof (CHAR)) {

        current = Source;
        destEnd = Destination;

        end = (PCSTR) ((PBYTE) Source + Count - sizeof (CHAR));

        while (*current && current < end) {
            *destEnd++ = *current++;
        }

        //
        // If current has data left, we need to make sure a DBCS string
        // is properly terminated.
        //

        if (*current) {

            end = current;
            current--;

            while (current >= Source) {

                if (!IsLeadByte (*current)) {
                    //
                    // destEnd is correct
                    //
                    break;
                }

                current--;
            }

            if (!((end - current) & 1)) {
                destEnd--;
            }
        }

        *destEnd = 0;
    }
}


VOID
StringCopyByteCountW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT Count
    )
{
    PCWSTR end;

    if (Count < sizeof (WCHAR)) {
        DEBUGMSG_IF ((
            Count != 0,
            DBG_WHOOPS,
            "Buffer passed to StringCopyByteCountW is a fraction of one character"
            ));

        return;
    }

    end = (PCWSTR) ((PBYTE) Source + Count - sizeof (WCHAR));

    while (Source < end) {
        *Destination++ = *Source++;
    }

    *Destination = 0;
}


VOID
StringCopyByteCountABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )

/*++

Routine Description:

  StringCopyByteCountAB copies a string segment into a destination buffer,
  and limits the copy to a maximum buffer size.  The return string is always
  nul-terminated, unless the buffer is too small to even hold a nul character.

Arguments:

  Destination          - Receives the string starting at Start and ending one
                         character before End.
  Start                - Specifies the start of the string.
  End                  - Specifies the first character not to copy.  If End
                         is equal or less than Start, then Destination is set
                         to an empty string (assuming the buffer can hold at
                         least one character)
  MaxBytesToCopyIncNul - Specifies the size of Destination, in bytes, and
                         including the nul terminator.

Return Value:

  None.

--*/

{
    INT width;

#ifdef DEBUG
    PCSTR check;

    check = Start;
    while (check < End) {
        if (!(*check)) {
            DEBUGMSG ((DBG_WHOOPS, "StringCopyByteCountABA: Nul found between start and end"));
            break;
        }

        check++;
    }
#endif

    width = (INT) (End - Start) + sizeof (CHAR);

    if (width > sizeof (CHAR)) {
        StringCopyByteCountA (Destination, Start, min ((UINT) width, MaxBytesToCopyIncNul));
    } else if (MaxBytesToCopyIncNul >= sizeof (CHAR)) {
        *Destination = 0;
    }
}

VOID
StringCopyByteCountABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )
{
    INT width;

#ifdef DEBUG
    PCWSTR check;

    check = Start;
    while (check < End) {
        if (!(*check)) {
            DEBUGMSG ((DBG_WHOOPS, "StringCopyByteCountABW: Nul found between start and end"));
            break;
        }

        check++;
    }
#endif

    width = (INT) (End - Start) + sizeof (WCHAR);

    if (width > sizeof (WCHAR)) {
        StringCopyByteCountW (Destination, Start, min ((UINT) width, MaxBytesToCopyIncNul));
    } else if (MaxBytesToCopyIncNul >= sizeof (WCHAR)) {
        *Destination = 0;
    }
}



/*++

Routine Description:

  AllocTextEx allocates a block of memory from the specified pool, or g_TextPool
  if no pool is specified, and is designated specifically for text processing.
  The g_TextPool is initialized when migutil.lib loads up, and there is 64K of
  guaranteed workspace, which will grow as necessary.

Arguments:

  Pool - Specifies the pool to allocate memory from

  CountOfChars - Specifies the number of characters (not bytes) to allocate.  The
                 return pointer is a block of memory that can hold CountOfChars characters,
                 weather they are SBCS, DBCS or UNICODE.

Return Value:

  A pointer to the allocated memory, or NULL if the pool could not be expanded
  to hold the number of specified characters.

--*/

PSTR
RealAllocTextExA (
    IN      PMHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PSTR text;

    if (CountOfChars == 0) {
        return NULL;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    text = PmGetAlignedMemory (Pool, CountOfChars * sizeof (CHAR) * 2);

    if (text)
        text [0] = 0;

    return text;
}

PWSTR
RealAllocTextExW (
    IN      PMHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PWSTR text;

    if (CountOfChars == 0) {
        return NULL;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    text = PmGetAlignedMemory (Pool, CountOfChars * sizeof (WCHAR));

    if (text)
        text [0] = 0;

    return text;
}


/*++

Routine Description:

  FreeText frees the memory allocated by AllocText.  After all strings are freed,
  the block will be emptied but not deallocated.

  It is important NOT to leak memory, because a leak will cause the pool to
  expand, and non-empty pools cause memory fragmentation.

Arguments:

  Text - Specifies the text to free, as returned from AllocText, DuplicateText,
         DuplicateTextEx, etc...

Return Value:

  none

--*/

VOID
FreeTextExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Text          OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PmReleaseMemory (Pool, (PVOID) Text);
    }
}


VOID
FreeTextExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PmReleaseMemory (Pool, (PVOID) Text);
    }
}



/*++

Routine Description:

  DuplicateTextEx duplicates a text string and allocates additional space a
  caller needs to complete its processing.  Optionally, the caller receives
  a pointer to the nul of the duplicated string (to allow more efficient
  appends).

Arguments:

  Text - Specifies the text to duplicate

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated and expanded string, or NULL if g_TextPool
  could not be expanded to fit the duplicated string and extra characters.

--*/

PSTR
RealDuplicateTextExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    )
{
    PSTR buf;
    PSTR d;
    PCSTR s;

    buf = AllocTextExA (Pool, CharCountA (Text) + ExtraChars + 1);
    if (buf) {
        s = Text;
        d = buf;
        while (*s) {
            if (IsLeadByte (*s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}

PWSTR
RealDuplicateTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    )
{
    PWSTR buf;
    PWSTR d;
    PCWSTR s;

    buf = AllocTextExW (Pool, CharCountW (Text) + ExtraChars + 1);
    if (buf) {
        s = Text;
        d = buf;
        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}


/*++

Routine Description:

  JoinText duplicates String1 and appends String2 to it delimited with the optional delimiterstring.

Arguments:

  String1 - Specifies the text to duplciate

  String2 - Specifies the text to append to String1

  DelimiterString - Optionally specifies the string to place between string 1 and string 2.

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated string and extra characters.

--*/

PSTR
RealJoinTextExA (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR CenterString,     OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    )
{
    PSTR buf;
    PSTR end;
    PSTR d;
    PCSTR s;

    buf = DuplicateTextExA (
              Pool,
              String1,
              CharCountA (String2) + ExtraChars + (CenterString ? CharCountA (CenterString) : 0),
              &end
              );

    if (buf) {

        d = end;

        if (CenterString) {
            s = CenterString;
            while (*s) {
                if (IsLeadByte (*s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
            }
        }

        s = String2;
        while (*s) {
            if (IsLeadByte (*s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}


PWSTR
RealJoinTextExW (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    )
{
    PWSTR buf;
    PWSTR end;
    PCWSTR s;
    PWSTR d;

    buf = DuplicateTextExW (
              Pool,
              String1,
              CharCountW (String2) + ExtraChars + (CenterString ? CharCountW(CenterString) : 0),
              &end
              );

    if (buf) {
        d = end;

        if (CenterString) {
            s = CenterString;
            while (*s) {
                *d++ = *s++;
            }
        }

        s = String2;

        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}


/*++

Routine Description:

  ExpandEnvironmentTextEx takes a block of text containing zero or more environment variables
  (encoded in %'s) and returns the text with the environment variables expanded. The function
  also allows the caller to specify additional environment variables in an array and will use
  these variables before calling GetEnvironmentVariable.

  The returned text is allocated out of the Text pool and should be freed using FreeText().


Arguments:

  InString - The string containing environement variables to be processed.

  ExtraVars - Optional var pointing to an array of environment variables to be used to supersede
              or suppliment the system environment variables. Even entries in the list are the
              names of environment variables, odd entries there values.
              (e.g. {"name1","value1","name2","value2",...}


Return Value:

  An expanded string.

--*/


PWSTR
RealExpandEnvironmentTextExW (
    IN      PCWSTR InString,
    IN      PCWSTR * ExtraVars   OPTIONAL
    )
{

    PWSTR   rString             = NULL;
    PWSTR   newString           = NULL;
    PWSTR   envName             = NULL;
    PWSTR   envValue            = NULL;
    BOOL    inSubstitution      = FALSE;
    BOOL    ignoreNextPercent   = FALSE;
    BOOL    errorOccurred       = FALSE;
    BOOL    foundValue          = FALSE;
    BOOL    freeValue           = FALSE;
    PCWSTR  nextPercent         = NULL;
    PCWSTR  source              = NULL;
    PCWSTR  savedSource         = NULL;
    UINT    maxSize             = 0;
    UINT    curSize             = 0;
    UINT    index               = 0;
    UINT    size                = 0;


    if (!InString) {
        return NULL;
    }

    if (*InString == 0) {
        return DuplicateTextW (InString);
    }


    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize + 3 > maxSize) {

                maxSize += 1024;
                newString = AllocTextW (maxSize);

                if (!newString) {
                    DEBUGMSG((DBG_ERROR,"ExpandEnvironmentTextEx: Memory Error!"));
                    errorOccurred = TRUE;
                    __leave;
                }

                if (rString) {
                    //lint -e(671)
                    CopyMemory (newString, rString, (SIZE_T) ((UINT)curSize * sizeof(WCHAR)));
                    FreeTextW(rString);
                }

                rString = newString;

            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (*source == L'%' && !inSubstitution) {
                if (ignoreNextPercent) {
                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = wcschr(source + 1,L'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextW(nextPercent - source);

                        if(envName){

                            StringCopyByteCountABW (
                                envName,
                                source + 1,
                                nextPercent,
                                (UINT) ((UBINT)nextPercent - (UBINT)source)
                                );


                            //
                            // Try to find the variable.
                            //
                            foundValue = FALSE;
                            freeValue = FALSE;

                            if (ExtraVars) {

                                //
                                // Search through the list of extra vars passed in by the caller.
                                // Even entries of this list are env var names. Odd entries are env values.
                                // {envname1,envvalue1,envname2,envvalue2,...}
                                //
                                index = 0;
                                while (ExtraVars[index]) {

                                    if (StringIMatchW(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                        foundValue = TRUE;
                                        envValue = (PWSTR) ExtraVars[index + 1];
                                        break;
                                    }
                                    index +=2;
                                }
                            }

                            if (!foundValue) {
                                //
                                // Still haven't found the environment variable. Use GetEnvironmentString.
                                //
                                //
                                size = GetEnvironmentVariableW(envName,NULL,0);

                                if (!size) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                                } else {

                                    //
                                    // Create a buffer large enough to hold this value and copy it in.
                                    //
                                    envValue = AllocTextW(size);

                                    if (envValue && (size - 1) != GetEnvironmentVariableW(envName,envValue,size)) {
                                        errorOccurred = TRUE;
                                        DEBUGMSGW((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                    }
                                    else {
                                        foundValue = TRUE;
                                    }

                                    freeValue = TRUE;
                                }
                            }


                            if (foundValue) {
                                //
                                // Ok, we have a valid environment value. Need to copy this data over.
                                // To do this, we update and save the current source into old source, set source = to the envValue,
                                // and set the inSubstitution value so that we don't attempt to expand any percents within
                                // the value.
                                //
                                savedSource     = nextPercent + 1;
                                source          = envValue;
                                inSubstitution  = TRUE;
                            }
                            else {
                                DEBUGMSGW ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                                ignoreNextPercent = TRUE;
                            }

                            //
                            // We are done with the environment name at this time, so clean it up.
                            //
                            FreeTextW(envName);
                            envName = NULL;
                        }
                        ELSE_DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: AllocTextW: Failed to allocate memory."));
                    }
                    ELSE_DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }


            //
            // Copy over the current character.
            //

            rString[curSize++] = *source++; //lint !e613

            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) { //lint !e613
                        rString[curSize] = 0;   //lint !e613
                    }
                    if (freeValue) {
                        FreeTextW(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;   //lint !e613
                }
            }
        }
    }   //lint !e613
    __finally {

        DEBUGMSGW_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : L"NULL"));

        if (envName) {
            FreeTextW(envName);
        }
        if (envValue && freeValue) {
            FreeTextW(envValue);
        }

    }

    return rString;
}


PSTR
RealExpandEnvironmentTextExA (
    IN      PCSTR InString,
    IN      PCSTR * ExtraVars   OPTIONAL
    )
{

    PSTR   rString             = NULL;
    PSTR   newString           = NULL;
    PSTR   envName             = NULL;
    PSTR   envValue            = NULL;
    BOOL   inSubstitution      = FALSE;
    BOOL   ignoreNextPercent   = FALSE;
    BOOL   errorOccurred       = FALSE;
    BOOL   foundValue          = FALSE;
    BOOL   freeValue           = FALSE;
    PCSTR  nextPercent         = NULL;
    PCSTR  source              = NULL;
    PCSTR  savedSource         = NULL;
    UINT   maxSize             = 0;
    UINT   curSize             = 0;
    UINT   index               = 0;
    UINT   size                = 0;


    if (!InString) {
        return NULL;
    }

    if (*InString == 0) {
        return DuplicateTextA (InString);
    }

    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize + 3 > maxSize) {

                maxSize += 1024;
                newString = AllocTextA (maxSize);

                if (!newString) {
                    DEBUGMSG((DBG_ERROR,"ExpandEnvironmentTextEx: Memory Error!"));
                    errorOccurred = TRUE;
                    __leave;
                }

                if (rString) {
                    CopyMemory (newString, rString, curSize * sizeof(CHAR));    //lint !e671
                    FreeTextA(rString);
                }

                rString = newString;
            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (!IsLeadByte(*source) && *source == '%' && !inSubstitution) {

                if (ignoreNextPercent) {

                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = _mbschr(source + 1,'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextA(nextPercent - source);
                        if(envName){
                            StringCopyABA (envName, source+1, nextPercent);


                            //
                            // Try to find the variable.
                            //
                            foundValue = FALSE;
                            freeValue = FALSE;

                            if (ExtraVars) {

                                //
                                // Search through the list of extra vars passed in by the caller.
                                // Even entries of this list are env var names. Odd entries are env values.
                                // {envname1,envvalue1,envname2,envvalue2,...}
                                //
                                index = 0;
                                while (ExtraVars[index]) {

                                    if (StringIMatch(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                        foundValue = TRUE;
                                        envValue = (PSTR) ExtraVars[index + 1];
                                        break;
                                    }
                                    index +=2;
                                }
                            }

                            if (!foundValue) {
                                //
                                // Still haven't found the environment variable. Use GetEnvironmentString.
                                //
                                //
                                size = GetEnvironmentVariableA(envName,NULL,0);

                                if (!size) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                                }
                                else {

                                    //
                                    // Create a buffer large enough to hold this value and copy it in.
                                    //
                                    envValue = AllocTextA(size);
                                    freeValue = TRUE;

                                    if (envValue && (size - 1) != GetEnvironmentVariableA(envName,envValue,size)) {
                                        errorOccurred = TRUE;
                                        DEBUGMSGA((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                    }
                                    else {
                                        foundValue = TRUE;
                                    }
                                }
                            }




                            if (foundValue) {

                                //
                                // Ok, we have a valid environment value. Need to copy this data over.
                                // To do this, we update and save the current source into old source, set source = to the envValue,
                                // and set the inSubstitution value so that we don't attempt to expand any percents within
                                // the value.
                                //
                                savedSource     = nextPercent + 1;
                                source          = envValue;
                                inSubstitution  = TRUE;



                            }
                            else {
                                DEBUGMSGA ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                                ignoreNextPercent = TRUE;

                            }

                            //
                            // We are done with the environment name at this time, so clean it up.
                            //
                            FreeTextA(envName);
                            envName = NULL;
                        }
                        ELSE_DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: AllocTextA: Failed to allocate memory."));

                    }
                    ELSE_DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }



            //
            // Copy over the current character.
            //
            if (IsLeadByte(*source)) {  //lint !e613
                rString[curSize++] = *source++; //lint !e613
            }
            rString[curSize++] = *source++; //lint !e613


            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) { //lint !e613
                        rString[curSize] = 0;   //lint !e613
                    }
                    if (freeValue) {
                        FreeTextA(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;   //lint !e613
                }
            }
        }
    }   //lint !e613
    __finally {

        DEBUGMSGA_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : "NULL"));

        if (envName) {
            FreeTextA(envName);
        }
        if (envValue && freeValue) {
            FreeTextA(envValue);
        }

    }

    return rString;
}



/*++

Routine Description:

  AppendWack adds a backslash to the end of any string, unless the string
  already ends in a backslash.

  AppendDosWack adds a backslash, but only if the path does not already
  end in a backslash or colon.  AppendWack supports DOS naming
  conventions: it does not append a back-slash if the path is empty,
  ends in a colon or if it ends in a back-slash already.

  AppendUncWack supports UNC naming conventions: it does not append a
  backslash if the path is empty or if it ends in a backslash already.

  AppendPathWack supports both DOS and UNC naming conventions, and uses the
  UNC naming convention if the string starts with double-wacks.

Arguments:

  Str - A buffer that holds the path, plus additional space for another
        backslash.

Return Value:

  none

--*/

PSTR
AppendWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str)
        return Str;

    last = Str;

    while (*Str) {
        last = Str;
        Str = _mbsinc (Str);
    }

    if (*last != '\\') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendWackW (
    IN      PWSTR Str
    )
{
    PCWSTR last;

    if (!Str)
        return Str;

    if (*Str) {
        Str = GetEndOfStringW (Str);
        last = Str - 1;
    } else {
        last = Str;
    }

    if (*last != '\\') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendDosWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str || !(*Str))
        return Str;

    do {
        last = Str;
        Str = _mbsinc (Str);
    } while (*Str);

    if (*last != '\\' && *last != ':') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendDosWackW (
    IN      PWSTR Str
    )
{
    PWSTR last;

    if (!Str || !(*Str))
        return Str;

    Str = GetEndOfStringW (Str);
    last = Str - 1;

    if (*last != L'\\' && *last != L':') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendUncWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str || !(*Str))
        return Str;

    do {
        last = Str;
        Str = _mbsinc (Str);
    } while (*Str);

    if (*last != '\\') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendUncWackW (
    IN      PWSTR Str
    )
{
    PWSTR last;

    if (!Str || !(*Str))
        return Str;

    Str = GetEndOfStringW (Str);
    last = Str - 1;

    if (*last != L'\\') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendPathWackA (
    IN      PSTR Str
    )
{
    if (!Str) {
        return Str;
    }

    if (Str[0] == '\\' && Str[1] == '\\') {
        return AppendUncWackA (Str);
    }

    return AppendDosWackA (Str);
}


PWSTR
AppendPathWackW (
    IN      PWSTR Str
    )
{
    if (!Str) {
        return Str;
    }

    if (Str[0] == L'\\' && Str[1] == L'\\') {
        return AppendUncWackW (Str);
    }

    return AppendDosWackW (Str);
}


DWORD
pGetStringsTotalSizeA (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCSTR source;

    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        size += ByteCountA (source) + DWSIZEOF(CHAR);
    }

    return size;
}

DWORD
pGetStringsTotalSizeW (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCWSTR source;

    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        size += ByteCountW (source) + DWSIZEOF(WCHAR);
    }

    return size;
}


PSTR
pJoinPathsInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PSTR end;
    PSTR endMinusOne;
    PCSTR source;
    PCSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            endMinusOne = _mbsdec2 (p, end);
            if (endMinusOne) {
                if (_mbsnextc (source) == '\\') {
                    if (_mbsnextc (endMinusOne) == '\\') {
                        source++;
                    }
                } else {
                    if (_mbsnextc (endMinusOne) != '\\') {
                        *end = '\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = StringCatA (end, source);
        }
        counter++;
    }

    return end;
}

PWSTR
pJoinPathsInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PWSTR end;
    PWSTR endMinusOne;
    PCWSTR source;
    PCWSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            endMinusOne = end > p ? end - 1 : NULL;
            if (endMinusOne) {
                if (*source == L'\\') {
                    if (*endMinusOne == L'\\') {
                        source++;
                    }
                } else {
                    if (*endMinusOne != L'\\') {
                        *end = L'\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = StringCatW (end, source);
        }
        counter++;
    }

    return end;
}


PSTR
_cdecl
RealJoinPathsInPoolExA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    DWORD size;
    PSTR dest;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    dest = (PSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pJoinPathsInBufferA (dest, args);
    va_end (args);

    return dest;
}


PWSTR
_cdecl
RealJoinPathsInPoolExW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    DWORD size;
    PWSTR dest;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    dest = (PWSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);
    va_start (args, Pool);
    pJoinPathsInBufferW (dest, args);
    va_end (args);

    return dest;
}


BOOL
JoinPathsExA (
    IN OUT      PGROWBUFFER Gb,
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (size == 0) {
        return FALSE;
    }

    end = (PSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pJoinPathsInBufferA (end, args);
    va_end (args);

    //
    // adjust Gb->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Gb->Buf && (PBYTE)(end + 1) <= Gb->Buf + Gb->End);
    Gb->End = (DWORD)((PBYTE)(end + 1) - Gb->Buf);

    return TRUE;
}

BOOL
JoinPathsExW (
    IN OUT      PGROWBUFFER Gb,
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (size == 0) {
        return FALSE;
    }

    end = (PWSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pJoinPathsInBufferW (end, args);
    va_end (args);

    //
    // adjust Gb->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Gb->Buf && (PBYTE)(end + 1) <= Gb->Buf + Gb->End);
    Gb->End = (DWORD)((PBYTE)(end + 1) - Gb->Buf);

    return TRUE;
}


PSTR
pBuildPathInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PCSTR source;
    INT counter;

    *Buffer = 0;

    counter = 0;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            *Buffer++ = '\\';
            *Buffer = 0;
        }
        Buffer = StringCatA (Buffer, source);
        counter++;
    }

    return Buffer;
}

PWSTR
pBuildPathInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PCWSTR source;
    INT counter;

    *Buffer = 0;

    counter = 0;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            *Buffer++ = L'\\';
            *Buffer = 0;
        }
        Buffer = StringCatW (Buffer, source);
        counter++;
    }

    return Buffer;
}


DWORD
BuildPathA (
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    va_start (args, SizeInBytes);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return 0;
    }

    if (!Buffer) {
        return size;
    }

    if (SizeInBytes < size) {
        //
        // buffer too small
        //
        return 0;
    }

    va_start (args, SizeInBytes);
    end = pBuildPathInBufferA (Buffer, args);
    va_end (args);

    MYASSERT (size == (DWORD)((PBYTE)(end + 1) - (PBYTE)Buffer));
    return size;
}

DWORD
BuildPathW (
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    va_start (args, SizeInBytes);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return 0;
    }

    if (!Buffer) {
        return size;
    }

    if (SizeInBytes < size) {
        //
        // buffer too small
        //
        return 0;
    }

    va_start (args, SizeInBytes);
    end = pBuildPathInBufferW (Buffer, args);
    va_end (args);

    MYASSERT (size == (DWORD)((PBYTE)(end + 1) - (PBYTE)Buffer));
    return size;
}


BOOL
BuildPathExA (
    IN OUT  PGROWBUFFER Gb,
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return FALSE;
    }

    end = (PSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pBuildPathInBufferA (end, args);
    va_end (args);

    MYASSERT ((PBYTE)(end + 1) == Gb->Buf + Gb->End);
    return (size != 0);
}

BOOL
BuildPathExW (
    IN OUT  PGROWBUFFER Gb,
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return FALSE;
    }

    end = (PWSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pBuildPathInBufferW (end, args);
    va_end (args);

    MYASSERT ((PBYTE)(end + 1) == Gb->Buf + Gb->End);
    return (size != 0);
}


PSTR
RealBuildPathInPoolA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    PSTR dest;
    DWORD size;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return NULL;
    }

    dest = (PSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pBuildPathInBufferA (dest, args);
    va_end (args);

    return dest;
}

PWSTR
RealBuildPathInPoolW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    PWSTR dest;
    DWORD size;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return NULL;
    }

    dest = (PWSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pBuildPathInBufferW (dest, args);
    va_end (args);

    return dest;
}


PSTR
RealAllocPathStringA (
    IN      DWORD Tchars
    )
{
    PSTR str;

    if (Tchars == 0) {
        Tchars = MAX_MBCHAR_PATH;
    }

    str = (PSTR) PmGetAlignedMemory (g_PathsPool, Tchars);

    if (str)
        str [0] = 0;

    return str;
}


PWSTR
RealAllocPathStringW (
    IN      DWORD Tchars
    )
{
    PWSTR str;

    if (Tchars == 0) {
        Tchars = MAX_WCHAR_PATH;
    }

    str = (PWSTR) PmGetAlignedMemory (g_PathsPool, Tchars * sizeof (WCHAR));

    if (str)
        str [0] = 0;

    return str;
}

VOID
RealSplitPathA (
    IN      PCSTR Path,
    OUT     PSTR *DrivePtr,
    OUT     PSTR *PathPtr,
    OUT     PSTR *FileNamePtr,
    OUT     PSTR *ExtPtr
    )
{
    CHAR drive[_MAX_DRIVE];
    CHAR dir[_MAX_DIR];
    CHAR fileName[_MAX_FNAME];
    CHAR ext[_MAX_EXT];

    _splitpath (Path, drive, dir, fileName, ext);

    if (DrivePtr) {
        *DrivePtr = PmDuplicateStringA (g_PathsPool, drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PmDuplicateStringA (g_PathsPool, dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PmDuplicateStringA (g_PathsPool, fileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PmDuplicateStringA (g_PathsPool, ext);
        MYASSERT (*ExtPtr);
    }
}


VOID
RealSplitPathW (
    IN      PCWSTR Path,
    OUT     PWSTR *DrivePtr,
    OUT     PWSTR *PathPtr,
    OUT     PWSTR *FileNamePtr,
    OUT     PWSTR *ExtPtr
    )
{
    WCHAR drive[_MAX_DRIVE];
    WCHAR dir[_MAX_DIR];
    WCHAR fileName[_MAX_FNAME];
    WCHAR ext[_MAX_EXT];

    _wsplitpath (Path, drive, dir, fileName, ext);

    if (DrivePtr) {
        *DrivePtr = PmDuplicateStringW (g_PathsPool, drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PmDuplicateStringW (g_PathsPool, dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PmDuplicateStringW (g_PathsPool, fileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PmDuplicateStringW (g_PathsPool, ext);
        MYASSERT (*ExtPtr);
    }
}


PSTR
RealDuplicatePathStringA (
    IN      PCSTR Path,
    IN      DWORD ExtraBytes
    )
{
    PSTR str;

    str = PmGetAlignedMemory (
                g_PathsPool,
                SizeOfStringA (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyA (str, Path);

    return str;
}


PWSTR
RealDuplicatePathStringW (
    IN      PCWSTR Path,
    IN      DWORD ExtraBytes
    )
{
    PWSTR str;

    str = PmGetAlignedMemory (
                g_PathsPool,
                SizeOfStringW (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyW (str, Path);

    return str;
}


BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    )
{
    DWORD bufferSize;
    DWORD pathSize;
    PSTR  currPathEnd;

    if (PathEnum == NULL) {
        return FALSE;
    }
    bufferSize = pathSize = GetEnvironmentVariable (TEXT("PATH"), NULL, 0);
    bufferSize *= 2;
    if (AdditionalPath != NULL) {
        bufferSize += SizeOfStringA (AdditionalPath);
    }
    if (SysDir != NULL) {
        bufferSize += SizeOfStringA (SysDir);
    }
    if (WinDir != NULL) {
        bufferSize += SizeOfStringA (WinDir);
    }
    PathEnum->BufferPtr = HeapAlloc (g_hHeap, 0, bufferSize);
    if (PathEnum->BufferPtr == NULL) {
        return FALSE;
    }
    PathEnum->BufferPtr [0] = 0;
    if (AdditionalPath != NULL) {
        StringCopyA (PathEnum->BufferPtr, AdditionalPath);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (SysDir != NULL) {
        StringCatA (PathEnum->BufferPtr, SysDir);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (WinDir != NULL) {
        StringCatA (PathEnum->BufferPtr, WinDir);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (IncludeEnvPath) {
        currPathEnd = GetEndOfStringA (PathEnum->BufferPtr);
        GetEnvironmentVariable (TEXT("PATH"), currPathEnd, pathSize);
    }

    PathEnum->PtrNextPath = PathEnum-> BufferPtr;
    return EnumNextPathA (PathEnum);
}


BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    PSTR currPathEnd;

    if (PathEnum->PtrNextPath == NULL) {
        AbortPathEnumA (PathEnum);
        return FALSE;
    }
    PathEnum->PtrCurrPath = PathEnum->PtrNextPath;

    PathEnum->PtrNextPath = _mbschr (PathEnum->PtrNextPath, ';');
    if (PathEnum->PtrNextPath == NULL) {
        return TRUE;
    }
    currPathEnd = PathEnum->PtrNextPath;
    PathEnum->PtrNextPath = _mbsinc (PathEnum->PtrNextPath);
    *currPathEnd = 0;
    if (*(PathEnum->PtrNextPath) == 0) {
        PathEnum->PtrNextPath = NULL;
    }

    if (*(PathEnum->PtrCurrPath) == 0) {
        //
        // We found an empty path segment. Skip it.
        //
        return EnumNextPathA (PathEnum);
    }

    return TRUE;
}


BOOL
AbortPathEnumA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    if (PathEnum->BufferPtr != NULL) {
        HeapFree (g_hHeap, 0, PathEnum->BufferPtr);
        PathEnum->BufferPtr = NULL;
    }
    return TRUE;
}


VOID
FreePathStringExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Path          OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PmReleaseMemory (Pool, (PSTR) Path);
    }
}


VOID
FreePathStringExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PmReleaseMemory (Pool, (PWSTR) Path);
    }
}



/*++

Routine Description:

  PushError and PopError push the error code onto a stack or pull the
  last pushed error code off the stack.  PushError uses GetLastError
  and PopError uses SetLastError to modify the last error value.

Arguments:

  none

Return Value:

  none

--*/


VOID
PushNewError (DWORD dwError)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = dwError;
    g_dwStackPos++;
}

VOID
PushError (VOID)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = GetLastError ();
    g_dwStackPos++;
}

DWORD
PopError (VOID)
{
    if (!g_dwStackPos)
        return GetLastError();

    g_dwStackPos--;
    SetLastError (g_dwErrorStack[g_dwStackPos]);

    return g_dwErrorStack[g_dwStackPos];
}



/*++

Routine Description:

  GetHexDigit is a simple base 16 ASCII to int convertor.  The
  convertor is case-insensitive.

Arguments:

  c - Character to convert

Return Value:

  Base 16 value corresponding to character supplied, or -1 if
  the character is not 0-9, A-F or a-f.

--*/

int
GetHexDigit (IN  int c)

{
    if (c >= '0' && c <= '9')
        return (c - '0');

    c = towlower ((wint_t) c);
    if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);

    return -1;
}


/*++

Routine Description:

  _tcsnum is similar to strtoul, except is figures out which base
  the number should be calculated from.  It supports decimal and
  hexadecimal numbers (using the 0x00 notation).  The return
  value is the decoded value, or 0 if a syntax error was found.

Arguments:

  szNum - Pointer to the string holding the number.  This number
          can be either decimal (a series of 0-9 characters), or
          hexadecimal (a series of 0-9, A-F or a-f characters,
          prefixed with 0x or 0X).

Return Value:

  The decoded unsigned long value, or zero if a syntax error was
  found.

--*/

DWORD
_mbsnum (IN PCSTR szNum)

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == '0' && tolower (szNum[1]) == 'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + (UINT)i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= '0' && *szNum <= '9')  {
            d = d * 10 + (*szNum - '0');
            szNum++;
        }
    }

    return d;
}


DWORD
_wcsnum (
    IN PCWSTR szNum
    )

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == L'0' && towlower (szNum[1]) == L'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + (UINT)i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= L'0' && *szNum <= L'9')  {
            d = d * 10 + (*szNum - L'0');
            szNum++;
        }
    }

    return d;
}


/*++

Routine Description:

  StringCat is a lstrcat-type routine. It returns the pointer to the end
  of a string instead of the beginning, is faster, and has the proper types
  to keep lint happy.

Arguments:

  Destination - A pointer to a caller-allocated buffer that may point
                anywhere within the string to append to
  Source      - A pointer to a string that is appended to Destination

Return Value:

  A pointer to the NULL terminator within the Destination string.

--*/

PSTR
StringCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    PCSTR current = Source;
    PCSTR end;

    //
    // Advance Destination to end of string
    //

    Destination = GetEndOfStringA (Destination);

    while (*current) {
        *Destination++ = *current++;    //lint !e613
    }

    //
    // Make sure DBCS string is properly terminated
    //

    end = current;
    current--;

    while (current >= Source) {

        if (!IsLeadByte (*current)) {
            //
            // destEnd is correct
            //
            break;
        }

        current--;
    }

    if (!((end - current) & 1)) {
        Destination--;  //lint !e794
    }

    *Destination = 0;   //lint !e794

    return Destination;
}


PWSTR
StringCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )

{
    // prevent NULL dereference
    if (!Destination)
        return NULL;

    //
    // Advance Destination to end of string
    //

    Destination = GetEndOfStringW (Destination);

    //
    // Copy string
    //

    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;

    return Destination;
}



/*++

Routine Description:

  _tcsistr is a case-insensitive version of _tcsstr.

Arguments:

  szStr    - A pointer to the larger string, which may hold szSubStr
  szSubStr - A pointer to a string that may be enclosed in szStr

Return Value:

  A pointer to the first occurance of szSubStr in szStr, or NULL if
  no match is found.

--*/


PCSTR
_mbsistr (PCSTR mbstrStr, PCSTR mbstrSubStr)

{
    PCSTR mbstrStart, mbstrStrPos, mbstrSubStrPos;
    PCSTR mbstrEnd;

    mbstrEnd = (PSTR) ((LPBYTE) mbstrStr + ByteCountA (mbstrStr) - ByteCountA (mbstrSubStr));

    for (mbstrStart = mbstrStr ; mbstrStart <= mbstrEnd ; mbstrStart = _mbsinc (mbstrStart)) {
        mbstrStrPos = mbstrStart;
        mbstrSubStrPos = mbstrSubStr;

        while (*mbstrSubStrPos &&
               _mbctolower ((MBCHAR) _mbsnextc (mbstrSubStrPos)) == _mbctolower ((MBCHAR) _mbsnextc (mbstrStrPos)))
        {
            mbstrStrPos = _mbsinc (mbstrStrPos);
            mbstrSubStrPos = _mbsinc (mbstrSubStrPos);
        }

        if (!(*mbstrSubStrPos))
            return mbstrStart;
    }

    return NULL;
}


PCWSTR
_wcsistr (PCWSTR wstrStr, PCWSTR wstrSubStr)

{
    PCWSTR wstrStart, wstrStrPos, wstrSubStrPos;
    PCWSTR wstrEnd;

    wstrEnd = (PWSTR) ((LPBYTE) wstrStr + ByteCountW (wstrStr) - ByteCountW (wstrSubStr));

    for (wstrStart = wstrStr ; wstrStart <= wstrEnd ; wstrStart++) {
        wstrStrPos = wstrStart;
        wstrSubStrPos = wstrSubStr;

        while (*wstrSubStrPos &&
               towlower (*wstrSubStrPos) == towlower (*wstrStrPos))
        {
            wstrStrPos++;
            wstrSubStrPos++;
        }

        if (!(*wstrSubStrPos))
            return wstrStart;
    }

    return NULL;
}

/*++

Routine Description:

  StringCompareAB compares a string against a string between to string
  pointers

Arguments:

  String - Specifies the string to compare

  Start - Specifies the start of the string to compare against

  end - Specifies the end of the string to compare against.  The character
        pointed to by End is not included in the comparision.

Return Value:

  Less than zero: String is numerically less than the string between Start and
                  End

  Zero: String matches the string between Start and End identically

  Greater than zero: String is numerically greater than the string between
                     Start and End

--*/

INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (_mbsnextc (String) != _mbsnextc (Start)) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return (INT) (_mbsnextc (Start) - _mbsnextc (String));
}

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (*String != *Start) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return *Start - *String;
}


BOOL
StringMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    )

/*++

Routine Description:

  StringMatchA is an optimized string compare.  Usually a comparison is used to
  see if two strings are identical, and the numeric releationships aren't
  important. This routine exploits that fact and does a byte-by-byte compare.

Arguments:

  String1 - Specifies the first string to compare
  String2 - Specifies the second string to compare

Return Value:

  TRUE if the strings match identically, FALSE otherwise.

--*/

{
    while (*String1) {
        if (*String1 != *String2) {
            return FALSE;
        }

        String1++;
        String2++;
    }

    if (*String2) {
        return FALSE;
    }

    return TRUE;
}


BOOL
StringMatchABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )

/*++

Routine Description:

  StringMatchABA is an optimized string compare.  Usually a comparison is
  used to see if two strings are identical, and the numeric releationships
  aren't important. This routine exploits that fact and does a byte-by-byte
  compare.

Arguments:

  String - Specifies the first string to compare
  Start  - Specifies the beginning of the second string to compare
  End    - Specifies the end of the second string to compare (points to one
           character beyond the last valid character of the second string)

Return Value:

  TRUE if the strings match identically, FALSE otherwise.  If End is equal
  or less than Start, the return value is always TRUE.

--*/

{
    while (*String && Start < End) {
        if (*String != *Start) {
            return FALSE;
        }

        String++;
        Start++;
    }

    if (Start < End && *Start) {
        return FALSE;
    }

    return TRUE;
}


INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (tolower ((INT)(_mbsnextc (String))) != tolower ((INT)(_mbsnextc (Start)))) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return (tolower ((INT)(_mbsnextc (Start))) - tolower ((INT)(_mbsnextc (String))));
}

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (towlower (*String) != towlower (*Start)) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return towlower (*Start) - towlower (*String);
}



VOID
_setmbchar (
    IN OUT  PSTR Str,
    IN      MBCHAR c
    )

/*++

Routine Description:

  _setmbchar sets the character at the specified string position, shifting
  bytes if necessary to keep the string in tact.

Arguments:

  Str -  String
  c   -  Character to set

Return Value:

  none

--*/

{
    if (c < 256) {
        if (IsLeadByte (*Str)) {
            //
            // Delete one byte from the string
            //

            MoveMemory (Str, Str+1, SizeOfStringA (Str+2) + 1);
        }

        *Str = (CHAR) c;
    } else {
        if (!IsLeadByte (*Str)) {
            //
            // Insert one byte in the string
            //

            MoveMemory (Str+1, Str, SizeOfStringA (Str));
        }

        *((WORD *) Str) = (WORD) c;
    }
}



/*++

Routine Description:

  GetNextRuleChar extracts the first character in the *p_szRule string,
  and determines the character value, decoding the ~xx~ syntax (which
  specifies any arbitrary value).

  GetNextRuleChar returns a complete character for SBCS and UNICODE, but
  it may return either a lead byte or non-lead byte for MBCS.  To indicate
  a MBCS character, two ~xx~ hex values are needed.

Arguments:

  p_szRule   - A pointer to a pointer; a caller-allocated buffer that
               holds the rule string.
  p_bFromHex - A pointer to a caller-allocated BOOL that receives TRUE
               when the return value was decoded from the <xx> syntax.

Return Value:

  The decoded character; *p_bFromHex identifies if the return value was

  a literal or was a hex-encoded character.

--*/


MBCHAR
GetNextRuleCharA (
    IN OUT  PCSTR *PtrToRule,
    OUT     BOOL *FromHex
    )
{
    MBCHAR ch;
    MBCHAR Value;
    INT i;
    PCSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (_mbsnextc (StartPtr) == '~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = _mbsnextc (*PtrToRule);
            *PtrToRule += 1;

            if (ch == '~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= '0' && ch <= '9') {
                Value += ch - '0';
            } else if (ch >= 'a' && ch <= 'f') {
                Value += ch - 'a' + 10;
            } else if (ch >= 'A' && ch <= 'F') {
                Value += ch - 'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGA ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = _mbsinc (StartPtr);
    return _mbsnextc (StartPtr);
}


WCHAR
GetNextRuleCharW (
    IN OUT  PCWSTR *PtrToRule,
    OUT     BOOL *FromHex
    )

{
    WCHAR ch;
    WCHAR Value;
    INT i;
    PCWSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (*StartPtr == L'~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = **PtrToRule;
            *PtrToRule += 1;

            if (ch == L'~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= L'0' && ch <= L'9') {
                Value += ch - L'0';
            } else if (ch >= L'a' && ch <= L'f') {
                Value += ch - L'a' + 10;
            } else if (ch >= L'A' && ch <= L'F') {
                Value += ch - L'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGW ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = StartPtr + 1;
    return *StartPtr;
}


/*++

Routine Description:

  DecodeRuleChars takes a complete rule string (szRule), possibly
  encoded with hex-specified character values (~xx~).  The output

  string contains unencoded characters.

Arguments:

  szRule    - A caller-allocated buffer, big enough to hold an
              unencoded rule.  szRule can be equal to szEncRule.
  szEncRule - The string holding a possibly encoded string.

Return Value:

  Equal to szRule.

--*/


PSTR
DecodeRuleCharsA (PSTR mbstrRule, PCSTR mbstrEncRule)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR) c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    } while (c);

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsW (PWSTR wstrRule, PCWSTR wstrEncRule)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    } while (c);

    return wstrOrgRule;
}


PSTR
DecodeRuleCharsABA (PSTR mbstrRule, PCSTR mbstrEncRule, PCSTR End)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (mbstrEncRule < End) {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR) c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    }

    *mbstrRule = 0;

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsABW (PWSTR wstrRule, PCWSTR wstrEncRule, PCWSTR End)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (wstrEncRule < End) {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    }

    *wstrRule = 0;

    return wstrOrgRule;
}



/*++

Routine Description:

  EncodeRuleChars takes an unencoded rule string (szRule), and
  converts it to a string possibly encoded with hex-specified
  character values (~xx~).  The output string contains encoded
  characters.

Arguments:

  szEncRule - A caller-allocated buffer, big enough to hold an
              encoded rule.  szEncRule CAN NOT be equal to szRule.
              One way to calculate a max buffer size for szEncRule
              is to use the following code:

                  allocsize = SizeOfString (szRule) * 6;

              In the worst case, each character in szRule will take
              six single-byte characters in szEncRule.  In the normal
              case, szEncRule will only be a few bytes bigger than
              szRule.

  szRule    - The string holding an unencoded string.

Return Value:

  Equal to szEncRule.

--*/

PSTR
EncodeRuleCharsA (PSTR mbstrEncRule, PCSTR mbstrRule)

{
    PSTR mbstrOrgRule;
    static CHAR mbstrExclusions[] = "[]<>\'*$|:?\";,%";
    MBCHAR c;

    mbstrOrgRule = mbstrEncRule;

    while (*mbstrRule)  {
        c = _mbsnextc (mbstrRule);

        if (!_ismbcprint (c) || _mbschr (mbstrExclusions, c)) {

            // Escape unprintable or excluded character
            wsprintfA (mbstrEncRule, "~%X~", c);
            mbstrEncRule = GetEndOfStringA (mbstrEncRule);
            mbstrRule = _mbsinc (mbstrRule);
        }
        else {
            // Copy multibyte character
            if (IsLeadByte (*mbstrRule)) {
                *mbstrEncRule = *mbstrRule;
                mbstrEncRule++;
                mbstrRule++;
            }

            *mbstrEncRule = *mbstrRule;
            mbstrEncRule++;
            mbstrRule++;
        }
    }

    *mbstrEncRule = 0;  //lint !e613

    return mbstrOrgRule;
}


PWSTR
EncodeRuleCharsW (PWSTR wstrEncRule, PCWSTR wstrRule)

{
    PWSTR wstrOrgRule;
    static WCHAR wstrExclusions[] = L"[]<>\'*$|:?\";,%";
    WCHAR c;

    wstrOrgRule = wstrEncRule;

    while (c = *wstrRule)   {   //lint !e720
        if (!iswprint (c) || wcschr (wstrExclusions, c)) {
            wsprintfW (wstrEncRule, L"~%X~", c);
            wstrEncRule = GetEndOfStringW (wstrEncRule);
        }
        else {
            *wstrEncRule = *wstrRule;
            wstrEncRule++;
        }

        wstrRule++;
    }

    *wstrEncRule = 0;

    return wstrOrgRule;
}


/*++

Routine Description:

  _tcsisprint is a string version of _istprint.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  Non-zero if szStr is made up only of printable characters.


--*/


int
_mbsisprint (PCSTR mbstrStr)

{
    while (*mbstrStr && _ismbcprint ((MBCHAR) _mbsnextc (mbstrStr))) {
        mbstrStr = _mbsinc (mbstrStr);
    }

    return *mbstrStr == 0;
}


int
_wcsisprint (PCWSTR wstrStr)

{
    while (*wstrStr && iswprint (*wstrStr)) {
        wstrStr++;
    }

    return *wstrStr == 0;
}


/*++

Routine Description:

  SkipSpace returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  A pointer to the first non-whitespace character in the string,
  or NULL if the string is made up of all whitespace characters
  or the string is empty.


--*/

PCSTR
SkipSpaceA (PCSTR mbstrStr)

{
    while (_ismbcspace ((MBCHAR) _mbsnextc (mbstrStr)))
        mbstrStr = _mbsinc (mbstrStr);

    return mbstrStr;
}


PCWSTR
SkipSpaceW (PCWSTR wstrStr)

{
    while (iswspace (*wstrStr))
        wstrStr++;

    return wstrStr;
}


/*++

Routine Description:

  SkipSpaceR returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

  This function is identical to SkipSpace except it works from
  right to left instead of left to right.

Arguments:

  StrBase - A pointer to the first character in the string
  Str     - A pointer to the end of the string, or NULL if the
            end is not known.

Return Value:

  A pointer to the first non-whitespace character in the string,
  as viewed from right to left, or NULL if the string is made up
  of all whitespace characters or the string is empty.


--*/

PCSTR
SkipSpaceRA (
    IN      PCSTR StrBase,
    IN      PCSTR Str           OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringA (StrBase);
    }

    if (*Str == 0) {    //lint !e613
        Str = _mbsdec2 (StrBase, Str);
        if (!Str) {
            return NULL;
        }
    }

    do {

        if (!_ismbcspace((MBCHAR) _mbsnextc(Str))) {
            return Str;
        }

    } while (Str = _mbsdec2(StrBase, Str)); //lint !e720

    return NULL;
}


PCWSTR
SkipSpaceRW (
    IN      PCWSTR StrBase,
    IN      PCWSTR Str          OPTIONAL
    )

{
    if (!StrBase) // prevent NULL dereference
        return NULL;
    if (!Str) {
        Str = GetEndOfStringW (StrBase);
    }

    if (*Str == 0) {
        Str--;
        if (Str < StrBase) {
            return NULL;
        }
    }

    do {
        if (!iswspace(*Str)) {
            return Str;
        }

    } while (Str-- != StrBase);

    return NULL;
}


/*++

Routine Description:

  TruncateTrailingSpace trims the specified string after the
  very last non-space character, or empties the string if it
  contains only space characters.  This routine uses isspace
  to determine what a space is.

Arguments:

  Str - Specifies string to process

Return Value:

  none

--*/

VOID
TruncateTrailingSpaceA (
    IN OUT  PSTR Str
    )
{
    PSTR LastNonSpace;
    PSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!_ismbcspace ((MBCHAR) _mbsnextc (Str))) {
            LastNonSpace = Str;
        }

        Str = _mbsinc (Str);
    }

    if (LastNonSpace) {
        *_mbsinc (LastNonSpace) = 0;
    } else {
        *OrgStr = 0;
    }
}

VOID
TruncateTrailingSpaceW (
    IN OUT  PWSTR Str
    )
{
    PWSTR LastNonSpace;
    PWSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!iswspace (*Str)) {
            LastNonSpace = Str;
        }

        Str++;
    }

    if (LastNonSpace) {
        *(LastNonSpace + 1) = 0;
    } else {
        *OrgStr = 0;
    }
}



/*++

Routine Description:

  IsPatternMatch compares a string against a pattern that may contain
  standard * or ? wildcards.

Arguments:

  wstrPattern  - A pattern possibly containing wildcards
  wstrStr      - The string to compare against the pattern

Return Value:

  TRUE when wstrStr and wstrPattern match when wildcards are expanded.
  FALSE if wstrStr does not match wstrPattern.

--*/

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    )
{

    MBCHAR chSrc, chPat;

    while (*strStr) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (strStr));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (strPattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (strStr)) == '*') {
                strStr = _mbsinc (strStr);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (strPattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchA (_mbsinc (strPattern), strStr)) {
                return TRUE;
            }

            // Allow any character and continue
            strStr = _mbsinc (strStr);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        strStr = _mbsinc (strStr);
        strPattern = _mbsinc (strPattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (strPattern) == '*') {
        strPattern = _mbsinc (strPattern);
    }
    if (_mbsnextc (strPattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    )

{
    WCHAR chSrc, chPat;

    while (*wstrStr) {
        chSrc = towlower (*wstrStr);
        chPat = towlower (*wstrPattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (wstrPattern[1] == L'*')
                wstrPattern++;

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (wstrPattern[1]);
            if (!chPat)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                wstrPattern++;
                if (IsPatternMatchW (wstrPattern, wstrStr))
                    return TRUE;

                // no, that didn't work, stick with star
                wstrPattern--;
            }

            //
            // Allow any character and continue
            //

            wstrStr++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        wstrPattern++;
        wstrStr++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *wstrPattern;
    if (chPat && (chPat != L'*' || wstrPattern[1]))
        return FALSE;

    return TRUE;
}

BOOL
IsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    MBCHAR chSrc, chPat;

    while (*Contained) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (Contained));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (Container));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Container)) == '*') {
                Container = _mbsinc (Container);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Container))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternContainedA (_mbsinc (Container), Contained)) {
                return TRUE;
            }

            // Allow any character and continue
            Contained = _mbsinc (Contained);
            continue;
        } else if (chPat == '?') {
            if (chSrc == '*') {
                return FALSE;
            }
        } else {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Contained = _mbsinc (Contained);
        Container = _mbsinc (Container);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Container) == '*') {
        Container = _mbsinc (Container);
    }
    if (_mbsnextc (Container)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    while (*Contained) {

        if (*Container == L'*') {

            // Skip all asterisks that are grouped together
            while (Container[1] == L'*') {
                Container++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!Container[1]) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternContainedW (Container + 1, Contained)) {
                return TRUE;
            }

            // Allow any character and continue
            Contained++;
            continue;
        } else if (*Container == L'?') {
            if (*Contained == L'*') {
                return FALSE;
            }
        } else {
            if (*Container != *Contained) {
                return FALSE;
            }
        }
        Contained++;
        Container++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (*Container == '*') {
        Container++;
    }
    if (*Container) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchAB compares a string against a pattern that may contain
  standard * or ? wildcards.  It only processes the string up to the
  specified end.

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{

    MBCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (Start));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (Pattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Start)) == '*') {
                Start = _mbsinc (Start);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Pattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchABA (_mbsinc (Pattern), Start, End)) {
                return TRUE;
            }

            // Allow any character and continue
            Start = _mbsinc (Start);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Start = _mbsinc (Start);
        Pattern = _mbsinc (Pattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Pattern) == '*') {
        Pattern = _mbsinc (Pattern);
    }

    if (_mbsnextc (Pattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )

{
    WCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = towlower (*Start);
        chPat = towlower (*Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (Pattern[1] == L'*') {
                Pattern++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (Pattern[1]);
            if (!chPat) {
                return TRUE;
            }

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                Pattern++;
                if (IsPatternMatchABW (Pattern, Start, End)) {
                    return TRUE;
                }

                // no, that didn't work, stick with star
                Pattern--;
            }

            //
            // Allow any character and continue
            //

            Start++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat) {
                return FALSE;
            }
        }

        //
        // Advance when pattern character matches string character
        //

        Pattern++;
        Start++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *Pattern;
    if (chPat && (chPat != L'*' || Pattern[1])) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchEx compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR String
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternA (Handle, String);

    DestroyParsedPatternA (Handle);

    return b;
}

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR String
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternW (Handle, String);

    DestroyParsedPatternW (Handle);

    return b;
}

/*++

Routine Description:

  IsPatternMatchExAB compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABA (Handle, Start, End);

    DestroyParsedPatternA (Handle);

    return b;
}

BOOL
IsPatternMatchExABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABW (Handle, Start, End);

    DestroyParsedPatternW (Handle);

    return b;
}

BOOL
pTestSetsA (
    IN      PCSTR Container,
    IN      PCSTR Contained,
    IN      BOOL ExcludeMode
    )
{
    MBCHAR ch;

    if (ExcludeMode) {
        if (!Contained) {
            return TRUE;
        }
        if (!Container) {
            return FALSE;
        }
    } else {
        if (!Container) {
            return TRUE;
        }
        if (!Contained) {
            return FALSE;
        }
    }

    while (*Contained) {
        ch = _mbsnextc (Contained);
        if (!pTestSetA (ch, Container, NULL)) {
            return FALSE;
        }
        Contained = _mbsinc (Contained);
    }
    return TRUE;
}

BOOL
pTestSetsW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained,
    IN      BOOL ExcludeMode
    )
{
    if (ExcludeMode) {
        if (!Contained) {
            return TRUE;
        }
        if (!Container) {
            return FALSE;
        }
    } else {
        if (!Container) {
            return TRUE;
        }
        if (!Contained) {
            return FALSE;
        }
    }

    while (*Contained) {
        if (!pTestSetW (*Contained, Container, NULL)) {
            return FALSE;
        }
        Contained ++;
    }
    return TRUE;
}

BOOL
pMatchSegmentA (
    IN      PSEGMENTA Source,
    IN      PSEGMENTA Destination
    )
{
    switch (Source->Type) {
    case SEGMENTTYPE_OPTIONAL:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            if (Source->Wildcard.MaxLen) {
                if ((Destination->Wildcard.MaxLen == 0) ||
                    (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen)
                    ) {
                    return FALSE;
                }
            }
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_REQUIRED:
            if (Source->Wildcard.MaxLen) {
                if (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen) {
                    return FALSE;
                }
            }
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetA (
                    _mbsnextc (Destination->Exact.LowerCasePhrase),
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_REQUIRED:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetA (
                    _mbsnextc (Destination->Exact.LowerCasePhrase),
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_EXACTMATCH:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            return FALSE;
        case SEGMENTTYPE_EXACTMATCH:
            if (_mbsnextc (Destination->Exact.LowerCasePhrase) != _mbsnextc (Source->Exact.LowerCasePhrase)) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

BOOL
pMatchSegmentW (
    IN      PSEGMENTW Source,
    IN      PSEGMENTW Destination
    )
{
    switch (Source->Type) {
    case SEGMENTTYPE_OPTIONAL:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            if (Source->Wildcard.MaxLen) {
                if ((Destination->Wildcard.MaxLen == 0) ||
                    (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen)
                    ) {
                    return FALSE;
                }
            }
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_REQUIRED:
            if (Source->Wildcard.MaxLen) {
                if (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen) {
                    return FALSE;
                }
            }
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetW (
                    *Destination->Exact.LowerCasePhrase,
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_REQUIRED:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetW (
                    *Destination->Exact.LowerCasePhrase,
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_EXACTMATCH:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            return FALSE;
        case SEGMENTTYPE_EXACTMATCH:
            if (*Destination->Exact.LowerCasePhrase != *Source->Exact.LowerCasePhrase) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

BOOL
pIsOneParsedPatternContainedA (
    IN      PPATTERNPROPSA Container,
    IN      UINT StartContainer,
    IN      PPATTERNPROPSA Contained,
    IN      UINT StartContained
    )
{
    UINT indexContainer = StartContainer;
    UINT indexContained = StartContained;
    PSEGMENTA containerSeg, containedSeg;

    if (StartContainer == Container->SegmentCount) {
        return FALSE;
    }

    while (indexContained < Contained->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        containedSeg = &Contained->Segment [indexContained];

        if (containerSeg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                indexContainer ++;
                if (indexContainer == Container->SegmentCount) {
                    return FALSE;
                }
                continue;
            }
            if (pIsOneParsedPatternContainedA (
                    Container,
                    indexContainer + 1,
                    Contained,
                    indexContained
                    )) {
                return TRUE;
            }
            indexContained ++;
            continue;
        } else if (containerSeg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                return FALSE;
            }
        } else {
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                return FALSE;
            }
        }
        indexContainer ++;
        indexContained ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (indexContainer < Container->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        if (containerSeg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexContainer ++;
    }

    return TRUE;
}

BOOL
pIsOneParsedPatternContainedW (
    IN      PPATTERNPROPSW Container,
    IN      UINT StartContainer,
    IN      PPATTERNPROPSW Contained,
    IN      UINT StartContained
    )
{
    UINT indexContainer = StartContainer;
    UINT indexContained = StartContained;
    PSEGMENTW containerSeg, containedSeg;

    if (StartContainer == Container->SegmentCount) {
        return FALSE;
    }

    while (indexContained < Contained->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        containedSeg = &Contained->Segment [indexContained];

        if (containerSeg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                indexContainer ++;
                if (indexContainer == Container->SegmentCount) {
                    return FALSE;
                }
                continue;
            }
            if (pIsOneParsedPatternContainedW (
                    Container,
                    indexContainer + 1,
                    Contained,
                    indexContained
                    )) {
                return TRUE;
            }
            indexContained ++;
            continue;
        } else if (containerSeg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                return FALSE;
            }
        } else {
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                return FALSE;
            }
        }
        indexContainer ++;
        indexContained ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (indexContainer < Container->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        if (containerSeg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexContainer ++;
    }

    return TRUE;
}

BOOL
IsExplodedParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Contained->PatternCount ; u1++) {

        b = FALSE;
        for (u2 = 0 ; u2 < Container->PatternCount ; u2++) {

            b = pIsOneParsedPatternContainedA (
                    &Container->Pattern[u2],
                    0,
                    &Contained->Pattern[u1],
                    0
                    );
            if (b) break;
        }
        if (!b) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
IsExplodedParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Contained->PatternCount ; u1++) {

        b = FALSE;
        for (u2 = 0 ; u2 < Container->PatternCount ; u2++) {

            b = pIsOneParsedPatternContainedW (
                    &Container->Pattern[u2],
                    0,
                    &Contained->Pattern[u1],
                    0
                    );
            if (b) break;
        }
        if (!b) {
            return FALSE;
        }
    }

    return TRUE;
}

PPARSEDPATTERNA
ExplodeParsedPatternA (
    IN      PPARSEDPATTERNA Pattern
    )
{
    PMHANDLE pool;
    PPARSEDPATTERNA pattern;
    PPATTERNPROPSA oldProps, newProps;
    PSEGMENTA oldSeg, newSeg;
    UINT i, j, k, newPropsSize, charCountTmp, oldSegIndex, byteIndex;
    BOOL result = TRUE;

    pool = PmCreateNamedPool ("Parsed Pattern");

    __try {

        pattern = (PPARSEDPATTERNA) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNA));
        ZeroMemory (pattern, sizeof (PARSEDPATTERNA));
        pattern->PatternCount = Pattern->PatternCount;
        pattern->Pool = pool;
        pattern->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                                pool,
                                                pattern->PatternCount * sizeof (PATTERNPROPSA)
                                                );

        for (i=0; i<pattern->PatternCount; i++) {
            oldProps = &Pattern->Pattern[i];
            newProps = &pattern->Pattern[i];
            ZeroMemory (newProps, sizeof (PATTERNPROPSA));
            // now let's walk oldProps to see how many segments we are
            // going to need
            newPropsSize = 0;
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    charCountTmp = CharCountA (oldSeg->Exact.LowerCasePhrase);
                    newPropsSize += (charCountTmp?charCountTmp:1);
                    break;
                case SEGMENTTYPE_REQUIRED:
                    newPropsSize += oldSeg->Wildcard.MaxLen;
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    newPropsSize ++;
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
            // now we allocate the required segments
            newProps->SegmentCount = newPropsSize;
            newProps->Segment = (PSEGMENTA) PmGetAlignedMemory (
                                                pool,
                                                newProps->SegmentCount * sizeof (SEGMENTA)
                                                );
            // now let's walk oldProps again and fill newProps segments.
            k = 0;
            newSeg = &newProps->Segment[k];
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                ZeroMemory (newSeg, sizeof (SEGMENTA));
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    oldSegIndex = CharCountA (oldSeg->Exact.LowerCasePhrase);
                    byteIndex = oldSeg->Exact.PhraseBytes;
                    if (!oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCSTR) PmGetAlignedMemory (
                                                                        pool, sizeof(CHAR)
                                                                        );
                            ((PSTR)newSeg->Exact.LowerCasePhrase) [0] = 0;
                            newSeg->Exact.PhraseBytes = 0;
                    } else {
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCSTR) PmGetAlignedMemory (
                                                                        pool, 3 * sizeof(CHAR)
                                                                        );
                            if (IsLeadByte (oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex])) {
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[1] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[2] = 0;
                                newSeg->Exact.PhraseBytes = 2;
                            } else {
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[1] = 0;
                                newSeg->Exact.PhraseBytes = 1;
                            }
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    }
                    break;
                case SEGMENTTYPE_REQUIRED:
                    oldSegIndex = oldSeg->Wildcard.MaxLen;
                    while (oldSegIndex) {
                        ZeroMemory (newSeg, sizeof (SEGMENTA));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = 1;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        oldSegIndex --;
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    ZeroMemory (newSeg, sizeof (SEGMENTA));
                    newSeg->Type = oldSeg->Type;
                    newSeg->Wildcard.MaxLen = oldSeg->Wildcard.MaxLen;
                    if (oldSeg->Wildcard.IncludeSet) {
                        newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                    }
                    if (oldSeg->Wildcard.ExcludeSet) {
                        newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                    }
                    k++;
                    newSeg = &newProps->Segment[k];
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
        }
    }
    __finally {
        if (!result) {
            PmDestroyPool (pool);
            pattern = NULL;
        }
    }
    return pattern;
}

PPARSEDPATTERNW
ExplodeParsedPatternW (
    IN      PPARSEDPATTERNW Pattern
    )
{
    PMHANDLE pool;
    PPARSEDPATTERNW pattern;
    PPATTERNPROPSW oldProps, newProps;
    PSEGMENTW oldSeg, newSeg;
    UINT i, j, k, newPropsSize, charCountTmp, oldSegIndex;
    BOOL result = TRUE;

    pool = PmCreateNamedPool ("Parsed Pattern");

    __try {

        pattern = (PPARSEDPATTERNW) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNW));
        ZeroMemory (pattern, sizeof (PARSEDPATTERNW));
        pattern->PatternCount = Pattern->PatternCount;
        pattern->Pool = pool;
        pattern->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                                pool,
                                                pattern->PatternCount * sizeof (PATTERNPROPSW)
                                                );

        for (i=0; i<pattern->PatternCount; i++) {
            oldProps = &Pattern->Pattern[i];
            newProps = &pattern->Pattern[i];
            ZeroMemory (newProps, sizeof (PATTERNPROPSW));
            // now let's walk oldProps to see how many segments we are
            // going to need
            newPropsSize = 0;
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    charCountTmp = CharCountW (oldSeg->Exact.LowerCasePhrase);
                    newPropsSize += (charCountTmp?charCountTmp:1);
                    break;
                case SEGMENTTYPE_REQUIRED:
                    newPropsSize += oldSeg->Wildcard.MaxLen;
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    newPropsSize ++;
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
            // now we allocate the required segments
            newProps->SegmentCount = newPropsSize;
            newProps->Segment = (PSEGMENTW) PmGetAlignedMemory (
                                                pool,
                                                newProps->SegmentCount * sizeof (SEGMENTW)
                                                );
            // now let's walk oldProps again and fill newProps segments.
            k = 0;
            newSeg = &newProps->Segment[k];
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                ZeroMemory (newSeg, sizeof (SEGMENTW));
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    oldSegIndex = CharCountW (oldSeg->Exact.LowerCasePhrase);
                    if (!oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCWSTR) PmGetAlignedMemory (
                                                                        pool, sizeof(WCHAR)
                                                                        );
                            ((PWSTR)newSeg->Exact.LowerCasePhrase) [0] = 0;
                            newSeg->Exact.PhraseBytes = 0;
                    } else {
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTW));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCWSTR) PmGetAlignedMemory (
                                                                        pool, 2 * sizeof(WCHAR)
                                                                        );
                            ((PWSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [(oldSeg->Exact.PhraseBytes / sizeof(WCHAR)) - oldSegIndex];
                            ((PWSTR)newSeg->Exact.LowerCasePhrase)[1] = 0;
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    }
                    break;
                case SEGMENTTYPE_REQUIRED:
                    oldSegIndex = oldSeg->Wildcard.MaxLen;
                    while (oldSegIndex) {
                        ZeroMemory (newSeg, sizeof (SEGMENTW));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = 1;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        oldSegIndex --;
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    ZeroMemory (newSeg, sizeof (SEGMENTW));
                    newSeg->Type = oldSeg->Type;
                    newSeg->Wildcard.MaxLen = oldSeg->Wildcard.MaxLen;
                    if (oldSeg->Wildcard.IncludeSet) {
                        newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                    }
                    if (oldSeg->Wildcard.ExcludeSet) {
                        newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                    }
                    k++;
                    newSeg = &newProps->Segment[k];
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
        }
    }
    __finally {
        if (!result) {
            PmDestroyPool (pool);
            pattern = NULL;
        }
    }
    return pattern;
}

/*++

Routine Description:

  IsPatternContainedEx compares two patterns to see if one of them is
  included in the other. Both patterns may contain any of the following
  expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Container - A container pattern possibly containing wildcards
  Contained - A contained pattern possibly containing wildcards

Return Value:

  TRUE when the second pattern is contained in the first one, FALSE if not.

--*/

BOOL
IsPatternContainedExA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    PPARSEDPATTERNA container = NULL, contained = NULL;
    PPARSEDPATTERNA expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        container = CreateParsedPatternA (Container);
        if (!container) {
            __leave;
        }
        expContainer = ExplodeParsedPatternA (container);
        if (!expContainer) {
            __leave;
        }
        contained = CreateParsedPatternA (Contained);
        if (!contained) {
            __leave;
        }
        expContained = ExplodeParsedPatternA (contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExA (expContainer, expContained);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternA (expContained);
        }
        if (contained) {
            DestroyParsedPatternA (contained);
        }
        if (expContainer) {
            DestroyParsedPatternA (expContainer);
        }
        if (container) {
            DestroyParsedPatternA (container);
        }
    }

    return result;
}

BOOL
IsPatternContainedExW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    PPARSEDPATTERNW container = NULL, contained = NULL;
    PPARSEDPATTERNW expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        container = CreateParsedPatternW (Container);
        if (!container) {
            __leave;
        }
        expContainer = ExplodeParsedPatternW (container);
        if (!expContainer) {
            __leave;
        }
        contained = CreateParsedPatternW (Contained);
        if (!contained) {
            __leave;
        }
        expContained = ExplodeParsedPatternW (contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExW (expContainer, expContained);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternW (expContained);
        }
        if (contained) {
            DestroyParsedPatternW (contained);
        }
        if (expContainer) {
            DestroyParsedPatternW (expContainer);
        }
        if (container) {
            DestroyParsedPatternW (container);
        }
    }

    return result;
}

BOOL
IsParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    )
{
    PPARSEDPATTERNA expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        expContainer = ExplodeParsedPatternA (Container);
        if (!expContainer) {
            __leave;
        }
        expContained = ExplodeParsedPatternA (Contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExA (expContainer, expContained);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternA (expContained);
        }
        if (expContainer) {
            DestroyParsedPatternA (expContainer);
        }
    }

    return result;
}

BOOL
IsParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    )
{
    PPARSEDPATTERNW expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        expContainer = ExplodeParsedPatternW (Container);
        if (!expContainer) {
            __leave;
        }
        expContained = ExplodeParsedPatternW (Contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExW (expContainer, expContained);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternW (expContained);
        }
        if (expContainer) {
            DestroyParsedPatternW (expContainer);
        }
    }

    return result;
}

/*++

Routine Description:

  pAppendCharToGrowBuffer copies the first character in a caller specified
  string into the specified grow buffer.  This function is used to build up a
  string inside a grow buffer, copying character by character.

Arguments:

  buf       - Specifies the grow buffer to add the character to, receives the
              character in its buffer
  PtrToChar - Specifies a pointer to the character to copy

Return Value:

  None.

--*/

VOID
pAppendCharToGrowBufferA (
    IN OUT  PGROWBUFFER Buf,
    IN      PCSTR PtrToChar
    )
{
    PBYTE p;
    UINT Len;

    if (IsLeadByte (*PtrToChar) && PtrToChar[1]) {
        Len = 2;
    } else {
        Len = 1;
    }

    p = GbGrow (Buf, Len);
    CopyMemory (p, PtrToChar, (SIZE_T) Len);
}


VOID
pAppendCharToGrowBufferW (
    IN OUT  PGROWBUFFER Buf,
    IN      PCWSTR PtrToChar
    )
{
    PBYTE p;

    p = GbGrow (Buf, sizeof(WCHAR));
    CopyMemory (p, PtrToChar, sizeof(WCHAR));
}


/*++

Routine Description:

  CreateParsedPattern parses the expanded pattern string into a set of
  structures.  Parsing is considered expensive relative to testing the
  pattern, so callers should avoid calling this function inside loops.  See
  IsPatternMatchEx for a good description of the pattern string syntax.

Arguments:

  Pattern - Specifies the pattern string, which can include the extended
            wildcard syntax.

Return Value:

  A pointer to a parsed pattern structure, which the caller will use like a
  handle, or NULL if a syntax error occurred.

--*/

PPARSEDPATTERNA
CreateParsedPatternA (
    IN      PCSTR Pattern
    )
{
    PMHANDLE Pool;
    PPARSEDPATTERNA Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = INIT_GROWBUFFER;
    GROWBUFFER SegmentArray = INIT_GROWBUFFER;
    GROWBUFFER PatternArray = INIT_GROWBUFFER;
    GROWBUFFER SetBuf = INIT_GROWBUFFER;
    PPATTERNPROPSA CurrentPattern;
    MBCHAR ch = 0;
    PCSTR LookAhead;
    PCSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTA Segment;
    PSEGMENTA SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    Pool = PmCreateNamedPool ("Parsed Pattern");

    Struct = (PPARSEDPATTERNA) PmGetAlignedMemory (Pool, sizeof (PARSEDPATTERNA));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNA));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (_mbsnextc (Pattern) == '<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (isspace ((INT)(_mbsnextc (Pattern)))) {
                Pattern = _mbsinc (Pattern);
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (_mbsnextc (Pattern) == '<') {
                Pattern = _mbsinc (Pattern);
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGA ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSA) GbGrow (&PatternArray, sizeof (PATTERNPROPSA));

                CurrentPattern->Segment = (PSEGMENTA) PmGetAlignedMemory (Pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTA);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    (SIZE_T) SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = _mbsnextc (Pattern);
            if (ch == '>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern = _mbsinc (Pattern);
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == '^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern = _mbsinc (Pattern);
                pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
                Pattern = _mbsinc (Pattern);
                break;
            }

            if (ch == '*' || ch == '?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == '*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern = _mbsinc (Pattern);

                if (_mbsnextc (Pattern) == '[') {
                    Pattern = _mbsinc (Pattern);
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
            Pattern = _mbsinc (Pattern);

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, "");
            Segment.Exact.LowerCasePhrase = PmDuplicateStringA (
                                                Pool,
                                                (PCSTR) ExactMatchBuf.Buf
                                                );
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (CHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            _mbslwr ((PSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTA) GbGrow (&SegmentArray, sizeof (SEGMENTA));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTA));

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= '0' && *LookAhead <= '9') {

                MaxLen = MaxLen * 10 + (*LookAhead - '0');
                LookAhead++;
            }

            if (LookAhead > Pattern && _mbsnextc (LookAhead) == ':') {
                Pattern = _mbsinc (LookAhead);

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            MYASSERT (SetBegin);

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.IncludeSet = PmDuplicateStringA (
                                                        Pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    _mbslwr ((PSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == '!') {
                //
                // Case 2: an exclude set
                //

                SetBegin = _mbsinc (SetBegin);
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {   //lint !e613
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.ExcludeSet = PmDuplicateStringA (
                                                        Pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    _mbslwr ((PSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = _mbsinc (SetBegin);
                break;
            }

            if (ch == '!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin = _mbsinc (SetBegin);

                if (_mbsnextc (SetBegin) != '(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin = _mbsinc (SetBegin);

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {   //lint !e613
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (_mbsnextc (SetBegin) == '^') {
                SetBegin = _mbsinc (SetBegin);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = _mbsinc (SetBegin);

            if (_mbsnextc (LookAhead) == '-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = _mbsinc (LookAhead);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (_mbsnextc (SetBegin) == '^') {
                    SetBegin = _mbsinc (SetBegin);
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferA (&SetBuf, SetBegin);
            }

            SetBegin = _mbsinc (SetBegin);
            ch = _mbsnextc (SetBegin);

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == ')') {

                    SetBegin = _mbsinc (SetBegin);
                    ch = _mbsnextc (SetBegin);

                } else if (ch != ',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (_mbsnextc (SetBegin) != '(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            while (*SetBegin) {
                if (_mbsnextc (SetBegin) == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (_mbsnextc (SetBegin) == ')') {

                    break;

                }

                if (IsLeadByte (SetBegin[0]) && SetBegin[1]) {
                    SetBegin += 2;
                } else {
                    SetBegin += 1;
                }
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            //
            // Now we are either at a comma or a close brace
            //

            ch = _mbsnextc (SetBegin);
            State = ReturnState;

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            ch = 0;

            while (*SetBegin) { //lint !e613
                ch = _mbsnextc (SetBegin);
                if (ch == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (ch == ',' || ch == ']') {

                    break;

                }

                SetBegin = _mbsinc (SetBegin);
            }

            MYASSERT (*SetBegin);   //lint !e794

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            }

            State = ReturnState;
            break;
        }   //lint !e787

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    GbFree (&ExactMatchBuf);
    GbFree (&SetBuf);
    GbFree (&SegmentArray);

    if (State == PATTERN_ERROR) {
        GbFree (&PatternArray);
        PmDestroyPool (Pool);
        return NULL;
    }

    if (PatternArray.End == 0) {
        //build an empty parsed pattern
        GbFree (&PatternArray);
        Struct->PatternCount = 1;
        Struct->Pool = Pool;
        Struct->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                                Pool,
                                                sizeof (PATTERNPROPSA)
                                                );
        Struct->Pattern[0].SegmentCount = 1;
        Struct->Pattern[0].Segment = (PSEGMENTA) PmGetAlignedMemory (
                                                    Pool,
                                                    sizeof (PSEGMENTA)
                                                    );
        Struct->Pattern[0].Segment[0].Type = SEGMENTTYPE_EXACTMATCH;
        Struct->Pattern[0].Segment[0].Exact.LowerCasePhrase = PmDuplicateStringA (Pool, "");
        Struct->Pattern[0].Segment[0].Exact.PhraseBytes = 0;

        return Struct;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                            Pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, (SIZE_T) PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSA);
    Struct->Pool = Pool;

    GbFree (&PatternArray);

    return Struct;
}


PPARSEDPATTERNW
CreateParsedPatternW (
    IN      PCWSTR Pattern
    )
{
    PMHANDLE Pool;
    PPARSEDPATTERNW Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = INIT_GROWBUFFER;
    GROWBUFFER SegmentArray = INIT_GROWBUFFER;
    GROWBUFFER PatternArray = INIT_GROWBUFFER;
    GROWBUFFER SetBuf = INIT_GROWBUFFER;
    PPATTERNPROPSW CurrentPattern;
    WCHAR ch = 0;
    PCWSTR LookAhead;
    PCWSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTW Segment;
    PSEGMENTW SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    Pool = PmCreateNamedPool ("Parsed Pattern");

    Struct = (PPARSEDPATTERNW) PmGetAlignedMemory (Pool, sizeof (PARSEDPATTERNW));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNW));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (*Pattern == L'<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (iswspace (*Pattern)) {
                Pattern++;
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (*Pattern == L'<') {
                Pattern++;
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGW ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSW) GbGrow (&PatternArray, sizeof (PATTERNPROPSW));

                CurrentPattern->Segment = (PSEGMENTW) PmGetAlignedMemory (Pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTW);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    (SIZE_T) SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = *Pattern;
            if (ch == L'>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern++;
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == L'^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern++;
                pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
                Pattern++;
                break;
            }

            if (ch == L'*' || ch == L'?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == L'*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern++;

                if (*Pattern == L'[') {
                    Pattern++;
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
            Pattern++;

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, L"");
            Segment.Exact.LowerCasePhrase = PmDuplicateStringW (
                                                Pool,
                                                (PCWSTR) ExactMatchBuf.Buf
                                                );  //lint !e64
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (WCHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            _wcslwr ((PWSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTW) GbGrow (&SegmentArray, sizeof (SEGMENTW));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTW));

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= L'0' && *LookAhead <= L'9') {

                MaxLen = MaxLen * 10 + (*LookAhead - L'0');
                LookAhead++;
            }

            if (LookAhead > Pattern && *LookAhead == L':') {
                Pattern = LookAhead + 1;

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.IncludeSet = PmDuplicateStringW (
                                                        Pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );  //lint !e64
                    _wcslwr ((PWSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: an exclude set
                //

                SetBegin++;
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.ExcludeSet = PmDuplicateStringW (
                                                        Pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );  //lint !e64
                    _wcslwr ((PWSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = SetBegin + 1;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin++; //lint !e613

                if (*SetBegin != L'(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin++;

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            if (*SetBegin == L'^') {
                SetBegin++;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = SetBegin + 1;

            if (*LookAhead == L'-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = LookAhead + 1;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (*SetBegin == L'^') {
                    SetBegin++;
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferW (&SetBuf, SetBegin);
            }

            SetBegin++;
            ch = *SetBegin;

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == L')') {

                    SetBegin++;
                    ch = *SetBegin;

                } else if (ch != L',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            if (*SetBegin != L'(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            while (*SetBegin) {
                if (*SetBegin == L'^') {

                    SetBegin++;

                } else if (*SetBegin == L')') {

                    break;

                }

                SetBegin++;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            //
            // Now we are either at a comma or a close brace
            //

            ch = *SetBegin;
            State = ReturnState;

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = 0;

            while (*SetBegin) {
                ch = *SetBegin;
                if (ch == L'^') {

                    SetBegin++; //lint !e613

                } else if (ch == L',' || ch == L']') {

                    break;

                }

                SetBegin++;
            }

            MYASSERT (*SetBegin);

            if (ch == L',') {
                SetBegin++;
            }

            State = ReturnState;
            break;
        }   //lint !e787

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    GbFree (&ExactMatchBuf);
    GbFree (&SetBuf);
    GbFree (&SegmentArray);

    if (State == PATTERN_ERROR) {
        GbFree (&PatternArray);
        PmDestroyPool (Pool);
        return NULL;
    }

    if (PatternArray.End == 0) {
        //build an empty parsed pattern
        GbFree (&PatternArray);
        Struct->PatternCount = 1;
        Struct->Pool = Pool;
        Struct->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                                Pool,
                                                sizeof (PATTERNPROPSW)
                                                );
        Struct->Pattern[0].SegmentCount = 1;
        Struct->Pattern[0].Segment = (PSEGMENTW) PmGetAlignedMemory (
                                                    Pool,
                                                    sizeof (PSEGMENTW)
                                                    );
        Struct->Pattern[0].Segment[0].Type = SEGMENTTYPE_EXACTMATCH;
        Struct->Pattern[0].Segment[0].Exact.LowerCasePhrase = PmDuplicateStringW (Pool, L"");
        Struct->Pattern[0].Segment[0].Exact.PhraseBytes = 0;

        return Struct;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                            Pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, (SIZE_T) PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSW);
    Struct->Pool = Pool;

    GbFree (&PatternArray);

    return Struct;
}

BOOL
WildCharsPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    UINT i,j;

    if (!ParsedPattern) {
        return FALSE;
    }
    for (i=0; i<ParsedPattern->PatternCount; i++) {
        if (ParsedPattern->Pattern[i].SegmentCount > 1) {
            return TRUE;
        }
        for (j=0; j<ParsedPattern->Pattern[i].SegmentCount; j++) {
            if ((ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_OPTIONAL) ||
                (ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_REQUIRED)
                ) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
WildCharsPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    UINT i,j;

    if (!ParsedPattern) {
        return FALSE;
    }
    for (i=0; i<ParsedPattern->PatternCount; i++) {
        if (ParsedPattern->Pattern[i].SegmentCount > 1) {
            return TRUE;
        }
        for (j=0; j<ParsedPattern->Pattern[i].SegmentCount; j++) {
            if ((ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_OPTIONAL) ||
                (ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_REQUIRED)
                ) {
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL
ParsedPatternTrimLastCharA (
    IN OUT  PPARSEDPATTERNA ParsedPattern
    )
{
    if (!ParsedPatternHasRootA (ParsedPattern)) {
        return FALSE;
    }
    ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes -= DWSIZEOF (CHAR);
    *(PSTR)((PBYTE)ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase +
            ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes) = 0;
    return TRUE;
}

BOOL
ParsedPatternTrimLastCharW (
    IN OUT  PPARSEDPATTERNW ParsedPattern
    )
{
    if (!ParsedPatternHasRootW (ParsedPattern)) {
        return FALSE;
    }
    ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes -= DWSIZEOF (WCHAR);
    *(PWSTR)((PBYTE)ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase +
             ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes) = 0;
    return TRUE;
}


VOID
UBINTtoHexA (
    IN      UBINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "0x%08X%08X", (DWORD)(Number >> 32), (DWORD)Number);
#else
    sprintf (String, "0x00000000%08X", Number);
#endif
}

VOID
UBINTtoHexW (
    IN      UBINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"0x%08X%08X", (DWORD)(Number >> 32), (DWORD)Number);
#else
    swprintf (String, L"0x00000000%08X", Number);
#endif
}

VOID
UBINTtoDecA (
    IN      UBINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "%I64u", Number);
#else
    sprintf (String, "%lu", Number);
#endif
}

VOID
UBINTtoDecW (
    IN      UBINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"%I64u", Number);
#else
    swprintf (String, L"%lu", Number);
#endif
}

VOID
BINTtoDecA (
    IN      BINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "%I64d", Number);
#else
    sprintf (String, "%ld", Number);
#endif
}

VOID
BINTtoDecW (
    IN      BINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"%I64d", Number);
#else
    swprintf (String, L"%ld", Number);
#endif
}

VOID
PrintPattern (
    IN      PCSTR PatStr,
    IN      PPARSEDPATTERNA Struct
    )

/*++

Routine Description:

  PrintPattern is used for debugging the pattern parsing and testing
  functions.

Arguments:

  PatStr - Specifies the original pattern string (which is printed as a
           heading)
  Struct - Specifies the parsed pattern struct

Return Value:

  None.

--*/

{
    CHAR poolStr [sizeof (UBINT) * 2 + 2 + 1];
    UINT u, v;

    printf ("Pattern: %s\n\n", PatStr);

    if (!Struct) {
        printf ("Invalid Pattern\n\n");
        return;
    }

    printf ("PatternCount: %u\n", Struct->PatternCount);
    UBINTtoHexA ((UBINT)Struct->Pool, poolStr);
    printf ("Pool: %s\n", poolStr);

    for (u = 0 ; u < Struct->PatternCount ; u++) {

        printf ("  Segment Count: %u\n", Struct->Pattern[u].SegmentCount);

        for (v = 0 ; v < Struct->Pattern->SegmentCount ; v++) {
            printf ("    Type: ");

            switch (Struct->Pattern[u].Segment[v].Type) {

            case SEGMENTTYPE_EXACTMATCH:
                printf ("SEGMENTTYPE_EXACTMATCH\n");
                printf ("      String: %s\n", Struct->Pattern[u].Segment[v].Exact.LowerCasePhrase);
                printf ("      Bytes: %u\n", Struct->Pattern[u].Segment[v].Exact.PhraseBytes);
                break;

            case SEGMENTTYPE_OPTIONAL:
                printf ("SEGMENTTYPE_OPTIONAL\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;

            case SEGMENTTYPE_REQUIRED:
                printf ("SEGMENTTYPE_REQUIRED\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;
            }   //lint !e744
        }

    }

    printf ("\n");
}



/*++

Routine Description:

  TestParsedPattern finds the end of the string to test and calls
  TestParsedPatternAB.

Arguments:

  ParsedPattern - Specifies the parsed pattern structure as returned by
                  CreateParsedPattern
  StringToTest  - Specifies the string to test against the pattern

Return Value:

  TRUE if the string fits the pattern, FALSE if it does not

--*/

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    )
{
    PCSTR EndPlusOne = GetEndOfStringA (StringToTest);

    return TestParsedPatternABA (ParsedPattern, StringToTest, EndPlusOne);
}


BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    )
{
    PCWSTR EndPlusOne = GetEndOfStringW (StringToTest);

    return TestParsedPatternABW (ParsedPattern, StringToTest, EndPlusOne);
}


/*++

Routine Description:

  pTestSet tests a character against an include and exclude set. The sets are
  formatted in pairs of characters, where the first character in the pair is
  the low range, and the second character in the pair is the high range.  The
  specified character will automatically be lower-cased, and all whitespace
  characters are tested against the space character (ascii 32).

Arguments:

  ch         - Specifies the character to test.  This character is converted
               to lower case before the test.
  IncludeSet - Specifies the set of characters that ch must be a member of.
               If NULL is specified, then the include set is all characters.
  ExcludeSet - Specifies the range of characters that ch cannot be a member
               of.  If NULL is specified, then no characters are excluded.

Return Value:

  TRUE if ch is in the include set and not in the exclude set; FALSE
  otherwise.

--*/

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    )
{
    MBCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (isspace ((INT)ch)) {
        if (ch != ' ') {
            if (pTestSetA (' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = _mbctolower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);
            HighChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);
            HighChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}


BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    )
{
    WCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (iswspace (ch)) {
        if (ch != L' ') {
            if (pTestSetW (L' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = towlower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = *IncludeSet++;
            HighChar = *IncludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = *ExcludeSet++;
            HighChar = *ExcludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}



/*++

Routine Description:

  pTestOnePatternAB tests a string against a parsed pattern. It loops through
  each segment in the pattern, and calls itself recursively in certain
  circumstances.

Arguments:

  Pattern      - Specifies the parsed pattern, as returned from
                 CreateParsedPattern
  StartSeg     - Specifies the segment within Pattern to start testing.  This
                 is used for recursion and outside callers should pass in 0.
  StringToTest - Specifies the string to test against Pattern.  In recursion,
                 this member will be a pointer to the start of the sub string
                 to test.
  EndPlusOne   - Specifies one character beyond the end of the string.  This
                 typically points to the nul terminator.

Return Value:

  TRUE if the string between StringToTest and EndPlusOne fits Pattern. FALSE
  otherwise.

--*/

BOOL
pTestOnePatternABA (
    IN      PPATTERNPROPSA Pattern,
    IN      UINT StartSeg,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTA Segment;
    MBCHAR ch1, ch2;
    PCSTR q;
    PCSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT)((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase;

            TempEnd = (PCSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 0;

            while (q < TempEnd) {

                ch1 = _mbsnextc (StringToTest);
                ch2 = _mbsnextc (q);

                ch1 = _mbctolower (ch1);

                if (ch1 != ch2) {
                    if (ch2 == ' ') {
                        if (!isspace ((INT)ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q = _mbsinc (q);
                StringToTest = _mbsinc (StringToTest);
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetA (
                            _mbsnextc (StringToTest),
                            Segment->Wildcard.IncludeSet,
                            Segment->Wildcard.ExcludeSet
                            )) {
                        return FALSE;
                    }

                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            } else {
                while (StringToTest < EndPlusOne && Chars > 0) {
                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            }

            if (Chars) {
                return FALSE;
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                    }
                }

            } else if (Chars) {

                while (TempEnd < EndPlusOne && Chars > 0) {
                    TempEnd = _mbsinc (TempEnd);
                    Chars--;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABA (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest = _mbsinc (StringToTest);

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }   //lint !e744
    }

    return TRUE;
}


BOOL
pTestOnePatternABW (
    IN      PPATTERNPROPSW Pattern,
    IN      UINT StartSeg,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTW Segment;
    WCHAR ch1, ch2;
    PCWSTR q;
    PCWSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT)((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase; //lint !e64

            TempEnd = (PCWSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 0;

            while (q < TempEnd) {

                ch1 = towlower (*StringToTest);
                ch2 = *q;

                if (ch1 != ch2) {
                    if (ch2 == L' ') {
                        if (!iswspace (ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q++;
                StringToTest++;
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetW (
                            *StringToTest,
                            Segment->Wildcard.IncludeSet,   //lint !e64
                            Segment->Wildcard.ExcludeSet
                            )) {    //lint !e64
                        return FALSE;
                    }

                    Chars--;
                    StringToTest++;
                }

                if (Chars) {
                    return FALSE;
                }

            } else {
                StringToTest += Chars;

                if (StringToTest > EndPlusOne) {
                    return FALSE;
                }
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,   //lint !e64
                                Segment->Wildcard.ExcludeSet
                                )) {    //lint !e64
                            break;
                        }

                        TempEnd++;
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,   //lint !e64
                                Segment->Wildcard.ExcludeSet
                                )) {    //lint !e64
                            break;
                        }

                        TempEnd++;
                    }
                }

            } else if (Chars) {

                TempEnd += Chars;
                if (TempEnd > EndPlusOne) {
                    TempEnd = EndPlusOne;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABW (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest++;

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }   //lint !e744
    }

    return TRUE;
}



/*++

Routine Description:

  TestParsedPattternAB loops through all the patterns in ParsedPattern,
  testing the specified string against each. The loop stops at the first
  match.

Arguments:

  ParsedPattern - Specifies the parsed pattern, as returned from
                  CreateParsedPattern
  StringToTest  - Specifies the start of the string to test.
  EndPlusOne    - Specifies a pointer to the first character after the end of
                  the string.  This often points to the nul at the end of the
                  string.  A nul must not exist in between StringToTest and
                  EndPlusOne; a nul can only be at *EndPlusOne.  A nul is not
                  required.

Return Value:

  TRUE if the string specified between StringToTest and EndPlusOne matches
  Pattern.  FALSE otherwise.

--*/

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABA (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}


BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABW (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}



/*++

Routine Description:

  DestroyParsedPattern cleans up a pattern allocated from CreateParsedPattern.

Arguments:

  ParsedPattern - Specifies the value returned from CreateParsedPattern.

Return Value:

  None.

--*/

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern) {
        PmDestroyPool (ParsedPattern->Pool);
    }
}


VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern) {
        PmDestroyPool (ParsedPattern->Pool);
    }
}


/*++

Routine Description:

  DecodeParsedPattern decodes all exact-matches sub-strings of the given pattern.

Arguments:

  ParsedPattern - Specifies the parsed pattern.

Return Value:

  None.

--*/

VOID
DecodeParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    UINT u;
    UINT v;
    PSTR phrase;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {
        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            if (ParsedPattern->Pattern[u].Segment[v].Type == SEGMENTTYPE_EXACTMATCH) {
                phrase = (PSTR)ParsedPattern->Pattern[u].Segment[v].Exact.LowerCasePhrase;
                DecodeRuleCharsA (phrase, phrase);
                ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes = ByteCountA (phrase);
            }
        }
    }
}


VOID
DecodeParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    UINT u;
    UINT v;
    PWSTR phrase;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {
        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            if (ParsedPattern->Pattern[u].Segment[v].Type == SEGMENTTYPE_EXACTMATCH) {
                phrase = (PWSTR)ParsedPattern->Pattern[u].Segment[v].Exact.LowerCasePhrase;
                DecodeRuleCharsW (phrase, phrase);
                ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes = ByteCountW (phrase);
            }
        }
    }
}


/*++

Routine Description:

  GetParsedPatternMinMaxSize returns the minimum and the maximum size (in bytes)
  of a string that would match the given parsed pattern.

Arguments:

  ParsedPattern - Specifies the parsed pattern
  MinSize - Receives the minimum size of a string that would match the pattern
  MaxSize - Receives the maximum size of a string that would match the pattern

Return Value:

  None.

--*/

VOID
GetParsedPatternMinMaxSizeA (
    IN      PPARSEDPATTERNA ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    )
{
    UINT u;
    UINT v;
    DWORD pmin;
    DWORD pmax;
    DWORD smin;
    DWORD smax;

    *MinSize = *MaxSize = 0;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {

        pmin = pmax = 0;

        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            switch (ParsedPattern->Pattern[u].Segment[v].Type) {
            case SEGMENTTYPE_EXACTMATCH:
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes;
                break;
            case SEGMENTTYPE_OPTIONAL:
                smin = 0;
                if (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen) {
                    smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (CHAR);
                } else {
                    smax = DWORD_MAX;
                }
                break;
            case SEGMENTTYPE_REQUIRED:
                MYASSERT (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen > 0);
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (CHAR);
                break;
            default:
                MYASSERT (FALSE);   //lint !e506
                smin = smax = 0;
            }
            pmin += smin;
            if (pmax < DWORD_MAX) {
                if (smax < DWORD_MAX) {
                    pmax += smax;
                } else {
                    pmax = DWORD_MAX;
                }
            }
        }

        if (pmin < *MinSize) {
            *MinSize = pmin;
        }
        if (pmax > *MaxSize) {
            *MaxSize = pmax;
        }
    }
}

VOID
GetParsedPatternMinMaxSizeW (
    IN      PPARSEDPATTERNW ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    )
{
    UINT u;
    UINT v;
    DWORD pmin;
    DWORD pmax;
    DWORD smin;
    DWORD smax;

    *MinSize = *MaxSize = 0;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {

        pmin = pmax = 0;

        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            switch (ParsedPattern->Pattern[u].Segment[v].Type) {
            case SEGMENTTYPE_EXACTMATCH:
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes;
                break;
            case SEGMENTTYPE_OPTIONAL:
                smin = 0;
                if (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen) {
                    smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (WCHAR);
                } else {
                    smax = DWORD_MAX;
                }
                break;
            case SEGMENTTYPE_REQUIRED:
                MYASSERT (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen > 0);
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (WCHAR);
                break;
            default:
                MYASSERT (FALSE);   //lint !e506
                smin = smax = 0;
            }
            pmin += smin;
            if (pmax < DWORD_MAX) {
                if (smax < DWORD_MAX) {
                    pmax += smax;
                } else {
                    pmax = DWORD_MAX;
                }
            }
        }

        if (pmin < *MinSize) {
            *MinSize = pmin;
        }
        if (pmax > *MaxSize) {
            *MaxSize = pmax;
        }
    }
}


/*++

Routine Description:

    PatternIncludesPattern decides if a given pattern includes another pattern,
    meaning that any string that would match the second will match the first.

Arguments:

    IncludingPattern - Specifies the first parsed pattern
    IncludedPattern - Specifies the second parsed pattern

Return Value:

    TRUE if the first pattern includes the second

--*/

BOOL
PatternIncludesPatternA (
    IN      PPARSEDPATTERNA IncludingPattern,
    IN      PPARSEDPATTERNA IncludedPattern
    )
{
    PPATTERNPROPSA pp1;
    PPATTERNPROPSA pp2;
    PSEGMENTA ps1;
    PSEGMENTA ps2;
    DWORD min1;
    DWORD max1;
    DWORD min2;
    DWORD max2;

    //
    // only deal with simple patterns for now (PatternCount == 1)
    //
    if (IncludingPattern->PatternCount > 1 || IncludedPattern->PatternCount > 1) {
        DEBUGMSGA ((DBG_ERROR, "PatternIncludesPatternA: multiple patterns not supported yet"));
        return FALSE;
    }

    //
    // test the usual cases first, quickly
    //
    pp1 = IncludingPattern->Pattern;
    MYASSERT (pp1);
    if (pp1->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalA (pp1->Segment)) {
        return TRUE;
    }

    pp2 = IncludedPattern->Pattern;
    MYASSERT (pp2);
    if (pp2->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalA (pp2->Segment)) {
        return FALSE;
    }

    if (pp1->SegmentCount == 1) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (pp2->SegmentCount == 1) {
                ps2 = pp2->Segment;
                if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                    return ps1->Exact.PhraseBytes == ps2->Exact.PhraseBytes &&
                           StringMatchA (ps1->Exact.LowerCasePhrase, ps2->Exact.LowerCasePhrase);
                }
            }
        }
    } else if (pp1->SegmentCount == 2) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (ParsedPatternSegmentIsPureOptionalA (pp1->Segment + 1)) {
                if (pp2->SegmentCount == 1) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                               StringMatchByteCountA (
                                    ps1->Exact.LowerCasePhrase,
                                    ps2->Exact.LowerCasePhrase,
                                    ps1->Exact.PhraseBytes
                                    );
                    }
                } else if (pp2->SegmentCount == 2) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        if (ParsedPatternSegmentIsPureOptionalA (pp2->Segment + 1)) {
                            return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                                   StringMatchByteCountA (
                                        ps1->Exact.LowerCasePhrase,
                                        ps2->Exact.LowerCasePhrase,
                                        ps1->Exact.PhraseBytes
                                        );
                        }
                    }
                }
            }
        }
    }

    GetParsedPatternMinMaxSizeA (IncludingPattern, &min1, &max1);
    GetParsedPatternMinMaxSizeA (IncludedPattern, &min2, &max2);
    if (min2 < min1 || max2 > max1) {
        return FALSE;
    }

    //
    // BUGBUG - not implemented yet
    //
    return FALSE;
}

BOOL
PatternIncludesPatternW (
    IN      PPARSEDPATTERNW IncludingPattern,
    IN      PPARSEDPATTERNW IncludedPattern
    )
{
    PPATTERNPROPSW pp1;
    PPATTERNPROPSW pp2;
    PSEGMENTW ps1;
    PSEGMENTW ps2;
    DWORD min1;
    DWORD max1;
    DWORD min2;
    DWORD max2;

    //
    // only deal with simple patterns for now (PatternCount == 1)
    //
    if (IncludingPattern->PatternCount > 1 || IncludedPattern->PatternCount > 1) {
        DEBUGMSGW ((DBG_ERROR, "PatternIncludesPatternW: multiple patterns not supported yet"));
        return FALSE;
    }

    //
    // test the usual cases first, quickly
    //
    pp1 = IncludingPattern->Pattern;
    MYASSERT (pp1);
    if (pp1->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalW (pp1->Segment)) {
        return TRUE;
    }

    pp2 = IncludedPattern->Pattern;
    MYASSERT (pp2);
    if (pp2->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalW (pp2->Segment)) {
        return FALSE;
    }

    if (pp1->SegmentCount == 1) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (pp2->SegmentCount == 1) {
                ps2 = pp2->Segment;
                if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                    return ps1->Exact.PhraseBytes == ps2->Exact.PhraseBytes &&
                           StringMatchW (ps1->Exact.LowerCasePhrase, ps2->Exact.LowerCasePhrase);   //lint !e64
                }
            }
        }
    } else if (pp1->SegmentCount == 2) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (ParsedPatternSegmentIsPureOptionalW (pp1->Segment + 1)) {
                if (pp2->SegmentCount == 1) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                               StringMatchByteCountW (
                                    ps1->Exact.LowerCasePhrase,
                                    ps2->Exact.LowerCasePhrase,
                                    ps1->Exact.PhraseBytes
                                    );  //lint !e64
                    }
                } else if (pp2->SegmentCount == 2) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        if (ParsedPatternSegmentIsPureOptionalW (pp2->Segment + 1)) {
                            return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                                   StringMatchByteCountW (
                                        ps1->Exact.LowerCasePhrase,
                                        ps2->Exact.LowerCasePhrase,
                                        ps1->Exact.PhraseBytes
                                        );  //lint !e64
                        }
                    }
                }
            }
        }
    }

    GetParsedPatternMinMaxSizeW (IncludingPattern, &min1, &max1);
    GetParsedPatternMinMaxSizeW (IncludedPattern, &min2, &max2);
    if (min2 < min1 || max2 > max1) {
        return FALSE;
    }

    //
    // BUGBUG - not implemented yet
    //
    return FALSE;
}


VOID
_copymbchar (
    OUT     PSTR sz1,
    IN      PCSTR sz2
    )

/*++

Routine Description:

  _copymbchar transfers the character at sz2 to sz1, which may be one or
  two bytes long.

Arguments:

  sz1       - The destination string
  sz2       - The source string

Return Value:

  none

--*/


{
    if (IsLeadByte (*sz2)) {
        sz1[1] = sz2[1];
    }

    *sz1 = *sz2;
}


/*++

Routine Description:

  _tcsctrim removes character c from the end of str if it exists.  It removes
  only one character at the most.

Arguments:

  str       - A pointer to the string that may have character c at the end
  c         - The character that may be at the end of the string

Return Value:

  TRUE if character c was at the end of the string, or FALSE if it was not.

--*/

BOOL
_mbsctrim (
    OUT     PSTR str,
    IN      MBCHAR c
    )
{
    PSTR end;

    end = GetEndOfStringA (str);
    end = _mbsdec2 (str, end);
    if (end && _mbsnextc (end) == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


BOOL
_wcsctrim (
    OUT     PWSTR str,
    IN      WCHAR c
    )
{
    PWSTR end;

    end = GetEndOfStringW (str);
    end == str ? end = NULL : end--;
    if (end && *end == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  The FreeStringResourceEx functions are used to free a recently used
  string that is not being passed back to the caller.  In almost all
  cases, this string is at the end of our array of pointers, so we can
  efficiently search sequentially in reverse order.  If the pointer is
  not the last element of the array, it is first swapped with the real
  last element of the array so the array size is reduced.

Arguments:

  AllocTable - The GROWBUFFER table that holds the list of previously
               allocated strings (return values of ParseMessageEx or
               GetResourceStringEx).
  String     - A pointer to the string that is in AllocTable

Return Value:

  none

--*/

VOID
FreeStringResourceExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR String
    )
{
    PCTSTR *ptr, *end, *start;

    if (!String) {
        return;
    }

    //
    // Locate string (search sequentially in reverse order)
    //

    if (AllocTable->End < sizeof (PCSTR)) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address table empty", String, String));
        return;
    }

    start = (PCSTR *) AllocTable->Buf;
    end = (PCSTR *) (AllocTable->Buf + AllocTable->End - sizeof (PCSTR));

    ptr = end;
    while (ptr >= start) {
        if (*ptr == String) {
            break;
        }
        ptr--;
    }

    //
    // String not found case
    //

    if (ptr < start) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address not found in table", String, String));
        return;
    }

    //
    // Free LocalAlloc'd memory
    //

    LocalFree ((HLOCAL) String);

    //
    // If this element is not the end, copy real end to the ptr
    //

    if (ptr < end) {
        *ptr = *end;
    }

    //
    // Shrink buffer size
    //

    AllocTable->End -= sizeof (PCSTR);
}


VOID
FreeStringResourcePtrExA (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExA(AllocTable, *String);
        *String = NULL;
    }
}


VOID
FreeStringResourceExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR String
    )
{
    FreeStringResourceExA (AllocTable, (PCSTR) String);
}


VOID
FreeStringResourcePtrExW (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCWSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExW(AllocTable, *String);
        *String = NULL;
    }
}



/*++

Routine Description:

  The pAddStringResource function is used to track pointers allocated
  by FormatMessage.  They are added to an array (maintained in a GROWBUFFER
  structure).  This table of pointers is used by FreeStringResource or
  StringResourceFree.

Arguments:

  String   - A pointer to a LocalAlloc'd string (the return value of
             FormatMessage).  This string is added to a table of allocated
             strings.

Return Value:

  none

--*/

VOID
pAddStringResource (
    IN      PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PCSTR *ptr;

    ptr = (PCSTR *) GbGrow (GrowBuf, sizeof (PCSTR));
    if (ptr) {
        *ptr = String;
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "pAddStringResource: GrowBuffer failure caused memory leak"));
}


/*++

Routine Description:

  pFreeAllStringResourcesEx frees all strings currently listed in AllocTable.
  This function allows the caller to wait until all processing is done
  to clean up string resources that may have been allocated.

Arguments:

  none

Return Value:

  none

--*/

VOID
pFreeAllStringResourcesEx (
    IN      PGROWBUFFER AllocTable
    )
{
    PCSTR *ptr, *start, *end;

    if (AllocTable->End) {
        start = (PCSTR *) AllocTable->Buf;
        end = (PCSTR *) (AllocTable->Buf + AllocTable->End);

        for (ptr = start ; ptr < end ; ptr++) {
            LocalFree ((HLOCAL) (*ptr));
        }
    }

    GbFree (AllocTable);
}



/*++

Routine Description:

  CreateAllocTable creates a GROWBUFFER structure that can be used with
  ParseMessageEx, GetStringResourceEx, FreeStringResourceEx and
  pFreeAllStringResourcesEx.  Call this function to recieve a private
  allocation table to pass to these functions.  Call DestroyAllocTable
  to clean up.

Arguments:

  none

Return Value:

  A pointer to a GROWBUFFER structure, or NULL if a memory allocation failed.

--*/

PGROWBUFFER
RealCreateAllocTable (
    VOID
    )
{
    PGROWBUFFER allocTable;
    GROWBUFFER tempForInit = INIT_GROWBUFFER;

    allocTable = (PGROWBUFFER) MemAlloc (g_hHeap, 0, sizeof (GROWBUFFER));
    CopyMemory (allocTable, &tempForInit, sizeof (GROWBUFFER));

    return allocTable;
}


/*++

Routine Description:

  DestroyAllocTable cleans up all memory associated with an AllocTable.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure allocated by CreateAllocTable

Return Value:

  none

--*/

VOID
DestroyAllocTable (
    OUT     PGROWBUFFER AllocTable
    )
{
    MYASSERT (AllocTable);
    pFreeAllStringResourcesEx (AllocTable);
    MemFree (g_hHeap, 0, AllocTable);
}


/*++

Routine Description:

  BeginMessageProcessing enters a guarded section of code that plans to use the
  ParseMessage and GetStringResource functions, but needs cleanup at the end
  of processing.

  EndMessageProcessing destroys all memory allocated within the message processing
  block, and leaves the guarded section.

Arguments:

  none

Return Value:

  BeginMessageProcessing returns FALSE if an out-of-memory condition occurrs.

--*/


BOOL
BeginMessageProcessing (
    VOID
    )
{
    if (!TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to enter BeginMessageProcessing while another"
                              "thread is processing messages as well."));
        EnterOurCriticalSection (&g_MessageCs);
    }

    g_LastAllocTable = g_ShortTermAllocTable;
    g_ShortTermAllocTable = CreateAllocTable();

    MYASSERT (g_ShortTermAllocTable);

    return TRUE;
}


VOID
EndMessageProcessing (
    VOID
    )
{
    if (TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to end message processing when it hasn't been started"));
        LeaveOurCriticalSection (&g_MessageCs);
        return;
    }

    DestroyAllocTable (g_ShortTermAllocTable);
    g_ShortTermAllocTable = g_LastAllocTable;
    LeaveOurCriticalSection (&g_MessageCs);
}


/*++

Routine Description:

  ParseMessage is used to obtain a string from the executable's message table
  and parse it with FormatMessage.  An array of arguments can be passed by
  the caller.  FormatMessage will replace %1 with the first element of the
  array, %2 with the second element, and so on.  The array does not need to
  be terminated, and if a message string uses %n, element n must be non-NULL.

Arguments:

  Template  - A string indicating which message to extract, or a WORD value
              cast as a string.  (ParseMessageID does this cast via a macro.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  Pointer to the string allocated.  Call StringResourceFree to free all
  allocated strings (a one-time cleanup for all strings).  The pointer may
  be NULL if the resource does not exist or is empty.

--*/

PCSTR
ParseMessageExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR Template,
    IN      PCSTR ArgArray[]
    )
{
    PSTR MsgBuf;
    DWORD rc;

    if (SHIFTRIGHT16 ((UBINT)Template)) {
        //
        // From string
        //
        rc = FormatMessageA (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_STRING,
                (LPVOID) Template,
                0,
                0,
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    } else {
        //
        // From resource
        //
        rc = FormatMessageA (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)((UBINT)Template),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    }

    if (rc > 0) {
        pAddStringResource (AllocTable, MsgBuf);
        return MsgBuf;
    }

    return NULL;
}


PCWSTR
ParseMessageExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR Template,
    IN      PCWSTR ArgArray[]
    )
{
    PWSTR MsgBuf;
    DWORD rc;

    if (SHIFTRIGHT16 ((UBINT)Template)) {
        //
        // From string
        //
        rc = FormatMessageW (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_STRING,
                (LPVOID) Template,
                0,
                0,
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    } else {
        //
        // From resource
        //
        rc = FormatMessageW (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)(UBINT)Template,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    }

    if (rc > 0) {
        pAddStringResource (AllocTable, (PCSTR) MsgBuf);
        return MsgBuf;
    }

    return NULL;
}



/*++

Routine Description:

  GetStringResourceEx is an argument-less wrapper of ParseMessageEx.  It allows
  the caller to specify a message ID and recieve a pointer to the string if
  it exists, and a table to track FormatMessage's allocations.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure that is used to maintain
               the handles of allocated strings
  ID         - The ID of the message resource to retrieve

Return Value:

  Pointer to the string allocated.  The return pointer may
  be NULL if the resource does not exist or is empty.

  Call FreeStringResource or DestroyAllocTable to clean up AllocTable.


--*/

PCSTR
GetStringResourceExA (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExA (AllocTable, (PSTR) (WORD) ID, NULL);
}

PCWSTR
GetStringResourceExW (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExW (AllocTable, (PWSTR) (WORD) ID, NULL);
}



/*++

Routine Description:

  ParseMessageInWnd is used to exchange a string in a window with one from
  the executable's message table.  It is provided for dialog box initialization,
  where a field in the dialog box requires dynamic data.  The dialog box
  resource should contain a control with its window text set to the message
  string.  Upon processing WM_INITDIALOG, the code should call ParseMessageInWnd,
  supplying the necessary ArgArray, so the dialog box is initialized with
  a dynamic message.

Arguments:

  hwnd      - The handle of a window whose title contains the message string ID
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  none

--*/

VOID
ParseMessageInWndA (
    IN      HWND Hwnd,
    IN      PCSTR ArgArray[]
    )
{
    CHAR buffer[512];
    PCSTR parsedMsg;

    GetWindowTextA (Hwnd, buffer, 512);
    parsedMsg = ParseMessageA (buffer, ArgArray);
    if (parsedMsg) {
        SetWindowTextA (Hwnd, parsedMsg);
        FreeStringResourceA (parsedMsg);
    }
}


VOID
ParseMessageInWndW (
    IN      HWND hwnd,
    IN      PCWSTR ArgArray[]
    )
{
    WCHAR buffer[512];
    PCWSTR parsedMsg;

    GetWindowTextW (hwnd, buffer, 512);
    parsedMsg = ParseMessageW (buffer, ArgArray);
    if (parsedMsg) {
        SetWindowTextW (hwnd, parsedMsg);
        FreeStringResourceW (parsedMsg);
    }
}



/*++

Routine Description:

  ResourceMessageBox is used to display a message based on a message resource
  ID.

Arguments:

  HwndOwner - The handle of the owner of the message box to be displayed
  ID        - The identifier of the message resource
  Flags     - MessageBox flags (MB_OK, etc.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  The return value of MessageBox (MB_YES, etc.)

--*/

INT
ResourceMessageBoxA (
    IN      HWND HwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCSTR ArgArray[]
    )
{
    PCSTR message;
    PCSTR title;
    int rc;

    message = ParseMessageA ((PSTR)(UBINT)ID, ArgArray);
    if (!message)
        return -1;

    title = GetStringResourceA (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxA (HwndOwner, message, title, Flags);

    FreeStringResourceA (message);
    if (title) {
        FreeStringResourceA (title);
    }

    return rc;
}


INT
ResourceMessageBoxW (
    IN      HWND HwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCWSTR ArgArray[]
    )
{
    PCWSTR message;
    PCWSTR title;
    int rc;

    message = ParseMessageW ((PWSTR)(UBINT)ID, ArgArray);
    if (!message)
        return -1;

    title = GetStringResourceW (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxW (HwndOwner, message, title, Flags);

    FreeStringResourceW (message);
    if (title) {
        FreeStringResourceW (title);
    }

    return rc;
}


BOOL
StringReplaceA (
    IN      PSTR Buffer,
    IN      DWORD MaxSize,
    IN      PSTR ReplaceStartPos,
    IN      PSTR ReplaceEndPos,
    IN      PCSTR NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PSTR        movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (DWORD)((UBINT)ReplaceEndPos - (UBINT)ReplaceStartPos);
    newSubStringLength  = ByteCountA(NewString);
    currentStringLength = SizeOfStringA(Buffer) + 1;
    offset = (LONG)newSubStringLength - (LONG)oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if ((LONG)currentStringLength + offset > (LONG)MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 (UBINT)movePosition >= (UBINT)ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        } else {

            //
            // left or no shift.
            //
            for(movePosition = ReplaceStartPos + newSubStringLength;    //lint !e613
                movePosition < Buffer + currentStringLength;
                movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        CopyMemory (ReplaceStartPos, NewString, newSubStringLength);    //lint !e668

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}



BOOL
StringReplaceW (
    IN      PWSTR Buffer,
    IN      DWORD MaxSize,
    IN      PWSTR ReplaceStartPos,
    IN      PWSTR ReplaceEndPos,
    IN      PCWSTR NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PWSTR       movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (DWORD)((UBINT)ReplaceEndPos - (UBINT)ReplaceStartPos);
    newSubStringLength  = CharCountW(NewString);
    currentStringLength = CharCountW(Buffer) + 1;
    offset = (LONG)newSubStringLength - (LONG)oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if ((LONG)currentStringLength + offset > (LONG)MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 (UBINT)movePosition >= (UBINT)ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        } else {

            //
            // left or no shift.
            //
            for (movePosition = ReplaceStartPos + newSubStringLength;    //lint !e613
                 movePosition < Buffer + currentStringLength;
                 movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        wcsncpy(ReplaceStartPos,NewString,newSubStringLength);

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}

#if 0
/*++

Routine Description:

  AddInfSectionToHashTable enumerates the specified section and adds each
  item to the string table.  An optional callback allows data to be associated
  with each item.

Arguments:

  Table          - Specifies the table that receives new entries
  InfFile        - Specifies an open INF handle of the file to read
  Section        - Specifies the INF section name to enumerate
  Field          - Specifies which field to extract text from.  If the field
                   exists, it is added to the string table.
  Callback       - Specifies optional callback to be called before adding to
                   the string table.  The callback supplies additional data.
  CallbackParam  - Data passed to the callback

Return Value:

  TRUE if the INF file was processed successfullly, or FALSE if an error
  occurred.

--*/


BOOL
AddInfSectionToHashTableA (
    IN OUT  HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCSTR Section,
    IN      DWORD Field,
    IN      ADDINFSECTION_PROCA Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    LONG rc;
    HASHTABLE ht;
    DWORD reqSize;
    DWORD currentSize = 0;
    PSTR newBuffer, buffer = NULL;
    PVOID data;
    UINT dataSize;
    BOOL b = FALSE;

    //
    // On NT, Setup API is compiled with UNICODE, so the string table
    // functions are UNICODE only.
    //

    if (ISNT()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineA (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldA (&ic, Field, NULL, 0, &reqSize)) {
                continue;
            }

            if (reqSize > currentSize) {
                reqSize = ((reqSize / 1024) + 1) * 1024;
                if (buffer) {
                    newBuffer = (PSTR) MemReAlloc (g_hHeap, 0, buffer, reqSize);
                } else {
                    newBuffer = (PSTR) MemAlloc (g_hHeap, 0, reqSize);
                }

                if (!newBuffer) {
                    goto cleanup;
                }

                buffer = newBuffer;
                currentSize = reqSize;
            }

            if (!SetupGetStringFieldA (&ic, Field, buffer, currentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToHashTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            data = NULL;
            dataSize = 0;

            if (Callback) {
                rc = Callback (buffer, &data, &dataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            ht = HtAddStringExA (
                        Table,
                        buffer,
                        data,
                        CASE_INSENSITIVE
                        );

            if (!ht) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (buffer) {
        PushError();
        MemFree (g_hHeap, 0, buffer);
        PopError();
    }
    return b;
}


BOOL
AddInfSectionToHashTableW (
    IN OUT  HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCWSTR Section,
    IN      DWORD Field,
    IN      ADDINFSECTION_PROCW Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    HASHTABLE ht;
    LONG rc;
    DWORD reqSize;
    DWORD currentSize = 0;
    PWSTR newBuffer, buffer = NULL;
    PVOID data;
    UINT dataSize;
    BOOL b = FALSE;

    //
    // On Win9x, Setup API is compiled with ANSI, so the string table
    // functions are ANSI only.
    //

    if (ISWIN9X()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineW (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldW (&ic, Field, NULL, 0, &reqSize)) {
                continue;
            }

            if (reqSize > currentSize) {
                reqSize = ((reqSize / 1024) + 1) * 1024;
                if (buffer) {
                    newBuffer = (PWSTR) MemReAlloc (g_hHeap, 0, buffer, reqSize);
                } else {
                    newBuffer = (PWSTR) MemAlloc (g_hHeap, 0, reqSize);
                }

                if (!newBuffer) {
                    goto cleanup;
                }

                buffer = newBuffer;
                currentSize = reqSize;
            }

            if (!SetupGetStringFieldW (&ic, Field, buffer, currentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToHashTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            data = NULL;
            dataSize = 0;

            if (Callback) {
                rc = Callback (buffer, &data, &dataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            ht = HtAddStringExW (
                        Table,
                        buffer,
                        data,
                        CASE_INSENSITIVE
                        );

            if (!ht) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (buffer) {
        PushError();
        MemFree (g_hHeap, 0, buffer);
        PopError();
    }
    return b;
}
#endif

/*++

Routine Description:

  Finds the last wack in the path and returns a pointer to the next
  character.  If no wack is found, returns a pointer to the full
  string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file name in the path.

--*/

PCSTR
GetFileNameFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;

    p = _mbsrchr (PathSpec, '\\');
    if (p) {
        p = _mbsinc (p);
    } else {
        p = PathSpec;
    }

    return p;
}

PCWSTR
GetFileNameFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;

    p = wcsrchr (PathSpec, L'\\');
    if (p) {
        p++;
    } else {
        p = PathSpec;
    }

    return p;
}


/*++

Routine Description:

  Finds the last wack in the path and then the last point from the remaining path
  returning a pointer to the next character. If no point is found, returns a null pointer.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, excluding the dot, or NULL if no extension exists.

--*/

PCSTR
GetFileExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p + 1;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    return ReturnPtr;
}


PCWSTR
GetFileExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p + 1;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  GetDotExtensionFromPath finds the last wack in the path and then the last dot from
  the remaining path, returning a pointer to the dot. If no dot is found, returns the
  end of the string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, including the dot, or the end of the string if
  no extension exists.

--*/

PCSTR
GetDotExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


PCWSTR
GetDotExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  CountInstancesOfChar returns the number of occurances Char
  is found in String.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT count;

    count = 0;
    while (*String) {
        if (_mbsnextc (String) == Char) {
            count++;
        }

        String = _mbsinc (String);
    }

    return count;
}


UINT
CountInstancesOfCharW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT count;

    count = 0;
    while (*String) {
        if (*String == Char) {
            count++;
        }

        String++;
    }

    return count;
}


/*++

Routine Description:

  CountInstancesOfCharI returns the number of occurances Char
  is found in String.  The comparison is case-insenetive.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharIA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT count;

    Char = (MBCHAR)tolower ((INT)Char);

    count = 0;
    while (*String) {
        if ((MBCHAR) tolower ((INT)_mbsnextc (String)) == Char) {
            count++;
        }

        String = _mbsinc (String);
    }

    return count;
}


UINT
CountInstancesOfCharIW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT count;

    Char = towlower (Char);

    count = 0;
    while (*String) {
        if (towlower (*String) == Char) {
            count++;
        }

        String++;
    }

    return count;
}


/*++

Routine Description:

  Searches the string counting the number of occurances of
  SearchString exist in SourceString.

Arguments:

  SourceString - Specifies the text that may or may not contain
                 search text

  SearchString - Specifies the text phrase to count

Return Value:

  The number of times SearchString appears in SourceString.

--*/

UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    )
{
    PCSTR p;
    UINT count;
    UINT searchBytes;

    count = 0;
    p = SourceString;
    searchBytes = ByteCountA (SearchString);

    while (p = _mbsistr (p, SearchString)) {    //lint !e720
        count++;
        p += searchBytes;
    }

    return count;
}


UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    )
{
    PCWSTR p;
    UINT count;
    UINT SearchChars;

    count = 0;
    p = SourceString;
    SearchChars = CharCountW (SearchString);

    while (p = _wcsistr (p, SearchString)) {    //lint !e720
        count++;
        p += SearchChars;
    }

    return count;
}


/*++

Routine Description:

  Searches and replaces all occurances of SearchString with
  ReplaceString.

Arguments:

  SourceString - String that contiains zero or more instances
                 of the search text

  SearchString - String to search for.  Cannot be zero-length or NULL.

  ReplaceString - String to replace.  Can be zero-length but cannot
                  be NULL.

Return Value:

  A pointer to the pool-allocated string, or NULL if no instances
  of SearchString were found in SourceString.  Free the non-NULL
  pointer with FreePathString.

--*/

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    )
{
    PSTR newString;
    PBYTE p, q;
    PBYTE dest;
    UINT count;
    UINT size;
    UINT searchBytes;
    UINT replaceBytes;
    UINT untouchedBytes;

    //
    // count occurances within the string
    //

    count = CountInstancesOfSubStringA (
                SourceString,
                SearchString
                );

    if (!count) {
        return NULL;
    }

    searchBytes = ByteCountA (SearchString);
    replaceBytes = ByteCountA (ReplaceString);
    MYASSERT (searchBytes);

    size = SizeOfStringA (SourceString) -
           count * searchBytes +
           count * replaceBytes;

    newString = (PSTR) PmGetAlignedMemory (g_PathsPool, size);
    if (!newString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    dest = (PBYTE) newString;

    while (q = (PBYTE) _mbsistr ((PCSTR) p, SearchString)) {    //lint !e720

        untouchedBytes = (DWORD)(q - p);

        if (untouchedBytes) {
            CopyMemory (dest, p, (SIZE_T) untouchedBytes);
            dest += untouchedBytes;
        }

        if (replaceBytes) {
            CopyMemory (dest, (PBYTE) ReplaceString, (SIZE_T) replaceBytes);
            dest += replaceBytes;
        }

        p = q + searchBytes;
    }

    StringCopyA ((PSTR) dest, (PSTR) p);

    return newString;
}


PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    )
{
    PWSTR newString;
    PBYTE p, q;
    PBYTE dest;
    UINT count;
    UINT size;
    UINT searchBytes;
    UINT replaceBytes;
    UINT untouchedBytes;

    //
    // count occurances within the string
    //

    count = CountInstancesOfSubStringW (
                SourceString,
                SearchString
                );

    if (!count) {
        return NULL;
    }

    searchBytes = ByteCountW (SearchString);
    replaceBytes = ByteCountW (ReplaceString);
    MYASSERT (searchBytes);

    size = SizeOfStringW (SourceString) -
           count * searchBytes +
           count * replaceBytes;

    newString = (PWSTR) PmGetAlignedMemory (g_PathsPool, size);
    if (!newString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    dest = (PBYTE) newString;

    while (q = (PBYTE) _wcsistr ((PCWSTR) p, SearchString)) {   //lint !e720

        untouchedBytes = (DWORD)(q - p);

        if (untouchedBytes) {
            CopyMemory (dest, p, (SIZE_T) untouchedBytes);
            dest += untouchedBytes;
        }

        if (replaceBytes) {
            CopyMemory (dest, (PBYTE) ReplaceString, (SIZE_T) replaceBytes);
            dest += replaceBytes;
        }

        p = q + searchBytes;
    }

    StringCopyW ((PWSTR) dest, (PWSTR) p);

    return newString;
}


PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     PUINT NumArgs
    )

/*++

Routine Description:

  CommandLineToArgvA implements an ANSI version of the Win32 function
  CommandLineToArgvW.

Arguments:

  CmdLine   - A pointer to the complete command line, including the
              module name.  This is the same string returned by
              GetCommandLineA().

  NumArgs   - Receives the number of arguments allocated, identical to
              main's argc parameter.  That is, NumArgs is equal to
              the number of command line arguments plus one for the
              command itself.

Return Value:

  A pointer to an array of string pointers, one per argument.  The
  command line arguments are placed in separate nul-terminated strings.
  The caller must free the memory using a single call to GlobalFree or
  LocalFree.

--*/

{
    PCSTR start, end;
    BOOL QuoteMode;
    MBCHAR ch = 0;
    UINT Pass;
    UINT ArgStrSize;
    UINT Args;
    PSTR ArgStrEnd = NULL;     // filled in on pass one, used on pass two
    PSTR *ArgPtrArray = NULL;  // filled in on pass one, used on pass two

    //
    // count args on first pass, then allocate memory and create arg string
    //

    ArgStrSize = 0;
    Pass = 0;
    do {
        // Init loop
        Pass++;
        Args = 0;
        start = CmdLine;

        // Skip leading space
        while (isspace (*start)) {
            start++;
        }

        while (*start) {
            // Look for quote mode
            if (*start == '\"') {
                QuoteMode = TRUE;
                start++;
            } else {
                QuoteMode = FALSE;
            }

            // Find end of arg
            end = start;
            while (*end) {
                ch = _mbsnextc (end);
                if (QuoteMode) {
                    if (ch == '\"') {
                        break;
                    }
                } else {
                    if (isspace ((INT)ch)) {
                        break;
                    }
                }

                end = _mbsinc (end);
            }

            // If Pass 1, add string size
            if (Pass == 1) {
                ArgStrSize += (UINT)((UBINT)end - (UBINT)start) + 1;
            }

            // If Pass 2, copy strings to buffer
            else {
                MYASSERT (ArgStrEnd);
                MYASSERT (ArgPtrArray);

                ArgPtrArray[Args] = ArgStrEnd;  //lint !e613
                StringCopyABA (ArgStrEnd, start, end);
                ArgStrEnd = GetEndOfStringA (ArgStrEnd);    //lint !e668
                ArgStrEnd++;    //lint !e613
            }

            // Set start to next arg
            Args++;

            if (QuoteMode && ch == '\"') {
                end = _mbsinc (end);
            }

            start = end;
            while (isspace (*start)) {
                start++;
            }
        }

        // If Pass 1, allocate strings
        if (Pass == 1) {
            if (Args) {
                ArgPtrArray = (PSTR *) GlobalAlloc (
                                            GPTR,
                                            (UINT)(sizeof (PSTR) * Args + ArgStrSize)
                                            );
                if (!ArgPtrArray) {
                    return NULL;
                }

                ArgStrEnd = (PSTR) (&ArgPtrArray[Args]);
            } else {
                return NULL;
            }
        }
    } while (Pass < 2);

    *NumArgs = Args;
    return ArgPtrArray;
}


BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringA (MultiSzEnum->CurrentString) + 1;  //lint !e613
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}


BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringW (MultiSzEnum->CurrentString) + 1;
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}


PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    )
{
    PCSTR ptr = CurrPtr;

    for (;;) {
        ptr = _mbsdec2 (StartStr, ptr);

        if (!ptr) {
            return NULL;
        }
        if (_mbsnextc (ptr) == SearchChar) {
            return (PSTR) ptr;
        }
    }
}


PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    )
{
    PCWSTR ptr = CurrPtr;

    while (ptr > StartStr) {
        ptr--;

        if (*ptr == SearchChar) {
            return (PWSTR) ptr;
        }
    }

    return NULL;
}


VOID
ToggleWacksA (
    IN      PSTR Line,
    IN      BOOL Operation
    )
{
    CHAR curChar;
    CHAR newChar;
    PSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : '\\';
    newChar = Operation ? '\\' : WACK_REPLACE_CHAR;

    do {

        p = _mbschr (p, curChar);

        if (p) {

            *p = newChar;
            p = _mbsinc (p);
        }

    } while (p);
}


VOID
ToggleWacksW (
    IN      PWSTR Line,
    IN      BOOL Operation
    )
{
    WCHAR curChar;
    WCHAR newChar;
    PWSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : L'\\';
    newChar = Operation ? L'\\' : WACK_REPLACE_CHAR;

    do {

        p = wcschr (p, curChar);

        if (p) {

            *p = newChar;
            p++;
        }

    } while (p);
}


PSTR
pGoBackA (
    IN      PSTR LastChar,
    IN      PSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar = _mbsdec2 (FirstChar, LastChar);
    while (NumWacks && (LastChar >= FirstChar)) {
        if (_mbsnextc (LastChar) == '\\') {
            NumWacks --;
        }
        LastChar = _mbsdec2 (FirstChar, LastChar);
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}


PWSTR
pGoBackW (
    IN      PWSTR LastChar,
    IN      PWSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar --;
    while (NumWacks && (LastChar >= FirstChar)) {
        if (*LastChar == L'\\') {
            NumWacks --;
        }
        LastChar --;
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}


UINT
pCountDotsA (
    IN      PCSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (_mbsnextc (PathSeg) != '.') {
            return 0;
        }
        numDots ++;
        PathSeg = _mbsinc (PathSeg);
    }
    return numDots;
}


UINT
pCountDotsW (
    IN      PCWSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (*PathSeg != L'.') {
            return 0;
        }
        numDots ++;
        PathSeg ++;
    }
    return numDots;
}

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    )
{
    CHAR pathSeg [MAX_MBCHAR_PATH];
    PCSTR wackPtr;
    UINT dotNr;
    PSTR newPath = DuplicatePathStringA (FileSpec, 0);
    PSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = _mbschr (FileSpec, '\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr = _mbsinc (wackPtr);
                if (!wackPtr) {
                    FreePathStringA (newPath);
                    return NULL;
                }
                if (_mbsnextc (wackPtr) == '\\') {
                    // this one starts with a double wack
                    wackPtr = _mbsinc (wackPtr);
                    if (!wackPtr) {
                        FreePathStringA (newPath);
                        return NULL;
                    }
                    wackPtr = _mbschr (wackPtr, '\\');
                } else {
                    wackPtr = _mbschr (wackPtr, '\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {
                StringCopyByteCountABA (pathSeg, FileSpec, wackPtr, MAX_MBCHAR_PATH);
                FileSpec = _mbsinc (wackPtr);
            } else {
                StringCopyByteCountABA (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MAX_MBCHAR_PATH);
            }
        } else {
            StringCopyByteCountABA (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MAX_MBCHAR_PATH);
        }

        if (*pathSeg) {
            dotNr = pCountDotsA (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackA (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGA ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringA (newPath);
                    return NULL;
                }
            } else {

                StringCopyA (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringA (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = '\\';
                    //we increment this because we know that \ is a single byte character.
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR pathSeg [MEMDB_MAX];
    PCWSTR wackPtr;
    UINT dotNr;
    PWSTR newPath = DuplicatePathStringW (FileSpec, 0);
    PWSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;
    if (!FileSpec)
        return NULL;

    do {
        wackPtr = wcschr (FileSpec, L'\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr ++;
                if (*wackPtr == 0) {
                    FreePathStringW (newPath);
                    return NULL;
                }
                if (*wackPtr == L'\\') {
                    // this one starts with a double wack
                    wackPtr ++;
                    if (!wackPtr) {
                        FreePathStringW (newPath);
                        return NULL;
                    }
                    wackPtr = wcschr (wackPtr, L'\\');
                } else {
                    wackPtr = wcschr (wackPtr, L'\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {

                StringCopyByteCountABW (
                    pathSeg,
                    FileSpec,
                    wackPtr,
                    (UINT) sizeof (pathSeg)
                    );

                FileSpec = wackPtr + 1;
            } else {
                StringCopyByteCountABW (pathSeg, FileSpec, GetEndOfStringW (FileSpec), MAX_WCHAR_PATH);
            }
        } else {
            StringCopyByteCountABW (pathSeg, FileSpec, GetEndOfStringW (FileSpec), MAX_WCHAR_PATH);
        }

        if (*pathSeg) {
            dotNr = pCountDotsW (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackW (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGW ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringW (newPath);
                    return NULL;
                }
            } else {

                StringCopyW (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringW (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = L'\\';
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

UINT
pBuildFromDHList (
    IN      UINT ch1,
    IN      UINT ch2
    )
{
    PDHLIST p;
    UINT result = 0;

    p = g_DHList;
    while (p->char1) {
        if ((p->char1 == ch1) && (p->char2 == ch2)) {
            result = p->result;
            break;
        }
        p++;
    }
    return result;
}


VOID
_mbssetchar (
    OUT     PSTR Dest,
    IN      UINT Char
    )
{
    if (Char >= 256) {
        *(Dest+1) = *((PBYTE)(&Char));
        *(Dest) = *((PBYTE)(&Char) + 1);
    }
    else {
        *Dest = (CHAR) Char;
    }
}


/*++

Routine Description:

    FindLastWack finds the position of the last \ in the given string or NULL if none found

Arguments:

    Str - Specifies the string

Return Value:

    Pointer to the last occurence of a \ in the string or NULL

--*/

PCSTR
FindLastWackA (
    IN      PCSTR Str
    )
{
    PCSTR lastWack = NULL;

    if (Str) {
        while ((Str = _mbschr (Str, '\\')) != NULL) {
            lastWack = Str;
            Str++;
        }
    }

    return lastWack;
}


PCWSTR
FindLastWackW (
    IN      PCWSTR Str
    )
{
    PCWSTR lastWack = NULL;

    if (Str) {
        while ((Str = wcschr (Str, L'\\')) != NULL) {
            lastWack = Str;
            Str++;
        }
    }

    return lastWack;
}


/*++

Routine Description:

    GetNodePatternMinMaxLevels treats the given string pattern as a path with \ as separator
    and computes the min and max levels of the given node; the root has level 1; if a * is
    followed by \ it is treated as a single level (e.g. *\ only enumerates roots)

Arguments:

    NodePattern - Specifies the node as a string pattern
    FormattedNodePattern - Receives the formatted string, eliminating duplicate * and the last \;
                    may be the same as NodePattern
    MinLevel - Receives the minimum level of a node having this pattern
    MaxLevel - Receives the maximum level of a node having this pattern; may be NODE_LEVEL_MAX

Return Value:

    TRUE if NodePattern is a valid pattern and the function succeeded, FALSE otherwise

--*/

#define NODESTATE_BEGIN     0
#define NODESTATE_UNC       1
#define NODESTATE_BEGINSEG  2
#define NODESTATE_INSEG     3
#define NODESTATE_ESCAPED   4
#define NODESTATE_STAR      5
#define NODESTATE_STARONLY  6

BOOL
GetNodePatternMinMaxLevelsA (
    IN          PCSTR NodePattern,
    OUT         PSTR FormattedNode,     OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    )
{
    PCSTR nodePattern = NodePattern;
    MBCHAR currCh = 0;
    DWORD minLevel = 0;
    DWORD maxLevel = 0;
    DWORD state = NODESTATE_BEGIN;
    BOOL advance;
    BOOL copyChar;

    if (!NodePattern || *NodePattern == 0) {
        return FALSE;
    }

    while (*nodePattern) {
        advance = TRUE;
        copyChar = TRUE;
        currCh = _mbsnextc (nodePattern);
        switch (state) {
        case NODESTATE_BEGIN:
            switch (currCh) {
            case '\\':
                state = NODESTATE_UNC;
                break;
            case '*':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '?':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_ESCAPED;
                break;
            default:
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_UNC:
            minLevel ++;
            if (maxLevel != NODE_LEVEL_MAX) {
                maxLevel ++;
            }
            switch (currCh) {
            case '\\':
                state = NODESTATE_BEGINSEG;
                break;
            case '*':
                state = NODESTATE_BEGINSEG;
                advance = FALSE;
                break;
            case '?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_BEGINSEG:
            switch (currCh) {
            case '\\':
                DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: two wacks in a row: %s", NodePattern));
                return FALSE;
            case '*':
                minLevel --;
                state = NODESTATE_STARONLY;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case '?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_STARONLY:
            state = NODESTATE_INSEG;
            if (currCh == '*') {
                copyChar = FALSE;
            } else {
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                advance = FALSE;
            }
            break;
        case NODESTATE_STAR:
            state = NODESTATE_INSEG;
            if (currCh == '*') {
                copyChar = FALSE;
            } else {
                advance = FALSE;
            }
            break;
        case NODESTATE_INSEG:
            switch (currCh) {
            case '\\':
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                state = NODESTATE_BEGINSEG;
                break;
            case '*':
                state = NODESTATE_STAR;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case '?':
                state = NODESTATE_INSEG;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_ESCAPED:
            if (!_mbschr (EscapedCharsA, currCh)) {
                DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: illegal escaped character: %s", NodePattern));
                return FALSE;
            }
            state = NODESTATE_INSEG;
            break;
        default:
            DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: unknown state while processing: %s", NodePattern));
            return FALSE;
        }
        if (advance) {
            if (copyChar && FormattedNode) {
                if (IsLeadByte (*nodePattern)) {
                    *FormattedNode = *nodePattern;
                    FormattedNode ++;
                    nodePattern ++;
                }
                *FormattedNode = *nodePattern;
                FormattedNode ++;
                nodePattern ++;
            } else {
                nodePattern = _mbsinc (nodePattern);
            }
        }
    }
    if (MinLevel) {
        *MinLevel = minLevel;
    }
    if (MaxLevel) {
        *MaxLevel = maxLevel;
    }
    if (FormattedNode) {
        *FormattedNode = 0;
    }
    return TRUE;
}

BOOL
GetNodePatternMinMaxLevelsW (
    IN          PCWSTR NodePattern,
    OUT         PWSTR FormattedNode,    OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    )
{
    PCWSTR nodePattern = NodePattern;
    DWORD minLevel = 0;
    DWORD maxLevel = 0;
    DWORD state = NODESTATE_BEGIN;
    BOOL advance;
    BOOL copyChar;

    if (!NodePattern || *NodePattern == 0) {
        return FALSE;
    }

    while (*nodePattern) {
        advance = TRUE;
        copyChar = TRUE;
        switch (state) {
        case NODESTATE_BEGIN:
            switch (*nodePattern) {
            case L'\\':
                state = NODESTATE_UNC;
                break;
            case L'*':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'?':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_ESCAPED;
                break;
            default:
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_UNC:
            minLevel ++;
            if (maxLevel != NODE_LEVEL_MAX) {
                maxLevel ++;
            }
            switch (*nodePattern) {
            case L'\\':
                state = NODESTATE_BEGINSEG;
                break;
            case L'*':
                state = NODESTATE_BEGINSEG;
                advance = FALSE;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_BEGINSEG:
            switch (*nodePattern) {
            case L'\\':
                DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: two wacks in a row: %s", NodePattern));
                return FALSE;
            case L'*':
                minLevel --;
                state = NODESTATE_STARONLY;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_STARONLY:
            state = NODESTATE_INSEG;
            if (*nodePattern == L'*') {
                copyChar = FALSE;
            } else {
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                advance = FALSE;
            }
            break;
        case NODESTATE_STAR:
            state = NODESTATE_INSEG;
            if (*nodePattern == L'*') {
                copyChar = FALSE;
            } else {
                advance = FALSE;
            }
            break;
        case NODESTATE_INSEG:
            switch (*nodePattern) {
            case L'\\':
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                state = NODESTATE_BEGINSEG;
                break;
            case L'*':
                state = NODESTATE_STAR;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_ESCAPED:
            if (!wcschr (EscapedCharsW, *nodePattern)) {
                DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: illegal escaped character: %s", NodePattern));
                return FALSE;
            }
            state = NODESTATE_INSEG;
            break;
        default:
            DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: unknown state while processing: %s", NodePattern));
            return FALSE;
        }
        if (advance) {
            if (copyChar && FormattedNode) {
                *FormattedNode = *nodePattern;
                FormattedNode ++;
                nodePattern ++;
            } else {
                nodePattern ++;
            }
        }
    }
    if (MinLevel) {
        *MinLevel = minLevel;
    }
    if (MaxLevel) {
        *MaxLevel = maxLevel;
    }
    if (FormattedNode) {
        *FormattedNode = 0;
    }
    return TRUE;
}

#if 0
//
// PORTBUG Uses memdb max. #if 0'd out for now.
//
PCSTR
ConvertSBtoDB (
    IN      PCSTR RootPath,
    IN      PCSTR FullPath,
    IN      PCSTR Limit
    )
{
    CHAR result[MEMDB_MAX];
    PCSTR p,p1,q;
    PSTR s;
    UINT ch;
    UINT ch1;
    BOOL dhCase = FALSE;

    ZeroMemory (result, MAX_PATH);
    p = FullPath;
    q = RootPath;
    s = result;

    while (*p && (((DWORD)s - (DWORD)result) < MEMDB_MAX)) {
        if (q && *q) {
            _mbssetchar (s, _mbsnextc(p));
            q = _mbsinc (q);
        } else if (Limit && (p >= Limit)) {
            _mbssetchar (s, _mbsnextc(p));
        } else {
            ch = _mbsnextc (p);

            //
            // It is very important not to make the conversion for characters below A1. Otherwise
            // all english letters will be converted to large letters.
            //
            if (ch >= 0xA1 && ch <= 0xDF) {
                // this is a candidate for conversion
                // we need to see if there is a special Dakutenn/Handakuten conversion
                dhCase = FALSE;
                p1 = _mbsinc (p);
                if (p1) {
                    ch1 = _mbsnextc (p1);
                    ch1 = pBuildFromDHList (ch, ch1);
                    if (ch1) {
                        p = _mbsinc (p);
                        _mbssetchar (s, ch1);
                        dhCase = TRUE;
                    }
                }
                if (!dhCase) {
                    _mbssetchar (s, _mbbtombc (ch));
                }
            } else {
                _mbssetchar (s, ch);
            }
        }
        p = _mbsinc (p);
        s = _mbsinc (s);
    }
    result [MAX_PATH - 1] = 0;
    return (DuplicatePathString (result, 0));
}

#endif

ULONGLONG
StringToUint64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    ULONGLONG n;

    n = 0;
    while (*String >= '0' && *String <= '9') {
        n = n * 10 + *String - '0';
        String++;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


ULONGLONG
StringToUint64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    ULONGLONG n;

    n = 0;
    while (*String >= L'0' && *String <= L'9') {
        n = n * 10 + *String - L'0';
        String++;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


LONGLONG
StringToInt64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    LONGLONG n;
    BOOL negate = FALSE;

    if (*String == '-') {
        negate = TRUE;
        String++;
    } else if (*String == '+') {
        String++;
    }

    n = 0;
    while (*String >= '0' && *String <= '9') {
        n = n * 10 + *String - '0';
        String++;
    }

    if (negate) {
        n = -n;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


LONGLONG
StringToInt64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    LONGLONG n;
    BOOL negate = FALSE;

    if (*String == L'-') {
        negate = TRUE;
        String++;
    } else if (*String == L'+') {
        String++;
    }

    n = 0;
    while (*String >= L'0' && *String <= L'9') {
        n = n * 10 + *String - L'0';
        String++;
    }

    if (negate) {
        n = -n;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\objstr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    objstr.c

Abstract:

    Implements a set of APIs to handle the string representation of nodes/leafs of a tree

Author:

    03-Jan-2000 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

/*
                                   +-------+
                                   | root1 |                            Level 1
                                   +-------+
                                      / \
                                    /     \
                          +---------+     (-------)
                          |  node1  |    (  leaf1  )                    Level 2
                          +---------+     (-------)
                          /  |   \  \__________
                        /    |     \           \
               +-------+ +-------+  (-------)   (-------)
               | node2 | | node3 | (  leaf2  ) (  leaf3  )              Level 3
               +-------+ +-------+  (-------)   (-------)
                  / \
                /     \
          +-------+  (-------)
          | node4 | (  leaf4  )                                         Level 4
          +-------+  (-------)
             / \
           /     \
    (-------)   (-------)
   (  leaf5  ) (  leaf6  )                                              Level 5
    (-------)   (-------)


    The string representation of some tree elements above:

    root1
    root1 <leaf1>
    root1\node1
    root1\node1 <leaf2>
    root1\node1 <leaf3>

*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_OBJSTR      "ObjStr"

//
// Strings
//

#define S_OBJSTR        "ObjStr"

//
// Constants
//

#define OBJSTR_LEAF_HEADA           '<'
#define OBJSTR_LEAF_HEADW           L'<'

#define OBJSTR_LEAF_TAILA           '>'
#define OBJSTR_LEAF_TAILW           L'>'

#define OBJSTR_SEPARATORA           ' '
#define OBJSTR_SEPARATORW           L' '


//
// Macros
//

#define pObjStrAllocateMemory(Size)   PmGetMemory (g_ObjStrPool, Size)

#define pObjStrFreeMemory(Buffer)     if (/*lint --e(774)*/Buffer) PmReleaseMemory (g_ObjStrPool, Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_ObjStrPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
ObsInitialize (
    VOID
    )

/*++

Routine Description:

    ObsInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_ObjStrPool = PmCreateNamedPool (S_OBJSTR);
    return g_ObjStrPool != NULL;
}


VOID
ObsTerminate (
    VOID
    )

/*++

Routine Description:

    ObsTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    if (g_ObjStrPool) {
        PmDestroyPool (g_ObjStrPool);
        g_ObjStrPool = NULL;
    }
}


/*++

Routine Description:

    pExtractStringAB is a private function that creates a new string in the given pool,
    using a source string and a limit to copy up to.

Arguments:

    Start - Specifies the source string
    End - Specifies the point to copy up to (excluding it), within the same string
    Pool - Specifies the pool to use for allocation

Return Value:

    A pointer to the newly created string

--*/

PSTR
pExtractStringABA (
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      PMHANDLE Pool
    )
{
    PSTR p;

    p = PmGetMemory (Pool, (DWORD)(End - Start + 1) * DWSIZEOF (CHAR));
    StringCopyABA (p, Start, End);
    return p;
}


PWSTR
pExtractStringABW (
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      PMHANDLE Pool
    )
{
    PWSTR p;

    p = PmGetMemory (Pool, (DWORD)(End - Start + 1) * DWSIZEOF (WCHAR));
    StringCopyABW (p, Start, End);
    return p;
}


/*++

Routine Description:

    ObsFree frees the given object from the private pool

Arguments:

    EncodedObject - Specifies the source string
    End - Specifies the point to copy up to (excluding it), within the same string
    Pool - Specifies the pool to use for allocation

Return Value:

    A pointer to the newly created string

--*/

VOID
ObsFreeA (
    IN      PCSTR EncodedObject
    )
{
    pObjStrFreeMemory ((PVOID)EncodedObject);
}


VOID
ObsFreeW (
    IN      PCWSTR EncodedObject
    )
{
    pObjStrFreeMemory ((PVOID)EncodedObject);
}

BOOL
ObsEncodeStringA (
    PSTR Destination,
    PCSTR Source
    )
{
    MBCHAR ch;

    while (*Source) {
        ch = _mbsnextc (Source);
        if (_mbschr (EscapedCharsA, ch)) {
            *Destination = '^';
            Destination ++;
        }
        // now copy the multibyte character
        if (IsLeadByte (*Source)) {
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
        *Destination = *Source;
        Destination ++;
        Source ++;
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsEncodeStringW (
    PWSTR Destination,
    PCWSTR Source
    )
{
    while (*Source) {
        if (wcschr (EscapedCharsW, *Source)) {
            *Destination = L'^';
            Destination ++;
        }
        *Destination = *Source;
        Destination ++;
        Source ++;
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsDecodeStringA (
    PSTR Destination,
    PCSTR Source
    )
{
    BOOL escaping = FALSE;

    while (*Source) {
        if ((_mbsnextc (Source) == '^') && (!escaping)) {
            escaping = TRUE;
            Source ++;
        } else {
            escaping = FALSE;
            // now copy the multibyte character
            if (IsLeadByte (*Source)) {
                *Destination = *Source;
                Destination ++;
                Source ++;
            }
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsDecodeStringW (
    PWSTR Destination,
    PCWSTR Source
    )
{
    BOOL escaping = FALSE;

    while (*Source) {
        if ((*Source == L'^') && (!escaping)) {
            escaping = TRUE;
            Source ++;
        } else {
            escaping = FALSE;
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
    }
    *Destination = 0;
    return TRUE;
}


/*++

Routine Description:

    ObsSplitObjectStringEx splits the given encoded object into components: node and
    leaf. Strings are allocated from the given pool

Arguments:

    EncodedObject - Specifies the source object string
    DecodedNode - Receives the decoded node part; optional
    DecodedLeaf - Receives the decoded leaf part; optional
    Pool - Specifies the pool to use for allocation; optional; if not specified,
           the module pool will be used and ObsFree needs to be called for them
           to be freed

Return Value:

    TRUE if the source object has a legal format and it has been split into components

--*/

BOOL
ObsSplitObjectStringExA (
    IN      PCSTR EncodedObject,
    OUT     PSTR* DecodedNode,          OPTIONAL
    OUT     PSTR* DecodedLeaf,          OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    )
{
    PCSTR p;
    PCSTR q;
    PCSTR nodeTerm;
    PSTR leaf = NULL;
    PCSTR lastWack = NULL;
    PCSTR lastStar = NULL;

    MYASSERT (EncodedObject);
    if (!EncodedObject) {
        return FALSE;
    }

    if (!Pool) {
        Pool = g_ObjStrPool;
    }

    p = EncodedObject;

    if (*p == '\\') {
        //
        // must be UNC format; check for syntax
        //
        p++;
        if (*p != '\\') {
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExA: relative paths not supported: %s",
                EncodedObject
                ));
            return FALSE;
        }
    }

    while (*p && *p != OBJSTR_LEAF_HEADA) {
        if (*p == OBJSTR_SEPARATORA) {
            q = p + 1;
            while (*q == OBJSTR_SEPARATORA) {
                q++;
            }
            if (*q == 0 || *q == OBJSTR_LEAF_HEADA) {
                break;
            }
            p = q;
        }
        if (*p == '\\') {
            if ((UBINT)p == (UBINT)lastWack + 1) {
                //
                // two wacks in a row? no way
                //
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsSplitObjectStringExA: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                return FALSE;
            }
            lastWack = p;
        } else if (*p == '*') {
            lastStar = p;
        }
        p = CharNextA (p);
    }

    if (p == EncodedObject) {
        DEBUGMSGA ((
            DBG_OBJSTR,
            "ObsSplitObjectStringExA: Bad EncodedObject: %s",
            EncodedObject
            ));
        return FALSE;
    }

    if (lastWack && lastWack + 1 == p && lastStar && lastStar + 1 != lastWack) {
        nodeTerm = lastWack;
    } else {
        nodeTerm = p;
    }

    while (*p == OBJSTR_SEPARATORA) {
        //
        // *p is one byte wide
        //
        p++;
    }

    if (*p) {

        if (*p != OBJSTR_LEAF_HEADA) {
            //
            // wrong start
            //
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExA: Bad EncodedObject: %s",
                EncodedObject
                ));
            return FALSE;
        }

        q = p + 1;
        while (*q != OBJSTR_LEAF_TAILA) {
            if (*q == 0) {
                //
                // incorrectly terminated
                //
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsSplitObjectStringExA: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                return FALSE;
            }
            q = CharNextA (q);
        }

        if (*(q + 1) != 0) {
            //
            // must end after the terminating char
            //
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExA: Bad EncodedObject: \"%s\"; chars after the leaf",
                EncodedObject
                ));
            return FALSE;
        }

        if (DecodedLeaf) {
            leaf = pExtractStringABA (p + 1, q, Pool);
            if (DecodeStrings) {
                //
                // decode chars
                //
                ObsDecodeStringA (leaf, leaf);
            }
        }
    }

    if (DecodedLeaf) {
        *DecodedLeaf = leaf;
    }

    if (DecodedNode) {
        *DecodedNode = pExtractStringABA (EncodedObject, nodeTerm, Pool);
        if (DecodeStrings) {
            //
            // decode chars
            //
            ObsDecodeStringA (*DecodedNode, *DecodedNode);
        }
    }

    return TRUE;
}


BOOL
ObsSplitObjectStringExW (
    IN      PCWSTR EncodedObject,
    OUT     PWSTR* DecodedNode,         OPTIONAL
    OUT     PWSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    )
{
    PCWSTR p;
    PCWSTR q;
    PCWSTR nodeTerm;
    PWSTR leaf = NULL;
    PCWSTR lastWack = NULL;
    PCWSTR lastStar = NULL;

    MYASSERT (EncodedObject);
    if (!EncodedObject) {
        return FALSE;
    }

    if (!Pool) {
        Pool = g_ObjStrPool;
    }

    p = EncodedObject;

    if (*p == L'\\') {
        //
        // must be UNC format; check for syntax
        //
        p++;
        if (*p != L'\\') {
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExW: relative paths not supported: %s",
                EncodedObject
                ));
            return FALSE;
        }
    }

    while (*p && *p != OBJSTR_LEAF_HEADW) {
        if (*p == OBJSTR_SEPARATORW) {
            q = p + 1;
            while (*q == OBJSTR_SEPARATORW) {
                q++;
            }
            if (*q == 0 || *q == OBJSTR_LEAF_HEADW) {
                break;
            }
            p = q;
        }
        if (*p == L'\\') {
            if ((UBINT)p == (UBINT)lastWack + 1) {
                //
                // two wacks in a row? no way
                //
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsSplitObjectStringExW: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                return FALSE;
            }
            lastWack = p;
        } else if (*p == L'*') {
            lastStar = p;
        }
        p++;
    }

    if (p == EncodedObject) {
        DEBUGMSGW ((
            DBG_OBJSTR,
            "ObsSplitObjectStringExW: Bad EncodedObject: %s",
            EncodedObject
            ));
        return FALSE;
    }

    if (lastWack && lastWack + 1 == p && lastStar && lastStar + 1 != lastWack) {
        nodeTerm = lastWack;
    } else {
        nodeTerm = p;
    }

    while (*p == OBJSTR_SEPARATORW) {
        //
        // *p is one WCHAR wide
        //
        p++;
    }

    if (*p) {

        if (*p != OBJSTR_LEAF_HEADW) {
            //
            // wrong start
            //
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExW: Bad EncodedObject: %s",
                EncodedObject
                ));
            return FALSE;
        }

        q = p + 1;
        while (*q != OBJSTR_LEAF_TAILW) {
            if (*q == 0) {
                //
                // incorrectly terminated
                //
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsSplitObjectStringExW: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                return FALSE;
            }
            q++;
        }

        if (*(q + 1) != 0) {
            //
            // must end after the terminating char
            //
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsSplitObjectStringExW: Bad EncodedObject: \"%s\"; chars after the leaf",
                EncodedObject
                ));
            return FALSE;
        }

        if (DecodedLeaf) {
            leaf = pExtractStringABW (p + 1, q, Pool);
            if (DecodeStrings) {
                //
                // decode chars
                //
                ObsDecodeStringW (leaf, leaf);
            }
        }
    }

    if (DecodedLeaf) {
        *DecodedLeaf = leaf;
    }

    if (DecodedNode) {
        *DecodedNode = pExtractStringABW (EncodedObject, nodeTerm, Pool);
        if (DecodeStrings) {
            //
            // decode chars
            //
            ObsDecodeStringW (*DecodedNode, *DecodedNode);

        }
    }
    return TRUE;
}


/*++

Routine Description:

    ObsBuildEncodedObjectStringEx builds an encoded object from components: node and
    leaf. The string is allocated from the module's pool

Arguments:

    DecodedNode - Specifies the decoded node part
    DecodedLeaf - Specifies the decoded leaf part; optional
    EncodeObject - Specifies TRUE if the resulting object needs to be encoded using
                   encoding rules

Return Value:

    Pointer to the newly created object string

--*/

PSTR
ObsBuildEncodedObjectStringExA (
    IN      PCSTR DecodedNode,
    IN      PCSTR DecodedLeaf,      OPTIONAL
    IN      BOOL EncodeObject
    )
{
    PSTR encodedNode;
    PSTR encodedLeaf;
    PSTR encodedString;

    MYASSERT (DecodedNode);
    if (!DecodedNode) {
        return NULL;
    }
    //
    // at most, one byte char will be expanded to 4 bytes (4 times)
    //
    if (EncodeObject) {
        encodedNode = pObjStrAllocateMemory (4 * ByteCountA (DecodedNode) + DWSIZEOF(CHAR));
        ObsEncodeStringA (encodedNode, DecodedNode);
    } else {
        encodedNode = DuplicateTextExA (g_ObjStrPool, DecodedNode, 0, NULL);
    }

    if (!DecodedLeaf) {
        return encodedNode;
    }

    if (EncodeObject) {
        encodedLeaf = pObjStrAllocateMemory (4 * ByteCountA (DecodedLeaf) + DWSIZEOF(CHAR));
        ObsEncodeStringA (encodedLeaf, DecodedLeaf);
    } else {
        encodedLeaf = DuplicateTextExA (g_ObjStrPool, DecodedLeaf, 0, NULL);
    }

    //
    // preferred format: %1 <%2>    %1 - Node, %2 - Leaf
    //
    encodedString = pObjStrAllocateMemory (
                        ByteCountA (encodedNode) +
                        DWSIZEOF (" <>") +
                        ByteCountA (encodedLeaf)
                        );
    wsprintfA (
        encodedString,
        "%s %c%s%c",
        encodedNode,
        OBJSTR_LEAF_HEADA,
        encodedLeaf,
        OBJSTR_LEAF_TAILA
        );

    pObjStrFreeMemory (encodedNode);
    pObjStrFreeMemory (encodedLeaf);

    return encodedString;
}


PWSTR
ObsBuildEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,     OPTIONAL
    IN      BOOL EncodeObject
    )
{
    PWSTR encodedNode;
    PWSTR encodedLeaf;
    PWSTR encodedString;

    MYASSERT (DecodedNode);
    if (!DecodedNode) {
        return NULL;
    }
    //
    // at most, one wide char will be expanded to 4 wide chars (4 times)
    //
    if (EncodeObject) {
        encodedNode = pObjStrAllocateMemory (4 * ByteCountW (DecodedNode) + DWSIZEOF(WCHAR));
        ObsEncodeStringW (encodedNode, DecodedNode);
    } else {
        encodedNode = DuplicateTextExW (g_ObjStrPool, DecodedNode, 0, NULL);
    }

    if (!DecodedLeaf) {
        return encodedNode;
    }

    if (EncodeObject) {
        encodedLeaf = pObjStrAllocateMemory (4 * ByteCountW (DecodedLeaf) + DWSIZEOF(WCHAR));
        ObsEncodeStringW (encodedLeaf, DecodedLeaf);
    } else {
        encodedLeaf = DuplicateTextExW (g_ObjStrPool, DecodedLeaf, 0, NULL);
    }

    //
    // preferred format: %1 <%2>    %1 - Node, %2 - Leaf
    //
    encodedString = pObjStrAllocateMemory (
                        ByteCountW (encodedNode) +
                        DWSIZEOF (L" <>") +
                        ByteCountW (encodedLeaf)
                        );
    wsprintfW (
        encodedString,
        L"%s %c%s%c",
        encodedNode,
        OBJSTR_LEAF_HEADW,
        encodedLeaf,
        OBJSTR_LEAF_TAILW
        );

    pObjStrFreeMemory (encodedNode);
    pObjStrFreeMemory (encodedLeaf);

    return encodedString;
}


/*++

Routine Description:

    ObsCreateParsedPatternEx parses the given object into an internal format for quick
    pattern matching

Arguments:

    EncodedObject - Specifies the source object string

Return Value:

    A pointer to the newly created structure or NULL if the object was invalid

--*/

POBSPARSEDPATTERNA
ObsCreateParsedPatternExA (
    IN      PCSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    )
{
    POBSPARSEDPATTERNA ospp;
    PSTR decodedNode;
    PSTR decodedLeaf;
    PCSTR p;
    PCSTR root;

    MYASSERT (EncodedObject);

    if (!ObsSplitObjectStringExA (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return NULL;
    }

    ospp = pObjStrAllocateMemory (DWSIZEOF(OBSPARSEDPATTERNA));
    ZeroMemory (ospp, DWSIZEOF(OBSPARSEDPATTERNA));
    ospp->MaxSubLevel = NODE_LEVEL_MAX;

    MYASSERT (decodedNode);
    if (!GetNodePatternMinMaxLevelsA (decodedNode, decodedNode, &ospp->MinNodeLevel, &ospp->MaxNodeLevel)) {
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }

    MYASSERT (ospp->MinNodeLevel > 0 && ospp->MaxNodeLevel >= ospp->MinNodeLevel);
    if (ospp->MaxNodeLevel != NODE_LEVEL_MAX) {
        ospp->MaxSubLevel = ospp->MaxNodeLevel - ospp->MinNodeLevel;
    }

    ospp->NodePattern = CreateParsedPatternA (decodedNode);
    if (!ospp->NodePattern) {
        DEBUGMSGA ((
            DBG_OBJSTR,
            "ObsCreateParsedPatternExA: Bad EncodedObject: %s",
            EncodedObject
            ));
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }
    if (ospp->NodePattern->PatternCount > 1) {
        DEBUGMSGA ((
            DBG_OBJSTR,
            "ObsCreateParsedPatternExA: Bad EncodedObject (multiple patterns specified): %s",
            EncodedObject
            ));
        DestroyParsedPatternA (ospp->NodePattern);
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }

    root = ParsedPatternGetRootA (ospp->NodePattern);
    if (root) {
        //
        // extract the real root part
        //
        if (ParsedPatternIsExactMatchA (ospp->NodePattern)) {
            ospp->Flags |= OBSPF_EXACTNODE;
            ospp->ExactRoot = DuplicateTextExA (g_ObjStrPool, root, 0, NULL);
            ospp->ExactRootBytes = ByteCountA (root);
            ospp->MaxSubLevel = 0;
        } else {
            p = FindLastWackA (root);
            if (p) {
                //
                // exact root specified
                // if the last wack is actually the last character or is followed by star(s),
                // optimize the matching by setting some flags
                //
                if (*(p + 1) == 0) {
                    if (ParsedPatternIsRootPlusStarA (ospp->NodePattern)) {
                        ospp->Flags |= OBSPF_NODEISROOTPLUSSTAR;
                    }
                }
                if (MakePrimaryRootEndWithWack && *root != '\\') {
                    //
                    // see if this is really the primary root
                    //
                    if (p == _mbschr (root, '\\')) {
                        //
                        // include it in the string
                        //
                        p++;
                    }
                }
                ospp->ExactRoot = pExtractStringABA (root, p, g_ObjStrPool);
                ospp->ExactRootBytes = (DWORD)((PBYTE)p - (PBYTE)root);
            }
        }
    } else if (ParsedPatternIsOptionalA (ospp->NodePattern)) {
        ospp->Flags |= OBSPF_OPTIONALNODE;
    }

    if (decodedLeaf) {
        if (*decodedLeaf) {
            ospp->LeafPattern = CreateParsedPatternA (decodedLeaf);
            if (!ospp->LeafPattern) {
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExA: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                DestroyParsedPatternA (ospp->NodePattern);
                pObjStrFreeMemory (ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                pObjStrFreeMemory (ospp);
                return NULL;
            }
            if (ospp->LeafPattern->PatternCount > 1) {
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExA: Bad EncodedObject (multiple patterns specified): %s",
                    EncodedObject
                    ));
                DestroyParsedPatternA (ospp->NodePattern);
                DestroyParsedPatternA (ospp->LeafPattern);
                pObjStrFreeMemory (ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                pObjStrFreeMemory (ospp);
                return NULL;
            }

            if (ParsedPatternIsOptionalA (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_OPTIONALLEAF;
            } else if (ParsedPatternIsExactMatchA (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_EXACTLEAF;
            }

        } else {
            //
            // accept empty string for leaf
            //
            ospp->Flags |= OBSPF_EXACTLEAF;
        }
        ospp->Leaf = DuplicateTextExA (g_ObjStrPool, decodedLeaf, 0, NULL);
    } else {
        ospp->Flags |= OBSPF_NOLEAF;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);
    return ospp;
}


POBSPARSEDPATTERNW
ObsCreateParsedPatternExW (
    IN      PCWSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    )
{
    POBSPARSEDPATTERNW ospp;
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    PCWSTR p;
    PCWSTR root;

    MYASSERT (EncodedObject);

    if (!ObsSplitObjectStringExW (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return NULL;
    }

    ospp = pObjStrAllocateMemory (DWSIZEOF(OBSPARSEDPATTERNW));
    ZeroMemory (ospp, DWSIZEOF(OBSPARSEDPATTERNW));
    ospp->MaxSubLevel = NODE_LEVEL_MAX;

    MYASSERT (decodedNode);
    if (!GetNodePatternMinMaxLevelsW (decodedNode, decodedNode, &ospp->MinNodeLevel, &ospp->MaxNodeLevel)) {
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }

    MYASSERT (ospp->MinNodeLevel > 0 && ospp->MaxNodeLevel >= ospp->MinNodeLevel);
    if (ospp->MaxNodeLevel != NODE_LEVEL_MAX) {
        ospp->MaxSubLevel = ospp->MaxNodeLevel - ospp->MinNodeLevel;
    }

    ospp->NodePattern = CreateParsedPatternW (decodedNode);
    if (!ospp->NodePattern) {
        DEBUGMSGW ((
            DBG_OBJSTR,
            "ObsCreateParsedPatternExW: Bad EncodedObject: %s",
            EncodedObject
            ));
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }
    if (ospp->NodePattern->PatternCount > 1) {
        DEBUGMSGW ((
            DBG_OBJSTR,
            "ObsCreateParsedPatternExW: Bad EncodedObject (multiple patterns specified): %s",
            EncodedObject
            ));
        DestroyParsedPatternW (ospp->NodePattern);
        pObjStrFreeMemory (decodedNode);
        pObjStrFreeMemory (decodedLeaf);
        pObjStrFreeMemory (ospp);
        return NULL;
    }

    root = ParsedPatternGetRootW (ospp->NodePattern);
    if (root) {
        //
        // extract the real root part
        //
        if (ParsedPatternIsExactMatchW (ospp->NodePattern)) {
            ospp->Flags |= OBSPF_EXACTNODE;
            ospp->ExactRoot = DuplicateTextExW (g_ObjStrPool, root, 0, NULL);
            ospp->ExactRootBytes = ByteCountW (root);
            ospp->MaxSubLevel = 0;
        } else {
            p = FindLastWackW (root);
            if (p) {
                //
                // exact root specified
                // if the last wack is actually the last character or is followed by star(s),
                // optimize the matching by setting some flags
                //
                if (*(p + 1) == 0) {
                    if (ParsedPatternIsRootPlusStarW (ospp->NodePattern)) {
                        ospp->Flags |= OBSPF_NODEISROOTPLUSSTAR;
                    }
                }
                if (MakePrimaryRootEndWithWack && *root != L'\\') {
                    //
                    // see if this is really the primary root
                    //
                    if (p == wcschr (root, L'\\')) {
                        //
                        // include it in the string
                        //
                        p++;
                    }
                }
                ospp->ExactRoot = pExtractStringABW (root, p, g_ObjStrPool);
                ospp->ExactRootBytes = (DWORD)((PBYTE)p - (PBYTE)root);
            }
        }
    } else if (ParsedPatternIsOptionalW (ospp->NodePattern)) {
        ospp->Flags |= OBSPF_OPTIONALNODE;
    }

    if (decodedLeaf) {
        if (*decodedLeaf) {
            ospp->LeafPattern = CreateParsedPatternW (decodedLeaf);
            if (!ospp->LeafPattern) {
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExW: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                DestroyParsedPatternW (ospp->NodePattern);
                pObjStrFreeMemory (ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                pObjStrFreeMemory (ospp);
                return NULL;
            }
            if (ospp->LeafPattern->PatternCount > 1) {
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExW: Bad EncodedObject (multiple patterns specified): %s",
                    EncodedObject
                    ));
                DestroyParsedPatternW (ospp->NodePattern);
                DestroyParsedPatternW (ospp->LeafPattern);
                pObjStrFreeMemory (ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                pObjStrFreeMemory (ospp);
                return NULL;
            }

            if (ParsedPatternIsOptionalW (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_OPTIONALLEAF;
            } else if (ParsedPatternIsExactMatchW (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_EXACTLEAF;
            }

        } else {
            //
            // accept empty string for leaf
            //
            ospp->Flags |= OBSPF_EXACTLEAF;
        }
        ospp->Leaf = DuplicateTextExW (g_ObjStrPool, decodedLeaf, 0, NULL);
    } else {
        ospp->Flags |= OBSPF_NOLEAF;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);
    return ospp;
}


/*++

Routine Description:

    ObsDestroyParsedPattern destroys the given structure, freeing resources

Arguments:

    ParsedPattern - Specifies the parsed pattern structure

Return Value:

    none

--*/

VOID
ObsDestroyParsedPatternA (
    IN      POBSPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern) {
        if (ParsedPattern->NodePattern) {
            DestroyParsedPatternA (ParsedPattern->NodePattern);
        }
        if (ParsedPattern->LeafPattern) {
            DestroyParsedPatternA (ParsedPattern->LeafPattern);
        }
        if (ParsedPattern->Leaf) {
            FreeTextExA (g_ObjStrPool, ParsedPattern->Leaf);
        }
        pObjStrFreeMemory (ParsedPattern->ExactRoot);
        pObjStrFreeMemory (ParsedPattern);
    }
}


VOID
ObsDestroyParsedPatternW (
    IN      POBSPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern) {
        if (ParsedPattern->NodePattern) {
            DestroyParsedPatternW (ParsedPattern->NodePattern);
        }
        if (ParsedPattern->LeafPattern) {
            DestroyParsedPatternW (ParsedPattern->LeafPattern);
        }
        if (ParsedPattern->Leaf) {
            FreeTextExW (g_ObjStrPool, ParsedPattern->Leaf);
        }
        pObjStrFreeMemory (ParsedPattern->ExactRoot);
        pObjStrFreeMemory (ParsedPattern);
    }
}


/*++

Routine Description:

    ObsParsedPatternMatch tests the given object against a parsed pattern

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    EncodedObject - Specifies the object string to test against the pattern

Return Value:

    TRUE if the string matches the pattern

--*/

BOOL
ObsParsedPatternMatchA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR EncodedObject
    )
{
    PSTR decodedNode;
    PSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExA (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    b = ObsParsedPatternMatchExA (ParsedPattern, decodedNode, decodedLeaf);

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}

BOOL
ObsParsedPatternMatchW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR EncodedObject
    )
{
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExW (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    b = ObsParsedPatternMatchExW (ParsedPattern, decodedNode, decodedLeaf);

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}


/*++

Routine Description:

    ObsParsedPatternMatchEx tests the given object, given by its components,
    against a parsed pattern

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    Node - Specifies the node part of the object string to test against the pattern
    Leaf - Specifies the leaf part of the object string to test against the pattern

Return Value:

    TRUE if the string components match the pattern

--*/

BOOL
ObsParsedPatternMatchExA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR Node,
    IN      PCSTR Leaf                          OPTIONAL
    )
{
    MYASSERT (Node && ParsedPattern->NodePattern);
    if (!(Node && ParsedPattern->NodePattern)) {
       return FALSE;
    }

    if ((ParsedPattern->Flags & OBSPF_NOLEAF) && Leaf ||
        !(ParsedPattern->Flags & OBSPF_NOLEAF) && !Leaf
        ) {
        return FALSE;
    }

    if (!TestParsedPatternA (ParsedPattern->NodePattern, Node)) {
        return FALSE;
    }

    return !Leaf || TestParsedPatternA (ParsedPattern->LeafPattern, Leaf);
}

BOOL
ObsParsedPatternMatchExW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR Node,                        OPTIONAL
    IN      PCWSTR Leaf                         OPTIONAL
    )
{
    MYASSERT (Node && ParsedPattern->NodePattern);
    if (!(Node && ParsedPattern->NodePattern)) {
       return FALSE;
    }

    if ((ParsedPattern->Flags & OBSPF_NOLEAF) && Leaf ||
        !(ParsedPattern->Flags & OBSPF_NOLEAF) && !Leaf
        ) {
        return FALSE;
    }

    if (!TestParsedPatternW (ParsedPattern->NodePattern, Node)) {
        return FALSE;
    }

    return !Leaf || TestParsedPatternW (ParsedPattern->LeafPattern, Leaf);
}


/*++

Routine Description:

    ObsPatternMatch tests an object string against a pattern object string

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    Node - Specifies the node part of the object string to test against the pattern
    Leaf - Specifies the leaf part of the object string to test against the pattern

Return Value:

    TRUE if the string components match the pattern

--*/

BOOL
ObsPatternMatchA (
    IN      PCSTR ObjectPattern,
    IN      PCSTR ObjectStr
    )
{
    PSTR opNode;
    PSTR opLeaf;
    PSTR osNode;
    PSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExA (ObjectPattern, &opNode, &opLeaf, NULL, FALSE)) {
        if (ObsSplitObjectStringExA (ObjectStr, &osNode, &osLeaf, NULL, TRUE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternMatchExABA (opNode, osNode, GetEndOfStringA (osNode));
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternMatchExABA (opLeaf, osLeaf, GetEndOfStringA (osLeaf));
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsPatternMatchA: bad ObjectStr: %s", ObjectStr));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsPatternMatchA: bad ObjectPattern: %s", ObjectPattern));

    return b;
}

BOOL
ObsPatternMatchW (
    IN      PCWSTR ObjectPattern,
    IN      PCWSTR ObjectStr
    )
{
    PWSTR opNode;
    PWSTR opLeaf;
    PWSTR osNode;
    PWSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExW (ObjectPattern, &opNode, &opLeaf, NULL, FALSE)) {
        if (ObsSplitObjectStringExW (ObjectStr, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternMatchExABW (opNode, osNode, GetEndOfStringW (osNode));
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternMatchExABW (opLeaf, osLeaf, GetEndOfStringW (osLeaf));
                    } else {
                        b = FALSE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsPatternMatchW: bad ObjectStr: %s", ObjectStr));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsPatternMatchW: bad ObjectPattern: %s", ObjectPattern));

    return b;
}

/*++

Routine Description:

    ObsIsPatternContained compares two patterns to see if one of them is
    included in the other. Both patterns may contain any of the following
    expressions:

Arguments:

    Container - Specifies the container pattern
    Contained - Specifies the contained pattern

Return Value:

    TRUE if Contained is contained in Container

--*/

BOOL
ObsIsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    PSTR opNode;
    PSTR opLeaf;
    PSTR osNode;
    PSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExA (Container, &opNode, &opLeaf, NULL, FALSE)) {

        if (ObsSplitObjectStringExA (Contained, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternContainedExA (opNode, osNode);
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternContainedExA (opLeaf, osLeaf);
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsIsPatternContainedA: bad Contained string: %s", Contained));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsIsPatternContainedA: bad Container string: %s", Container));

    return b;
}

BOOL
ObsIsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    PWSTR opNode;
    PWSTR opLeaf;
    PWSTR osNode;
    PWSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExW (Container, &opNode, &opLeaf, NULL, FALSE)) {

        if (ObsSplitObjectStringExW (Contained, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternContainedExW (opNode, osNode);
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternContainedExW (opLeaf, osLeaf);
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsIsPatternContainedW: bad Contained string: %s", Contained));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsIsPatternContainedW: bad Container string: %s", Container));

    return b;
}


/*++

Routine Description:

    ObsGetPatternLevels gets the minimum and maximum levels of a string that would
    match the given pattern.

Arguments:

    ObjectPattern - Specifies the pattern
    MinLevel - Receives the minimum possible level; the root has level 1
    MaxLevel - Receives the maximum possible level; the root has level 1

Return Value:

    TRUE if the pattern was correct and computing was done; FALSE otherwise

--*/

BOOL
ObsGetPatternLevelsA (
    IN      PCSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    )
{
    PSTR decodedNode;
    PSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExA (ObjectPattern, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    if (decodedNode) {
        b = GetNodePatternMinMaxLevelsA (decodedNode, decodedNode, MinLevel, MaxLevel);
    } else {
        b = FALSE;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}

BOOL
ObsGetPatternLevelsW (
    IN      PCWSTR ObjectPattern,
    OUT     PDWORD MinLevel,
    OUT     PDWORD MaxLevel
    )
{
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExW (ObjectPattern, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    if (decodedNode) {
        b = GetNodePatternMinMaxLevelsW (decodedNode, decodedNode, MinLevel, MaxLevel);
    } else {
        b = FALSE;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}


/*++

Routine Description:

    ObsPatternIncludesPattern decides if a given pattern includes another pattern,
    meaning that any string that would match the second will match the first.

Arguments:

    IncludingPattern - Specifies the first parsed pattern
    IncludedPattern - Specifies the second parsed pattern

Return Value:

    TRUE if the first pattern includes the second

--*/

BOOL
ObsPatternIncludesPatternA (
    IN      POBSPARSEDPATTERNA IncludingPattern,
    IN      POBSPARSEDPATTERNA IncludedPattern
    )
{
    MYASSERT (IncludingPattern->NodePattern && IncludedPattern->NodePattern);
    if (!(IncludingPattern->NodePattern && IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->MinNodeLevel > IncludedPattern->MinNodeLevel ||
        IncludingPattern->MaxNodeLevel < IncludedPattern->MaxNodeLevel
        ) {
        return FALSE;
    }

    if (!PatternIncludesPatternA (IncludingPattern->NodePattern, IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->LeafPattern) {
        if (!IncludedPattern->LeafPattern) {
            return FALSE;
        }
        if (!PatternIncludesPatternA (IncludingPattern->LeafPattern, IncludedPattern->LeafPattern)) {
            return FALSE;
        }
    } else {
        if (IncludedPattern->LeafPattern) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
ObsPatternIncludesPatternW (
    IN      POBSPARSEDPATTERNW IncludingPattern,
    IN      POBSPARSEDPATTERNW IncludedPattern
    )
{
    MYASSERT (IncludingPattern->NodePattern && IncludedPattern->NodePattern);
    if (!(IncludingPattern->NodePattern && IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->MinNodeLevel > IncludedPattern->MinNodeLevel ||
        IncludingPattern->MaxNodeLevel < IncludedPattern->MaxNodeLevel
        ) {
        return FALSE;
    }

    if (!PatternIncludesPatternW (IncludingPattern->NodePattern, IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->LeafPattern) {
        if (!IncludedPattern->LeafPattern) {
            return FALSE;
        }
        if (!PatternIncludesPatternW (IncludingPattern->LeafPattern, IncludedPattern->LeafPattern)) {
            return FALSE;
        }
    } else {
        if (IncludedPattern->LeafPattern) {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\main.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main source file of migutil.dll

Author:

    Jim Schmidt (jimschm)   01-Aug-1996

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     23-Sep-1998 Start thread
    marcw       23-Sep-1998 Locale fix
    jimschm     03-Nov-1997 Added TextAlloc routines
    marcw       22-Jul-1997 Added IS<platform> functions.

--*/


#include "pch.h"
#include "utilsp.h"
#include "locale.h"

//#define DEBUG_ALL_FILES

HINSTANCE g_hInst;
HANDLE g_hHeap;

OSVERSIONINFOA g_OsInfo;
OUR_CRITICAL_SECTION g_MemDbCs;

#define TEXT_GROWTH_SIZE    65536


//
// OS-dependent flags for MultiByteToWideChar
//

DWORD g_MigutilWCToMBFlags = 0;


//
// g_ShortTermAllocTable is the default table used for resource string
// management.  New strings are allocated from the table.
//
// Allocation tables are very simple ways to store strings loaded in from
// the exe image.  The loaded string is copied into the table and kept
// around until it is explicitly freed.  Multiple attempts at getting the
// same resource string return the same string, inc'ing a use counter.
//
// g_OutOfMemoryTable is the table used to hold out-of-memory text.  It
// is loaded up at init time and is kept in memory for the whole time
// migutil is in use, so out-of-memory messages can always be displayed.
//

PGROWBUFFER g_ShortTermAllocTable;
PGROWBUFFER g_OutOfMemoryTable;

//
// We make sure the message APIs (GetStringResource, ParseMessageID, etc)
// are thread-safe
//

OUR_CRITICAL_SECTION g_MessageCs;

//
// The PoolMem routines must also be thread-safe
//

OUR_CRITICAL_SECTION g_PmCs;

//
// MemAlloc critical section
//

OUR_CRITICAL_SECTION g_MemAllocCs;

//
// The following pools are used for text management.  g_RegistryApiPool is
// for reg.c, g_PathsPool is for the JoinPaths/DuplicatePath/etc routines,
// and g_TextPool is for AllocText, DupText, etc.
//
PMHANDLE g_RegistryApiPool;
PMHANDLE g_PathsPool;
PMHANDLE g_TextPool;

VOID
UtInitialize (
    IN      HANDLE Heap             OPTIONAL
    )
{
    //
    // Set globals
    //

    if (Heap) {
        g_hHeap = Heap;
    } else {
        g_hHeap = GetProcessHeap();
    }

    g_hInst = GetModuleHandle (NULL);

    //
    // Load in OSVERSION info.
    //
    g_OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA (&g_OsInfo);

    //
    // Initialize log
    //

    Init_Log (NULL);

    //
    // Create critical sections
    //

    InitializeOurCriticalSection (&g_MemAllocCs);
    InitializeOurCriticalSection (&g_MemDbCs);
    InitializeOurCriticalSection (&g_PmCs);
    InitializeOurCriticalSection (&g_MessageCs);

    //
    // Now that MemAlloc will work, initialize allocation tracking
    //

    InitAllocationTracking();

    //
    // Create the short-term alloc table for string resource utils
    //

    g_ShortTermAllocTable = CreateAllocTable();

    //
    // MultiByteToWideChar has desirable flags that only function on NT
    //
    g_MigutilWCToMBFlags = (ISNT()) ? WC_NO_BEST_FIT_CHARS : 0;

#ifdef _lint

    g_MigutilWCToMBFlags = g_MigutilWCToMBFlags;

#endif


    //
    // Create pools used by utils.lib code
    //

    g_RegistryApiPool = PmCreateNamedPool ("Registry API");
    g_PathsPool = PmCreateNamedPool ("Paths");
    g_TextPool = PmCreateNamedPool ("Text");

    PmSetMinimumGrowthSize (g_TextPool, TEXT_GROWTH_SIZE);

    ObsInitialize ();
    ElInitialize ();

    //
    // The "out of memory" message
    //

    g_OutOfMemoryTable = CreateAllocTable();

    g_OutOfMemoryRetry  = GetStringResourceExA (
                                g_OutOfMemoryTable,
                                10001 /* MSG_OUT_OF_MEMORY_RETRY */
                                );

    g_OutOfMemoryString = GetStringResourceExA (
                                g_OutOfMemoryTable,
                                10002 /* MSG_OUT_OF_MEMORY */
                                );

    if (!g_OutOfMemoryString || !g_OutOfMemoryRetry) {
        DEBUGMSG ((
            DBG_WARNING,
            "Cannot load out of memory messages; resources 10001 and 10002 do not exist"
            ));
    }

    //
    // set the locale to the system locale. Not doing this can cause isspace
    // to AV in certain MBSCHR circumstances.
    //
    setlocale(LC_ALL,"");
}


VOID
UtTerminate (
    VOID
    )
{
    //
    // Free utility pools
    //

    ElTerminate ();
    ObsTerminate ();

    if (g_RegistryApiPool) {
        PmDestroyPool (g_RegistryApiPool);
    }

    if (g_PathsPool) {
        PmDestroyPool (g_PathsPool);
    }

    if (g_TextPool) {
        PmDestroyPool (g_TextPool);
    }

    if (g_ShortTermAllocTable) {
        DestroyAllocTable (g_ShortTermAllocTable);
    }

    if (g_OutOfMemoryTable) {
        DestroyAllocTable (g_OutOfMemoryTable);
    }

    FreeAllocationTracking();

    //
    // Clean up handles used by critical sections
    //

    DeleteOurCriticalSection (&g_MemAllocCs);
    DeleteOurCriticalSection (&g_MemDbCs);
    DeleteOurCriticalSection (&g_PmCs);
    DeleteOurCriticalSection (&g_MessageCs);

    //
    // MUST BE VERY LAST CODE TO RUN
    //

    DumpHeapStats();
    Exit_Log ();
}



#define WIDTH(rect) (rect.right - rect.left)
#define HEIGHT(rect) (rect.bottom - rect.top)

void
CenterWindow (
    IN  HWND hwnd,
    IN  HWND Parent
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    MYASSERT (IsWindow (hwnd));

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


static INT g_MigUtilWaitCounter = 0;
static HCURSOR g_MigUtilWaitCursor = NULL;

VOID
TurnOnWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOnWaitCursor sets the cursor to IDC_WAIT.  It maintains a use
  counter, so code requring the wait cursor can be nested.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_MigUtilWaitCounter == 0) {
        g_MigUtilWaitCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
    }

    g_MigUtilWaitCounter++;
}


VOID
TurnOffWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOffWaitCursor decrements the wait cursor counter, and if it
  reaches zero the cursor is restored.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_MigUtilWaitCounter) {
        DEBUGMSG ((DBG_WHOOPS, "TurnOffWaitCursor called too many times"));
    } else {
        g_MigUtilWaitCounter--;

        if (!g_MigUtilWaitCounter) {
            SetCursor (g_MigUtilWaitCursor);
        }
    }
}


/*++

Routine Description:

  Win9x does not support TryEnterOurCriticalSection, so we must implement
  our own version because it is quite a useful function.

Arguments:

  pcs - A pointer to an OUR_CRITICAL_SECTION object

Return Value:

  TRUE if the function succeeded, or FALSE if it failed.  See Win32
  SDK docs on critical sections, as these routines are identical to
  the caller.

--*/

BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    // Create initially signaled, auto-reset event
    pcs->EventHandle = CreateEvent (NULL, FALSE, TRUE, NULL);
    if (!pcs->EventHandle) {
        return FALSE;
    }

    return TRUE;
}


VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    if (pcs->EventHandle) {
        CloseHandle (pcs->EventHandle);
        pcs->EventHandle = NULL;
    }

}


BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    // Wait for event to become signaled, then turn it off
    rc = WaitForSingleObject (pcs->EventHandle, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    SetEvent (pcs->EventHandle);
}

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    rc = WaitForSingleObject (pcs->EventHandle, 0);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}




HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    )
{
    DWORD DontCare;

    return CreateThread (NULL, 0, Address, Arg, 0, &DontCare);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\version.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    version.c

Abstract:

    Implements a set of enumeration routines to access version
    information from a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    calinn      03-Sep-1999 Moved over from Win9xUpg project.

--*/

//
// Includes
//

#include "pch.h"

//
// Debug constants
//

#define DBG_VERSION     "VerAPI"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PCSTR g_DefaultTranslationsA[] = {
    "04090000",
    "040904E4",
    "040904B0",
    NULL
};

PCWSTR g_DefaultTranslationsW[] = {
    L"04090000",
    L"040904E4",
    L"040904B0",
    NULL
};

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

PCSTR
pVrEnumValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
pVrEnumValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

PCSTR
pVrEnumNextTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
pVrEnumNextTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

//
// Macro expansion definition
//

// None

//
// Code
//


/*++

Routine Description:

  VrCreateEnumStructA and VrCreateEnumStructW are called to load a version
  structure from a file and to obtain the fixed version stamp info that is
  language-independent.

  The caller must call VrDestroyEnumStruct after the VrValueEnum is no
  longer needed.

Arguments:

  VrValueEnum - Receives the version stamp info to be used by other
                functions in this module

  FileSpec    - Specifies the file to obtain version information from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

BOOL
VrCreateEnumStructA (
    OUT     PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR FileSpec
    )
{
    //
    // Initialize the structure
    //

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMA));
    VrValueEnum->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VrValueEnum->Size = GetFileVersionInfoSizeA (
                                (PSTR) FileSpec,
                                &VrValueEnum->Handle
                                );

    if (!VrValueEnum->Size) {
        DEBUGMSG ((DBG_VERSION, "File %s does not have version information", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VrValueEnum->VersionBuffer = GbGrow (&VrValueEnum->GrowBuf, VrValueEnum->Size * 2);

    if (!VrValueEnum->VersionBuffer) {
        return FALSE;
    }

    VrValueEnum->StringBuffer = VrValueEnum->GrowBuf.Buf + VrValueEnum->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoA (
             (PSTR) FileSpec,
             VrValueEnum->Handle,
             VrValueEnum->Size,
             VrValueEnum->VersionBuffer
             )) {
        VrDestroyEnumStructA (VrValueEnum);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueA (
        VrValueEnum->VersionBuffer,
        "\\",
        &VrValueEnum->FixedInfo,
        &VrValueEnum->FixedInfoSize
        );

    return TRUE;
}

BOOL
VrCreateEnumStructW (
    OUT     PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR FileSpec
    )
{
    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMW));
    VrValueEnum->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VrValueEnum->Size = GetFileVersionInfoSizeW (
                                (PWSTR) FileSpec,
                                &VrValueEnum->Handle
                                );

    if (!VrValueEnum->Size) {
        DEBUGMSG ((DBG_VERSION, "File %S does not have version info", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VrValueEnum->VersionBuffer = GbGrow (&VrValueEnum->GrowBuf, VrValueEnum->Size * 2);

    if (!VrValueEnum->VersionBuffer) {
        return FALSE;
    }

    VrValueEnum->StringBuffer = VrValueEnum->GrowBuf.Buf + VrValueEnum->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoW (
             (PWSTR) FileSpec,
             VrValueEnum->Handle,
             VrValueEnum->Size,
             VrValueEnum->VersionBuffer
             )) {
        VrDestroyEnumStructW (VrValueEnum);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueW (
        VrValueEnum->VersionBuffer,
        L"\\",
        &VrValueEnum->FixedInfo,
        &VrValueEnum->FixedInfoSize
        );

    return TRUE;
}


/*++

Routine Description:

  VrDestroyEnumStructA and VrDestroyEnumStructW cleans up all memory
  allocated by the routines in this module.

Arguments:

  VrValueEnum - Specifies the structure to clean up

Return Value:

  none

--*/

VOID
VrDestroyEnumStructA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )
{
    //
    // Clean up all allocations made by any routine using
    // the VrValueEnum
    //

    if (VrValueEnum->GrowBuf.Buf) {
        GbFree (&VrValueEnum->GrowBuf);
    }

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMA));
}

VOID
VrDestroyEnumStructW (
    IN      PVRVALUE_ENUMW VrValueEnum
    )
{
    //
    // Clean up all allocations made by any routine using
    // the VrValueEnum
    //

    if (VrValueEnum->GrowBuf.Buf) {
        GbFree (&VrValueEnum->GrowBuf);
    }

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMW));
}


/*++

Routine Description:

  pVrEnumFirstTranslationA and pVrEnumFirstTranslationW return the translation
  string needed to access the string table of a version stamp.

Arguments:

  VrValueEnum - Specifies the structure that has been initialized
                by VrCreateEnumStruct.

Return Value:

  A pointer to a string specifying the first translation, or
  NULL if no translations exist.

--*/

PCSTR
pVrEnumFirstTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    UINT arraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueA (
            VrValueEnum->VersionBuffer,
            "\\VarFileInfo\\Translation",
            &VrValueEnum->Translations,
            &arraySize
            )) {
        //
        // No translations are available
        //

        arraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VrValueEnum->CurrentDefaultTranslation = 0;
    VrValueEnum->MaxTranslations = arraySize / sizeof (TRANSLATION);
    VrValueEnum->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VrValueEnum->MaxTranslations == 0,
        DBG_VERSION,
        "File %s has no translations",
        VrValueEnum->FileSpec
        ));

    return pVrEnumNextTranslationA (VrValueEnum);
}

PCWSTR
pVrEnumFirstTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    UINT arraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueW (
            VrValueEnum->VersionBuffer,
            L"\\VarFileInfo\\Translation",
            &VrValueEnum->Translations,
            &arraySize
            )) {
        //
        // No translations are available
        //

        arraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VrValueEnum->CurrentDefaultTranslation = 0;
    VrValueEnum->MaxTranslations = arraySize / sizeof (TRANSLATION);
    VrValueEnum->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VrValueEnum->MaxTranslations == 0,
        DBG_VERSION,
        "File %S has no translations",
        VrValueEnum->FileSpec
        ));

    return pVrEnumNextTranslationW (VrValueEnum);
}


/*++

Routine Description:

  pIsDefaultTranslationA and pIsDefaultTranslationW return TRUE
  if the specified translation string is enumerated by default.
  These routines stops multiple enumeration of the same
  translation string.

Arguments:

  TranslationStr - Specifies the translation string to test

Return Value:

  TRUE if the translation string is the same as a default translation
  string, or FALSE if it is not.

--*/

BOOL
pIsDefaultTranslationA (
    IN      PCSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsA[i] ; i++) {
        if (StringIMatchA (TranslationStr, g_DefaultTranslationsA[i])) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
pIsDefaultTranslationW (
    IN      PCWSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsW[i] ; i++) {
        if (StringIMatchW (TranslationStr, g_DefaultTranslationsW[i])) {
            return TRUE;
        }
    }
    return FALSE;
}


/*++

Routine Description:

  pVrEnumNextTranslationA and pVrEnumNextTranslationW continue
  the enumeration of translation strings, needed to access the
  string table in a version stamp.

Arguments:

  VrValueEnum - Specifies the same structure passed to
                pVrEnumFirstTranslation.

Return Value:

  A pointer to a string specifying the next translation, or
  NULL if no additional translations exist.

--*/

PCSTR
pVrEnumNextTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PTRANSLATION translation;

    if (g_DefaultTranslationsA[VrValueEnum->CurrentDefaultTranslation]) {
        //
        // Return default translations first
        //

        StringCopyA (
            VrValueEnum->TranslationStr,
            g_DefaultTranslationsA[VrValueEnum->CurrentDefaultTranslation]
            );

        VrValueEnum->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VrValueEnum->CurrentTranslation == VrValueEnum->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            translation = &VrValueEnum->Translations[VrValueEnum->CurrentTranslation];

            wsprintfA (
                VrValueEnum->TranslationStr,
                "%04x%04x",
                translation->CodePage,
                translation->Language
                );

            VrValueEnum->CurrentTranslation++;

        } while (pIsDefaultTranslationA (VrValueEnum->TranslationStr));
    }

    return VrValueEnum->TranslationStr;
}

PCWSTR
pVrEnumNextTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PTRANSLATION translation;

    if (g_DefaultTranslationsW[VrValueEnum->CurrentDefaultTranslation]) {

        StringCopyW (
            VrValueEnum->TranslationStr,
            g_DefaultTranslationsW[VrValueEnum->CurrentDefaultTranslation]
            );

        VrValueEnum->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VrValueEnum->CurrentTranslation == VrValueEnum->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            translation = &VrValueEnum->Translations[VrValueEnum->CurrentTranslation];

            wsprintfW (
                VrValueEnum->TranslationStr,
                L"%04x%04x",
                translation->CodePage,
                translation->Language
                );

            VrValueEnum->CurrentTranslation++;

        } while (pIsDefaultTranslationW (VrValueEnum->TranslationStr));
    }

    return VrValueEnum->TranslationStr;
}


/*++

Routine Description:

  VrEnumFirstValueA and VrEnumFirstValueW return the first value
  stored in a version stamp for a specific field. If the field
  does not exist, the functions returns NULL.

  An enumeration of VrEnumFirstValue/VrEnumNextValue
  is used to list all localized strings for a field.

Arguments:

  VrValueEnum  - Specifies the structure that was initialized by
                 VrCreateEnumStruct.

  VersionField - Specifies the name of the version field to enumerate

Return Value:

  A pointer to the first value of the field, or NULL if the field does
  not exist.

--*/

PCSTR
VrEnumFirstValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionField
    )
{
    PCSTR result = NULL;

    if (!pVrEnumFirstTranslationA (VrValueEnum)) {
        return NULL;
    }

    VrValueEnum->VersionField = VersionField;

    result = pVrEnumValueA (VrValueEnum);

    if (!result) {
        result = VrEnumNextValueA (VrValueEnum);
    }

    return result;
}

PCWSTR
VrEnumFirstValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionField
    )
{
    PCWSTR result = NULL;

    if (!pVrEnumFirstTranslationW (VrValueEnum)) {
        return NULL;
    }

    VrValueEnum->VersionField = VersionField;

    result = pVrEnumValueW (VrValueEnum);

    if (!result) {
        result = VrEnumNextValueW (VrValueEnum);
    }

    return result;
}


/*++

Routine Description:

  VrEnumNextValueA and VrEnumNextValueW return the next value
  stored in a version stamp for a specific field.

Arguments:

  VrValueEnum - Specifies the same structure passed to VrEnumFirstValue

Return Value:

  A pointer to the next value of the field, or NULL if another field
  does not exist.

--*/

PCSTR
VrEnumNextValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PCSTR result = NULL;

    do {
        if (!pVrEnumNextTranslationA (VrValueEnum)) {
            break;
        }

        result = pVrEnumValueA (VrValueEnum);

    } while (!result);

    return result;
}

PCWSTR
VrEnumNextValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PCWSTR result = NULL;

    do {
        if (!pVrEnumNextTranslationW (VrValueEnum)) {
            break;
        }

        result = pVrEnumValueW (VrValueEnum);

    } while (!result);

    return result;
}


/*++

Routine Description:

  pVrEnumValueA and pVrEnumValueW are routines that obtain
  the value of a version field. They are used for both
  VrEnumFirstValue and VrEnumNextValue.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A pointer to the version value for the current translation, or
  NULL if the value does not exist for the current translation.

--*/

PCSTR
pVrEnumValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PSTR text;
    UINT stringLen;
    PBYTE string;
    PCSTR result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    text = RealAllocTextExA (NULL, 0);

    text = AllocTextA (
               SizeOfStringA (VrValueEnum->TranslationStr) +
               SizeOfStringA (VrValueEnum->VersionField) +
               16
               );

    if (!text) {
        return NULL;
    }

    wsprintfA (
        text,
        "\\StringFileInfo\\%s\\%s",
        VrValueEnum->TranslationStr,
        VrValueEnum->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueA (
                VrValueEnum->VersionBuffer,
                text,
                &string,
                &stringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        StringCopyByteCountA (VrValueEnum->StringBuffer, (PCSTR) string, stringLen);

        result = (PCSTR)VrValueEnum->StringBuffer;

    }
    __finally {
        FreeTextA (text);
    }

    return result;
}

PCWSTR
pVrEnumValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PWSTR text;
    UINT stringLen;
    PBYTE string;
    PCWSTR result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    text = AllocTextW (
               18 +
               CharCountW (VrValueEnum->TranslationStr) +
               CharCountW (VrValueEnum->VersionField)
               );

    if (!text) {
        return NULL;
    }

    wsprintfW (
        text,
        L"\\StringFileInfo\\%s\\%s",
        VrValueEnum->TranslationStr,
        VrValueEnum->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueW (
                VrValueEnum->VersionBuffer,
                text,
                &string,
                &stringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        CopyMemory (VrValueEnum->StringBuffer, string, stringLen * sizeof (WCHAR));
        VrValueEnum->StringBuffer [stringLen * sizeof (WCHAR)] = 0;
        result = (PWSTR) VrValueEnum->StringBuffer;

    }
    __finally {
        FreeTextW (text);
    }

    return result;
}


ULONGLONG
VrGetBinaryFileVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileVersion returns the FileVersion field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A ULONGLONG FileVersion field

--*/

{
    ULONGLONG result = 0;

    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VrValueEnum->FixedInfo->dwFileVersionLS;
        *(((PDWORD) (&result)) + 1) = VrValueEnum->FixedInfo->dwFileVersionMS;
    }
    return result;
}


ULONGLONG
VrGetBinaryProductVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryProductVersion returns the ProductVersion field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A ULONGLONG ProductVersion field

--*/

{
    ULONGLONG result = 0;

    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VrValueEnum->FixedInfo->dwProductVersionLS;
        *(((PDWORD) (&result)) + 1) = VrValueEnum->FixedInfo->dwProductVersionMS;
    }
    return result;
}


DWORD
VrGetBinaryFileDateLoA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileDateLo returns the LS dword from FileDate field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD, LS dword of the FileDate field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileDateLS;
    }
    return 0;
}


DWORD
VrGetBinaryFileDateHiA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileDateHi returns the MS dword from FileDate field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD, MS dword of the FileDate field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileDateMS;
    }
    return 0;
}


DWORD
VrGetBinaryOsVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryOsVersion returns the FileOS field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD FileOS field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileOS;
    }
    return 0;
}


DWORD
VrGetBinaryFileType (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileType returns the FileType field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD FileType field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileType;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\main\poolmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    poolmem.c

Abstract:

    poolmem provides a managed allocation scheme in which large blocks of memory are
    allocated (pools) and then divided up by request into low overhead memory chunks
    upon request. poolmem provides for easy creation/clean-up of memory, freeing the
    developer for more important tasks.

Author:

    Marc R. Whitten (marcw) 13-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     28-Sep-1998 Debug message fixes

--*/

#include "pch.h"

#ifdef UNICODE
#error UNICODE not allowed
#endif


//
// Includes
//

#include "utilsp.h"

#define DBG_POOLMEM "Poolmem"

//
// Strings
//

// None

//
// Constants
//

//
// Tree Memory Allocation structure.
//

#ifdef DEBUG
#define VALIDDOGTAG 0x021371
#define FREEDOGTAG  0x031073
#endif


#define MAX_POOL_NAME       32

//
// Macros
//

// None

//
// Types
//

typedef struct _PMBLOCK PMBLOCK, *PPMBLOCK;

struct _PMBLOCK {
    UINT_PTR Index;         // Tracks into RawMemory.
    SIZE_T Size;            // the size in bytes of RawMemory.
    PPMBLOCK NextBlock;     // A pointer to the next block in the pool chain.
    PPMBLOCK PrevBlock;     // A pointer to the prev block in the pool chain.
    DWORD UseCount;         // The number of allocations currently referring
                            // to this block.
    PBYTE RawMemory;        // The actual bytes of allocable memory in this block.
};
typedef struct _ALLOCATION ALLOCATION, * PALLOCATION;
struct _ALLOCATION {
#ifdef DEBUG
    DWORD DogTag;           // A signature to ensure validity.
    PALLOCATION Next;       // The next allocation in the list.
    PALLOCATION Prev;       // The previous allocation in the list.
#endif

    PPMBLOCK ParentBlock;   // A reference to the block from which this allocation
                            // was created.

};

typedef enum {
    FREE_NOT_CALLED,
    FREE_CALLED,
    WHO_CARES
} FREESTATE;


typedef struct _POOLHEADER {
    PPMBLOCK PoolHead;                  // The active memory block in this pool.
    SIZE_T MinimumBlockSize;            // minimum size to allocate when a new block is needed.

#ifdef DEBUG
    CHAR Name[MAX_POOL_NAME];
    SIZE_T TotalAllocationRequestBytes;
    SIZE_T MaxAllocationSize;
    SIZE_T CurrentlyAllocatedMemory;
    SIZE_T MaximumAllocatedMemory;
    UINT NumAllocationRequests;
    UINT NumFreeRequests;
    UINT NumBlockFrees;
    UINT NumBlockClears;
    UINT NumBlockAllocations;

    PALLOCATION AllocationList;         // A linked list of all of the allocations active in the
                                        // pool.
    FREESTATE FreeCalled;               // A state variable indicating that PoolMemReleaseMemory()
                                        // has been called at least once on this pool.
#endif

} POOLHEADER, *PPOOLHEADER;

//
// Globals
//

#ifdef DEBUG
DWORD g_PmDisplayed;
DWORD g_PmNotDisplayed;
#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



BOOL
pPmAddMemory (
    IN  PMHANDLE Handle,
    IN  SIZE_T Size
    )
/*++

Routine Description:

    pPmAddMemory is the function responsible for actually growing the size of
    the pool by adding a new block of memory. This function is used by
    PmCreatePool and PmGetMemory.

    when called, this function attempts to allocate at least poolHeader ->
    MinimumBlockSize bytes of memory. If the requested size is actually larger
    than the minimum, the requested size is allocated instead. This is consistent
    with PoolMem's main purpose: An efficient allocator for larger numbers of small
    objects. If PoolMem is being used to allocate very large objects, the benefits
    are lost and poolmem becomes a very inefficient allocator.

Arguments:

    Handle - A Handle to a Pool of Memory.

    Size - Size to allocate.


Return Value:

    returns TRUE if memory was successfully added, FALSE otherwise.

--*/
{
    PBYTE allocedMemory;
    PPMBLOCK newBlock;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;
    SIZE_T sizeNeeded;

    MYASSERT(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(PMBLOCK) > poolHeader->MinimumBlockSize) {
        sizeNeeded = Size + sizeof(PMBLOCK);
    }
    else {
        sizeNeeded = poolHeader->MinimumBlockSize;
    }
    MYASSERT (g_TrackFile);
    allocedMemory = MemAlloc(g_hHeap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock = (PPMBLOCK) allocedMemory;
        newBlock->Size = sizeNeeded - sizeof(PMBLOCK);
        newBlock->RawMemory = allocedMemory + sizeof(PMBLOCK);
        newBlock->Index = 0;
        newBlock->UseCount = 0;

        //
        // Link the block into the list.
        //
        if (poolHeader->PoolHead) {
            poolHeader->PoolHead->PrevBlock = newBlock;
        }
        newBlock->NextBlock = poolHeader->PoolHead;
        newBlock->PrevBlock = NULL;
        poolHeader->PoolHead = newBlock;

#ifdef DEBUG

        //
        // Keep track of pool statistics.
        //
        poolHeader->CurrentlyAllocatedMemory  += sizeNeeded;
        poolHeader->MaximumAllocatedMemory =
            max(poolHeader->MaximumAllocatedMemory,poolHeader->CurrentlyAllocatedMemory);

        poolHeader->NumBlockAllocations++;

#endif

    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;

}


PMHANDLE
RealPmCreatePool (
    VOID
    )
/*++

Routine Description:

    Initializes a new memory pool and returns a handle to it.

Arguments:

    None.

Return Value:

    If the function completes succssessfully, it returns a valid PMHANDLE, otherwise,
    it returns NULL.

--*/

{
    BOOL ableToAddMemory;
    PPOOLHEADER header = NULL;

    EnterOurCriticalSection (&g_PmCs);

    __try {

        //
        // Allocate the header of this pool.
        //
        header = MemAlloc(g_hHeap,0,sizeof(POOLHEADER));

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header->MinimumBlockSize = POOLMEMORYBLOCKSIZE;
        header->PoolHead = NULL;

#ifdef DEBUG

        //
        // Statistics for the debug version.
        //
        header->TotalAllocationRequestBytes = 0;
        header->MaxAllocationSize = 0;
        header->CurrentlyAllocatedMemory = 0;
        header->MaximumAllocatedMemory = 0;
        header->NumAllocationRequests = 0;
        header->NumFreeRequests = 0;
        header->NumBlockFrees = 0;
        header->NumBlockClears = 0;
        header->NumBlockAllocations = 0;
        header->Name[0] = 0;


#endif
        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = pPmAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            MemFree(g_hHeap,0,header);
            header = NULL;
            DEBUGMSG((DBG_ERROR,"PoolMem: Unable to initialize memory pool."));
        }

#ifdef DEBUG

        //
        // These are 'cookie' variables that hold tracking information when dogtag checking
        // is enabled.
        //
        g_PmNotDisplayed =  12;
        g_PmDisplayed =     24;

        if (ableToAddMemory) {
            header->AllocationList = NULL;  //lint !e613
            header->FreeCalled = FREE_NOT_CALLED;   //lint !e613
        }
#endif

    } __finally {

        LeaveOurCriticalSection (&g_PmCs);
    }

    return (PMHANDLE) header;

}

VOID
pDeregisterPoolAllocations (
    PPOOLHEADER PoolHeader
    )
{

#ifdef DEBUG
    PALLOCATION p,cur;

    if (PoolHeader->FreeCalled == WHO_CARES) {
        return;
    }

    p = PoolHeader->AllocationList;

    while (p) {

        cur = p;
        p = p->Next;

        DebugUnregisterAllocation(POOLMEM_POINTER,cur);

    }

    PoolHeader->AllocationList = NULL;
#endif
}


VOID
PmEmptyPool (
    IN PMHANDLE Handle
    )

/*++

Routine Description:

    PmEmptyPool resets the index pointer of the index block back
    to zero, so the next allocation will come from the already allocated
    active block.

    Calling this function invalidates all pointers previously allocated from
    the active block.

Arguments:

    Handle - Specifies the pool to reset

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);

    EnterOurCriticalSection (&g_PmCs);

    __try {

        poolHeader->PoolHead->UseCount = 0;
        poolHeader->PoolHead->Index = 0;

#ifdef DEBUG
        poolHeader->NumBlockClears++;
#endif

#ifdef DEBUG

        pDeregisterPoolAllocations(poolHeader);

#endif


    } __finally {

        LeaveOurCriticalSection (&g_PmCs);
    }

}



VOID
PmSetMinimumGrowthSize (
    IN PMHANDLE Handle,
    IN SIZE_T Size
    )
/*++

Routine Description:

    Sets the minimum growth size for a memory pool. This value is used when new blocks
    are actually added to the pool. The PoolMem allocator will attempt to allocate at
    least this minimum size.

Arguments:

    Handle - A valid PMHANDLE.
    Size   - The minimum size in bytes to grow the pool by on each allocation.

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(Handle != NULL);

    poolHeader->MinimumBlockSize = max(Size,0);
}


VOID
PmDestroyPool (
    PMHANDLE Handle
    )
/*++

Routine Description:

    PmDestroyPool completely cleans up the memory pool identified by Handle. It
    simply walks the list of memory blocks associated with the memory pool, freeing each of them.

Arguments:

    Handle - A valid PMHANDLE.

Return Value:

    None.

--*/
{
    PPMBLOCK nextBlock;
    PPMBLOCK blockToFree;
    PPOOLHEADER poolHeader;


    MYASSERT(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

#ifdef DEBUG

    if (poolHeader->NumAllocationRequests) {
        CHAR FloatWorkaround[32];

        _gcvt (
            ((DOUBLE) (poolHeader->TotalAllocationRequestBytes)) / poolHeader->NumAllocationRequests,
            8,
            FloatWorkaround
            );

        //
        // Spew the statistics of this pool to the debug log.
        //
        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool Statistics for %s\n"
                "\n"
                "Requested Size in Bytes\n"
                "  Average: %s\n"
                "  Maximum: %u\n"
                "\n"
                "Pool Size in Bytes\n"
                "  Current: %u\n"
                "  Maximum: %u\n"
                "\n"
                "Allocation Requests\n"
                "  Caller Requests: %u\n"
                "  Block Allocations: %u\n"
                "\n"
                "Free Requests\n"
                "  Caller Requests: %u\n"
                "  Block Frees: %u\n"
                "  Block Clears: %u",
            poolHeader->Name[0] ? poolHeader->Name : TEXT("[Unnamed Pool]"),
            FloatWorkaround,
            poolHeader->MaxAllocationSize,
            poolHeader->CurrentlyAllocatedMemory,
            poolHeader->MaximumAllocatedMemory,
            poolHeader->NumAllocationRequests,
            poolHeader->NumBlockAllocations,
            poolHeader->NumFreeRequests,
            poolHeader->NumBlockFrees,
            poolHeader->NumBlockClears
            ));

    } else if (poolHeader->Name[0]) {

        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool %s was allocated but was never used",
            poolHeader->Name
            ));
    }


    //
    // Free all allocations that have not yet been freed.
    //

    pDeregisterPoolAllocations(poolHeader);

#endif


    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader-> PoolHead;

    while (blockToFree != NULL) {

        nextBlock = blockToFree->NextBlock;
        MemFree(g_hHeap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    MemFree(g_hHeap,0,poolHeader);

}

PVOID
RealPmGetMemory (
    IN PMHANDLE Handle,
    IN SIZE_T Size,
    IN DWORD AlignSize
    )

/*++

Routine Description:

    RealPmGetMemory is the worker routine that processes all requests to retrieve memory
    from a pool. Other calls eventually decay into a call to this common routine. This routine
    attempts to service the request out of the current memory block, or, if it cannot, out of
    a newly allocated block.

Arguments:

    Handle - A valid PMHANDLE.
    Size   - Contains the size in bytes that the caller needs from the pool.
    AlignSize - Provides an alignment value. The returned memory will be aligned on <alignsize> byte
        boundaries.

Return Value:

    The allocated memory, or, NULL if no memory could be allocated.

--*/
{
    BOOL haveEnoughMemory = TRUE;
    PVOID rMemory = NULL;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;
    PPMBLOCK currentBlock;
    PALLOCATION allocation;
    SIZE_T sizeNeeded;
    UINT_PTR padLength;

    MYASSERT(poolHeader != NULL);
    MYASSERT(Size);

    EnterOurCriticalSection (&g_PmCs);

    __try {

        //
        // Assume that the current block of memory will be sufficient.
        //
        currentBlock = poolHeader->PoolHead;

#ifdef DEBUG


        //
        // Update stats.
        //
        poolHeader->MaxAllocationSize = max(poolHeader->MaxAllocationSize,Size);
        poolHeader->NumAllocationRequests++;
        poolHeader->TotalAllocationRequestBytes += Size;

#endif

        //
        // Determine if more memory is needed, attempt to add if needed. Note that the size
        // must include the size of an ALLOCATION struct in addition to the size required
        // by the callee. Note the references to AlignSize in the test below. This is to ensure
        // that there is enough memory to allocate after taking into acount data alignment.
        //
        sizeNeeded = Size + sizeof(ALLOCATION);

        if (currentBlock->Size - currentBlock->Index < sizeNeeded + AlignSize) {

            haveEnoughMemory = pPmAddMemory(poolHeader,sizeNeeded + AlignSize);

            //
            // Make sure that the currentBlock is correctly set
            //
            currentBlock = poolHeader->PoolHead;
        }

        //
        // If there is enough memory available, return it.
        //
        if (haveEnoughMemory) {
            if (AlignSize) {

                padLength = (UINT_PTR) currentBlock + sizeof(PMBLOCK)
                    + currentBlock->Index + sizeof(ALLOCATION);
                currentBlock->Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

            }

            //
            // Save a reference to this block in the memorys ALLOCATION structure.
            // This will be used to decrease the use count on a block when releasing
            // memory.
            //
            (PBYTE) allocation = &(currentBlock->RawMemory[currentBlock->Index]);
            allocation->ParentBlock = currentBlock;


#ifdef DEBUG

            //
            // Track this memory.
            //
            allocation->DogTag = VALIDDOGTAG;
            allocation->Next = poolHeader->AllocationList;
            allocation->Prev = NULL;

            if (poolHeader->AllocationList) {
                poolHeader->AllocationList->Prev = allocation;
            }

            poolHeader->AllocationList = allocation;

            if (poolHeader->FreeCalled != WHO_CARES) {

                DebugRegisterAllocation(POOLMEM_POINTER, allocation, g_TrackFile, g_TrackLine);

            }


#endif

            //
            //  Ok, get a reference to the actual memory to return to the user.
            //
            rMemory = (PVOID)
                &(currentBlock->RawMemory[currentBlock->Index + sizeof(ALLOCATION)]);

            //
            // Update memory block data fields.
            //
            currentBlock->Index += sizeNeeded;
            currentBlock->UseCount++;
        }
        else {
            DEBUGMSG((DBG_ERROR,
                "GetPoolMemory Failed. Size: %u",Size));
        }

    } __finally {

        LeaveOurCriticalSection (&g_PmCs);
    }

    return rMemory;
}

VOID
PmReleaseMemory (
    IN PMHANDLE Handle,
    IN PCVOID Memory
    )
/*++

Routine Description:

    PmReleaseMemory notifies the Pool that a piece of memory is no longer needed.
    if all memory within a non-active block (i.e. not the first block) is released,
    that block will be freed. If all memory is released within an active block, that blocks
    stats are simply cleared, effectively reclaiming its space.

Arguments:

    Handle - A Handle to a Pool of Memory.
    Memory - Contains the address of the memory that is no longer needed.

Return Value:

    None.

--*/
{
    PALLOCATION allocation;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL && Memory != NULL);

    EnterOurCriticalSection (&g_PmCs);

    __try {

        //
        // Get a reference to the ALLOCATION struct that precedes the actual memory.
        //
        allocation = (PALLOCATION) Memory - 1;

#ifdef DEBUG

        //
        // Update stats.
        //
        poolHeader->NumFreeRequests++;  //lint !e613

#endif




#ifdef DEBUG

        if (poolHeader->FreeCalled == FREE_NOT_CALLED) {    //lint !e613
            poolHeader->FreeCalled = FREE_CALLED;   //lint !e613
        }

        //
        // Check the dog tag on the allocation to provide sanity checking on the memory passed in.
        //
        if (allocation->DogTag != VALIDDOGTAG) {
            if (allocation->DogTag == FREEDOGTAG) {
                DEBUGMSG((
                    DBG_WHOOPS,
                    "Poolmem Error! This dogtag has already been freed! Pool: %s",
                    poolHeader->Name
                    ));

            } else {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Poolmem Error! Unknown value found in allocation dogtag.  Pool: %s",
                    poolHeader->Name
                    ));

                MYASSERT (FALSE);   //lint !e506
            }

            __leave;

        } else {
            allocation->DogTag = FREEDOGTAG;
        }

        if (allocation->Next) {
            allocation->Next->Prev = allocation->Prev;
        }

        if (poolHeader->AllocationList == allocation) { //lint !e613
            poolHeader->AllocationList = allocation->Next;  //lint !e613
        } else {

            allocation->Prev->Next = allocation->Next;
        }


        if (poolHeader->FreeCalled != WHO_CARES) {  //lint !e613
            DebugUnregisterAllocation(POOLMEM_POINTER,allocation);
        }
#endif

        //
        // Check to make sure this memory has not previously been freed.
        //
        if (allocation->ParentBlock == NULL) {
            DEBUGMSG((
                DBG_WHOOPS,
                "PoolMem Error! previously freed memory passed to PoolMemReleaseMemory.  Pool: %s",
                poolHeader->Name
                ));
            __leave;
        }

        //
        // Update the use count on this allocations parent block.
        //
        allocation->ParentBlock->UseCount--;




        if (allocation->ParentBlock->UseCount == 0) {

            //
            // This was the last allocation still referring to the parent block.
            //

            if (allocation->ParentBlock != poolHeader->PoolHead) {  //lint !e613
                //
                // Since the parent block isn't the active block, simply delete it.
                //

#ifdef DEBUG

                //
                // Adjust stats.
                //
                poolHeader->NumBlockFrees++;    //lint !e613
                poolHeader->CurrentlyAllocatedMemory -=
                    allocation->ParentBlock->Size + sizeof(PMBLOCK);    //lint !e613


#endif

                if (allocation->ParentBlock->NextBlock) {
                    allocation->ParentBlock->NextBlock->PrevBlock =
                        allocation->ParentBlock->PrevBlock;
                }
                allocation->ParentBlock->PrevBlock->NextBlock =
                    allocation->ParentBlock->NextBlock;
                MemFree(g_hHeap,0,allocation->ParentBlock);


            }
            else {
                //
                // Since this is the active block, reset it.
                //
                allocation->ParentBlock->Index = 0;
                allocation->ParentBlock = NULL;

#ifdef DEBUG
                poolHeader->NumBlockClears++;   //lint !e613
#endif

            }
        }
        else {
            allocation->ParentBlock = NULL;

        }

    } __finally {

        LeaveOurCriticalSection (&g_PmCs);
    }

}


#ifdef DEBUG

PMHANDLE
RealPmCreateNamedPool (
    IN PCSTR Name
    )
{
    PMHANDLE pool;
    PPOOLHEADER poolHeader;

    pool = RealPmCreatePool();
    if (pool) {
        poolHeader = (PPOOLHEADER) pool;
        StringCopyByteCountA (poolHeader->Name, Name, MAX_POOL_NAME);
        MYASSERT (!poolHeader->TotalAllocationRequestBytes);
    }

    return pool;
}

#endif



PSTR
PmDuplicateMultiSzA (
    IN PMHANDLE Handle,
    IN PCSTR MultiSzToCopy
    )
{
    PSTR rString = (PSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (rString [0] != 0) {
        rString = GetEndOfStringA (rString) + 1;    //lint !e613
    }
    size = (UINT_PTR) rString -  (UINT_PTR) MultiSzToCopy + 1;
    rString = PmGetAlignedMemory(Handle, size);
    memcpy (rString, MultiSzToCopy, size);

    return rString;
}

PWSTR
PmDuplicateMultiSzW (
    IN PMHANDLE Handle,
    IN PCWSTR MultiSzToCopy
    )
{
    PWSTR rString = (PWSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (rString [0] != 0) {
        rString = GetEndOfStringW (rString) + 1;
    }
    size = ((UINT_PTR) rString - (UINT_PTR) MultiSzToCopy + 1) * sizeof(WCHAR);
    rString = PmGetAlignedMemory(Handle, size);
    memcpy (rString, MultiSzToCopy, size);

    return rString;
}



#ifdef DEBUG

VOID
PmDisableTracking (
    IN PMHANDLE Handle
    )

/*++

Routine Description:

    PmDisableTracking suppresses the debug output caused by a pool
    that has a mix of freed and non-freed blocks.

Arguments:

    Handle - A Handle to a Pool of Memory.

Return Value:

    None.

--*/
{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);
    poolHeader->FreeCalled = WHO_CARES;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\bintree.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    bintree.c

Abstract:

    Routines that manage the binary trees in the memdb database

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

--*/


#include "pch.h"

// PORTBUG: Make sure to pick up latest fixes in win9xupg project

//
// Includes
//

#include "memdbp.h"
#include "bintree.h"

//
// Strings
//

// None

//
// Constants
//

#define NODESTRUCT_SIZE_MAIN    (4*sizeof(UINT) + sizeof(WORD))
#define BINTREE_SIZE_MAIN    sizeof(UINT)
#define LISTELEM_SIZE_MAIN    (3*sizeof(UINT))

#ifdef DEBUG

    #define NODESTRUCT_HEADER_SIZE  (sizeof(DWORD)+sizeof(BOOL))
    #define NODESTRUCT_SIZE         ((WORD)(NODESTRUCT_SIZE_MAIN + (g_UseDebugStructs ? NODESTRUCT_HEADER_SIZE : 0)))

    #define BINTREE_HEADER_SIZE  (sizeof(DWORD)+2*sizeof(INT)+sizeof(BOOL))
    #define BINTREE_SIZE         ((WORD)(BINTREE_SIZE_MAIN + (g_UseDebugStructs ? BINTREE_HEADER_SIZE : 0)))

    #define LISTELEM_HEADER_SIZE  sizeof(DWORD)
    #define LISTELEM_SIZE         ((WORD)(LISTELEM_SIZE_MAIN + (g_UseDebugStructs ? LISTELEM_HEADER_SIZE : 0)))

#else

    #define NODESTRUCT_SIZE         ((WORD)NODESTRUCT_SIZE_MAIN)
    #define BINTREE_SIZE         ((WORD)BINTREE_SIZE_MAIN)
    #define LISTELEM_SIZE         ((WORD)LISTELEM_SIZE_MAIN)

#endif


//
// Macros
//

#define MAX(a,b) (a>b ? a : b)
#define ABS(x) (x<0 ? -x : x)

#ifdef DEBUG

//
// if BINTREECHECKTREEBALANCE is true, every addition or deletion
// or rotation checks to make sure tree is balanced and
// correct.  this of course take a lot of time.
//
#define BINTREECHECKTREEBALANCE    FALSE

#define INITTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc=0; } }
#define INCTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc++; } }
#define DECTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc--; } }
#define TESTTREENODES(tree) { if (g_UseDebugStructs) { MYASSERT(tree->NodeAlloc==0); } }
#define INITTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc=0; } }
#define INCTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc++; } }
#define DECTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc--; } }
#define TESTTREEELEMS(tree) { if (g_UseDebugStructs) { MYASSERT(tree->ElemAlloc==0); } }

#else

#define BINTREECHECKTREEBALANCE

#define INITTREENODES(tree)
#define INCTREENODES(tree)
#define DECTREENODES(tree)
#define TESTTREENODES(tree)
#define INITTREEELEMS(tree)
#define INCTREEELEMS(tree)
#define DECTREEELEMS(tree)
#define TESTTREEELEMS(tree)

#endif

#if defined(DEBUG)
#if BINTREECHECKTREEBALANCE

#define TESTNODETREE(node) MYASSERT(pBinTreeCheckBalance(node));
#define TESTTREE(tree) MYASSERT(pBinTreeCheck(tree));

#else

#define TESTNODETREE(node)
#define TESTTREE(tree)

#endif

#else

#define TESTNODETREE(node)
#define TESTTREE(tree)

#endif

//
// Types
//

typedef struct {

#ifdef DEBUG
    DWORD Signature;
    BOOL Deleted;
#endif

    union {
        struct {        //for normal nodes
            UINT Data;              //offset of data structure
            UINT Left;              //offset of left child
            UINT Right;             //offset of right child
            UINT Parent;            //offset of parent
        };//lint !e657
        struct {        //for the InsertionOrdered list header node (tree->Root points to this)
            UINT Root;              //offset of actual root of tree
            UINT Head;              //head of insertion ordered list
            UINT Tail;              //tail of insertion ordered list
        };//lint !e657
        UINT NextDeleted;           //offset of next deleted node
    };


    struct {
        WORD InsertionOrdered : 1;  //flag, 1 if insertion-ordered (only really needed
                                    //by enumeration methods, because to save space
                                    //there is no tree pointer in the NODESTRUCT, but
                                    //we need a way for enumeration methods to know if
                                    //node->Data is the offset of the data or the
                                    //offset of a LISTELEM (which it is when we are in
                                    //insertion-ordered mode)).
        WORD InsertionHead : 1;     //flag, 1 if this node is the head of insertion
                                    //ordered tree.
        WORD LeftDepth : 7;         //depths of subtrees.  these can be 7 bits because
        WORD RightDepth : 7;        //if depth got up to near 128, the approximate
                                    //number of nodes would be 1e35.
    };//lint !e657
} NODESTRUCT, *PNODESTRUCT;

//
// normally, the BINTREE structure simply has the offset
// of the root node of the tree in its Root member.  but
// when we are in insertion-ordered mode, we have an extra
// node whose offset is stored in the BINTREE->Root.  this
// Header Node points to the head of the insertion-ordered
// linked list, the tail of the list, and the actual root
// of the binary tree.
//

typedef struct {

#ifdef DEBUG

    DWORD Signature;
    INT NodeAlloc;          // counter for number of nodes allocated
    INT ElemAlloc;          // counter for number of elems allocated
    BOOL Deleted;           // flag which is TRUE if tree is deleted

#endif

    union {
        UINT Root;          // offset of top level NODESTRUCT
        UINT NextDeleted;   // offset of next deleted tree
    };

} BINTREE, *PBINTREE;

//
// if we are in insertion-ordered mode, that means every
// enumeration will be in the order that we added the
// data.  to do this, we use a linked list with the binary
// tree.  the data member of the NODESTRUCT holds the
// offset of the LISTELEM structure, and the data member
// of the LISTELEM structure holds the offset of the data.
// To enumerate, we just walk the linked list in order.
//

typedef struct {

#ifdef DEBUG
    DWORD Signature;
#endif

    union {
        struct {
            UINT Next;      // offset of next element in list
            UINT Data;      // offset of data structure this element is for
            UINT Node;      // offset of NODESTRUCT this listelem corresponds to
        };//lint !e657
        UINT NextDeleted;
    };

} LISTELEM, *PLISTELEM;

//
// Globals
//

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

PNODESTRUCT
pBinTreeFindNode (
    IN      PBINTREE Tree,
    IN      PCWSTR String
    );

PNODESTRUCT
pBinTreeEnumFirst (
    IN      PBINTREE Tree
    );

PNODESTRUCT
pBinTreeEnumNext (
    IN OUT  PNODESTRUCT CurrentNode
    );

PNODESTRUCT
pBinTreeAllocNode (
    OUT     PUINT Offset
    );

PBINTREE
pBinTreeAllocTree (
    OUT     PUINT Offset
    );

PLISTELEM
pBinTreeAllocListElem (
    OUT     PUINT Offset
    );

VOID
pBinTreeFreeNode (
    PNODESTRUCT Node
    );

VOID
pBinTreeFreeTree (
    PBINTREE Tree
    );

VOID
pBinTreeFreeListElem (
    PLISTELEM Elem
    );

VOID
pBinTreeDestroy (
    PNODESTRUCT Node,
    PBINTREE Tree
    );

//
// This starts at node and moves up tree balancing.
// The function stops moving up when it finds a node
// which has no change in depth values and/or no balancing
// to be done.  Otherwise, it goes all the way to top.
// Carry TreeOffset through for rotate functions
//
VOID
pBinTreeBalanceUpward (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

//
// After pBinTreeNodeBalance, parent of node could have incorrect
// depth values and might need rebalancing.
// Carry TreeOffset through for rotate functions.
// Assumes children of 'node' are balanced.
// Returns true if node rebalanced or if depth values changed.
//
BOOL
pBinTreeNodeBalance (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

//
// After using the following rotate functions, the parents of node
// could have incorrect depth values, and could need rebalancing.
// We do not have double-rotate functions because that is taken
// care of inside these.  Need TreeOffset just in case node is top node
//
VOID
pBinTreeRotateRight (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

VOID
pBinTreeRotateLeft (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );


#ifdef DEBUG

INT
pBinTreeCheckBalance (
    IN      PNODESTRUCT Node
    );

INT
pBinTreeCheck (
    IN      PBINTREE Tree
    );

#endif

//
// Macro expansion definition
//

// None

//
// Code
//

//
// If we are in debug mode, these conversions
// are implemented as functions, so we can
// check for errors.  If we are not in debug
// mode, the conversions are simple macros.
//
#ifdef DEBUG

UINT
GetNodeOffset (
    IN      PNODESTRUCT Node
    )
{
    if (!Node) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Node) + NODESTRUCT_HEADER_SIZE;
    }

    MYASSERT (Node->Signature == NODESTRUCT_SIGNATURE);

    return PTR_TO_OFFSET(Node);
}


UINT
GetTreeOffset (
    PBINTREE Tree
    )
{

    if (!Tree) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Tree) + BINTREE_HEADER_SIZE;
    }

    MYASSERT (Tree->Signature == BINTREE_SIGNATURE);

    return PTR_TO_OFFSET(Tree);
}


UINT
GetListElemOffset (
    PLISTELEM Elem
    )
{
    if (!Elem) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Elem) + LISTELEM_HEADER_SIZE;
    }

    MYASSERT (Elem->Signature == LISTELEM_SIGNATURE);

    return PTR_TO_OFFSET(Elem);
}


PNODESTRUCT
GetNodeStruct (
    UINT Offset
    )
{
    PNODESTRUCT node;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PNODESTRUCT) OFFSET_TO_PTR(Offset - NODESTRUCT_HEADER_SIZE);
    }

    node = (PNODESTRUCT) OFFSET_TO_PTR(Offset);

    MYASSERT (node->Signature == NODESTRUCT_SIGNATURE);

    return node;
}


PBINTREE
GetBinTree (
    UINT Offset
    )
{
    PBINTREE tree;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PBINTREE) OFFSET_TO_PTR(Offset - BINTREE_HEADER_SIZE);
    }

    tree = (PBINTREE) OFFSET_TO_PTR(Offset);

    MYASSERT (tree->Signature == BINTREE_SIGNATURE);

    return tree;
}


PLISTELEM
GetListElem (
    UINT Offset
    )
{
    PLISTELEM elem;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PLISTELEM) OFFSET_TO_PTR(Offset - LISTELEM_HEADER_SIZE);
    }

    elem = (PLISTELEM) OFFSET_TO_PTR(Offset);

    MYASSERT (elem->Signature == LISTELEM_SIGNATURE);

    return elem;
}

#else

#define GetNodeOffset(Node)         ((Node) ?                   \
                                        PTR_TO_OFFSET(Node) :   \
                                        INVALID_OFFSET)

#define GetTreeOffset(Tree)         ((Tree) ?                   \
                                        PTR_TO_OFFSET(Tree) :   \
                                        INVALID_OFFSET)

#define GetListElemOffset(Elem)     ((Elem) ?                   \
                                        PTR_TO_OFFSET(Elem) :   \
                                        INVALID_OFFSET)

#define GetNodeStruct(Offset)       (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PNODESTRUCT) OFFSET_TO_PTR(Offset))

#define GetBinTree(Offset)          (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PBINTREE) OFFSET_TO_PTR(Offset))

#define GetListElem(Offset)         (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PLISTELEM)OFFSET_TO_PTR(Offset))


#endif


//
// GetNodeData - takes a node and gets the data
//      structure offset
//
// GetNodeDataStr - takes a node and gets the
//      pascal-style string in the data structure offset
//

#define GetNodeData(Node)       ((Node)->InsertionOrdered ?                 \
                                        GetListElem((Node)->Data)->Data :   \
                                        (Node)->Data)

#define GetNodeDataStr(Node)    (GetDataStr(GetNodeData(Node)))


PNODESTRUCT
GetTreeRoot (
    IN      PBINTREE Tree
    )
{
    PNODESTRUCT cur;

    if (!Tree || Tree->Root == INVALID_OFFSET) {
        return NULL;
    }

    cur = GetNodeStruct (Tree->Root);

    if (cur->InsertionHead) {
        return GetNodeStruct (cur->Root);
    } else {
        return cur;
    }
}


VOID
pSetTreeRoot (
    IN      PBINTREE Tree,
    IN      UINT Offset
    )
{
    PNODESTRUCT cur;

    if (!Tree) {
        return;
    }

    cur = GetNodeStruct(Tree->Root);

    if (cur && cur->InsertionHead) {
        cur->Root = Offset;
    } else {
        Tree->Root = Offset;
    }
}

#define IsTreeInsertionOrdered(Tree)    ((Tree) ?                                               \
                                            ((Tree)->Root==INVALID_OFFSET ?                     \
                                                FALSE :                                         \
                                                GetNodeStruct((Tree)->Root)->InsertionHead) :   \
                                            FALSE)







UINT
BinTreeNew (
    VOID
    )

/*++

Routine Description:

  BinTreeNew creates a new binary tree data structure. This is done when a new
  node is created via a set operation of some sort. Additional items are added
  to the binary tree via BinTreeAddNode.

Arguments:

  None.

Return Value:

  The offset to the new tree.

Comments:

  This function assumes that it cannot fail,  because if a low-level memory
  routine fails, the process will die.

  The database heap might be moved by the allocation request, and could
  invalidate pointers. The caller must use care not to use pointers until
  after this routine returns, or it must re-convert offsets into new pointers.

--*/

{
    UINT treeOffset;
    PBINTREE tree;

    tree = pBinTreeAllocTree (&treeOffset);

    tree->Root = INVALID_OFFSET;

    INITTREENODES(tree);
    INITTREEELEMS(tree);

    return treeOffset;
}


BOOL
BinTreeAddNode (
    IN      UINT TreeOffset,
    IN      UINT Data
    )

/*++

Routine Description:

  BinTreeAddNode adds a new item to an existing binary tree.

Arguments:

  TreeOffset - Indicates the root of the binary tree, as returned by
               BinTreeNew.
  Data       - Specifies the offset of the data structure containing the
               node to insert. The string address is computed from Data via
               GetDataStr.

Return Value:

  TRUE if the insertion operation succeeded, FALSE if the item is already in
  the tree.

--*/

{
    UINT nodeOffset;
    UINT elemOffset;
    UINT parentOffset;
    PNODESTRUCT node;
    PNODESTRUCT cur;
    PNODESTRUCT parent;
    PBINTREE tree;
    PLISTELEM elem;
    INT cmp;
    PCWSTR dataStr;

    if (TreeOffset == INVALID_OFFSET) {
        return FALSE;
    }

    //
    // Keep track of initial database pointer.  If it changes, we need
    // to readjust our pointers.
    //

    tree = GetBinTree (TreeOffset);

    if (!GetTreeRoot (tree)) {

        //
        // No root case -- add this item as the root
        //

        node = pBinTreeAllocNode (&nodeOffset);
        PTR_WAS_INVALIDATED(tree);

        tree = GetBinTree (TreeOffset);
        INCTREENODES (tree);

        pSetTreeRoot (tree, nodeOffset);

        node->Parent = INVALID_OFFSET;
        parentOffset = INVALID_OFFSET;
        parent = NULL;

    } else {

        //
        // Existing root case -- try to find the item, then if it does
        // not exist, add it.
        //

        cur = GetTreeRoot (tree);
        dataStr = GetDataStr (Data);

        do {
            cmp = StringPasICompare (dataStr, GetNodeDataStr (cur));

            if (!cmp) {
                //
                // Node is already in tree
                //
                return FALSE;
            }

            //
            // Go to left or right node, depending on search result
            //

            parentOffset = GetNodeOffset (cur);

            if (cmp < 0) {
                cur = GetNodeStruct(cur->Left);
            } else {
                cur = GetNodeStruct(cur->Right);
            }

        } while (cur);

        //
        // Node is not in the tree.  Add it now.
        //

        node = pBinTreeAllocNode(&nodeOffset);
        PTR_WAS_INVALIDATED(cur);
        PTR_WAS_INVALIDATED(tree);

        tree = GetBinTree (TreeOffset);
        INCTREENODES (tree);

        node->Parent = parentOffset;
        parent = GetNodeStruct (parentOffset);

        if (cmp < 0) {
            parent->Left = nodeOffset;
        } else {
            parent->Right = nodeOffset;
        }
    }

    //
    // Verify the code above restored the tree pointer if
    // an allocation occurred.
    //

    MYASSERT (tree == GetBinTree (TreeOffset));

    //
    // Initialize the new node
    //

    node->Left          = INVALID_OFFSET;
    node->Right         = INVALID_OFFSET;
    node->LeftDepth     = 0;
    node->RightDepth    = 0;
    node->InsertionHead = 0;

    if (!IsTreeInsertionOrdered (tree)) {
        //
        // We are in sorted-order mode
        //

        node->Data = Data;
        node->InsertionOrdered = 0;

    } else {
        //
        // We are in insertion-ordered mode
        //

        elem = pBinTreeAllocListElem (&elemOffset);
        PTR_WAS_INVALIDATED(parent);
        PTR_WAS_INVALIDATED(tree);
        PTR_WAS_INVALIDATED(node);

        parent = GetNodeStruct (parentOffset);
        tree = GetBinTree (TreeOffset);
        node = GetNodeStruct (nodeOffset);

        INCTREEELEMS(tree);

        node->InsertionOrdered = 1;
        node->Data = elemOffset;                // NODESTRUCT.Data is offset of list element
        elem->Data = Data;                      // LISTELEM holds offset of data
        elem->Node = nodeOffset;                // LISTELEM points back to nodestruct
        elem->Next = INVALID_OFFSET;            // elem will be put at end of list

        //now use node to point to list header
        node = GetNodeStruct (tree->Root);
        MYASSERT (node->InsertionHead);

        if (node->Head == INVALID_OFFSET) {     // if this is true, the list is empty
            node->Head = elemOffset;            // put elemOffset at beginning of the list
        } else {                                // otherwise, put the new element at end of list
            MYASSERT (node->Tail != INVALID_OFFSET);
            GetListElem (node->Tail)->Next = elemOffset;
        }

        node->Tail = elemOffset;                // new element is tail of list
    }

    pBinTreeBalanceUpward (parent, TreeOffset);

    TESTTREE (GetBinTree (TreeOffset));

    return TRUE;
}


UINT
BinTreeDeleteNode (
    IN      UINT TreeOffset,
    IN      PCWSTR Str,
    OUT     PBOOL LastNode              OPTIONAL
    )

/*++

Routine Description:

  BinTreeDeleteNode removes a string from a binary tree.

Arguments:

  TreeOffset - Specifies the binary tree to remove the string from
  Str        - Specifies the string to remove
  LastNode   - Receives TRUE if the binary tree became empty as a result of
               the delete, FALSE otherwise

Return Value:

  The data offset of the string that was deleted

--*/

{
    PNODESTRUCT deleteNode;
    PNODESTRUCT parent;
    PNODESTRUCT replace;
    UINT data;
    UINT replaceOffset;
    UINT deleteNodeOffset;
    PNODESTRUCT startBalance;
    PNODESTRUCT startBalance2 = NULL;
    PBINTREE tree;
    UINT elemOffset;
    PLISTELEM elem;
    PLISTELEM cur;
    PNODESTRUCT header;

    //
    // after we delete a node, we have to start from somewhere and
    // move up the tree, fixing the balance of nodes.  startBalance
    // is a pointer to the nodestruct to start at.  in more complicated
    // deletions, like when the deleted node has two children, and the
    // replacement node is way down the tree, there are two places to
    // start rebalancing from.
    //

    if (TreeOffset == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    tree = GetBinTree (TreeOffset);

    deleteNode = pBinTreeFindNode (tree, Str);
    if (deleteNode == NULL) {
        return INVALID_OFFSET;
    }

    if (LastNode) {
        *LastNode = FALSE;
    }

    deleteNodeOffset = GetNodeOffset (deleteNode);
    parent = GetNodeStruct (deleteNode->Parent);

    data = GetNodeData (deleteNode);

    if (deleteNode->Right == INVALID_OFFSET && deleteNode->Left == INVALID_OFFSET) {

        //
        // deleteNode has no children
        //

        if (parent == NULL) {

            if (LastNode) {
                *LastNode = TRUE;
            }

            pSetTreeRoot(tree, INVALID_OFFSET);

        } else {

            if (parent->Left == deleteNodeOffset) {
                parent->Left=INVALID_OFFSET;
            } else {
                parent->Right=INVALID_OFFSET;
            }

        }

        startBalance = parent;

    } else {
        //
        // deleteNode has one or two children
        //

        if (deleteNode->Right == INVALID_OFFSET || deleteNode->Left == INVALID_OFFSET) {

            //
            // deleteNode has one child
            //

            if (deleteNode->Right == INVALID_OFFSET) {
                replace = GetNodeStruct (deleteNode->Left);
            } else {
                replace = GetNodeStruct (deleteNode->Right);
            }

            replaceOffset = GetNodeOffset (replace);

            //
            // deleteNode->Parent has new child, so check balance
            //

            startBalance = parent;

        } else {

            //
            // deleteNode has two children: find replacement on deeper side
            //

            if (deleteNode->LeftDepth > deleteNode->RightDepth) {

                //
                // find replacement node on left
                //

                replace = GetNodeStruct (deleteNode->Left);

                if (replace->Right == INVALID_OFFSET) {
                    //
                    // node's left child has no right child, so replace is node->Left
                    //
                    replace->Right = deleteNode->Right;  //hook up node's right child to replace

                    GetNodeStruct (replace->Right)->Parent = deleteNode->Left;

                    replaceOffset = GetNodeOffset (replace);

                } else {
                    //
                    // deleteNode's left child has right child, so find the rightmost child
                    //

                    do {
                        //
                        // move right as far as possible
                        //
                        replace = GetNodeStruct (replace->Right);

                    } while (replace->Right != INVALID_OFFSET);

                    //
                    // child of replace->Parent changed, so balance
                    //

                    startBalance2 = GetNodeStruct (replace->Parent);

                    //
                    // replace's parent's right child is replace's left
                    //

                    startBalance2->Right = replace->Left;

                    if (replace->Left != INVALID_OFFSET) {
                        //
                        // hook up left children to replace->Parent
                        //
                        GetNodeStruct(replace->Left)->Parent = replace->Parent;
                    }

                    replaceOffset = GetNodeOffset (replace);

                    //
                    // hook up children of deleteNode to replace
                    //

                    replace->Left = deleteNode->Left;
                    GetNodeStruct (replace->Left)->Parent = replaceOffset;

                    replace->Right = deleteNode->Right;
                    GetNodeStruct (replace->Right)->Parent = replaceOffset;
                }

            } else {
                //
                // find replacement node on right
                //

                replace = GetNodeStruct (deleteNode->Right);

                if (replace->Left == INVALID_OFFSET) {
                    //
                    // deleteNode's right child has no left child, so replace is deleteNode->Right
                    //

                    replace->Left = deleteNode->Left;  // hook up node's left child to replace

                    GetNodeStruct (replace->Left)->Parent = deleteNode->Right;

                    replaceOffset = GetNodeOffset (replace);

                } else {
                    //
                    // deleteNode's right child has left child, so find the leftmost child
                    //

                    do {

                        replace = GetNodeStruct (replace->Left);

                    } while (replace->Left != INVALID_OFFSET);

                    //
                    // child of replace->Parent changed, so balance
                    //
                    startBalance2 = GetNodeStruct (replace->Parent);

                    //
                    // replace's parent's left child is replace's right
                    //
                    startBalance2->Left = replace->Right;

                    if (replace->Right != INVALID_OFFSET) {
                        //
                        // hook up right children to replace->Parent
                        //
                        GetNodeStruct (replace->Right)->Parent = replace->Parent;
                    }

                    replaceOffset = GetNodeOffset (replace);

                    //
                    // hook up children of deleteNode to replace
                    //
                    replace->Right = deleteNode->Right;
                    GetNodeStruct (replace->Right)->Parent = replaceOffset;

                    replace->Left = deleteNode->Left;
                    GetNodeStruct (replace->Left)->Parent = replaceOffset;
                }
            }

            //
            // in all cases of deleted node having two children,
            // the place to start (second) balancing is the node
            // that replaces the deleted node, because it will
            // always have at least one new child.
            //
            startBalance = replace;
        }

        //
        // this is offset
        //

        replace->Parent = deleteNode->Parent;

        if (parent == NULL) {
            //
            // deleting top-level node
            //
            pSetTreeRoot (tree, replaceOffset);

        } else {
            if (parent->Left == deleteNodeOffset) {
                parent->Left = replaceOffset;
            } else {
                parent->Right = replaceOffset;
            }
        }
    }

    if (startBalance2) {
        //
        // startBalance2 is lower one
        //
        pBinTreeBalanceUpward (startBalance2, TreeOffset);
    }

    pBinTreeBalanceUpward (startBalance, TreeOffset);

    if (deleteNode->InsertionOrdered) {
        //
        // We are in insertion-ordered mode
        //

        //
        // get offset of LISTELEM for this NODESTRUCT
        //
        elemOffset = deleteNode->Data;
        elem = GetListElem (elemOffset);

        header = GetNodeStruct (tree->Root);   //get the header of list

        if (header->Head == elemOffset) {
            //
            // if elem was first in list
            //

            header->Head = elem->Next;

            if (elem->Next == INVALID_OFFSET) {     // if elem was last in list
                header->Tail = INVALID_OFFSET;
            }

        } else {
            //
            // elem was not first in list
            //

            cur = GetListElem (header->Head);

            while (cur->Next != elemOffset) {
                MYASSERT (cur->Next != INVALID_OFFSET);
                cur = GetListElem (cur->Next);
            }

            //
            // now cur is the element before elem, so pull elem out of list
            //

            cur->Next = elem->Next;
            if (elem->Next == INVALID_OFFSET) {           // if elem was last in list
                header->Tail = GetListElemOffset(cur);    // set end pointer to new last element
            }
        }

        pBinTreeFreeListElem (elem);
        DECTREEELEMS(tree);
    }

    pBinTreeFreeNode (deleteNode);
    DECTREENODES(tree);

    TESTTREE(tree);

    return data;
}


PNODESTRUCT
pBinTreeFindNode (
    IN      PBINTREE Tree,
    IN      PCWSTR Str
    )
{
    PNODESTRUCT cur;
    INT cmp;

    if (!Tree) {
        return NULL;
    }

    cur = GetTreeRoot (Tree);

    while (cur) {

        cmp = StringPasICompare (Str, GetNodeDataStr (cur));

        if (!cmp) {
            break;
        }

        if (cmp < 0) {
            cur = GetNodeStruct (cur->Left);
        } else {
            cur = GetNodeStruct (cur->Right);
        }
    }

    return cur;
}


UINT
BinTreeFindNode (
    IN      UINT TreeOffset,
    IN      PCWSTR Str
    )

/*++

Routine Description:

  BinTreeFindNode searches a binary tree for a string and returns the offset
  to the item data.

Arguments:

  TreeOffset - Specifies the binary tree to search
  Str        - Specifies the string to find

Return Value:

  The offset to the node data, or INVALID_OFFSET if string is not found.

--*/

{
    PNODESTRUCT node;
    PBINTREE tree;

    tree = GetBinTree (TreeOffset);
    node = pBinTreeFindNode (tree, Str);

    if (!node) {
        return INVALID_OFFSET;
    }

    return GetNodeData(node);
}


VOID
pBinTreeDestroy (
    IN      PNODESTRUCT Node,       OPTIONAL
    IN      PBINTREE Tree           OPTIONAL
    )

/*++

Routine Description:

  pBinTreeDestroy destroys a binary tree. This routine is recursive.

Arguments:

  Node - Specifies the node to deallocate.  All child nodes are also
         deallocated.
  Tree - Specifies the tree that Node belongs to

Return Value:

  None.

--*/

{
    if (!Node || !Tree) {
        return;
    }

    pBinTreeDestroy (GetNodeStruct (Node->Left), Tree);
    pBinTreeDestroy (GetNodeStruct (Node->Right), Tree);

    if (Node->InsertionOrdered) {
        pBinTreeFreeListElem (GetListElem (Node->Data));
        DECTREEELEMS(Tree);
    }

    pBinTreeFreeNode (Node);
    DECTREENODES(Tree);
}


VOID
BinTreeDestroy (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeDestroy deallocates all nodes in a binary tree.

Arguments:

  TreeOffset - Specifies the binary tree to free

Return Value:

  None.

--*/

{
    PBINTREE tree;
    PNODESTRUCT root;
    PNODESTRUCT header;

    if (TreeOffset==INVALID_OFFSET) {
        return;
    }

    tree = GetBinTree (TreeOffset);
    root = GetNodeStruct (tree->Root);

    if (root && root->InsertionHead) {
        header = root;
        root = GetNodeStruct (root->Root);
    } else {
        header = NULL;
    }

    pBinTreeDestroy (root, tree);

    if (header) {
        pBinTreeFreeNode(header);
        DECTREENODES(tree);
    }

    TESTTREENODES(tree);
    TESTTREEELEMS(tree);

    pBinTreeFreeTree(tree);
}


PNODESTRUCT
pBinTreeEnumFirst (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeEnumFirst returns the first node in the specified tree.

Arguments:

  Tree - Specifies the tree to begin enumerating

Return Value:

  A pointer to the first node struct, or NULL if no items exist in Tree, or
  if Tree is NULL.

--*/

{
    PNODESTRUCT cur;

    cur = GetTreeRoot (Tree);

    if (cur) {

        while (cur->Left != INVALID_OFFSET) {
            cur = GetNodeStruct (cur->Left);
        }

    }

    return cur;
}


PNODESTRUCT
pBinTreeEnumNext (
    IN      PNODESTRUCT CurrentNode
    )

/*++

Routine Description:

  pBinTreeEnumNext continues an enumeration of a binary tree. It walks the
  tree in sorted order.

Arguments:

  CurrentNode - Specifies the previous node returned by pBinTreeEnumFirst or
                pBinTreeEnumNext.

Return Value:

  Returns the next node in the tree, or NULL if no more items are left to
  enumerate.

--*/

{
    PNODESTRUCT cur;
    PNODESTRUCT parent;

    if (!CurrentNode) {
        return NULL;
    }

    cur = CurrentNode;

    if (cur->Right != INVALID_OFFSET) {

        cur = GetNodeStruct (cur->Right);

        while (cur->Left != INVALID_OFFSET) {
            cur = GetNodeStruct (cur->Left);
        }

        return cur;
    }

    //
    // otherwise, cur has no right child, so we have to
    // move upwards until we find a parent to the right
    // (or we reach top of tree, meaning we are done)
    //

    for (;;) {
        parent = GetNodeStruct (cur->Parent);

        //
        // if has no parent or parent is to right
        //

        if (!parent || parent->Left == GetNodeOffset (cur)) {
            break;
        }

        cur = parent;
    }

    return parent;
}


PLISTELEM
pBinTreeInsertionEnumFirst (
    PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeInsertionEnumFirst begins an enumeration of the nodes inside an
  insertion-ordered tree.  If the tree is not insertion ordered, no items are
  enumerated.  If insertion order was enabled after items had been previously
  added, this enumeration will not return those initial items.

Arguments:

  Tree - Specifies the tree to begin enumeration of

Return Value:

  A pointer to the linked list element, or NULL if no insertion-ordered nodes
  exist in Tree, or NULL if Tree is NULL.

--*/

{
    PNODESTRUCT header;

    if (!Tree) {
        return NULL;
    }

    header = GetNodeStruct (Tree->Root);

    return header ? GetListElem (header->Head) : NULL;
}


PLISTELEM
pBinTreeInsertionEnumNext (
    IN      PLISTELEM Elem
    )

/*++

Routine Description:

  pBinTreeInsertionEnumNext continues an enumeration of the insertion-ordered
  nodes in a binary tree.

Arguments:

  Elem - Specifies the previously enumerated list element

Return Value:

  A pointer to the next element, or NULL if no more elements exist, or if
  Elem is NULL.

--*/

{
    if (!Elem) {
        return NULL;
    }

    return GetListElem (Elem->Next);
}


UINT
BinTreeEnumFirst (
    IN      UINT TreeOffset,
    OUT     PUINT Enum
    )

/*++

Routine Description:

  BinTreeEnumFirst begins an enumeration of the data offsets stored in a
  binary tree. The enumeration is sorted order or insertion order, depending
  on the insertion order setting within the tree.

Arguments:

  TreeOffset - Specifies the binary tree to begin enumeration of.
  Enum       - Receives the offset to the binary tree node.

Return Value:

  The offset to the data associated with the first node, or INVALID_OFFSET if
  the tree is empty.

--*/

{
    PBINTREE tree;
    PNODESTRUCT node;
    PLISTELEM elem;

    MYASSERT (Enum);

    if (TreeOffset == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    tree = GetBinTree (TreeOffset);

    if (IsTreeInsertionOrdered (tree)) {
        //
        // tree is insertion-ordered, so get first element in
        // linked list.  enumerator is NODESTRUCT for this elem
        //

        elem = pBinTreeInsertionEnumFirst (tree);

        if (!elem) {

            if (Enum) {
                *Enum = INVALID_OFFSET;
            }

            return INVALID_OFFSET;

        } else {

            if (Enum) {
                *Enum = elem->Node;
            }

            return elem->Data;
        }

    } else {

        //
        // tree is not insertion-ordered, so get leftmost node.
        // enumerator is the offset of this node.
        //

        node = pBinTreeEnumFirst (tree);

        if (Enum) {
            *Enum = GetNodeOffset (node);
        }

        return !node ? INVALID_OFFSET : node->Data;
    }
}


UINT
BinTreeEnumNext (
    IN OUT  PUINT Enum
    )

/*++

Routine Description:

  BinTreeEnumNext continues an enumeration started by BinTreeEnumFirst.

Arguments:

  Enum - Specifies the previous node offset, receivies the enumerated node
         offset.

Return Value:

  The offset to the data associated with the next node, or INVALID_OFFSET if
  no more nodes exist in the tree.

--*/

{
    PNODESTRUCT node;
    PLISTELEM elem;

    MYASSERT (Enum);

    if (*Enum == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    node = GetNodeStruct (*Enum);

    if (node->InsertionOrdered) {
        //
        // tree is insertion-ordered,
        // so get next node in list.
        //

        elem = pBinTreeInsertionEnumNext (GetListElem (node->Data));

        if (!elem) {
            *Enum = INVALID_OFFSET;
            return INVALID_OFFSET;
        } else {
            *Enum = elem->Node;
            return elem->Data;
        }

    } else {
        //
        // tree is not insertion-ordered,
        // so get next node in tree.
        //
        node = pBinTreeEnumNext (node);

        *Enum = GetNodeOffset (node);
        return !node ? INVALID_OFFSET : node->Data;
    }
}



PNODESTRUCT
pBinTreeAllocNode (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocNode allocates a node in the current global database, and
  returns the offset and pointer to that node.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receivies the offset to the newly created node.

Return Value:

  A pointer to the newly created node.

--*/

{
    PNODESTRUCT node;

    if (g_CurrentDatabase->FirstBinTreeNodeDeleted == INVALID_OFFSET) {

        *Offset = DatabaseAllocBlock (NODESTRUCT_SIZE);
        MYASSERT (*Offset != INVALID_OFFSET);

#ifdef DEBUG
        if (g_UseDebugStructs) {
            node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset);
            node->Signature = NODESTRUCT_SIGNATURE;
        } else {
            node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset - NODESTRUCT_HEADER_SIZE);
        }
#else
        node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeNodeDeleted;
        node = GetNodeStruct(*Offset);
        g_CurrentDatabase->FirstBinTreeNodeDeleted = node->NextDeleted;
    }

#ifdef DEBUG
    if (g_UseDebugStructs) {
        node->Deleted = FALSE;
    }
#endif

    return node;
}


VOID
pBinTreeFreeNode (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeFreeNode puts an allocated node on the deleted list.  It does not
  adjust any other linkage.

Arguments:

  Node - Specifies the node to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT(Node);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        MYASSERT(Node->Signature == NODESTRUCT_SIGNATURE);
        Node->Deleted = TRUE;
    }
#endif

    Node->NextDeleted = g_CurrentDatabase->FirstBinTreeNodeDeleted;
    g_CurrentDatabase->FirstBinTreeNodeDeleted = GetNodeOffset(Node);
}


PBINTREE
pBinTreeAllocTree (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocTree creates a binary tree data structure. If a structure
  is available in the detele list, then it is used.  Otherwise, the
  database grows.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receivies the offset to the binary tree.

Return Value:

  A pointer to the new binary tree structure.

--*/

{
    PBINTREE tree;

    if (g_CurrentDatabase->FirstBinTreeDeleted == INVALID_OFFSET) {

        *Offset = DatabaseAllocBlock (BINTREE_SIZE);
        MYASSERT (*Offset != INVALID_OFFSET);

#ifdef DEBUG
        if (g_UseDebugStructs) {
            tree = (PBINTREE) OFFSET_TO_PTR(*Offset);
            tree->Signature = BINTREE_SIGNATURE;
        } else {
            tree = (PBINTREE) OFFSET_TO_PTR(*Offset - BINTREE_HEADER_SIZE);
        }
#else
        tree = (PBINTREE)OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeDeleted;
        tree = GetBinTree (*Offset);
        g_CurrentDatabase->FirstBinTreeDeleted = tree->NextDeleted;
    }

#ifdef DEBUG
    if (g_UseDebugStructs) {
        tree->Deleted = FALSE;
    }
#endif

    return tree;
}


VOID
pBinTreeFreeTree (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeFreeTree frees a binary tree structure.  It does not free the nodes
  within the structure.

Arguments:

  Tree - Specifies the binary tree structure to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT (Tree);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        Tree->Deleted = TRUE;
        MYASSERT (Tree->Signature == BINTREE_SIGNATURE);
    }
#endif

    Tree->NextDeleted = g_CurrentDatabase->FirstBinTreeDeleted;
    g_CurrentDatabase->FirstBinTreeDeleted = GetTreeOffset (Tree);
}


PLISTELEM
pBinTreeAllocListElem (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocListElem allocates a list element. If an element is available
  in the deleted list, it is used.  Otherwise, a new element is allocated
  from the database.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receives the offset of the newly allocated element

Return Value:

  A pointer to the allocated list element

--*/

{
    PLISTELEM elem;

    if (g_CurrentDatabase->FirstBinTreeListElemDeleted == INVALID_OFFSET) {

        *Offset = DatabaseAllocBlock (LISTELEM_SIZE);
        MYASSERT (*Offset != INVALID_OFFSET);

#ifdef DEBUG

        if (g_UseDebugStructs) {
            elem = (PLISTELEM) OFFSET_TO_PTR(*Offset);
            elem->Signature = LISTELEM_SIGNATURE;
        } else {
            elem = (PLISTELEM) OFFSET_TO_PTR(*Offset - LISTELEM_HEADER_SIZE);
        }

#else
        elem = (PLISTELEM) OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeListElemDeleted;
        elem = GetListElem (*Offset);
        g_CurrentDatabase->FirstBinTreeListElemDeleted = elem->NextDeleted;
    }

    return elem;
}


VOID
pBinTreeFreeListElem (
    IN      PLISTELEM Elem
    )

/*++

Routine Description:

  pBinTreeFreeListElem puts an allocated list element on the deleted element
  list, so it will be reused in a future allocation.

Arguments:

  Elem - Specifies the element to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT(Elem);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        MYASSERT(Elem->Signature == LISTELEM_SIGNATURE);
    }
#endif

    Elem->NextDeleted = g_CurrentDatabase->FirstBinTreeListElemDeleted;
    g_CurrentDatabase->FirstBinTreeListElemDeleted = GetListElemOffset(Elem);
}


VOID
pBinTreeBalanceUpward (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeBalanceUpward makes sure that the specified node is balanced. If it
  is not balanced, the nodes are rotated as necessary, and balancing
  continues up the tree.

Arguments:

  Node - Specifies the node to balance

  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT cur;
    PNODESTRUCT next;

    cur = Node;

    //
    // Move up tree.  stop if:
    //      a) hit top of tree
    //      b) pBinTreeNodeBalance returns FALSE (nothing changed)
    //

    while (cur) {
        //
        // need to grab cur's parent before balancing
        // cur because cur might change place in tree
        //

        next = GetNodeStruct (cur->Parent);

        if (!pBinTreeNodeBalance (cur, TreeOffset)) {
            return;
        }

        cur = next;
    }
}


BOOL
pBinTreeNodeBalance (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeNodeBalance checks the balance of the specified node, and if
  necessary, performs a rotation to balance the node. If a rotation was
  performed, the parent might become imbalanced.

Arguments:

  Node       - Specifies the node to balance
  TreeOffset - Specifies the offset to the binary tree that contains Node

Return Value:

  TRUE if a rotation was performed, FALSE if Node is already balanced

--*/

{
    UINT left;
    UINT right;
    PNODESTRUCT leftNode;
    PNODESTRUCT rightNode;

    if (!Node) {
        return FALSE;
    }

    leftNode  = GetNodeStruct (Node->Left);
    rightNode = GetNodeStruct (Node->Right);

    if (!rightNode) {
        right = 0;
    } else {
        right = MAX (rightNode->RightDepth, rightNode->LeftDepth) + 1;
    }

    if (!leftNode) {
        left = 0;
    } else {
        left = MAX (leftNode->RightDepth, leftNode->LeftDepth) + 1;
    }

    if (right == Node->RightDepth && left == Node->LeftDepth) {
        //
        // if node values have not changed, node is balanced
        //
        TESTNODETREE(Node);
        return FALSE;
    }

    MYASSERT (right < 126);
    MYASSERT (left < 126);

    Node->RightDepth = (WORD) right;
    Node->LeftDepth  = (WORD) left;

    if (Node->RightDepth > (Node->LeftDepth + 1)) {
        //
        // right heavy
        //

        pBinTreeRotateLeft (Node, TreeOffset);

    } else if (Node->LeftDepth > (Node->RightDepth + 1)) {
        //
        // left heavy
        //

        pBinTreeRotateRight (Node, TreeOffset);
    }

    return TRUE;
}


VOID
pBinTreeRotateLeft (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeRotateLeft performs a left rotation on Node, moving one node
  from the right side to the left side, in order to balance the node.

Arguments:

  Node       - Specifies the node to rotate left
  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT newRoot;
    PNODESTRUCT parent;
    PNODESTRUCT right;
    UINT nodeOffset;
    UINT newRootOffset;

    if (!Node) {
        return;
    }

    MYASSERT (Node->Right != INVALID_OFFSET);

    nodeOffset = GetNodeOffset (Node);
    parent     = GetNodeStruct (Node->Parent);

    right = GetNodeStruct (Node->Right);

    //
    // make sure right side is heavier on outside
    //

    if (right->LeftDepth > right->RightDepth) {
        pBinTreeRotateRight (right, TreeOffset);
        PTR_WAS_INVALIDATED(right);
    }

    newRootOffset = Node->Right;
    newRoot = GetNodeStruct (newRootOffset);

    Node->Right = newRoot->Left;
    if (newRoot->Left != INVALID_OFFSET) {
        GetNodeStruct (newRoot->Left)->Parent = nodeOffset;
    }

    newRoot->Parent = Node->Parent;
    if (Node->Parent == INVALID_OFFSET) {
        pSetTreeRoot (GetBinTree (TreeOffset), newRootOffset);
    } else {
        if (parent->Left == nodeOffset) {
            parent->Left = newRootOffset;
        } else {
            parent->Right = newRootOffset;
        }
    }

    newRoot->Left = nodeOffset;
    Node->Parent = newRootOffset;

    pBinTreeNodeBalance (Node, TreeOffset);
    pBinTreeNodeBalance (newRoot, TreeOffset);
}


VOID
pBinTreeRotateRight (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeRotateRight performs a right rotation on Node, moving one node from
  the left side to the right side, in order to balance the node.

Arguments:

  Node       - Specifies the node to rotate left
  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT newRoot;
    PNODESTRUCT parent;
    PNODESTRUCT left;
    UINT nodeOffset;
    UINT newRootOffset;

    if (!Node) {
        return;
    }

    MYASSERT (Node->Left != INVALID_OFFSET);

    nodeOffset = GetNodeOffset (Node);
    parent = GetNodeStruct (Node->Parent);

    left = GetNodeStruct (Node->Left);

    //
    // make sure left side is heavier on outside
    //

    if (left->RightDepth > left->LeftDepth) {
        pBinTreeRotateLeft (left, TreeOffset);
        PTR_WAS_INVALIDATED (left);
    }

    newRootOffset = Node->Left;
    newRoot = GetNodeStruct (newRootOffset);
    Node->Left = newRoot->Right;

    if (newRoot->Right != INVALID_OFFSET) {
        GetNodeStruct (newRoot->Right)->Parent = nodeOffset;
    }

    newRoot->Parent = Node->Parent;

    if (Node->Parent == INVALID_OFFSET) {
        pSetTreeRoot (GetBinTree (TreeOffset), newRootOffset);
    } else {
        if (parent->Left == nodeOffset) {
            parent->Left = newRootOffset;
        } else {
            parent->Right = newRootOffset;
        }
    }

    newRoot->Right = nodeOffset;
    Node->Parent = newRootOffset;

    pBinTreeNodeBalance (Node, TreeOffset);
    pBinTreeNodeBalance (newRoot, TreeOffset);

}


BOOL
BinTreeSetInsertionOrdered (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeSetInsertionOrdered transforms a binary tree into an
  insertion-ordered link list.

Arguments:

  TreeOffset - Specifies the binary tree to make insertion-ordered

Return Value:

  TRUE if the tree was changed, FALSE if TreeOffset is not valid.

--*/

{
    PBINTREE tree;
    PNODESTRUCT node;
    PNODESTRUCT root;
    PNODESTRUCT header;
    PLISTELEM elem;
    PLISTELEM prevElem;
    UINT headerOffset;
    UINT offset;
    UINT nodeOffset;
    PBYTE buf;

    if (TreeOffset == INVALID_OFFSET) {
        return FALSE;
    }

    //
    // This is to test if allocations move buffer
    //
    buf = g_CurrentDatabase->Buf;

    tree = GetBinTree (TreeOffset);
    root = GetNodeStruct (tree->Root);

    if (root && root->InsertionHead) {
        return TRUE;
    }

    header = pBinTreeAllocNode (&headerOffset);

    if (buf != g_CurrentDatabase->Buf) {
        PTR_WAS_INVALIDATED(tree);
        PTR_WAS_INVALIDATED(root);

        tree = GetBinTree (TreeOffset);
        root = GetNodeStruct (tree->Root);
        buf = g_CurrentDatabase->Buf;
    }

    INCTREENODES(tree);

    header->InsertionOrdered = TRUE;
    header->InsertionHead = TRUE;
    header->Data = tree->Root;
    header->Head = INVALID_OFFSET;
    header->Tail = INVALID_OFFSET;
    header->Parent = INVALID_OFFSET;
    tree->Root = headerOffset;

    if (root) {
        //
        // There is at least one node in tree, so create LISTELEMs
        //

        node = pBinTreeEnumFirst (tree);

        do {
            nodeOffset = GetNodeOffset (node);

            elem = pBinTreeAllocListElem (&offset);

            if (buf != g_CurrentDatabase->Buf) {
                PTR_WAS_INVALIDATED(tree);
                PTR_WAS_INVALIDATED(root);
                PTR_WAS_INVALIDATED(header);
                PTR_WAS_INVALIDATED(node);

                tree = GetBinTree (TreeOffset);
                header = GetNodeStruct (headerOffset);
                node = GetNodeStruct (nodeOffset);

                buf = g_CurrentDatabase->Buf;
            }

            INCTREEELEMS(tree);

            //
            // Update header element pointers
            //
            if (header->Head == INVALID_OFFSET) {
                header->Head = offset;
            }

            if (header->Tail != INVALID_OFFSET) {
                prevElem = GetListElem (header->Tail);
                prevElem->Next = offset;
            }

            header->Tail = offset;

            //
            // Set new LISTELEM members, and corresponding node members
            //

            elem->Data = node->Data;
            elem->Node = nodeOffset;
            elem->Next = INVALID_OFFSET;
            node->Data = offset;

            node->InsertionOrdered = 1;

            node = pBinTreeEnumNext (node);

        } while (node);
    }

    return TRUE;
}


UINT
pBinTreeSize (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeSize computes the number of nodes indicated by Node and all of its
  children.

Arguments:

  Node - Specifies the node to find the size of.

Return Value:

  The number of nodes represented by Node and its children.

--*/

{
    if (!Node) {
        return 0;
    }

    return (pBinTreeSize (GetNodeStruct (Node->Left)) ? 1 : 0) +
           (pBinTreeSize (GetNodeStruct (Node->Right)) ? 1 : 0) + 1;
}


UINT
BinTreeSize (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeSize returns the total number of nodes in the specified binary tree

Arguments:

  TreeOffset - Specifies the offset to the binary tree

Return Value:

  The number of nodes in the binary tree

--*/

{
    PBINTREE tree;

    if (TreeOffset == INVALID_OFFSET) {
        return 0;
    }

    tree = GetBinTree (TreeOffset);

    return pBinTreeSize (GetTreeRoot (tree));
}

#ifdef DEBUG


INT
pBinTreeMaxDepth (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeMaxDepth returns the number of nodes in the longest path. This
  function is used to find out how deep the tree is.

  This routine is recursive.

Arguments:

  Node - Specifies the node to compute the depth of.

Return Value:

  The number of nodes in the deepest path.

--*/

{
    INT leftDepth, rightDepth;

    if (Node == NULL) {
        return 0;
    }

    leftDepth = pBinTreeMaxDepth (GetNodeStruct (Node->Left));
    rightDepth = pBinTreeMaxDepth (GetNodeStruct (Node->Right));

    return MAX (leftDepth, rightDepth) + 1;
}


INT
BinTreeMaxDepth (
    UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeMaxDepth returns the total depth of the specified tree

Arguments:

  TreeOffset - Specifies the tree to compute the depth of

Return Value:

  The depth of the tree (in levels)

--*/

{
    PBINTREE tree;

    if (TreeOffset == INVALID_OFFSET) {
        return 0;
    }

    tree = GetBinTree (TreeOffset);

    return pBinTreeMaxDepth (GetTreeRoot (tree));
}


BOOL
pBinTreeCheckBalanceOfNode (
    IN      PNODESTRUCT Node,
    OUT     PINT Depth
    )

/*++

Routine Description:

  pBinTreeCheckBalanceOfNode verifies Node is balanced, and all of its
  children are also balanced.

  This function is recursive.

Arguments:

  Node - Specifies the node to check
  Depth - Receives the depth of the node

Return Value:

  TRUE if the node is balanced, FALSE otherwise

--*/

{
    INT lDepth = 0;
    INT rDepth = 0;
    BOOL flag = TRUE;

    if (!Node) {
        if (Depth) {
            *Depth = 0;
        }

        return TRUE;
    }

    flag = flag && pBinTreeCheckBalanceOfNode (GetNodeStruct (Node->Left), &lDepth);
    MYASSERT (flag);

    flag = flag && pBinTreeCheckBalanceOfNode (GetNodeStruct (Node->Right), &rDepth);
    MYASSERT (flag);

    flag = flag && ((INT) Node->LeftDepth == lDepth);
    MYASSERT (flag);

    flag = flag && ((INT) Node->RightDepth == rDepth);
    MYASSERT (flag);

    if (Depth != NULL) {
        *Depth = MAX (lDepth, rDepth) + 1;
    }

    flag = flag && (ABS ((lDepth - rDepth)) <= 1);
    MYASSERT (flag);

    return flag;
}


BOOL
pBinTreeCheckBalance (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeCheckBalance checks the balance of Node

Arguments:

  Node - Specifies the node to check the balance of

Return Value:

  TRUE if Node is balanced, FALSE otherwise.

--*/

{
    return pBinTreeCheckBalanceOfNode (Node, NULL);
}


BOOL
pBinTreeCheck (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeCheck checks if the binary tree is sorted and linked properly.  It
  enumerates the binary tree structure and compares the strings for proper
  order. If the tree is sorted properly, then the balance is checked.

Arguments:

  Tree - Specifies the tree to check

Return Value:

  TRUE if the binary tree is correct, FALSE otherwise.

--*/

{
    BOOL flag;
    PNODESTRUCT cur;
    PNODESTRUCT prev;

    prev = pBinTreeEnumFirst (Tree);

    if (Tree) {

        cur = pBinTreeEnumNext (prev);

        while (cur) {

            flag = (StringPasICompare (GetNodeDataStr(prev), GetNodeDataStr(cur)) < 0);
            MYASSERT(flag);

            if (!flag) {
                return FALSE;
            }

            prev = cur;
            cur = pBinTreeEnumNext (prev);
        }
    }

    return pBinTreeCheckBalance (GetTreeRoot (Tree));
}


BOOL
BinTreeCheck (
    UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeCheck makes sure the specified binary tree is sorted and balanced
  properly

Arguments:

  TreeOffset - Specifies the offset of the tree to check

Return Value:

  TRUE if the tree is sorted properly, FALSE otherwise.

--*/

{
    PBINTREE tree;

    tree = GetBinTree (TreeOffset);

    return pBinTreeCheck (tree);
}





#include <stdio.h>
#include <math.h>

void indent (
    IN      UINT size)
{
    UINT i;
    for (i = 0; i < size; i++)
        wprintf (L" ");
}

INT turn (
    IN      UINT num,
    IN      UINT sel,
    IN      UINT width
    )
{
    UINT temp = num;

    MYASSERT (width > sel);

    if ((temp >> (width-sel-1)) & 1)
        return 1;
    else
        return -1;
}

#define SCREENWIDTH     64

void BinTreePrint(UINT TreeOffset)
{
    PNODESTRUCT cur;
    UINT i,j;
    UINT level=0;
    UINT numnodes,spacing;
    BOOL printed;
    PBINTREE tree;
    PWSTR str;
    UINT strsize,stringlen;
    tree = GetBinTree(TreeOffset);

    if (!GetTreeRoot(tree)) return;

    while (level<31)
    {
        printed=FALSE;

        if (level == 0) {
            numnodes = 1;
        } else {
            numnodes = (UINT)pow ((double)2, (double)level);
        }

        spacing=SCREENWIDTH / numnodes;

        for (i=0;i<numnodes;i++)
        {
            cur = GetTreeRoot(tree);
            j=0;
            while (j<level && cur!=NULL)
            {
                if (turn(i,j,level)<0)
                    cur = GetNodeStruct(cur->Left);
                else
                    cur = GetNodeStruct(cur->Right);
                j++;
            }

            if (cur==NULL) {
                indent(spacing);
            } else {
                str=GetNodeDataStr(cur);
                strsize=StringPasCharCount(str);
                StringPasConvertFrom(str);
                printed=TRUE;
                if (cur->LeftDepth==0 && cur->RightDepth==0) {
                    stringlen=strsize+1;
                    indent((spacing-stringlen)/2);
                    wprintf(L"%s ",str);
                } else {
                    stringlen=strsize+2;
                    indent((spacing-stringlen)/2);
                    wprintf(L"%s%1d%1d",str,cur->LeftDepth,cur->RightDepth);
                }
                indent(spacing-((spacing-stringlen)/2)-stringlen);
                StringPasConvertTo(str);
            }
        }

        wprintf(L"\n");
        if (!printed)
            break;
        level++;
    }
}



UINT BinTreeGetSizeOfStruct(DWORD Signature)
{
    switch (Signature)
    {
    case NODESTRUCT_SIGNATURE:
        return NODESTRUCT_SIZE;
    case BINTREE_SIGNATURE:
        return BINTREE_SIZE;
    case LISTELEM_SIGNATURE:
        return LISTELEM_SIZE;
    default:
        return 0;
    }
}


BOOL pBinTreeFindTreeInDatabase(UINT TreeOffset)
{
    PBINTREE Tree;

    if (!g_UseDebugStructs) {
        return TRUE;
    }
    if (TreeOffset==INVALID_OFFSET)
        return FALSE;

    Tree=GetBinTree(TreeOffset);

    if (Tree->Deleted) {
        return TRUE;
    }

    if (!GetTreeRoot(Tree)) {
        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Binary tree at offset 0x%08lX is Empty!",
            TreeOffset
            ));
        return FALSE;
    }

    return BinTreeFindStructInDatabase(NODESTRUCT_SIGNATURE, GetNodeOffset(GetTreeRoot(Tree)));
}

BOOL pBinTreeFindNodeInDatabase(UINT NodeOffset)
{
    UINT Index;
    PNODESTRUCT Node;

    if (!g_UseDebugStructs) {
        return TRUE;
    }
    if (NodeOffset == INVALID_OFFSET)
        return FALSE;

    Node=GetNodeStruct(NodeOffset);
    if (Node->Deleted || Node->InsertionHead) {
        return TRUE;
    }

    Index = GetNodeData(Node);

    if (Index==INVALID_OFFSET) {

        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Data of Node at offset 0x%8lX is Invalid!",
            NodeOffset
            ));
        return FALSE;
    }

    return FindKeyStructInDatabase(KeyIndexToOffset(Index));
}


BOOL BinTreeFindStructInDatabase(DWORD Sig, UINT Offset)
{
    switch (Sig)
    {
    case NODESTRUCT_SIGNATURE:
        return (pBinTreeFindNodeInDatabase(Offset));
    case BINTREE_SIGNATURE:
        return (pBinTreeFindTreeInDatabase(Offset));
    case LISTELEM_SIGNATURE:
        return TRUE;
    default:
        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Invalid BinTree Struct!"
            ));
        printf("Invalid BinTree struct!\n");
    }
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\bintree.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bintree.h

Abstract:

    Routines that manage the binary trees in the memdb database

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999


--*/


//
// all string arguments for BinTree functions must
// be Pascal-style strings (use StringPas...() functions
// defined in pastring.c).
//




//
// returns offset of binary tree
// OffsetOfString is the offset in bytes in the data structure
// of the string used to order the different nodes
//
UINT BinTreeNew();

//
// returns INVALID_OFFSET if node already exists,
// or offset of NODESTRUCT if add went okay
//
BOOL BinTreeAddNode(UINT TreeOffset, UINT data);

//
// removes node and returns offset of data
//
UINT BinTreeDeleteNode(UINT TreeOffset, PCWSTR str, PBOOL LastNode);

//
// returns pointer to data
//
UINT BinTreeFindNode(UINT TreeOffset, PCWSTR str);

//
// destroys and deallocates tree (but not data contained inside)
//
void BinTreeDestroy(UINT TreeOffset);

//
// enumerate first node in tree.  this takes the offset of
// the BINTREE struct and a pointer to a UINT which will
// hold data for BinTreeEnumNext.
//
UINT BinTreeEnumFirst(UINT TreeOffset, PUINT pEnum);

//
// pEnum is the enumerator filled by BinTreeEnumFirst
//
UINT BinTreeEnumNext(PUINT pEnum);

//
// turns the binary tree to insertion order - can only be
// done if the binary tree contains 0 or 1 nodes.  return
// TRUE if conversion is successful, or if binary tree is
// already in Insertion-Ordered mode.
//
BOOL BinTreeSetInsertionOrdered(UINT TreeOffset);



//
// number of nodes in tree
//
UINT BinTreeSize(UINT TreeOffset);



#ifdef DEBUG

//
// maximum depth of tree
//
int BinTreeMaxDepth(UINT TreeOffset);

//
// displays tree.  strsize is length of strings to display
//
void BinTreePrint(UINT TreeOffset);

//
// checks to make sure tree is valid and good
//
BOOL BinTreeCheck(UINT TreeOffset);

#else

#define BinTreePrint(a)
#define BinTreeCheck(a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\keydata.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keydata.c

Abstract:

    Routines that manage data for the memdb key structures.

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"






//
// KeyStruct Data Functions
//


BOOL
KeyStructSetValue (
    IN      UINT KeyIndex,
    IN      UINT Value
    )

/*++

Routine Description:

  sets the value for a key

Arguments:

  KeyIndex - index of key
  Value - value to put in key

Return Value:

  TRUE if successful

--*/

{
    PKEYSTRUCT KeyStruct;

    KeyStruct = GetKeyStruct(KeyIndex);
    MYASSERT(KeyStruct);

    KeyStruct->Value = Value;

    KeyStruct->DataFlags |= DATAFLAG_VALUE;

    return TRUE;
}

BOOL
KeyStructSetFlags (
    IN      UINT KeyIndex,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  sets the flags for a key

Arguments:

  KeyIndex      - index of key
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PKEYSTRUCT KeyStruct;

    KeyStruct = GetKeyStruct(KeyIndex);
    MYASSERT(KeyStruct);

    if (KeyStruct->DataFlags & DATAFLAG_FLAGS) {
        if (ReplaceFlags) {
            KeyStruct->Flags = SetFlags;
        } else {
            KeyStruct->Flags &= ~ClearFlags;
            KeyStruct->Flags |= SetFlags;
        }
    } else {
        KeyStruct->Flags = SetFlags;
        KeyStruct->DataFlags |= DATAFLAG_FLAGS;
    }
    return TRUE;
}

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e794

UINT g_TotalData = 0;

UINT
pAllocateNewDataStruct (
    IN      UINT DataSize,
	IN		UINT AltDataSize
    )

/*++

Routine Description:

  pAllocateNewDataStruct allocates a block of memory in the single
  heap, for holding a data structure.

Arguments:

  DataSize       - Size of the binary data that needs to be stored here

Return Value:

  An Index to the new structure.

--*/

{
    UINT size;
    PKEYSTRUCT keyStruct = NULL;
    UINT offset;
    UINT prevDel;
    UINT result;

	size = DataSize + KEYSTRUCT_SIZE;

    //
    // Look for free block
    //
    prevDel = INVALID_OFFSET;
    offset = g_CurrentDatabase->FirstKeyDeleted;

    while (offset != INVALID_OFFSET) {
        keyStruct = GetKeyStructFromOffset (offset);
        MYASSERT (keyStruct);
        if ((keyStruct->Size >= size) && (keyStruct->Size < (size + ALLOC_TOLERANCE))) {
            break;
        }

        prevDel = offset;
        offset = keyStruct->NextDeleted;
    }

    if (offset == INVALID_OFFSET) {
        //
        // We could not find one so we need to allocate a new block
        //
		g_TotalData ++;

        offset = DatabaseAllocBlock (size + AltDataSize);

#ifdef DEBUG
        //
        // if we are in debug mode, and we are using debug structs, set
        // pointer normally and set Signature DWORD.  if we are not using
        // debug structs, then set pointer to 4 bytes below actual offset,
        // so all members are shifted down.
        //
        if (g_UseDebugStructs) {
            keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR (offset);
            keyStruct->Signature = KEYSTRUCT_SIGNATURE;
        } else {
            keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR (offset - KEYSTRUCT_HEADER_SIZE);
        }
#else
        keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(offset);
#endif

        keyStruct->Size = size + AltDataSize;
    } else {
        //
        // Delink free block if recovering free space
        //
        if (prevDel != INVALID_OFFSET) {
            GetKeyStructFromOffset (prevDel)->NextDeleted = keyStruct->NextDeleted;
        } else {
            g_CurrentDatabase->FirstKeyDeleted = keyStruct->NextDeleted;
        }
#ifdef DEBUG
        keyStruct->KeyFlags &= ~KSF_DELETED;
#endif
    }

    //
    // Init new block
    //
    keyStruct->DataSize = DataSize;
    keyStruct->DataStructIndex = INVALID_OFFSET;
    keyStruct->NextLevelTree = INVALID_OFFSET;
    keyStruct->PrevLevelIndex = INVALID_OFFSET;
    keyStruct->Flags = 0;
    keyStruct->KeyFlags = KSF_DATABLOCK;
    keyStruct->DataFlags = 0;

    result = AddKeyOffsetToBuffer (offset);

    return result;
}
//lint -restore

UINT
KeyStructAddBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructAddBinaryData adds a certain type of binary data to a key
  if it doesn't exist yet. If it does, the function fails.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data handle if successfull, INVALID_OFFSET otherwise.

--*/

{
    PKEYSTRUCT prevStruct,dataStruct,nextStruct,keyStruct;
    UINT dataIndex, prevIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevIndex = KeyIndex;
    prevStruct = keyStruct;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        prevIndex = dataIndex;
        prevStruct = dataStruct;
        dataIndex = dataStruct->DataStructIndex;
    }

    if (found) {
        return INVALID_OFFSET;
    }

    dataIndex = pAllocateNewDataStruct (DataSize, 0);

    if (dataIndex == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);
    prevStruct = GetKeyStruct (prevIndex);
    MYASSERT (prevStruct);

    dataStruct = GetKeyStruct (dataIndex);
    MYASSERT (dataStruct);

    keyStruct->DataFlags |= Type;
    dataStruct->DataFlags |= Type;
    dataStruct->DataFlags |= Instance;
    CopyMemory (dataStruct->Data, Data, DataSize);

    dataStruct->DataStructIndex = prevStruct->DataStructIndex;
    dataStruct->PrevLevelIndex = prevIndex;
    prevStruct->DataStructIndex = dataIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = dataIndex;
    }

    return dataIndex;
}

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
UINT
KeyStructGrowBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructGrowBinaryData appends a certain type of binary data to a key
  if it does exist. If it doesn't, the new data is added.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data handle if successfull, INVALID_OFFSET otherwise.

--*/

{
    PKEYSTRUCT prevStruct;
    PKEYSTRUCT dataStruct;
    PKEYSTRUCT keyStruct;
    PKEYSTRUCT nextStruct;
    PKEYSTRUCT newStruct;
    UINT dataIndex;
    UINT newIndex;
    UINT prevIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevStruct = keyStruct;
    prevIndex = KeyIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        prevStruct = dataStruct;
        prevIndex = dataIndex;
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return KeyStructAddBinaryData (KeyIndex, Type, Instance, Data, DataSize);
    }

	if (dataStruct->Size >= KEYSTRUCT_SIZE + DataSize + dataStruct->DataSize) {

		CopyMemory (dataStruct->Data + dataStruct->DataSize, Data, DataSize);
		dataStruct->DataSize += DataSize;
		return dataIndex;

	} else {

		newIndex = pAllocateNewDataStruct (DataSize + dataStruct->DataSize, 1024);

		if (newIndex == INVALID_OFFSET) {
			return INVALID_OFFSET;
		}

		// now we need to reget all keystructs used so far because the database
		// might have moved
		keyStruct = GetKeyStruct (KeyIndex);
		MYASSERT (keyStruct);
		dataStruct = GetKeyStruct (dataIndex);
		MYASSERT (dataStruct);
		prevStruct = GetKeyStruct (prevIndex);
		MYASSERT (prevStruct);

		newStruct = GetKeyStruct (newIndex);
		MYASSERT (newStruct);

		newStruct->DataSize = dataStruct->DataSize + DataSize;
		newStruct->DataFlags = dataStruct->DataFlags;
		newStruct->DataStructIndex = dataStruct->DataStructIndex;
		newStruct->PrevLevelIndex = dataStruct->PrevLevelIndex;
		CopyMemory (newStruct->Data, dataStruct->Data, dataStruct->DataSize);
		CopyMemory (newStruct->Data + dataStruct->DataSize, Data, DataSize);

		prevStruct->DataStructIndex = newIndex;

		if (newStruct->DataStructIndex != INVALID_OFFSET) {
			nextStruct = GetKeyStruct (newStruct->DataStructIndex);
			MYASSERT (nextStruct);
			nextStruct->PrevLevelIndex = newIndex;
		}

		// now simply remove the block
		//
		// Donate block to free space
		//

		dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
		g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (dataIndex);
#ifdef DEBUG
		dataStruct->KeyFlags |= KSF_DELETED;
#endif
		RemoveKeyOffsetFromBuffer (dataIndex);

		return newIndex;
	}
}
//lint -restore

UINT
KeyStructGrowBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructGrowBinaryDataByIndex appends a certain type of binary data to
  an existing structure identified by OldIndex. The old structure is
  deleted and a new one is allocated holding both old and new data.

Arguments:

  OldIndex  - index of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data index if successfull, INVALID_OFFSET otherwise.

--*/

{
    UINT newIndex;
    PKEYSTRUCT oldStruct, newStruct, prevStruct, nextStruct;

    oldStruct = GetKeyStruct (OldIndex);
    MYASSERT (oldStruct);

	if (oldStruct->Size >= KEYSTRUCT_SIZE + DataSize + oldStruct->DataSize) {

		CopyMemory (oldStruct->Data + oldStruct->DataSize, Data, DataSize);
		oldStruct->DataSize += DataSize;
		return OldIndex;

	} else {

		newIndex = pAllocateNewDataStruct (DataSize + oldStruct->DataSize, 1024);

		if (newIndex == INVALID_OFFSET) {
			return INVALID_OFFSET;
		}

		// now we need to reget all keystructs used so far because the database
		// might have moved
		oldStruct = GetKeyStruct (OldIndex);
		MYASSERT (oldStruct);

		newStruct = GetKeyStruct (newIndex);
		MYASSERT (newStruct);

		newStruct->DataStructIndex = oldStruct->DataStructIndex;
		newStruct->PrevLevelIndex = oldStruct->PrevLevelIndex;
		newStruct->DataFlags = oldStruct->DataFlags;
		CopyMemory (newStruct->Data, oldStruct->Data, oldStruct->DataSize);
		CopyMemory (newStruct->Data + oldStruct->DataSize, Data, DataSize);

		prevStruct = GetKeyStruct (newStruct->PrevLevelIndex);
		MYASSERT (prevStruct);
		prevStruct->DataStructIndex = newIndex;

		if (newStruct->DataStructIndex != INVALID_OFFSET) {
			nextStruct = GetKeyStruct (newStruct->DataStructIndex);
			MYASSERT (nextStruct);
			nextStruct->PrevLevelIndex = newIndex;
		}

		// now simply remove the block
		//
		// Donate block to free space
		//

		oldStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
		g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (OldIndex);
#ifdef DEBUG
		oldStruct->KeyFlags |= KSF_DELETED;
#endif
		RemoveKeyOffsetFromBuffer (OldIndex);

		return newIndex;
	}
}

// LINT - in the next function prevstruct is thought to be possibly not initialized.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
BOOL
KeyStructDeleteBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  KeyStructDeleteBinaryData deletes a certain type of binary data from a key
  if it exists. If it doesn't, the function will simply return success.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data

Return Value:

  TRUE if successfull, FALSE if not.

--*/

{
    PKEYSTRUCT prevStruct, nextStruct, dataStruct, keyStruct;
    UINT dataIndex, prevIndex;
    BOOL found = FALSE;
    UINT typeInstances = 0;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        // no such type of data, exiting
        return TRUE;
    }

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevIndex = KeyIndex;
    prevStruct = keyStruct;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if ((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) {
            typeInstances ++;
            if ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance) {
                found = TRUE;
                //
                // now let's see if we have more instances of this binary type
                //
                if (dataStruct->DataStructIndex != INVALID_OFFSET) {
                    nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
                    if ((nextStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) {
                        typeInstances ++;
                    }
                }
                break;
            } else if ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance) {
                break;
            }
        } else if ((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) {
            break;
        }
        prevIndex = dataIndex;
        prevStruct = dataStruct;
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return TRUE;
    }

    // remove the linkage
    prevStruct->DataStructIndex = dataStruct->DataStructIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = prevIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (dataIndex);
#ifdef DEBUG
    dataStruct->KeyFlags |= KSF_DELETED;
#endif
    RemoveKeyOffsetFromBuffer (dataIndex);

    //
    // finally, fix the keystruct if this was the only instance of this type
    //
    MYASSERT (typeInstances >= 1);
    if (typeInstances == 1) {
        keyStruct->DataFlags &= ~Type;
    }

    return TRUE;
}
//lint -restore

BOOL
KeyStructDeleteBinaryDataByIndex (
    IN      UINT DataIndex
    )

/*++

Routine Description:

  KeyStructDeleteBinaryDataByIndex deletes a certain type of binary data from a key.

Arguments:

  DataIndex  - index of data

Return Value:

  TRUE if successfull, FALSE if not.

--*/

{
    PKEYSTRUCT prevStruct, nextStruct, dataStruct, keyStruct;
    BYTE type = 0;
    UINT typeInstances = 0;

    dataStruct = GetKeyStruct (DataIndex);
    MYASSERT (dataStruct);
    type = dataStruct->DataFlags & DATAFLAG_BINARYMASK;
    typeInstances ++;

    prevStruct = GetKeyStruct (dataStruct->PrevLevelIndex);
    MYASSERT (prevStruct);
    if ((prevStruct->DataFlags & DATAFLAG_BINARYMASK) == type) {
        typeInstances ++;
    }
    prevStruct->DataStructIndex = dataStruct->DataStructIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        if ((nextStruct->DataFlags & DATAFLAG_BINARYMASK) == type) {
            typeInstances ++;
        }
        nextStruct->PrevLevelIndex = dataStruct->PrevLevelIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (DataIndex);
#ifdef DEBUG
    dataStruct->KeyFlags |= KSF_DELETED;
#endif
    RemoveKeyOffsetFromBuffer (DataIndex);

    //
    // finally, fix the keystruct if this was the only instance of this type
    //
    MYASSERT (typeInstances >= 1);
    if (typeInstances == 1) {
        // first we need to find the key starting with the current database struct
        keyStruct = dataStruct;
        while (keyStruct->KeyFlags & KSF_DATABLOCK) {
            // still a datablock
            if (keyStruct->PrevLevelIndex == INVALID_OFFSET) {
                // something is wrong, the first level is a datablock??
                break;
            }
            keyStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
            MYASSERT (keyStruct);
        }
        if (!(keyStruct->KeyFlags & KSF_DATABLOCK)) {
            keyStruct->DataFlags &= ~type;
        }
    }

    return TRUE;
}

UINT
KeyStructReplaceBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )
{
    UINT newIndex;
    PKEYSTRUCT oldStruct, newStruct, prevStruct, nextStruct;

    // BUGBUG - optimize this by keeping the current structure is big enough.

	newIndex = pAllocateNewDataStruct (DataSize, 0);

    if (newIndex == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    oldStruct = GetKeyStruct (OldIndex);
    MYASSERT (oldStruct);

    newStruct = GetKeyStruct (newIndex);
    MYASSERT (newStruct);

    newStruct->DataStructIndex = oldStruct->DataStructIndex;
    newStruct->PrevLevelIndex = oldStruct->PrevLevelIndex;
    newStruct->DataFlags = oldStruct->DataFlags;
    CopyMemory (newStruct->Data, Data, DataSize);

    prevStruct = GetKeyStruct (newStruct->PrevLevelIndex);
    MYASSERT (prevStruct);
    prevStruct->DataStructIndex = newIndex;

    if (newStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (newStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = newIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    oldStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (OldIndex);
#ifdef DEBUG
    oldStruct->KeyFlags |= KSF_DELETED;
#endif
    RemoveKeyOffsetFromBuffer (OldIndex);

    return newIndex;
}

// LINT - in the next function prevstruct is thought to be possibly not initialized.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
PBYTE
KeyStructGetBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize
    )
{
    PKEYSTRUCT dataStruct,keyStruct;
    UINT dataIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        return NULL;
    }

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return NULL;
    }

    if (DataSize) {
        *DataSize = dataStruct->DataSize;
    }

    return dataStruct->Data;
}
//lint -restore

PBYTE
KeyStructGetBinaryDataByIndex (
    IN      UINT DataIndex,
    OUT     PUINT DataSize
    )
{
    PKEYSTRUCT dataStruct;

    dataStruct = GetKeyStruct (DataIndex);
    MYASSERT (dataStruct);

    if (DataSize) {
        *DataSize = dataStruct->DataSize;
    }

    return dataStruct->Data;
}

UINT
KeyStructGetDataIndex (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  KeyStructGetDataIndex looks for a certain type of data and returns it's index
  if it exists. If it doesn't, the function will simply return INVALID_OFFSET.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data

Return Value:

  A data index if successfull, INVALID_OFFSET if not.

--*/

{
    PKEYSTRUCT keyStruct, dataStruct;
    UINT dataIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        return INVALID_OFFSET;
    }

    // check to see if we have the data there
    dataIndex = keyStruct->DataStructIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        dataIndex = dataStruct->DataStructIndex;
    }
    if (!found) {
        return INVALID_OFFSET;
    }
    return dataIndex;
}

DATAHANDLE
KeyStructAddLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BOOL toBeAdded = TRUE;
    UINT result = INVALID_OFFSET;
    PUINT linkArray;
    UINT linkSize;

    if (!AllowDuplicates) {
        //
        // check to see if we already have this linkage added
        //
        linkArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &linkSize);

        if (linkArray) {

            while (linkSize >= SIZEOF (UINT)) {

                if (*linkArray == Linkage) {
                    toBeAdded = FALSE;
                    break;
                }

                linkArray ++;
                linkSize -= SIZEOF (UINT);
            }
        }
    }

    if (toBeAdded) {
        result = KeyStructGrowBinaryData (KeyIndex, Type, Instance, (PBYTE)(&Linkage), SIZEOF (UINT));
    } else {
        result = KeyStructGetDataIndex (KeyIndex, Type, Instance);
    }

    return result;
}

DATAHANDLE
KeyStructAddLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BOOL toBeAdded = TRUE;
    UINT result = INVALID_OFFSET;
    PUINT linkArray;
    UINT linkSize;

    if (!AllowDuplicates) {
        //
        // check to see if we already have this linkage added
        //
        linkArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &linkSize);

        if (linkArray) {

            while (linkSize >= SIZEOF (UINT)) {

                if (*linkArray == Linkage) {
                    toBeAdded = FALSE;
                    break;
                }

                linkArray ++;
                linkSize -= SIZEOF (UINT);
            }
        }
    }

    if (toBeAdded) {
        result = KeyStructGrowBinaryDataByIndex (DataIndex, (PBYTE)(&Linkage), SIZEOF (UINT));
    } else {
        result = DataIndex;
    }

    return result;
}

BOOL
KeyStructDeleteLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BOOL checking = TRUE;
    BOOL result = FALSE;
    PUINT srcArray, destArray, newArray;
    UINT srcSize, newSize;

    srcArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &srcSize);

    if (srcArray) {
        newArray = MemDbGetMemory (srcSize);

        if (newArray) {

            destArray = newArray;
            newSize = 0;

            while (srcSize >= SIZEOF (UINT)) {
                if ((*srcArray == Linkage) &&
                    (checking)
                    ) {
                    if (FirstOnly) {
                        checking = FALSE;
                    }
                    srcArray ++;
                    srcSize -= SIZEOF (UINT);
                } else {
                    *destArray = *srcArray;
                    srcSize -= SIZEOF (UINT);
                    newSize += SIZEOF (UINT);
                }
            }

            if (newSize) {
                result = TRUE;
                result = result && KeyStructDeleteBinaryData (KeyIndex, Type, Instance);
                result = result && (KeyStructAddBinaryData (KeyIndex, Type, Instance, (PBYTE)newArray, newSize) != INVALID_OFFSET);
            } else {
                result = KeyStructDeleteBinaryData (KeyIndex, Type, Instance);
            }

            MemDbReleaseMemory (newArray);
        }
    }

    return result;
}

BOOL
KeyStructDeleteLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BOOL checking = TRUE;
    BOOL result = FALSE;
    PUINT srcArray, destArray, newArray;
    UINT srcSize, newSize;

    srcArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &srcSize);

    if (srcArray) {
        newArray = MemDbGetMemory (srcSize);

        if (newArray) {

            destArray = newArray;
            newSize = 0;

            while (srcSize >= SIZEOF (UINT)) {
                if ((*srcArray == Linkage) &&
                    (checking)
                    ) {
                    if (FirstOnly) {
                        checking = FALSE;
                    }
                    srcArray ++;
                    srcSize -= SIZEOF (UINT);
                } else {
                    *destArray = *srcArray;
                    srcSize -= SIZEOF (UINT);
                    newSize += SIZEOF (UINT);
                }
            }

            if (newSize) {
                result = (KeyStructReplaceBinaryDataByIndex (DataIndex, (PBYTE)newArray, newSize) != INVALID_OFFSET);
            } else {
                result = KeyStructDeleteBinaryDataByIndex (DataIndex);
            }

            MemDbReleaseMemory (newArray);
        }
    }

    return result;
}

BOOL
KeyStructTestLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    BOOL result = FALSE;
    PUINT srcArray;
    UINT srcSize = 0;

    srcArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &srcSize);

    while (srcSize >= SIZEOF (KEYHANDLE)) {
        if (*srcArray == Linkage) {
            result = TRUE;
            break;
        }
        srcSize -= SIZEOF (KEYHANDLE);
    }
    return result;
}

BOOL
KeyStructTestLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage
    )
{
    BOOL result = FALSE;
    PUINT srcArray;
    UINT srcSize;

    srcArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &srcSize);

    while (srcSize >= SIZEOF (UINT)) {
        if (*srcArray == Linkage) {
            result = TRUE;
            break;
        }
        srcSize -= SIZEOF (UINT);
    }
    return result;
}

BOOL
KeyStructGetValue (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Value
    )
{
    if (!Value) {
        return TRUE;
    }

    if (!(KeyStruct->DataFlags & DATAFLAG_VALUE)) {
        //
        // there is no value, but we still set output to
        // zero and return TRUE
        //
        *Value = 0;
        return TRUE;
    }
    *Value = KeyStruct->Value;

    return TRUE;
}

BOOL
KeyStructGetFlags (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Flags
    )
{
    if (!Flags) {
        return TRUE;
    }
    if (!(KeyStruct->DataFlags & DATAFLAG_FLAGS)) {
        //
        // there are no flags, but we still set output to
        // zero and return TRUE
        //
        *Flags = 0;
        return TRUE;
    }
    *Flags = KeyStruct->Flags;

    return TRUE;
}



VOID
KeyStructFreeAllData (
    PKEYSTRUCT KeyStruct
    )

/*++

Routine Description:

  KeyStructFreeDataBlock frees a data block and resets the
  the KSF data flags, if the key struct has a data block allocated.

--*/

{
    //BUGBUG - reimplement this
    //KeyStructFreeData (KeyStruct);
    KeyStruct->Value = 0;
    KeyStruct->Flags = 0;
    KeyStruct->DataFlags &= ~DATAFLAG_VALUE;
    KeyStruct->DataFlags &= ~DATAFLAG_FLAGS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\hash.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hashing routines used to speed lookup of memdb keys.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    Jim Schmidt (jimschm) 21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#define DBG_MEMDB       "MemDb"



//
// #defines
//

#define HASH_BUCKETS    7001//4099
#define HASH_BLOCK_SIZE (HASH_BUCKETS * sizeof (BUCKETSTRUCT))
#define HASHBUFPTR(offset) ((PBUCKETSTRUCT) (pHashTable->Buf + offset))






typedef struct _tagHASHSTRUCT {
    UINT Offset;
    UINT NextItem;
} BUCKETSTRUCT, *PBUCKETSTRUCT;

typedef struct {
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    UINT Bucket;
    UINT LastOffset;
} HASHENUM, *PHASHENUM;


BOOL
EnumFirstHashEntry (
    IN      PMEMDBHASH pHashTable,
    OUT     PHASHENUM HashEnum
    );

BOOL
EnumNextHashEntry (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PHASHENUM HashEnum
    );


//
// Local privates
//

VOID
pResetHashBlock (
    IN      PMEMDBHASH pHashTable
    );


//
// Implementation
//

PMEMDBHASH
CreateHashBlock (
    VOID
    )
{
    PMEMDBHASH pHashTable;
    pHashTable = (PMEMDBHASH) MemAlloc (g_hHeap, 0, sizeof(MEMDBHASH));
    if (!pHashTable) {
        DEBUGMSG ((DBG_ERROR, "Could not allocate hash table!\n"));
        return NULL;
    }
    pHashTable->Size = HASH_BLOCK_SIZE * 2;

    pHashTable->Buf = (PBYTE) MemAlloc (g_hHeap, 0, pHashTable->Size);
    if (!pHashTable->Buf) {
        DEBUGMSG ((DBG_ERROR, "Could not allocate hash buffer!\n"));
        MemFree (g_hHeap, 0, pHashTable);
        return NULL;
    }
    pResetHashBlock(pHashTable);

    return pHashTable;
}


VOID
pResetHashBlock (
    IN      PMEMDBHASH pHashTable
    )
{
    PBUCKETSTRUCT BucketPtr;
    INT i;

    pHashTable->End = HASH_BLOCK_SIZE;
    pHashTable->FreeHead = INVALID_OFFSET;

    BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf;
    for (i = 0 ; i < HASH_BUCKETS ; i++) {
        BucketPtr->Offset = INVALID_OFFSET;
        BucketPtr->NextItem = INVALID_OFFSET;
        BucketPtr++;
    }
}


VOID
FreeHashBlock (
    IN      PMEMDBHASH pHashTable
    )
{
    if (pHashTable->Buf) {
        MemFree (g_hHeap, 0, pHashTable->Buf);
    }

    MemFree (g_hHeap, 0, pHashTable);
}


BOOL
EnumFirstHashEntry (
    IN      PMEMDBHASH pHashTable,
    OUT     PHASHENUM EnumPtr
    )
{
    ZeroMemory (EnumPtr, sizeof (HASHENUM));

    return EnumNextHashEntry (pHashTable, EnumPtr);
}


BOOL
EnumNextHashEntry (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PHASHENUM EnumPtr
    )
{
    for (;;) {
        if (EnumPtr->Bucket == HASH_BUCKETS) {
            //
            // The completion case
            //

            return FALSE;
        }

        if (!EnumPtr->BucketPtr) {
            //
            // This case occurs when we are begining to enumerate a bucket
            //

            EnumPtr->BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf + EnumPtr->Bucket;
            if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Return this first item in the bucket
            //

            EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
            return TRUE;
        }

        //
        // This case occurs when we are continuing enumeration of a bucket
        //

        if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
            //
            // Current bucket item (and also the last bucket item) may have
            // been deleted -- check that now
            //

            if (!EnumPtr->PrevBucketPtr) {
                //
                // Last item has been deleted; continue to next bucket
                //

                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Previous bucket item is valid; use it.
            //

            EnumPtr->BucketPtr = EnumPtr->PrevBucketPtr;

        } else {
            //
            // Current bucket item may have been deleted, but another item was
            // moved to its place -- check that now
            //

            if (EnumPtr->BucketPtr->Offset != EnumPtr->LastOffset) {
                EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
                return TRUE;
            }
        }

        //
        // We now know that the current bucket item was not changed, so it
        // becomes our previous item and we move on to the next item (if
        // one exists)
        //

        if (EnumPtr->BucketPtr->NextItem == INVALID_OFFSET) {
            //
            // End of bucket reached
            //

            EnumPtr->BucketPtr = NULL;
            EnumPtr->Bucket += 1;
            continue;
        }

        EnumPtr->PrevBucketPtr = EnumPtr->BucketPtr;
        EnumPtr->BucketPtr = HASHBUFPTR (EnumPtr->BucketPtr->NextItem);


        EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
        MYASSERT(EnumPtr->LastOffset != INVALID_OFFSET);
        break;
    }

    return TRUE;
}



BOOL
WriteHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    )
{
    *(((PUINT)*Buf)++) = pHashTable->End;
    *(((PUINT)*Buf)++) = pHashTable->FreeHead;

    CopyMemory(*Buf, pHashTable->Buf, pHashTable->End);
    *Buf += pHashTable->End;

    return TRUE;
}


BOOL
ReadHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    )
{
    pHashTable->End = *(((PUINT)*Buf)++);
    pHashTable->FreeHead = *(((PUINT)*Buf)++);

    if (pHashTable->End > pHashTable->Size) {
        //
        // if the hash table in the file will not fit in the buffer
        // already allocated, free current buffer and allocate new one.
        //
        MemFree (g_hHeap, 0, pHashTable->Buf);
        pHashTable->Size = pHashTable->End;
        pHashTable->Buf = (PBYTE) MemAlloc (g_hHeap, 0, pHashTable->Size);
    }

    CopyMemory(pHashTable->Buf, *Buf, pHashTable->End);
    *Buf += pHashTable->End;
    return TRUE;
}

UINT GetHashTableBlockSize (
    IN      PMEMDBHASH pHashTable
    )
{
    return 2*sizeof(UINT) + pHashTable->End;
}


UINT
pCalculateHashVal (
    IN      PCWSTR String
    )
{
    UINT Hash = 0;

    while (*String) {
        Hash = (Hash << 3) | (Hash >> 29);
        Hash += towlower (*String);
        String++;
    }

    Hash %= HASH_BUCKETS;

    return Hash;
}

UINT
pAllocBucket (
    IN      PMEMDBHASH pHashTable
    )
{
    UINT rBucketOffset;
    PBYTE TempBuf;
    PBUCKETSTRUCT BucketPtr;

    if (pHashTable->FreeHead != INVALID_OFFSET) {
        rBucketOffset = pHashTable->FreeHead;
        BucketPtr = HASHBUFPTR (rBucketOffset);
        pHashTable->FreeHead = BucketPtr->NextItem;

        MYASSERT (rBucketOffset < pHashTable->End);
    } else {

        if (pHashTable->End + sizeof (BUCKETSTRUCT) > pHashTable->Size) {
            pHashTable->Size += HASH_BLOCK_SIZE;
            TempBuf = MemReAlloc (g_hHeap, 0, pHashTable->Buf, pHashTable->Size);
            DEBUGMSG ((DBG_NAUSEA, "Realloc'd memdb hash table"));

            if (!TempBuf) {
                DEBUGMSG ((DBG_ERROR, "Out of memory!"));
                pHashTable->Size -= HASH_BLOCK_SIZE;
                return INVALID_OFFSET;
            }

            pHashTable->Buf = TempBuf;
        }

        rBucketOffset = pHashTable->End;
        pHashTable->End += sizeof (BUCKETSTRUCT);

        BucketPtr = HASHBUFPTR (rBucketOffset);
    }

    BucketPtr->Offset = INVALID_OFFSET;
    BucketPtr->NextItem = INVALID_OFFSET;

    return rBucketOffset;
}


BOOL
AddHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    IN      UINT Offset
    )
{
    UINT Bucket;
    PBUCKETSTRUCT BucketPtr, PrevBucketPtr;
    UINT BucketOffset;
    UINT NewOffset;
    UINT PrevBucketOffset;

    Bucket = pCalculateHashVal (FullString);
    BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf + Bucket;

    //
    // See if root bucket item has been used or not
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        //
        // Yes - add to end of the chain
        //

        BucketOffset = Bucket * sizeof (BUCKETSTRUCT);
        do {
            BucketPtr = HASHBUFPTR (BucketOffset);
            PrevBucketOffset = BucketOffset;
            BucketOffset = BucketPtr->NextItem;
        } while (BucketOffset != INVALID_OFFSET);


        //
        // Add to the chain
        //

        NewOffset = pAllocBucket(pHashTable);
        PrevBucketPtr = HASHBUFPTR (PrevBucketOffset);
        PrevBucketPtr->NextItem = NewOffset;

        if (NewOffset == INVALID_OFFSET) {
            return FALSE;
        }

        BucketPtr = HASHBUFPTR (NewOffset);
        MYASSERT (BucketPtr->NextItem == INVALID_OFFSET);
    }

    BucketPtr->Offset = Offset;

#ifdef DEBUG
    {
        UINT HashOffset;

        HashOffset = FindStringInHashTable (pHashTable, FullString);
        MYASSERT (HashOffset != INVALID_OFFSET);
        DEBUGMSG_IF ((HashOffset != Offset, DBG_MEMDB, "Duplicate in hash table: %s", FullString));
    }
#endif

    return TRUE;
}


PBUCKETSTRUCT
pFindBucketItemInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    OUT     PBUCKETSTRUCT *PrevBucketPtr,       OPTIONAL
    OUT     PUINT HashOffsetPtr                 OPTIONAL
    )
{
    UINT Bucket;
    UINT BucketOffset;
    PBUCKETSTRUCT BucketPtr = NULL;
    WCHAR TempStr[MEMDB_MAX];

    Bucket = pCalculateHashVal (FullString);
    BucketOffset = Bucket * sizeof (BUCKETSTRUCT);

#ifdef DEBUG
    {
        //
        // Circular link check
        //

        UINT Prev, Next;
        UINT Turtle, Rabbit;
        BOOL Even = FALSE;

        Rabbit = BucketOffset;
        Turtle = Rabbit;
        while (Rabbit != INVALID_OFFSET) {
            // Make rabbit point to next item in chain
            Prev = Rabbit;
            BucketPtr = HASHBUFPTR (Rabbit);
            Rabbit = BucketPtr->NextItem;

            // We should always be ahead of the turtle
            if (Rabbit == Turtle) {
                BucketPtr = HASHBUFPTR (Rabbit);
                Next = BucketPtr->NextItem;
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Circular link detected in memdb hash table!  Turtle=%u, Rabbit=%u, Next=%u, Prev=%u",
                    Turtle,
                    Rabbit,
                    Next,
                    Prev
                    ));

                return NULL;
            }

            // Make turtle point to next item in chain (1 of every 2 passes)
            if (Even) {
                BucketPtr = HASHBUFPTR (Turtle);
                Turtle = BucketPtr->NextItem;
            }

            Even = !Even;
        }
    }
#endif

    BucketPtr = HASHBUFPTR (BucketOffset);

    if (PrevBucketPtr) {
        *PrevBucketPtr = BucketPtr;
    }

    //
    // If root bucket is not empty, scan bucket for FullString
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        do  {

            BucketPtr = HASHBUFPTR (BucketOffset);
            //
            // Build string using offset
            //

            PrivateBuildKeyFromIndex (
                0,
                BucketPtr->Offset,
                TempStr,
                NULL,
                NULL,
                NULL
                );

            //
            // Do compare and return if match is found
            //

            if (StringIMatchW (FullString, TempStr)) {
                if (HashOffsetPtr) {
                    *HashOffsetPtr = BucketOffset;
                }
                return BucketPtr;
            }


            if (PrevBucketPtr) {
                *PrevBucketPtr = BucketPtr;
            }

            BucketOffset = BucketPtr->NextItem;

        } while (BucketOffset != INVALID_OFFSET);
    }

    return NULL;
}


UINT
FindStringInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    )
{
    PBUCKETSTRUCT BucketPtr;

    BucketPtr = pFindBucketItemInHashTable (pHashTable, FullString, NULL, NULL);
    if (BucketPtr) {
        return BucketPtr->Offset;
    }

    return INVALID_OFFSET;
}


BOOL
RemoveHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    )
{
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    UINT NextOffset;
    PBUCKETSTRUCT NextBucketPtr;
    UINT BucketOffset;

    BucketPtr = pFindBucketItemInHashTable (pHashTable, FullString, &PrevBucketPtr, &BucketOffset);
    if (!BucketPtr) {
        return FALSE;
    }

    if (PrevBucketPtr != BucketPtr) {
        //
        // If not at the first level (prev != current), give the block
        // to free space.
        //

        PrevBucketPtr->NextItem = BucketPtr->NextItem;
        BucketPtr->NextItem = pHashTable->FreeHead;
        BucketPtr->Offset = INVALID_OFFSET;
        pHashTable->FreeHead = BucketOffset;

    } else {

        //
        // Invalidate next item pointer if at the first level
        //

        if (BucketPtr->NextItem != INVALID_OFFSET) {
            //
            // Copy next item to root array
            //

            NextOffset = BucketPtr->NextItem;
            NextBucketPtr = HASHBUFPTR (NextOffset);
            CopyMemory (BucketPtr, NextBucketPtr, sizeof (BUCKETSTRUCT));

            //
            // Donate next item to free space
            //

            NextBucketPtr->NextItem = pHashTable->FreeHead;
            NextBucketPtr->Offset = INVALID_OFFSET;
            pHashTable->FreeHead = NextOffset;


        } else {
            //
            // Delete of last item in bucket -- invalidate the root array item
            //

            BucketPtr->NextItem = INVALID_OFFSET;
            BucketPtr->Offset = INVALID_OFFSET;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\memdb.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdb.c

Abstract:

    A memory-based database for managing all kinds of data relationships.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    jimschm     05-Oct-1999  Documentation
    mvander     13-Aug-1999  many changes
    jimschm     23-Sep-1998  Expanded user flags to 24 bits (from 12 bits)
    calinn      12-Dec-1997  Extended MemDbMakePrintableKey and MemDbMakeNonPrintableKey
    jimschm     03-Dec-1997  Added multi-thread synchronization
    jimschm     22-Oct-1997  Split into multiple source files,
                             added multiple memory block capability
    jimschm     16-Sep-1997  Hashing: delete fix
    jimschm     29-Jul-1997  Hashing, user flags added
    jimschm     07-Mar-1997  Signature changes
    jimschm     03-Mar-1997  PrivateBuildKeyFromOffset changes
    jimschm     18-Dec-1996  Fixed deltree bug

--*/

#include "pch.h"

// PORTBUG: Make sure to pick up latest fixes in win9xupg project

//
// Includes
//

#include "memdbp.h"
#include "bintree.h"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

OUR_CRITICAL_SECTION g_MemDbCs;
PMHANDLE g_MemDbPool = NULL;

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
MemDbInitialize (
    VOID
    )

/*++

Routine Description:

  MemDbInitialize creates data structures for an initial database.  Calling
  this routine is required.

Arguments:

  None.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    if (!DatabasesInitialize ()) {
        return FALSE;
    }

    g_MemDbPool = PmCreateNamedPool ("MemDb");

    if (g_MemDbPool == NULL) {
        MemDbTerminate ();
        return FALSE;
    }

    return TRUE;
}


VOID
MemDbTerminate (
    VOID
    )

/*++

Routine Description:

  MemDbTerminate frees all resources associated with MemDb.
  This routine should be called at process termination.

Arguments:

  None.

Return Value:

  None.

--*/

{
    if (g_MemDbPool) {
        PmDestroyPool (g_MemDbPool);
        g_MemDbPool = NULL;
    }

    DatabasesTerminate();
}

PVOID
MemDbGetMemory (
    IN      UINT Size
    )
{
    return PmGetMemory (g_MemDbPool, Size);
}

VOID
MemDbReleaseMemory (
    IN      PCVOID Memory
    )
{
    PmReleaseMemory (g_MemDbPool, Memory);
}


KEYHANDLE
MemDbAddKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbAddKey creates a memdb key that has no values, flags or any
  other data.  This is used to reduce the size of the database.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created key or INVALID_OFFSET if
  not successful.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = INVALID_OFFSET;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbAddKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbAddKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbAddKey creates a memdb key that has no values, flags or any
  other data.  This is used to reduce the size of the database.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created key or INVALID_OFFSET if
  not successful.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = INVALID_OFFSET;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        //
        // first make sure there is no key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            SetLastError (ERROR_ALREADY_EXISTS);
            __leave;
        }

        keyIndex = NewEmptyKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            result = GET_EXTERNAL_INDEX (keyIndex);;
            SetLastError (ERROR_SUCCESS);
        }
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbSetKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbSetKey creates a memdb key that has no values, flags or any
  other data.  This is used to reduce the size of the database.
  If the key exists it will return the handle of the existing key.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created or existent key or INVALID_OFFSET
  if some error occurs.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = INVALID_OFFSET;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbSetKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbSetKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbSetKey creates a memdb key that has no values, flags or any
  other data.  This is used to reduce the size of the database.
  If the key exists it will return the handle of the existing key.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created or existent key or INVALID_OFFSET
  if some error occurs.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = INVALID_OFFSET;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        //
        // first make sure there is no key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            SetLastError (ERROR_ALREADY_EXISTS);
            result = GET_EXTERNAL_INDEX (keyIndex);;
            __leave;
        }

        keyIndex = NewEmptyKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            result = GET_EXTERNAL_INDEX (keyIndex);;
            SetLastError (ERROR_SUCCESS);
        }
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteKeyA (
    IN      PCSTR KeyStr
    )

/*++

Routine Description:

  MemDbDeleteKey deletes a specific string from the database (along with all
  data associated with it)

Arguments:

  KeyStr - Specifies the key string to delete (i.e., foo\bar\cat)

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        result = MemDbDeleteKeyW (p);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteKeyW (
    IN      PCWSTR KeyStr
    )

/*++

Routine Description:

  MemDbDeleteKey deletes a specific string from the database (along with all
  data associated with it)

Arguments:

  KeyStr - Specifies the key string to delete (i.e., foo\bar\cat)

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR subKey;
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    subKey = SelectHiveW (KeyStr);

    result = DeleteKey (subKey, g_CurrentDatabase->FirstLevelTree, TRUE);

    LeaveOurCriticalSection (&g_MemDbCs);

#ifdef DEBUG
    if (g_DatabaseCheckLevel) {
        CheckDatabase (g_DatabaseCheckLevel);
    }
#endif
    return result;
}

BOOL
MemDbDeleteKeyByHandle (
    IN      KEYHANDLE KeyHandle
    )

/*++

Routine Description:

  MemDbDeleteKeyByHandle deletes a specific key from the database
  identified by the key handle. It also removes all data associated
  with it.

Arguments:

  KeyHandle - Key Handle identifying the key

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    BYTE dbIndex;
    BOOL result;

    if (KeyHandle == INVALID_OFFSET) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    dbIndex = GET_DATABASE (KeyHandle);

    SelectDatabase (dbIndex);

    result = PrivateDeleteKeyByIndex (GET_INDEX (KeyHandle));

#ifdef DEBUG
    if (g_DatabaseCheckLevel) {
        CheckDatabase (g_DatabaseCheckLevel);
    }
#endif
    LeaveOurCriticalSection (&g_MemDbCs);

    return result;
}

BOOL
MemDbDeleteTreeA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbDeleteTree removes an entire tree branch from the database, including
  all data associated. The specified key string does not need to be
  an endpoint (i.e., specifying foo\bar will cause deletion of foo\bar\cat).

Arguments:

  KeyName - Specifies the key string to delete. This string cannot be empty.

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteTreeW (p);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteTreeW (
    IN  PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbDeleteTree removes an entire tree branch from the database, including
  all data associated. The specified key string does not need to be
  an endpoint (i.e., specifying foo\bar will cause deletion of foo\bar\cat).

Arguments:

  KeyName - Specifies the key string to delete. This string cannot be empty.

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR subKey;
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    subKey = SelectHiveW (KeyName);

    result = DeleteKey (subKey, g_CurrentDatabase->FirstLevelTree, FALSE);

#ifdef DEBUG
    if (g_DatabaseCheckLevel) {
        CheckDatabase (g_DatabaseCheckLevel);
    }
#endif
    LeaveOurCriticalSection (&g_MemDbCs);

    return result;
}

PCSTR
MemDbGetKeyFromHandleA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    )

/*++

Routine Description:

  MemDbGetKeyFromHandle will create a key string given the key handle.
  It will allocate memory from memdb's private pool to store the result.
  Caller is responsible for calling MemDbReleaseMemory on the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

Return Value:

  A valid string (using memory allocated from memdb's private pool) if
  successful, NULL otherwise.

--*/

{
    PSTR result = NULL;
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    PKEYSTRUCT keyStruct;
    PSTR p;

    if (KeyHandle == INVALID_OFFSET) {
        return NULL;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        if (StartLevel == MEMDB_LAST_LEVEL) {
            //
            // Special case -- get the last level string
            //

            keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
            if (!keyStruct) {
                __leave;
            }

            result = MemDbGetMemory (keyStruct->KeyName[0] * 2 + 1);
            p = DirectUnicodeToDbcsN (
                    result, 
                    keyStruct->KeyName + 1, 
                    keyStruct->KeyName[0] * sizeof (WCHAR)
                    );
            *p = 0;

            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                result = MemDbGetMemory (chars*2+1);
                KnownSizeWtoA (result, wideBuffer);
                __leave;
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

PCWSTR
MemDbGetKeyFromHandleW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    )

/*++

Routine Description:

  MemDbGetKeyFromHandle will create a key string given the key handle.
  It will allocate memory from memdb's private pool to store the result.
  Caller is responsible for calling MemDbReleaseMemory on the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

Return Value:

  A valid string (using memory allocated from memdb's private pool) if
  successful, NULL otherwise.

--*/

{
    PWSTR result = NULL;
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    PKEYSTRUCT keyStruct;

    if (KeyHandle == INVALID_OFFSET) {
        return NULL;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        if (StartLevel == MEMDB_LAST_LEVEL) {
            //
            // Special case -- get the last level string
            //

            keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
            if (!keyStruct) {
                __leave;
            }

            chars = keyStruct->KeyName[0];
            result = MemDbGetMemory ((chars + 1) * sizeof (WCHAR));
            CopyMemory (result, keyStruct->KeyName + 1, chars * sizeof (WCHAR));
            result[chars] = 0;

            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                result = MemDbGetMemory (chars*2+1);
                StringCopyW (result, wideBuffer);
                __leave;
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetKeyFromHandleExA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer
    )

/*++

Routine Description:

  MemDbGetKeyFromHandleEx will create a key string given the key handle.
  It will use caller's grow buffer to store the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

  Buffer     - Specifies an intialized grow buffer that may contain data.
               Receives the key string, appended to data in the buffer (if
               any)

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    WCHAR wideBuffer[MEMDB_MAX];
    CHAR ansiBuffer[MEMDB_MAX*2];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    BOOL result = FALSE;

    if (KeyHandle == INVALID_OFFSET) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                KnownSizeWtoA (ansiBuffer, wideBuffer);
                if (Buffer) {
                    (void)GbCopyStringA (Buffer, ansiBuffer);
                }
                result = TRUE;
                __leave;
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetKeyFromHandleExW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN      PGROWBUFFER Buffer
    )

/*++

Routine Description:

  MemDbGetKeyFromHandleEx will create a key string given the key handle.
  It will use caller's grow buffer to store the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

  Buffer     - Specifies an intialized grow buffer that may contain data.
               Receives the key string, appended to data in the buffer (if
               any)

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    BOOL result = FALSE;

    if (KeyHandle == INVALID_OFFSET) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                if (Buffer) {
                    (void)GbCopyStringW (Buffer, wideBuffer);
                }
                result = TRUE;
                __leave;
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetHandleFromKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbGetHandleFromKey will return the key handle associated with KeyName,
  if it's already added in memdb.

Arguments:

  KeyName - Specifies the key to search.

Return Value:

  Returns the key handle of the requested key or INVALID_OFFSET if
  the key is not present.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = INVALID_OFFSET;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbGetHandleFromKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbGetHandleFromKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbGetHandleFromKey will return the key handle associated with KeyName,
  if it's already added in memdb.

Arguments:

  KeyName - Specifies the key to search.

Return Value:

  Returns the key handle of the requested key or INVALID_OFFSET if
  the key is not present.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = INVALID_OFFSET;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        //
        // first make sure there is a key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (keyIndex);
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbSetValueAndFlagsExA (
    IN      PCSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx creates the key if it doesn't exist and then
  it sets it's value and it's flags based on the arguments.

Arguments:

  KeyName       - Specifies the key string (i.e., foo\bar\cat)
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful, INVALID_OFFSET otherwise.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = INVALID_OFFSET;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbSetValueAndFlagsExW (
                    keyNameW,
                    AlterValue,
                    Value,
                    ReplaceFlags,
                    SetFlags,
                    ClearFlags
                    );
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbSetValueAndFlagsExW (
    IN      PCWSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx creates the key if it doesn't exist and then
  it sets it's value and it's flags based on the arguments.

Arguments:

  KeyName       - Specifies the key string (i.e., foo\bar\cat)
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful, INVALID_OFFSET otherwise.

--*/

{
    PCWSTR subKey;
    KEYHANDLE result = INVALID_OFFSET;
    UINT keyIndex;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        if (AlterValue) {
            if (!KeyStructSetValue (keyIndex, Value)) {
                __leave;
            }
        }

        if ((ReplaceFlags && SetFlags) ||
            (!ReplaceFlags && (SetFlags || ClearFlags))
            ) {

            if (!KeyStructSetFlags (keyIndex, ReplaceFlags, SetFlags, ClearFlags)) {
                __leave;
            }
        }

        result = GET_EXTERNAL_INDEX (keyIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbSetValueAndFlagsByHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx modifies value and/or flags for an existing key
  identified by KeyHandle.

Arguments:

  KeyHandle     - Identifies an existing key
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful,
  INVALID_OFFSET otherwise.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (KeyHandle == INVALID_OFFSET) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        if (AlterValue) {
            if (!KeyStructSetValue (GET_INDEX (KeyHandle), Value)) {
                __leave;
            }
        }

        if ((ReplaceFlags && SetFlags) ||
            (!ReplaceFlags && (SetFlags || ClearFlags))
            ) {

            if (!KeyStructSetFlags (GET_INDEX (KeyHandle), ReplaceFlags, SetFlags, ClearFlags)) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsA (
    IN      PCSTR KeyName,
    OUT     PUINT Value,       OPTIONAL
    OUT     PUINT Flags        OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsA is the external entry point for querying the database
  for a value and flags.

Arguments:

  KeyName       - Specifies the key to query (i.e., foo\bar\cat)
  Value         - Recieves the value associated with Key, if Key exists.
  Flags         - Receives the flags associated with Key, if Key exists.

Return Value:

  TRUE if Key exists in the database, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetValueAndFlagsW (p, Value, Flags);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsW (
    IN  PCWSTR KeyName,
    OUT PUINT Value,           OPTIONAL
    OUT PUINT Flags            OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsW is the external entry point for querying the database
  for a value and flags.

Arguments:

  KeyName       - Specifies the key to query (i.e., foo\bar\cat)
  Value         - Recieves the value associated with Key, if Key exists.
  Flags         - Receives the flags associated with Key, if Key exists.

Return Value:

  TRUE if Key exists in the database, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = TRUE;

        result = result && KeyStructGetValue (GetKeyStruct (keyIndex), Value);
        result = result && KeyStructGetFlags (GetKeyStruct (keyIndex), Flags);
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsByHandle (
    IN  KEYHANDLE KeyHandle,
    OUT PUINT Value,           OPTIONAL
    OUT PUINT Flags            OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsByHandle is the external entry point for querying the database
  for a value and flags based on a key handle.

Arguments:

  KeyHandle     - Specifies the key handle to query
  Value         - Recieves the value associated with Key, if KeyHandle exists.
  Flags         - Receives the flags associated with Key, if KeyHandle exists.

Return Value:

  TRUE if KeyHandle exists in the database, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PKEYSTRUCT keyStruct;
    BOOL result = FALSE;

    if (KeyHandle == INVALID_OFFSET) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
        if (!keyStruct) {
            __leave;
        }

        result = TRUE;

        result = result && KeyStructGetValue (keyStruct, Value);
        result = result && KeyStructGetFlags (keyStruct, Flags);
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = INVALID_OFFSET;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbAddDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}

DATAHANDLE
MemDbAddDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = INVALID_OFFSET;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructAddBinaryData (keyIndex, Type, Instance, Data, DataSize);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyHandle     - Specifies the key using the key handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = INVALID_OFFSET;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        dataIndex = KeyStructAddBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGetDataHandleA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p;
    DATAHANDLE result = INVALID_OFFSET;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataHandleW (p, Type, Instance);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbGetDataHandleW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = INVALID_OFFSET;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        dataIndex = KeyStructGetDataIndex (keyIndex, Type, Instance);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbSetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for setting binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is replaced

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = INVALID_OFFSET;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbSetDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbSetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for setting binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is replaced, if it doesn't, it is created.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = INVALID_OFFSET;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        KeyStructDeleteBinaryData (keyIndex, Type, Instance);
        dataIndex = KeyStructAddBinaryData (keyIndex, Type, Instance, Data, DataSize);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbSetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for replacing an existing binary data.

Arguments:

  DataHandle    - Specifies an existing data handle
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = INVALID_OFFSET;

    if (DataHandle == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);

        SelectDatabase (dbIndex);

        dataIndex = KeyStructReplaceBinaryDataByIndex (GET_INDEX (DataHandle), Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }
        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbSetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetDataByKeyHandle is the a general purpose routine for setting binary data for a key.
  If this type of data already exists, it is replaced, if it doesn't, it is created.

Arguments:

  KeyHandle     - Specifies the key using the key handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = INVALID_OFFSET;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        KeyStructDeleteBinaryData (GET_INDEX (KeyHandle), Type, Instance);
        dataIndex = KeyStructAddBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowData is the a general purpose routine for growing binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is growed by appending the new data, if not, it is created by adding the new data

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = INVALID_OFFSET;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGrowDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowData is the a general purpose routine for growing binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is growed by appending the new data, if not, it is created by adding the new data

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = INVALID_OFFSET;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructGrowBinaryData (keyIndex, Type, Instance, Data, DataSize);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowDataByDataHandle is the a general purpose routine for growing binary data for a key.

Arguments:

  DataHandle    - Specifies the existing binary data handle
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = INVALID_OFFSET;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);

        SelectDatabase (dbIndex);

        dataIndex = KeyStructGrowBinaryDataByIndex (GET_INDEX (DataHandle), Data, DataSize);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowDataByDataHandle is the a general purpose routine for growing binary
  data for a key. If the data is not present it is added, if it's present, the
  new data is appended.

Arguments:

  KeyHandle     - Specifies the key we want by it's handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, INVALID_OFFSET otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = INVALID_OFFSET;

    if (KeyHandle == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        dataIndex = KeyStructGrowBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return NULL. The
  function will allocate memory from memdb's private pool. Caller is responsible
  for releasing the memory.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    PCWSTR p;
    PBYTE result = NULL;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataW (p, Type, Instance, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


PBYTE
MemDbGetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return NULL. The
  function will allocate memory from memdb's private pool. Caller is responsible
  for releasing the memory.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return NULL;
    }

    if (Instance > 3) {
        return NULL;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (keyIndex, Type, Instance, &localSize);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    OUT     PUINT DataSize                  OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByDataHandle is the a general purpose routine for retrieving
  existing binary data for a key.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);

        SelectDatabase (dbIndex);

        tempResult = KeyStructGetBinaryDataByIndex (GET_INDEX (DataHandle), &localSize);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize                      OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByKeyHandle is the a general purpose routine for retrieving existing binary data for a key.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return NULL;
    }

    if (Instance > 3) {
        return NULL;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        tempResult = KeyStructGetBinaryData (GET_INDEX (KeyHandle), Type, Instance, &localSize);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataExA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataEx is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return FALSE. The
  function will use the caller supplied growbuffer to store the data.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataExW (p, Type, Instance, Buffer, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


BOOL
MemDbGetDataExW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return FALSE. The
  function will use the caller supplied growbuffer to store the data.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (keyIndex, Type, Instance, &localSize);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataByDataHandleEx (
    IN      DATAHANDLE DataHandle,
    OUT     PGROWBUFFER Buffer,
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for retrieving
  existing binary data for a key. The function will use the caller supplied
  growbuffer to store the data.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);

        SelectDatabase (dbIndex);

        tempResult = KeyStructGetBinaryDataByIndex (GET_INDEX (DataHandle), &localSize);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataByKeyHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByKeyHandle is the a general purpose routine for retrieving
  existing binary data for a key. The function will use the caller supplied
  growbuffer to store the data.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        tempResult = KeyStructGetBinaryData (GET_INDEX (KeyHandle), Type, Instance, &localSize);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbDeleteDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for removing existing data for a
  key. If the data does not exist the function will return TRUE anyway.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if function was successful, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteDataW (p, Type, Instance);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbDeleteData is the a general purpose routine for removing existing binary
  data for a key. If the data does not exist the function will return TRUE
  anyway.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if function was successful, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructDeleteBinaryData (keyIndex, Type, Instance);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteDataByDataHandle (
    IN      DATAHANDLE DataHandle
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for removing
  existing binary data for a key.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);

        SelectDatabase (dbIndex);

        result = KeyStructDeleteBinaryDataByIndex (GET_INDEX (DataHandle));
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for removing
  existing binary data for a key.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        result = KeyStructDeleteBinaryData (GET_INDEX (KeyHandle), Type, Instance);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    PCWSTR p;
    DATAHANDLE result = INVALID_OFFSET;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbAddLinkageValueW (p, Type, Instance, Linkage, AllowDuplicates);
        FreeConvertedStr (p);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = INVALID_OFFSET;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructAddLinkage (keyIndex, Type, Instance, Linkage, AllowDuplicates);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = INVALID_OFFSET;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);

        SelectDatabase (dbIndex);

        dataIndex = KeyStructAddLinkageByIndex (GET_INDEX (DataHandle), Linkage, AllowDuplicates);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = INVALID_OFFSET;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        dataIndex = KeyStructAddLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage, AllowDuplicates);

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteLinkageValueW (p, Type, Instance, Linkage, FirstOnly);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructDeleteLinkage (keyIndex, Type, Instance, Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);

        SelectDatabase (dbIndex);

        result = KeyStructDeleteLinkageByIndex (GET_INDEX (DataHandle), Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        result = KeyStructDeleteLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage
    )
{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbTestLinkageValueW (p, Type, Instance, Linkage);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbTestLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructTestLinkage (keyIndex, Type, Instance, Linkage);
    }
    __finally {

        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      KEYHANDLE Linkage
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);

        SelectDatabase (dbIndex);

        result = KeyStructTestLinkageByIndex (GET_INDEX (DataHandle), Linkage);
    }
    __finally {

        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        result = KeyStructTestLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage);
    }
    __finally {

        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbAddLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbAddLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbAddLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {

            keyIndex1 = NewKey (subKey1);
            if (keyIndex1 == INVALID_OFFSET) {
                __leave;
            }
        }
        subKey2 = SelectHiveW (KeyName2);

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {

            keyIndex2 = NewKey (subKey2);
            if (keyIndex2 == INVALID_OFFSET) {
                __leave;
            }
        }

        subKey1 = SelectHiveW (KeyName1);

        dataIndex = KeyStructAddLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2), FALSE);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        if (Type == DATAFLAG_DOUBLELINK) {

            subKey2 = SelectHiveW (KeyName2);

            dataIndex = KeyStructAddLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1), FALSE);

            if (dataIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbAddLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);

        SelectDatabase (dbIndex1);

        keyIndex1 = GET_INDEX (KeyHandle1);

        if (keyIndex1 == INVALID_OFFSET) {

            __leave;
        }
        dbIndex2 = GET_DATABASE (KeyHandle2);

        SelectDatabase (dbIndex2);

        keyIndex2 = GET_INDEX (KeyHandle2);

        if (keyIndex2 == INVALID_OFFSET) {

            __leave;
        }

        SelectDatabase (dbIndex1);

        dataIndex = KeyStructAddLinkage (keyIndex1, Type, Instance, KeyHandle2, FALSE);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        if (Type == DATAFLAG_DOUBLELINK) {

            SelectDatabase (dbIndex2);

            dataIndex = KeyStructAddLinkage (keyIndex2, Type, Instance, KeyHandle1, FALSE);

            if (dataIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbDeleteLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbDeleteLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        subKey2 = SelectHiveW (KeyName2);

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        subKey1 = SelectHiveW (KeyName1);

        result = KeyStructDeleteLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2), FALSE);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            subKey2 = SelectHiveW (KeyName2);

            result = KeyStructDeleteLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1), FALSE);
        }
    }
    __finally {

        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);

        SelectDatabase (dbIndex1);

        keyIndex1 = GET_INDEX (KeyHandle1);

        if (keyIndex1 == INVALID_OFFSET) {

            __leave;
        }
        dbIndex2 = GET_DATABASE (KeyHandle2);

        SelectDatabase (dbIndex2);

        keyIndex2 = GET_INDEX (KeyHandle2);

        if (keyIndex2 == INVALID_OFFSET) {

            __leave;
        }

        SelectDatabase (dbIndex1);

        result = KeyStructDeleteLinkage (keyIndex1, Type, Instance, KeyHandle2, FALSE);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            SelectDatabase (dbIndex2);

            result = KeyStructDeleteLinkage (keyIndex2, Type, Instance, KeyHandle1, FALSE);
        }
    }
    __finally {

        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbTestLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbTestLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        subKey2 = SelectHiveW (KeyName2);

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        subKey1 = SelectHiveW (KeyName1);

        result = KeyStructTestLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2));

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            subKey2 = SelectHiveW (KeyName2);

            result = KeyStructTestLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1));
        }
    }
    __finally {

        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);

        SelectDatabase (dbIndex1);

        keyIndex1 = GET_INDEX (KeyHandle1);

        if (keyIndex1 == INVALID_OFFSET) {

            __leave;
        }
        dbIndex2 = GET_DATABASE (KeyHandle2);

        SelectDatabase (dbIndex2);

        keyIndex2 = GET_INDEX (KeyHandle2);

        if (keyIndex2 == INVALID_OFFSET) {

            __leave;
        }

        SelectDatabase (dbIndex1);

        result = KeyStructTestLinkage (keyIndex1, Type, Instance, KeyHandle2);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            SelectDatabase (dbIndex2);

            result = KeyStructTestLinkage (keyIndex2, Type, Instance, KeyHandle1);
        }
    }
    __finally {

        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    PCWSTR p = NULL;
    KEYHANDLE result = INVALID_OFFSET;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetLinkageW (p, Type, Instance, LinkageIndex);
        FreeConvertedStr (p);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = INVALID_OFFSET;
    PUINT linkArray;
    UINT linkArraySize;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            __leave;
        }

        linkArraySize = 0;

        linkArray = (PUINT)KeyStructGetBinaryData (keyIndex, Type, Instance, &linkArraySize);

        linkArraySize = linkArraySize / SIZEOF(UINT);

        if (linkArraySize <= LinkageIndex) {
            __leave;
        }

        result = linkArray [LinkageIndex];
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    UINT keyIndex;
    BYTE dbIndex;
    KEYHANDLE result = INVALID_OFFSET;
    PUINT linkArray;
    UINT linkArraySize;

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return INVALID_OFFSET;
    }

    if (Instance > 3) {
        return INVALID_OFFSET;
    }

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);

        SelectDatabase (dbIndex);

        keyIndex = GET_INDEX (KeyHandle);

        if (keyIndex == INVALID_OFFSET) {

            __leave;
        }

        linkArray = (PUINT)KeyStructGetBinaryData (keyIndex, Type, Instance, &linkArraySize);

        linkArraySize = linkArraySize / SIZEOF(UINT);

        if (linkArraySize <= LinkageIndex) {
            __leave;
        }

        result = linkArray [LinkageIndex];
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
pCheckEnumConditions (
    IN      UINT KeyIndex,
    IN      PMEMDB_ENUMW MemDbEnum
    )
{
    PKEYSTRUCT keyStruct;
    UINT index;
    PWSTR segPtr, segEndPtr;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (keyStruct->KeyFlags & KSF_ENDPOINT) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_ENDPOINTS)) {
            return FALSE;
        }
        MemDbEnum->EndPoint = TRUE;
    } else {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_NONENDPOINTS)) {
            return FALSE;
        }
        MemDbEnum->EndPoint = FALSE;
    }
    if (keyStruct->DataFlags & DATAFLAG_UNORDERED) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_UNORDERED)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_SINGLELINK) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_SINGLELINK)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_DOUBLELINK) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_DOUBLELINK)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_VALUE) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_VALUE)) {
            return FALSE;
        }
        MemDbEnum->Value = keyStruct->Value;
    } else {
        MemDbEnum->Value = 0;
    }
    if (keyStruct->DataFlags & DATAFLAG_FLAGS) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_FLAGS)) {
            return FALSE;
        }
        MemDbEnum->Flags = keyStruct->Flags;
    } else {
        MemDbEnum->Flags = 0;
    }
    if (!keyStruct->DataFlags) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_EMPTY)) {
            return FALSE;
        }
    }
    if (MemDbEnum->BeginLevel != ENUMLEVEL_LASTLEVEL) {
        if (MemDbEnum->CurrentLevel - 1 < MemDbEnum->BeginLevel) {
            return FALSE;
        }
        if (MemDbEnum->CurrentLevel - 1 > MemDbEnum->EndLevel) {
            return FALSE;
        }
    }
    MemDbEnum->KeyHandle = GET_EXTERNAL_INDEX (KeyIndex);
    index = 0;
    segPtr = MemDbEnum->KeyNameCopy;
    MemDbEnum->FullKeyName[0] = 0;
    MemDbEnum->KeyName[0] = 0;
    while (segPtr) {
        segEndPtr = wcschr (segPtr, L'\\');
        if (segEndPtr) {
            *segEndPtr = 0;
        }

        index ++;
        if (index > 1) {
            StringCatW (MemDbEnum->FullKeyName, L"\\");
            StringCatW (MemDbEnum->FullKeyName, segPtr);
        } else {
            switch (g_CurrentDatabaseIndex) {

            case DB_PERMANENT:
                StringCopyW (MemDbEnum->FullKeyName, segPtr);
                break;

            case DB_TEMPORARY:

                StringCopyW (MemDbEnum->FullKeyName, L"~");
                StringCatW (MemDbEnum->FullKeyName, segPtr);
                break;

            default:
                StringCopyW (MemDbEnum->FullKeyName, segPtr);

            }
        }
        if (MemDbEnum->BeginLevel == ENUMLEVEL_LASTLEVEL) {
            if (index >= MemDbEnum->CurrentLevel) {
                //this is the last segment, copy it to the
                //partial key
                StringCopyW (MemDbEnum->KeyName, segPtr);
            }
        } else {
            if (index > MemDbEnum->BeginLevel) {
                //copy the current segment in partial key
                if ((index - 1) == MemDbEnum->BeginLevel) {
                    if (index == 1) {
                        switch (g_CurrentDatabaseIndex) {

                        case DB_PERMANENT:
                            StringCopyW (MemDbEnum->FullKeyName, segPtr);
                            break;

                        case DB_TEMPORARY:

                            StringCopyW (MemDbEnum->FullKeyName, L"~");
                            StringCatW (MemDbEnum->FullKeyName, segPtr);
                            break;

                        default:
                            StringCopyW (MemDbEnum->FullKeyName, segPtr);

                        }
                    } else {
                        StringCopyW (MemDbEnum->KeyName, segPtr);
                    }
                } else {
                    StringCatW (MemDbEnum->KeyName, L"\\");
                    StringCatW (MemDbEnum->KeyName, segPtr);
                }
            }
        }

        if (segEndPtr) {
            segPtr = segEndPtr + 1;
            *segEndPtr = L'\\';
        } else {
            segPtr = NULL;
        }

        if (index >= MemDbEnum->CurrentLevel) {
            // no more segments to copy
            break;
        }
    }
    return TRUE;
}

VOID
pAddKeyToEnumStruct (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR KeyName
    )
{
    PCWSTR lastName;
    PWSTR endPtr;

    lastName = MemDbEnum->KeyNameCopy;
    if (lastName) {
        MemDbEnum->KeyNameCopy = JoinTextExW (g_MemDbPool, lastName, L"\\", NULL, KeyName[0] + 1, &endPtr);
        StringPasCopyConvertFrom (endPtr, KeyName);
        MemDbReleaseMemory ((PBYTE)lastName);
    } else {
        MemDbEnum->KeyNameCopy = (PWSTR)MemDbGetMemory ((KeyName[0] + 1) * SIZEOF(WCHAR));
        StringPasCopyConvertFrom ((PWSTR)MemDbEnum->KeyNameCopy, KeyName);
    }
    // BUGBUG - this way of doing it will fill out the pool very fast.
    // need to find a way to release first and allocate after that.
}

VOID
pDeleteLastKeyFromEnumStruct (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    PWSTR lastWackPtr;

    lastWackPtr = wcsrchr (MemDbEnum->KeyNameCopy, L'\\');
    if (lastWackPtr) {
        *lastWackPtr = 0;
    }
}

BOOL
pMemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    BOOL shouldReturn = FALSE;
    BOOL result = FALSE;
    BOOL patternMatch = TRUE;
    BOOL goOn = TRUE;
    UINT treeEnumContext;
    UINT treeEnumNode;
    UINT tempKeyIndex;
    PKEYSTRUCT tempKeyStruct;
    PBYTE gbAddress;
    UINT minLevel;
    UINT internalLevel;

    while (!shouldReturn) {

        if (MemDbEnum->EnumerationMode) {

            result = FALSE;

            minLevel = MemDbEnum->CurrentLevel;
            internalLevel = MemDbEnum->CurrentLevel;

            if (MemDbEnum->TreeEnumLevel == MemDbEnum->TreeEnumBuffer.End) {

                patternMatch = FALSE;

                while (!patternMatch) {

                    if (MemDbEnum->TreeEnumBuffer.End) {

                        goOn = TRUE;

                        while (goOn) {
                            // we are in the middle of some tree enumeration
                            // let's get back the context and continue
                            if (MemDbEnum->TreeEnumBuffer.End == 0) {
                                // we can't back out any more, we're done
                                break;
                            }
                            MemDbEnum->TreeEnumBuffer.End -= (SIZEOF(UINT)+SIZEOF(UINT));
                            if (MemDbEnum->TreeEnumLevel > MemDbEnum->TreeEnumBuffer.End) {
                                MemDbEnum->TreeEnumLevel = MemDbEnum->TreeEnumBuffer.End;
                            }
                            minLevel --;
                            if (MemDbEnum->CurrentLevel > minLevel) {
                                MemDbEnum->CurrentLevel = minLevel;
                            }
                            if (internalLevel > minLevel) {
                                internalLevel = minLevel;
                            }
                            pDeleteLastKeyFromEnumStruct (MemDbEnum);
                            treeEnumContext = *((PUINT) (MemDbEnum->TreeEnumBuffer.Buf+MemDbEnum->TreeEnumBuffer.End + SIZEOF(UINT)));
                            tempKeyIndex = BinTreeEnumNext (&treeEnumContext);
                            if (tempKeyIndex != INVALID_OFFSET) {
                                minLevel ++;
                                internalLevel ++;
                                goOn = FALSE;
                                // put them in the grow buffer
                                gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                if (gbAddress) {
                                    *((PUINT) (gbAddress)) = tempKeyIndex;
                                    *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                }
                                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                MYASSERT (tempKeyStruct);
                                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                treeEnumNode = tempKeyStruct->NextLevelTree;
                                while ((treeEnumNode != INVALID_OFFSET) &&
                                       (internalLevel - 1 <= MemDbEnum->EndLevel)
                                       ) {
                                    tempKeyIndex = BinTreeEnumFirst (treeEnumNode, &treeEnumContext);
                                    if (tempKeyIndex != INVALID_OFFSET) {
                                        minLevel ++;
                                        internalLevel ++;
                                        // put them in the grow buffer
                                        gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                        if (gbAddress) {
                                            *((PUINT) (gbAddress)) = tempKeyIndex;
                                            *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                        }
                                        tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                        MYASSERT (tempKeyStruct);
                                        pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                        treeEnumNode = tempKeyStruct->NextLevelTree;
                                    } else {
                                        treeEnumNode = INVALID_OFFSET;
                                    }
                                }
                            }
                        }

                    } else {
                        // we are about to start the tree enumeration
                        // let's start the enumeration and push the
                        // context data in our buffer

                        treeEnumNode = MemDbEnum->CurrentIndex;
                        while ((treeEnumNode != INVALID_OFFSET) &&
                               (internalLevel <= MemDbEnum->EndLevel)
                               ) {
                            tempKeyIndex = BinTreeEnumFirst (treeEnumNode, &treeEnumContext);
                            if (tempKeyIndex != INVALID_OFFSET) {
                                minLevel ++;
                                internalLevel ++;
                                // put them in the grow buffer
                                gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                if (gbAddress) {
                                    *((PUINT) (gbAddress)) = tempKeyIndex;
                                    *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                }
                                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                MYASSERT (tempKeyStruct);
                                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                treeEnumNode = tempKeyStruct->NextLevelTree;
                            } else {
                                treeEnumNode = INVALID_OFFSET;
                            }
                        }
                    }
                    if (MemDbEnum->TreeEnumBuffer.End == 0) {
                        // we can't back out any more, we're done
                        break;
                    }
                    patternMatch = IsPatternMatchW (
                                        MemDbEnum->PatternCopy,
                                        MemDbEnum->KeyNameCopy
                                        );
                }
            }

            if (MemDbEnum->TreeEnumLevel == MemDbEnum->TreeEnumBuffer.End) {
                break;
            }
            MYASSERT (MemDbEnum->TreeEnumLevel < MemDbEnum->TreeEnumBuffer.End);

            // now implement segment by segment enumeration because we
            // just created a full key that matches the pattern
            MemDbEnum->CurrentLevel ++;
            shouldReturn = pCheckEnumConditions (
                                *((PUINT) (MemDbEnum->TreeEnumBuffer.Buf+MemDbEnum->TreeEnumLevel)),
                                MemDbEnum
                                );
            MemDbEnum->TreeEnumLevel += (SIZEOF(UINT)+SIZEOF(UINT));
            result = TRUE;

        } else {

            result = FALSE;

            if (!MemDbEnum->PatternEndPtr) {
                //we are done, no more segments
                break;
            }

            MemDbEnum->PatternPtr = MemDbEnum->PatternEndPtr;
            MemDbEnum->PatternEndPtr = wcschr (MemDbEnum->PatternPtr, L'\\');
            if (MemDbEnum->PatternEndPtr) {
                *MemDbEnum->PatternEndPtr = 0;
            }

            if (wcschr (MemDbEnum->PatternPtr, L'*') ||
                wcschr (MemDbEnum->PatternPtr, L'?')
                ) {

                MemDbEnum->EnumerationMode = TRUE;

            } else {
                tempKeyIndex = FindKeyStructInTree (
                                    MemDbEnum->CurrentIndex,
                                    MemDbEnum->PatternPtr,
                                    FALSE
                                    );
                if (tempKeyIndex == INVALID_OFFSET) {
                    // we are done, the segment we look for does not exist
                    break;
                }
                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                MYASSERT (tempKeyStruct);
                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                MemDbEnum->CurrentIndex = tempKeyStruct->NextLevelTree;

                MemDbEnum->CurrentLevel ++;
                shouldReturn = pCheckEnumConditions (
                                    tempKeyIndex,
                                    MemDbEnum
                                    );
                result = TRUE;
            }
            if (MemDbEnum->PatternEndPtr) {
                *MemDbEnum->PatternEndPtr = L'\\';
                MemDbEnum->PatternEndPtr++;
            }
        }
    }
    return result;
}

BOOL
MemDbEnumFirstW (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel
    )
{
    BOOL result = FALSE;
    PCWSTR subPattern;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subPattern = SelectHiveW (EnumPattern);

        ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMW));
        MemDbEnum->KeyHandle = INVALID_OFFSET;
        MemDbEnum->CurrentDatabaseIndex = GetCurrentDatabaseIndex ();
        MemDbEnum->EnumFlags = EnumFlags;
        MemDbEnum->PatternCopy = DuplicateTextExW (g_MemDbPool, subPattern, 0, NULL);
        if (!MemDbEnum->PatternCopy) {
            __leave;
        }
        MemDbEnum->PatternPtr = MemDbEnum->PatternCopy;
        MemDbEnum->PatternEndPtr = MemDbEnum->PatternPtr;
        MemDbEnum->CurrentIndex = g_CurrentDatabase->FirstLevelTree;
        MemDbEnum->BeginLevel = BeginLevel;
        if (MemDbEnum->BeginLevel == ENUMLEVEL_LASTLEVEL) {
            MemDbEnum->EndLevel = ENUMLEVEL_ALLLEVELS;
        } else {
            MemDbEnum->EndLevel = EndLevel;
            if (MemDbEnum->EndLevel < MemDbEnum->BeginLevel) {
                MemDbEnum->EndLevel = MemDbEnum->BeginLevel;
            }
        }
        MemDbEnum->CurrentLevel = 0;

        result = pMemDbEnumNextW (MemDbEnum);
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }
    return result;
}

BOOL
MemDbEnumFirstA (
    IN OUT  PMEMDB_ENUMA MemDbEnum,
    IN      PCSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel
    )
{
    BOOL result = FALSE;
    PCSTR ansiStr;
    PCWSTR unicodeStr;

    unicodeStr = ConvertAtoW (EnumPattern);
    if (!unicodeStr) {
        return FALSE;
    }
    result = MemDbEnumFirstW (
                &(MemDbEnum->UnicodeEnum),
                unicodeStr,
                EnumFlags,
                BeginLevel,
                EndLevel
                );
    if (result) {
        ansiStr = ConvertWtoA (MemDbEnum->UnicodeEnum.FullKeyName);
        if (ansiStr) {
            StringCopyA (MemDbEnum->FullKeyName, ansiStr);
            FreeConvertedStr (ansiStr);
        }
        ansiStr = ConvertWtoA (MemDbEnum->UnicodeEnum.KeyName);
        if (ansiStr) {
            StringCopyA (MemDbEnum->KeyName, ansiStr);
            FreeConvertedStr (ansiStr);
        }
        MemDbEnum->Value = MemDbEnum->UnicodeEnum.Value;
        MemDbEnum->Flags = MemDbEnum->UnicodeEnum.Flags;
        MemDbEnum->KeyHandle = MemDbEnum->UnicodeEnum.KeyHandle;
        MemDbEnum->EndPoint = MemDbEnum->UnicodeEnum.EndPoint;
    }
    return result;
}

BOOL
MemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        SelectDatabase (MemDbEnum->CurrentDatabaseIndex);

        result = pMemDbEnumNextW (MemDbEnum);
    }
    __finally {
        LeaveOurCriticalSection (&g_MemDbCs);
    }
    return result;
}

BOOL
MemDbEnumNextA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    )
{
    BOOL result = FALSE;
    PCSTR ansiStr;

    result = MemDbEnumNextW (&(MemDbEnum->UnicodeEnum));
    if (result) {
        ansiStr = ConvertWtoA (MemDbEnum->UnicodeEnum.FullKeyName);
        if (ansiStr) {
            StringCopyA (MemDbEnum->FullKeyName, ansiStr);
            FreeConvertedStr (ansiStr);
        }
        ansiStr = ConvertWtoA (MemDbEnum->UnicodeEnum.KeyName);
        if (ansiStr) {
            StringCopyA (MemDbEnum->KeyName, ansiStr);
            FreeConvertedStr (ansiStr);
        }
        MemDbEnum->Value = MemDbEnum->UnicodeEnum.Value;
        MemDbEnum->Flags = MemDbEnum->UnicodeEnum.Flags;
        MemDbEnum->KeyHandle = MemDbEnum->UnicodeEnum.KeyHandle;
        MemDbEnum->EndPoint = MemDbEnum->UnicodeEnum.EndPoint;
    }
    return result;
}

BOOL
MemDbEnumAbortW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMW));
    return TRUE;
}

BOOL
MemDbEnumAbortA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    )
{
    ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMA));
    return TRUE;
}

BOOL
MemDbSetInsertionOrderedA (
    IN      PCSTR Key
    )

/*++

Routine Description:

  MemDbSetInsertionOrderedA sets the enumeration order of the children of Key
  to be in the order they were inserted.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PCWSTR unicodeKey;
    BOOL b = FALSE;

    unicodeKey = ConvertAtoW (Key);

    if (unicodeKey) {
        b = MemDbSetInsertionOrderedW (unicodeKey);
    }

    FreeConvertedStr (unicodeKey);
    return b;
}

BOOL
MemDbSetInsertionOrderedW (
    IN      PCWSTR Key
    )

/*++

Routine Description:

  MemDbSetInsertionOrderedW sets the enumeration order of the children of Key
  to be in the order they were inserted.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL b = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (Key);

        keyIndex = FindKeyStruct (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        b = KeyStructSetInsertionOrdered(GetKeyStruct(keyIndex));
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveOurCriticalSection (&g_MemDbCs);
    }

    return b;
}

#ifdef DEBUG

BOOL
MemDbCheckDatabase(
    UINT Level
    )

/*++

Routine Description:

  MemDbCheckDatabase enumerates the entire database and verifies that each
  enumerated key can be found in the hash table.

Arguments:

  Level - Specifies database check level

Return Value:

  TRUE if the database is valid, FALSE otherwise.

--*/

{
    return (CheckDatabase(Level) && CheckLevel(g_CurrentDatabase->FirstLevelTree, INVALID_OFFSET));
}


UINT
MemDbGetDatabaseSize (
    VOID
    )

/*++

Routine Description:

  MemDbGetDatabaseSize returns the size of the main database heap. This
  number does not represent the entire database size, because it does not
  include binary value heaps or temporary database heaps.

Arguments:

  None.

Return Value:

  The size of the main database heap.

--*/

{
    SelectDatabase(0);
    return g_CurrentDatabase->End;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\database.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    database.c

Abstract:

    Routines that manage the memdb database memory

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    calinn     12-Jan-2000  prepare for 5.1 release

--*/

//
// Includes
//

#include "pch.h"
#include "memdbp.h"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define MAX_MEMDB_SIZE      0x80000000  //02 GB
#define INIT_BLOCK_SIZE     0x00010000  //64 KB

//
// Types
//

typedef struct {
    HANDLE hFile;
    HANDLE hMap;
    WCHAR Hive[MAX_HIVE_NAME];
    CHAR FileName[MAX_PATH];
    PDATABASE Database;
} DATABASECONTROL, *PDATABASECONTROL;

//
// Globals
//

BOOL g_DatabaseInitialized = FALSE;
DATABASECONTROL g_PermanentDatabaseControl;
DATABASECONTROL g_TemporaryDatabaseControl;
PDATABASE g_CurrentDatabase = NULL;
BYTE g_CurrentDatabaseIndex = DB_NOTHING;

#ifdef DEBUG

BOOL g_UseDebugStructs = TRUE;

#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
SelectDatabase (
    IN      BYTE DatabaseIndex
    )
{
    switch (DatabaseIndex) {
    case DB_PERMANENT:
        g_CurrentDatabase = g_PermanentDatabaseControl.Database;
        g_CurrentDatabaseIndex = DB_PERMANENT;
        break;
    case DB_TEMPORARY:
        g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
        g_CurrentDatabaseIndex = DB_TEMPORARY;
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

BOOL
pMapDatabaseFile (
    PDATABASECONTROL DatabaseControl
    )
{
    MYASSERT(DatabaseControl);

    DatabaseControl->Database = (PDATABASE) MapFileFromHandle (DatabaseControl->hFile, &DatabaseControl->hMap);

    return DatabaseControl->Database != NULL;
}

BOOL
pUnmapDatabaseFile (
    PDATABASECONTROL DatabaseControl
    )
{
    MYASSERT(DatabaseControl);

    if (!UnmapFileFromHandle (
            (PBYTE)DatabaseControl->Database,
            DatabaseControl->hMap
            )) {

        return FALSE;
    }

    DatabaseControl->hMap = NULL;
    DatabaseControl->Database = NULL;

    return TRUE;
}

BOOL
pGetTempFileName (
    IN OUT  PSTR FileName,
    IN      BOOL TryCurrent
    )
{
    PCHAR a, b;
    CHAR Extension[6];
    UINT Number = 0;
    HANDLE hFile;

    a = (PCHAR) GetFileNameFromPathA (FileName);
    b = (PCHAR) GetDotExtensionFromPathA (FileName);

    if (!a) {
        a = (PCHAR) GetEndOfStringA (FileName);
    } else if (b && a<b && TryCurrent) {
        //
        // if we have a filename and we want to try the current file,
        // if it is not open, this filename is okay.
        //
        hFile = OpenFileA (FileName, OPEN_ALWAYS);
        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hFile);
            return TRUE;
        }
    }

    if (b) {
        StringCopyA (Extension, b);
        *b = '\0';
    } else {
        b = (PCHAR) GetEndOfStringA (FileName);
        Extension [0] = 0;
    }

    if (a >= b) {       //lint !e613
        a = b;
        *(a++) = 'T';   //lint !e613
    } else {
        a++;            //lint !e613
    }

    if (a+7 == b) {
        b = a;
        while (*b != '\0') {
            if (*b < '0' || *b > '9') {
                break;
            }
            b++;
        }

        if (*b == '\0') {
            Number = (UINT)atoi(a);
            Number++;
        }
    }

    do {
        if (Number > 9999999) {
            return FALSE;
        }

        sprintf (a, "%07lu", Number);
        StringCatA (a, Extension);
        Number++;
        hFile = OpenFileA (FileName, OPEN_ALWAYS);
    } while (hFile == INVALID_HANDLE_VALUE);

    CloseHandle(hFile);

    return TRUE;
}

BOOL
SizeDatabaseBuffer (
    IN      BYTE DatabaseIndex,
    IN      UINT NewSize
    )
/*++
Routine Description:

    SizeDatabaseBuffer will resize the file that backs up the existent allocated
    memory and will remap the file.

Arguments:

    DatabaseIndex - specifies which database we are talking about
    NewSize - specifies the new size of the buffer

Return Value:

    TRUE if the function succeeded, FALSE if not.

--*/

{
    DWORD bytes;
    BOOL resetCurrentDatabase = FALSE;
    PDATABASECONTROL databaseControl;

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        break;
    default:
        return FALSE;
    }
    resetCurrentDatabase = (databaseControl->Database == g_CurrentDatabase);

    MYASSERT(databaseControl->hFile != INVALID_HANDLE_VALUE);

    if (databaseControl->Database) {
        //
        // if we already have a database, unmap current file from memory.
        //
        if (!pUnmapDatabaseFile (databaseControl)) {
            return FALSE;
        }
    }

    if (SetFilePointer(
            databaseControl->hFile,
            0,
            NULL,
            FILE_BEGIN
            ) == INVALID_SET_FILE_POINTER) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot set file pointer"));
        return FALSE;
    }

    if (NewSize) {
        //
        // if size argument is not 0, fix file size indicator at beginning
        //
        if (!WriteFile (databaseControl->hFile, (PBYTE) &NewSize, sizeof (UINT), &bytes, NULL)) {
            return FALSE;
        }
    } else {
        //
        // if size argument is 0, that means look at first UINT in file
        // which is database->allocsize, and size the file to that size
        //
        if (!ReadFile (databaseControl->hFile, (PBYTE) &NewSize, sizeof (UINT), &bytes, NULL)) {
            return FALSE;
        }
    }

    // in the next call, we know that NewSize cannot exceed MAX_MEMDB_SIZE
    // which is 2GB (so casting an unsigned to a signed is safe).
    if (!SetSizeOfFile (databaseControl->hFile, (LONGLONG)NewSize)) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot set size of file"));
        return FALSE;
    }

    //
    // now map file into memory, so everything can use ->Buf for access.
    //
    if (!pMapDatabaseFile(databaseControl)) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot map database file to memory"));
        return FALSE;
    }

    MYASSERT(databaseControl->Database->AllocSize == NewSize);

    if (resetCurrentDatabase) {
        SelectDatabase (DatabaseIndex);
    }

    return TRUE;
}

UINT
DatabaseAllocBlock (
    UINT Size
    )

/*++
Routine Description:

    DatabaseAllocBlock allocates a block of memory in the single
    heap of size Size, expanding it if necessary.
    This function may move the database buffer.  Pointers
    into the database might not be valid afterwards.

Arguments:

    Size - size of block to allocate

Return Value:

    An offset to block that was allocated

--*/

{
    UINT blockSize;
    UINT offset;

    if (Size + g_CurrentDatabase->End + sizeof(DATABASE) > g_CurrentDatabase->AllocSize) {

        if (g_CurrentDatabase->AllocSize >= MAX_MEMDB_SIZE) {

            DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot allocate any more database memory (1)"));
            OutOfMemory_Terminate ();
        }

        blockSize = INIT_BLOCK_SIZE * (1 + (g_CurrentDatabase->AllocSize / (INIT_BLOCK_SIZE*8)));

        if (g_CurrentDatabase->AllocSize + blockSize > MAX_MEMDB_SIZE) {

            blockSize = MAX_MEMDB_SIZE - g_CurrentDatabase->AllocSize;
        }

        if (!SizeDatabaseBuffer (g_CurrentDatabaseIndex, g_CurrentDatabase->AllocSize + blockSize)) {

            DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot allocate any more database memory (2)"));
            OutOfMemory_Terminate ();
        }
    }

    offset = g_CurrentDatabase->End;
    g_CurrentDatabase->End += Size;

    return offset;
}

BOOL
pInitializeDatabase (
    IN      BYTE DatabaseIndex
    )
{
    PDATABASECONTROL databaseControl;

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        StringCopyA (databaseControl->FileName, "p0000000.db");
        StringCopyW (databaseControl->Hive, L"p0000000.db");
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        StringCopyA (databaseControl->FileName, "t0000000.db");
        StringCopyW (databaseControl->Hive, L"t0000000.db");
        break;
    default:
        return FALSE;
    }
    if (!pGetTempFileName (databaseControl->FileName, TRUE)) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot get temporary file name"));
        return FALSE;
    }

    databaseControl->hFile = INVALID_HANDLE_VALUE;
    databaseControl->hMap = NULL;
    databaseControl->Database = NULL;

    databaseControl->hFile = OpenFileA (databaseControl->FileName, CREATE_ALWAYS);

    if ((databaseControl->hFile == INVALID_HANDLE_VALUE) ||
        (databaseControl->hFile == NULL)
        ) {

        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot open database file"));
        return FALSE;

    }

    if ((!SizeDatabaseBuffer (DatabaseIndex, INIT_BLOCK_SIZE)) ||
        (databaseControl->Database == NULL)
        ) {

        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot initialize database"));
        return FALSE;

    }

    databaseControl->Database->End = 0;
    databaseControl->Database->FirstLevelTree = INVALID_OFFSET;
    databaseControl->Database->FirstKeyDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeNodeDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeListElemDeleted = INVALID_OFFSET;

    databaseControl->Database->HashTable = CreateHashBlock();
    MYASSERT (databaseControl->Database->HashTable);

    ZeroMemory (&databaseControl->Database->OffsetBuffer, sizeof (GROWBUFFER));
    databaseControl->Database->OffsetBufferFirstDeletedIndex = INVALID_OFFSET;

    return TRUE;
}

BOOL
pDestroyDatabase (
    IN      BYTE DatabaseIndex
    )
{
    PDATABASECONTROL databaseControl;

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        break;
    default:
        return FALSE;
    }

    //
    // Free all resources for the database
    //
    if (databaseControl->Database) {

        FreeHashBlock (databaseControl->Database->HashTable);
        GbFree (&databaseControl->Database->OffsetBuffer);

        if (!UnmapFile (databaseControl->Database, databaseControl->hMap, databaseControl->hFile)) {

            DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot unmap file"));
        }

        databaseControl->Database = NULL;
    }

    databaseControl->hMap = NULL;
    databaseControl->hFile = INVALID_HANDLE_VALUE;

    DeleteFileA (databaseControl->FileName);

    ZeroMemory (databaseControl, sizeof (DATABASECONTROL));

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        if (g_PermanentDatabaseControl.Database) {
            g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_TEMPORARY;
        } else {
            g_CurrentDatabase = NULL;
            g_CurrentDatabaseIndex = DB_NOTHING;
        }
        break;
    case DB_TEMPORARY:
        if (g_PermanentDatabaseControl.Database) {
            g_CurrentDatabase = g_PermanentDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_PERMANENT;
        } else {
            g_CurrentDatabase = NULL;
            g_CurrentDatabaseIndex = DB_NOTHING;
        }
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
DatabasesInitialize (
    VOID
    )
{
    g_CurrentDatabase = NULL;
    g_CurrentDatabaseIndex = DB_NOTHING;

    //
    // Empty the database memory block
    //
    ZeroMemory (&g_PermanentDatabaseControl, sizeof (DATABASECONTROL));
    if (!pInitializeDatabase (DB_PERMANENT)) {
        return FALSE;
    }
    ZeroMemory (&g_TemporaryDatabaseControl, sizeof (DATABASECONTROL));
    if (!pInitializeDatabase (DB_TEMPORARY)) {
        pDestroyDatabase (DB_PERMANENT);
        return FALSE;
    }

    g_DatabaseInitialized = TRUE;

    SelectDatabase (DB_PERMANENT);

    return TRUE;
}

VOID
DatabasesTerminate (
    VOID
    )
{
    if (g_DatabaseInitialized) {

        //
        // Free all database blocks
        //

        pDestroyDatabase (DB_TEMPORARY);
        pDestroyDatabase (DB_PERMANENT);

        g_CurrentDatabase = NULL;
        g_CurrentDatabaseIndex = DB_NOTHING;
    }
}

PCWSTR
SelectHiveW (
    IN      PCWSTR FullKeyStr
    )
{
    PCWSTR result = FullKeyStr;

    if (FullKeyStr) {

        switch (FullKeyStr[0]) {
        case L'~':
            g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_TEMPORARY;
            result ++;
            break;
        default:
            g_CurrentDatabase = g_PermanentDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_PERMANENT;
        }
    }

    return result;
}

BYTE
GetCurrentDatabaseIndex (
    VOID
    )
{
    return g_CurrentDatabaseIndex;
}


#ifdef DEBUG
#include "bintree.h"

UINT g_DatabaseCheckLevel = 0;

BOOL
CheckDatabase (
    IN      UINT Level
    )
{
    UINT offset,currOffset;
    BOOL deleted;
    PKEYSTRUCT keyStruct, newStruct;
    PDWORD signature;
    UINT blockSize;

    if (Level >= MEMDB_CHECKLEVEL1) {

        // first let's walk the deleted structures making sure that the signature is good
        offset = g_CurrentDatabase->FirstKeyDeleted;

        while (offset != INVALID_OFFSET) {

            keyStruct = GetKeyStructFromOffset (offset);
            MYASSERT (keyStruct);

            if (keyStruct->Signature != KEYSTRUCT_SIGNATURE) {
                DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", offset));
                return FALSE;
            }
            offset = keyStruct->NextDeleted;
        }
    }

    if (Level >= MEMDB_CHECKLEVEL2) {

        // now let's look in the offset array and examine all keystructs pointed from there
        offset = 0;
        while (offset < g_CurrentDatabase->OffsetBuffer.End) {

            // now let's look if offset is deleted or not
            deleted = FALSE;
            currOffset = g_CurrentDatabase->OffsetBufferFirstDeletedIndex;
            while (currOffset != INVALID_OFFSET) {
                if (currOffset == offset) {
                    deleted = TRUE;
                    break;
                }
                currOffset = *(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + currOffset);
            }

            if (!deleted) {

                keyStruct = GetKeyStruct (GET_INDEX (offset));
                if (!keyStruct) {
                    DEBUGMSG ((DBG_ERROR, "Invalid offset found: 0x%8X!", GET_INDEX (offset)));
                    return FALSE;
                }
                if (keyStruct->Signature != KEYSTRUCT_SIGNATURE) {
                    DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", GET_INDEX(offset)));
                    return FALSE;
                }
                if (keyStruct->DataStructIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->DataStructIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->DataStructIndex));
                        return FALSE;
                    }
                }
                if (keyStruct->NextLevelTree != INVALID_OFFSET) {
                    if (!BinTreeCheck (keyStruct->NextLevelTree)) {
                        DEBUGMSG ((DBG_ERROR, "Invalid Binary tree found at offset: 0x%8X", keyStruct->NextLevelTree));
                        return FALSE;
                    }
                }
                if (keyStruct->PrevLevelIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->PrevLevelIndex));
                        return FALSE;
                    }
                }
            }
            offset += SIZEOF (UINT);
        }
    }

    if (Level >= MEMDB_CHECKLEVEL3) {

        // now let's walk the actual database buffer looking for all valid structures stored here
        offset = 0;

        while (offset < g_CurrentDatabase->End) {

            signature = (PDWORD)OFFSET_TO_PTR (offset);

            switch (*signature) {
            case KEYSTRUCT_SIGNATURE:
                if (!FindKeyStructInDatabase (offset)) {
                    DEBUGMSG ((DBG_ERROR, "Could not find KeyStruct (Offset 0x%lX) in database or deleted list!", offset));
                    return FALSE;
                }
                keyStruct = GetKeyStructFromOffset (offset);
                if (keyStruct->DataStructIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->DataStructIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->DataStructIndex));
                        return FALSE;
                    }
                }
                if (keyStruct->NextLevelTree != INVALID_OFFSET) {
                    if (!BinTreeCheck (keyStruct->NextLevelTree)) {
                        DEBUGMSG ((DBG_ERROR, "Invalid Binary tree found at offset: 0x%8X", keyStruct->NextLevelTree));
                        return FALSE;
                    }
                }
                if (keyStruct->PrevLevelIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->PrevLevelIndex));
                        return FALSE;
                    }
                }
                blockSize = keyStruct->Size;
                break;
            case NODESTRUCT_SIGNATURE:
            case BINTREE_SIGNATURE:
            case LISTELEM_SIGNATURE:
                if (!BinTreeFindStructInDatabase (*signature, offset)) {
                    DEBUGMSG ((DBG_ERROR, "Could not find BinTree struct (Offset 0x%lX) in database or deleted list!", offset));
                    return FALSE;
                }
                blockSize = BinTreeGetSizeOfStruct(*signature);
                break;
            default:
                DEBUGMSG ((DBG_ERROR, "Invalid structure found in database buffer!"));
                return FALSE;
            }

            if (blockSize==0) {
                DEBUGMSG ((DBG_ERROR, "Invalid block size found in database buffer!"));
                return FALSE;
            }

            offset += blockSize;
        }
    }
    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\keyfind.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keyfind.c

Abstract:

    Routines that manage finding the memdb key structures.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  split from keystruct.c


--*/

#include "pch.h"
#include "memdbp.h"






UINT
FindKeyStruct (
    PCWSTR Key
    )
/*++

Routine Description:

  FindKeyStruct takes a wack-delimited key string, and returns the Index
  of the keystruct.  this is different than FindKey() because that only
  finds endpoints, so it is fast, because it can use the hash table.
  this recurses down the memdb database levels to the specified keystruct.

Arguments:

  Key                - String holding full path of key to be found

Return Value:

  Index of key, or INVALID_OFFSET if function failed

--*/
{
    UINT TreeOffset, Index=INVALID_OFFSET;
    PWSTR p, q;
    WCHAR Temp[MEMDB_MAX];

    if (*Key==0) {
        return INVALID_OFFSET;
    }
    StringCopyW (Temp, Key);
    q = Temp;

    do {
        if (Index == INVALID_OFFSET) {
            TreeOffset = g_CurrentDatabase->FirstLevelTree;
        } else {
            TreeOffset = GetKeyStruct(Index)->NextLevelTree;
        }

        if (TreeOffset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        p = wcschr (q, L'\\');
        if (p) {
            *p = 0;
        }

        Index = FindKeyStructInTree (TreeOffset, q, FALSE);

        if (Index == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        if (p) {
            q = p + 1;
        }

    } while (p);

    return Index;
}
















UINT
pFindPatternKeyStruct (
    IN      UINT TreeOffset,
    IN OUT  PUINT pTreeEnum,
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  pFindPatternKeyStruct takes a key name and looks for the
  Index in the tree specified by TreeOffset.  The key name must
  not contain backslashes, and the stored key name is
  treated as a pattern.

Arguments:

  TreeOffset - An offset to the tree
  pTreeEnum - The previous value from pFindPatternKeyStruct
               (for enumeration) or INVALID_OFFSET for the first
               call.
  KeyName - The name of the key to find in the binary tree

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;
    UINT KeyIndex;

    MYASSERT(pTreeEnum!=NULL);

    if (*pTreeEnum == INVALID_OFFSET) {
        //
        // if KeyIndex is invalid this is the first search item
        //
        KeyIndex = GetFirstIndex(TreeOffset, pTreeEnum);
    } else {
        //
        // otherwise advance KeyIndex
        //
        KeyIndex = GetNextIndex(pTreeEnum);
    }

    while (KeyIndex != INVALID_OFFSET) {
        //
        // Examine key as a pattern, then go to next node
        //
        KeyStruct = GetKeyStruct(KeyIndex);
        //
        // Compare key (KeyStruct->KeyName is the pattern)
        //

        if (IsPatternMatchCharCountW (
                KeyStruct->KeyName + 1,
                *KeyStruct->KeyName,
                KeyName,
                CharCountW (KeyName)
                )) {
            return KeyIndex;
        }
        //
        // No match yet - go to next node
        //
        KeyIndex = GetNextIndex(pTreeEnum);
    }

    return INVALID_OFFSET;
}




UINT
pFindPatternKeyStructUsingPattern (
    IN      UINT TreeOffset,
    IN OUT  PUINT pTreeEnum,
    IN      PCWSTR PatternStr
    )

/*++

Routine Description:

  pFindPatternKeyStructUsingPattern takes a key pattern and looks
  for the Index in the tree specified by TreeOffset.  The key name
  must not contain backslashes, but can contain wildcards.  The
  wildcards in the stored key are processed as well.

Arguments:

  TreeOffset      - An offset to the tree
  pTreeEnum - The previous value from pFindPatternKeyStructUsingPattern
               (for enumeration) or INVALID_OFFSET for the first
               call.
  KeyName - The name of the key to find in the binary tree

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;
    UINT KeyIndex;

    MYASSERT(pTreeEnum!=NULL);

    if (*pTreeEnum == INVALID_OFFSET) {
        KeyIndex = GetFirstIndex(TreeOffset, pTreeEnum);
    } else {
        KeyIndex = GetNextIndex(pTreeEnum);
    }
    //
    // Examine key as a pattern, then go to next node
    //
    while (KeyIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct(KeyIndex);

        //
        // Compare key (PatternStr is the pattern)
        //
        if (IsPatternMatchCharCountW (
                PatternStr,
                CharCountW (PatternStr),
                KeyStruct->KeyName + 1,
                *KeyStruct->KeyName
                )) {
            return KeyIndex;
        }
        //
        // Compare key (KeyStruct->KeyName is the pattern)
        //
        if (IsPatternMatchCharCountW (
                KeyStruct->KeyName + 1,
                *KeyStruct->KeyName,
                PatternStr,
                CharCountW (PatternStr)
                )) {
            return KeyIndex;
        }

        KeyIndex = GetNextIndex(pTreeEnum);
    }

    return INVALID_OFFSET;
}


UINT
FindKey (
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  FindKey locates a complete key string and returns
  the Index to the KEYSTRUCT, or INVALID_OFFSET if
  the key path does not exist.  The FullKeyPath
  must supply the complete path to the KEYSTRUCT.

Arguments:

  FullKeyPath - A backslash-delimited key path to a value

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    return FindStringInHashTable (g_CurrentDatabase->HashTable, FullKeyPath);
}




UINT
pFindPatternKeyWorker (
    IN      PCWSTR SubKey,
    IN      PCWSTR End,
    IN      UINT TreeOffset,
    IN      BOOL EndPatternAllowed
    )
{
    UINT Index, TreeEnum=INVALID_OFFSET;
    PCWSTR NextSubKey;
    UINT MatchIndex;
    PKEYSTRUCT KeyStruct;

    NextSubKey = GetEndOfStringW (SubKey) + 1;

    // Begin an enumeration of the matches
    Index = pFindPatternKeyStruct (TreeOffset, &TreeEnum, SubKey);

    while (Index != INVALID_OFFSET) {
        //
        // Is there more in the caller's key string to test?
        //

        if (NextSubKey < End) {
            //
            // Yes, call pFindPatternKeyWorker recursively
            //

            MatchIndex = pFindPatternKeyWorker (
                                NextSubKey,
                                End,
                                GetKeyStruct(Index)->NextLevelTree,
                                EndPatternAllowed
                                );

            if (MatchIndex != INVALID_OFFSET) {
                //
                // We found one match.  There may be others, but
                // we return this one.
                //

                return MatchIndex;
            }

        } else {
            //
            // No, if this is an endpoint, return the match.
            //

            KeyStruct = GetKeyStruct (Index);

            if (KeyStruct->KeyFlags & KSF_ENDPOINT) {
                return Index;
            }
        }

        // Continue enumeration
        Index = pFindPatternKeyStruct (TreeOffset, &TreeEnum, SubKey);
    }

    //
    // The normal search failed.  Now we test for an endpoint that has
    // just an asterisk.  If we find one, we return it as our match.
    // This only applies when we have more subkeys, and EndPatternAllowed
    // is TRUE.
    //

    TreeEnum=INVALID_OFFSET;
    if (NextSubKey < End && EndPatternAllowed) {
        // Begin another enumeration of the matches
        Index = pFindPatternKeyStruct (TreeOffset, &TreeEnum, SubKey);

        while (Index != INVALID_OFFSET) {
            //
            // If EndPatternAllowed is TRUE, then test this offset
            // for an exact match with an asterisk.
            //

            KeyStruct = GetKeyStruct (Index);

            if (KeyStruct->KeyFlags & KSF_ENDPOINT) {
                if ((*KeyStruct->KeyName == 1) && (*(KeyStruct->KeyName + 1) == L'*')) {
                    return Index;
                }
            }

            // Continue enumeration
            Index = pFindPatternKeyStruct (TreeOffset, &TreeEnum, SubKey);
        }
    }


    //
    // No match was found
    //

    return INVALID_OFFSET;
}

UINT
FindKeyStructUsingPattern (
    IN      UINT TreeOffset,
    IN OUT  PUINT pTreeEnum,
    IN      PCWSTR PatternStr
    )

/*++

Routine Description:

  FindKeyStructUsingPattern takes a key pattern and looks
  for the Index in the tree specified by TreeOffset.  The key
  name must not contain backslashes, but can contain wildcards.

Arguments:

  TreeOffset - An offset to the tree

  pTreeEnum - The previous value from FindKeyStructUsingPattern
               (for enumeration) or INVALID_OFFSET for the first
               call.

  KeyName - The name of the key to find in the binary tree

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;
    UINT KeyIndex;

    MYASSERT(pTreeEnum!=NULL);

    if (*pTreeEnum == INVALID_OFFSET) {
        KeyIndex = GetFirstIndex(TreeOffset, pTreeEnum);
    } else {
        KeyIndex = GetNextIndex(pTreeEnum);
    }

    //
    // Examine key as a pattern, then go to next node
    //
    while (KeyIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct(KeyIndex);

        if (IsPatternMatchCharCountW (
                PatternStr,
                CharCountW (PatternStr),
                KeyStruct->KeyName + 1,
                *KeyStruct->KeyName
                )) {
            return KeyIndex;
        }
        //
        // No match yet - go to next node
        //
        KeyIndex = GetNextIndex(pTreeEnum);
    }

    return INVALID_OFFSET;
}

#ifdef DEBUG
BOOL FindKeyStructInDatabase(UINT KeyOffset)
{
    PKEYSTRUCT pKey;

    pKey = GetKeyStructFromOffset(KeyOffset);

    if (pKey->KeyFlags & KSF_DELETED) {
        return TRUE;
    }

    while (pKey->PrevLevelIndex!=INVALID_OFFSET) {
        pKey=GetKeyStruct(pKey->PrevLevelIndex);
    }

    return (FindKeyStructInTree(g_CurrentDatabase->FirstLevelTree, pKey->KeyName, TRUE)!=INVALID_OFFSET);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\keystruct.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keystruct.c

Abstract:

    Routines that manage the memdb key structures.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  major restructuring
    jimschm     30-Dec-1998  Hacked in AVL balancing
    jimschm     23-Sep-1998  Proxy nodes, so MemDbMoveTree can replace end nodes too
    jimschm     29-May-1998  Ability to replace center nodes in key strings
    jimschm     21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"
#include "bintree.h"

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e794

UINT g_TotalKeys = 0;

UINT
pAllocKeyStruct (
    IN     PCWSTR KeyName,
    IN     UINT PrevLevelIndex
    )
/*++

Routine Description:

  pAllocKeyStruct allocates a block of memory in the single
  heap, expanding it if necessary.

  The KeyName must not already be in the tree, and
  PrevLevelIndex must point to a valid UINT Index
  variable.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyName - The string identifying the key.  It cannot
            contain backslashes.  The new struct will
            be initialized and this name will be copied
            into the struct.

  PrevLevelIndex - Specifies the previous level root Index

Return Value:

  An Index to the new structure.

--*/

{
    UINT size;
    PKEYSTRUCT KeyStruct = NULL;
    UINT Offset;
    UINT PrevDel;
    UINT TreeOffset;
    UINT Index;

    size = SizeOfStringW (KeyName) + KEYSTRUCT_SIZE;

    //
    // Look for free block
    //

    PrevDel = INVALID_OFFSET;
    Offset = g_CurrentDatabase->FirstKeyDeleted;

    while (Offset != INVALID_OFFSET) {
        KeyStruct = GetKeyStructFromOffset(Offset);
        MYASSERT(KeyStruct);
        if (KeyStruct->Size >= size && KeyStruct->Size < (size + ALLOC_TOLERANCE)) {
            break;
        }

        PrevDel = Offset;
        Offset = KeyStruct->NextDeleted;
    }

    if (Offset == INVALID_OFFSET) {
        //
        // Alloc new block if no free space
        //

		g_TotalKeys ++;

        Offset = DatabaseAllocBlock (size);

#ifdef DEBUG
        //
        // if we are in debug mode, and we are using debug structs, set
        // pointer normally and set Signature DWORD.  if we are not using
        // debug structs, then set pointer to 4 bytes below actual offset,
        // so all members are shifted down.
        //
        if (g_UseDebugStructs) {
            KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset);
            KeyStruct->Signature = KEYSTRUCT_SIGNATURE;
        } else {
            KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset - KEYSTRUCT_HEADER_SIZE);
        }
#else
        KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset);
#endif

        KeyStruct->Size = size;
    } else {
        //
        // Delink free block if recovering free space
        //

        if (PrevDel != INVALID_OFFSET) {
            GetKeyStructFromOffset(PrevDel)->NextDeleted = KeyStruct->NextDeleted;
        } else {
            g_CurrentDatabase->FirstKeyDeleted = KeyStruct->NextDeleted;
        }
#ifdef DEBUG
        KeyStruct->KeyFlags &= ~KSF_DELETED;
#endif
    }

    //
    // Init new block
    //
    KeyStruct->DataStructIndex = INVALID_OFFSET;
    KeyStruct->NextLevelTree = INVALID_OFFSET;
    KeyStruct->PrevLevelIndex = PrevLevelIndex;
    KeyStruct->Value = 0;
    KeyStruct->KeyFlags = 0;
    KeyStruct->DataFlags = 0;
    StringPasCopyConvertTo (KeyStruct->KeyName, KeyName);

    Index = AddKeyOffsetToBuffer(Offset);

    //
    // Put it in the tree
    //
    TreeOffset = (KeyStruct->PrevLevelIndex == INVALID_OFFSET) ?
                    g_CurrentDatabase->FirstLevelTree :
                    GetKeyStruct(KeyStruct->PrevLevelIndex)->NextLevelTree;
    if (TreeOffset == INVALID_OFFSET) {
        TreeOffset = BinTreeNew();
        if (PrevLevelIndex == INVALID_OFFSET) {
            g_CurrentDatabase->FirstLevelTree = TreeOffset;
        } else {
            GetKeyStruct(PrevLevelIndex)->NextLevelTree = TreeOffset;
        }
    }
    BinTreeAddNode(TreeOffset, Index);

    return Index;
}
//lint -restore

UINT
pNewKey (
    IN  PCWSTR KeyStr,
    IN  BOOL Endpoint
    )

/*++

Routine Description:

  NewKey allocates a key struct off our heap, and links it into the binary
  tree.  KeyStr must be a full key path, and any part of the path that does
  not exist will be created.  KeyStr must not already exist (though parts
  of it can exist).

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyStr - The full path to the value, separated by backslashes.
           Each string between backslashes will cause a key
           struct to be allocated and linked.  Some of the
           structs may already have been allocated.

  Endpoint - Specifies TRUE if new node is an endpoint, or FALSE if
             it is not.

Return Value:

  An Index to the last node of the new structure, or
  INVALID_OFFSET if the key could not be allocated.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    UINT Index, ThisLevelTree;
    PKEYSTRUCT KeyStruct;
    UINT PrevLevelIndex;
    BOOL NewNodeCreated = FALSE;

    StringCopyW (Path, KeyStr);
    End = Path;
    ThisLevelTree = g_CurrentDatabase->FirstLevelTree;
    PrevLevelIndex = INVALID_OFFSET;

    do  {
        // Split string at backslash
        Start = End;
        p = wcschr (End, L'\\');
        if (p) {
            End = p + 1;
            *p = 0;
        }
        else
            End = NULL;

        // Look in tree for key
        if (!NewNodeCreated) {
            Index = FindKeyStructInTree (ThisLevelTree, Start, FALSE);
        } else {
            Index = INVALID_OFFSET;
        }

        if (Index == INVALID_OFFSET) {
            // Add a new key if it was not found
            Index = pAllocKeyStruct (Start, PrevLevelIndex);
            if (Index == INVALID_OFFSET) {
                return INVALID_OFFSET;
            }


            NewNodeCreated = TRUE;
        }

        // Continue to next level
        KeyStruct = GetKeyStruct (Index);
        PrevLevelIndex = Index;
        ThisLevelTree = KeyStruct->NextLevelTree;
    } while (End);

    if (Endpoint) {
        if (!(KeyStruct->KeyFlags & KSF_ENDPOINT)) {
            NewNodeCreated = TRUE;
        }

        KeyStruct->KeyFlags |= KSF_ENDPOINT;

        if (NewNodeCreated) {
            (void)AddHashTableEntry (g_CurrentDatabase->HashTable, KeyStr, Index);
        }
    }
    return Index;
}

UINT
NewKey (
    IN  PCWSTR KeyStr
    )
/*++

Routine Description:

  creates a new key that is an endpoint.

Arguments:

  KeyStr - The string identifying the key.

Return Value:

  An Index to the new structure.

--*/
{
    return pNewKey (KeyStr, TRUE);
}

UINT
NewEmptyKey (
    IN  PCWSTR KeyStr
    )
/*++

Routine Description:

  creates an empty new key that is NOT an endpoint.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyStr - The string identifying the key.

Return Value:

  An Index to the new structure.

--*/
{
    return pNewKey (KeyStr, TRUE);
}






VOID
pRemoveKeyFromTree (
    IN      PKEYSTRUCT pKey
    )
{
    BOOL LastNode;
    PUINT pTreeOffset;
    MYASSERT(pKey);
    if (pKey->PrevLevelIndex==INVALID_OFFSET) {
        pTreeOffset = &g_CurrentDatabase->FirstLevelTree;
    } else {
        pTreeOffset = &GetKeyStruct(pKey->PrevLevelIndex)->NextLevelTree;
    }

    MYASSERT(*pTreeOffset!=INVALID_OFFSET);
    BinTreeDeleteNode (*pTreeOffset, pKey->KeyName, &LastNode);
    if (LastNode) {
        BinTreeDestroy(*pTreeOffset);
        *pTreeOffset = INVALID_OFFSET;
    }
}


VOID
pDeallocKeyStruct (
    IN      UINT Index,
    IN      BOOL ClearFlag,
    IN      BOOL DelinkFlag,
    IN      BOOL FreeIndexFlag
    )

/*++

Routine Description:

  pDeallocKeyStruct first deletes all structures pointed to by
  NextLevelTree.  After all items are deleted from the next
  level, pDeallocKeyStruct optionally delinks the struct from
  the binary tree.  Before exiting, the struct is given to the
  deleted block chain.

Arguments:

  Index       - An index in g_CurrentDatabase->OffsetBuffer
  ClearFlag   - Specifies TRUE if the key struct's children are to
                be deleted, or FALSE if the current key struct should
                simply be cleaned up but left allocated.
  DelinkFlag  - A flag indicating TRUE to delink the struct from
                the binary tree it is in, or FALSE if the struct is
                only to be added to the deleted block chain.
  FreeIndexFlag - This argument is only used if ClearFlag is true.
                It is FALSE if we do not want to free the index in
                g_CurrentDatabase->OffsetBuffer (i.e., we are moving the key and we do
                not want to deallocate the space in the buffer), or
                TRUE if we are just deleting the key, so we no longer
                need the g_CurrentDatabase->OffsetBuffer space at Index.

Return Value:

  none

--*/

{
    PKEYSTRUCT KeyStruct;
    UINT KeyIndex, TreeEnum;
    WCHAR TempStr[MEMDB_MAX];
    PUINT linkageList;
    UINT linkageSize;
    BYTE instance;
    BYTE oldDbIndex;

    KeyStruct = GetKeyStruct (Index);

    if (FreeIndexFlag && (KeyStruct->DataFlags & DATAFLAG_DOUBLELINK)) {
        //
        // we have some double linkage here. Let's go to the other
        // key and remove the linkage that points to this one
        //

        for (instance = 0; instance <= DATAFLAG_INSTANCEMASK; instance ++) {

            // First, retrieve the linkage list
            linkageSize = 0;
            linkageList = (PUINT) KeyStructGetBinaryData (
                                        Index,
                                        DATAFLAG_DOUBLELINK,
                                        instance,
                                        &linkageSize
                                        );
            if (linkageList) {

                oldDbIndex = g_CurrentDatabaseIndex;

                while (linkageSize) {

                    SelectDatabase (GET_DATABASE (*linkageList));

                    KeyStructDeleteLinkage (
                        GET_INDEX (*linkageList),
                        DATAFLAG_DOUBLELINK,
                        instance,
                        GET_EXTERNAL_INDEX (Index),
                        FALSE
                        );

                    linkageSize -= SIZEOF (UINT);
                    linkageList ++;

                    if (linkageSize < SIZEOF (UINT)) {
                        break;
                    }
                }

                SelectDatabase (oldDbIndex);
            }
        }
    }

    if (KeyStruct->KeyFlags & KSF_ENDPOINT) {
        //
        // Remove endpoints from hash table and free key data
        //
        if (PrivateBuildKeyFromIndex (0, Index, TempStr, NULL, NULL, NULL)) {
            RemoveHashTableEntry (g_CurrentDatabase->HashTable, TempStr);
        }

        KeyStructFreeAllData (KeyStruct);
        KeyStruct->KeyFlags &= ~KSF_ENDPOINT;
    }

    if (ClearFlag) {
        //
        // Call recursively if there are sublevels to this key
        //
        if (KeyStruct->NextLevelTree != INVALID_OFFSET) {

            KeyIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

            while (KeyIndex != INVALID_OFFSET) {
                pDeallocKeyStruct (KeyIndex, TRUE, FALSE, FreeIndexFlag);
                KeyIndex = GetNextIndex (&TreeEnum);
            }

            BinTreeDestroy(KeyStruct->NextLevelTree);
        }

        //
        // Remove the item from its binary tree
        //
        if (DelinkFlag) {
            pRemoveKeyFromTree(KeyStruct);
        }

        //
        // Donate block to free space unless caller does not
        // want child structs freed.
        //

        KeyStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
        g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset(Index);
#ifdef DEBUG
        KeyStruct->KeyFlags |= KSF_DELETED;
#endif

        if (FreeIndexFlag) {
            RemoveKeyOffsetFromBuffer(Index);
        }
    }
}

BOOL
PrivateDeleteKeyByIndex (
    IN      UINT Index
    )

/*++

Routine Description:

  PrivateDeleteKeyByIndex will completely destroy the key struct
  that Index points to (along with all sub-levels. Furthermore,
  it goes back recursively and removes the parent structures as well
  if they no longer have a child (the current one was the only one).

Arguments:

  Index     - Index of the key structure.

Return Value:

  TRUE if successfull, FALSE otherwise

--*/

{
    PKEYSTRUCT keyStruct;
    UINT prevLevelIndex;
    BOOL result = TRUE;

    keyStruct = GetKeyStruct (Index);

    prevLevelIndex = keyStruct->PrevLevelIndex;

    pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);

    if (prevLevelIndex != INVALID_OFFSET) {

        keyStruct = GetKeyStruct (prevLevelIndex);

        if (keyStruct->NextLevelTree != INVALID_OFFSET) {

            result = PrivateDeleteKeyByIndex (prevLevelIndex);
        }
    }

    return result;
}

BOOL
DeleteKey (
    IN      PCWSTR KeyStr,
    IN      UINT TreeOffset,
    IN      BOOL MustMatch
    )

/*++

Routine Description:

  DeleteKey takes a key path and puts the key struct in the deleted
  block chain.  Any sub-levels are deleted as well.

Arguments:

  KeyStr     - The full path to the value, separated by backslashes.
  TreeOffset    - A pointer to the level's binary tree root variable.
  MustMatch  - A flag indicating if the delete only applies to
               end points or if any matching struct is to be deleted.
               TRUE indicates only endpoints can be deleted.

Return Value:

  none

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    UINT Index, NextIndex, TreeEnum=INVALID_OFFSET;
    PKEYSTRUCT KeyStruct;

    StringCopyW (Path, KeyStr);
    End = Path;

    //
    // Split string at backslash
    //

    Start = End;
    p = wcschr (End, L'\\');
    if (p) {
        End = p + 1;
        *p = 0;

    } else {
        End = NULL;
    }

    //
    // Look at this level for the very first key
    //

    Index = FindKeyStructUsingPattern (TreeOffset, &TreeEnum, Start);

    //
    // If this is the last level, delete the matching keys
    // (may need to be endpoints if MustMatch is TRUE)
    //

    if (!End) {
        while (Index != INVALID_OFFSET) {
            KeyStruct = GetKeyStruct (Index);
            NextIndex = FindKeyStructUsingPattern (TreeOffset, &TreeEnum, Start);

            //
            // If must match and lower levels exist, don't delete, just turn
            // off the endpoint flag
            //

            if (MustMatch && KeyStruct->NextLevelTree != INVALID_OFFSET) {
                // Call to clean up, not to delink or recurse
                pDeallocKeyStruct (Index, FALSE, FALSE, FALSE);
            }

            //
            // Else delete the struct if an endpoint or don't care about
            // endpoints
            //

            else if (!MustMatch || (KeyStruct->KeyFlags & KSF_ENDPOINT)) {
                // Call to free the entire key struct and all children
                pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);
            }

            Index = NextIndex;
        }
    }

    //
    // Otherwise recursively examine next level for each match
    //

    else {
        while (Index != INVALID_OFFSET) {
            //
            // Delete all matching subkeys
            //

            NextIndex = FindKeyStructUsingPattern (TreeOffset, &TreeEnum, Start);
            KeyStruct = GetKeyStruct (Index);
            DeleteKey (End, KeyStruct->NextLevelTree, MustMatch);

            //
            // If this is not an endpoint and has no children, delete it
            //

            if (KeyStruct->NextLevelTree == INVALID_OFFSET &&
                !(KeyStruct->KeyFlags & KSF_ENDPOINT)
                ) {
                // Call to free the entire key struct
                pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);
            }

            //
            // Continue looking in this level for another match
            //

            Index = NextIndex;
        }
    }

    return TRUE;
}




VOID
pRemoveHashEntriesForNode (
    IN      PCWSTR Root,
    IN      UINT Index
    )

/*++

Routine Description:

  pRemoveHashEntriesFromNode removes all hash table entries from all children
  of the specified node.  This function is called recursively.

Arguments:

  Root   - Specifies the root string that corresponds with Index.  This must
           also contain the temporary hive root.
  Index - Specifies the Index of the node to process.  The node and all of
           its children will be removed from the hash table.

Return Value:

  None.

--*/

{
    UINT ChildIndex, TreeEnum;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;

    //
    // Remove hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Index);

    if (KeyStruct->KeyFlags & KSF_ENDPOINT) {
        RemoveHashTableEntry (g_CurrentDatabase->HashTable, Root);

#ifdef DEBUG
        {
            UINT HashIndex;

            HashIndex = FindStringInHashTable (g_CurrentDatabase->HashTable, Root);
            if (HashIndex != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb move duplicate: %s", Root));
            }
        }
#endif
    }

    //
    // Recurse for all children, removing hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

    while (ChildIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (ChildIndex);
        StringPasCopyConvertFrom (End, KeyStruct->KeyName);
        pRemoveHashEntriesForNode (ChildRoot, ChildIndex);

        ChildIndex = GetNextIndex(&TreeEnum);
    }
}


VOID
pAddHashEntriesForNode (
    IN      PCWSTR Root,
    IN      UINT Index,
    IN      BOOL AddRoot
    )

/*++

Routine Description:

  pAddHashEntriesForNode adds hash table entries for the specified root and
  all of its children.

Arguments:

  Root    - Specifies the root string that corresponds to Index.  This string
            must also include the temporary hive root.
  Index  - Specifies the node Index to begin processing.  The node and all
            of its children are added to the hash table.
  AddRoot - Specifies TRUE if the root should be added to the hash table,
            FALSE otherwise.


Return Value:

  None.

--*/

{
    UINT ChildIndex, TreeEnum;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;
    UINT HashIndex;

    //
    // Add hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Index);

    if (AddRoot && KeyStruct->KeyFlags & KSF_ENDPOINT) {

        HashIndex = FindStringInHashTable (g_CurrentDatabase->HashTable, Root);

        if (HashIndex != Index) {

#ifdef DEBUG
            if (HashIndex != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb duplicate: %s", Root));
            }
#endif

            AddHashTableEntry (g_CurrentDatabase->HashTable, Root, Index);
        }
    }

    //
    // Recurse for all children, adding hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

    while (ChildIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct(ChildIndex);
        StringPasCopyConvertFrom (End, KeyStruct->KeyName);
        pAddHashEntriesForNode(ChildRoot, ChildIndex, TRUE);

        ChildIndex = GetNextIndex(&TreeEnum);
    }
}

#ifdef DEBUG
//
// in non-DEBUG mode, GetKeyStructFromOffset
// and GetKeyStruct are implemented as macros
//

PKEYSTRUCT
GetKeyStructFromOffset (
    IN UINT Offset
    )
/*++

Routine Description:

  GetKeyStruct returns a pointer given an Offset.  The debug version
  checks the signature and validity of each Index.  It is assumed that
  Offset is always valid.

Arguments:

  Offset - Specifies the Offset to the node

Return Value:

  The pointer to the node.

--*/
{
    PKEYSTRUCT KeyStruct;

    if (Offset == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in GetKeyStruct at offset %u", Offset));
        return NULL;
    }
    if (!g_CurrentDatabase) {
        DEBUGMSG ((DBG_ERROR, "Attempt to access non-existent buffer at %u", Offset));
        return NULL;
    }
    if (Offset > g_CurrentDatabase->End) {
        DEBUGMSG ((DBG_ERROR, "Access beyond length of buffer in GetKeyStruct (offset %u)", Offset));
        return NULL;
    }

    if (!g_UseDebugStructs) {
        KeyStruct = (PKEYSTRUCT) OFFSET_TO_PTR (Offset - KEYSTRUCT_HEADER_SIZE);
        return KeyStruct;
    }

    KeyStruct = (PKEYSTRUCT) OFFSET_TO_PTR (Offset);
    if (KeyStruct->Signature != KEYSTRUCT_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Signature does not match in GetKeyStruct at offset %u!", Offset));
        return NULL;
    }

    return KeyStruct;
}


PKEYSTRUCT
GetKeyStruct (
    IN UINT Index
    )
/*++

Routine Description:

  GetKeyStruct returns a pointer given an Index.  The debug version
  checks the signature and validity of each Index.  It is assumed that Index
  is always valid.

Arguments:

  Index - Specifies the Index to the node

Return Value:

  The pointer to the node.

--*/
{
    UINT Offset;
    if (Index == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in GetKeyStruct at index %u", Index));
        return NULL;
    }

    Offset = KeyIndexToOffset(Index);
    if (Offset == INVALID_OFFSET) {
        return NULL;
    }
    return GetKeyStructFromOffset(Offset);
}


#endif











BOOL
PrivateBuildKeyFromIndex (
    IN      UINT StartLevel,               // zero-based
    IN      UINT TailIndex,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PUINT ValPtr,                   OPTIONAL
    OUT     PUINT UserFlagsPtr,             OPTIONAL
    OUT     PUINT Chars                     OPTIONAL
    )

/*++

Routine Description:

  PrivateBuildKeyFromIndex generates the key string given an Index.  The
  caller can specify the start level to skip root nodes.  It is assumed that
  TailIndex is always valid.

Arguments:

  StartLevel   - Specifies the zero-based level to begin building the key
                 string.  This is used to skip the root portion of the key
                 string.
  TailIndex    - Specifies the Index to the last level of the key string.
  Buffer       - Receives the key string, must be able to hold MEMDB_MAX
                 characters.
  ValPtr       - Receives the key's value
  UserFlagsPtr - Receives the user flags
  Chars        - Receives the number of characters in Buffer

Return Value:

  TRUE if the key was build properly, FALSE otherwise.

--*/

{
    static UINT Indices[MEMDB_MAX];
    PKEYSTRUCT KeyStruct;
    UINT CurrentIndex;
    UINT IndexEnd;
    UINT IndexStart;
    register PWSTR p;

    //
    // Build string
    //

    IndexEnd = MEMDB_MAX;
    IndexStart = MEMDB_MAX;

    CurrentIndex = TailIndex;
    while (CurrentIndex != INVALID_OFFSET) {
        //
        // Record offset
        //
        IndexStart--;
        Indices[IndexStart] = CurrentIndex;

        //
        // Dec for start level and go to parent
        //
        KeyStruct = GetKeyStruct (CurrentIndex);
        if (!KeyStruct) {
            return FALSE;
        }
        CurrentIndex = KeyStruct->PrevLevelIndex;
    }

    //
    // Filter for "string is not long enough"
    //
    IndexStart += StartLevel;
    if (IndexStart >= IndexEnd) {
        return FALSE;
    }

    //
    // Transfer node's value and flags to caller's variables
    //

    if (ValPtr) {
        KeyStructGetValue (GetKeyStruct(TailIndex), ValPtr);
    }
    if (UserFlagsPtr) {
        KeyStructGetFlags (GetKeyStruct(TailIndex), UserFlagsPtr);
    }

    //
    // Copy each piece of the string to Buffer and calculate character count
    //
    if (Buffer) {
        p = Buffer;
        for (CurrentIndex = IndexStart ; CurrentIndex < IndexEnd ; CurrentIndex++) {
            KeyStruct = GetKeyStruct (Indices[CurrentIndex]);
            CopyMemory(p, KeyStruct->KeyName + 1, *KeyStruct->KeyName * sizeof(WCHAR));
            p += *KeyStruct->KeyName;
            *p++ = L'\\';
        }
        p--;
        *p = 0;

        if (Chars) {
            *Chars = (UINT)(((UBINT)p - (UBINT)Buffer) / sizeof (WCHAR));
        }

    } else if (Chars) {
        *Chars = 0;

        for (CurrentIndex = IndexStart ; CurrentIndex < IndexEnd ; CurrentIndex++) {
            KeyStruct = GetKeyStruct (Indices[CurrentIndex]);
            *Chars += StringPasCharCount(KeyStruct->KeyName) + 1;
        }

        *Chars -= 1;
    }

    return TRUE;
}



BOOL
KeyStructSetInsertionOrdered (
    IN      PKEYSTRUCT pKey
    )

/*++
Routine Description:

  KeyStructSetInsertionOrdered sets the enumeration order of the children
  of Key to be in the order they were inserted.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    return BinTreeSetInsertionOrdered(pKey->NextLevelTree);
}





UINT
GetFirstIndex (
    IN      UINT TreeOffset,
    OUT     PUINT pTreeEnum
    )

/*++

Routine Description:

  GetFirstIndex walks down the left side of the binary tree
  pointed to by TreeOffset, and returns the left-most node.

Arguments:

  TreeOffset    - An offset to the root of the tree
  TreeEnum      - a pointer to a UINT which will hold enumeration
                  information for future calls of GetNextIndex

Return Value:

  An Index to the leftmost structure, or INVALID_OFFSET if the
  root was invalid.

--*/


{
    return BinTreeEnumFirst(TreeOffset, pTreeEnum);
}


UINT
GetNextIndex (
    IN OUT      PUINT pTreeEnum
    )

/*++

Routine Description:

  GetNextIndex traverses the binary tree in order.

Arguments:

  TreeEnum   - Enumerator filled by GetFirstIndex which
               will be changed by this function

Return Value:

  An Index to the next structure, or INVALID_OFFSET if the
  end is reached.

--*/

{
    return BinTreeEnumNext(pTreeEnum);
}



UINT KeyStructGetChildCount (
    IN      PKEYSTRUCT pKey
    )
{
    if (!pKey) {
        return 0;
    }
    return BinTreeSize(pKey->NextLevelTree);
}



UINT
FindKeyStructInTree (
    IN UINT TreeOffset,
    IN PWSTR KeyName,
    IN BOOL IsPascalString
    )

/*++

Routine Description:

  FindKeyStructInTree takes a key name and looks for the
  Index in the tree specified by TreeOffset.  The key
  name must not contain backslashes.

Arguments:

  TreeOffset - An offset to the root of the level

  KeyName - The name of the key to find in the binary tree
        (not the full key path; just the name of this level).

  IsPascalString - TRUE if string is in pascal format (char
        count is first WCHAR, no null terminator) otherwise FALSE

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    UINT Index;
    if (!IsPascalString) {
        StringPasConvertTo(KeyName);
    }
    Index = BinTreeFindNode(TreeOffset, KeyName);
    if (!IsPascalString) {
        StringPasConvertFrom(KeyName);
    }
    return Index;
}












#ifdef DEBUG

BOOL
CheckLevel(UINT TreeOffset,
            UINT PrevLevelIndex
            )
{
    PKEYSTRUCT pKey;
    UINT KeyIndex, TreeEnum;
    WCHAR key[MEMDB_MAX];

    if (TreeOffset==INVALID_OFFSET) {
        return TRUE;
    }
    BinTreeCheck(TreeOffset);

#if MEMDB_VERBOSE
    if (PrevLevelIndex!=INVALID_OFFSET) {
        wprintf(L"children of %.*s:\n",*GetKeyStruct(PrevLevelIndex)->KeyName,GetKeyStruct(PrevLevelIndex)->KeyName+1);
    } else {
        printf("top level children:\n");
    }

    BinTreePrint(TreeOffset);
#endif

    if ((KeyIndex=BinTreeEnumFirst(TreeOffset,&TreeEnum))!=INVALID_OFFSET) {
        do {
            pKey=GetKeyStruct(KeyIndex);

            if (pKey->PrevLevelIndex!=PrevLevelIndex) {
                wprintf(L"MemDbCheckDatabase: PrevLevelIndex of Keystruct %s incorrect!", StringPasCopyConvertFrom (key, pKey->KeyName));
            }

            if (!CheckLevel(pKey->NextLevelTree, KeyIndex)) {
                wprintf(L"Child tree of %s bad!\n", StringPasCopyConvertFrom (key, pKey->KeyName));
            }

        } while ((KeyIndex=BinTreeEnumNext(&TreeEnum))!=INVALID_OFFSET);
    } else {
        printf("MemDbCheckDatabase: non-null binary tree has no children!");
        return FALSE;
    }
    return TRUE;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\memdbex.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbex.c

Abstract:

    Extensions to use the memdb tree like a relational database

Author:

    Jim Schmidt (jimschm) 2-Dec-1996

Revision History:

    mvander     13-Aug-1999 many changes
    jimschm     23-Sep-1998 Expanded user flags to 24 bits (from
                            12 bits), removed AnsiFromUnicode
    jimschm     21-Oct-1997 Cleaned up a little
    marcw       09-Apr-1997 Added MemDbGetOffset* functions.
    jimschm     17-Jan-1997 All string params can be NULL now
    jimschm     18-Dec-1996 Added GetEndpointValue functions

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\pch\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\pch\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\memdbp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbp.h

Abstract:

    internal functions for memdb operations

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/


//
// Macros
//

//
// database types
//
#define DB_NOTHING          0x00
#define DB_PERMANENT        0x01
#define DB_TEMPORARY        0x02

#ifdef DEBUG

#define PTR_WAS_INVALIDATED(x)          (x=NULL)

#else

#define PTR_WAS_INVALIDATED(x)

#endif

//
// signatures for different memory structures.
//
#define KEYSTRUCT_SIGNATURE         ('K'+('E'<<8)+('E'<<16)+('Y'<<24))
#define DATABLOCK_SIGNATURE         ('B'+('L'<<8)+('O'<<16)+('K'<<24))
#define NODESTRUCT_SIGNATURE        ('N'+('O'<<8)+('D'<<16)+('E'<<24))
#define BINTREE_SIGNATURE           ('T'+('R'<<8)+('E'<<16)+('E'<<24))
#define LISTELEM_SIGNATURE          ('L'+('I'<<8)+('S'<<16)+('T'<<24))


#define MEMDB_VERBOSE   0


//
// KEYSTRUCT flags
//

#define KSF_ENDPOINT        0x01
#define KSF_DATABLOCK       0x02

//
// we only need this flag for easier checking
// of keys, in FindKeyStructInDatabase()
//
#ifdef DEBUG
#define KSF_DELETED         0x04
#endif






//
// database allocation parameters
//

#define ALLOC_TOLERANCE 32

#define MAX_HIVE_NAME       64


//
// Typedefs
//

typedef struct {
    UINT Size;
    UINT End;
    UINT FreeHead;
    PBYTE Buf;
} MEMDBHASH, *PMEMDBHASH;



//
//
// The DATABASE structure holds all pieces of information necessary
// to maintain a portion of the overall memory database.  There are
// two DATABASE structures, a permanent and a temporary one.
//

typedef struct {
    UINT AllocSize;
    UINT End;
    UINT FirstLevelTree;
    UINT FirstKeyDeleted;          // this stores the Offset of the key, not the Index
    UINT FirstBinTreeDeleted;
    UINT FirstBinTreeNodeDeleted;
    UINT FirstBinTreeListElemDeleted;
    PMEMDBHASH HashTable;
    GROWBUFFER OffsetBuffer;
    UINT OffsetBufferFirstDeletedIndex;
    BYTE Buf[];
} DATABASE, *PDATABASE;



//
// Globals - defined in database.c
//

extern PDATABASE g_CurrentDatabase;
extern BYTE g_CurrentDatabaseIndex;
extern OUR_CRITICAL_SECTION g_MemDbCs;

#ifdef DEBUG
extern BOOL g_UseDebugStructs;
#endif




#define OFFSET_TO_PTR(Offset)   (g_CurrentDatabase->Buf+(Offset))
#define PTR_TO_OFFSET(Ptr)      (UINT)((UBINT)(Ptr)-(UBINT)(g_CurrentDatabase->Buf))



//
// GET_EXTERNAL_INDEX converts an internal index and converts it to a key or data handle (has database number as top byte).
// GET_DATABASE takes a key or data handle and returns the database number byte
// GET_INDEX takes a key or data handle and returns the index without the database number
//
#define GET_EXTERNAL_INDEX(Index) ((Index) | ((UINT)(g_CurrentDatabaseIndex) << (8*sizeof(UINT)-8)))
#define GET_DATABASE(Index) ((BYTE)((Index) >> (8*sizeof(UINT)-8)))
#define GET_INDEX(Index) ((Index) & (INVALID_OFFSET>>8))




//
// a KEYSTRUCT holds each piece of a memdb entry.  A single KEYSTRUCT
// holds a portion of a key (delimited by a backslash), and the
// KEYSTRUCTs are organized into a binary tree.  Each KEYSTRUCT
// can also contain additional binary trees.  This is what makes
// memdb so versatile--many relationships can be established by
// formatting key strings in various ways.
//
// when changing offset of KeyName in KEYSTRUCT (by adding new members
// or resizing or reordering, etc) be sure to change constant in
// GetDataStr macro below (currently (3*sizeof(UINT)+4)).


typedef struct {
#ifdef DEBUG
    DWORD Signature;
#endif

    union {
        UINT Value;                // value of key
        UINT DataSize;             // size of the actual data (if this is a data structure
        UINT NextDeleted;          // for deleted items, we keep a list of free blocks
    };

    UINT Flags;                    // key flags

    UINT DataStructIndex;          // offset of Data structure holding the binary data
    UINT NextLevelTree;            // offset of bintree holding next level keystructs
    UINT PrevLevelIndex;           // index of previous level keystruct

    UINT Size;                     // size of block (maybe not all of it is used)
    BYTE KeyFlags;
    BYTE DataFlags;

    union {
        WCHAR KeyName[];           // name of key (just this level, not full key)
        BYTE Data[];               // Binary data stored in this keystruct
    };
} KEYSTRUCT, *PKEYSTRUCT;

#define KEYSTRUCT_SIZE_MAIN ((WORD)(5*sizeof(UINT) + sizeof(UINT) + 2*sizeof(BYTE)))

#ifdef DEBUG
#define KEYSTRUCT_HEADER_SIZE   sizeof(DWORD)
#define KEYSTRUCT_SIZE      (KEYSTRUCT_SIZE_MAIN + \
                            (WORD)(g_UseDebugStructs ? KEYSTRUCT_HEADER_SIZE : 0))
#else
#define KEYSTRUCT_SIZE      KEYSTRUCT_SIZE_MAIN
#endif

//
// GetDataStr is used by the bintree.c functions to get
// the data string inside a data element, to be used for
// ordering in the tree.  For us, the data type is
// a KeyStruct.
//
#define GetDataStr(DataIndex) ((PWSTR)(OFFSET_TO_PTR(KeyIndexToOffset(DataIndex)+KEYSTRUCT_SIZE)))












//
// hash.c routines
//

PMEMDBHASH
CreateHashBlock (
    VOID
    );

VOID
FreeHashBlock (
    IN      PMEMDBHASH pHashTable
    );

BOOL
ReadHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    );

BOOL
WriteHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    );

UINT
GetHashTableBlockSize (
    IN      PMEMDBHASH pHashTable
    );

BOOL
AddHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    IN      UINT Offset
    );

UINT
FindStringInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    );

BOOL
RemoveHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    );



//
// memdbfile.c
//



#define OpenFileA(FileName, OpenMethod) CreateFileA(                        \
                                            FileName,                       \
                                            GENERIC_READ|GENERIC_WRITE,     \
                                            0,                              \
                                            NULL,                           \
                                            OpenMethod,                     \
                                            FILE_ATTRIBUTE_NORMAL,          \
                                            NULL                            \
                                            )

BOOL
SetSizeOfFile (
    HANDLE hFile,
    LONGLONG Size
    );

PBYTE
MapFileFromHandle (
    HANDLE hFile,
    PHANDLE hMap
    );

#define UnmapFileFromHandle(Buf, hMap) UnmapFile(Buf, hMap, INVALID_HANDLE_VALUE)





//
// database.c
//


BOOL
DatabasesInitialize (
    VOID
    );

VOID
DatabasesTerminate (
    VOID
    );

BOOL
SizeDatabaseBuffer (
    IN      BYTE DatabaseIndex,
    IN      UINT NewSize
    );

UINT
DatabaseAllocBlock (
    IN      UINT Size
    );

BOOL
SelectDatabase (
    IN      BYTE DatabaseIndex
    );

PCWSTR
SelectHiveW (
    IN      PCWSTR FullKeyStr
    );

BYTE
GetCurrentDatabaseIndex (
    VOID
    );

#ifdef DEBUG

BOOL
CheckDatabase (
    IN      UINT Level
    );

#endif


//
// offsetbuf.c
//

VOID
RedirectKeyIndex (
    IN      UINT Index,
    IN      UINT TargetIndex
    );

UINT
KeyIndexToOffset (
    IN  UINT Index
    );

UINT
AddKeyOffsetToBuffer(
    IN  UINT Offset
    );

VOID
RemoveKeyOffsetFromBuffer(
    IN  UINT Index
    );

VOID
MarkIndexList (
    PUINT IndexList,
    UINT IndexListSize
    );

BOOL
ReadOffsetBlock (
    OUT     PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    );

BOOL
WriteOffsetBlock (
    IN      PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    );

UINT GetOffsetBufferBlockSize (
    IN      PGROWBUFFER pOffsetBuffer
    );



//
// pastring.c
// Pascal-style string: wide characters, first char
//      is number of characters, no null-termination
//

typedef WCHAR * PPASTR;
typedef WCHAR const * PCPASTR;

//
// these convert a WSTR in place from null-terminated
// to Pascal-style strings
//
PPASTR StringPasConvertTo (PWSTR str);
PWSTR StringPasConvertFrom (PPASTR str);

//
// these convert a WSTR from null-terminated
// to Pascal-style strings in new string buffer
//
PPASTR StringPasCopyConvertTo (PPASTR str1, PCWSTR str2);
PWSTR StringPasCopyConvertFrom (PWSTR str1, PCPASTR str2);

PPASTR StringPasCopy (PPASTR str1, PCPASTR str2);
UINT StringPasCharCount (PCPASTR str);

INT  StringPasCompare (PCPASTR str1, PCPASTR str2);
BOOL StringPasMatch (PCPASTR str1, PCPASTR str2);
INT  StringPasICompare (PCPASTR str1, PCPASTR str2);
BOOL StringPasIMatch (PCPASTR str1, PCPASTR str2);

BOOL
IsPatternMatchCharCountW (
    IN      PCWSTR Pattern,
    IN      UINT PatternLen,
    IN      PCWSTR String,
    IN      UINT StringLen
    );




//
// keystrct.c
//

#ifdef DEBUG

PKEYSTRUCT
GetKeyStructFromOffset (
    UINT Offset
    );

PKEYSTRUCT
GetKeyStruct (
    UINT Index
    );

#else

#define GetKeyStructFromOffset(Offset) ((Offset==INVALID_OFFSET) ?          \
                                        NULL :                              \
                                        (PKEYSTRUCT)OFFSET_TO_PTR(Offset))
#define GetKeyStruct(Index)            ((Index==INVALID_OFFSET) ?           \
                                        NULL :                              \
                                        GetKeyStructFromOffset(KeyIndexToOffset(Index)))
#endif



UINT
GetFirstIndex (
    IN      UINT TreeOffset,
    OUT     PUINT pTreeEnum
    );

UINT
GetNextIndex (
    IN OUT      PUINT pTreeEnum
    );

UINT
NewKey (
    IN  PCWSTR KeyStr
    );

UINT
NewEmptyKey (
    IN  PCWSTR KeyStr
    );


BOOL
PrivateDeleteKeyByIndex (
    IN      UINT Index
    );

BOOL
DeleteKey (
    IN      PCWSTR KeyStr,
    IN      UINT TreeOffset,
    IN      BOOL MustMatch
    );

BOOL
PrivateBuildKeyFromIndex (
    IN      UINT StartLevel,               // zero-based
    IN      UINT TailIndex,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PUINT ValPtr,                   OPTIONAL
    OUT     PUINT UserFlagsPtr,             OPTIONAL
    OUT     PUINT SizeInChars               OPTIONAL
    );


BOOL
KeyStructSetInsertionOrdered (
    IN      PKEYSTRUCT Key
    );


UINT KeyStructGetChildCount (
    IN      PKEYSTRUCT pKey
    );

UINT
FindKeyStructInTree (
    IN UINT TreeOffset,
    IN PWSTR KeyName,
    IN BOOL IsPascalString
    );




#ifdef DEBUG
BOOL
CheckLevel(UINT TreeOffset,
            UINT PrevLevelIndex
            );
#endif



//
// keyfind.c
//


UINT
FindKeyStruct(
    IN PCWSTR Key
    );

UINT
FindKey (
    IN  PCWSTR FullKeyPath
    );

UINT
FindKeyStructUsingPattern (
    IN      UINT TreeOffset,
    IN OUT  PUINT pTreeEnum,
    IN      PCWSTR PatternStr
    );

#ifdef DEBUG
BOOL
FindKeyStructInDatabase(
    UINT KeyOffset
    );
#endif


//
// keydata.c
//


BOOL
KeyStructSetValue (
    IN      UINT KeyIndex,
    IN      UINT Value
    );

BOOL
KeyStructSetFlags (
    IN      UINT KeyIndex,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

UINT
KeyStructAddBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

UINT
KeyStructGrowBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

UINT
KeyStructGrowBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

BOOL
KeyStructDeleteBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
KeyStructDeleteBinaryDataByIndex (
    IN      UINT DataIndex
    );

UINT
KeyStructReplaceBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

PBYTE
KeyStructGetBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize
    );

PBYTE
KeyStructGetBinaryDataByIndex (
    IN      UINT DataIndex,
    OUT     PUINT DataSize
    );

UINT
KeyStructGetDataIndex (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    );

DATAHANDLE
KeyStructAddLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
KeyStructAddLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

BOOL
KeyStructDeleteLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
KeyStructDeleteLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
KeyStructTestLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
KeyStructTestLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage
    );

BOOL
KeyStructGetValue (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Value
    );

BOOL
KeyStructGetFlags (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Flags
    );

VOID
KeyStructFreeAllData (
    PKEYSTRUCT KeyStruct
    );







//
// bintree.c
//

#ifdef DEBUG

//
// violating code hiding for easier debugging.
// (only database.c should see bintree functions)
//

UINT
BinTreeGetSizeOfStruct(
    DWORD Signature
    );

BOOL
BinTreeFindStructInDatabase(
    DWORD Sig,
    UINT Offset
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\memdbfile.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbfile.c

Abstract:

    file operations for memdb saving/loading/exporting/importing

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  split from memdb.c


--*/

#include "pch.h"
#include "memdbp.h"

//
// This is our version stamp.  Change MEMDB_VERSION_STAMP only.
//

#define MEMDB_VERSION_STAMP L"v9 "

#define VERSION_BASE_SIGNATURE  L"memdb dat file "
#define MEMDB_DEBUG_SIGNATURE   L"debug"
#define MEMDB_NODBG_SIGNATURE   L"nodbg"

#define VERSION_SIGNATURE VERSION_BASE_SIGNATURE MEMDB_VERSION_STAMP
#define DEBUG_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_DEBUG_SIGNATURE
#define RETAIL_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_NODBG_SIGNATURE

#ifdef DEBUG
#define FILE_SIGNATURE DEBUG_FILE_SIGNATURE
#else
#define FILE_SIGNATURE RETAIL_FILE_SIGNATURE
#endif

PBYTE
MapFileFromHandle (
    HANDLE hFile,
    PHANDLE hMap
    )
{
    MYASSERT(hMap);
    if (hFile == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    *hMap = CreateFileMappingA (
        hFile,
        NULL,
        PAGE_READWRITE,
        0,
        0,
        NULL
        );
    if (*hMap == NULL) {
        return NULL;
    }

    return MapViewOfFile (*hMap, FILE_MAP_WRITE, 0, 0, 0);
}

BOOL
SetSizeOfFile (
    HANDLE hFile,
    LONGLONG Size
    )
{
    LONG a;
    LONG b;
    PLONG sizeHi;

    a = (LONG) Size;
    b = (LONG) (SHIFTRIGHT32(Size));
    if (b) {
        sizeHi = &b;
    } else {
        sizeHi = NULL;
    }

    if (SetFilePointer (hFile, a, sizeHi, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
        return FALSE;
    }
    if (!SetEndOfFile (hFile)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
WriteBlocks (
    IN OUT  PBYTE *Buf,
    IN      PMEMDBHASH pHashTable,
    IN      PGROWBUFFER pOffsetBuffer
    )
{
    MYASSERT(Buf);
    MYASSERT(pHashTable);
    MYASSERT(pOffsetBuffer);

    if (!WriteHashBlock (pHashTable, Buf)) {
        return FALSE;
    }
    if (!WriteOffsetBlock (pOffsetBuffer, Buf)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ReadBlocks (
    IN OUT  PBYTE *Buf,
    OUT     PMEMDBHASH *ppHashTable,
    OUT     PGROWBUFFER pOffsetBuffer
    )
{
    MYASSERT(Buf);
    MYASSERT(ppHashTable);
    MYASSERT(pOffsetBuffer);

    //
    // fill hash block
    //
    if (!*ppHashTable) {
        return FALSE;
    }
    if (!ReadHashBlock (*ppHashTable, Buf)) {
        return FALSE;
    }
    if (!ReadOffsetBlock (pOffsetBuffer, Buf)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
pPrivateMemDbSave (
    PCSTR FileName
    )
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    HANDLE hMap = INVALID_HANDLE_VALUE;
    PBYTE Buf = NULL;
    PBYTE MapPtr = NULL;
    BOOL result = FALSE;

    EnterOurCriticalSection (&g_MemDbCs);

    __try {

        SelectDatabase (DB_PERMANENT);

        //
        // now we resize file to fit everything in it.
        //
        FileHandle = OpenFileA (FileName, CREATE_ALWAYS);

        if (FileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!SetSizeOfFile (
                FileHandle,
                (LONGLONG)(sizeof (FILE_SIGNATURE)) +
                g_CurrentDatabase->AllocSize +
                GetHashTableBlockSize (g_CurrentDatabase->HashTable) +
                GetOffsetBufferBlockSize (&g_CurrentDatabase->OffsetBuffer)
                )) {
            __leave;
        }

        Buf = MapFileFromHandle (FileHandle, &hMap);

        if (Buf == NULL) {
            __leave;
        }

        MapPtr = Buf;

        CopyMemory (Buf, FILE_SIGNATURE, sizeof (FILE_SIGNATURE));

        Buf += sizeof (FILE_SIGNATURE);

        CopyMemory (Buf, g_CurrentDatabase, g_CurrentDatabase->AllocSize);

        Buf += g_CurrentDatabase->AllocSize;

        if (!WriteBlocks (
                &Buf,
                g_CurrentDatabase->HashTable,
                &g_CurrentDatabase->OffsetBuffer
                )) {
            __leave;
        }

        result = TRUE;
    }
    __finally {

        UnmapFile (MapPtr, hMap, FileHandle);

        PushError();

        // lint is not familiar with __finally so...
        if (!result) {  //lint !e774
            DeleteFileA (FileName);
        }

        LeaveOurCriticalSection (&g_MemDbCs);

        PopError();
    }

    return result;
}

BOOL
MemDbSaveA (
    PCSTR FileName
    )
{
    return pPrivateMemDbSave (FileName);                   // TRUE=UNICODE
}

BOOL
MemDbSaveW (
    PCWSTR FileName
    )
{
    PCSTR p;
    BOOL b = FALSE;

    p = ConvertWtoA (FileName);
    if (p) {
        b = pPrivateMemDbSave (p);
        FreeConvertedStr (p);
    }

    return b;
}

BOOL
pPrivateMemDbLoad (
    IN      PCWSTR FileName,
    OUT     PMEMDB_VERSION Version,                 OPTIONAL
    IN      BOOL QueryVersionOnly
    )
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    HANDLE hMap = INVALID_HANDLE_VALUE;
    WCHAR FileSig[sizeof(FILE_SIGNATURE)];
    PCWSTR VerPtr;
    UINT DbSize;
    PMEMDBHASH pHashTable;
    PBYTE Buf = NULL;
    BOOL result = FALSE;


    EnterOurCriticalSection (&g_MemDbCs);

    __try {
        __try {

            if (Version) {
                ZeroMemory (Version, sizeof (MEMDB_VERSION));
            }

            //
            // Blow away existing resources
            //

            if (!QueryVersionOnly) {
                DatabasesTerminate ();
                DatabasesInitialize ();
                SelectDatabase (DB_PERMANENT);
            }

            Buf = MapFileIntoMemoryW (FileName, &FileHandle, &hMap);

            if (Buf == NULL) {
                __leave;
            }

            //
            // Obtain the file signature
            //
            // NOTE: Entire file read is in UNICODE char set
            //

            CopyMemory (FileSig, Buf, sizeof(FILE_SIGNATURE));

            if (Version) {
                if (StringMatchByteCountW (
                        VERSION_BASE_SIGNATURE,
                        FileSig,
                        sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR)
                        )) {

                    Version->Valid = TRUE;

                    //
                    // Identify version number
                    //

                    VerPtr = (PCWSTR) ((PBYTE)FileSig + sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR));

                    if (StringMatchByteCountW (
                            MEMDB_VERSION_STAMP,
                            VerPtr,
                            sizeof (MEMDB_VERSION_STAMP) - sizeof (WCHAR)
                            )) {
                        Version->CurrentVersion = TRUE;
                    }

                    Version->Version = (UINT) _wtoi (VerPtr + 1);

                    //
                    // Identify checked or free build
                    //

                    VerPtr += (sizeof (MEMDB_VERSION_STAMP) / sizeof (WCHAR)) - 1;

                    if (StringMatchByteCountW (
                            MEMDB_DEBUG_SIGNATURE,
                            VerPtr,
                            sizeof (MEMDB_DEBUG_SIGNATURE) - sizeof (WCHAR)
                            )) {

                        Version->Debug = TRUE;

                    } else if (!StringMatchByteCountW (
                                    VerPtr,
                                    MEMDB_NODBG_SIGNATURE,
                                    sizeof (MEMDB_NODBG_SIGNATURE) - sizeof (WCHAR)
                                    )) {
                        Version->Valid = FALSE;
                    }
                }
            }

            if (!QueryVersionOnly) {

                if (!StringMatchW (FileSig, FILE_SIGNATURE)) {

#ifdef DEBUG
                    if (StringMatchW (FileSig, DEBUG_FILE_SIGNATURE)) {

                        g_UseDebugStructs = TRUE;

                    } else if (StringMatchW (FileSig, RETAIL_FILE_SIGNATURE)) {

                        DEBUGMSG ((DBG_ERROR, "memdb dat file is from free build; checked version expected"));
                        g_UseDebugStructs = FALSE;

                    } else {
#endif
                        SetLastError (ERROR_BAD_FORMAT);
                        LOG ((LOG_WARNING, "Warning: data file could be from checked build; free version expected"));
                        __leave;
#ifdef DEBUG
                    }
#endif
                }

                Buf += sizeof(FILE_SIGNATURE);
                DbSize = *((PUINT)Buf);

                //
                // resize the database.  SizeDatabaseBuffer also fixes g_CurrentDatabase
                // and other global variables, so we dont have to worry.
                //
                if (!SizeDatabaseBuffer(g_CurrentDatabaseIndex, DbSize)) {
                    __leave;
                }

                //
                // save hashtable pointer (which points to hashtable created
                // in InitializeDatabases (above)), then load database, then
                // fix hashtable pointer.
                //
                pHashTable = g_CurrentDatabase->HashTable;
                CopyMemory (g_CurrentDatabase, Buf, DbSize);
                g_CurrentDatabase->HashTable = pHashTable;
                Buf += DbSize;

                if (!ReadBlocks (
                        &Buf,
                        &g_CurrentDatabase->HashTable,
                        &g_CurrentDatabase->OffsetBuffer
                        )) {
                    __leave;
                }
                result = TRUE;
            }

            UnmapFile (Buf, hMap, FileHandle);

        }
        __except (TRUE) {
            result = FALSE;
            PushError();
            LOG ((LOG_ERROR, "MemDb dat file %s could not be loaded because of an exception", FileName));
            PopError();
        }
    }
    __finally {

        PushError();

        if (!result && !QueryVersionOnly) {
            DatabasesTerminate ();
            DatabasesInitialize ();
        }

        LeaveOurCriticalSection (&g_MemDbCs);

        PopError();
    }
    return result;
}

BOOL
MemDbLoadA (
    IN PCSTR FileName
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (FileName);
    if (p) {
        b = pPrivateMemDbLoad (p, NULL, FALSE);
        FreeConvertedStr (p);
    }
    return b;
}

BOOL
MemDbLoadW (
    IN PCWSTR FileName
    )
{
    return pPrivateMemDbLoad (FileName, NULL, FALSE);
}

BOOL
MemDbQueryVersionA (
    PCSTR FileName,
    PMEMDB_VERSION Version
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (FileName);
    if (p) {
        b = pPrivateMemDbLoad (p, Version, TRUE);
        FreeConvertedStr (p);
    }

    return b ? Version->Valid : FALSE;
}

BOOL
MemDbQueryVersionW (
    PCWSTR FileName,
    PMEMDB_VERSION Version
    )
{
    pPrivateMemDbLoad (FileName, Version, TRUE);
    return Version->Valid;
}

/* format for binary file export

    DWORD Signature

    UINT Version

    UINT GlobalFlags// 0x00000001 mask for Ansi format
                    // 0x00000002 mask for debug mode

        //
        // each _KEY block is followed by its children,
        // and each of those is followed by its children,
        // etc., so it is easy to recurse to gather
        // the whole tree.
        //

    struct _KEY {

      #if (GlobalFlags & MEMDB_EXPORT_FLAGS_DEBUG)
        WORD DebugSig       // signature for each keystruct block.
      #endif
        WORD StructSize;    // total number of bytes including this member
        WORD NameSize;      // total number of bytes in Key[]
        WORD DataSize;      // total number of bytes in Data[]
        WORD NumChildren    // number of children, whose data structures will follow
                            // this one (though not necessarily one after another, if
                            // any of them have children themselves)
        BYTE Key[];         // Should be PCSTR or PCWSTR (not zero terminated).
                            // the first key in the exported file will have the full
                            // key path as its key name.
        BYTE Data[];        // block of data pieces, all in same format as in datablock.c
    }

*/
#define MEMDB_EXPORT_SIGNATURE              ('M'+('D'<<8)+('B'<<16)+('X'<<24))
//BUGBUG - reenable the line below when implementing export and import functions
//#define MEMDB_EXPORT_DEBUG_SIG              ('K'+('Y'<<8))
#define MEMDB_EXPORT_VERSION                0x00000003
#define MEMDB_EXPORT_FLAGS_ANSI             0x00000001
#define MEMDB_EXPORT_FLAGS_DEBUG            0x00000002

//BUGBUG - implement the function and remove lint comments
//lint -save -e713 -e715
BOOL
pMemDbExportWorker (
    IN  HANDLE FileHandle,
    IN  UINT KeyIndex,
    IN  BOOL AnsiFormat,
    IN  PCWSTR FullKeyPath
    )
/*++

Routine Description:

  exports a key to a file, and then recurses through
  that key's children.

Arguments:

  FileHandle - already opened handle to write to

  KeyIndex - index of key to write

  AnsiFormat - if TRUE, then FullKeyPath (above) and KeyName
        (below) are actually ANSI strings (not unicode).

  FullKeyPath - only used for first keystruct to be written
        to file.  it specifies the full path of the root key.
        for all others, this argument should be NULL.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    return TRUE;
}
//lint -restore

BOOL
pMemDbExport (
    IN      PCWSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    )
/*++

Routine Description:

  exports a MemDb tree to a file

Arguments:

  RootTree - full key path of the top level key to write
        to the file.

  FileName - file to write to.

  AnsiFormat - if TRUE, then RootTree and FileName are
        actually ANSI strings (not unicode).


Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    UINT Flags;
    DWORD written;
    UINT RootIndex;
    PCWSTR SubRootTreeW, RootTreeW;
    BOOL b;

    if (AnsiFormat) {
        //
        // if we are in ansi mode, everything is ANSI strings,
        // but we still need unicode string for SelectHiveW ()
        //
        RootTreeW = ConvertAtoW ((PCSTR)RootTree);

        if (!RootTreeW) {
            return FALSE;
        }
    } else {
        RootTreeW = RootTree;
    }
    SubRootTreeW = SelectHiveW (RootTreeW);
    RootIndex = FindKeyStruct (SubRootTreeW);
    if (AnsiFormat) {
        FreeConvertedStr(RootTreeW);
    }

    if (RootIndex == INVALID_OFFSET) {
        return FALSE;
    }

    FileHandle = OpenFileA (FileName, CREATE_ALWAYS);

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    Flags = MEMDB_EXPORT_SIGNATURE;
    WriteFile (FileHandle, &Flags, sizeof (DWORD), &written, NULL);

    Flags = MEMDB_EXPORT_VERSION;
    WriteFile (FileHandle, &Flags, sizeof (UINT), &written, NULL);

    Flags = AnsiFormat ? MEMDB_EXPORT_FLAGS_ANSI : 0;

#ifdef DEBUG
    Flags |= MEMDB_EXPORT_FLAGS_DEBUG;
#endif
    WriteFile (FileHandle, &Flags, sizeof (UINT), &written, NULL);

    //
    // write root index key and all children to file.
    //
    b = pMemDbExportWorker(FileHandle, RootIndex, AnsiFormat, RootTree);


    //
    // finally write the zero terminator
    //
    Flags = 0;
    WriteFile (FileHandle, &Flags, sizeof (WORD), &written, NULL);

    CloseHandle (FileHandle);

    return b;
}

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    )
{
    PCWSTR p;
    BOOL b;

    if (!AnsiFormat) {

        p = ConvertAtoW (RootTree);

        if (!p) {
            return FALSE;
        }

        b = pMemDbExport (p, FileName, FALSE);

        FreeConvertedStr (p);

    } else {

        b = pMemDbExport ((PCWSTR)RootTree, FileName, TRUE);

    }

    return b;
}

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    )
{
    PCSTR p, FileNameA;
    BOOL b;

    FileNameA = ConvertWtoA (FileName);

    if (!FileNameA) {

        return FALSE;

    }

    if (AnsiFormat) {

        p = ConvertWtoA (RootTree);

        if (!p) {

            FreeConvertedStr (FileNameA);
            return FALSE;

        }

        b = pMemDbExport ((PCWSTR)p, FileNameA, TRUE);

        FreeConvertedStr (p);

    } else {

        b = pMemDbExport (RootTree, FileNameA, FALSE);

    }

    FreeConvertedStr (FileNameA);

    return b;
}

//BUGBUG - implement the function and remove lint comments
//lint -save -e713 -e715
BOOL
pMemDbImportWorker (
    IN      PBYTE *FileBuffer,
    IN      BOOL AnsiFormat,
    IN      BOOL DebugMode,
    IN      BOOL ExportRoot
    )
/*++

Routine Description:

  imports a key from a file, and then recurses through
  that key's children.

Arguments:

  FileBuffer - pointer to a memory pointer, which should
        initially point to the beginning of the
        memory-mapped file to read.  this will be updated
        as the function runs

  AnsiFormat - TRUE if the file is in ANSI mode (determined
        by file header)

  DebugMode - TRUE if the file is in debug mode (determined
        by file header)

  ExportRoot - TRUE if this is the first call to this function
        for a file (the name of the first keystruct in a file
        is the full key path for that keystruct, all other keys
        in the file have only the relative name).

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    return TRUE;
}
//lint -restore

BOOL
MemDbImportA (
    IN      PCSTR FileName
    )
{
    PCWSTR FileNameW;
    BOOL b = FALSE;

    FileNameW = ConvertAtoW (FileName);

    if (FileNameW) {
        b = MemDbImportW (FileNameW);
        FreeConvertedStr (FileNameW);
    }

    return b;
}

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  MemDbImportW imports a tree from a private binary format. The format is described above.

Arguments:

  FileName - Name of the binary format file to import from.

Return Value:

  TRUE is successfull, FALSE if not.

--*/
{
    PBYTE fileBuff, BufferPtr;
    HANDLE fileHandle;
    HANDLE mapHandle;
    BOOL b;
    UINT Flags;

    fileBuff = MapFileIntoMemoryW (FileName, &fileHandle, &mapHandle);
    if (fileBuff == NULL) {
        DEBUGMSGW ((DBG_ERROR, "Could not execute MemDbImport for %s", FileName));
        return FALSE;
    }

    __try {
        BufferPtr = fileBuff;
        if (*((PDWORD) BufferPtr) != MEMDB_EXPORT_SIGNATURE) {
            DEBUGMSGW ((DBG_ERROR, "Unknown signature for file to import: %s", FileName));
            b = FALSE;
        } else {
            BufferPtr += sizeof (DWORD);

            if (*((PUINT) BufferPtr) != MEMDB_EXPORT_VERSION) {

                DEBUGMSGW ((DBG_ERROR, "Unknown or outdated version for file to import: %s", FileName));
                b = FALSE;
            } else {
                BufferPtr += sizeof (UINT);
                Flags = *((PUINT) BufferPtr);
                BufferPtr += sizeof (UINT);

                b = pMemDbImportWorker (
                    &BufferPtr,
                    Flags & MEMDB_EXPORT_FLAGS_ANSI,
                    Flags & MEMDB_EXPORT_FLAGS_DEBUG,
                    TRUE
                    );
            }
        }
    }
    __except (1) {
        DEBUGMSGW ((DBG_ERROR, "Access violation while importing: %s", FileName));
    }

    UnmapFile (fileBuff, mapHandle, fileHandle);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\offsetbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    offsetbuf.c

Abstract:

    Routines that manage the keystruct offsetbuffer

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"



//
// we store index flags in the top two bits of the UINT offsets in
// the buffer, because offsets never have a top two bits set
//
// if the user links a key, we want to mark that index, so we
// dont add it to the deleted index list.  if a key is linked,
// and then deleted, we want to keep that key's index pointing
// to INVALID_OFFSET, instead of reusing the index.
//
// if a key is moved, we replace the key's original offset with
// the index of the new key's offset.  then we flag that the
// offset has been redirected.
//
// if an index is marked or redirected, when that key is deleted,
// we just set the true index (the index that any redirected indices
// point to) to INVALID_OFFSET.
//

#define INDEX_FLAG_BITS                 2
#define INDEX_MOVE_BITS_TO_POS(bits)    (((UINT)(bits)) << (8*sizeof(UINT)-INDEX_FLAG_BITS))
#define INDEX_MARKED_FLAG               INDEX_MOVE_BITS_TO_POS(0x01)
#define INDEX_REDIRECTED_FLAG           INDEX_MOVE_BITS_TO_POS(0x02)
#define INDEX_FLAG_MASK                 INDEX_MOVE_BITS_TO_POS(0x03)

#define GET_UINT_AT_INDEX(index)          (*(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + (index)))
#define SET_UINT_AT_INDEX(index, offset)  ((*(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + (index)))=(offset))

#define MARK_INDEX(Index)       (GET_UINT_AT_INDEX(Index) |= INDEX_MARKED_FLAG)
#define IS_INDEX_MARKED(Index)  ((BOOL)(GET_UINT_AT_INDEX(Index) & INDEX_FLAG_MASK))


VOID
MarkIndexList (
    IN      PUINT IndexList,
    IN      UINT IndexListSize
    )
{
    BYTE CurrentDatabase;
    UINT i;

    CurrentDatabase = g_CurrentDatabaseIndex;

    //
    // iterate through whole list, switch to correct
    // database, and mark list as linked.
    //
    for (i = 0; i < IndexListSize; i++) {
        SelectDatabase (GET_DATABASE (IndexList[i]));
        MARK_INDEX (GET_INDEX (IndexList[i]));
#ifdef _DEBUG
        if (GET_UINT_AT_INDEX (GET_INDEX (IndexList[i])) != INVALID_OFFSET) {
            MYASSERT (GetKeyStruct (GET_INDEX (IndexList[i])));
        }
#endif
    }

    SelectDatabase (CurrentDatabase);
}

VOID
RedirectKeyIndex (
    IN      UINT Index,
    IN      UINT TargetIndex
    )
/*++

Routine Description:
  sets the offset at Index to TargetIndex, with INDEX_REDIRECTED_FLAG
  set in the top byte.  also, we mark TargetIndex, indicating it has
  something redirected to it.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    MYASSERT(!(TargetIndex & INDEX_FLAG_MASK));
    MYASSERT(!(GET_UINT_AT_INDEX(Index) & INDEX_REDIRECTED_FLAG));
    MYASSERT(!(GET_UINT_AT_INDEX(TargetIndex) & INDEX_REDIRECTED_FLAG));
    SET_UINT_AT_INDEX(Index, TargetIndex | INDEX_REDIRECTED_FLAG);
    MARK_INDEX(TargetIndex);
}

UINT
pGetTrueIndex (
    IN  UINT Index
    )
/*++

Routine Description:
  takes and index and returns the true index, which is the index that
  actually holds the offset of the keystruct.  indexes with the
  redirected flag hold the index they are redirected to.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    while (GET_UINT_AT_INDEX(Index) & INDEX_REDIRECTED_FLAG) {
        Index = GET_UINT_AT_INDEX(Index) & ~INDEX_FLAG_MASK;
    }
    return Index;
}










UINT
KeyIndexToOffset (
    IN  UINT Index
    )
/*++

Routine Description:
  KeyIndexToOffset converts an index of a Keystruct
  (in g_CurrentDatabase->OffsetBuffer) to the Keystruct's offset in the database.

Arguments:
  Index - index in OffsetBuffer.  must be valid

Return Value:
  Offset of Keystruct.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    MYASSERT (Index <= g_CurrentDatabase->OffsetBuffer.End-sizeof(UINT));

    if (!g_CurrentDatabase->OffsetBuffer.Buf) {
        return INVALID_OFFSET;
    }

    do {
        Index = GET_UINT_AT_INDEX(Index);
        if (Index == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }
        if (!(Index & INDEX_REDIRECTED_FLAG)) {
            //
            // we have found a non-redirected index, so check
            // that this points to a real keystruct, and return it.
            //
            MYASSERT(GetKeyStructFromOffset(Index & ~INDEX_FLAG_MASK));
            return Index & ~INDEX_FLAG_MASK;
        }
        Index &= ~INDEX_FLAG_MASK;
        MYASSERT (Index <= g_CurrentDatabase->OffsetBuffer.End-sizeof(UINT));
    } while (TRUE); //lint !e506
}






UINT
AddKeyOffsetToBuffer (
    IN  UINT Offset
    )
/*++

Routine Description:
  gets a space in g_CurrentDatabase->OffsetBuffer and sets it to Offset

Arguments:
  Offset - value to put in buffer space

Return Value:
  Index of space in g_CurrentDatabase->OffsetBuffer

--*/
{
    PUINT Ptr;

    if (Offset & INDEX_FLAG_MASK) {
        DEBUGMSG ((DBG_ERROR, "Offset to be put in list is too big, 0x%08lX", Offset));
        return FALSE;
    }

    //
    // this will check that Offset is valid and points to Keystruct
    //
    MYASSERT(GetKeyStructFromOffset(Offset));

    if (g_CurrentDatabase->OffsetBufferFirstDeletedIndex != INVALID_OFFSET)
    {
        //
        // if we have deleted offsets from offset list, we
        // find an open index, the first of which is stored
        // in g_CurrentDatabase->OffsetBufferFirstDeletedIndex.  the value at
        // this index in the buffer is the next open index,
        // and the value at that index is the next one, etc.
        //
        Ptr = &GET_UINT_AT_INDEX(g_CurrentDatabase->OffsetBufferFirstDeletedIndex);
        g_CurrentDatabase->OffsetBufferFirstDeletedIndex = *Ptr;
    } else {
        //
        // otherwise, make g_CurrentDatabase->OffsetBuffer bigger to hold new offset.
        //
        Ptr = (PUINT) GbGrow (&g_CurrentDatabase->OffsetBuffer, sizeof(UINT));
    }

    *Ptr = Offset;

    return (UINT)((UBINT)Ptr - (UBINT)g_CurrentDatabase->OffsetBuffer.Buf);
}


VOID
RemoveKeyOffsetFromBuffer(
    IN  UINT Index
    )
/*++

Routine Description:
  frees a space in g_CurrentDatabase->OffsetBuffer (adds to deleted index list)

Arguments:
  Index - position of space to free

--*/
{
    if (Index == INVALID_OFFSET) {
        return;
    }

    if (IS_INDEX_MARKED(Index)) {
        //
        // if index is marked, either it is redirected or something
        // is linked to this index.  either way, we do not want to
        // reuse the index, so just set true index (not a redirected
        // one) to INVALID_OFFSET.
        //
        SET_UINT_AT_INDEX(pGetTrueIndex(Index), INVALID_OFFSET);
    } else {
        //
        // index not marked, so we can reuse this index by
        // putting it in the deleted index list.
        //
        SET_UINT_AT_INDEX(Index, g_CurrentDatabase->OffsetBufferFirstDeletedIndex);
        g_CurrentDatabase->OffsetBufferFirstDeletedIndex = Index;
    }
}



BOOL
WriteOffsetBlock (
    IN      PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    )
{
    MYASSERT(pOffsetBuffer);

    *(((PUINT)*Buf)++) = pOffsetBuffer->End;
    CopyMemory (*Buf, pOffsetBuffer->Buf, pOffsetBuffer->End);

    *Buf += pOffsetBuffer->End;
    return TRUE;
}


BOOL
ReadOffsetBlock (
    OUT     PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    )
{
    UINT OffsetBufferSize;

    MYASSERT(pOffsetBuffer);

    ZeroMemory (pOffsetBuffer, sizeof (GROWBUFFER));

    OffsetBufferSize = *(((PUINT)*Buf)++);

    if (OffsetBufferSize > 0) {
        if (!GbGrow(pOffsetBuffer, OffsetBufferSize)) {
            return FALSE;
        }
        CopyMemory (pOffsetBuffer->Buf, *Buf, OffsetBufferSize);
        *Buf += OffsetBufferSize;
    }

    return TRUE;
}


UINT GetOffsetBufferBlockSize (
    IN      PGROWBUFFER pOffsetBuffer
    )
{
    return sizeof (UINT) + pOffsetBuffer->End;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\memdbutil.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbutil.c

Abstract:

    MemDb Utility functions

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     xx-xxx-1999  split from memdb.c

--*/

#include "pch.h"

BOOL
MemDbValidateDatabase (
    VOID
    )
{
    //BUGBUG reimplement this
    return TRUE;
}


/*++

Routine Description:

  MemDbMakeNonPrintableKey converts the double-backslashe pairs in a string
  to ASCII 1, a non-printable character.  This allows the caller to store
  properly escaped strings in MemDb.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakeNonPrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == '\\' &&
                _mbsnextc (_mbsinc (KeyName)) == '\\'
                ) {
                _setmbchar (KeyName, 1);
                KeyName = _mbsinc (KeyName);
                MYASSERT (_mbsnextc (KeyName) == '\\');
                _setmbchar (KeyName, 1);
            }

            DEBUGMSG_IF ((
                _mbsnextc (KeyName) == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == '*') {
                _setmbchar (KeyName, 2);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == '?') {
                _setmbchar (KeyName, 3);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakeNonPrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == L'\\' && KeyName[1] == L'\\') {
                KeyName[0] = 1;
                KeyName[1] = 1;
                KeyName++;
            }

            DEBUGMSG_IF ((
                KeyName[0] == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 2;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 3;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName++;
    }
}


/*++

Routine Description:

  MemDbMakePrintableKey converts the ASCII 1 characters to backslashes,
  restoring the string converted by MemDbMakeNonPrintableKey.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakePrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == 1) {
                _setmbchar (KeyName, '\\');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == 2) {
                _setmbchar (KeyName, '*');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == 3) {
                _setmbchar (KeyName, '?');
            }
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakePrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == 1) {
                KeyName[0] = L'\\';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == 2) {
                KeyName[0] = L'*';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == 3) {
                KeyName[0] = L'?';
            }
        }
        KeyName++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\memdb\pastring.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    pastring.c

Abstract:

    Routines that manage the pascal strings

Author:

    Matthew Vanderzee (matthewv) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"








PPASTR
StringPasConvertTo (
    IN OUT PWSTR str
    )
/*++

  Converts a string in place from a zero-terminated
  string to a pascal-style string.

--*/
{
    WCHAR Len;
    MYASSERT(str);
    Len = (WORD) CharCountW (str);
    MoveMemory (str + 1, str, Len * sizeof(WCHAR));
    *str = Len;
    return str;
}

PWSTR
StringPasConvertFrom (
    IN OUT PPASTR str
    )
/*++

  Converts a string in place from a pascal-style string
  to a null-terminated string.

--*/
{
    WCHAR Len;
    MYASSERT(str);
    Len = *str;
    MoveMemory (str, str + 1, Len * sizeof(WCHAR));
    *(str + Len) = 0;
    return str;
}

PPASTR
StringPasCopyConvertTo (
    OUT PPASTR str1,
    IN  PCWSTR str2
    )
/*++

  Converts a string from a zero-terminated
  string to a pascal-style string in a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    *str1 = (WORD) CharCountW (str2);
    CopyMemory (str1 + 1, str2, *str1 * sizeof(WCHAR));
    return str1;
}

PWSTR
StringPasCopyConvertFrom (
    OUT PWSTR str1,
    IN  PCPASTR str2
    )
/*++

  Converts a string from a pascal-style string
  to a null-terminated string in a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    CopyMemory (str1, str2 + 1, *str2 * sizeof(WCHAR));
    *(str1 + *str2) = 0;
    return str1;
}

PPASTR
StringPasCopy (
    OUT PPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Copys a pascal string to a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    CopyMemory (str1, str2, (*str2+1) * sizeof(WCHAR));
    return str1;
}

UINT
StringPasCharCount (
    IN  PCPASTR str
    )
/*++

  Returns the number of characters in a string.

--*/
{
    MYASSERT(str);
    return (UINT)(*str);
}


INT
StringPasCompare (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Compares two pascal-style strings, returns values
  in the same fashion as strcmp().

--*/
{
    INT equal;
    INT diff;
    MYASSERT(str1);
    MYASSERT(str2);
    //
    // diff is < 0 if str1 is shorter, = 0 if
    // strings are same length, otherwise > 0
    //
    diff = *str1 - *str2;
    equal = wcsncmp(str1+1, str2+1, (diff < 0) ? *str1 : *str2);
    if (equal != 0) {
        return equal;
    }
    return diff;
}

BOOL
StringPasMatch (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Returns TRUE if the two strings match

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    if (*str1 != *str2) {
        return FALSE;
    }
    return wcsncmp(str1+1, str2+1, *str2)==0;
}


INT
StringPasICompare (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Compares two pascal-style strings, returns values
  in the same fashion as strcmp().  (CASE INSENSITIVE)

--*/
{
    INT equal;
    INT diff;
    MYASSERT(str1);
    MYASSERT(str2);
    //
    // diff is < 0 if str1 is shorter, = 0 if
    // strings are same length, otherwise > 0
    //
    diff = *str1 - *str2;
    equal = _wcsnicmp(str1+1, str2+1, (diff < 0) ? *str1 : *str2);
    if (equal != 0) {
        return equal;
    }
    return diff;
}

BOOL
StringPasIMatch (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Returns TRUE if the two strings match (CASE INSENSITIVE)

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    if (*str1 != *str2) {
        return FALSE;
    }
    return _wcsnicmp(str1+1, str2+1, *str2)==0;
}

BOOL
IsPatternMatchCharCountW (
    IN      PCWSTR Pattern,
    IN      UINT PatternLen,
    IN      PCWSTR String,
    IN      UINT StringLen
    )
/*++

Routine Description:

  returns TRUE if the string wstrStr matches the
  pattern wstrPattern, which can contain wildcards
  '*' and '?'.  This can be used with pascal-style
  strings or normal zero-terminated strings.  the
  string pointer arguments should point to the first
  actual character in the string (the second character
  in a pascal string) and the corresponding INT value
  is the length of the string.  if the INT value is
  negative, we assume the corresponding string is a
  zero-terminated string, and we calculate the length
  ourselves.

Arguments:
  wstrPattern - character buffer holding a pattern which
        may include wildcards.
  PatternLen - number of characters in wstrPattern
  wstrStr - character buffer holding a string
  StrLen - number of characters in wstrStr

--*/
{
    WCHAR chSrc, chPat;

    while (StringLen > 0) {
        chSrc = towlower (*String);
        chPat = towlower (*Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (PatternLen > 0 && Pattern[1] == L'*') {
                Pattern++;
                PatternLen--;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (PatternLen <= 1)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            chPat = towlower (Pattern[1]);
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                if (IsPatternMatchCharCountW (Pattern+1, PatternLen-1, String, StringLen))
                    return TRUE;

            }

            // Allow any character and continue
            String++;
            StringLen--;
            continue;
        }

        //
        // otherwise, current pattern char is not a
        // '*', so if it is not a '?', then make sure
        // pattern char matches string character.
        //
        if (chPat != L'?') {
            if (chSrc != chPat)
                return FALSE;
        }

        Pattern++;
        PatternLen--;
        String++;
        StringLen--;
    }

    if (PatternLen==0) {
        return TRUE;
    }

    //
    // Fail when there is more pattern and
    // pattern does not end in an asterisk
    //
    while (PatternLen > 0 && Pattern[0] == L'*') {
        Pattern ++;
        PatternLen --;
    }
    return (PatternLen = 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\reg\regenum.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regenum.c

Abstract:

    Implements a set of APIs to enumerate the local registry using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "reg.h"

//
// Includes
//

// None

#define DBG_REGENUM     "RegEnum"

//
// Strings
//

#define S_REGENUM       "REGENUM"

//
// Constants
//

// None

//
// Macros
//

#define pAllocateMemory(Size)   PmGetMemory (g_RegEnumPool,Size)
#define pFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_RegEnumPool, (PVOID)Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_RegEnumPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
RegEnumInitialize (
    VOID
    )

/*++

Routine Description:

    RegEnumInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_RegEnumPool = PmCreateNamedPool (S_REGENUM);
    return g_RegEnumPool != NULL;
}


VOID
RegEnumTerminate (
    VOID
    )

/*++

Routine Description:

    RegEnumTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    if (g_RegEnumPool) {
        PmDestroyPool (g_RegEnumPool);
        g_RegEnumPool = NULL;
    }
}

BOOL
RegEnumDefaultCallbackA (
    IN      PREGNODEA RegNode       OPTIONAL
    )
{
    DWORD error;

    error = GetLastError ();

    if (error == ERROR_ACCESS_DENIED) {
        return TRUE;
    }

    return FALSE;
}

BOOL
RegEnumDefaultCallbackW (
    IN      PREGNODEW RegNode       OPTIONAL
    )
{
    DWORD error;

    error = GetLastError ();

    if (error == ERROR_ACCESS_DENIED) {
        return TRUE;
    }

    return FALSE;
}


INT g_RootEnumIndexTable [] = { 2, 4, 6, 8, -1};

BOOL
EnumFirstRegRootA (
    OUT     PREGROOT_ENUMA EnumPtr
    )
{
    EnumPtr->Index = 0;
    return EnumNextRegRootA (EnumPtr);
}

BOOL
EnumFirstRegRootW (
    OUT     PREGROOT_ENUMW EnumPtr
    )
{
    EnumPtr->Index = 0;
    return EnumNextRegRootW (EnumPtr);
}


BOOL
EnumNextRegRootA (
    IN OUT  PREGROOT_ENUMA EnumPtr
    )
{
    INT i;
    LONG result;

    i = g_RootEnumIndexTable [EnumPtr->Index];

    while (i >= 0) {
        EnumPtr->RegRootName = GetRootStringFromOffsetA (i);
        EnumPtr->RegRootHandle = GetRootKeyFromOffset(i);
        EnumPtr->Index++;
        result = RegQueryInfoKey (
                    EnumPtr->RegRootHandle,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        if (result == ERROR_SUCCESS) {
            return TRUE;
        }
        i = g_RootEnumIndexTable [EnumPtr->Index];
    }
    return FALSE;
}

BOOL
EnumNextRegRootW (
    IN OUT  PREGROOT_ENUMW EnumPtr
    )
{
    INT i;
    LONG result;

    i = g_RootEnumIndexTable [EnumPtr->Index];

    while (i >= 0) {
        EnumPtr->RegRootName = GetRootStringFromOffsetW (i);
        EnumPtr->RegRootHandle = GetRootKeyFromOffset(i);
        EnumPtr->Index++;
        result = RegQueryInfoKey (
                    EnumPtr->RegRootHandle,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        if (result == ERROR_SUCCESS) {
            return TRUE;
        }
        i = g_RootEnumIndexTable [EnumPtr->Index];
    }
    return FALSE;
}

/*++

Routine Description:

    pGetRegEnumInfo is a private function that validates and translates the enumeration info
    in an internal form that's more accessible to the enum routines

Arguments:

    RegEnumInfo - Receives the enum info
    EncodedRegPattern - Specifies the encoded pattern (encoded as defined by the
                        ObjectString functions)
    EnumKeyNames - Specifies TRUE if key names should be returned during the enumeration
                   (if they match the pattern); a key name is returned before any of its
                   subkeys or values
    ValuesFirst - Specifies TRUE if a key's values should be returned before key's subkeys;
                  this parameter decides the enum order between values and subkeys
                  for each key
    DepthFirst - Specifies TRUE if the current subkey of any key should be fully enumerated
                 before going to the next subkey; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum level of a key that is to be enumerated, relative to
                  the root; if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    keys/values are excluded from enumeration; this slows down the speed

Return Value:

    TRUE if all params are valid; in this case, RegEnumInfo is filled with the corresponding
         info.
    FALSE otherwise.

--*/

BOOL
pGetRegEnumInfoA (
    OUT     PREGENUMINFOA RegEnumInfo,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions
    )
{
    RegEnumInfo->RegPattern = ObsCreateParsedPatternA (EncodedRegPattern);
    if (!RegEnumInfo->RegPattern) {
        DEBUGMSGA ((DBG_ERROR, "pGetRegEnumInfoA: bad EncodedRegPattern: %s", EncodedRegPattern));
        return FALSE;
    }

    if (RegEnumInfo->RegPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsA (
                RegEnumInfo->RegPattern->ExactRoot,
                NULL,
                &RegEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        RegEnumInfo->RootLevel = 1;
    }

    if (!RegEnumInfo->RegPattern->Leaf) {
        //
        // no value pattern specified; assume only keynames will be returned
        // overwrite caller's setting
        //
        DEBUGMSGA ((
            DBG_REGENUM,
            "pGetRegEnumInfoA: no value pattern specified; forcing EnumDirNames to TRUE"
            ));
        EnumKeyNames = TRUE;
    }

    if (EnumKeyNames) {
        RegEnumInfo->Flags |= REIF_RETURN_KEYS;
    }
    if (ValuesFirst) {
        RegEnumInfo->Flags |= REIF_VALUES_FIRST;
    }
    if (DepthFirst) {
        RegEnumInfo->Flags |= REIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        RegEnumInfo->Flags |= REIF_USE_EXCLUSIONS;
    }

    RegEnumInfo->MaxSubLevel = min (MaxSubLevel, RegEnumInfo->RegPattern->MaxSubLevel);

    return TRUE;
}


BOOL
pGetRegEnumInfoW (
    OUT     PREGENUMINFOW RegEnumInfo,
    IN      PCWSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions
    )
{
    RegEnumInfo->RegPattern = ObsCreateParsedPatternW (EncodedRegPattern);
    if (!RegEnumInfo->RegPattern) {
        DEBUGMSGW ((DBG_ERROR, "pGetRegEnumInfoW: bad EncodedRegPattern: %s", EncodedRegPattern));
        return FALSE;
    }

    if (RegEnumInfo->RegPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsW (
                RegEnumInfo->RegPattern->ExactRoot, //lint !e64
                NULL,
                &RegEnumInfo->RootLevel,
                NULL
                )) {    //lint !e64
            return FALSE;
        }
    } else {
        RegEnumInfo->RootLevel = 1;
    }

    if (!RegEnumInfo->RegPattern->Leaf) {
        //
        // no value pattern specified; assume only keynames will be returned
        // overwrite caller's setting
        //
        DEBUGMSGW ((
            DBG_REGENUM,
            "pGetRegEnumInfoW: no value pattern specified; forcing EnumDirNames to TRUE"
            ));
        EnumKeyNames = TRUE;
    }

    if (EnumKeyNames) {
        RegEnumInfo->Flags |= REIF_RETURN_KEYS;
    }
    if (ValuesFirst) {
        RegEnumInfo->Flags |= REIF_VALUES_FIRST;
    }
    if (DepthFirst) {
        RegEnumInfo->Flags |= REIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        RegEnumInfo->Flags |= REIF_USE_EXCLUSIONS;
    }

    RegEnumInfo->MaxSubLevel = min (MaxSubLevel, RegEnumInfo->RegPattern->MaxSubLevel);

    return TRUE;
}


/*++

Routine Description:

    pGetRegNodeInfo retrieves information about a key, using its name

Arguments:

    RegNode - Receives information about this key

Return Value:

    TRUE if info was successfully read, FALSE otherwise.

--*/

BOOL
pGetRegNodeInfoA (
    IN OUT  PREGNODEA RegNode
    )
{
    LONG rc;

    rc = RegQueryInfoKeyA (
            RegNode->KeyHandle,
            NULL,
            NULL,
            NULL,
            &RegNode->SubKeyCount,
            &RegNode->SubKeyLengthMax,
            NULL,
            &RegNode->ValueCount,
            &RegNode->ValueLengthMax,
            &RegNode->ValueDataSizeMax,
            NULL,
            NULL
            );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    if (RegNode->SubKeyCount) {

        if (RegNode->SubKeyLengthMax) {
            //
            // add space for the NULL
            //
            RegNode->SubKeyLengthMax++;
        } else {
            //
            // OS bug
            //
            RegNode->SubKeyLengthMax = MAX_REGISTRY_KEYA;
        }
        RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (MBCHAR));
    }

    if (RegNode->ValueCount) {
        //
        // add space for the NULL
        //
        RegNode->ValueLengthMax++;
        RegNode->ValueDataSizeMax++;
        RegNode->ValueName = pAllocateMemory (RegNode->ValueLengthMax * DWSIZEOF (MBCHAR));
        RegNode->ValueData = pAllocateMemory (RegNode->ValueDataSizeMax);
        RegNode->Flags |= RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}

BOOL
pGetRegNodeInfoW (
    IN OUT  PREGNODEW RegNode
    )
{
    LONG rc;

    rc = RegQueryInfoKeyW (
            RegNode->KeyHandle,
            NULL,
            NULL,
            NULL,
            &RegNode->SubKeyCount,
            &RegNode->SubKeyLengthMax,
            NULL,
            &RegNode->ValueCount,
            &RegNode->ValueLengthMax,
            &RegNode->ValueDataSizeMax,
            NULL,
            NULL
            );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    if (RegNode->SubKeyCount) {

        if (RegNode->SubKeyLengthMax) {
            //
            // add space for the NULL
            //
            RegNode->SubKeyLengthMax++;
        } else {
            //
            // OS bug
            //
            RegNode->SubKeyLengthMax = MAX_REGISTRY_KEYW;
        }
        RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (WCHAR));
    }

    if (RegNode->ValueCount) {
        //
        // add space for the NULL
        //
        RegNode->ValueLengthMax++;
        RegNode->ValueDataSizeMax++;
        RegNode->ValueName = pAllocateMemory (RegNode->ValueLengthMax * DWSIZEOF (WCHAR));
        RegNode->ValueData = pAllocateMemory (RegNode->ValueDataSizeMax);
        RegNode->Flags |= RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}


/*++

Routine Description:

    pGetCurrentRegNode returns the current reg node to be enumerated, based on DepthFirst flag

Arguments:

    RegEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be retrieved, regardless of
                  DepthFirst flag

Return Value:

    The current node if any or NULL if none remaining.

--*/

PREGNODEA
pGetCurrentRegNodeA (
    IN      PREGTREE_ENUMA RegEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &RegEnum->RegNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (REGNODEA)) {
        return NULL;
    }

    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        return (PREGNODEA)(gb->Buf + gb->End) - 1;
    } else {
        return (PREGNODEA)(gb->Buf + gb->UserIndex);
    }
}

PREGNODEW
pGetCurrentRegNodeW (
    IN      PREGTREE_ENUMW RegEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &RegEnum->RegNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (REGNODEW)) {
        return NULL;
    }

    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        return (PREGNODEW)(gb->Buf + gb->End) - 1;
    } else {
        return (PREGNODEW)(gb->Buf + gb->UserIndex);
    }
}


/*++

Routine Description:

    pDeleteRegNode frees the resources associated with the current reg node and destroys it

Arguments:

    RegEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be deleted, regardless of
                  DepthFirst flag

Return Value:

    TRUE if there was a node to delete, FALSE if no more nodes

--*/

BOOL
pDeleteRegNodeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    IN      BOOL LastCreated
    )
{
    PREGNODEA regNode;
    PGROWBUFFER gb = &RegEnum->RegNodes;

    regNode = pGetCurrentRegNodeA (RegEnum, LastCreated);
    if (!regNode) {
        return FALSE;
    }

    if (regNode->KeyHandle) {
        CloseRegKey (regNode->KeyHandle);
    }
    if (regNode->KeyName) {
        FreePathStringExA (g_RegEnumPool, regNode->KeyName);
    }
    if (regNode->SubKeyName) {
        pFreeMemory (regNode->SubKeyName);
    }
    if (regNode->ValueName) {
        pFreeMemory (regNode->ValueName);
    }
    if (regNode->ValueData) {
        pFreeMemory (regNode->ValueData);
    }

    if (RegEnum->LastNode == regNode) {
        RegEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (REGNODEA);
    } else {
        gb->UserIndex += DWSIZEOF (REGNODEA);
        //
        // reset list
        //
        if (gb->Size - gb->End < DWSIZEOF (REGNODEA)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }
    }

    return TRUE;
}

BOOL
pDeleteRegNodeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    IN      BOOL LastCreated
    )
{
    PREGNODEW regNode;
    PGROWBUFFER gb = &RegEnum->RegNodes;

    regNode = pGetCurrentRegNodeW (RegEnum, LastCreated);
    if (!regNode) {
        return FALSE;
    }

    if (regNode->KeyHandle) {
        CloseRegKey (regNode->KeyHandle);
    }
    if (regNode->KeyName) {
        FreePathStringExW (g_RegEnumPool, regNode->KeyName);
    }
    if (regNode->SubKeyName) {
        pFreeMemory (regNode->SubKeyName);
    }
    if (regNode->ValueName) {
        pFreeMemory (regNode->ValueName);
    }
    if (regNode->ValueData) {
        pFreeMemory (regNode->ValueData);
    }

    if (RegEnum->LastNode == regNode) {
        RegEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (REGNODEW);
    } else {
        gb->UserIndex += DWSIZEOF (REGNODEW);
        //
        // reset list
        //
        if (gb->Size - gb->End < DWSIZEOF (REGNODEW)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }
    }

    return TRUE;
}


/*++

Routine Description:

    pCreateRegNode creates a new node given a context, a key name or a parent node

Arguments:

    RegEnum - Specifies the context
    KeyName - Specifies the key name of the new node; may be NULL only if ParentNode is not NULL
    ParentNode - Specifies a pointer to the parent node of the new node; a pointer to the node
                 is required because the parent node location in memory may change as a result
                 of the growbuffer changing buffer location when it grows;
                 may be NULL only if KeyName is not;
    Ignore - Receives a meaningful value only if NULL is returned (no node created);
             if TRUE upon return, the failure of node creation should be ignored

Return Value:

    A pointer to the new node or NULL if no node was created

--*/

PREGNODEA
pCreateRegNodeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    IN      PCSTR KeyName,              OPTIONAL
    IN      PREGNODEA* ParentNode,      OPTIONAL
    IN      PBOOL Ignore                OPTIONAL
    )
{
    PREGNODEA newNode;
    PSTR newKeyName;
    REGSAM prevMode;
    PSEGMENTA FirstSegment;
    LONG offset = 0;

    if (KeyName) {
        newKeyName = DuplicateTextExA (g_RegEnumPool, KeyName, 0, NULL);
    } else {
        MYASSERT (ParentNode);
        newKeyName = JoinPathsInPoolExA ((
                        g_RegEnumPool,
                        (*ParentNode)->KeyName,
                        (*ParentNode)->SubKeyName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        FirstSegment = RegEnum->RegEnumInfo.RegPattern->NodePattern->Pattern->Segment;
        if (FirstSegment->Type == SEGMENTTYPE_EXACTMATCH &&
            !StringIMatchByteCountA (
                    FirstSegment->Exact.LowerCasePhrase,
                    newKeyName,
                    FirstSegment->Exact.PhraseBytes
                    )) {
            DEBUGMSGA ((
                DBG_REGENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newKeyName
                ));

            FreeTextExA (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // look if this key and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2A (ELT_REGKEY, newKeyName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {

            DEBUGMSGA ((
                DBG_REGENUM,
                "Skipping tree %s\\%s because it's excluded",
                newKeyName,
                RegEnum->RegEnumInfo.RegPattern->Leaf
                ));

            FreeTextExA (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PREGNODEA) GbGrow (&RegEnum->RegNodes, DWSIZEOF (REGNODEA));
    if (!newNode) {
        FreeTextExA (g_RegEnumPool, newKeyName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PREGNODEA)(RegEnum->RegNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (REGNODEA));

    newNode->KeyName = newKeyName;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);

    if (ParentNode) {
        newNode->KeyHandle = OpenRegKeyA ((*ParentNode)->KeyHandle, (*ParentNode)->SubKeyName);
        newNode->Flags |= RNF_RETURN_KEYS;
    } else {
        newNode->KeyHandle = OpenRegKeyStrA (newNode->KeyName);
    }

    SetRegOpenAccessMode (prevMode);

    if (!newNode->KeyHandle) {
        DEBUGMSGA ((
            DBG_REGENUM,
            "pCreateRegNodeA: Cannot open registry key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    if (!pGetRegNodeInfoA (newNode)) {
        DEBUGMSGA ((
            DBG_REGENUM,
            "pCreateRegNodeA: Cannot get info for key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    newNode->EnumState = RNS_ENUM_INIT;

    if ((RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternA (RegEnum->RegEnumInfo.RegPattern->NodePattern, newKeyName)
        ) {
        newNode->Flags |= RNF_KEYNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (RegEnum->RegEnumInfo.CallbackOnError) {
            *Ignore = (*RegEnum->RegEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    if (newNode) {
        pDeleteRegNodeA (RegEnum, TRUE);
    }
    return NULL;
}

PREGNODEW
pCreateRegNodeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    IN      PCWSTR KeyName,             OPTIONAL
    IN      PREGNODEW* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PREGNODEW newNode;
    PWSTR newKeyName;
    REGSAM prevMode;
    PSEGMENTW FirstSegment;
    LONG offset = 0;

    if (KeyName) {
        newKeyName = DuplicateTextExW (g_RegEnumPool, KeyName, 0, NULL);
    } else {
        MYASSERT (ParentNode);
        newKeyName = JoinPathsInPoolExW ((
                        g_RegEnumPool,
                        (*ParentNode)->KeyName,
                        (*ParentNode)->SubKeyName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        FirstSegment = RegEnum->RegEnumInfo.RegPattern->NodePattern->Pattern->Segment;
        if (FirstSegment->Type == SEGMENTTYPE_EXACTMATCH &&
            !StringIMatchByteCountW (
                    FirstSegment->Exact.LowerCasePhrase,
                    newKeyName,
                    FirstSegment->Exact.PhraseBytes
                    )) {    //lint !e64
            DEBUGMSGW ((
                DBG_REGENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newKeyName
                ));

            FreeTextExW (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // look if this key and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2W (ELT_REGKEY, newKeyName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {   //lint !e64

            DEBUGMSGW ((
                DBG_REGENUM,
                "Skipping tree %s\\%s because it's excluded",
                newKeyName,
                RegEnum->RegEnumInfo.RegPattern->Leaf
                ));

            FreeTextExW (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PREGNODEW) GbGrow (&RegEnum->RegNodes, DWSIZEOF (REGNODEW));
    if (!newNode) {
        FreeTextExW (g_RegEnumPool, newKeyName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PREGNODEW)(RegEnum->RegNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (REGNODEW));

    newNode->KeyName = newKeyName;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);

    if (ParentNode) {
        newNode->KeyHandle = OpenRegKeyW ((*ParentNode)->KeyHandle, (*ParentNode)->SubKeyName);
        newNode->Flags |= RNF_RETURN_KEYS;
    } else {
        newNode->KeyHandle = OpenRegKeyStrW (newNode->KeyName);
    }

    SetRegOpenAccessMode (prevMode);

    if (!newNode->KeyHandle) {
        DEBUGMSGW ((
            DBG_REGENUM,
            "pCreateRegNodeW: Cannot open registry key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    if (!pGetRegNodeInfoW (newNode)) {
        DEBUGMSGW ((
            DBG_REGENUM,
            "pCreateRegNodeW: Cannot get info for key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    newNode->EnumState = RNS_ENUM_INIT;

    if ((RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternW (RegEnum->RegEnumInfo.RegPattern->NodePattern, newKeyName)
        ) {
        newNode->Flags |= RNF_KEYNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (RegEnum->RegEnumInfo.CallbackOnError) {
            *Ignore = (*RegEnum->RegEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    if (newNode) {
        pDeleteRegNodeW (RegEnum, TRUE);
    }
    return NULL;
}


/*++

Routine Description:

    pEnumFirstRegRoot enumerates the first root that matches caller's conditions

Arguments:

    RegEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumFirstRegRootA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    PCSTR root;
    BOOL ignore;

    root = RegEnum->RegEnumInfo.RegPattern->ExactRoot;

    if (root) {

        if (pCreateRegNodeA (RegEnum, root, NULL, NULL)) {
            RegEnum->RootState = RES_ROOT_DONE;
            return TRUE;
        }
    } else {

        RegEnum->RootEnum = pAllocateMemory (DWSIZEOF (REGROOT_ENUMA));

        if (!EnumFirstRegRootA (RegEnum->RootEnum)) {
            return FALSE;
        }

        do {
            if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2A (ELT_REGKEY, RegEnum->RootEnum->RegRootName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {
                    DEBUGMSGA ((DBG_REGENUM, "pEnumFirstRegRootA: Root is excluded: %s", RegEnum->RootEnum->RegRootName));
                    continue;
                }
            }
            if (!pCreateRegNodeA (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            RegEnum->RootState = RES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextRegRootA (RegEnum->RootEnum));

        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }

    return FALSE;
}

BOOL
pEnumFirstRegRootW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    PCWSTR root;
    BOOL ignore;

    root = RegEnum->RegEnumInfo.RegPattern->ExactRoot;  //lint !e64

    if (root) {

        if (pCreateRegNodeW (RegEnum, root, NULL, NULL)) {
            RegEnum->RootState = RES_ROOT_DONE;
            return TRUE;
        }
    } else {

        RegEnum->RootEnum = pAllocateMemory (DWSIZEOF (REGROOT_ENUMW));

        if (!EnumFirstRegRootW (RegEnum->RootEnum)) {
            return FALSE;
        }

        do {
            if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2W (ELT_REGKEY, RegEnum->RootEnum->RegRootName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {   //lint !e64
                    DEBUGMSGW ((DBG_REGENUM, "pEnumFirstRegRootW: Root is excluded: %s", RegEnum->RootEnum->RegRootName));
                    continue;
                }
            }
            if (!pCreateRegNodeW (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            RegEnum->RootState = RES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextRegRootW (RegEnum->RootEnum));

        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }

    return FALSE;
}


/*++

Routine Description:

    pEnumNextRegRoot enumerates the next root that matches caller's conditions

Arguments:

    RegEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumNextRegRootA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    BOOL ignore;

    while (EnumNextRegRootA (RegEnum->RootEnum)) {
        if (pCreateRegNodeA (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    RegEnum->RootState = RES_ROOT_DONE;

    return FALSE;
}

BOOL
pEnumNextRegRootW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    BOOL ignore;

    while (EnumNextRegRootW (RegEnum->RootEnum)) {
        if (pCreateRegNodeW (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    RegEnum->RootState = RES_ROOT_DONE;

    return FALSE;
}


/*++

Routine Description:

    pEnumNextValue enumerates the next value that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new value was found; FALSE if not

--*/

BOOL
pEnumNextValueA (
    IN OUT  PREGNODEA RegNode
    )
{
    LONG rc;
    DWORD valueNameLength;

    RegNode->ValueIndex++;
    if (RegNode->ValueIndex > RegNode->ValueCount) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    valueNameLength = RegNode->ValueLengthMax;
    RegNode->ValueDataSize = RegNode->ValueDataSizeMax;

    rc = RegEnumValueA (
            RegNode->KeyHandle,
            RegNode->ValueIndex - 1,
            RegNode->ValueName,
            &valueNameLength,
            NULL,
            &RegNode->ValueType,
            RegNode->ValueData,
            &RegNode->ValueDataSize
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : (DWORD)rc);
        return FALSE;
    }

    RegNode->Flags &= ~(RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID);

    return TRUE;
}

BOOL
pEnumNextValueW (
    IN OUT  PREGNODEW RegNode
    )
{
    LONG rc;
    DWORD valueNameLength;

    RegNode->ValueIndex++;
    if (RegNode->ValueIndex > RegNode->ValueCount) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    valueNameLength = RegNode->ValueLengthMax;
    RegNode->ValueDataSize = RegNode->ValueDataSizeMax;

    rc = RegEnumValueW (
            RegNode->KeyHandle,
            RegNode->ValueIndex - 1,
            RegNode->ValueName,
            &valueNameLength,
            NULL,
            &RegNode->ValueType,
            RegNode->ValueData,
            &RegNode->ValueDataSize
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : (DWORD)rc);
        return FALSE;
    }

    RegNode->Flags &= ~(RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID);

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstValue enumerates the first value that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first value was found; FALSE if not

--*/

BOOL
pEnumFirstValueA (
    IN OUT  PREGNODEA RegNode
    )
{
    RegNode->ValueIndex = 0;
    return pEnumNextValueA (RegNode);
}

BOOL
pEnumFirstValueW (
    OUT     PREGNODEW RegNode
    )
{
    RegNode->ValueIndex = 0;
    return pEnumNextValueW (RegNode);
}


/*++

Routine Description:

    pEnumNextSubKey enumerates the next subkey that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new subkey was found; FALSE if not

--*/

BOOL
pEnumNextSubKeyA (
    IN OUT  PREGNODEA RegNode
    )
{
    LONG rc;

    RegNode->SubKeyIndex++;

    do {
        rc = RegEnumKeyA (
                RegNode->KeyHandle,
                RegNode->SubKeyIndex - 1,
                RegNode->SubKeyName,
                RegNode->SubKeyLengthMax
                );

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        if (rc == ERROR_MORE_DATA) {
            //
            // double the current buffer size
            //
            MYASSERT (RegNode->SubKeyName);
            pFreeMemory (RegNode->SubKeyName);
            RegNode->SubKeyLengthMax *= 2;
            RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (MBCHAR));
        }

    } while (rc == ERROR_MORE_DATA);

    return rc == ERROR_SUCCESS;
}

BOOL
pEnumNextSubKeyW (
    IN OUT  PREGNODEW RegNode
    )
{
    LONG rc;

    RegNode->SubKeyIndex++;

    do {
        rc = RegEnumKeyW (
                RegNode->KeyHandle,
                RegNode->SubKeyIndex - 1,
                RegNode->SubKeyName,
                RegNode->SubKeyLengthMax
                );

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        if (rc == ERROR_MORE_DATA) {
            //
            // double the current buffer size
            //
            MYASSERT (RegNode->SubKeyName);
            pFreeMemory (RegNode->SubKeyName);
            RegNode->SubKeyLengthMax *= 2;
            RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (WCHAR));
        }

    } while (rc == ERROR_MORE_DATA);

    return rc == ERROR_SUCCESS;
}


/*++

Routine Description:

    pEnumFirstSubKey enumerates the first subkey that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first subkey was found; FALSE if not

--*/

BOOL
pEnumFirstSubKeyA (
    IN OUT  PREGNODEA RegNode
    )
{
    RegNode->SubKeyIndex = 0;
    return pEnumNextSubKeyA (RegNode);
}

BOOL
pEnumFirstSubKeyW (
    OUT     PREGNODEW RegNode
    )
{
    RegNode->SubKeyIndex = 0;
    return pEnumNextSubKeyW (RegNode);
}


/*++

Routine Description:

    pEnumNextRegObjectInTree is a private function that enumerates the next node matching
    the specified criteria; it's implemented as a state machine that travels the keys/values
    as specified the the caller; it doesn't check if they actually match the patterns

Arguments:

    RegEnum - Specifies the current enum context; receives updated info
    CurrentKeyNode - Receives the key node that is currently processed, if success is returned

Return Value:

    TRUE if a next match was found; FALSE if no more keys/values match

--*/

BOOL
pEnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    OUT     PREGNODEA* CurrentKeyNode
    )
{
    PREGNODEA currentNode;
    PREGNODEA newNode;
    PCSTR valueName;
    BOOL ignore;
    LONG rc;

    while ((currentNode = pGetCurrentRegNodeA (RegEnum, FALSE)) != NULL) {

        *CurrentKeyNode = currentNode;

        switch (currentNode->EnumState) {

        case RNS_VALUE_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTLEAF) {

                valueName = RegEnum->RegEnumInfo.RegPattern->Leaf;
                MYASSERT (valueName);

                currentNode->EnumState = RNS_VALUE_DONE;
                currentNode->ValueDataSize = currentNode->ValueDataSizeMax;

                rc = RegQueryValueExA (
                        currentNode->KeyHandle,
                        valueName,
                        NULL,
                        &currentNode->ValueType,
                        currentNode->ValueData,
                        &currentNode->ValueDataSize
                        );
                if (rc == ERROR_SUCCESS) {
                    if (SizeOfStringA (valueName) <=
                        currentNode->ValueLengthMax * DWSIZEOF (MBCHAR)
                        ) {
                        StringCopyA (currentNode->ValueName, valueName);
                        currentNode->Flags &= ~(RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID);
                        return TRUE;
                    }
                }

            } else {

                if (pEnumFirstValueA (currentNode)) {
                    currentNode->EnumState = RNS_VALUE_NEXT;
                    return TRUE;
                }
                currentNode->EnumState = RNS_VALUE_DONE;
            }
            break;

        case RNS_VALUE_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (pEnumNextValueA (currentNode)) {
                return TRUE;
            }

            //
            // no more values for this one, go to the next
            //
            currentNode->EnumState = RNS_VALUE_DONE;
            //
            // fall through
            //
        case RNS_VALUE_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) || !currentNode->SubKeyCount) {
                //
                // done with this node
                //
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }
            //
            // now enum subkeys
            //
            currentNode->EnumState = RNS_SUBKEY_FIRST;
            //
            // fall through
            //
        case RNS_SUBKEY_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            //
            // check new node's level; if too large, quit
            //
            if (currentNode->SubLevel >= RegEnum->RegEnumInfo.MaxSubLevel) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (!pEnumFirstSubKeyA (currentNode)) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            currentNode->EnumState = RNS_SUBKEY_NEXT;
            newNode = pCreateRegNodeA (RegEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // now look at the new node
                //
                if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                    newNode->Flags &= ~RNF_RETURN_KEYS;
                    *CurrentKeyNode = newNode;
                    return TRUE;
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating registry; aborting enumeration"
                    ));
                RegEnum->RootState = RES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case RNS_SUBKEY_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (pEnumNextSubKeyA (currentNode)) {
                newNode = pCreateRegNodeA (RegEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                        newNode->Flags &= ~RNF_RETURN_KEYS;
                        *CurrentKeyNode = newNode;
                        return TRUE;
                    }
                    break;
                }
                if (!ignore) {
                    //
                    // abort enum
                    //
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating registry; aborting enumeration"
                        ));
                    RegEnum->RootState = RES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subkey
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = RNS_SUBKEY_DONE;
            //
            // fall through
            //
        case RNS_SUBKEY_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // now enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = RNS_ENUM_DONE;
            //
            // fall through
            //
        case RNS_ENUM_DONE:

            pDeleteRegNodeA (RegEnum, FALSE);
            break;

        case RNS_ENUM_INIT:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (currentNode->Flags & RNF_RETURN_KEYS) {
                    currentNode->Flags &= ~RNF_RETURN_KEYS;
                    return TRUE;
                }
            }

            if (RegEnum->ControlFlags & RECF_SKIPKEY) {
                RegEnum->ControlFlags &= ~RECF_SKIPKEY;
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }

            if ((RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            if (currentNode->SubKeyCount) {
                //
                // enum keys
                //
                if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTNODE) {
                    currentNode->EnumState = RNS_SUBKEY_DONE;
                } else {
                    currentNode->EnumState = RNS_SUBKEY_FIRST;
                }
                break;
            }
            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            currentNode->EnumState = RNS_ENUM_DONE;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}

BOOL
pEnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    OUT     PREGNODEW* CurrentKeyNode
    )
{
    PREGNODEW currentNode;
    PREGNODEW newNode;
    PCWSTR valueName;
    BOOL ignore;
    LONG rc;

    while ((currentNode = pGetCurrentRegNodeW (RegEnum, FALSE)) != NULL) {

        *CurrentKeyNode = currentNode;

        switch (currentNode->EnumState) {

        case RNS_VALUE_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTLEAF) {

                valueName = RegEnum->RegEnumInfo.RegPattern->Leaf;  //lint !e64
                MYASSERT (valueName);

                currentNode->EnumState = RNS_VALUE_DONE;
                currentNode->ValueDataSize = currentNode->ValueDataSizeMax;

                rc = RegQueryValueExW (
                        currentNode->KeyHandle,
                        valueName,
                        NULL,
                        &currentNode->ValueType,
                        currentNode->ValueData,
                        &currentNode->ValueDataSize
                        );
                if (rc == ERROR_SUCCESS) {
                    if (SizeOfStringW (valueName) <=
                        currentNode->ValueLengthMax * DWSIZEOF (WCHAR)
                        ) {
                        StringCopyW (currentNode->ValueName, valueName);
                        currentNode->Flags &= ~(RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID);
                        return TRUE;
                    }
                }

            } else {

                if (pEnumFirstValueW (currentNode)) {
                    currentNode->EnumState = RNS_VALUE_NEXT;
                    return TRUE;
                }
                currentNode->EnumState = RNS_VALUE_DONE;
            }
            break;

        case RNS_VALUE_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (pEnumNextValueW (currentNode)) {
                return TRUE;
            }
            //
            // no more values for this one, go to the next
            //
            currentNode->EnumState = RNS_VALUE_DONE;
            //
            // fall through
            //
        case RNS_VALUE_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) || !currentNode->SubKeyCount) {
                //
                // done with this node
                //
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }
            //
            // now enum subkeys
            //
            currentNode->EnumState = RNS_SUBKEY_FIRST;
            //
            // fall through
            //
        case RNS_SUBKEY_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            //
            // check new node's level; if too large, quit
            //
            if (currentNode->SubLevel >= RegEnum->RegEnumInfo.MaxSubLevel) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (!pEnumFirstSubKeyW (currentNode)) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            currentNode->EnumState = RNS_SUBKEY_NEXT;
            newNode = pCreateRegNodeW (RegEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // now look at the new node
                //
                if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                    newNode->Flags &= ~RNF_RETURN_KEYS;
                    *CurrentKeyNode = newNode;
                    return TRUE;
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGW ((
                    DBG_ERROR,
                    "Error encountered enumerating registry; aborting enumeration"
                    ));
                RegEnum->RootState = RES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case RNS_SUBKEY_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (pEnumNextSubKeyW (currentNode)) {
                newNode = pCreateRegNodeW (RegEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                        newNode->Flags &= ~RNF_RETURN_KEYS;
                        *CurrentKeyNode = newNode;
                        return TRUE;
                    }
                    break;
                }
                if (!ignore) {
                    //
                    // abort enum
                    //
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "Error encountered enumerating registry; aborting enumeration"
                        ));
                    RegEnum->RootState = RES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subkey
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = RNS_SUBKEY_DONE;
            //
            // fall through
            //
        case RNS_SUBKEY_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // now enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = RNS_ENUM_DONE;
            //
            // fall through
            //
        case RNS_ENUM_DONE:

            pDeleteRegNodeW (RegEnum, FALSE);
            break;

        case RNS_ENUM_INIT:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (currentNode->Flags & RNF_RETURN_KEYS) {
                    currentNode->Flags &= ~RNF_RETURN_KEYS;
                    return TRUE;
                }
            }

            if (RegEnum->ControlFlags & RECF_SKIPKEY) {
                RegEnum->ControlFlags &= ~RECF_SKIPKEY;
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }

            if ((RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            if (currentNode->SubKeyCount) {
                //
                // enum keys
                //
                if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTNODE) {
                    currentNode->EnumState = RNS_SUBKEY_DONE;
                } else {
                    currentNode->EnumState = RNS_SUBKEY_FIRST;
                }
                break;
            }
            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            currentNode->EnumState = RNS_ENUM_DONE;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}


/*++

Routine Description:

    EnumFirstRegObjectInTreeEx enumerates registry keys, and optionally values, that match the
    specified criteria

Arguments:

    RegEnum - Receives the enum context info; this will be used in subsequent calls to
              EnumNextRegObjectInTree
    EncodedRegPattern - Specifies the encoded key pattern (encoded as defined by the
                        ParsedPattern functions)
    EncodedValuePattern - Specifies the encoded value pattern (encoded as defined by the
                          ParsedPattern functions); optional; NULL means no values
                          should be returned (only look for keys)
    EnumKeyNames - Specifies TRUE if key names should be returned during the enumeration
                   (if they match the pattern); a key name is returned before any of its
                   subkeys or values
    ValuesFirst - Specifies TRUE if a key's values should be returned before key's subkeys;
                  this parameter decides the enum order between values and subkeys
                  for each key
    DepthFirst - Specifies TRUE if the current subkey of any key should be fully enumerated
                 before going to the next subkey; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a key that is to be enumerated,
                  relative to the root; if 0, only the root is enumerated;
                  if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    keys/values are excluded from enumeration; this slows down the speed
    CallbackOnError - Specifies a pointer to a callback function that will be called during
                      enumeration if an error occurs; if the callback is defined and it
                      returns FALSE, the enumeration is aborted, otherwise it will continue
                      ignoring the error

Return Value:

    TRUE if a first match is found.
    FALSE otherwise.

--*/

BOOL
EnumFirstRegObjectInTreeExA (
    OUT     PREGTREE_ENUMA RegEnum,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      RPE_ERROR_CALLBACKA CallbackOnError     OPTIONAL
    )
{
    MYASSERT (RegEnum && EncodedRegPattern && *EncodedRegPattern);

    ZeroMemory (RegEnum, DWSIZEOF (REGTREE_ENUMA));  //lint !e613 !e668

    //
    // first try to get reg enum info in internal format
    //
    if (!pGetRegEnumInfoA (
            &RegEnum->RegEnumInfo,
            EncodedRegPattern,
            EnumKeyNames,
            ValuesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions
            )) {    //lint !e613
        AbortEnumRegObjectInTreeA (RegEnum);
        return FALSE;
    }
    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) { //lint !e613
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedA (ELT_REGKEY, RegEnum->RegEnumInfo.RegPattern)) {    //lint !e613
            DEBUGMSGA ((
                DBG_REGENUM,
                "EnumFirstRegObjectInTreeExA: Root is excluded: %s",
                EncodedRegPattern
                ));
            AbortEnumRegObjectInTreeA (RegEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstRegRootA (RegEnum)) {
        AbortEnumRegObjectInTreeA (RegEnum);
        return FALSE;
    }

    /*lint -e(613)*/RegEnum->RegEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextRegObjectInTreeA (RegEnum);
}

BOOL
EnumFirstRegObjectInTreeExW (
    OUT     PREGTREE_ENUMW RegEnum,
    IN      PCWSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      RPE_ERROR_CALLBACKW CallbackOnError     OPTIONAL
    )
{
    MYASSERT (RegEnum && EncodedRegPattern && *EncodedRegPattern);

    ZeroMemory (RegEnum, DWSIZEOF (REGTREE_ENUMW));  //lint !e613 !e668

    //
    // first try to get reg enum info in internal format
    //
    if (!pGetRegEnumInfoW (
            &RegEnum->RegEnumInfo,
            EncodedRegPattern,
            EnumKeyNames,
            ValuesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions
            )) {    //lint !e613
        AbortEnumRegObjectInTreeW (RegEnum);
        return FALSE;
    }
    if (/*lint -e(613)*/RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedW (ELT_REGKEY, /*lint -e(613)*/RegEnum->RegEnumInfo.RegPattern)) {
            DEBUGMSGW ((
                DBG_REGENUM,
                "EnumFirstRegObjectInTreeExW: Root is excluded: %s",
                EncodedRegPattern
                ));
            AbortEnumRegObjectInTreeW (RegEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstRegRootW (RegEnum)) {
        AbortEnumRegObjectInTreeW (RegEnum);
        return FALSE;
    }

    /*lint -e(613)*/RegEnum->RegEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextRegObjectInTreeW (RegEnum);
}


/*++

Routine Description:

    EnumNextRegObjectInTree enumerates the next node matching the criteria specified in
    RegEnum; this is filled on the call to EnumFirstRegObjectInTreeEx;

Arguments:

    RegEnum - Specifies the current enum context; receives updated info

Return Value:

    TRUE if a next match was found; FALSE if no more keys/values match

--*/

BOOL
EnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    PREGNODEA currentNode;
    BOOL success;

    MYASSERT (RegEnum);

    do {
        if (RegEnum->EncodedFullName) {
            ObsFreeA (RegEnum->EncodedFullName);
            RegEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = '\\';
                RegEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextRegObjectInTreeA (RegEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->KeyName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & RNF_KEYNAME_MATCHES)) {   //lint !e613
                continue;
            }

            RegEnum->CurrentKeyHandle = /*lint -e(613)*/currentNode->KeyHandle;
            RegEnum->CurrentLevel = RegEnum->RegEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            if ((!currentNode->ValueName) || (currentNode->Flags & RNF_VALUENAME_INVALID)) {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->LastWackPtr = _mbsrchr (RegEnum->Location, '\\');
                if (!RegEnum->LastWackPtr) {
                    RegEnum->Name = RegEnum->Location;
                } else {
                    RegEnum->Name = _mbsinc (RegEnum->LastWackPtr);
                    if (!RegEnum->Name) {
                        RegEnum->Name = RegEnum->Location;
                    }
                }
                RegEnum->CurrentValueData = NULL;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;
                RegEnum->Attributes = REG_ATTRIBUTE_KEY;

                //
                // prepare full path buffer
                //
                StringCopyA (RegEnum->NativeFullName, RegEnum->Location);
                RegEnum->LastNode = currentNode;
                RegEnum->RegNameAppendPos = NULL;

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2A (ELT_REGKEY, RegEnum->Location, NULL)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s was found, but it's excluded",
                            RegEnum->Location
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                    RegEnum->Location,
                                                    NULL,
                                                    TRUE
                                                    );
            } else {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->Name = /*lint -e(613)*/currentNode->ValueName;
                RegEnum->CurrentValueData = /*lint -e(613)*/currentNode->ValueData;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;

                if (RegEnum->LastNode != currentNode) {
                    RegEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    RegEnum->NativeFullName[0] = 0;
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->NativeFullName, RegEnum->Location);
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->RegNameAppendPos, "\\[");
                } else if (!RegEnum->RegNameAppendPos) {
                    RegEnum->RegNameAppendPos = GetEndOfStringA (RegEnum->NativeFullName);
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->RegNameAppendPos, "\\[");
                }

                MYASSERT (RegEnum->Name);

                if (RegEnum->RegNameAppendPos + SizeOfStringA (RegEnum->Name) / DWSIZEOF(CHAR)>
                    RegEnum->NativeFullName + DWSIZEOF (RegEnum->NativeFullName) / DWSIZEOF(CHAR)) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "EnumNextRegObjectInTreeA: RegKey %s <%s> was found, but it's path is too long",
                        RegEnum->Location,
                        RegEnum->Name
                        ));
                    continue;
                }

                StringCopyA (RegEnum->RegNameAppendPos, RegEnum->Name);
                StringCatA (RegEnum->RegNameAppendPos, "]");

                RegEnum->Attributes = REG_ATTRIBUTE_VALUE;

                //
                // now test if the value matches
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !TestParsedPatternA (
                            RegEnum->RegEnumInfo.RegPattern->LeafPattern,
                            RegEnum->Name
                            )
                   ) {
                    continue;
                }

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (RegEnum->Name && ElIsExcludedA (ELT_REGVALUE, RegEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s <%s> was found, but it's excluded by value name",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                    if (ElIsExcluded2A (ELT_REGKEY, RegEnum->Location, RegEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s <%s> was found, but it's excluded",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                    RegEnum->Location,
                                                    RegEnum->Name,
                                                    TRUE
                                                    );
            }

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = 0;
            }

            return TRUE;
        }

        //
        // try the next root
        //
        if (RegEnum->RootState == RES_ROOT_DONE) {
            break;
        }

        MYASSERT (RegEnum->RootState == RES_ROOT_NEXT);
        MYASSERT (RegEnum->RootEnum);
        success = pEnumNextRegRootA (RegEnum);

    } while (success);

    AbortEnumRegObjectInTreeA (RegEnum);

    return FALSE;
}

BOOL
EnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    PREGNODEW currentNode;
    BOOL success;

    MYASSERT (RegEnum);

    do {
        if (RegEnum->EncodedFullName) {
            ObsFreeW (RegEnum->EncodedFullName);
            RegEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = L'\\';
                RegEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextRegObjectInTreeW (RegEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->KeyName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & RNF_KEYNAME_MATCHES)) {   //lint !e613
                continue;
            }

            RegEnum->CurrentKeyHandle = /*lint -e(613)*/currentNode->KeyHandle;
            RegEnum->CurrentLevel = RegEnum->RegEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            if ((!currentNode->ValueName) || (currentNode->Flags & RNF_VALUENAME_INVALID)) {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->LastWackPtr = wcsrchr (RegEnum->Location, L'\\');
                if (!RegEnum->LastWackPtr) {
                    RegEnum->Name = RegEnum->Location;
                } else {
                    RegEnum->Name = RegEnum->LastWackPtr + 1;
                    if (!RegEnum->Name) {
                        RegEnum->Name = RegEnum->Location;
                    }
                }
                RegEnum->CurrentValueData = NULL;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;
                RegEnum->Attributes = REG_ATTRIBUTE_KEY;
                //
                // prepare full path buffer
                //
                StringCopyW (RegEnum->NativeFullName, RegEnum->Location);
                RegEnum->LastNode = currentNode;
                RegEnum->RegNameAppendPos = NULL;

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2W (ELT_REGKEY, RegEnum->Location, NULL)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s was found, but it's excluded",
                            RegEnum->Location
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                    RegEnum->Location,
                                                    NULL,
                                                    TRUE
                                                    );
            } else {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->Name = /*lint -e(613)*/currentNode->ValueName;
                RegEnum->CurrentValueData = /*lint -e(613)*/currentNode->ValueData;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;

                if (RegEnum->LastNode != currentNode) {
                    RegEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    RegEnum->NativeFullName[0] = 0;
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->NativeFullName, RegEnum->Location);
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->RegNameAppendPos, L"\\[");
                } else if (!RegEnum->RegNameAppendPos) {
                    RegEnum->RegNameAppendPos = GetEndOfStringW (RegEnum->NativeFullName);
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->RegNameAppendPos, L"\\[");
                }

                MYASSERT (RegEnum->Name);

                if (RegEnum->RegNameAppendPos + SizeOfStringW (RegEnum->Name) / DWSIZEOF(WCHAR)>
                    RegEnum->NativeFullName + DWSIZEOF (RegEnum->NativeFullName) / DWSIZEOF(WCHAR)) {
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "EnumNextRegObjectInTreeW: RegKey %s <%s> was found, but it's path is too long",
                        RegEnum->Location,
                        RegEnum->Name
                        ));
                    continue;
                }

                StringCopyW (RegEnum->RegNameAppendPos, RegEnum->Name);
                StringCatW (RegEnum->RegNameAppendPos, L"]");

                RegEnum->Attributes = REG_ATTRIBUTE_VALUE;

                //
                // now test if the value matches
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !TestParsedPatternW (
                            RegEnum->RegEnumInfo.RegPattern->LeafPattern,
                            RegEnum->Name
                            )
                   ) {
                    continue;
                }

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (RegEnum->Name && ElIsExcludedW (ELT_REGVALUE, RegEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s <%s> was found, but it's excluded by value name",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                    if (ElIsExcluded2W (ELT_REGKEY, RegEnum->Location, RegEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s <%s> was found, but it's excluded",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                    RegEnum->Location,
                                                    RegEnum->Name,
                                                    TRUE
                                                    );
            }

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = 0;
            }

            return TRUE;
        }

        //
        // try the next root
        //
        if (RegEnum->RootState == RES_ROOT_DONE) {
            break;
        }

        MYASSERT (RegEnum->RootState == RES_ROOT_NEXT);
        MYASSERT (RegEnum->RootEnum);
        success = pEnumNextRegRootW (RegEnum);

    } while (success);

    AbortEnumRegObjectInTreeW (RegEnum);

    return FALSE;
}


/*++

Routine Description:

    AbortEnumRegObjectInTree aborts the enumeration, freeing all resources allocated

Arguments:

    RegEnum - Specifies the current enum context; receives a "clean" context

Return Value:

    none

--*/

VOID
AbortEnumRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    while (pDeleteRegNodeA (RegEnum, TRUE)) {
    }
    GbFree (&RegEnum->RegNodes);

    if (RegEnum->EncodedFullName) {
        ObsFreeA (RegEnum->EncodedFullName);
        RegEnum->EncodedFullName = NULL;
    }

    if (RegEnum->RegEnumInfo.RegPattern) {
        ObsDestroyParsedPatternA (RegEnum->RegEnumInfo.RegPattern);
        RegEnum->RegEnumInfo.RegPattern = NULL;
    }

    if (RegEnum->RootEnum) {
        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }
}

VOID
AbortEnumRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    while (pDeleteRegNodeW (RegEnum, TRUE)) {
    }
    GbFree (&RegEnum->RegNodes);

    if (RegEnum->EncodedFullName) {
        ObsFreeW (RegEnum->EncodedFullName);
        RegEnum->EncodedFullName = NULL;
    }

    if (RegEnum->RegEnumInfo.RegPattern) {
        ObsDestroyParsedPatternW (RegEnum->RegEnumInfo.RegPattern);
        RegEnum->RegEnumInfo.RegPattern = NULL;
    }

    if (RegEnum->RootEnum) {
        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\makefile.inc ===
C6_LOC=$(_NTDRIVE)\dosdev\c6

!IFNDEF DEBUG
DEBUG=0
!ENDIF

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IF $(DEBUG)
C_DBG_FLAGS= -Zi -Od -DDBG=1
ASM_DBG_FLAGS= -Zi
LINK_DBG_FLAGS= /codeview
!ELSE
C_DBG_FLAGS=-DDBG=0
ASM_DBG_FLAGS=
LINK_DBG_FLAGS=
!ENDIF

CC= cl16
CFLAGS= -W3 -Zel -G2 -AL $(C_DBG_FLAGS)
CINC= -X -I..\inc -I. -I$(C6_LOC)\include

AS= masm
AFLAGS= -Ml $(ASM_DBG_FLAGS)
AINC= -X -I.


.c.obj:
    $(CC) $(CFLAGS) $(CINC) -c $*.c

.c.cod:
    $(CC) $(CFLAGS) $(CINC) -Fc -c $*.c

.asm.obj:
    $(AS) $(AFLAGS) $(AINC) $*.asm;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\reg\regtrack.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regtrack.c

Abstract:

  Routines to track calls to registry APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  02-Sept-1997

Revisions:

  marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/


#include "pch.h"

#ifdef DEBUG


#undef RegOpenKeyExA
#undef RegCreateKeyExA
#undef RegOpenKeyExW
#undef RegCreateKeyExW

#define DBG_REGTRACK "RegTrack"

#define NO_MATCH        0xffffffff

DWORD g_DontCare;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList = INIT_GROWLIST;

DWORD
pFindKeyReference (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GlGetSize (&g_KeyTrackList);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GlGetItem (&g_KeyTrackList, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
pAddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    Size = sizeof (KEYTRACK) + SizeOfString (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;
    StringCopy (KeyTrack->SubKey, SubKey);

    (VOID)GlAppend (&g_KeyTrackList, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
pAddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    AnsiSubKey = ConvertWtoA (SubKey);
    pAddKeyReferenceA (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference (Key);
    if (Index != NO_MATCH) {
        GlDeleteItem (&g_KeyTrackList, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GlGetSize (&g_KeyTrackList);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GlGetItem (&g_KeyTrackList, d);
        DEBUGMSG ((DBG_REGTRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }
}

VOID
RegTrackTerminate (
    VOID
    )
{
    GlFree (&g_KeyTrackList);
}

VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReferenceA (Key, SubKey, File, Line);
}


VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReferenceW (Key, SubKey, File, Line);
}


LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference (Key)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Reg key handle closed via CloseRegKey, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExA (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExW (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        pAddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\moricons\dllinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contians the DLL attach/detach event entry point for the
    DOS PIF Setup icons resource DLL.

Author:

    Sunil Pai (sunilp) Feb 5, 1992

Revision History:

--*/

#include <windows.h>

HANDLE ThisDLLHandle;

BOOL
DLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
        break;

    case DLL_PROCESS_DETACH:

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\reg\reg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reg.c

Abstract:

    Implements utilities to parse a registry key string, and also implements
    wrappers to the registry API.  There are three groups of APIs in this
    source file: query functions, open and create functions, and registry
    string parsing functions.

    The query functions allow simplified querying, where the caller receives
    a MemAlloc'd pointer to the data and does not have to worry about managing
    the numerous parameters needed to do the query.  The query functions
    also allow filtering of values that are not the expected type.  All
    query functions have a version with 2 appended to the function name which
    allow the caller to specify an alternative allocator and deallocator.

    The open and create functions simplify the process of obtaining a key
    handle.  They allow the caller to specify a key string as input and return
    the key handle as output.

    The registry string parsing functions are utilities that can be used when
    processing registry key strings.  The functions extract the registry root
    from a string, convert it into a handle, convert a hive handle into a
    string, and so on.

Author:

    Jim Schmidt (jimschm)  20-Mar-1997

Revisions:

    ovidiut     22-Feb-1999 Added GetRegSubkeysCount
    calinn      23-Sep-1998 Fixed REG_SZ filtering
    jimschm     25-Mar-1998 Added CreateEncodedRegistryStringEx
    jimschm     21-Oct-1997 Added EnumFirstKeyInTree/EnumNextKeyInTree
    marcw       16-Jul-1997 Added CreateEncodedRegistryString/FreeEncodedRegistryString
    jimschm     22-Jun-1997 Added GetRegData

--*/

#include "pch.h"

#ifdef DEBUG
#undef RegCloseKey
#endif

HKEY g_Root = HKEY_ROOT;
REGSAM g_OpenSam = KEY_ALL_ACCESS;
REGSAM g_CreateSam = KEY_ALL_ACCESS;

#define DBG_REG     "Reg"

//
// Implementation
//


VOID
SetRegRoot (
    IN      HKEY Root
    )
{
    g_Root = Root;
}

HKEY
GetRegRoot (
    VOID
    )
{
    return g_Root;
}


REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_OpenSam;
    g_OpenSam = Mode;

    return OldMode;
}

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    )
{
    return g_OpenSam;
}

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_CreateSam;
    g_CreateSam = Mode;

    return OldMode;
}

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    )
{
    return g_CreateSam;
}

/*++

Routine Description:

  OpenRegKeyStrA and OpenRegKeyStrW parse a text string that specifies a
  registry key into the hive and subkey, and then they open the subkey
  and return the handle.

Arguments:

  RegKey    - Specifies the complete path to the registry subkey, including
              the hive.

Return Value:

  A non-NULL registry handle if successful, or NULL if either the subkey
  could not be opened or the string is malformed.

--*/

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyA (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = RealOpenRegKeyA (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);
    return Key;
}


HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    PCSTR AnsiRegKey;
    HKEY Key;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return NULL;
    }

    Key = RealOpenRegKeyStrA (AnsiRegKey /* , */ DEBUG_TRACKING_ARGS);

    FreeConvertedStr (AnsiRegKey);

    return Key;
}

PVOID
MemAllocWrapper (
    IN      DWORD Size
    )

/*++

Routine Description:

  pemAllocWrapper implements a default allocation routine.  The APIs
  that have a "2" at the end allow the caller to supply an alternative
  allocator or deallocator.  The routines without the "2" use this
  default allocator.

Arguments:

  Size - Specifies the amount of memory (in bytes) to allocate

Return Value:

  A pointer to a block of memory that can hold Size bytes, or NULL
  if allocation fails.

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}


VOID
MemFreeWrapper (
    IN      PVOID Mem
    )

/*++

Routine Description:

  MemFreeWrapper implements a default deallocation routine.
  See MemAllocWrapper above.

Arguments:

  Mem - Specifies the block of memory to free, and was allocated by the
        MemAllocWrapper function.

Return Value:

  none

--*/

{
    MemFree (g_hHeap, 0, Mem);
}


/*++

Routine Description:

  GetRegValueData2A and GetRegValueData2W query a registry value and
  return the data as a pointer.  They use the specified Alloc and Free
  routines to allocate and free the memory as needed.

  A GetRegValueData macro is defined, and it uses the default allocators,
  simplifying the function parameters and allowing the caller to free
  the return value via MemFree.

Arguments:

  hKey  - Specifies the registry key that holds the specified value.

  Value - Specifies the value name to query.

  Alloc - Specifies the allocation routine, called to allocate a block of
          memory for the return data.

  FreeRoutine  - Specifies the deallocation routine, called if an error is encountered
          during processing.

Return Value:

  A pointer to the data retrieved, or NULL if the value does not exist or an
  error occurred.  Call GetLastError to obtian the failure code.

--*/

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = RegQueryValueExA (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (CHAR));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = RegQueryValueExW (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }


    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


/*++

Routine Description:

  GetRegValueDataOfType2A and GetRegValueDataOfType2W are extensions of
  GetRegValueData.  They only return a data pointer when the data stored
  in the registry value is the correct type.

Arguments:

  hKey - Specifies the registry key to query

  Value - Specifies the value name to query

  MustBeType - Specifies the type of data (a REG_* constant).  If the specified
               value has data but is a different type, NULL will be returned.

  AllocRoutine - Specifies the allocation routine, called to allocate the return data.

  FreeRoutine - Specifies the deallocation routine, called when an error is encountered.

Return Value:

  If successful, returns a pointer to data that matches the specified type.
  If the data is a different type, the value name does not exist, or an
  error occurs during the query, NULL is returned, and the failure code
  can be obtained from GetLastError.

--*/


PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExA (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    switch (MustBeType) {

    case REG_SZ:
    case REG_EXPAND_SZ:
        if (Type == REG_SZ) {
            break;
        }
        if (Type == REG_EXPAND_SZ) {
            break;
        }
        return NULL;

    default:
        if (Type == MustBeType) {
            break;
        }
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (CHAR));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExW (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }
    switch (MustBeType) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            if (Type == REG_SZ) break;
            if (Type == REG_EXPAND_SZ) break;
            return NULL;
        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            if (Type == REG_DWORD) break;
            if (Type == REG_DWORD_BIG_ENDIAN) break;
            return NULL;
        default:
            if (Type == MustBeType) break;
            return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size;

    rc = RegQueryValueExA (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size;

    rc = RegQueryValueExW (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  GetRegKeyData2A and GetRegKeyData2W return default data associated
  with a registry key.  They open the specified subkey, query the value,
  close the subkey and return the data.

Arguments:

  Parent - Specifies the key that contains SubKey.

  SubKey - Specifies the name of the subkey to obtain the default value for.

  AllocRoutine  - Specifies the allocation routine, called to allocate a block of
           memory for the registry data.

  FreeRoutine   - Specifies the deallocation routine, called to free the block of
           data if an error occurs.

Return Value:

  A pointer to the block of data obtained from the subkey's default value,
  or NULL if the subkey does not exist or an error was encountered.  Call
  GetLastError for a failure code.

--*/

PBYTE
GetRegKeyData2A (
    IN      HKEY Parent,
    IN      PCSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyA (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2A (SubKeyHandle, "", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


PBYTE
GetRegKeyData2W (
    IN      HKEY Parent,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyW (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2W (SubKeyHandle, L"", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


/*++

Routine Description:

  GetRegData2A and GetRegData2W open a registry key, query a value,
  close the registry key and return the value.

Arguments:

  KeyString - Specifies the registry key to open

  ValueName - Specifies the value to query

  AllocRoutine - Specifies the allocation routine, used to allocate a block of
          memory to hold the value data

  FreeRoutine  - Specifies the deallocation routine, used to free the block of
          memory when an error is encountered.

Return Value:

  A pointer to the registry data retrieved, or NULL if the key or value
  does not exist, or if an error occurs. Call GetLastError for a failure code.

--*/

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrA (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2A (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrW (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2W (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    )
/*++

Routine Description:

  GetRegSubkeysCount retrieves the number of subkeys of a given parent key.

Arguments:

  ParentKey - Specifies a handle to the parent registry key.

  SubKeyCount - Receives the number of subkeys

  MaxSubKeyLen - Receives the length, in chars, of the longest subkey string

Return Value:

  TRUE if the count was retrieved successfully, FALSE otherwise.
  In this case, call GetLastError for a failure code.

--*/

{
    LONG rc;

    rc = RegQueryInfoKey (
                ParentKey,
                NULL,
                NULL,
                NULL,
                SubKeyCount,
                MaxSubKeyLen,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  CreateRegKeyA and CreateRegKeyW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the new key.

  NewKeyName - Specifies the name of the subkey to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExA (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExW (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


/*++

Routine Description:

  CreateRegKeyStrA and CreateRegKeyStrW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  NewKeyName - Specifies the full path to the key to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    CHAR RegKey[MAX_REGISTRY_KEYA];
    PCSTR Start;
    PCSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyA (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyA (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = _mbschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringA (Start);
        }

        StringCopyABA (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) { //lint !e613
            rc = OurRegOpenKeyExA (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExA (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) { //lint !e613
            Start = _mbsinc (Start);
        }

    } while (*Start);   //lint !e613

    return Parent;
}


HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    WCHAR RegKey[MAX_REGISTRY_KEYW];
    PCWSTR Start;
    PCWSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyW (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyW (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = wcschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringW (Start);
        }

        StringCopyABW (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) {
            rc = OurRegOpenKeyExW (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExW (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) {
            Start++;
        }
    } while (*Start);

    return Parent;
}


/*++

Routine Description:

  OpenRegKeyA and OpenRegKeyW open a subkey.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the subkey.

  KeyToOpen - Specifies the name of the subkey to open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY SubKey;
    LONG rc;

    rc = OurRegOpenKeyExA (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;

    rc = OurRegOpenKeyExW (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


LONG
RealCloseRegKey (
    IN      HKEY Key
    )

/*++

Routine Description:

  RealCloseRegKey closes the reg handle supplied, unless the handle is
  a pre-defined Win32 handle.  The CloseRegKey macro resolves directly
  to this function in the free build, and to OurCloseRegKey in the
  checked build.

Arguments:

  Key       - Specifies the reg handle to close

Return Value:

  A standard Win32 error code indicating outcome.

--*/

{
    LONG rc = ERROR_INVALID_HANDLE;

    if (!Key) {
        return ERROR_SUCCESS;
    }

    if (GetOffsetOfRootKey (Key)) {
        return ERROR_SUCCESS;
    }

    __try {
        rc = RegCloseKey (Key);
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_WHOOPS, "RegCloseKey threw an exception!"));
    }

    return rc;
}


/*++

Routine Description:

  GetOffsetOfRootString returns a non-zero offset to the g_RegRoots table
  below.  The offset can be used with GetRootStringFromOffset and
  GetRootKeyFromOffset.

Arguments:

  RootString    - A pointer to a string containing the path to a registry key
  LengthPtr     - A pointer to a variable that receives the length of the
                  registry root, including the joining backslash if it exists.

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if RootString does not
  contain a registry root.

--*/

typedef struct {
    PCSTR   RootText;
    PCWSTR  WideRootText;
    UINT    TextLength;
    HKEY    RootKey;
} REGISTRYROOT, *PREGISTRYROOT;

static
REGISTRYROOT g_RegRoots[] = {
    "HKR",                     L"HKR",                     3, HKEY_ROOT,
    "HKEY_ROOT",               L"HKEY_ROOT",               9, HKEY_ROOT,
    "HKLM",                    L"HKLM",                    4, HKEY_LOCAL_MACHINE,
    "HKEY_LOCAL_MACHINE",      L"HKEY_LOCAL_MACHINE",     18, HKEY_LOCAL_MACHINE,
    "HKU",                     L"HKU",                     3, HKEY_USERS,
    "HKEY_USERS",              L"HKEY_USERS",             10, HKEY_USERS,
    "HKCU",                    L"HKCU",                    4, HKEY_CURRENT_USER,
    "HKEY_CURRENT_USER",       L"HKEY_CURRENT_USER",      17, HKEY_CURRENT_USER,
    "HKCC",                    L"HKCC",                    4, HKEY_CURRENT_CONFIG,
    "HKEY_CURRENT_CONFIG",     L"HKEY_CURRENT_CONFIG",    19, HKEY_CURRENT_CONFIG,
    "HKCR",                    L"HKCR",                    4, HKEY_CLASSES_ROOT,
    "HKEY_CLASSES_ROOT",       L"HKEY_CLASSES_ROOT",      17, HKEY_CLASSES_ROOT,
    "HKDD",                    L"HKDD",                    4, HKEY_DYN_DATA,
    "HKEY_DYN_DATA",           L"HKEY_DYN_DATA",          13, HKEY_DYN_DATA,
    NULL,                      NULL,                       0, NULL
};

#define REGROOTS    14

INT
GetOffsetOfRootStringA (
    IN      PCSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    MBCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (StringIMatchCharCountA (
                RootString,
                g_RegRoots[i].RootText,
                g_RegRoots[i].TextLength
                )) {

            c = _mbsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != '\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}

INT
GetOffsetOfRootStringW (
    IN      PCWSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    WCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (!_wcsnicmp (RootString, g_RegRoots[i].WideRootText,
                        g_RegRoots[i].TextLength)
            ) {
            c = _wcsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != L'\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetOffsetOfRootKey returns a non-zero offset to the g_RegRoots table
  corresponding to the root that matches the supplied HKEY.  This offset
  can be used with GetRootStringFromOffset and GetRootKeyFromOffset.

Arguments:

  RootKey   - Supplies the handle to locate in g_RegRoots table

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if the handle is not
  a registry root.

--*/

INT
GetOffsetOfRootKey (
    IN      HKEY RootKey
    )
{
    INT i;

    if (RootKey == g_Root) {
        return 1;
    }

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (g_RegRoots[i].RootKey == RootKey) {
            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetRootStringFromOffset and GetRootKeyFromOffset return a pointer to a
  static string or HKEY, respectively.  If the offset supplied is invalid,
  these functions return NULL.

Arguments:

  i - The offset as returned by GetOffsetOfRootString or GetOffsetOfRootKey

Return Value:

  A pointer to a static string/HKEY, or NULL if offset is invalid

--*/

PCSTR
GetRootStringFromOffsetA (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].RootText;
}

PCWSTR
GetRootStringFromOffsetW (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].WideRootText;
}

HKEY
GetRootKeyFromOffset (
    IN      INT i
    )
{
    HKEY Ret;

    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    Ret = g_RegRoots[i - 1].RootKey;
    if (Ret == HKEY_ROOT) {
        Ret = g_Root;
    }

    return Ret;
}


/*++

Routine Description:

  ConvertRootStringToKey converts a registry key path's root to an HKEY.

Arguments:

  RegPath   - A pointer to a registry string that has a root at the begining
  LengthPtr - An optional pointer to a variable that receives the length of
              the root, including the joining backslash if it exists.

Return Value:

  A handle to the registry key, or NULL if RegPath does not have a root

--*/

HKEY
ConvertRootStringToKeyA (
    PCSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringA (RegPath, LengthPtr));
}

HKEY
ConvertRootStringToKeyW (
    PCWSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringW (RegPath, LengthPtr));
}


/*++

Routine Description:

  ConvertKeyToRootString converts a root HKEY to a registry root string

Arguments:

  RegRoot   - A handle to a registry root

Return Value:

  A pointer to a static string, or NULL if RegRoot is not a valid registry
  root handle

--*/

PCSTR
ConvertKeyToRootStringA (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetA (GetOffsetOfRootKey (RegRoot));
}

PCWSTR
ConvertKeyToRootStringW (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetW (GetOffsetOfRootKey (RegRoot));
}



/*++

Routine Description:

  CreateEncodedRegistryStringEx is used to create a registry string in the format commonly
  expected by w95upg reg routines. This format is:

    EncodedKey\[EncodedValue]

  Encoding is used to safely represent "special" characters
    (such as MBS chars and certain punctuation marks.)

  The [EncodedValue] part will exist only if Value is non null.

Arguments:

    Key - Contains an unencoded registry key.
    Value - Optionally contains an unencoded registry value.
    Tree - Specifies that the registry key refers to the entire key

Return Value:

    Returns a pointer to the encoded registry string, or NULL if there was an error.

--*/

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    )
{
    PSTR    rEncodedString = NULL;
    DWORD   requiredSize;
    PSTR    end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = SizeOfStringA(Key)*6 + (Value ? SizeOfStringA(Value)*6 : 0) + 10;
    rEncodedString  = AllocPathStringA(requiredSize);
    if (!rEncodedString)
        return NULL;

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsA(rEncodedString, Key);

    //
    // Finally, if a value exists, append it in encoded form. If a value does not exist,
    // then add an '*' to the line.
    //
    if (Value) {

        StringCopyA (AppendWackA (rEncodedString), "[");
        end = GetEndOfStringA (rEncodedString);
        EncodeRuleCharsA(end, Value);
        StringCatA(end, "]");

    } else if (Tree) {
        StringCopyA (AppendWackA (rEncodedString), "*");
    }

    return rEncodedString;
}


PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    )
{
    PWSTR   rEncodedString = NULL;
    DWORD   requiredSize;
    PWSTR   end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = SizeOfStringW(Key)*6 + (Value ? SizeOfStringW(Value)*6 : 0) + 10;
    rEncodedString  = AllocPathStringW(requiredSize);
    if (!rEncodedString)
        return NULL;

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsW(rEncodedString, Key);

    //
    // Finally, if a value exists, append it in encoded form.
    // If a value doesn't exist, add na '*' to the line.
    //
    if (Value) {

        StringCopyW (AppendWackW (rEncodedString), L"[");
        end = GetEndOfStringW (rEncodedString);
        EncodeRuleCharsW(end, Value);
        StringCatW(end, L"]");
    } else if (Tree) {
        StringCopyW (AppendWackW (rEncodedString), L"*");
    }

    return rEncodedString;
}


/*++

Routine Description:

    FreeEncodedRegistryString frees the memory allocated by a call to CreateEncodedRegistryString.

Arguments:

    None.


Return Value:

    None.

--*/
VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    )
{
    FreePathStringA(RegString);
}


VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    )
{
    FreePathStringW(RegString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\diskstat\diskstat.c ===
#include <mytypes.h>
#include <partio.h>
#include <diskio.h>
#include <misclib.h>
#include <partimag.h>
#include <msgfile.h>

#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <dos.h>
#include <stdlib.h>


char *textDiskCount;
char *textDiskN;
char *textInt13Unit;
char *textSectorsPerTrack;
char *textHeads;
char *textCylinders;
char *textExtInt13;
char *textNoExtInt13;
char *textPartitionsOnDisk;
char *textSystemId;
char *textStartSector;
char *textSectorCount;
char *textNoPartitionsOnDisk;
char *textCantAllocBuffer;
char *textIsNotMasterDisk;
char *textIsMasterDisk;
char *textCantAccessDisk;
char *textPartImageCount;
char *textImageN;
char *textImageCorrupt;
char *textImageName;
char *textOriginalTotalSectors;
char *textMBParens;
char *textDone;
char *textUsage;
char *textChecksum;
char *textChecksumFail;
char *textBytesProcessed;
char *textValidateFile;
char *textChecksumOk;
char *textRelocBitmap;
char *textRelocBoot;

MESSAGE_STRING TextMessages[] = { { &textDiskCount,            1 },
                                  { &textDiskN,                2 },
                                  { &textInt13Unit,            3 },
                                  { &textSectorsPerTrack,      4 },
                                  { &textHeads,                5 },
                                  { &textCylinders,            6 },
                                  { &textExtInt13,             7 },
                                  { &textNoExtInt13,           8 },
                                  { &textPartitionsOnDisk,     9 },
                                  { &textSystemId,            10 },
                                  { &textStartSector,         11 },
                                  { &textSectorCount,         12 },
                                  { &textNoPartitionsOnDisk,  13 },
                                  { &textCantAllocBuffer,     14 },
                                  { &textIsNotMasterDisk,     15 },
                                  { &textIsMasterDisk,        16 },
                                  { &textCantAccessDisk,      17 },
                                  { &textPartImageCount,      18 },
                                  { &textImageN,              19 },
                                  { &textImageCorrupt,        20 },
                                  { &textImageName,           21 },
                                  { &textOriginalTotalSectors,22 },
                                  { &textMBParens,            24 },
                                  { &textDone,                25 },
                                  { &textUsage,               26 },
                                  { &textChecksum,            27 },
                                  { &textChecksumFail,        28 },
                                  { &textBytesProcessed,      29 },
                                  { &textValidateFile,        30 },
                                  { &textChecksumOk,          31 },
                                  { &textRelocBitmap,         32 },
                                  { &textRelocBoot,           33 }
                                };

UINT PartCount;
BYTE SaveBuffer[512];
CMD_LINE_ARGS CmdLineArgs;


VOID
DumpDisk(
    IN UINT DiskId
    );

VOID
DumpPartitionsOnDisk(
    IN UINT DiskId
    );

VOID
DumpMasterDiskInfo(
    IN UINT DiskId
    );

BOOL
TestImage(
    IN  HDISK  DiskHandle,
    IN  ULONG  StartSector
    );

int
main(
    IN int argc,
    IN char *argv[]
    )
{
    UINT DiskCount,i;

    if(!GetTextForProgram(argv[0],TextMessages,sizeof(TextMessages)/sizeof(TextMessages[0]))) {
        fprintf(stderr,"Unable to find messages for program\n");
        return(FAILURE);
    }

    if(!ParseArgs(argc,argv,TRUE,"XT",&CmdLineArgs)) {
        fprintf(stderr,textUsage);
        fprintf(stderr,"\n");
        return(FAILURE);
    }

    PartCount = InitializePartitionList();
    DiskCount = InitializeDiskList();

    printf(textDiskCount,DiskCount);
    printf("\n");

    for(i=0; i<DiskCount; i++) {

        DumpDisk(i);
    }

    return(SUCCESS);
}


VOID
DumpDisk(
    IN UINT DiskId
    )
{
    BYTE Int13Unit;
    BYTE SectorsPerTrack;
    USHORT Heads;
    USHORT Cylinders;
    ULONG ExtendedSectorCount;

    printf("\n");
    printf(textDiskN,DiskId);
    printf("\n\n");

    GetDiskInfoById(
        DiskId,
        0,
        &Int13Unit,
        &SectorsPerTrack,
        &Heads,
        &Cylinders,
        &ExtendedSectorCount
        );

    printf("    %s ",textInt13Unit);
    printf("%x\n",Int13Unit);

    printf("    %s ",textSectorsPerTrack);
    printf("%u\n",SectorsPerTrack);

    printf("    %s ",textHeads);
    printf("%u\n",Heads);

    printf("    %s ",textCylinders);
    printf("%u\n",Cylinders);

    if(ExtendedSectorCount) {
        printf("    %s ",textExtInt13);
        printf("0x%lx\n",ExtendedSectorCount);
    } else {
        printf("    %s\n",textNoExtInt13);
    }

    DumpPartitionsOnDisk(DiskId);
    DumpMasterDiskInfo(DiskId);

    printf("\n%s\n",textDone);
}


VOID
DumpPartitionsOnDisk(
    IN UINT DiskId
    )
{
    UINT i;
    UINT id;
    BYTE SysId;
    ULONG StartSector;
    ULONG SectorCount;
    unsigned count;

    count = 0;
    printf("\n");

    for(i=0; i<PartCount; i++) {

        GetPartitionInfoById(
            i,
            0,
            &id,
            &SysId,
            &StartSector,
            &SectorCount
            );

        if(id == DiskId) {

            if(!count++) {
                printf("    %s\n",textPartitionsOnDisk);
            }

            printf("\n        %s ",textSystemId);
            printf("%u\n",SysId);
            printf("        %s ",textStartSector);
            printf("0x%lx\n",StartSector);
            printf("        %s ",textSectorCount);
            printf("0x%lx ",SectorCount);
            printf(textMBParens,SectorCount/2048);
            printf("\n");
        }
    }

    if(!count) {
        printf("    %s\n",textNoPartitionsOnDisk);
    }
}


VOID
DumpMasterDiskInfo(
    IN UINT DiskId
    )
{
    FPVOID Buffer,OriginalBuffer;
    HDISK hDisk;
    FPMASTER_DISK MasterDisk;
    FPPARTITION_IMAGE Image;
    UINT i;

    printf("\n");

    if(!AllocTrackBuffer(1,&Buffer,&OriginalBuffer)) {
        printf("    %s\n",textCantAllocBuffer);
        return;
    }

    if(IsMasterDisk(DiskId,Buffer)) {
        printf("    %s ",textIsMasterDisk);

        if(hDisk = OpenDisk(DiskId)) {

            if(ReadDisk(hDisk,1,1,Buffer)) {

                memcpy(SaveBuffer,Buffer,512);
                MasterDisk = (FPMASTER_DISK)SaveBuffer;

                printf("\n        (%u %s)\n", MasterDisk->ImageCount, textPartImageCount);

                Image = Buffer;

                for(i=0; i<MasterDisk->ImageCount; i++) {

                    printf("\n    ");
                    printf(textImageN,i+1);
                    printf("\n\n");

                    if(ReadDisk(hDisk,MasterDisk->ImageStartSector[i],1,Buffer)) {

                        if((Image->Signature == PARTITION_IMAGE_SIGNATURE)
                        && (Image->Size == sizeof(PARTITION_IMAGE))) {

                            printf("        %s %u\n",textSystemId,Image->SystemId);

                            printf("        %s 0x%lx ",textOriginalTotalSectors,Image->TotalSectorCount);
                            printf(textMBParens,Image->TotalSectorCount/2048);
                            printf("\n");

                            if( Image->Flags & PARTIMAGE_RELOCATE_BITMAP ) {                            
                                printf("        %s 0x%lx\n",textRelocBitmap,Image->BitmapRelocationStart);
                            }
                            if( Image->Flags & PARTIMAGE_RELOCATE_BOOT ) {                            
                                printf("        %s 0x%lx\n",textRelocBoot,Image->BootRelocationStart);
                            }
                            printf("\n");

                            if(CmdLineArgs.Test) {
                                TestImage(hDisk,MasterDisk->ImageStartSector[i]);
                            }

                        } else {
                            printf("        %s\n",textImageCorrupt);
                        }
                    } else {
                        printf("        %s\n",textCantAccessDisk);
                    }
                }
            } else {
                printf("\n    %s\n",textCantAccessDisk);
            }
        } else {
            printf("\n    %s\n",textCantAccessDisk);
        }
    } else {
        printf("    %s\n",textIsNotMasterDisk);
    }

    free(OriginalBuffer);
}

BOOL
TestImage(
    IN  HDISK  DiskHandle,
    IN  ULONG  StartSector
    )
{
    FPVOID Buffer,OriginalBuffer;
    ULONG CurrentSector;
    ULONG ImageCRC;
    ULONG CalcCRC;
    ULONG BytesCRC;

    ULONG SectorsRemaining;
    ULONG TotalSectors;
    ULONG BitmapSize;
    BYTE  Count;

    // need to allocate aligned buffer
    if(!AllocTrackBuffer(63,&Buffer,&OriginalBuffer)) {
        printf("    %s\n",textCantAllocBuffer);
        return FALSE;
    }

    CalcCRC = CRC32_INITIAL_VALUE;
    BytesCRC = 0;

    // read inital sector to get info
    CurrentSector = StartSector;
    if( ReadDisk( DiskHandle, CurrentSector, 1, Buffer ) ) {
        ImageCRC = ((PPARTITION_IMAGE)Buffer)->CRC;

        // determine the image bitmap size
        BitmapSize = ((PPARTITION_IMAGE)Buffer)->LastUsedCluster;
        BitmapSize = (BitmapSize % (8*512)) ? BitmapSize/(8*512)+1 : BitmapSize/(8*512);
        
        // calculate how many sectors remain in the image
        SectorsRemaining = ((PPARTITION_IMAGE)Buffer)->NonClusterSectors // fs structs
            + ((PPARTITION_IMAGE)Buffer)->SectorsPerCluster
            * ((PPARTITION_IMAGE)Buffer)->UsedClusterCount // data area
            + BitmapSize; // image cluster bitmap

        // zero out these fields in the header so we can recalculate the original CRC
        ((PPARTITION_IMAGE)Buffer)->CRC = 0;
        ((PPARTITION_IMAGE)Buffer)->BitmapRelocationStart = 0;
        ((PPARTITION_IMAGE)Buffer)->BootRelocationStart = 0;
        ((PPARTITION_IMAGE)Buffer)->Flags = 0;

        TotalSectors = SectorsRemaining;
    } else {
        printf("\n    %s\n",textCantAccessDisk);
        return FALSE;
    }

    CurrentSector++;
    
    // update the computed CRC
    CalcCRC = CRC32Compute( Buffer, 512, CalcCRC);
    BytesCRC += 512;

    // loop reading the entire file, updating the CRC
    while (SectorsRemaining) {
        Count = (BYTE) ((SectorsRemaining > 63L) ? 63L : SectorsRemaining);

        if( ReadDisk( DiskHandle, CurrentSector, Count , Buffer ) ) {
            CalcCRC = CRC32Compute( Buffer, Count*512, CalcCRC);            
            BytesCRC += Count*512;
        } else {
            printf("\n    %s\n",textCantAccessDisk);
            return FALSE;
        }        
        SectorsRemaining -= Count;
        CurrentSector += Count;

        // print progress
        printf("\r        %s (%u%%)", textValidateFile,100*(TotalSectors-SectorsRemaining)/TotalSectors);
    }
    // compare with stored CRC
    printf("\r        %s = 0x%08lx\n", textChecksum, CalcCRC );
    printf("\r        %s = 0x%08lx\n", textBytesProcessed,BytesCRC );

    if( CalcCRC != ImageCRC ) {
        printf("\n%s 0x%08lx\n",textChecksumFail,ImageCRC);    
        return FALSE;
    } else {
        printf("\r        %s\n", textChecksumOk);
    }
    
    free(OriginalBuffer);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\displib\font.c ===
#include <dos.h>
#include <share.h>
#include <stddef.h>
#include <malloc.h>
#include <string.h>

#include <mytypes.h>
#include <misclib.h>
#include <displib.h>

#include "bootfont.h"

//
// The following structures and constants are used in font files:
// DOS image header
// OS/2 image header
// OS/2 executable resource information structure
// OS/2 executable resource name information structure
//

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    USHORT e_magic;                     // Magic number
    USHORT e_cblp;                      // Bytes on last page of file
    USHORT e_cp;                        // Pages in file
    USHORT e_crlc;                      // Relocations
    USHORT e_cparhdr;                   // Size of header in paragraphs
    USHORT e_minalloc;                  // Minimum extra paragraphs needed
    USHORT e_maxalloc;                  // Maximum extra paragraphs needed
    USHORT e_ss;                        // Initial (relative) SS value
    USHORT e_sp;                        // Initial SP value
    USHORT e_csum;                      // Checksum
    USHORT e_ip;                        // Initial IP value
    USHORT e_cs;                        // Initial (relative) CS value
    USHORT e_lfarlc;                    // File address of relocation table
    USHORT e_ovno;                      // Overlay number
    USHORT e_res[4];                    // Reserved words
    USHORT e_oemid;                     // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;                   // OEM information; e_oemid specific
    USHORT e_res2[10];                  // Reserved words
    ULONG  e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER;

#define IMAGE_DOS_SIGNATURE 0x5A4D      // MZ

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    USHORT ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    USHORT ne_enttab;                   // Offset of Entry Table
    USHORT ne_cbenttab;                 // Number of bytes in Entry Table
    long   ne_crc;                      // Checksum of whole file
    USHORT ne_flags;                    // Flag word
    USHORT ne_autodata;                 // Automatic data segment number
    USHORT ne_heap;                     // Initial heap allocation
    USHORT ne_stack;                    // Initial stack allocation
    long   ne_csip;                     // Initial CS:IP setting
    long   ne_sssp;                     // Initial SS:SP setting
    USHORT ne_cseg;                     // Count of file segments
    USHORT ne_cmod;                     // Entries in Module Reference Table
    USHORT ne_cbnrestab;                // Size of non-resident name table
    USHORT ne_segtab;                   // Offset of Segment Table
    USHORT ne_rsrctab;                  // Offset of Resource Table
    USHORT ne_restab;                   // Offset of resident name table
    USHORT ne_modtab;                   // Offset of Module Reference Table
    USHORT ne_imptab;                   // Offset of Imported Names Table
    long   ne_nrestab;                  // Offset of Non-resident Names Table
    USHORT ne_cmovent;                  // Count of movable entries
    USHORT ne_align;                    // Segment alignment shift count
    USHORT ne_cres;                     // Count of resource segments
    UCHAR  ne_exetyp;                   // Target Operating system
    UCHAR  ne_flagsothers;              // Other .EXE flags
    USHORT ne_pretthunks;               // offset to return thunks
    USHORT ne_psegrefbytes;             // offset to segment ref. bytes
    USHORT ne_swaparea;                 // Minimum code swap area size
    USHORT ne_expver;                   // Expected Windows version number
} IMAGE_OS2_HEADER;

#define IMAGE_OS2_SIGNATURE 0x454E      // NE


typedef struct _RESOURCE_TYPE_INFORMATION {
    USHORT Ident;
    USHORT Number;
    long   Proc;
} RESOURCE_TYPE_INFORMATION;

#define FONT_DIRECTORY 0x8007
#define FONT_RESOURCE 0x8008

typedef struct _RESOURCE_NAME_INFORMATION {
    USHORT Offset;
    USHORT Length;
    USHORT Flags;
    USHORT Ident;
    USHORT Handle;
    USHORT Usage;
} RESOURCE_NAME_INFORMATION;

#pragma pack(1)
typedef struct _OEM_FONT_FILE_HEADER {
    USHORT Version;
    ULONG FileSize;
    UCHAR Copyright[60];
    USHORT Type;
    USHORT Points;
    USHORT VerticalResolution;
    USHORT HorizontalResolution;
    USHORT Ascent;
    USHORT InternalLeading;
    USHORT ExternalLeading;
    UCHAR Italic;
    UCHAR Underline;
    UCHAR StrikeOut;
    USHORT Weight;
    UCHAR CharacterSet;
    USHORT PixelWidth;
    USHORT PixelHeight;
    UCHAR Family;
    USHORT AverageWidth;
    USHORT MaximumWidth;
    UCHAR FirstCharacter;
    UCHAR LastCharacter;
    UCHAR DefaultCharacter;
    UCHAR BreakCharacter;
    USHORT WidthInBytes;
    ULONG Device;
    ULONG Face;
    ULONG BitsPointer;
    ULONG BitsOffset;
    UCHAR Filler;
} OEM_FONT_FILE_HEADER;
#pragma pack()

#define OEM_FONT_VERSION 0x200
#define OEM_FONT_TYPE 0
#define OEM_FONT_CHARACTER_SET 255
#define OEM_FONT_FAMILY (3 << 4)
#define FONT_WIDTH 8

typedef struct _FONT_CHAR {
    USHORT Width;
    USHORT Offset;
} FONT_CHAR;


union {
    IMAGE_DOS_HEADER DosHeader;
    IMAGE_OS2_HEADER Os2Header;
    OEM_FONT_FILE_HEADER FontHeader;
    RESOURCE_TYPE_INFORMATION ResourceType;
    RESOURCE_NAME_INFORMATION ResourceName;
    BOOTFONTBIN_HEADER BfbHeader;
} FontHeaders;

FONT_CHAR *FontCharMap;
BYTE *FontCharData;
unsigned FontDataBaseOffset;
BYTE GlyphHeight;

BYTE FontFirstChar,FontLastChar,FontDefaultChar;

BYTE TopPad,BottomPad;

unsigned BootfontFileHandle = (unsigned)(-1);
UCHAR PendingLeadByte;
unsigned SbcsCharCount;
unsigned DbcsCharCount;
ULONG SbcsFileOffset;
ULONG DbcsFileOffset;

#define DBCS_FIRST_LEAD     0x81
#define DBCS_LAST_LEAD      0xfe
#define DBCS_FIRST_TRAIL    0x40
#define DBCS_LAST_TRAIL     0xfe

//
// HACK: the only place this lib is used is with enduser,
// which already has the table of bit values we want.
// Save the 8 bytes and use them.
//
extern BYTE BitValue[8];
BYTE LeadByteTable[128/8];     // 128 bits
unsigned *DbcsCharOrdinalOffsetTable;
unsigned *SbcsCharOrdinalOffsetTable;
unsigned *FontCacheTable;
BYTE *FontCache;
unsigned NextCacheSlot;

#define FONT_CACHE_CAPACITY 750


BOOL
LoadBootfontBin(
    IN unsigned FileHandle,
    IN ULONG    FileSize
    );

VOID
UnloadBootfontBin(
    VOID
    );

VOID
FontWriteBfbChar(
    IN UCHAR  c,
    IN USHORT x,
    IN USHORT y,
    IN BYTE   ForegroundPixelValue,
    IN BYTE   BackgroundPixelValue
    );


BOOL
_far
FontLoadAndInit(
    IN FPCHAR Filename
    )
{
    BOOL b;
    ULONG FileSize;
    unsigned FileHandle;
    unsigned Count;
    int ScaleFactor;
    unsigned Offset,TableEndOffset;
    FONT_CHAR *map;
    unsigned hi,lo;
    FPVOID data;


    b = FALSE;

    //
    // Open the file and determine its size.
    //
    if(_dos_open(Filename,SH_DENYWR,&FileHandle)) {
        goto c0;
    }

    if(((FileSize = DosSeek(FileHandle,0,DOSSEEK_END)) == -1)
    || DosSeek(FileHandle,0,DOSSEEK_START)) {

        goto c1;
    }

    //
    // Read the DOS header.
    //
    if(_dos_read(FileHandle,&FontHeaders.DosHeader,sizeof(IMAGE_DOS_HEADER),&Count)
    || (Count != sizeof(IMAGE_DOS_HEADER))) {

        goto c1;
    }

    //
    // Special check for bootfont.bin-style font.
    //
    if(((BOOTFONTBIN_HEADER *)&FontHeaders.DosHeader)->Signature == BOOTFONTBIN_SIGNATURE) {
        return(LoadBootfontBin(FileHandle,FileSize));
    }

    //
    // Cap file size to something reasonable (and that fits in a
    // 16 bit value).
    //
    if(FileSize > 60000) {
        goto c1;
    }

    //
    // Basic header check.
    //
    if((FontHeaders.DosHeader.e_magic != IMAGE_DOS_SIGNATURE)
    || (FontHeaders.DosHeader.e_lfanew < sizeof(IMAGE_DOS_HEADER))) {

        goto c1;
    }

    //
    // Retrieve some info from the dos header before overwriting it.
    //
    Offset = (unsigned)FontHeaders.DosHeader.e_lfanew;

    //
    // Read the OS/2 header and make sure the resource table exists.
    //
    if((DosSeek(FileHandle,FontHeaders.DosHeader.e_lfanew,DOSSEEK_START) != FontHeaders.DosHeader.e_lfanew)
    || _dos_read(FileHandle,&FontHeaders.Os2Header,sizeof(IMAGE_OS2_HEADER),&Count)
    || (Count != sizeof(IMAGE_OS2_HEADER))
    || (FontHeaders.Os2Header.ne_magic != IMAGE_OS2_SIGNATURE)
    || (FontHeaders.Os2Header.ne_restab > 65535L)
    || (FontHeaders.Os2Header.ne_rsrctab > 65535L)
    || !(FontHeaders.Os2Header.ne_restab - FontHeaders.Os2Header.ne_rsrctab)) {

        goto c1;
    }

    //
    // Search for font resource.
    //
    TableEndOffset = Offset;
    Offset += (unsigned)FontHeaders.Os2Header.ne_rsrctab;
    TableEndOffset += (unsigned)FontHeaders.Os2Header.ne_restab;

    if((DosSeek(FileHandle,Offset,DOSSEEK_START) != Offset)
    || _dos_read(FileHandle,&ScaleFactor,2,&Count)
    || (Count != 2)) {

        goto c1;
    }

    Offset += 2;   // skip scale factor

    FontHeaders.ResourceType.Ident = 0;

    while(Offset < TableEndOffset) {

        if((DosSeek(FileHandle,Offset,DOSSEEK_START) != Offset)
        || _dos_read(FileHandle,&FontHeaders.ResourceType,sizeof(RESOURCE_TYPE_INFORMATION),&Count)
        || (Count != sizeof(RESOURCE_TYPE_INFORMATION))) {
            goto c1;
        }

        if(FontHeaders.ResourceType.Ident == FONT_RESOURCE) {
            break;
        }

        Offset += sizeof(RESOURCE_TYPE_INFORMATION)
                        + (FontHeaders.ResourceType.Number * sizeof(RESOURCE_NAME_INFORMATION));

    }

    if(FontHeaders.ResourceType.Ident != FONT_RESOURCE) {
        goto c1;
    }

    //
    // Get to resource name information.
    //
    Offset += sizeof(RESOURCE_TYPE_INFORMATION);
    if((DosSeek(FileHandle,Offset,DOSSEEK_START) != Offset)
    || _dos_read(FileHandle,&FontHeaders.ResourceName,sizeof(RESOURCE_NAME_INFORMATION),&Count)
    || (Count != sizeof(RESOURCE_NAME_INFORMATION))) {

        goto c1;
    }

    //
    // Read the oem font file header and validate it. We don't read the
    // table map in this part, we read that later.
    //
    Offset = FontHeaders.ResourceName.Offset << ScaleFactor;

    if((DosSeek(FileHandle,Offset,DOSSEEK_START) != Offset)
    || _dos_read(FileHandle,&FontHeaders,sizeof(OEM_FONT_FILE_HEADER),&Count)
    || (Count != sizeof(OEM_FONT_FILE_HEADER))
    || (FontHeaders.FontHeader.Version != OEM_FONT_VERSION)
    || (FontHeaders.FontHeader.Type != OEM_FONT_TYPE)
    || FontHeaders.FontHeader.Italic
    || FontHeaders.FontHeader.Underline
    || FontHeaders.FontHeader.StrikeOut
    || (FontHeaders.FontHeader.CharacterSet != OEM_FONT_CHARACTER_SET)
    || (FontHeaders.FontHeader.Family != OEM_FONT_FAMILY)
    || (FontHeaders.FontHeader.PixelWidth != FONT_WIDTH)
    || (FontHeaders.FontHeader.PixelHeight > 16 )) {

        goto c1;
    }

    //
    // Allocate memory for the mapping table and read it in.
    //
    FileSize = (FontHeaders.FontHeader.LastCharacter - FontHeaders.FontHeader.FirstCharacter) + 1;
    map = malloc((unsigned)FileSize * sizeof(FONT_CHAR));
    if(!map) {
        goto c1;
    }

    if(_dos_read(FileHandle,map,(unsigned)FileSize*sizeof(FONT_CHAR),&Count)
    || (Count != ((unsigned)FileSize*sizeof(FONT_CHAR)))) {
        goto c2;
    }

    //
    // Find the lowest and highest offsets to determine where the file data is.
    //
    hi = 0;
    lo = (unsigned)(-1);

    for(Count=0; Count<(unsigned)FileSize; Count++) {

        if(map[Count].Offset < lo) {
            lo = map[Count].Offset;
        }

        if(map[Count].Offset > hi) {
            hi = map[Count].Offset;
        }
    }

    FileSize = (unsigned)((hi - lo) + FontHeaders.FontHeader.PixelHeight);

    data = malloc((unsigned)FileSize);
    if(!data) {
        goto c2;
    }

    Offset += lo;

    if((DosSeek(FileHandle,Offset,DOSSEEK_START) != Offset)
    || _dos_read(FileHandle,data,(unsigned)FileSize,&Count)
    || (Count != (unsigned)FileSize)) {

        goto c3;
    }

    if(FontCharMap) {
        free(FontCharMap);
    }
    FontCharMap = map;

    if(FontCharData) {
        free(FontCharData);
    }
    FontCharData = data;

    FontDataBaseOffset = lo;

    GlyphHeight = (BYTE)FontHeaders.FontHeader.PixelHeight;
    FontFirstChar = FontHeaders.FontHeader.FirstCharacter;
    FontLastChar = FontHeaders.FontHeader.LastCharacter;
    FontDefaultChar = FontHeaders.FontHeader.DefaultCharacter;

    TopPad = 1;
    BottomPad = 1;

    if(BootfontFileHandle != (unsigned)(-1)) {
        UnloadBootfontBin();
    }

    b = TRUE;

c3:
    if(!b) {
        free(data);
    }
c2:
    if(!b) {
        free(map);
    }
c1:
    _dos_close(FileHandle);
c0:
    return(b);
}


BOOL
LoadBootfontBin(
    IN unsigned FileHandle,
    IN ULONG    FileSize
    )

/*++

Routine Description:

    This routine loads and initializes a font file in NT setup's
    bootfont.bin format.

Arguments:

    FileHandle - supplies DOS file handle of file.

    FileSize - supplies size of file in bytes.

Return Value:

    Boolean value indicating outcome. If TRUE, the file handle
    will be left open. If FALSE the file handle will have been closed.

--*/

{
    BOOL b;
    unsigned Count;
    unsigned i;
    unsigned MaxChars,CharsLeft;
    unsigned BytesPerChar;
    unsigned index;
    unsigned ordinal;
    unsigned nextslot;
    FPBYTE p;
    FPBYTE ScratchBuffer;
    unsigned *Table1,*Table2,*Table3;
    BYTE *cache;
    unsigned CacheOrd;

    b = FALSE;

    //
    // Rewind the file and read the header.
    //
    if(DosSeek(FileHandle,0,DOSSEEK_START)
    || _dos_read(FileHandle,&FontHeaders.BfbHeader,sizeof(BOOTFONTBIN_HEADER),&Count)
    || (Count != sizeof(BOOTFONTBIN_HEADER))) {

        goto c1;
    }

    //
    // Basic checks.
    //
    if((FontHeaders.BfbHeader.CharacterImageSbcsWidth != FONT_WIDTH)
    || (FontHeaders.BfbHeader.CharacterImageDbcsWidth != (2*FONT_WIDTH))) {

        goto c1;
    }

    //
    // Make sure the DBCS table looks good. No ranges can be in ASCII range,
    // the ranges must be legal (ie, end greater than start), and the table
    // must be terminated with a pair of 0s.
    //
    for(Count=0;
        FontHeaders.BfbHeader.DbcsLeadTable[Count]
     && FontHeaders.BfbHeader.DbcsLeadTable[Count+1]
     && (Count < (2*MAX_DBCS_RANGE));
        Count+=2) {

        if((FontHeaders.BfbHeader.DbcsLeadTable[Count] < DBCS_FIRST_LEAD)
        || (FontHeaders.BfbHeader.DbcsLeadTable[Count+1] < DBCS_FIRST_LEAD)
        || (FontHeaders.BfbHeader.DbcsLeadTable[Count] > DBCS_LAST_LEAD)
        || (FontHeaders.BfbHeader.DbcsLeadTable[Count+1] > DBCS_LAST_LEAD)
        || (FontHeaders.BfbHeader.DbcsLeadTable[Count] > FontHeaders.BfbHeader.DbcsLeadTable[Count+1])) {

            goto c1;
        }
    }

    if(FontHeaders.BfbHeader.DbcsLeadTable[Count]
    || FontHeaders.BfbHeader.DbcsLeadTable[Count+1]) {

        goto c1;
    }

    //
    // Now we build a table of characters and offset numbers
    // into the file, indexed by character value. The theoretical
    // maximum number of DBCS chars is when all of 81-fe are leads and
    // each of 40-fe are trails for each lead byte; 7e * bf = 5e02 (24066)
    // separate DBCS characters. (Actually 7f is not a valid trail byte but
    // that only shaves 126 chars off the total, which not worth the headache.)
    // Each character requires 2 bytes for an ordinal number in the font file,
    // which gives a theoretical maximum table size of bc04 bytes. Mercifully
    // this is much less than the malloc max of ffe8 bytes.
    //
    // We do something similar for the SBCS case also.
    //
    #define TABLE1_SIZE (2*(((DBCS_LAST_LEAD-DBCS_FIRST_LEAD)+1) * ((DBCS_LAST_TRAIL-DBCS_FIRST_TRAIL)+1)))
    #define TABLE2_SIZE (2*255)
    #define TABLE3_SIZE (2*(FontHeaders.BfbHeader.NumSbcsChars + FontHeaders.BfbHeader.NumDbcsChars))

    Table1 = malloc(TABLE1_SIZE);
    if(!Table1) {
        goto c1;
    }
    Table2 = malloc(TABLE2_SIZE);
    if(!Table2) {
        goto c2;
    }
    Table3 = malloc(TABLE3_SIZE);
    if(!Table3) {
        goto c3;
    }
    //
    // Each slot in the font cache is a 2 byte header indicating the ordinal
    // value of the character cached in the slot, and then the bits that
    // make up the glyph. Entries are sized for double-byte chars even though
    // this wastes space for the single-byte case.
    //
    cache = malloc(FONT_CACHE_CAPACITY * (FontHeaders.BfbHeader.CharacterImageHeight+2) * 2);
    if(!cache) {
        goto c4;
    }

    memset(Table1,0,TABLE1_SIZE);
    memset(Table2,0,TABLE2_SIZE);
    memset(Table3,0xff,TABLE3_SIZE);

    if(DosSeek(FileHandle,FontHeaders.BfbHeader.DbcsOffset,DOSSEEK_START) != FontHeaders.BfbHeader.DbcsOffset) {
        goto c5;
    }

    #define SCRATCH_SIZE 18000              // exactly 1000 chars in typical case
    ScratchBuffer = malloc(SCRATCH_SIZE);
    if(!ScratchBuffer) {
        goto c5;
    }

    //
    // Build an offset table for sbcs chars.
    // There are a max of 255 SBCS chars (1-255).
    //
    BytesPerChar = (FontHeaders.BfbHeader.CharacterImageHeight)+1;
    if(DosSeek(FileHandle,FontHeaders.BfbHeader.SbcsOffset,DOSSEEK_START) != FontHeaders.BfbHeader.SbcsOffset) {
        free(ScratchBuffer);
        goto c5;
    }

    MaxChars = SCRATCH_SIZE / BytesPerChar;
    CharsLeft = FontHeaders.BfbHeader.NumSbcsChars;
    ordinal = 0;
    CacheOrd = 0;

    while(CharsLeft) {

        Count = CharsLeft;
        if(Count > MaxChars) {
            Count = MaxChars;
        }

        if(_dos_read(FileHandle,ScratchBuffer,Count*BytesPerChar,&i)
        || (i != (Count*BytesPerChar))) {
            free(ScratchBuffer);
            goto c5;
        }

        CharsLeft -= Count;

        for(p=ScratchBuffer,i=0; i<Count; i++,p+=BytesPerChar,ordinal++) {

            if(!p[0]) {
                //
                // Invalid value, skip this character
                //
                continue;
            }

            index = (unsigned)p[0] - 1;

            Table2[index] = ordinal;

            //
            // Cache most chars in the ascii range.
            //
            if((p[0] >= ' ') && (p[0] <= 'z')) {
                *(unsigned *)&cache[2*BytesPerChar*CacheOrd] = ordinal;
                memmove(cache+(2*BytesPerChar*CacheOrd)+2,&p[1],BytesPerChar-1);
                Table3[ordinal] = CacheOrd++;
            }
        }
    }

    nextslot = CacheOrd;

    BytesPerChar = (FontHeaders.BfbHeader.CharacterImageHeight*2)+2;
    MaxChars = SCRATCH_SIZE / BytesPerChar;
    CharsLeft = FontHeaders.BfbHeader.NumDbcsChars;
    ordinal = 0;

    while(CharsLeft) {

        Count = CharsLeft;
        if(Count > MaxChars) {
            Count = MaxChars;
        }

        if(_dos_read(FileHandle,ScratchBuffer,Count*BytesPerChar,&i)
        || (i != (Count*BytesPerChar))) {
            free(ScratchBuffer);
            goto c5;
        }

        CharsLeft -= Count;

        for(p=ScratchBuffer,i=0; i<Count; i++,p+=BytesPerChar,ordinal++) {

            if((p[0] < DBCS_FIRST_LEAD) || (p[0] > DBCS_LAST_LEAD)
            || (p[1] < DBCS_FIRST_TRAIL) || (p[1] > DBCS_LAST_TRAIL)) {
                //
                // Invalid DBCS value, skip this character
                //
                continue;
            }

            index = (unsigned)(p[0] - DBCS_FIRST_LEAD);
            index <<= 8;

            index |= p[1] - DBCS_FIRST_TRAIL;

            index -= (unsigned)(p[0] - DBCS_FIRST_LEAD) * (DBCS_FIRST_TRAIL + (255-DBCS_LAST_TRAIL));

            Table1[index] = ordinal;

            //
            // Cache first n chars that fit in the cache
            //
            if(CacheOrd < FONT_CACHE_CAPACITY) {
                *(unsigned *)&cache[CacheOrd*BytesPerChar] = ordinal+FontHeaders.BfbHeader.NumSbcsChars;
                memmove(cache+(CacheOrd*BytesPerChar)+2,&p[2],BytesPerChar-2);
                Table3[ordinal+FontHeaders.BfbHeader.NumSbcsChars] = CacheOrd++;
            }
        }
    }

    free(ScratchBuffer);

    //
    // Everything looks good. Set up globals.
    //
    memset(LeadByteTable,0,sizeof(LeadByteTable));

    for(Count=0;
            FontHeaders.BfbHeader.DbcsLeadTable[Count]
         && FontHeaders.BfbHeader.DbcsLeadTable[Count+1];
        Count+=2) {

        for(i = FontHeaders.BfbHeader.DbcsLeadTable[Count];
           i <= FontHeaders.BfbHeader.DbcsLeadTable[Count+1];
           i++) {

            LeadByteTable[(i-128)/8] |= BitValue[(i-128)%8];
        }
    }

    SbcsCharCount = FontHeaders.BfbHeader.NumSbcsChars;
    DbcsCharCount = FontHeaders.BfbHeader.NumDbcsChars;

    GlyphHeight = FontHeaders.BfbHeader.CharacterImageHeight;
    TopPad = FontHeaders.BfbHeader.CharacterTopPad;
    BottomPad = FontHeaders.BfbHeader.CharacterBottomPad;

    SbcsFileOffset = FontHeaders.BfbHeader.SbcsOffset;
    DbcsFileOffset = FontHeaders.BfbHeader.DbcsOffset;

    if(BootfontFileHandle != (unsigned)(-1)) {
        UnloadBootfontBin();
    }

    DbcsCharOrdinalOffsetTable = Table1;
    SbcsCharOrdinalOffsetTable = Table2;
    FontCacheTable = Table3;
    FontCache = cache;
    NextCacheSlot = nextslot;

    BootfontFileHandle = FileHandle;

    if(FontCharMap) {
        free(FontCharMap);
        FontCharMap = NULL;
    }

    if(FontCharData) {
        free(FontCharData);
        FontCharData = NULL;
    }

    b = TRUE;

c5:
    if(!b) {
        free(cache);
    }
c4:
    if(!b) {
        free(Table3);
    }
c3:
    if(!b) {
        free(Table2);
    }
c2:
    if(!b) {
        free(Table1);
    }
c1:
    if(!b) {
        _dos_close(FileHandle);
    }
    return(b);
}


VOID
UnloadBootfontBin(
    VOID
    )
{
    _dos_close(BootfontFileHandle);
    BootfontFileHandle = (unsigned)(-1);
    PendingLeadByte = 0;
    free(DbcsCharOrdinalOffsetTable);
    free(SbcsCharOrdinalOffsetTable);
    free(FontCacheTable);
    free(FontCache);
    DbcsCharOrdinalOffsetTable = NULL;
    SbcsCharOrdinalOffsetTable = NULL;
    FontCacheTable = NULL;
    FontCache = NULL;
}


VOID
_far
FontGetInfo(
    OUT FPBYTE Width,
    OUT FPBYTE Height
    )
{
    *Width = FONT_WIDTH;
    *Height = GlyphHeight + TopPad + BottomPad;
}


VOID
_far
FontWriteChar(
    IN UCHAR  c,
    IN USHORT x,
    IN USHORT y,
    IN BYTE   ForegroundPixelValue,
    IN BYTE   BackgroundPixelValue
    )
{
    BYTE PixelMap[2];

    if(BootfontFileHandle != (unsigned)(-1)) {
        //
        // Use bootfont.bin method
        //
        FontWriteBfbChar(c,x,y,ForegroundPixelValue,BackgroundPixelValue);
        return;
    }

    PixelMap[0] = BackgroundPixelValue;
    PixelMap[1] = ForegroundPixelValue;

    if((c < FontFirstChar) || (c > FontLastChar)) {
        c = FontDefaultChar;
    }

    //
    // Pad if necessary by filling in background
    //
    if(BackgroundPixelValue < VGAPIX_TRANSPARENT) {
        if(TopPad) {
            VgaClearRegion(x,y,FONT_WIDTH,TopPad,BackgroundPixelValue);
        }
        if(BottomPad) {
            VgaClearRegion(x,y+TopPad+GlyphHeight,FONT_WIDTH,BottomPad,BackgroundPixelValue);
        }
    }

    VgaBitBlt(
        x,
        y + TopPad,
        FONT_WIDTH,
        GlyphHeight,
        1,
        FALSE,
        PixelMap,
        FontCharData + (FontCharMap[c-FontFirstChar].Offset - FontDataBaseOffset)
        );
}


VOID
_far
FontWriteString(
    IN UCHAR  *String,
    IN USHORT  x,
    IN USHORT  y,
    IN BYTE    ForegroundPixelValue,
    IN BYTE    BackgroundPixelValue
    )
{
    for( ; *String; String++) {
        FontWriteChar(*String,x,y,ForegroundPixelValue,BackgroundPixelValue);
        x += FONT_WIDTH;
    }

    PendingLeadByte = 0;
}


VOID
FontWriteBfbChar(
    IN UCHAR  c,
    IN USHORT x,
    IN USHORT y,
    IN BYTE   ForegroundPixelValue,
    IN BYTE   BackgroundPixelValue
    )
{
    unsigned scale;
    unsigned index;
    unsigned Ordinal;
    unsigned i,read;
    ULONG FileOffset = 0;
    FPBYTE Glyph = NULL;
    BYTE PixelMap[2];
    FPBYTE p;

    if(PendingLeadByte) {
        //
        // Got second half of DBCS character. Render now.
        //
        index = (unsigned)(PendingLeadByte - DBCS_FIRST_LEAD);
        index <<= 8;
        index |= c - DBCS_FIRST_TRAIL;
        index -= (unsigned)(PendingLeadByte - DBCS_FIRST_LEAD) * (DBCS_FIRST_TRAIL + (255-DBCS_LAST_TRAIL));
        PendingLeadByte = 0;

        Ordinal = DbcsCharOrdinalOffsetTable[index];

        //
        // Is this character cached?
        //
        if(FontCacheTable[Ordinal+SbcsCharCount] == (unsigned)(-1)) {
            //
            // No, need to cache it.
            //
            FileOffset = ((ULONG)Ordinal * ((2 * GlyphHeight) + 2)) + DbcsFileOffset + 2;
        } else {
            //
            // Yes, get glyph.
            //
            Glyph = FontCache + (((2 * GlyphHeight) + 2) * FontCacheTable[Ordinal+SbcsCharCount]) + 2;
        }

        Ordinal += SbcsCharCount;
        x -= FONT_WIDTH;
        scale = 2;
    } else {
        //
        // See if DBCS char or a lead byte
        //
        if((c >= DBCS_FIRST_LEAD) && (LeadByteTable[(c-128)/8] & BitValue[(c-128)%8])) {
            PendingLeadByte = c;
            return;
        }

        //
        // SBCS char.
        //
        Ordinal = SbcsCharOrdinalOffsetTable[c-1];

        //
        // Is this character cached?
        //
        if(FontCacheTable[Ordinal] == (unsigned)(-1)) {
            //
            // No, need to cache it.
            //
            FileOffset = ((ULONG)Ordinal * (GlyphHeight + 1)) + SbcsFileOffset + 1;
        } else {
            //
            // Yes, get glyph
            //
            Glyph = FontCache + (((2 * GlyphHeight) + 2) * FontCacheTable[Ordinal]) + 2;
        }

        scale = 1;
    }

    if(FileOffset) {
        //
        // Pull the character in from the file.
        //
        Glyph = NULL;
        if(DosSeek(BootfontFileHandle,FileOffset,DOSSEEK_START) == FileOffset) {

            //
            // Point at the entry in the font cache where we're going
            // to stick the glyph.
            //
            p = FontCache + (NextCacheSlot * ((2 * GlyphHeight) + 2));

            //
            // Invalidate the caching for the character currently
            // cached in the slot we're going to overwrite. If the read
            // fails halfway through, the glyph may be trashed anyway,
            // so we do it before we know if the read succeeds.
            //
            FontCacheTable[*(unsigned *)p] = (unsigned)(-1);

            i = _dos_read(BootfontFileHandle,p+2,scale*GlyphHeight,&read);

            if(!i && (read == (scale * GlyphHeight))) {

                *(unsigned *)p = Ordinal;
                Glyph = p+2;

                FontCacheTable[Ordinal] = NextCacheSlot++;
                if(NextCacheSlot == FONT_CACHE_CAPACITY) {
                    NextCacheSlot = 0;
                }
            }
        }
    }

    if(Glyph) {
        //
        // Pad if necessary by filling in background
        //
        if(BackgroundPixelValue < VGAPIX_TRANSPARENT) {
            if(TopPad) {
                VgaClearRegion(x,y,scale*FONT_WIDTH,TopPad,BackgroundPixelValue);
            }
            if(BottomPad) {
                VgaClearRegion(x,y+TopPad+GlyphHeight,scale*FONT_WIDTH,BottomPad,BackgroundPixelValue);
            }
        }

        PixelMap[0] = BackgroundPixelValue;
        PixelMap[1] = ForegroundPixelValue;

        VgaBitBlt(
            x,
            y + TopPad,
            scale*FONT_WIDTH,
            GlyphHeight,
            scale,
            FALSE,
            PixelMap,
            Glyph
            );

    } else {
        //
        // Put a block up there.
        //
        VgaClearRegion(x,y,scale*FONT_WIDTH,TopPad+BottomPad+GlyphHeight,ForegroundPixelValue);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\displib\bootfont.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    bootfint.h

Abstract:

    Header file describing the bootfont.bin file used to provide
    dbcs support during system or setup bootstrap.

Author:

    tedm 11-July-1995

Revision History:

--*/


//
// Define maximum number of dbcs lead byte ranges we support.
//
#define MAX_DBCS_RANGE  5

//
// Define signature value.
//
#define BOOTFONTBIN_SIGNATURE 0x5465644d

//
// Define structure used as a header for the bootfont.bin file.
//
#pragma pack(1)
typedef struct _BOOTFONTBIN_HEADER {

    //
    // Signature. Must be BOOTFONTBIN_SIGNATURE.
    //
    ULONG Signature;

    //
    // Language id of the language supported by this font.
    // This should match the language id of resources in msgs.xxx.
    //
    ULONG LanguageId;

    //
    // Number of sbcs characters and dbcs characters contained in the file.
    //
    unsigned NumSbcsChars;
    unsigned filler1;
    unsigned NumDbcsChars;
    unsigned filler2;

    //
    // Offsets within the file to the images.
    //
    ULONG    SbcsOffset;
    ULONG    DbcsOffset;

    //
    // Total sizes of the images.
    //
    ULONG    SbcsEntriesTotalSize;
    ULONG    DbcsEntriesTotalSize;

    //
    // Dbcs lead byte table. Must contain a pair of 0's to indicate the end.
    //
    UCHAR DbcsLeadTable[(MAX_DBCS_RANGE+1)*2];

    //
    // Height values for the font.
    // CharacterImageHeight is the height in scan lines/pixels of the
    // font image. Each character is drawn with additional 'padding'
    // lines on the top and bottom, whose sizes are also contained here.
    //
    UCHAR CharacterImageHeight;
    UCHAR CharacterTopPad;
    UCHAR CharacterBottomPad;

    //
    // Width values for the font. These values contain the width in pixels
    // of a single byte character and double byte character.
    //
    // NOTE: CURRENTLY THE SINGLE BYTE WIDTH *MUST* BE 8 AND THE DOUBLE BYTE
    // WIDTH *MUST* BE 16!!!
    //
    UCHAR CharacterImageSbcsWidth;
    UCHAR CharacterImageDbcsWidth;

} BOOTFONTBIN_HEADER, *PBOOTFONTBIN_HEADER;
#pragma pack()

//
// Images themselves follow.
//
// First there are SbcsCharacters entries for single-byte chars.
// The first byte in each entry is the ascii char code. The next n bytes are
// the image. n is dependent on the width and height of an sbcs char.
//
// Following these are the dbcs images. The first 2 bytes are the dbcs
// character code (highbyte lowbyte) and the next n bytes are the image.
// n is dependent on the width and height of a dbcs char.
//
// Important note: the characters must be sorted in ascending order!
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\migdlls\src\utils\sandbox\sandbox.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sandbox.c

Abstract:

    Utilities to run code in isolated processes (sandbox apis).

Author:

    Jim Schmidt (jimschm)   31-Jan-2000

Revision History:



--*/

//
// Includes
//

#include "pch.h"
#include "utilsp.h"

#define DBG_SANDBOX     "Sandbox"

//
// Strings
//

// None

//
// Constants
//

#define S_SBCLASS       TEXT("SandboxHost")

//
// Macros
//

// None

//
// Types
//

typedef struct {
    BOOL Win32;
    HANDLE Mapping;
    HANDLE Ack;
    UINT Instance;
    TCHAR WindowTitle[64];

} IPCDATA, *PIPCDATA;

typedef struct {
    DWORD   Command;
    DWORD   Result;
    DWORD   TechnicalLogId;
    DWORD   GuiLogId;
    DWORD   DataSize;
    BYTE    Data[];
} MAPDATA, *PMAPDATA;

//
// Globals
//

static PCTSTR g_Mode;
static BOOL g_Sandbox;
static TCHAR g_ExePath16[MAX_TCHAR_PATH] = TEXT("sandbx16.exe");
static TCHAR g_ExePath32[MAX_TCHAR_PATH] = TEXT("sandbx32.exe");

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

LRESULT
CALLBACK
pIpcMessageProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
pCreateExchangeThread (
    IN      UINT Instance
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
SbInitialize (
    IN      BOOL SandboxProcess
    )
{
    WNDCLASS wc;

    //
    // Set the globals
    //

    g_Sandbox = SandboxProcess;
    g_Mode = SandboxProcess ? TEXT("Sandbox") : TEXT("HostProc");
    g_ProcessHandle = NULL;

    //
    // Register the window class for message passing
    //

    ZeroMemory (&wc, sizeof (wc));

    wc.lpfnWndProc = pIpcMessageProc;
    wc.hInstance = g_hInst;
    wc.lpszClassName = S_SBCLASS;

    RegisterClass (&wc);

    return TRUE;
}


VOID
pCloseIpcData (
    IN OUT  PIPCDATA IpcData
    )
{
    if (IpcData->Ack) {
        CloseHandle (IpcData->Ack);
    }

    if (IpcData->Mapping) {
        CloseHandle (IpcData->Mapping);
    }

    if (IpcData->ProcessHandle) {
        CloseHandle (IpcData->ProcessHandle);
    }

    if (IpcData->File && IpcData->File != INVALID_HANDLE_VALUE) {
        CloseHandle (IpcData->File);
    }

    if (IpcData->HostProcHwnd) {
        DestroyWindow (ipcData->HostProcHwnd);
    }

    ZeroMemory (IpcData, sizeof (IPCDATA));
}


DWORD
WINAPI
pAckThread (
    PVOID Arg
    )
{
    PIPCDATA ipcData = (PIPCDATA) Arg;
    MSG msg;
    HWND hwnd;

    //
    // Create a message-only hwnd
    //

    hwnd = CreateWindow (
                S_SBCLASS,
                ipcData->WindowTitle,
                WS_POPUP,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                g_hInst,
                ipcData->Instance
                );

    if (!hwnd) {
        LOG ((LOG_ERROR, "Failed to create host message window"));
        return 0;
    }

    //
    // Loop until the window is destroyed
    //

    while (GetMessage (&msg, hwnd, 0, 0)) {

        DispatchMessage (&msg);

        if (msg.message == WM_NCDESTROY) {
            break;
        }
    }

    return 1;
}


SBHANDLE
SbCreateSandboxA (
    IN      PCSTR DllPath,
    IN      PCSTR WorkingDir            OPTIONAL
    )
{
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_ATTRIBUTES sa, *psa;
    BOOL result = FALSE;
    PIPCDATA ipcData = NULL;
    static UINT instance = 0;
    TCHAR objectName[64];
    TCHAR cmdLine[MAX_TCHAR_PATH * 2];
    BOOL win32;
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    BOOL processResult;
    HANDLE objectArray[2];
    UINT u;
    DWORD rc;
    TCHAR tempPath[MAX_TCHAR_PATH];
    TCHAR tempFile[MAX_TCHAR_PATH];

    __try {
        //
        // BUGBUG - need mutex to guard instance variable
        // BUGBUG - need to test instance variable against window title
        // BUGBUG - need to detect dll type
        //

        win32 = TRUE;

        //
        // Allocate an IPCDATA struct, then fill it in
        //

        ipcData = (PIPCDATA) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (IPCDATA));

        ipcData.Win32 = win32;
        ipcData.Instance = instance;

        if (ISNT()) {
            //
            // Create nul DACL for NT
            //

            ZeroMemory (&sa, sizeof (sa));

            psd = (PSECURITY_DESCRIPTOR) MemAlloc (g_hHeap, 0, SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION)) {
                __leave;
            }

            if (!SetSecurityDescriptorDacl (psd, TRUE, (PACL) NULL, FALSE)) {
                 __leave;
            }

            sa.nLength = sizeof (sa);
            sa.lpSecurityDescriptor = psd;

            psa = &sa;

        } else {
            psa = NULL;
        }

        //
        // Create the IPC objects: an event and a memory mapped file
        //

        ipcData->Ack = CreateEvent (psa, FALSE, FALSE, NULL);

        wsprintf (objectName, TEXT("Sandbox%u.IpcData"), instance);
        ipcData->Mapping = CreateFileMapping (
                                INVALID_HANDLE_VALUE,
                                psa,
                                PAGE_READWRITE,
                                0,
                                0x10000,
                                objectName
                                );

        if (!ipcData->Ack || !ipcData->Mapping) {
            LOG ((LOG_ERROR, "Can't create IPC objects"));
            __leave;
        }

        //
        // Create the ack window proc thread and have it wait for messages
        //

        wsprintf (ipcData->WindowTitle, TEXT("SandboxHost%u"), instance);

        if (!pCreateExchangeThread()) {
            LOG ((LOG_ERROR, "Can't create ack thread"));
            __leave;
        }

        //
        // Launch the sandbox process
        //

        wsprintfA (
            cmdLine,
            "\"%s\" -i:%u",
            win32 ? g_ExePath32 : g_ExePath16,
            instance
            );

        ZeroMemory (&si, sizeof (si));
        si.cb = sizeof (si);
        si.dwFlags = STARTF_FORCEOFFFEEDBACK;

        processResult = CreateProcessA (
                            NULL,
                            cmdLine,
                            NULL,
                            NULL,
                            FALSE,
                            CREATE_DEFAULT_ERROR_MODE,
                            NULL,
                            WorkingDir,
                            &si,
                            &pi
                            );

        if (!processResult) {
            LOG ((LOG_ERROR, "Cannot start %s", cmdLine));
            __leave;
        }

        CloseHandle (pi.hThread);
        ipcData->ProcessHandle = pi.hProcess;

        //
        // Wait for process to fail or wait for it to send an ack
        //

        objectArray[0] = ipcData->Ack;
        objectArray[1] = pi.hProcess;
        rc = WaitForMultipleObjects (2, objectArray, FALSE, 60000);

        if (rc != WAIT_OBJECT_0) {
            DEBUGMSG ((
                DBG_WARNING,
                "Process %x did not signal 'ready'. Wait timed out. (%s)",
                g_ProcessHandle,
                g_Mode
                ));

            LOG ((LOG_ERROR, "Failed to launch sandbox."));
            __leave;
        }

        //
        // Launch was successful -- sandbox is now waiting for a command
        //

        DEBUGMSG ((DBG_SANDBOX, "Process %s is running (%s)", cmdLine, g_Mode));

        instance++;
        result = TRUE;
    }
    __finally {
        //
        // Cleanup code
        //

        PushError();

        if (!result) {
            if (ipcData) {
                pCloseIpcData (ipcData);
                MemFree (g_hHeap, 0, ipcData);
            }
        }

        if (psd) {
            MemFree (g_hHeap, 0, psd);
        }

        PopError();
    }

    return result ? (SBHANDLE) ipcData : NULL;
}


VOID
SbDestroySandbox (
    IN      SBHANDLE SandboxHandle
    )
{
    PIPCDATA ipcData = (PIPCDATA) SandboxHandle;
    DWORD rc;
    COPYDATA copyData;

    if (ipcData) {
        //
        // Tell sandbox to close
        //

        if (ipcData->Win32) {
            //
            // Turn off the ready event
            //

            MYASSERT (WAIT_OBJECT_0 == WaitForSingleObject (ipcData->ReadyEvent, 0));

            ResetEvent (ipcData->ReadyEvent);

            //
            // Wait for the sandbox to close, kill it if necessary
            //

            rc = WaitForSingleObject (ipcData->ProcessHandle, 10000);

            if (rc != WAIT_OBJECT_0) {
                TerminateProcess (ipcData->ProcessHandle, 0);
            }

        } else {

            //
            // Send a shutdown message to the sandbox
            //

            ZeroMemory (&copyData, sizeof (copyData));

            copyData.dwData = SB_CLOSE;

            SendMessage (
                ipcData->SandboxHwnd,
                WM_COPYDATA,
                ipcData->HostProcHwnd,
                copyData
                );

            //
            // Wait for the sandbox to close, kill it if necessary
            //

            rc = WaitForSingleObject (ipcData->ProcessHandle, 10000);

            if (rc != WAIT_OBJECT_0) {
                TerminateProcess (ipcData->ProcessHandle, 0);
            }
        }

        //
        // Clean up resources
        //

        pCloseIpcData (ipcData);
        MemFree (g_hHeap, 0, ipcData);
    }
}


LRESULT
CALLBACK
pIpcMessageProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    COPYDATASTRUCT *p;

    switch (uMsg) {

    case WM_COPYDATA:
        p = (COPYDATASTRUCT *) lParam;
        break;
    }

    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}


BOOL
pCreateExchangeThread (
    IN      UINT Instance
    )
{
    HANDLE thread;

    thread = StartThread (pAckThread, (PVOID) Instance);

    return thread != NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\display.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dndisp.c

Abstract:

    DOS-based NT setup program video display routines.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "enduser.h"


#define SCREEN_TOP_SCANLINE 80

#define SCREEN_WIDTH        80
#define SCREEN_HEIGHT       25


BYTE CurrentPixelValue;
BYTE LeftMargin;
BYTE ScreenX;
BYTE ScreenY;
BYTE CharWidth;
BYTE CharHeight;
FPCHAR BannerBitmap;


VOID
DispInitialize(
    VOID
    )

/*++

Routine Description:

    Put the display in a known state and initialize
    the display package.

Arguments:

    None.

Return Value:

    None.

--*/

{
    VgaInit();          // this clears the screen

    FontGetInfo(&CharWidth,&CharHeight);

    DispClearClientArea(NULL);

    DispSetLeftMargin(TEXT_LEFT_MARGIN);
    DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE);

    CurrentPixelValue = DEFAULT_TEXT_PIXEL_VALUE;
}


VOID
DispReinitialize(
    VOID
    )
{
    FontGetInfo(&CharWidth,&CharHeight);
}


VOID
DispSetCurrentPixelValue(
    IN BYTE PixelValue
    )
{
    CurrentPixelValue = PixelValue;
}


FPVOID
DispSaveDescriptionArea(
    OUT USHORT *SaveTop,
    OUT USHORT *SaveHeight,
    OUT USHORT *SaveBytesPerRow,
    OUT USHORT *DescriptionTop
    )
{
    *DescriptionTop = (CharHeight > 12) ? 16 : 25;
    *SaveHeight = CharHeight * 5;
    *SaveTop = (*DescriptionTop * CharHeight) + SCREEN_TOP_SCANLINE;

    return(VgaSaveBlock(0,*SaveTop,640,*SaveHeight,SaveBytesPerRow));
}


VOID
DispSetLeftMargin(
    IN BYTE X
    )
{
    LeftMargin = X;
}


VOID
DispClearClientArea(
    IN FPCHAR NewBannerBitmap OPTIONAL
    )

/*++

Routine Description:

    Clear the client area of the screen, ie, the area between the header
    and status line. We do this by restoring the background and banner
    bitmaps.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if(NewBannerBitmap) {
        BannerBitmap = strdup(NewBannerBitmap);
    }

    VgaDisplayBitmapFromFile("backgrnd.bmp",0,0,IoBuffer,63*512);
    redisplay:
    if(!VgaDisplayBitmapFromFile(BannerBitmap ? BannerBitmap : "enduser.bmp",0,0,IoBuffer,63*512)) {
        //
        // File might not exist
        //
        if(BannerBitmap) {
            free(BannerBitmap);
            BannerBitmap = NULL;
            goto redisplay;
        }
    }
}


VOID
DispPositionCursor(
    IN BYTE X,
    IN BYTE Y
    )

/*++

Routine Description:

    Position the cursor.

Arguments:

    X,Y - cursor coords

Return Value:

    None.

--*/

{
    if(X >= SCREEN_WIDTH) {
        X = 0;
        Y++;
    }

    if(Y >= SCREEN_HEIGHT) {
        Y = 0;
    }

    ScreenX = X;
    ScreenY = Y;
}


VOID
DispGetCursorPosition(
    OUT FPBYTE X,
    OUT FPBYTE Y
    )
{
    *X = ScreenX;
    *Y = ScreenY;
}


VOID
DispWriteChar(
    IN CHAR chr
    )

/*++

Routine Description:

    Write a character in the current attribute at the current position.

Arguments:

    chr - Character to write

Return Value:

    None.

--*/

{
    if(chr == '\n') {
        ScreenX = LeftMargin;
        ScreenY++;
        return;
    }

    //
    // Output the character
    //
    FontWriteChar(
        chr,
        ScreenX * CharWidth,
        SCREEN_TOP_SCANLINE + (ScreenY * CharHeight),
        CurrentPixelValue,
        16                      // no background value, text is transparent
        );
}


VOID
DispWriteString(
    IN FPCHAR String
    )

/*++

Routine Description:

    Write a string on the client area in the current position and
    adjust the current position.  The string is written in the current
    attribute.

Arguments:

    String - null terminated string to write.

Return Value:

    None.

--*/

{
    FPCHAR p;

    for(p=String; *p; p++) {
        DispWriteChar(*p);
        if(*p != '\n') {
            ScreenX++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\displib\vgac.c ===
#include <dos.h>
#include <share.h>

#include <mytypes.h>
#include <misclib.h>
#include <displib.h>


#define VGA_WIDTH_PIXELS        640
#define VGA_HEIGHT_SCAN_LINES   480


typedef struct _BITMAPFILEHEADER {
    USHORT bfType;
    ULONG  bfSize;
    USHORT bfReserved1;
    USHORT bfReserved2;
    ULONG  bfOffBits;
} BITMAPFILEHEADER;

typedef struct _BITMAPINFOHEADER{
   ULONG  biSize;
   long   biWidth;
   long   biHeight;
   USHORT biPlanes;
   USHORT biBitCount;
   ULONG  biCompression;
   ULONG  biSizeImage;
   long   biXPelsPerMeter;
   long   biYPelsPerMeter;
   ULONG  biClrUsed;
   ULONG  biClrImportant;
} BITMAPINFOHEADER;


BITMAPFILEHEADER FileHeader;
BITMAPINFOHEADER InfoHeader;

//
// Pixel maps. This is set up so that when bitmaps using the standard
// Windows VGA palette are displayed from a file, monochrome ones have
// a dark blue foreground and black background. Color bitmaps use the
// dark blue index as the background; pixels that are dark blue are
// assigned to be background and not placed into the video buffer.
//
BYTE PixMapMono[2] = { VGAPIX_BLACK, VGAPIX_BLUE };

BYTE PixMapColor[16] = { VGAPIX_BLACK,
                         VGAPIX_RED,
                         VGAPIX_GREEN,
                         VGAPIX_YELLOW,
                         VGAPIX_BLUE,
                         VGAPIX_MAGENTA,
                         VGAPIX_CYAN,
                         VGAPIX_LIGHT_GRAY,
                         VGAPIX_DARK_GRAY,
                         VGAPIX_LIGHT_RED,
                         VGAPIX_LIGHT_GREEN,
                         VGAPIX_LIGHT_YELLOW,
                         VGAPIX_LIGHT_BLUE,
                         VGAPIX_TRANSPARENT,
                         VGAPIX_LIGHT_CYAN,
                         VGAPIX_WHITE
                       };

BOOL
_far
VgaDisplayBitmapFromFile(
    IN FPCHAR Filename,
    IN USHORT x,
    IN USHORT y,
    IN FPVOID ScratchBuffer,
    IN UINT   ScratchBufferSize
    )
{
    unsigned FileHandle;
    unsigned Count;
    unsigned BytesPerLine;
    unsigned MaxLines;
    unsigned Lines;
    unsigned Bottom;
    BOOL b = FALSE;

    //
    // Open the file.
    //
    if(_dos_open(Filename,SH_DENYWR,&FileHandle)) {
        goto c0;
    }

    //
    // Read the bitmap file header and validate it.
    //
    if(_dos_read(FileHandle,&FileHeader,sizeof(BITMAPFILEHEADER),&Count)
    || (Count != sizeof(BITMAPFILEHEADER))
    || (FileHeader.bfType != 0x4d42)) {
        goto c1;
    }

    //
    // Read the bitmap info header and validate it.
    //
    if(_dos_read(FileHandle,&InfoHeader,sizeof(BITMAPINFOHEADER),&Count)
    || (Count != sizeof(BITMAPINFOHEADER))
    || (InfoHeader.biSize != sizeof(BITMAPINFOHEADER))
    || (InfoHeader.biHeight < 0)
    || ((y + InfoHeader.biHeight) > VGA_HEIGHT_SCAN_LINES)
    || ((x + InfoHeader.biWidth) > VGA_WIDTH_PIXELS)
    || (InfoHeader.biPlanes != 1)
    || ((InfoHeader.biBitCount != 1) && (InfoHeader.biBitCount != 4))
    || InfoHeader.biCompression) {

        goto c1;
    }

    //
    // Calculate the number of bytes per line. Rows are padded to
    // dword boundary.
    //
    Count = 8 / InfoHeader.biBitCount;
    BytesPerLine = (unsigned)(InfoHeader.biWidth / Count);
    if(InfoHeader.biWidth % Count) {
        BytesPerLine++;
    }
    BytesPerLine = (BytesPerLine+3) & 0xfffc;

    //
    // Ignore the color table for now. Seek to the start of the
    // actual bits.
    //
    if(DosSeek(FileHandle,FileHeader.bfOffBits,DOSSEEK_START) != FileHeader.bfOffBits) {
        goto c1;
    }

    //
    // Figure out how many lines fit into the buffer we were given.
    //
    MaxLines = ScratchBufferSize / BytesPerLine;

    Bottom = (y + (USHORT)InfoHeader.biHeight) - 1;

    while(InfoHeader.biHeight) {

        Lines = (unsigned)InfoHeader.biHeight;
        if(Lines > MaxLines) {
            Lines = MaxLines;
        }

        if(_dos_read(FileHandle,ScratchBuffer,Lines*BytesPerLine,&Count)
        || (Count != (Lines*BytesPerLine))) {

            goto c1;
        }

        VgaBitBlt(
            x,
            Bottom,
            (unsigned)InfoHeader.biWidth,
            -Lines,
            BytesPerLine,
            InfoHeader.biBitCount != 1,
            (InfoHeader.biBitCount != 1) ? PixMapColor : PixMapMono,
            ScratchBuffer
            );

        InfoHeader.biHeight -= Lines;
        Bottom -= Lines;
    }

    b = TRUE;

c1:
    _dos_close(FileHandle);
c0:
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\displib\vgaa.asm ===
DOSSEG
    .MODEL LARGE

VGA_BUFFER_SEG          equ 0a000h
VGA_WIDTH_PIXELS        equ 640
VGA_HEIGHT_SCAN_LINES   equ 480
VGA_BYTES_PER_SCAN_LINE equ (VGA_WIDTH_PIXELS/8)

VGA_REGISTER            equ 3ceh

VGAREG_SETRESET         equ 0
VGAREG_ENABLESETRESET   equ 1
VGAREG_READMAPSELECT    equ 4
VGAREG_MODE             equ 5
VGAREG_BITMASK          equ 8



    .CODE

    extrn _malloc:far

.286


;++
;
; VOID
; _far
; VgaBitBlt(
;     IN USHORT x,
;     IN USHORT y,
;     IN USHORT w,
;     IN USHORT h,
;     IN USHORT BytesPerRow,
;     IN BOOL   IsColor,
;     IN FPBYTE PixelMap,
;     IN FPVOID Data
;     );
;
; Routine Description:
;
;   Blits a rectangular block from memory to the screen.
;   The block is interpreted as a monochrome bitmap.
;
; Arguments:
;
;   x - gives the x position of the left edge of the target.
;
;   y - gives the y position of the *bottom* edge of the target.
;       The data is expected to be in standard Windows bottom-up
;       format, and the bitmap grows upward from this line as
;       it's transferred.
;
;   w - gives the width in pixels of a row of the source bitmap.
;
;   h - gives the number of lines in the source bitmap. The target
;       is lines y through (y-h)+1 inclusive, in a bottom-up fashion.
;
;   BytesPerRow - supplies the number of bytes in a row of data in the
;       bitmap. Rows in a Windows bitmap are padded to a dword boundary.
;
;   IsColor - if 0 the bitmap is interpreted as 1 bpp. If non-0 the bitmap
;       is interpreted as 4 bpp.
;
;   PixelMap - supplies an array of translations from pixel values in
;       the source bitmap to values to be placed into video memory
;       for that pixel. Each n-bit (1 for mono, 4 for color) value from
;       the source bitmap is used as an index into this array.
;       The 4-bit value looked up in the array is what is actually
;       placed into video memory for the pixel. For mono this is a
;       2 byte table, for color it's 16.
;
;   Data - supplies a pointer to the bitmap bits. The bits are expected
;       to be in the standard Windows bitmap bottom-up arrangement.
;       Each row of pixels is padded to a 4-byte boundary.
;
; Return Value:
;
;   None.
;
;--

vbb_x            equ word  ptr [bp+6]
vbb_y            equ word  ptr [bp+8]
vbb_w            equ word  ptr [bp+10]
vbb_h            equ           [bp+12]
vbb_BytesPerRow  equ word  ptr [bp+14]
vbb_IsColor      equ word  ptr [bp+16]
vbb_PixelMap     equ dword ptr [bp+18]
vbb_PixelMapl    equ word  ptr [bp+18]
vbb_PixelMaph    equ word  ptr [bp+20]
vbb_Datal        equ word  ptr [bp+22]
vbb_Datah        equ word  ptr [bp+24]

vbb_InitialShift equ byte  ptr [bp-1]
vbb_DataByteMask equ byte  ptr [bp-2]
vbb_ShiftAdjust  equ byte  ptr [bp-4]
vbb_PixelsRemain equ word  ptr [bp-6]
vbb_BufferOffset equ word  ptr [bp-8]
vbb_NextRowDelta equ word  ptr [bp-10]

LocalPixelMap db 16 dup (?)

    public _VgaBitBlt
_VgaBitBlt proc far

    push    bp
    mov     bp,sp
    sub     sp,10

    push    ds
    push    es
    push    si
    push    di
    push    bx

    ;
    ; Adjust for top-down vs bottom-up bitmap
    ;
    mov     vbb_NextRowDelta,VGA_BYTES_PER_SCAN_LINE
    test    byte ptr vbb_h[1],80h
    jns     @f
    neg     word ptr vbb_h              ; make the height positive
    neg     vbb_NextRowDelta            ; move backwards through buffer

    ;
    ; Set up read mode 0 and write mode 2.
    ;
@@: mov     dx,VGA_REGISTER
    mov     al,VGAREG_MODE
    mov     ah,2                        ; write mode 2, read mode 0
    out     dx,ax

    ;
    ; Set up bpp-dependent values
    ;
    cmp     vbb_IsColor,0
    jz      vbbmono
    mov     vbb_InitialShift,4
    mov     vbb_DataByteMask,0fh
    mov     vbb_ShiftAdjust,4           ; adjust shift count by 4 bits
    mov     cx,8                        ; pixel map is 16 bytes = 8 words
    jmp     short vbbmovemap
vbbmono:
    mov     vbb_InitialShift,7
    mov     vbb_DataByteMask,1
    mov     vbb_ShiftAdjust,1           ; adjust shift count by 1 bit
    mov     cx,1                        ; pixel map is 2 bytes = 1 words
vbbmovemap:
    ;
    ; Place the pixel map into memory addressable via cs.
    ; cx = count of words to move
    ;
    push    cs
    pop     es
    lea     di,LocalPixelMap            ; es:di -> local copy of pixel map
    mov     si,vbb_PixelMapl
    or      si,vbb_PixelMaph
    jnz     vbbmovemap2                 ; caller specified a pixel map

    ;
    ; No pixel map specified, build identity map
    ;
    mov     al,0
    stosb
    cmp     vbb_IsColor,0
    jne     vbbcolor
    mov     al,0fh
    stosb
    jmp     short vbbmovemap2
vbbcolor:
    inc     al
    stosb
    mov     ax,0302h
    stosw
    mov     ax,0504h
    stosw
    mov     ax,0706h
    stosw
    mov     ax,0908h
    stosw
    mov     ax,0b0ah
    stosw
    mov     ax,0d0ch
    stosw
    mov     ax,0f0eh
    stosw
    jmp     short vbbmovemap3
vbbmovemap2:
    lds     si,vbb_PixelMap             ; ds:si -> pixel map
    rep movsw
vbbmovemap3:
    mov     ax,vbb_Datah
    mov     ds,ax                       ; ds addresses bitmap data
    mov     ax,VGA_BUFFER_SEG
    mov     es,ax                       ; es addresses VGA video buffer

    ;
    ; Calculate address of first byte in video buffer we need to touch.
    ; Note that the y position is the *bottom* of the area to blit.
    ;
    mov     ax,VGA_BYTES_PER_SCAN_LINE
    mul     word ptr vbb_y              ; ax = offset of first byte on line
    mov     vbb_BufferOffset,ax
    mov     ax,vbb_x
    mov     cl,3                        ; divide by # bits in a byte (2^3)
    shr     ax,cl                       ; ax = offset of byte within line
    add     vbb_BufferOffset,ax         ; form offset of byte in buffer

    lea     bx,LocalPixelMap            ; cs:bx -> local copy of pixel map
    mov     dx,VGA_REGISTER             ; mul above clobbered dx

vbbrow:
    dec     word ptr vbb_h              ; done yet?
    js      vbbdone                     ; number went from 0 to -1, so we're done.

    mov     si,vbb_Datal                ; ds:si -> start of row in bitmap data
    mov     ax,vbb_BytesPerRow
    add     vbb_Datal,ax                ; point at next row for next iteration
    mov     di,vbb_BufferOffset
    mov     cx,vbb_NextRowDelta         ; move up or down for next row
    add     vbb_BufferOffset,cx

    mov     cx,vbb_w
    mov     vbb_PixelsRemain,cx         ; number of pixels remaining in row

    mov     cx,vbb_x
    and     cl,7                        ; cl = bit number of first bit on line
    sub     cl,7
    neg     cl                          ; cl = shift count
    mov     ah,1
    shl     ah,cl                       ; ah = initial bit mask

    mov     al,es:[di]                  ; load latches for current byte

vbbfetch:
    mov     cl,vbb_InitialShift         ; cl = shift count to extract data from bitmap
    lodsb                               ; get next byte from bitmap
    mov     ch,al                       ; save it

vbbbyte:
    ;
    ; ah = current bit mask
    ;
    mov     al,VGAREG_BITMASK
    out     dx,ax

    mov     al,ch                       ; restore byte from bitmap
    shr     al,cl                       ; place value into low n bits
    and     al,vbb_DataByteMask         ; al = value from bitmap
    xlatb   cs:[bx]                     ; al = pixel value to put into video memory

    ;
    ; Skip this pixel if the pixel value is greater than legal values
    ;
    test    al,0f0h
    jnz     vbbpix

    ;
    ; Stick this pixel into video memory.
    ; The bit mask is already set up to isloate the single pixel
    ; we want to modify.
    ;
    mov     es:[di],al

vbbpix:
    ;
    ; Adjust the bitmask to isolate the next pixel.
    ; If we've reached the end of the current byte then load the
    ; latches for the next one.
    ;
    ror     ah,1
    jnc     @f
    inc     di
@@: mov     al,es:[di]                  ; update latches

    ;
    ; Now check termination conditions to see if we're done with
    ; the current row and if we're done with the current byte.
    ;
    dec     vbb_PixelsRemain            ; done with this row yet?
    jz      vbbrow                      ; yes, start next row
    sub     cl,vbb_ShiftAdjust          ; adjust shift count
    jge     vbbbyte                     ; get next pixel from byte we loaded earlier
    jl      vbbfetch                    ; get next byte from bitmap

vbbdone:
    ;
    ; Restore BIOS defaults
    ;
    mov     dx,VGA_REGISTER
    mov     al,VGAREG_MODE
    mov     ah,0                        ; write mode 0, read mode 0
    out     dx,ax

    pop     bx
    pop     di
    pop     si
    pop     es
    pop     ds
    leave
    ret

_VgaBitBlt endp


;++
;
; VOID
; _far
; VgaClearRegion(
;     IN USHORT x,
;     IN USHORT y,
;     IN USHORT w,
;     IN USHORT h,
;     IN BYTE   PixelValue
;     );
;
; Routine Description:
;
;   Clears a given region on the vga screen to a given pixel value.
;
; Arguments:
;
;   x,y,w,h - give the x and y of the upper left corner
;       of the region to clear, and its width and height.
;
;   PixelValue - supplies pixel value to clear to.
;
; Return Value:
;
;   None.
;
;--

vcr_x          equ word ptr [bp+6]
vcr_y          equ word ptr [bp+8]
vcr_w          equ          [bp+10]
vcr_h          equ word ptr [bp+12]
vcr_PixelValue equ byte ptr [bp+14]

vcr_FirstByte  equ [bp+8]
vcr_startmask  equ byte ptr [bp+6]
vcr_endmask    equ byte ptr [bp+7]
vcr_fullbytes  equ byte ptr [bp+15]


    public _VgaClearRegion
_VgaClearRegion proc far

    push    bp
    mov     bp,sp
    push    di

    ;
    ; Calculate offset of first byte in first row we care about.
    ;
    mov     ax,VGA_BYTES_PER_SCAN_LINE
    mul     word ptr vcr_y              ; ax = y position
    mov     vcr_FirstByte,ax            ; store offset

    ;
    ; Now add in the byte offset of the byte containing the first pixel on
    ; each scan line.
    ;
    mov     ax,vcr_x                    ; ax = x position
    mov     cx,8                        ; divide by # of bits in a byte
    div     cl                          ; ah = bit, al = byte
    add     vcr_FirstByte,al
    adc     byte ptr vcr_FirstByte[1],0 ; [bp+8] -> byte in scan line with first pixel

    ;
    ; Calculate bitmask for partial byte at start of line.
    ; The layout of the video buffer is such that the mask to address
    ; the 0th pixel is 80, to address the 1st pixel is 40, etc.
    ; Thus the bit within the byte is essentially the number of
    ; high bits in the 8 bit mask that need to be 0.
    ;
    sub     cl,ah                       ; cl = count of 1 bits, ch = 0
    cmp     cx,vcr_w                    ; too many for desired width?
    pushf

    mov     ch,1
    shl     ch,cl
    dec     ch                          ; ch = bitmask, bottom cl bits are 1

    popf
    jbe     vcr_storestart              ; don't need to truncate width

    sub     cl,vcr_w                    ; cl = count of unwanted low bits
    mov     al,1
    shl     al,cl
    dec     al
    not     al
    and     ch,al
    mov     cl,vcr_w

vcr_storestart:
    ;
    ; cl = # pixels in partial byte
    ; ch = bitmask
    ;
    mov     vcr_startmask,ch            ; save mask for start
    xor     ch,ch                       ; cx = pixels accounted for so far
    mov     ax,vcr_w
    sub     ax,cx                       ; ax = remaining width
    jnz     vcr_calcbytes
    mov     vcr_fullbytes,dl            ; no full bytes
    mov     vcr_endmask,dl              ; no partial at end of line
    jmp     short vcrdoit

vcr_calcbytes:
    ;
    ; ax = remaining width
    ;
    mov     cl,8
    div     cl                          ; al = full bytes, ah = partial
    mov     vcr_fullbytes,al

    ;
    ; Now calculate the mask for the partial byte at the end
    ; of each line. This will involve setting n of the high bits
    ; in a mask.
    ;
    mov     cl,8
    sub     cl,ah
    mov     al,1
    shl     al,cl
    dec     al
    not     al
    mov     vcr_endmask,al

vcrdoit:
    mov     dx,VGA_REGISTER

    ;
    ; The enable set/reset is set up so that the data that gets written
    ; into video memory comes from the set/reset register, not the cpu.
    ; Thus the content of ax is irrelevent when we store to video mem.
    ;
    mov     al,VGAREG_SETRESET          ; set/reset register
    mov     ah,vcr_PixelValue           ; ah = pixel value
    out     dx,ax                       ; load set/reset register

    mov     al,VGAREG_ENABLESETRESET    ; enable set/reset register
    mov     ah,15                       ; mask = write planes from set/reset
    out     dx,ax                       ; load enable set/reset register

    mov     ax,VGA_BUFFER_SEG
    mov     es,ax

    mov     cx,vcr_h                    ; get row count

nextrow:
    push    cx

    mov     di,vcr_FirstByte            ; es:di -> first byte in target
    add     word ptr vcr_FirstByte,VGA_BYTES_PER_SCAN_LINE

    ;
    ; Do partial byte at relevent part of start of line
    ;
    mov     al,VGAREG_BITMASK
    mov     ah,vcr_startmask
    out     dx,ax
    mov     al,es:[di]                  ; load latches
    stosb                               ; update video memory

    ;
    ; Do all full bytes on this line
    ;
    mov     al,VGAREG_BITMASK
    mov     ah,255
    out     dx,ax
    mov     cl,vcr_fullbytes
    mov     ch,0
    rep stosb

    ;
    ; And finally the trail part
    ;
    mov     al,VGAREG_BITMASK
    mov     ah,vcr_endmask
    out     dx,ax
    mov     al,es:[di]                  ; load latches
    stosb                               ; update video memory

    pop     cx                          ; restore row count
    loop    nextrow

    ;
    ; Restore default enable set/reset, bitmask
    ;
    mov     al,VGAREG_ENABLESETRESET
    mov     ah,0
    mov     dx,VGA_REGISTER
    out     dx,ax
    mov     al,VGAREG_BITMASK
    mov     ah,255
    out     dx,ax

    pop     di
    leave
    ret

_VgaClearRegion endp


;++
;
; VOID
; _far
; VgaClearScreen(
;     IN BYTE PixelValue
;     );
;
; Routine Description:
;
;   Clears the 640x480 vga graphics screen.
;
; Arguments:
;
;   PixelValue - supplies pixel value to clear to.
;
; Return Value:
;
;   None.
;
;--

vcs_PixelValue equ [bp+6]

    public _VgaClearScreen
_VgaClearScreen proc far

    push    bp
    mov     bp,sp

    push    vcs_PixelValue
    push    VGA_HEIGHT_SCAN_LINES
    push    VGA_WIDTH_PIXELS
    push    0
    push    0

    call    _VgaClearRegion

    add     sp,10

    leave
    ret

_VgaClearScreen endp


;++
;
; VOID
; _far
; VgaInit(
;     VOID
;     );
;
; Routine Description:
;
;   Initializes display support by setting 640x480 vga graphics mode
;   and clearing the screen.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

    public _VgaInit
_VgaInit proc far

    mov     ax,12h
    mov     bx,0
    int     10h
    push    0                       ; pixel value
    call    _VgaClearScreen
    add     sp,2
    ret

_VgaInit endp



;++
;
; FPVOID
; _far
; VgaSaveBlock(
;     IN USHORT   x,
;     IN USHORT   y,
;     IN USHORT   w,
;     IN USHORT   h,
;     IN FPUSHORT BytesPerRow
;     );
;
; Routine Description:
;
;   Grabs a block of memory from the screen and places it into a block
;   of memory. The block can later be used with VgaBitBlt.
;
;   This routine limits the size of the block to 32K. If the block
;   would be larger than this, the routine fails.
;
; Arguments:
;
;   x - supplies x coordinate of left edge of area to save.
;       This MUST be an even multiple of 8. If it is not, the routine
;       fails and returns NULL.
;
;   y - supplies y coordinate of top of area to save.
;
;   w - supplies width in pixels of area to save. This MUST be an even
;       multiple of 8. If it is not, the routine fails and returns NULL.
;
;   h - supplies height of area to save.
;
;   BytesPerRow - receives number of bytes in a row of the saved block.
;       This value is suitable for passing in as the BytesPerRow parameter
;       to VgaBitBlt.
;
; Return Value:
;
;   Pointer to bits, allocated via malloc(). Caller can free when finished.
;   NULL if couldn't allocate enough memory for the saved block or invalid
;   parameters were given.
;
;--

vsb_x           equ word  ptr [bp+6]
vsb_y           equ word  ptr [bp+8]
vsb_w           equ word  ptr [bp+10]
vsb_h           equ word  ptr [bp+12]
vsb_BytesPerRow equ dword ptr [bp+14]

vsb_BytesLeft   equ word  ptr [bp-2]

MakeAndSave2Pixels label near
    ;
    ; Take the 4 bytes from the bit planes and based on the top
    ; 2 bits of each, build 2 pixel values and save into the
    ; target bitmap. We take advantage of the fact that the sar
    ; instruction replicates the top bit as it shifts. This allows
    ; us to essentially shift 2 adjacent bits into nonadjacent
    ; bit positions.
    ;
    mov     dx,bx
    mov     ax,cx
    sar     dh,3                    ; shift bit 7 to bit 7 and bit 6 to bit 3
    sar     dl,4                    ; shift bit 7 to bit 6 and bit 6 to bit 2
    sar     ah,5                    ; shift bit 7 to bit 5 and bit 6 to bit 1
    sar     al,6                    ; shift bit 7 to bit 4 and bit 6 to bit 0
    and     dx,8844h                ; isolate top 2 bits for each of two pixels
    and     ax,2211h                ; and then isolate bottom 2 bits
    or      al,ah                   ; or in bit 1 for each pixel
    or      al,dl                   ; or in bit 2 for each pixel
    or      al,dh                   ; or in bit 3 for each pixel
    stosb                           ; al has 2 pixel values, save in bitmap
    retn

    public _VgaSaveBlock
_VgaSaveBlock proc far

    push    bp
    mov     bp,sp
    sub     sp,2
    push    es
    push    si
    push    di
    push    bx
    push    ds

    ;
    ; Check conditions. Violation of them is catastrophic
    ; as the implementation simply can't handle it.
    ;
    test    vsb_x,7
    jnz     vsbinval
    test    vsb_w,7
    jz      vsbok
vsbinval:
    xor     ax,ax
    mov     dx,ax
    jmp     vsb_done

    ;
    ; Calculate the bytes per row. Rows are padded to a dword boundary.
    ; There are 4 bits per pixel and 8 bits per byte, so we can simply divide
    ; the width by 2 to calculate this value. Note that the result is
    ; always naturally aligned to a dword boundary.
    ;
vsbok:
    mov     ax,vsb_w
    shr     vsb_w,3                 ; width is now expressed in bytes
    shr     ax,1
    les     di,vsb_BytesPerRow
    mov     es:[di],ax              ; store in caller's variable

    ;
    ; Calculate the size of the buffer we need, which is simply
    ; height * bytes-per-row. Allocate a buffer and zero it out.
    ;
    ; NOTE: we have not disturbed ds yet. ds MUST be the caller's value
    ; before we attempt to call the CRTs!
    ;
    ; ax = bytes per row
    ;
    mul     vsb_h                   ; ax = buffer size needed
    cmp     dx,0                    ; > 64K?
    jnz     vsbinval                ; yes, too big
    cmp     ah,0                    ; > 32K?
    jl      vsbinval                ; yes, too big
    push    ax                      ; pass size to malloc
    call    _malloc
    pop     cx                      ; throw away size param off stack
    mov     bx,dx
    or      bx,ax
    jz      vsb_done                ; dx:ax set for error return

    mov     es,dx
    mov     di,ax                   ; es:di -> bits
    push    ax                      ; save offset for later return

    mov     ax,VGA_BYTES_PER_SCAN_LINE
    mul     vsb_y                   ; ax -> first byte on first line
    shr     vsb_x,3                 ; convert x coord to byte count
    add     vsb_x,ax                ; vsb_x -> first byte to save

    mov     ax,VGA_BUFFER_SEG
    mov     ds,ax                   ; ds addresses vga video buffer

vsbrow:
    mov     si,vsb_x                ; ds:si -> first byte in vga buf to save
    add     vsb_x,VGA_BYTES_PER_SCAN_LINE ; prepare for next iteration

    mov     dx,vsb_w
    mov     vsb_BytesLeft,dx

vsbbyte:
    ;
    ; Read the 4 planes at the current byte
    ;
    mov     dx,VGA_REGISTER
    mov     al,VGAREG_READMAPSELECT
    mov     ah,3
    out     dx,ax
    mov     bh,[si]
    dec     ah
    out     dx,ax
    mov     bl,[si]
    dec     ah
    out     dx,ax
    mov     ch,[si]
    dec     ah
    out     dx,ax
    mov     cl,[si]
    inc     si

    ;
    ; bh = byte from plane 3
    ; bl = byte from plane 2
    ; ch = byte from plane 1
    ; cl = byte from plane 0
    ;
    call    MakeAndSave2Pixels
    shl     bx,2
    shl     cx,2
    call    MakeAndSave2Pixels
    shl     bx,2
    shl     cx,2
    call    MakeAndSave2Pixels
    shl     bx,2
    shl     cx,2
    call    MakeAndSave2Pixels

    ;
    ; Do all bytes on this line.
    ;
    dec     vsb_BytesLeft
    jnz     vsbbyte

    ;
    ; Done with line, see if done.
    ;
    dec     vsb_h
    jnz     vsbrow

    ;
    ; Done, return buffer to caller.
    ;
    mov     dx,es
    pop     ax                      ; dx:ax -> bit buffer

vsb_done:
    pop     ds
    pop     bx
    pop     di
    pop     si
    pop     es
    leave
    ret

_VgaSaveBlock endp

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\expand.c ===
#include "enduser.h"

VOID
TransferNonClusterData(
    IN     HDISK  DiskHandle,
    IN OUT ULONG *SourceStart,
    IN OUT ULONG *TargetStart
    );

VOID
ExpandFromStart(
    IN HDISK DiskHandle,
    IN ULONG SourceStart,
    IN ULONG TargetStart
    );

VOID
ExpandFromEnd(
    IN HDISK DiskHandle,
    IN ULONG SourceStart,
    IN ULONG TargetStart
    );

VOID
InitializeClusterMapForward(
    IN HDISK DiskHandle
    );

VOID
InitializeClusterMapReverse(
    IN HDISK DiskHandle
    );

VOID
GetForwardClusterRun(
    IN  HDISK  DiskHandle,
    OUT ULONG *StartCluster,
    OUT ULONG *StartOffset,
    OUT ULONG *ClusterCount
    );

VOID
GetReverseClusterRun(
    IN  HDISK  DiskHandle,
    OUT ULONG *StartCluster,
    OUT ULONG *StartOffset,
    OUT ULONG *ClusterCount
    );

VOID
Fat32ExpandOneFat( 
    IN      HDISK   DiskHandle, 
    IN OUT  ULONG   *SourceStart,
    IN OUT  ULONG   *TargetStart,
    IN      ULONG   Fat32FatSectorCount, 
    IN      ULONG   Fat32AdjustedFatSectorCount 
    );

VOID
ExpandImage(
    IN HDISK DiskHandle,
    IN BYTE  SectorsPerTrack,
    IN ULONG SourceStart,
    IN ULONG TargetStart
    )
{
    //
    // Transfer non-cluster data to the start of the drive.
    //
    TransferNonClusterData(DiskHandle,&SourceStart,&TargetStart);

    //
    // Expand out data from the image moving forward until we either
    // run out of image or we would overwrite data in the image we
    // haven't used yet.
    //
    ExpandFromStart(DiskHandle,SourceStart,TargetStart);

    //
    // Expand out data from the image moving backwards until we
    // reach the point at which the forward transfer above stopped.
    //
    ExpandFromEnd(DiskHandle,SourceStart,TargetStart);
}


VOID
TransferNonClusterData(
    IN     HDISK  DiskHandle,
    IN OUT ULONG *SourceStart,
    IN OUT ULONG *TargetStart
    )
{
    ULONG Write;
    ULONG Count;
    ULONG Offset;
    ULONG Fat32FatSectorCount;
    ULONG Fat32AdjustedFatSectorCount;
    BOOL Xms;

    _Log("Transfer non cluster data, source = 0x%lx, target = 0x%lx\n",*SourceStart,*TargetStart);
    
    //
    // See if we've already done this step.
    //
    if(!CmdLineArgs.Test && (MasterDiskInfo.State >= MDS_DID_NONCLUSTER_DATA)) {
        _Log("Non cluster data already transferred\n");
        *SourceStart += PartitionImage.NonClusterSectors;
        *TargetStart += PartitionImage.NonClusterSectors;
        GaugeDelta(2*PartitionImage.NonClusterSectors);
        return;
    }

    //
    // this wil be zero if not resizing (FAT32)
    //
    if(PartitionImage.Fat32AdjustedSectorCount) {

        _Log("Non cluster data sectors previously processed = 0x%lx\n",MasterDiskInfo.NonClusterSectorsDone);
        GaugeDelta(2*MasterDiskInfo.NonClusterSectorsDone);

        //
        // Fat32 case
        //
        // BUGBUG We run into big problems if the image is located right at the beginning of the disk.
        // This needs to be prevented in makemast.
        //

        //
        // Get the old size of the FAT in sectors.
        //
        Fat32FatSectorCount = PartitionImage.Fat32OriginalFatTableSectCount;

        // 
        // Calculate the new size of the FAT in sectors.
        //
        Fat32AdjustedFatSectorCount = PartitionImage.Fat32AdjustedFatTableEntryCount/(512/4);
        Fat32AdjustedFatSectorCount = (PartitionImage.Fat32AdjustedFatTableEntryCount%(512/4)) ? 
                                    Fat32AdjustedFatSectorCount++: Fat32AdjustedFatSectorCount;

        Offset = 0;

        //
        // all right, restore the reserved sectors at the beginning of the disk
        // since the number of reserved sectors for FAT32 is small, just read
        // and write them all at once.
        //
        if( MasterDiskInfo.NonClusterSectorsDone < PartitionImage.Fat32ReservedSectors ) {        

            //
            // if we haven't already done this
            //

            XmsIoDiskRead(
                DiskHandle,
                *SourceStart,
                PartitionImage.Fat32ReservedSectors,
                &Write,
                &Xms
                );
            XmsIoDiskWrite(DiskHandle,*TargetStart,Offset,Write,Xms);
    
            _Log("Restore %lu reserved sectors from 0x%lx\n",Write,*SourceStart);
            MasterDiskInfo.NonClusterSectorsDone += Write;
            if(!CmdLineArgs.Test) {
                UpdateMasterDiskState(DiskHandle,MasterDiskInfo.State);
            }

        }

        *SourceStart += PartitionImage.Fat32ReservedSectors;
        *TargetStart += PartitionImage.Fat32ReservedSectors;

        //
        // now do the first FAT table
        //
        _Log("Restore FAT32 tables.\n");

        if( MasterDiskInfo.NonClusterSectorsDone <
            ( PartitionImage.Fat32ReservedSectors + Fat32FatSectorCount )) {
        
            //
            // if we haven't already done this
            //
            _Log("Restore first FAT.\n");
            Fat32ExpandOneFat( DiskHandle, 
                               SourceStart, 
                               TargetStart,
                               Fat32FatSectorCount, 
                               Fat32AdjustedFatSectorCount
                               );
    
        } else {
            _Log("First FAT already restored.\n");
        }


        //
        // now do the second FAT table
        //
        _Log("Restore second FAT.\n");
        Fat32ExpandOneFat( DiskHandle, 
                           SourceStart, 
                           TargetStart,
                           Fat32FatSectorCount, 
                           Fat32AdjustedFatSectorCount
                           );

    } else {

        //
        // Other file systems
        //    
        _Log("Non cluster data sectors previously processed = 0x%lx\n",MasterDiskInfo.NonClusterSectorsDone);
    
        GaugeDelta(2*MasterDiskInfo.NonClusterSectorsDone);
        *SourceStart += MasterDiskInfo.NonClusterSectorsDone;
        *TargetStart += MasterDiskInfo.NonClusterSectorsDone;

        while(MasterDiskInfo.NonClusterSectorsDone < PartitionImage.NonClusterSectors) {
            XmsIoDiskRead(
                DiskHandle,
                *SourceStart,
                PartitionImage.NonClusterSectors - MasterDiskInfo.NonClusterSectorsDone,
                &Write,
                &Xms
                );
    
            _Log("Read %lu non-cluster sectors from 0x%lx\n",Write,*SourceStart);
    
            Offset = 0;
    
            while(Write) {
    
                //
                // Write as large a chunk as possible without overlap.
                //
                if((*TargetStart + Write) > *SourceStart) {
                    Count = *SourceStart - *TargetStart;
                } else {
                    Count = Write;
                }
    
                XmsIoDiskWrite(DiskHandle,*TargetStart,Offset,Count,Xms);
    
                Write -= Count;
                *SourceStart += Count;
                Offset += Count;
    
                MasterDiskInfo.NonClusterSectorsDone += Count;
                if(!CmdLineArgs.Test) {
                    UpdateMasterDiskState(DiskHandle,MasterDiskInfo.State);
                }
    
                _Log("Wrote %lu non-cluster sectors to 0x%lx\n",Count,*TargetStart);
    
                *TargetStart += Count;
            }
        }
    }

    //
    // Update master disk state to indicate that we're done with this step.
    //
    if(!CmdLineArgs.Test) {
        UpdateMasterDiskState(DiskHandle,MDS_DID_NONCLUSTER_DATA);
    }
}


VOID
ExpandFromStart(
    IN HDISK DiskHandle,
    IN ULONG SourceStart,
    IN ULONG TargetStart
    )
{
    ULONG Start,Offset,Count;
    ULONG SourceFirst;
    ULONG TargetFirst;
    ULONG SoFar;
    ULONG u;
    BOOL Xms;
    ULONG Write;

    //
    // See if we've already done this step.
    //
    if(!CmdLineArgs.Test && (MasterDiskInfo.State >= MDS_DID_XFER_FORWARD)) {
        _Log("Already did expand in forward direction\n");
        GaugeDelta(2*MasterDiskInfo.ForwardXferSectorCount);
        return;
    }

    _Log("\nStarting forward expansion, sectors previously done = 0x%lx\n",MasterDiskInfo.ForwardXferSectorCount);

    InitializeClusterMapForward(DiskHandle);

    SoFar = 0;

    //
    // Get a run of clusters and calculate the first and last sector
    // of the source and the target. If there are no more clusters left,
    // we're done.
    //
    nextrun:
    GetForwardClusterRun(DiskHandle,&Start,&Offset,&Count);
    if(!Count) {
        if(!CmdLineArgs.Test) {
            UpdateMasterDiskState(DiskHandle,MDS_DID_XFER_FORWARD);
        }
        return;
    }

    Start *= PartitionImage.SectorsPerCluster;
    Offset *= PartitionImage.SectorsPerCluster;
    Count *= PartitionImage.SectorsPerCluster;

    _Log("\nSector run: start = 0x%lx, count = 0x%lx, offset = 0x%lx\n",Start,Count,Offset);

    //
    // See if we're already done this xfer or part of it on a previous pass.
    // Note that SoFar cannot ever be greater than
    // MasterDiskInfo.ForwardXFerSectorCount because we increment them both
    // by the same amount after a transfer. In most cases they will be equal.
    //
    if((SoFar+Count) <= MasterDiskInfo.ForwardXferSectorCount) {

        _Log("Already did this run, skipping\n");

        SoFar += Count;
        GaugeDelta(2*Count);
        goto nextrun;
    }
    if(u = (MasterDiskInfo.ForwardXferSectorCount - SoFar)) {
        //
        // We know that Count > MasterDiskInfo.ForwardXFerSectorCount - SoFar,
        // which means that if we get here, Count > u >= 1.
        //
        // Adjust the counts and fall through. Note that after this from now on
        // MasterDiskInfo.ForwardXFerSectorCount == SoFar, meaning neither this
        // nor the previous if clause will be triggered.
        //

        _Log("Already partially did this run, adjusting\n");

        SoFar += u;
        Start += u;
        Offset += u;
        Count -= u;
        GaugeDelta(2*u);
    }

    SourceFirst = SourceStart + Offset;
    TargetFirst = TargetStart + Start;

    //
    // If writing to the target would hose over data we haven't
    // read from the source yet, we're done with the forward expansion.
    //
    if(SourceFirst < TargetFirst) {

        _Log("Target passes source, done with forward expansion\n");

        if(!CmdLineArgs.Test) {
            UpdateMasterDiskState(DiskHandle,MDS_DID_XFER_FORWARD);
        }
        return;
    }

    //
    // If the source and target are the same, nothing to do.
    // Otherwise, do our thing.
    //
    if(SourceFirst == TargetFirst) {

        _Log("Source is same as target\n");

        SoFar += Count;
        MasterDiskInfo.ForwardXferSectorCount += Count;
        if(!CmdLineArgs.Test) {
            UpdateMasterDiskState(DiskHandle,MasterDiskInfo.State);
        }
        GaugeDelta(2*Count);
    } else {

        while(Count) {

            XmsIoDiskRead(DiskHandle,SourceFirst,Count,&Write,&Xms);

            _Log("Read %lu sectors from 0x%lx\n",Write,SourceFirst);

            Offset = 0;

            while(Write) {
                //
                // Write as large a run as possible without overlap.
                //
                if((TargetFirst+Write) > SourceFirst) {
                    u = SourceFirst - TargetFirst;
                } else {
                    u = Write;
                }
                _Log("Writing %lu sectors to 0x%lx\n",u,TargetFirst);

                XmsIoDiskWrite(DiskHandle,TargetFirst,Offset,u,Xms);

                //
                // Update vars
                //
                SoFar += u;
                SourceFirst += u;
                Offset += u;
                Write -= u;
                Count -= u;

                MasterDiskInfo.ForwardXferSectorCount += u;
                if(!CmdLineArgs.Test) {
                    UpdateMasterDiskState(DiskHandle,MasterDiskInfo.State);
                }

                _Log("Wrote %lu sectors to 0x%lx\n",u,TargetFirst);

                TargetFirst += u;
            }
        }
    }

    //
    // Process additional clusters.
    //
    goto nextrun;
}


VOID
ExpandFromEnd(
    IN HDISK DiskHandle,
    IN ULONG SourceStart,
    IN ULONG TargetStart
    )
{
    ULONG End,Offset,Count;
    ULONG SourceEnd;
    ULONG TargetEnd;
    ULONG SoFar;
    ULONG u;
    BOOL Xms;
    ULONG Write;

    //
    // See if we've already done this step.
    //
    if(!CmdLineArgs.Test && (MasterDiskInfo.State >= MDS_DID_XFER_REVERSE)) {
        _Log("Already did expand in reverse direction\n");
        GaugeDelta(2*MasterDiskInfo.ReverseXferSectorCount);
        return;
    }

    _Log("Starting reverse expansion, sectors previously done = 0x%lx\n",MasterDiskInfo.ReverseXferSectorCount);

    InitializeClusterMapReverse(DiskHandle);

    SoFar = 0;

    //
    // Get a run of clusters and calculate the first and last sector
    // of the source and the target. If there are no more clusters left,
    // we're done.
    //
    nextrun:
    GetReverseClusterRun(DiskHandle,&End,&Offset,&Count);
    if(!Count) {
        if(!CmdLineArgs.Test) {
            UpdateMasterDiskState(DiskHandle,MDS_DID_XFER_REVERSE);
        }
        return;
    }

    End = (End + 1) * PartitionImage.SectorsPerCluster;
    Offset = (Offset + 1) * PartitionImage.SectorsPerCluster;
    Count *= PartitionImage.SectorsPerCluster;

    _Log("\nSector run: end = 0x%lx, count = 0x%lx, offset = 0x%lx\n",End,Count,Offset);

    //
    // See if we're already done this xfer or part of it on a previous pass.
    // Note that SoFar cannot ever be greater than
    // MasterDiskInfo.ReverseXFerSectorCount because we increment them both
    // by the same amount after a transfer. In most cases they will be equal.
    //
    if((SoFar+Count) <= MasterDiskInfo.ReverseXferSectorCount) {

        _Log("Already did this run, skipping\n");

        SoFar += Count;
        GaugeDelta(2*Count);
        goto nextrun;
    }
    if(u = (MasterDiskInfo.ReverseXferSectorCount - SoFar)) {
        //
        // We know that Count > MasterDiskInfo.ReverseXFerSectorCount - SoFar,
        // which means that if we get here, Count > u >= 1.
        //
        // Adjust the counts and fall through. Note that after this from now on
        // MasterDiskInfo.ReverseXFerSectorCount == SoFar, meaning neither this
        // nor the previous if clause will be triggered.
        //

        _Log("Already partially did this run, adjusting\n");

        SoFar += u;
        End -= u;
        Offset -= u;
        Count -= u;
        GaugeDelta(2*u);
    }

    SourceEnd = SourceStart + Offset;
    TargetEnd = TargetStart + End;

    //
    // If writing to the target would hose over data we haven't
    // read from the source yet, we're done.
    //
    if(TargetEnd < SourceEnd) {
        _Log("Target passes source, done with reverse expansion\n");
        if(!CmdLineArgs.Test) {
            UpdateMasterDiskState(DiskHandle,MDS_DID_XFER_REVERSE);
        }
        return;
    }

    //
    // If the source and target are the same, nothing to do.
    // (Note: this case should not occur, since we would have
    // picked it up on the forward scan. But just in case,
    // we handle it anyway.)
    // Otherwise, do our thing.
    //
    if(SourceEnd == TargetEnd) {

        _Log("Source is same as target\n");

        SoFar += Count;
        MasterDiskInfo.ReverseXferSectorCount += Count;
        if(!CmdLineArgs.Test) {
            UpdateMasterDiskState(DiskHandle,MasterDiskInfo.State);
        }
        GaugeDelta(2*Count);
    } else {

        while(Count) {

            XmsIoDiskRead(DiskHandle,SourceEnd-Count,Count,&Write,&Xms);

            _Log("Read %lu sectors from 0x%lx\n",Write,SourceEnd-Count);

            Offset = Write;

            while(Write) {
                //
                // Write as large a run as possible without overlap.
                //
                if((TargetEnd-Write) < SourceEnd) {
                    u = TargetEnd - SourceEnd;
                } else {
                    u = Write;
                }

                _Log("Writing %lu sectors to 0x%lx\n",u,TargetEnd-u);
                XmsIoDiskWrite(DiskHandle,TargetEnd-u,Offset-u,u,Xms);

                //
                // Update vars
                //
                SoFar += u;
                SourceEnd -= u;
                TargetEnd -= u;
                Offset -= u;
                Write -= u;
                Count -= u;

                MasterDiskInfo.ReverseXferSectorCount += u;
                if(!CmdLineArgs.Test) {
                    UpdateMasterDiskState(DiskHandle,MasterDiskInfo.State);
                }

                _Log("Wrote %lu sectors to 0x%lx\n",u,TargetEnd);
            }
        }
    }

    //
    // Process additional clusters.
    //
    goto nextrun;
}


////////////////////////////////////////////////////

ULONG _NextClusterToExamine;
BYTE _ClusterBuffer[512];
ULONG _BufferedClusterMapSector;
ULONG _ClusterBufferBase;
ULONG _ClusterOffset;
BOOL _First;

BYTE  BitValue[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };


VOID
InitializeClusterMapForward(
    IN HDISK DiskHandle
    )
{
    //
    // Read the first sector of the cluster bitmap.
    //
    if(!ReadDisk(DiskHandle,MasterDiskInfo.ClusterBitmapStart,1,IoBuffer)) {
        FatalError(textReadFailedAtSector,1,MasterDiskInfo.ClusterBitmapStart);
    }
    memmove(_ClusterBuffer,IoBuffer,512);

    _BufferedClusterMapSector = MasterDiskInfo.ClusterBitmapStart;
    _NextClusterToExamine = 0;
    _ClusterBufferBase = 0;
    _ClusterOffset = 0;
}


VOID
GetForwardClusterRun(
    IN  HDISK  DiskHandle,
    OUT ULONG *StartCluster,
    OUT ULONG *StartOffset,
    OUT ULONG *ClusterCount
    )
{
    UINT cluster;
    BOOL b;

    *ClusterCount = 0;

    //
    // Locate the next 1 bit in the map.
    //
    while(_NextClusterToExamine <= PartitionImage.LastUsedCluster) {

        //
        // Reload the cluster buffer if necessary.
        //
        if(_NextClusterToExamine && !(_NextClusterToExamine % CLUSTER_BITS_PER_SECTOR)) {

            if(!ReadDisk(DiskHandle,++_BufferedClusterMapSector,1,IoBuffer)) {
                FatalError(textReadFailedAtSector,1,_BufferedClusterMapSector);
            }
            memmove(_ClusterBuffer,IoBuffer,512);

            _ClusterBufferBase += CLUSTER_BITS_PER_SECTOR;
        }

        cluster = (UINT)(_NextClusterToExamine - _ClusterBufferBase);

        //
        // See if this bit is one, which starts a run of used clusters.
        // To simplify things, we won't return a run that spans sectors
        // in the cluster bitmap.
        //
        b = FALSE;

        while((_ClusterBuffer[cluster/8] & BitValue[cluster%8])
        && (cluster < CLUSTER_BITS_PER_SECTOR)
        && (_NextClusterToExamine <= PartitionImage.LastUsedCluster)) {

            if(!b) {
                *StartOffset = _ClusterOffset;
                *StartCluster = _NextClusterToExamine;
                b = TRUE;
            }

            *ClusterCount += 1;
            cluster++;
            _NextClusterToExamine++;
            _ClusterOffset++;
        }

        if(b) {
            return;
        }

        _NextClusterToExamine++;
    }
}


VOID
InitializeClusterMapReverse(
    IN HDISK DiskHandle
    )
{
    ULONG Sector;

    //
    // Read the last sector of the cluster bitmap.
    //
    Sector = MasterDiskInfo.ClusterBitmapStart
           + (PartitionImage.LastUsedCluster/CLUSTER_BITS_PER_SECTOR);

    if(!ReadDisk(DiskHandle,Sector,1,IoBuffer)) {
        FatalError(textReadFailedAtSector,1,Sector);
    }
    memmove(_ClusterBuffer,IoBuffer,512);

    _BufferedClusterMapSector = Sector;
    _NextClusterToExamine = PartitionImage.LastUsedCluster;

    _ClusterBufferBase = (PartitionImage.LastUsedCluster / CLUSTER_BITS_PER_SECTOR)
                       * CLUSTER_BITS_PER_SECTOR;

    _ClusterOffset = PartitionImage.UsedClusterCount-1;

    _First = TRUE;
}


VOID
GetReverseClusterRun(
    IN  HDISK  DiskHandle,
    OUT ULONG *StartCluster,
    OUT ULONG *StartOffset,
    OUT ULONG *ClusterCount
    )
{
    UINT cluster;
    BOOL b;

    *ClusterCount = 0;

    //
    // Locate the next 1 bit in the map.
    //
    while(_NextClusterToExamine != (ULONG)(-1)) {

        //
        // Reload the cluster buffer if necessary.
        //
        if(((_NextClusterToExamine % CLUSTER_BITS_PER_SECTOR) == (CLUSTER_BITS_PER_SECTOR-1)) && !_First) {

            if(!ReadDisk(DiskHandle,--_BufferedClusterMapSector,1,IoBuffer)) {
                FatalError(textReadFailedAtSector,1,_BufferedClusterMapSector);
            }
            memmove(_ClusterBuffer,IoBuffer,512);

            _ClusterBufferBase -= CLUSTER_BITS_PER_SECTOR;
        }

        _First = FALSE;
        cluster = (UINT)(_NextClusterToExamine - _ClusterBufferBase);

        //
        // See if this bit is one, which starts a run of used clusters.
        // To simplify things, we won't return a run that spans sectors
        // in the cluster bitmap.
        //
        b = FALSE;

        while((_ClusterBuffer[cluster/8] & BitValue[cluster%8])
        && (cluster != (UINT)(-1))
        && (_NextClusterToExamine != (ULONG)(-1))) {

            if(!b) {
                *StartCluster = _NextClusterToExamine;
                *StartOffset = _ClusterOffset;
                b = TRUE;
            }

            *ClusterCount += 1;
            cluster--;
            _NextClusterToExamine--;
            _ClusterOffset--;
        }

        if(b) {
            return;
        }

        _NextClusterToExamine--;
    }

    return;
}

VOID
Fat32ExpandOneFat( 
    IN      HDISK   DiskHandle, 
    IN OUT  ULONG   *SourceStart,
    IN OUT  ULONG   *TargetStart,
    IN      ULONG   Fat32FatSectorCount, 
    IN      ULONG   Fat32AdjustedFatSectorCount 
    )     
{    
    ULONG   RemainingSectors;
    ULONG   Counter;
    ULONG   Write;
    ULONG   Offset;
    BOOL    Xms;

    RemainingSectors = Fat32FatSectorCount;
    Offset = 0;

    //
    // now restore the FAT table
    //

    while( RemainingSectors ) {
        XmsIoDiskRead(
            DiskHandle,
            *SourceStart,
            RemainingSectors,
            &Write,
            &Xms
            );
    
        XmsIoDiskWrite(DiskHandle,*TargetStart,Offset,Write,Xms);
        
        RemainingSectors -= Write;
        *SourceStart += Write;
        *TargetStart += Write;

        if(!CmdLineArgs.Test) {
            UpdateMasterDiskState(DiskHandle,MasterDiskInfo.State);
        }
        MasterDiskInfo.NonClusterSectorsDone += Write; // the final update is delayed until we
                                                       // fill the rest of the FAT with zeros.
    }

    //
    // zero out the rest of the FAT table.
    //

    memset(IoBuffer, 0, 512);

    for(Counter=0; Counter<Fat32AdjustedFatSectorCount-Fat32FatSectorCount; Counter++ ) {
        if(!CmdLineArgs.Test) {
            WriteDisk(DiskHandle,*TargetStart,1,IoBuffer);
        }
        (*TargetStart)++;
    }

    //
    // putting the final update here insures that we are done with zeroing the FAT out.
    //
    if(!CmdLineArgs.Test) {
        UpdateMasterDiskState(DiskHandle,MasterDiskInfo.State);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\misc.c ===
#include "enduser.h"


VOID
UpdateMasterDiskState(
    IN HDISK DiskHandle,
    IN UINT  NewState
    )
{
    MasterDiskInfo.State = NewState;
    memset(IoBuffer,0,512);
    memcpy(IoBuffer,&MasterDiskInfo,sizeof(MASTER_DISK));
    if(!WriteDisk(DiskHandle,1,1,IoBuffer)) {
        FatalError(textWriteFailedAtSector,1,1L);
    }
}


UINT
LocateMasterDisk(
    IN UINT UserSpecifiedInt13Unit OPTIONAL
    )
{
    UINT DiskCount;
    UINT i;
    BYTE Int13Unit;
    BYTE spt;
    USHORT h,cyl;
    ULONG ext;
    BYTE UnitToMatch;

    UnitToMatch = (BYTE)(UserSpecifiedInt13Unit ? UserSpecifiedInt13Unit : 0x80);

    DiskCount = InitializeDiskList();

    for(i=0; i<DiskCount; i++) {

        if(IsMasterDisk(i,IoBuffer)) {
            //
            // Want unit 80h
            //
            if(GetDiskInfoById(i,0,&Int13Unit,&spt,&h,&cyl,&ext)
            && (Int13Unit == UnitToMatch)) {
                return(i);
            }
        }
    }

    FatalError(textCantFindMasterDisk);
}


VOID
FatalError(
    IN FPCHAR FormatString,
    ...
    )
{
    char strng[250];
    va_list arglist;
    unsigned p;

    DispClearClientArea(NULL);

    DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE);

    DispSetCurrentPixelValue(VGAPIX_LIGHT_YELLOW);

    DispWriteString(textFatalError1);
    DispWriteString("\n\n");
    DispWriteString(textFatalError2);

    DispSetCurrentPixelValue(VGAPIX_LIGHT_RED);

    va_start(arglist,FormatString);
    vsprintf(strng,FormatString,arglist);
    va_end(arglist);

    DispWriteString("\n\n");
    DispWriteString(strng);

    //
    // Hanging this way prevents control-c because DOS isn't involved.
    //
    // We allow a special way to get out of this screen and exit
    // the program, for testing.
    //
    strcpy(strng,"I am TEDM");
    p = (unsigned)strng;

    _asm {
        y:
        mov     si,p

        x:
        push    si

        xor     ax,ax                   ; get keystroke
        int     16h

        pop     si

        push    ss
        pop     ds
        cmp     byte ptr [si],0         ; reached and of match string?
        jnz     not0                    ; no, try to match chars
        cmp     al,ASCI_CR              ; see if user hit ENTER
        je      bustout                 ; user entered magic code, exit to DOS
        jne     y                       ; start all over

    not0:
        cmp     [si],al                 ; still on target for magic sequence?
        jne     y                       ; no, start over
        inc     si                      ; yes, set up for next iteration
        jmp     short x

    bustout:

        mov     ax,3
        int     10h
    }

    exit(0);
}


USHORT
GetKey(
    VOID
    )
{
    USHORT c;

    _asm {
        mov ah,0
        int 16h
        mov c,ax
    }

    switch(c) {
    case 0x5000:
        return(DN_KEY_DOWN);
    case 0x4800:
        return(DN_KEY_UP);
    case 0x4200:
        return(DN_KEY_F8);
    default:
        return(c & 0x00ff);
    }
}


VOID
DrainKeyboard(
    VOID
    )
{
    _asm {
        drain:

        mov     ah,1            ; get keyboard status
        int     16h             ; zero flag set = no key waiting
        jz      drained         ; no key waiting, we're done
        mov     ah,0            ; get keypress, we know one is there
        int     16h
        jmp     short drain     ; see if there are more keys waiting

        drained:
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\oschoice.c ===
#include "enduser.h"


UINT
PresentOsMenu(
    IN FPCHAR ImageNames[MAX_PARTITION_IMAGES],
    IN FPCHAR ImageDesc[MAX_PARTITION_IMAGES],
    IN UINT   ImageCount
    );

BOOL
ValidateOsSelection(
    IN FPCHAR Name
    );



VOID
GetUserOsChoice(
    IN HDISK DiskHandle
    )
{
    UINT Selection;
    FPCHAR ImageNames[MAX_PARTITION_IMAGES];
    FPCHAR ImageDesc[MAX_PARTITION_IMAGES];
    UINT Count;
    UINT u;
    int BaseMsg,DescBase;
    FPPARTITION_IMAGE Image;

    //
    // See if we already got the user's selection. If so, don't get it again.
    // If not, get it.
    //
    if(MasterDiskInfo.State >= MDS_GOT_OS_CHOICE) {
        _Log("Already have OS choice (%u), returning\n",MasterDiskInfo.SelectionOrdinal);
        return;
    }

    //
    // Validate image count.
    //
    if(!MasterDiskInfo.ImageCount) {
        FatalError(textNoOsImages);
    }

    //
    // Locate the first message for the OS name overrides in the
    // message file. We assume the messages are contiguous in the table.
    //
    Count = GetTextCount();
    BaseMsg = -1;
    for(u=0; u<Count; u++) {
        if(TextMessages[u].Id == TEXT_OS_NAME_BASE) {
            BaseMsg = u;
        }
        if(TextMessages[u].Id == TEXT_OS_DESC_BASE) {
            DescBase = u;
        }
    }

    //
    // Build the array of names.
    //
    _Log("Reading partition image headers to build os choice menu...\n\n");
    Image = IoBuffer;
    for(u=0; u<MasterDiskInfo.ImageCount; u++) {

        //
        // Read the image's header from the disk.
        //
        if(!ReadDisk(DiskHandle,MasterDiskInfo.ImageStartSector[u],1,IoBuffer)) {
            FatalError(textReadFailedAtSector,1,MasterDiskInfo.ImageStartSector[u]);
        }

        _Log("Image %u --\n",u);
        _Log("   Signature:         0x%lx\n",Image->Signature);
        _Log("   Size:              %u\n",Image->Size);
        _Log("   NonClusterSectors: 0x%lx\n",Image->NonClusterSectors);
        _Log("   ClusterCount:      0x%lx\n",Image->ClusterCount);
        _Log("   TotalSectorCount:  0x%lx\n",Image->TotalSectorCount);
        _Log("   LastUsedCluster:   0x%lx\n",Image->LastUsedCluster);
        _Log("   UsedClusterCount:  0x%lx\n",Image->UsedClusterCount);
        _Log("   BitmapRelocStart:  0x%lx\n",Image->BitmapRelocationStart);
        _Log("   BootRelocStart:    0x%lx\n",Image->BootRelocationStart);
        _Log("   SectorsPerCluster: %u\n",Image->SectorsPerCluster);
        _Log("   SystemId:          %u\n",Image->SystemId);
        _Log("   Flags:             0x%x\n",Image->Flags);
        _Log("\n");

        ImageNames[u] = strdup(*TextMessages[BaseMsg+u].String);
        if(!ImageNames[u]) {
            FatalError(textOOM);
        }
        ImageDesc[u] = strdup(*TextMessages[DescBase+u].String);
        if(!ImageDesc[u]) {
            FatalError(textOOM);
        }
    }

    do {
        Selection = PresentOsMenu(ImageNames,ImageDesc,MasterDiskInfo.ImageCount);
    } while(!ValidateOsSelection(ImageNames[Selection]));

    for(u=0; u<MasterDiskInfo.ImageCount; u++) {
        free(ImageNames[u]);
        free(ImageDesc[u]);
    }

    MasterDiskInfo.SelectionOrdinal = Selection;
    if(!CmdLineArgs.Test) {
        _Log("Updating master disk state for os selection (%u)...\n",Selection);
        UpdateMasterDiskState(DiskHandle,MDS_GOT_OS_CHOICE);
        _Log("Master disk state for os selection has been updated\n");
    }
}


UINT
PresentOsMenu(
    IN FPCHAR ImageNames[MAX_PARTITION_IMAGES],
    IN FPCHAR ImageDesc[MAX_PARTITION_IMAGES],
    IN UINT   ImageCount
    )
{
    UINT u;
    BYTE x,top;
    UINT LongestName,Length;
    char str[80];
    USHORT key;
    UINT Selection;
    int Previous;
    FPVOID SaveArea;
    unsigned SaveBytesPerRow,SaveTop,SaveHeight,DescriptionTop;

    DispClearClientArea(NULL);
    DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE);

    DispWriteString(textSelectOsPrompt);
    DispWriteString("\n\n");

    DispGetCursorPosition(&x,&top);
    top++;                              // top is now first line of menu

    #define OS_LEFT 10
    DispSetLeftMargin(OS_LEFT);

    SaveArea = DispSaveDescriptionArea(&SaveTop,&SaveHeight,&SaveBytesPerRow,&DescriptionTop);

    DrainKeyboard();

    LongestName = 0;
    for(u=0; u<ImageCount; u++) {

        Length = strlen(ImageNames[u]);
        if(Length > LongestName) {
            LongestName = Length;
        }

        DispWriteString("\n ");
        DispWriteString(ImageNames[u]);
    }

    Selection = 0;
    goto highlight;

    while((key = GetKey()) != ASCI_CR) {

        Previous = -1;

        if(key == DN_KEY_UP) {
            if(Selection) {
                 Previous = Selection;
                 Selection--;
            }
        } else {
            if(key == DN_KEY_DOWN) {
                if(Selection < (ImageCount-1)) {
                    Previous = Selection;
                    Selection++;
                }
            }
        }

        if(Previous != -1) {
            //
            // Unhighlight the previous one and erase its description
            //
            memset(str,' ',LongestName+2);
            str[LongestName+2] = 0;
            memcpy(str+1,ImageNames[Previous],strlen(ImageNames[Previous]));

            DispPositionCursor(OS_LEFT,(BYTE)(top+Previous));
            DispWriteString(str);

            //
            // Restore description area
            //
            if(SaveArea) {
                VgaBitBlt(0,SaveTop,640,SaveHeight,SaveBytesPerRow,TRUE,NULL,SaveArea);
            } else {
                VgaClearRegion(0,SaveTop,640,SaveHeight,VGAPIX_BLUE);
            }

            //
            // Highlight the newly selected one
            //
            highlight:
            memset(str,' ',LongestName+2);
            str[LongestName+2] = 0;
            memcpy(str+1,ImageNames[Selection],strlen(ImageNames[Selection]));

            DispPositionCursor(OS_LEFT,(BYTE)(top+Selection));
            DispSetCurrentPixelValue(HIGHLIGHT_TEXT_PIXEL_VALUE);
            DispWriteString(str);

            //
            // Write description
            //
            DispPositionCursor(1,(BYTE)DescriptionTop);
            DispSetLeftMargin(1);
            DispSetCurrentPixelValue(VGAPIX_LIGHT_CYAN);
            DispWriteString(ImageDesc[Selection]);

            //
            // Restore defaults for future text display
            //
            DispSetLeftMargin(OS_LEFT);
            DispSetCurrentPixelValue(DEFAULT_TEXT_PIXEL_VALUE);
        }
    }

    if(SaveArea) {
        free(SaveArea);
    }

    DispSetLeftMargin(TEXT_LEFT_MARGIN);
    return(Selection);
}


BOOL
ValidateOsSelection(
    IN FPCHAR Name
    )
{
    DispClearClientArea(NULL);
    DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE);

    DispWriteString(textConfirmOs1);
    DispWriteString("\n\n\n");
    DispWriteString(Name);
    DispWriteString("\n\n\n");
    DispWriteString(textConfirmOs2);

    DrainKeyboard();

    return(GetKey() == DN_KEY_F8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\enduser.c ===
#include "enduser.h"



/*

    In message files:

    [10000]-[10019] are reserved for language names

    [11000]-[11019] are reserved for OS selection names,
        which override the names specified in the images'
        partition image header structures.

*/


//
// Global data
//
FPVOID IoBuffer,_IoBuffer;
MASTER_DISK MasterDiskInfo;
CMD_LINE_ARGS CmdLineArgs;



VOID
GetUserLanguageChoice(
    IN HDISK DiskHandle
    );

VOID
SwitchMessageFiles(
    IN UINT LanguageOrdinal
    );

VOID
SwitchBitmapAndFont(
    IN UINT LanguageOrdinal
    );



VOID
main(
    IN int   argc,
    IN char *argv[]
    )
{
    HDISK DiskHandle;
    UINT MasterDiskId;

    ParseArgs(argc,argv,FALSE,"DLMTXY",&CmdLineArgs);
    _LogSetFlags(LOGFLAG_CLOSE_REOPEN);

    //
    // Load the initial message file. If this fails something is *really* hosed.
    // Bail out. Note that the bail-out message is in English but there's nothing
    // we can do about it since we haven't been able to load the message file!
    //
    if(!PatchMessagesFromFile("enduser.msg",TextMessages,GetTextCount())) {
        fprintf(stderr,"Setup could not load its message file.\n");
        fprintf(stderr,"Contact your computer's manufacturer.\n");
        return;
    }

    //
    // Load the initial font. If this failes something is *really* hosed.
    // We won't even be able to go into graphics mode, but we will be able
    // to at least tell the user something's wrong using the text from
    // the message file.
    //
    if(!FontLoadAndInit("enduser.fon")) {
        fprintf(stderr,"%s\n\n%s\n\n",textFatalError1,textFatalError2);
        fprintf(stderr,textCantLoadFont,"enduser.fon");
        fprintf(stderr,"\n");
        return;
    }

    //
    // Allocate a maximally-sized track buffer now.
    //
    if(!AllocTrackBuffer(63,&IoBuffer,&_IoBuffer)) {
        _Log("Can't allocate 63-sector I/O buffer\n");
        FatalError(textOOM);
    }

    //
    // Initialize the display package. This clears the screen and
    // tosses up the background and banner bitmaps.
    //
    DispInitialize();

    //
    // Locate and open the master HD. Read the master disk info structure
    // off the disk.
    //
    MasterDiskId = LocateMasterDisk(CmdLineArgs.MasterDiskInt13Unit);
    DiskHandle = OpenDisk(MasterDiskId);
    if(!DiskHandle) {
        FatalError(textCantOpenMasterDisk);
    }
    if(!ReadDisk(DiskHandle,1,1,IoBuffer)) {
        FatalError(textReadFailedAtSector,1,1L);
    }
    memcpy(&MasterDiskInfo,IoBuffer,sizeof(MASTER_DISK));

    _Log("\nInitial master disk info (read from disk sector 1):\n");
    _Log("  Signature                   = 0x%lx\n",MasterDiskInfo.Signature);
    _Log("  Size                        = %u\n",MasterDiskInfo.Size);
    _Log("  State                       = %u\n",MasterDiskInfo.State);
    _Log("  StartupPartitionStartSector = 0x%lx\n",MasterDiskInfo.StartupPartitionStartSector);
    _Log("  ImageCount                  = %u\n",MasterDiskInfo.ImageCount);
    _Log("  SelectedLanguage            = %u\n",MasterDiskInfo.SelectedLanguage);
    _Log("  SelectionOrdinal            = %u\n",MasterDiskInfo.SelectionOrdinal);
    _Log("  ClusterBitmapStart          = 0x%lx\n",MasterDiskInfo.ClusterBitmapStart);
    _Log("  NonClusterSectorsDone       = 0x%lx\n",MasterDiskInfo.NonClusterSectorsDone);
    _Log("  ForwardXferSectorCount      = 0x%lx\n",MasterDiskInfo.ForwardXferSectorCount);
    _Log("  ReverseXferSectorCount      = 0x%lx\n",MasterDiskInfo.ReverseXferSectorCount);
    _Log("  OriginalSectorsPerTrack     = 0x%u\n",MasterDiskInfo.OriginalSectorsPerTrack);
    _Log("  OriginalHeads               = 0x%u\n",MasterDiskInfo.OriginalHeads);
    _Log("\n");

    //
    // Get user's choice of language and change message files and font
    // and banner bitmap.
    //
    GetUserLanguageChoice(DiskHandle);
    SwitchMessageFiles(MasterDiskInfo.SelectedLanguage);
    SwitchBitmapAndFont(MasterDiskInfo.SelectedLanguage);

    //
    // Get user's choice of OSes.
    //
    GetUserOsChoice(DiskHandle);

    //
    // Restore the selected OS.
    //
    RestoreUsersDisk(DiskHandle);

    //
    // Done, reboot.
    //
    DispClearClientArea(NULL);
    DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE+2);
    DispWriteString(textRebootPrompt1);
    DispWriteString("\n\n");
    DispWriteString(textRebootPrompt2);

    _Log("Done.\n");

    while(GetKey() != ASCI_CR) ;

    if(CmdLineArgs.Test) {
        _asm {
            mov ax,3    // standard vga mode
            int 10h
        }
    } else {
        RebootSystem();
    }
}


VOID
GetUserLanguageChoice(
    IN HDISK DiskHandle
    )
{
    UINT Selection = 0;
    int Previous;
    UINT OriginalLangCount;
    UINT Count,i;
    UINT BaseMsg;
    BYTE x,y;
    USHORT c;
    char string[250];

    //
    // See if we already got the user's selection. If so, don't get it again.
    // If not, get it.
    //
    if(!CmdLineArgs.Test && (MasterDiskInfo.State >= MDS_GOT_LANGUAGE)) {
        _Log("Already have language (%u), returning\n",MasterDiskInfo.SelectedLanguage);
        return;
    }

    OriginalLangCount = CmdLineArgs.LanguageCount;
    if(CmdLineArgs.LanguageCount > 1) {

        _Log("Don't already have language, allow user to select 1 of %u languages\n",CmdLineArgs.LanguageCount);

        //
        // Verify that we actually have names for these languages.
        // Otherwise we could end up following null pointers.
        //
        CmdLineArgs.LanguageCount = 0;
        Count = GetTextCount();
        for(i=0; i<Count; i++) {
            if(TextMessages[i].Id == TEXT_LANGUAGE_NAME_BASE) {
                BaseMsg = i;
                while((TextMessages[i].Id <= TEXT_LANGUAGE_NAME_END)
                && TextMessages[i].String
                && *TextMessages[i].String) {

                    CmdLineArgs.LanguageCount++;
                    i++;
                }
                break;
            }
        }

        if(CmdLineArgs.LanguageCount > OriginalLangCount) {
            CmdLineArgs.LanguageCount = OriginalLangCount;
        }
    }

    if(CmdLineArgs.LanguageCount > 1) {

        _Log("Language count validated, user will select 1 of %u languages\n",CmdLineArgs.LanguageCount);

        reselect:

        DrainKeyboard();
        DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE);
        DispWriteString(textSelectLanguage);
        DispWriteString("\n\n");

        DispGetCursorPosition(&x,&y);
        y++;                            // y is coord of top language line

        #define LANG_LEFT 15
        DispSetLeftMargin(LANG_LEFT);

        x = 0;
        for(i=0; i<CmdLineArgs.LanguageCount; i++) {
            DispWriteString("\n ");
            DispWriteString(*TextMessages[BaseMsg+i].String);
            if((Count = strlen(*TextMessages[BaseMsg+i].String)) > x) {
                x = (BYTE)Count;
            }
        }

        goto highlight;

        while((c = GetKey()) != ASCI_CR) {

            Previous = -1;

            if(c == DN_KEY_UP) {
                if(Selection) {
                    Previous = Selection;
                    Selection--;
                }
            } else {
                if(c == DN_KEY_DOWN) {
                    if(Selection < (CmdLineArgs.LanguageCount-1)) {
                        Previous = Selection;
                        Selection++;
                    }
                }
            }

            if(Previous != -1) {

                memset(string,' ',x+2);
                string[x+2] = 0;

                memcpy(
                    string+1,
                    *TextMessages[BaseMsg+Previous].String,
                    strlen(*TextMessages[BaseMsg+Previous].String)
                    );

                DispPositionCursor(LANG_LEFT,(BYTE)(y+Previous));
                DispWriteString(string);

                highlight:

                memset(string,' ',x+2);
                string[x+2] = 0;

                memcpy(
                    string+1,
                    *TextMessages[BaseMsg+Selection].String,
                    strlen(*TextMessages[BaseMsg+Selection].String)
                    );

                DispPositionCursor(LANG_LEFT,(BYTE)(y+Selection));
                DispSetCurrentPixelValue(HIGHLIGHT_TEXT_PIXEL_VALUE);
                DispWriteString(string);
                DispSetCurrentPixelValue(DEFAULT_TEXT_PIXEL_VALUE);
            }
        }

        DispSetLeftMargin(TEXT_LEFT_MARGIN);

        //
        // Now confirm.
        //
        DispClearClientArea(NULL);
        DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE);
        sprintf(string,textConfirmLanguage1,*TextMessages[BaseMsg+Selection].String);
        DispWriteString(string);
        DispWriteString("\n\n");
        DispWriteString(textConfirmLanguage2);
        DrainKeyboard();
        if(GetKey() != ASCI_CR) {
            DispClearClientArea(NULL);
            goto reselect;
        }
         
    } else {
        _Log("Language selection option not invoked\n");
        Selection = 0;
    }

    MasterDiskInfo.SelectedLanguage = Selection;

    if(!CmdLineArgs.Test) {
        _Log("Updating master disk state for language selection (%u)...\n",Selection);
        UpdateMasterDiskState(DiskHandle,MDS_GOT_LANGUAGE);
        _Log("Master disk state for language selection has been updated\n");
    }
}


VOID
SwitchMessageFiles(
    IN UINT LanguageOrdinal
    )

/*++

Routine Description:

    This routine loads a new text message file based on the language
    selected by the user.

    The filename will be <language_ordinal>.msg.

Arguments:

    LanguageOrdinal - supplies the ordinal of the language selected
        by the user, 0-n.

Return Value:

    None.

--*/

{
    char Filename[20];

    sprintf(Filename,"%u.msg",LanguageOrdinal);

    //
    // If this fails, oh, well.
    //
    PatchMessagesFromFile(Filename,TextMessages,GetTextCount());
}


VOID
SwitchBitmapAndFont(
    IN UINT LanguageOrdinal
    )

/*++

Routine Description:

    This routine loads a new font and banner bitmap based on the language
    selected by the user.

    The filenames will be <language_ordinal>.fon and .bmp.

Arguments:

    LanguageOrdinal - supplies the ordinal of the language selected
        by the user, 0-n.

Return Value:

    None.

--*/

{
    char Filename[20];

    //
    // If this fails assume the file doesn't exist and
    // don't worry about it.
    //
    sprintf(Filename,"%u.fon",LanguageOrdinal);
    FontLoadAndInit(Filename);

    //
    // Reinitialize the display to recalc font stuff
    //
    DispReinitialize();

    //
    // Pass a new banner bitmap filename and reinitialize
    // the display area.
    //
    sprintf(Filename,"%u.bmp",LanguageOrdinal);
    DispClearClientArea(Filename);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\gauge.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dngauge.c

Abstract:

    Code implementing a gas gauge for file copies for DOS-hosted NT Setup.

Author:

    Ted Miller (tedm) 14-April-1992

Revision History:

--*/


#include "enduser.h"

#define THERM_WIDTH         500
#define THERM_HEIGHT        18

#define FRAME_THICK         2
#define MARGIN_LEFT         5
#define MARGIN_RIGHT        5
#define MARGIN_TOP          6
#define MARGIN_BOTTOM       (CharHeight+4)

#define FRAME_WIDTH         (THERM_WIDTH+(2*FRAME_THICK)+MARGIN_LEFT+MARGIN_RIGHT)
#define FRAME_HEIGHT        (THERM_HEIGHT+(2*FRAME_THICK)+MARGIN_TOP+MARGIN_BOTTOM)

#define FRAME_X             ((640-FRAME_WIDTH)/2)
#define FRAME_Y             300

#define THERM_X             (FRAME_X + FRAME_THICK + MARGIN_LEFT)
#define THERM_Y             (FRAME_Y + FRAME_THICK + MARGIN_TOP)

#define FRAME_COLOR         VGAPIX_LIGHT_GRAY
#define MARGIN_COLOR        VGAPIX_BLUE
#define THERM_COLOR         VGAPIX_LIGHT_YELLOW


ULONG TickCount;
ULONG TickedSoFar;
unsigned CurrentPercent;
unsigned CurrentThermWidth;

extern BYTE CharWidth;
extern BYTE CharHeight;

VOID
pGaugeDraw(
    VOID
    );


VOID
GaugeInit(
    IN ULONG RangeMax
    )

/*++

Routine Description:

    Initialize the gas gauge.  This includes drawing the gas gauge at 0%
    and setting some global variables.

Arguments:

    RangeMax - supplies maximum tick count that 100% represents.

Return Value:

    None.

--*/

{
    TickCount = RangeMax;
    TickedSoFar = 0;
    CurrentPercent = 0;
    CurrentThermWidth = 0;

    pGaugeDraw();
}


VOID
DnpRepaintGaugeTherm(
    IN BOOL ForceRepaint
    )

/*++

Routine Description:

    Draw the entire gauge in its current state.

Arguments:

    ForceRepaint - if TRUE, the gauge is redrawn even if the percentage
        hasn't changed since the last time the gauge was redrawn.

Return Value:

    None.

--*/

{
    unsigned PercentComplete;
    unsigned Width;
    char text[10];

    if(!TickCount) {
        return;
    }

    //
    // Figure out the percent complete and how many pixels
    // of width the current tick count represents on-screen.
    //
    PercentComplete = (unsigned)(100L * TickedSoFar / TickCount);
    Width = (unsigned)(THERM_WIDTH * TickedSoFar / TickCount);

    if(ForceRepaint || (Width != CurrentThermWidth)) {

        CurrentThermWidth = Width;

        VgaClearRegion(THERM_X,THERM_Y,Width,THERM_HEIGHT,THERM_COLOR);

        if(ForceRepaint || (CurrentPercent != PercentComplete)) {

            CurrentPercent = PercentComplete;

            Width = sprintf(text,"%u%%",CurrentPercent);

            FontWriteString(
                text,
                (640-(CharWidth*Width))/2,
                THERM_Y + THERM_HEIGHT + ((MARGIN_BOTTOM-CharHeight)/2) + 1,
                VGAPIX_LIGHT_GRAY,
                VGAPIX_BLUE
                );
        }
    }
}


VOID
GaugeDelta(
    IN ULONG Delta
    )

/*++

Routine Description:

    'Tick' the gas gauge by adding a given delta to the progress so far.
    Adjust the thermometer and percent-complete readouts.

Arguments:

    Delta - supplies additional progress units.

Return Value:

    None.

--*/

{
    TickedSoFar += Delta;
    if(TickedSoFar > TickCount) {
        TickedSoFar = TickCount;
    }
    DnpRepaintGaugeTherm(FALSE);
}


VOID
pGaugeDraw(
    VOID
    )

/*++

Routine Description:

    Redraw the gas gauge in its current state.

Arguments:

    None.

Return Value:

    None.

--*/


{
    VgaClearRegion(FRAME_X,FRAME_Y,FRAME_WIDTH,FRAME_HEIGHT,FRAME_COLOR);

    VgaClearRegion(
        FRAME_X + FRAME_THICK,
        FRAME_Y + FRAME_THICK,
        FRAME_WIDTH - (2*FRAME_THICK),
        FRAME_HEIGHT - (2*FRAME_THICK),
        MARGIN_COLOR
        );

    DnpRepaintGaugeTherm(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\io.c ===
#include "enduser.h"


ULONG XmsEntry;
unsigned XmsHandle;
unsigned XmsMaxSectors;

#pragma pack(1)
struct {
    ULONG Count;
    USHORT SourceHandle;
    ULONG SourceOffset;
    USHORT DestinationHandle;
    ULONG DestinationOffset;
} XmsParams;
#pragma pack()


VOID
XmsInit(
    VOID
    )

/*++

Routine Description:

    Initiialize the XMS i/o package by checking to see
    if XMS memory is available and if so, grabbing the largest block
    we can.

Arguments:

    None.

Return Value:

    None.

--*/

{
    unsigned e_s=0,e_o=0;
    ULONG Entry;
    unsigned LargestBlock;
    unsigned Handle;
    BOOL b;

    //
    // Check XMS installed
    //
    _asm {
        mov     ax,4300h
        int     2fh
        cmp     al,80h
        jne     xmschecked
        mov     ax,4310h
        int     2fh
        mov     e_o,bx
        mov     bx,es
        mov     e_s,bx
        xmschecked:
    }

    if(!e_s && !e_o) {
        FatalError(textNoXmsManager);
    }

    Entry = ((ULONG)e_s << 16) | e_o;

    //
    // Get size of largest block and make sure it's
    // large enough to make use of XMS worthwhile.
    // IoBuffer is 63*512 sectors, which is just under 32K.
    // So we want at least 32K. Also trim the block size
    // so the sector count will fit in a ushort.
    //
    _asm {
        mov     ah,8
        call    far ptr [Entry]
        mov     LargestBlock,ax
    }

    if(LargestBlock < 32) {
        FatalError(textNoXmsManager);
    }
    if(LargestBlock > 32767) {
        LargestBlock = 32767;
    }

    //
    // Allocate the block.
    //
    _asm {
        mov     ah,9
        mov     dx,LargestBlock
        call    far ptr [Entry]
        mov     Handle,dx
        mov     b,ax
    }

    if(!b) {
        FatalError(textNoXmsManager);
    }

    XmsEntry = Entry;
    XmsHandle = Handle;
    XmsMaxSectors = LargestBlock * 2 - 128;     // actually it's * 1024/512
                                                // make it 64K smaller just in case.
}


VOID
XmsTerminate(
    VOID
    )

/*++

Routine Description:

    Terminate XMS i/o by releasing any allocated block.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Entry;
    int Handle;

    if(XmsEntry && XmsMaxSectors) {

        Entry = XmsEntry;
        Handle = XmsHandle;

        _asm {
            mov     ah,0ah
            mov     dx,Handle
            call    far ptr [Entry]
        }

        XmsEntry = 0;
        XmsHandle = 0;
        XmsMaxSectors = 0;
    }
}


VOID
XmsIoDiskRead(
    IN  HDISK  DiskHandle,
    IN  ULONG  StartSector,
    IN  ULONG  SectorCount,
    OUT ULONG *SectorsRead,
    OUT BOOL  *Xms
    )

/*++

Routine Description:

    Read sectors from a disk.

    If the sector count is less then 64 or XMS is not available,
    then a maximum of 63 sectors will be read into the buffer
    pointed to by the IoBuffer global variable.

    If the sector count is greater than 63 and XMS is available,
    then as many sectors as will fit into our XMS buffer are
    read and buffered in XMS memory, using IoBuffer as the
    intermediary transfer buffer.

    Every read deltas the gas gauge by the number of sectors
    transferred.

Arguments:

    DiskHandle - supplies disk handle of disk to be read from.

    StartSector - supplies first sector of read run.

    SectorCount - supplies the number of sectors the caller
        wants to read.

    SectorsRead - receives the number of sectors read, which is
        the minimum of the number of sectors the caller actually
        wants, and either 63 (non-xms case) or XmsSectors (xms case).

    Xms - recieves a value indicating whether the sectors were read
        and buffered in Xms memory. The caller may need to know this
        when he goes to write the data later.

Return Value:

    None. Does not return if error.

--*/

{
    BYTE c;
    BOOL b;
    BYTE code;
    ULONG Entry;
    unsigned x_s,x_o;

    if((SectorCount <= 63) || !XmsMaxSectors) {
        //
        // Conventional memory only. I/O to IoBuffer.
        //
        *Xms = FALSE;
        if(SectorCount > 63) {
            SectorCount = 63;
        }

        if(!ReadDisk(DiskHandle,StartSector,(BYTE)SectorCount,IoBuffer)) {
            FatalError(textReadFailedAtSector,(UINT)SectorCount,StartSector);
        }

        *SectorsRead = SectorCount;
        GaugeDelta(SectorCount);
        return;
    }

    //
    // XMS read.
    //
    *Xms = TRUE;
    if(SectorCount > XmsMaxSectors) {
        SectorCount = XmsMaxSectors;
    }
    *SectorsRead = SectorCount;

    XmsParams.SourceHandle = 0;
    XmsParams.SourceOffset = (ULONG)IoBuffer;
    XmsParams.DestinationHandle = XmsHandle;
    XmsParams.DestinationOffset = 0;

    Entry = XmsEntry;
    x_s = (unsigned)((ULONG)(void _far *)&XmsParams >> 16);
    x_o = (unsigned)(ULONG)&XmsParams;

    while(SectorCount) {

        c = (BYTE)((SectorCount > 63L) ? 63L : SectorCount);

        if(!ReadDisk(DiskHandle,StartSector,c,IoBuffer)) {
            FatalError(textReadFailedAtSector,c,StartSector);
        }

        XmsParams.Count = c * 512L;

        _asm {
            push    ds
            push    si
            push    x_s
            pop     ds
            mov     si,x_o
            mov     ah,0bh
            call    far ptr [Entry]
            mov     b,ax
            mov     code,bl
            pop     si
            pop     ds
        }

        if(!b) {
            FatalError(textXmsMemoryError,code);
        }

        XmsParams.DestinationOffset += XmsParams.Count;
        StartSector += c;
        SectorCount -= c;
        GaugeDelta(c);
    }
}


VOID
XmsIoDiskWrite(
    IN HDISK  DiskHandle,
    IN ULONG  StartSector,
    IN ULONG  SectorOffset,
    IN ULONG  SectorCount,
    IN BOOL   Xms
    )

/*++

Routine Description:

    Write sectors to a disk.

    Sectors are written either from IoBuffer or from XMS memory
    (using IoBuffer as the intermediary transfer buffer) as the caller
    specifies.

    Every write deltas the gas gauge by the number of sectors
    transferred.

Arguments:

    DiskHandle - supplies disk handle of disk to write to.

    StartSector - supplies first sector of write run.

    SectorOffset - supplies the number of sectors to skip/ignore at
        the start of the i/o buffer (either IoBuffer or XMS memory).
        This allows the caller to write out a previously read run
        in chunks.

    SectorCount - supplies the number of sectors to write.

    Xms - supplies a value indicating whether the data to be written
        is in Xms memory. If not, it's in IoBuffer.

Return Value:

    None. Does not return if error.

--*/

{
    BYTE c;
    BYTE i;
    BOOL b;
    BYTE code;
    ULONG Entry;
    unsigned x_s,x_o;

    if(!Xms) {
        //
        // Conventional memory only. I/O from IoBuffer.
        // SectorCount had better be <= 63!
        //
        if(!CmdLineArgs.Test) {
            i=0;
            while(i<3) {
                //
                // Retry a couple times. (My machine seems to randomly fail a write once in a while.)
                //
                if(WriteDisk(DiskHandle,
                             StartSector,
                             (BYTE)SectorCount,
                             (FPBYTE)IoBuffer+((unsigned)SectorOffset*512))
                   ) {
                    if(i>0) {
                        _Log("  *** Write succeeded retried %d times.\n", i );
                    }
                    break;
                }
                _Log("  *** Write error at sector %ld length %d attempt %d\n", StartSector,SectorCount, i );
                i++;
            }
            if(i==3) { 
                FatalError(textWriteFailedAtSector,(UINT)SectorCount,StartSector);
            }
        }
        GaugeDelta(SectorCount);
        return;
    }

    //
    // XMS write. SectorCount had better be <= XmsMaxSectors!
    //
    XmsParams.SourceHandle = XmsHandle;
    XmsParams.SourceOffset = 512 * SectorOffset;
    XmsParams.DestinationHandle = 0;
    XmsParams.DestinationOffset = (ULONG)IoBuffer;

    Entry = XmsEntry;
    x_s = (unsigned)((ULONG)(void _far *)&XmsParams >> 16);
    x_o = (unsigned)(ULONG)&XmsParams;

    while(SectorCount) {

        c = (BYTE)((SectorCount > 63L) ? 63L : SectorCount);

        XmsParams.Count = c * 512L;

        _asm {
            push    ds
            push    si
            push    x_s
            pop     ds
            mov     si,x_o
            mov     ah,0bh
            call    far ptr [Entry]
            mov     b,ax
            mov     code,bl
            pop     si
            pop     ds
        }

        if(!b) {
            FatalError(textXmsMemoryError,code);
        }

        if(!CmdLineArgs.Test) {
            i=0;
            while(i<3) {
                //
                // Retry a couple times. (My machine seems to randomly fail a write once in a while.)
                //
                if(WriteDisk(DiskHandle,StartSector,c,IoBuffer)) {
                    if(i>0) {
                        _Log("  *** Write succeeded retried %d times.\n", i );
                    }
                    break;
                }
                _Log("  *** Write error at sector %ld length %d attempt %d\n", StartSector, c, i );
                i++;
            }
            if(i==3) {
                FatalError(textWriteFailedAtSector,c,StartSector);
            }
        }

        XmsParams.SourceOffset += XmsParams.Count;
        StartSector += c;
        SectorCount -= c;
        GaugeDelta(c);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\enduser.h ===
#include <mytypes.h>
#include <misclib.h>
#include <diskio.h>
#include <partimag.h>
#include <msgfile.h>
#include <displib.h>
#include <partio.h>

#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <ctype.h>
#include <errno.h>
#include <dos.h>
#include <share.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

//
// Global data
//
extern FPVOID IoBuffer,_IoBuffer;
extern MASTER_DISK MasterDiskInfo;
extern CMD_LINE_ARGS CmdLineArgs;
extern PARTITION_IMAGE PartitionImage;

//
// Text
//
extern MESSAGE_STRING TextMessages[];

unsigned
GetTextCount(
    VOID
    );

extern char *textCantLoadFont;
extern char *textNoXmsManager;
extern char *textXmsMemoryError;
extern char *textFatalError1;
extern char *textFatalError2;
extern char *textReadFailedAtSector;
extern char *textWriteFailedAtSector;
extern char *textCantFindMasterDisk;
extern char *textOOM;
extern char *textCantOpenMasterDisk;
extern char *textCantFindMPKBoot;
extern char *textNoOsImages;
extern char *textSelectLanguage;
extern char *textConfirmLanguage1;
extern char *textConfirmLanguage2;
extern char *textRebootPrompt1;
extern char *textRebootPrompt2;
extern char *textSelectOsPrompt;
extern char *textConfirmOs1;
extern char *textConfirmOs2;
extern char *textPleaseWaitRestoring;
extern char *textValidatingImage;
extern char *textChecksumFail;
extern char *textChecksumOk;

//
// [10000]-[10009] are reserved for language names
// [11000]-[11009] are reserved for OS selection names,
//      which override the names specified in the images'
//      partition image header structures.
//
#define TEXT_LANGUAGE_NAME_BASE 10000
extern char *textLangName0;
extern char *textLangName1;
extern char *textLangName2;
extern char *textLangName3;
extern char *textLangName4;
extern char *textLangName5;
extern char *textLangName6;
extern char *textLangName7;
extern char *textLangName8;
extern char *textLangName9;
#define TEXT_LANGUAGE_NAME_END 10009


#define TEXT_OS_NAME_BASE 11000
extern char *textOsName0;
extern char *textOsName1;
extern char *textOsName2;
extern char *textOsName3;
extern char *textOsName4;
extern char *textOsName5;
extern char *textOsName6;
extern char *textOsName7;
extern char *textOsName8;
extern char *textOsName9;
#define TEXT_OS_NAME_END 11009

#define TEXT_OS_DESC_BASE 12000
extern char *textOsDesc0;
extern char *textOsDesc1;
extern char *textOsDesc2;
extern char *textOsDesc3;
extern char *textOsDesc4;
extern char *textOsDesc5;
extern char *textOsDesc6;
extern char *textOsDesc7;
extern char *textOsDesc8;
extern char *textOsDesc9;
#define TEXT_OS_DESC_END 12009

//
// Text positioning stuff
//
#define TEXT_LEFT_MARGIN     3
#define TEXT_TOP_LINE        0

//
// Constant that gives the number of clusters described in
// one sector of the cluster bitmap (sector size * bits per byte)
//
#define CLUSTER_BITS_PER_SECTOR     4096

//
// Top-level routine for restoring the user's disk.
//
VOID
RestoreUsersDisk(
    IN HDISK DiskHandle
    );

VOID
ExpandImage(
    IN HDISK DiskHandle,
    IN BYTE  SectorsPerTrack,
    IN ULONG SourceStart,
    IN ULONG TargetStart
    );

//
// Misc routines
//
VOID
UpdateMasterDiskState(
    IN HDISK DiskHandle,
    IN UINT  NewState
    );

UINT
LocateMasterDisk(
    IN UINT UserSpecifiedInt13Unit OPTIONAL
    );

VOID
GetUserOsChoice(
    IN HDISK DiskHandle
    );

VOID
FatalError(
    IN FPCHAR FormatString,
    ...
    );

//
// Keyboard reading stuff
//
USHORT
GetKey(
    VOID
    );

#define DN_KEY_DOWN     0x0100
#define DN_KEY_UP       0x0200
#define DN_KEY_F8       0x1800
#define ASCI_CR         13
#define ASCI_ESC        27

VOID
DrainKeyboard(
    VOID
    );


//
// Display routines
//
#define DEFAULT_TEXT_PIXEL_VALUE    VGAPIX_LIGHT_GRAY
#define HIGHLIGHT_TEXT_PIXEL_VALUE  VGAPIX_WHITE

VOID
DispInitialize(
    VOID
    );

VOID
DispReinitialize(
    VOID
    );

VOID
DispClearClientArea(
    IN FPCHAR NewBannerBitmap OPTIONAL
    );

VOID
DispSetCurrentPixelValue(
    IN BYTE PixelValue
    );

VOID
DispPositionCursor(
    IN BYTE X,
    IN BYTE Y
    );

VOID
DispGetCursorPosition(
    OUT FPBYTE X,
    OUT FPBYTE Y
    );

FPVOID
DispSaveDescriptionArea(
    OUT USHORT *SaveTop,
    OUT USHORT *SaveHeight,
    OUT USHORT *SaveBytesPerRow,
    OUT USHORT *DescriptionTop
    );

VOID
DispWriteChar(
    IN CHAR chr
    );

VOID
DispWriteString(
    IN FPCHAR String
    );

VOID
DispSetLeftMargin(
    IN BYTE X
    );

//
// Gas gauge routines
//
VOID
GaugeInit(
    IN ULONG RangeMax
    );

VOID
GaugeDelta(
    IN ULONG Delta
    );

//
// XMS i/o routines
//
VOID
XmsInit(
    VOID
    );

VOID
XmsTerminate(
    VOID
    );

VOID
XmsIoDiskRead(
    IN  HDISK  DiskHandle,
    IN  ULONG  StartSector,
    IN  ULONG  SectorCount,
    OUT ULONG *SectorsRead,
    OUT BOOL  *Xms
    );

VOID
XmsIoDiskWrite(
    IN HDISK  DiskHandle,
    IN ULONG  StartSector,
    IN ULONG  SectorOffset,
    IN ULONG  SectorCount,
    IN BOOL   Xms
    );

#if 0
//
// Inf routines
//
int
LoadInf(
    IN  FPCHAR  Filename,
    OUT FPVOID *Handle,
    OUT FPUINT  ErrorLineNumber
    );

VOID
UnloadInf(
    IN FPVOID Handle
    );

BOOL
InfSectionExists(
    IN FPVOID Handle,
    IN FPCHAR SectionName
    );

FPCHAR
InfGetSectionLineIndex(
    IN FPVOID   Handle,
    IN FPCHAR   SectionName,
    IN unsigned LineIndex,
    IN unsigned ValueIndex
    );

FPCHAR
InfGetSectionKeyIndex(
    IN FPVOID   Handle,
    IN FPCHAR   SectionName,
    IN FPCHAR   Key,
    IN unsigned ValueIndex
    );

FPCHAR
InfGetSectionLineKey(
    IN FPVOID   Handle,
    IN FPCHAR   SectionName,
    IN unsigned LineIndex
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\imagpart\imagpart.c ===
#include "imagpart.h"

#include <malloc.h>


typedef struct _HANDLES {
    HPARTITION SourcePartitionHandle;
    UINT OutputFileHandle,BitmapFileHandle;
} HANDLES, *PHANDLES;

//
// Global data
//
CMD_LINE_ARGS CmdLineArgs;
FPVOID IoBuffer,OriginalIoBuffer;
char OutputFilename[256];
char BitmapFilename[256];
ULONG CheckSum;
ULONG BytesCRC;

//
// Text for the program
//
char *textNoPartitions;
char *textSourcePrompt;
char *textTransferringFsStructs;
char *textPartOpenError;
char *textFileReadFailed;
char *textTransferringClusters;
char *textCombiningFiles;
char *textReadFailedAtSector;
char *textOOM;
char *textDone;
char *textFileWriteError;
char *textCantCreateNewFile;
char *textSelectOutput;
char *textDisk;
char *textPaddedMbCount;
char *textInvalidSelection;
char *textUsage;
char *textCantCreateFile;
char *textScanningFat;
char *textNtfsUnsupportedConfig;
char *textNtfsCorrupt;
char *textInitNtfsDataStruct;
char *textNtfsBuildingBitmap;
char *textProcessingNtfsBitmap;
char *textUnsupportedFs;
char *textChecksum;
char *textBytesProcessed;

MESSAGE_STRING TextMessages[] = { { &textNoPartitions,1           },
                                  { &textSourcePrompt,2           },
                                  { &textTransferringFsStructs,3  },
                                  { &textPartOpenError,4          },
                                  { &textFileReadFailed,5         },
                                  { &textTransferringClusters,6   },
                                  { &textCombiningFiles,7         },
                                  { &textReadFailedAtSector,8     },
                                  { &textOOM,9                    },
                                  { &textDone,11                  },
                                  { &textFileWriteError,12        },
                                  { &textCantCreateNewFile,17     },
                                  { &textSelectOutput,18          },
                                  { &textDisk,20                  },
                                  { &textPaddedMbCount,21         },
                                  { &textInvalidSelection,22      },
                                  { &textUsage,25                 },
                                  { &textCantCreateFile,26        },
                                  { &textScanningFat,27           },
                                  { &textNtfsUnsupportedConfig,29 },
                                  { &textNtfsCorrupt,30           },
                                  { &textInitNtfsDataStruct,31    },
                                  { &textNtfsBuildingBitmap,32    },
                                  { &textProcessingNtfsBitmap,33  },
                                  { &textUnsupportedFs,34         },
                                  { &textChecksum,35              },
                                  { &textBytesProcessed,36        }
                                };


BOOL
DoIt(
    IN PHANDLES Handles
    );

BOOL
DetermineAndOpenSource(
    IN  UINT        PartitionCount,
    OUT HPARTITION *SourcePartitionHandle
    );

BOOL
DetermineAndCreateOutput(
    OUT UINT *OutputFileHandle,
    OUT UINT *BitmapFileHandle
    );

BOOL
DetermineFsAndInitVolumeData(
    IN  HPARTITION        PartitionHandle,
    OUT FilesystemType   *FsType,
    OUT PPARTITION_IMAGE  PartitionImage
    );

BOOL
TransferFsStructsToOutput(
    IN HPARTITION PartitionHandle,
    IN UINT       FileHandle,
    IN ULONG      SectorCount
    );

BOOL
TransferUsedClustersToOutput(
    IN HANDLES         *Handles,
    IN PARTITION_IMAGE *PartitionImage
    );

BOOL
AppendClusterMapToOutput(
    IN HANDLES         *Handles,
    IN PARTITION_IMAGE *PartitionImage
    );



int
main(
    IN int   argc,
    IN char *argv[]
    )
{
    UINT PartCount;
    BOOL b;
    HANDLES Handles;

    if(!GetTextForProgram(argv[0],TextMessages,sizeof(TextMessages)/sizeof(TextMessages[0]))) {
        fprintf(stderr,"Unable to find messages for program\n");
        return(FAILURE);
    }

    if(!ParseArgs(argc,argv,TRUE,"DIQTXY",&CmdLineArgs)) {
        fprintf(stderr,textUsage);
        fprintf(stderr,"\n");
        return(FAILURE);
    }
    _Log("Begin imagpart\n");
    //
    // Allocate a maximally sized i/o buffer right up front.
    //
    _Log("Allocating Track Buffer.\n");
    if(!AllocTrackBuffer(63,&IoBuffer,&OriginalIoBuffer)) {
        fprintf(stderr,"%s\n",textOOM);
        b = FALSE;
        goto c0;
    }

    _Log("Scanning partition tables...\n");
    PartCount = InitializePartitionList();
    if(!PartCount) {
        fprintf(stderr,"%s\n",textNoPartitions);
        b = FALSE;
        goto c1;
    }

    //
    // Get the source partition and target filename.
    // The source partition is opened and the target filename is created.
    //
    _Log("Determining target partition...\n");
    b = DetermineAndOpenSource(PartCount,&Handles.SourcePartitionHandle);
    if(!b) {
        goto c1;
    }

    printf("\n\n");

    _Log("Determining output file...\n");
    b = DetermineAndCreateOutput(&Handles.OutputFileHandle,&Handles.BitmapFileHandle);
    if(!b) {
        goto c2;
    }    

    CheckSum = CRC32_INITIAL_VALUE;
    BytesCRC = 0;

    _Log("Starting image transfer...\n");
    b = DoIt(&Handles);

    printf(textChecksum, OutputFilename, CheckSum);
    printf("\n");
    printf(textBytesProcessed, BytesCRC);

    _dos_close(Handles.OutputFileHandle);
    _dos_close(Handles.BitmapFileHandle);
    FlushDisks();
    if(!CmdLineArgs.Test) {
        unlink(BitmapFilename);
        if(!b) {
            unlink(OutputFilename);
        }
    }
c2:
    ClosePartition(Handles.SourcePartitionHandle);
c1:
    free(OriginalIoBuffer);
c0:
    if(b) {
        printf("\n%s\n",textDone);
    }
    _Log("Done.\n");

    return(b ? SUCCESS : FAILURE);
}


BOOL
DetermineAndOpenSource(
    IN  UINT        PartitionCount,
    OUT HPARTITION *SourcePartitionHandle
    )

/*++

Routine Description:

    This routine prompts the user to select a partition to be imaged,
    from the list of all partitions that are visible on all drives.
    The selected partition is opened for the caller.

Arguments:

    PartitionCount - supplies the number of partitions on all drives,
        as returned by InitializePartitionList().

    SourcePartitionHandle - in the success case, receives the handle
        to the selected partition.

Return Value:

    Boolean value indicating outcome. If false, a message will have been
    printed explaining why.

--*/

{
    UINT Selection;

    if(CmdLineArgs.Quiet) {
        Selection = 0;
    } else {
        Selection = SelectPartition(
                        PartitionCount,
                        textSourcePrompt,
                        NULL,
                        textDisk,
                        textPaddedMbCount,
                        textInvalidSelection
                        );
    }

    *SourcePartitionHandle = OpenPartition(Selection);
    if(!(*SourcePartitionHandle)) {
        fprintf(stderr,"%s\n",textPartOpenError);
        return(FALSE);
    }
    _Log("Partition opened sucessfully.\n");
    return(TRUE);
}


BOOL
DetermineAndCreateOutput(
    OUT UINT *OutputFileHandle,
    OUT UINT *BitmapFileHandle
    )

/*++

Routine Description:

    This routine prompts the user to enter a filename that will contain
    the output partition image. The file is created (it must not already
    exist). In addition a temporary file named $CLUSMAP.TMP will be
    created in the same directory. Any file with that name is overwritten.

Arguments:

    OutputFileHandle - in the success case, receives a handle
        to the created output file, which will be 0-length.

    BitmapFileHandle - in the success case, receives a handle to the
        created $CLUMAP.TMP file, which will be 0-length.

Return Value:

    Boolean value indicating outcome. If false, a message will have been
    printed explaining why.

--*/

{
    char *p;

    if(CmdLineArgs.ImageFile) {
        printf("%s %s\n",textSelectOutput,CmdLineArgs.ImageFile);
        strcpy(OutputFilename,CmdLineArgs.ImageFile);
        goto gotit;
    }

    //
    // Prompt the user for a filename.
    //
    prompt:
    printf("%s ",textSelectOutput);
    gets(OutputFilename);

    //
    // Attempt to create the file
    //
    gotit:
    if(_dos_creatnew(OutputFilename,_A_NORMAL,OutputFileHandle)) {
        fprintf(stderr,"\n");
        fprintf(stderr,textCantCreateNewFile,OutputFilename);
        fprintf(stderr,"\n");
        goto prompt;
    }
    _Log("Output file name is %s\n",OutputFilename);
    _Log("Successfully created output file.\n");

    //
    // Form the name of the temp file for the cluster bitmap
    //
    strcpy(BitmapFilename,OutputFilename);
    if(p = strrchr(BitmapFilename,'\\')) {
        p++;
    } else {
        if(BitmapFilename[1] == ':') {
            p = BitmapFilename+2;
        } else {
            p = BitmapFilename;
        }
    }
    strcpy(p,"$CLUSMAP.TMP");

    if(_dos_creat(BitmapFilename,_A_NORMAL,BitmapFileHandle)) {
        _dos_close(*OutputFileHandle);
        unlink(OutputFilename);
        fprintf(stderr,"\n");
        fprintf(stderr,textCantCreateFile,BitmapFilename);
        fprintf(stderr,"\n");
        _Log("FAILED creating temporary cluster bitmap file.\n");
        return(FALSE);
    }
    _Log("Successfully created temporary cluster bitmap file.\n");
    return(TRUE);
}


BOOL
DoIt(
    IN PHANDLES Handles
    )
{
    FilesystemType FsType;
    PARTITION_IMAGE PartitionImage;
    BOOL b;
    UINT Written;
    UINT Read;

    memset(&PartitionImage,0,sizeof(PARTITION_IMAGE));
    PartitionImage.Signature = PARTITION_IMAGE_SIGNATURE;
    PartitionImage.Size = sizeof(PARTITION_IMAGE);

    //
    // Determine file system and initialize various data about the volume.
    //
    _Log("Determining Filesystem and Volume Data...\n");
    if(!DetermineFsAndInitVolumeData(Handles->SourcePartitionHandle,&FsType,&PartitionImage)) {
        return(FALSE);
    }

    //
    // Build the cluster bitmap. One bit per cluster, 0=unused, 1=used.
    // The cluster bitmap goes into a temporary file, since we'll need
    // to append it to the actual data later.
    //
    _Log("Building cluster bitmap...\n");
    b = BuildClusterBitmap(
            FsType,
            Handles->SourcePartitionHandle,
            Handles->BitmapFileHandle,
            &PartitionImage
            );

    if(!b) {
        return(FALSE);
    }

    //
    // Write the partition image header into the output file.
    //
    _Log("Initializing image header...\n");
    memset(IoBuffer,0,512);
    memmove(IoBuffer,&PartitionImage,sizeof(PARTITION_IMAGE));
    if(_dos_write(Handles->OutputFileHandle,IoBuffer,512,&Written) || (Written != 512)) {
        fprintf(stderr,"\n%s\n",textFileWriteError);
        _Log("Error: Failed writing image header!\n");
        return(FALSE);
    }

    //
    // the CRC checking code in the other modules assumes the following is true
    // when the CRC stored in the image file was computed: 
    //
    //    ((PPARTITION_IMAGE)IoBuffer)->BitmapRelocationStart = 0;
    //    ((PPARTITION_IMAGE)IoBuffer)->BootRelocationStart = 0;
    //    ((PPARTITION_IMAGE)IoBuffer)->Flags = 0;
    //

    CheckSum = CRC32Compute( IoBuffer, 512, CheckSum);
    BytesCRC += 512;

    //
    // Transfer the file system reserved area into the output file.
    //
    _Log("Transferring fs reserved areas to image file...\n");
    b = TransferFsStructsToOutput(
            Handles->SourcePartitionHandle,
            Handles->OutputFileHandle,
            PartitionImage.NonClusterSectors
            );

    if(!b) {
        _Log("Error: Failed writing fs reserved areas to image file!\n");
        return(FALSE);
    }

    //
    // Transfer the used clusters into the output file.
    //
    _Log("Transferring used clusters to image file...\n");
    b = TransferUsedClustersToOutput(Handles,&PartitionImage);
    if(!b) {
        _Log("Error: Failed transferring used clusters to image file...\n");
        return(FALSE);
    }

    //
    // Append the cluster map to the output file.
    //
    _Log("Transferring cluster map to image file...\n");
    b = AppendClusterMapToOutput(Handles,&PartitionImage);
    if(!b) {
        _Log("Error: FAILED transferring cluster map to image file...\n");
        return(FALSE);
    }

    //
    // Set the checksum.
    //

    memset(IoBuffer,0,512);

    // seek to the start of the file
    if(DosSeek(Handles->OutputFileHandle,0,DOSSEEK_START) != 0) {
        fprintf(stderr,"\n%s\n",textFileWriteError);
        return(FALSE);
    }
    // read the header in
    if(_dos_read(Handles->OutputFileHandle,IoBuffer,512,&Read) || (Read != 512 )) {
        fprintf(stderr,"\n%s\n",textFileWriteError);
        return(FALSE);
    }
       
    ((PPARTITION_IMAGE)IoBuffer)->CRC = CheckSum;
    _Log("Image file (%s) checksum = 0x%08lx\n", OutputFilename, CheckSum);
    _Log("Total bytes processed = 0x%08lx\n",BytesCRC);

    // seek to the start of the file
    if(DosSeek(Handles->OutputFileHandle,0,DOSSEEK_START) != 0) {
        fprintf(stderr,"\n%s\n",textFileWriteError);
        _Log("Error: Failed writing image CRC!\n");        
        return(FALSE);
    }
    // write out the modified image header with the CRC
    if(_dos_write(Handles->OutputFileHandle,IoBuffer,512,&Written) || (Written != 512)) {
        fprintf(stderr,"\n%s\n",textFileWriteError);
        _Log("Error: Failed writing image CRC!\n");        
        return(FALSE);
    }

    return b;
}


BOOL
DetermineFsAndInitVolumeData(
    IN  HPARTITION        PartitionHandle,
    OUT FilesystemType   *FsType,
    OUT PPARTITION_IMAGE  PartitionImage
    )

/*++

Routine Description:

    This routine determines the file system on the source partition
    (fat, ntfs, or other) and initializes sector and cluster count
    values in a PARTITION_IMAGE structure based on the volume's
    characteristics.

Arguments:

    PartitionHandle - supplies handle to the source partition

    FsType - receives the file system type.

    PartitionImage - receives volume-related sector and cluster counts.
        The following members are filled in:

            TotalSectorCount
            NonClusterSectors
            ClusterCount
            SectorsPerCluster
            SystemId

Return Value:

    Boolean value indicating outcome. If false, a message will have been
    printed out explaining why.

--*/

{
    BOOL b;
    UINT DiskId;
    ULONG dontcare;

    if(FatIsFat(PartitionHandle)) {
        *FsType = FilesystemFat;
        _Log("    The partition is FAT...\n");
        b = FatInitializeVolumeData(
                PartitionHandle,
                &PartitionImage->TotalSectorCount,
                &PartitionImage->NonClusterSectors,
                &PartitionImage->ClusterCount,
                &PartitionImage->SectorsPerCluster
                );

    } else {
        if(NtfsIsNtfs(PartitionHandle)) {
            *FsType = FilesystemNtfs;
            _Log("    The partition is NTFS...\n");
            b = NtfsInitializeVolumeData(
                    PartitionHandle,
                    &PartitionImage->TotalSectorCount,
                    &PartitionImage->NonClusterSectors,
                    &PartitionImage->ClusterCount,
                    &PartitionImage->SectorsPerCluster
                    );
        } else {
            fprintf(stderr,"\n%s\n",textUnsupportedFs);
            _Log("Error: The partition type is unknown!\n");
            b = FALSE;
        }
    }

    if(b) {
        //
        // Get the system id byte
        //
        b = GetPartitionInfoByHandle(
                PartitionHandle,
                &DiskId,
                &PartitionImage->SystemId,
                &dontcare,
                &dontcare
                );

        if(!b) {
            fprintf(stderr,"\n%s\n",textPartOpenError);
            _Log("Error: Failed opening partition!");
        }
        
        _Log("    System Id Byte      = 0x%02x\n",PartitionImage->SystemId);
        _Log("    Total Sector Count  = 0x%08lx\n",PartitionImage->TotalSectorCount);
        _Log("    Non-Cluster Sectors = 0x%08lx\n",PartitionImage->NonClusterSectors);
        _Log("    Cluster Count       = 0x%08lx\n",PartitionImage->ClusterCount);
        _Log("    Sectors Per Cluster = 0x%02x\n",PartitionImage->SectorsPerCluster);

    }
    
    return(b);
}


BOOL
TransferFsStructsToOutput(
    IN HPARTITION PartitionHandle,
    IN UINT       FileHandle,
    IN ULONG      SectorCount
    )

/*++

Routine Description:

    This routine transfers each sector that is not part of a cluster
    to the output file. Such sectors are assumed to start at sector 0
    and run contiguously through a sector passed to this routine as
    a parameter.

Arguments:

    PartitionHandle - supplies handle to partition being imaged.

    FileHandle - supplies file handle for output. It is assumed that
        the file position is correct; no seeking is performed prior
        to data being written to the file.

    SectorCount - supplies the number of sectors to be transferred
        from the partition to the output file.

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed.

--*/

{
    BYTE Count;
    ULONG Sector;
    ULONG OriginalCount;
    unsigned Written;

    Sector = 0L;

    if(SectorCount) {
        printf(textTransferringFsStructs,0);
        printf("\r");
        OriginalCount = SectorCount;
    } else {
        OriginalCount = 0;
    }

    while(SectorCount) {

        Count = (SectorCount > 63L) ? (BYTE)63 : (BYTE)SectorCount;

        if(!ReadPartition(PartitionHandle,Sector,Count,IoBuffer)) {
            fprintf(stderr,"\n");
            fprintf(stderr,textReadFailedAtSector,Sector);
            fprintf(stderr,"\n");
            return(FALSE);
        }

        // update checksum
        CheckSum = CRC32Compute( IoBuffer, Count*512, CheckSum);
        BytesCRC += Count * 512;

        if(_dos_write(FileHandle,IoBuffer,Count*512,&Written) || (Written != (Count*512U))) {
            fprintf(stderr,"\n%s\n",textFileWriteError);
            return(FALSE);
        }

        Sector += Count;
        SectorCount -= Count;

        printf(textTransferringFsStructs,100 * (OriginalCount - SectorCount) / OriginalCount);
        printf("\r");
    }

    if(OriginalCount) {
        printf("\n");
    }

    return(TRUE);
}


BOOL
TransferUsedClustersToOutput(
    IN HANDLES         *Handles,
    IN PARTITION_IMAGE *PartitionImage
    )
{
    ULONG StartCluster,ClusterCount;
    ULONG StartSector,SectorCount;
    BYTE Count;
    UINT Written;
    BOOL b;
    ULONG SectorsSoFar;

    printf(textTransferringClusters,0);
    printf("\r");
    SectorsSoFar = 0;

    //
    // Reserve the last sector of the io buffer for the cluster map
    //
    if(!InitClusterMap((FPBYTE)IoBuffer+(62*512),Handles->BitmapFileHandle,PartitionImage->LastUsedCluster)) {
        return(FALSE);
    }

    b = TRUE;
    while(b && (b=GetNextClusterRun(&StartCluster,&ClusterCount)) && ClusterCount) {

        StartSector = PartitionImage->NonClusterSectors
                    + (StartCluster * PartitionImage->SectorsPerCluster);

        SectorCount = ClusterCount * PartitionImage->SectorsPerCluster;

        while(b && SectorCount) {

            Count = (SectorCount > 62L) ? (BYTE)62 : (BYTE)SectorCount;

            if(b = ReadPartition(Handles->SourcePartitionHandle,StartSector,Count,IoBuffer)) {
                if(!_dos_write(Handles->OutputFileHandle,IoBuffer,Count*512,&Written) && (Written == (Count*512U))) {
                    SectorCount -= Count;
                    StartSector += Count;
                    SectorsSoFar += Count;

                    printf(
                        textTransferringClusters,
                        (100*SectorsSoFar) / (PartitionImage->UsedClusterCount*PartitionImage->SectorsPerCluster)
                        );

                    printf("\r");
                    
                    // update checksum
                    CheckSum = CRC32Compute( IoBuffer, Count*512, CheckSum);
                    BytesCRC += Count * 512;

                } else {
                    fprintf(stderr,"\n%s\n",textFileWriteError);
                    b = FALSE;
                }
            } else {
                fprintf(stderr,"\n");
                fprintf(stderr,textReadFailedAtSector,StartSector);
                fprintf(stderr,"\n");
            }
        }
    }

    if(b) {
        printf("\n");
    }

    return(b);
}


BOOL
AppendClusterMapToOutput(
    IN HANDLES         *Handles,
    IN PARTITION_IMAGE *PartitionImage
    )

/*++

Routine Description:

    This routine appends the cluster bitmap file to the end of the
    partition image output file.

Arguments:

    Handles - supplies a pointer to the structure that contains the
        2 output file handles. This routine takes care of seeking, rewinding,
        etc, so no assumptions are made about the handles' state.

    PartitionImage - supplies information about the partition being imaged
        and partition image file being created.

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed.

--*/

{
    ULONG BitmapSizeBytes;
    UINT Read,Written;
    ULONG BytesLeft;
    UINT Size;

    printf(textCombiningFiles,0);
    printf("\r");

    //
    // Figure out how large the bitmap actually is in bytes,
    // rounding up to a sector boundary.
    //
    BitmapSizeBytes = ((PartitionImage->LastUsedCluster/(8*512)) + 1) * 512;

    //
    // Seek to the end of the output file and the start of the
    // cluster bitmap file, just in case.
    //
    DosSeek(Handles->OutputFileHandle,0,DOSSEEK_END);
    DosSeek(Handles->BitmapFileHandle,0,DOSSEEK_START);

    //
    // Transfer data.
    //
    BytesLeft = BitmapSizeBytes;

    while(BytesLeft) {

        Size = (BytesLeft > (63*512)) ? 63*512 : (UINT)BytesLeft;

        if(_dos_read(Handles->BitmapFileHandle,IoBuffer,Size,&Read) || (Read != Size)) {
            fprintf(stderr,"\n%s\n",textFileReadFailed);
            return(FALSE);
        }

        CheckSum = CRC32Compute( IoBuffer, Size, CheckSum);
        BytesCRC += Size;

        if(_dos_write(Handles->OutputFileHandle,IoBuffer,Size,&Written) || (Written != Size)) {
            fprintf(stderr,"\n%s\n",textFileWriteError);
            return(FALSE);
        }

        BytesLeft -= Size;

        printf(textCombiningFiles,100 * (BitmapSizeBytes - BytesLeft) / BitmapSizeBytes);
        printf("\r");
    }

    printf("\n");
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\imagpart\ntfs.c ===
#include "imagpart.h"

#include <malloc.h>
#include <stddef.h>

#include "ntfs.h"


//
// NTFS boot sector.
//
#pragma pack(1)
typedef struct _NTFS_BOOT_SECTOR {
    BYTE   Jump[3];
    BYTE   Oem[8];
    USHORT BytesPerSector;
    BYTE   SectorsPerCluster;
    USHORT ReservedSectors;
    BYTE   Fats;
    USHORT RootEntries;
    USHORT Sectors;
    BYTE   Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;
    BYTE   Unused0[4];
    ULONG  NumberSectors;
    ULONG  NumberSectorsh;
    ULONG  MftStartLcn;
    ULONG  MftStartLcnh;
    ULONG  Mft2StartLcn;
    ULONG  Mft2StartLcnh;
    CHAR   ClustersPerFileRecordSegment;
    BYTE   Unused1[3];
    CHAR   DefClusPerIndexAllocBuffer;
    BYTE   Unused2[3];
    ULONG  SerialNumberl;
    ULONG  SerialNumberh;
    ULONG  Checksum;
    BYTE   BootStrap[512-86];
    USHORT AA55Signature;
} NTFS_BOOT_SECTOR, _far *FPNTFS_BOOT_SECTOR;
#pragma pack()

//
// Globals, which make our life easier.
//
BYTE SectorsPerFrs;
unsigned SegmentsInMft;
FPFILE_RECORD_SEGMENT FrsScratchBuffer;
FPFILE_RECORD_SEGMENT MftLcnFrsScratchBuffer;

typedef struct _MFT_MAPPING {
    ULONG Start;
    BYTE Count;
} MFT_MAPPING, *PMFT_MAPPING, _far *FPMFT_MAPPING;

FPMFT_MAPPING MftMappings;

FPATTRIBUTE_LIST_ENTRY AttrListBuffer;
#define ATTR_LIST_BUFFER_SIZE   8192


BOOL
pNtfsSetUpMft(
    IN HPARTITION          PartitionHandle,
    IN PARTITION_IMAGE    *PartitionImage,
    IN FPNTFS_BOOT_SECTOR  BootSector
    );

BOOL
pNtfsTransferVolumeBitmap(
    IN HPARTITION       PartitionHandle,
    IN PARTITION_IMAGE *PartitionImage,
    IN UINT             OutputFileHandle
    );

BOOL
pNtfsProcessVolumeBitmap(
    IN OUT PARTITION_IMAGE *PartitionImage,
    IN     UINT             FileHandle
    );

BOOL
pNtfsMultiSectorFixup(
    IN OUT FPVOID Buffer
    );

FPATTRIBUTE_RECORD
pNtfsLocateAttributeRecord(
    IN FPFILE_RECORD_SEGMENT MftFrsBuffer,
    IN ULONG                 TypeCode
    );

BOOL
pNtfsReadWholeAttribute(
    IN  HPARTITION          PartitionHandle,
    IN  PARTITION_IMAGE    *PartitionImage,
    IN  FPATTRIBUTE_RECORD  Attribute,
    OUT FPVOID              Buffer,             OPTIONAL
    IN  UINT                OutputFileHandle    OPTIONAL
    );

BOOL
pNtfsComputeMftLcn(
    IN  HPARTITION  PartitionHandle,
    IN  ULONG       Vcn,
    OUT ULONG      *Lcn
    );

BOOL
pNtfsComputeLcn(
    IN  ULONG               Vcn,
    IN  FPATTRIBUTE_RECORD  Attribute,
    OUT ULONG              *Lcn,
    OUT UINT               *RunLength
    );

ULONG
pNtfsLcnFromMappingPair(
    IN FPBYTE p
    );

ULONG
pNtfsVcnFromMappingPair(
    IN FPBYTE p
    );

BOOL
pNtfsReadFrs(
    IN  HPARTITION       PartitionHandle,
    IN  PARTITION_IMAGE *PartitionImage,
    IN  ULONG            FileNumber,
    OUT FPVOID           Buffer
    );

BOOL
pNtfsReadMftSectors(
    IN  HPARTITION       PartitionHandle,
    IN  PARTITION_IMAGE *PartitionImage,
    IN  ULONG            Vbn,
    OUT FPBYTE           Buffer
    );

BOOL
pNtfsSearchFrsForAttrList(
    IN  HPARTITION             PartitionHandle,
    IN  PARTITION_IMAGE       *PartitionImage,
    IN  FPFILE_RECORD_SEGMENT  FrsBuffer,
    IN  ULONG                  TypeCode,
    OUT ULONG                 *Frn
    );




BOOL
NtfsIsNtfs(
    IN HPARTITION PartitionHandle
    )
{
    FPNTFS_BOOT_SECTOR BootSector;

    if(!ReadPartition(PartitionHandle,0,1,IoBuffer)) {
        return(FALSE);
    }

    BootSector = IoBuffer;

    //
    // Ensure that NTFS appears in the OEM field.
    //
    if(strncmp(BootSector->Oem,"NTFS    ",8)) {
        return(FALSE);
    }

    //
    // Check bytes per sector
    //
    if(BootSector->BytesPerSector != 512) {
        return(FALSE);
    }

    //
    // Other checks.
    //
    if((BootSector->SectorsPerCluster !=  1)
    && (BootSector->SectorsPerCluster !=  2)
    && (BootSector->SectorsPerCluster !=  4)
    && (BootSector->SectorsPerCluster !=  8)
    && (BootSector->SectorsPerCluster != 16)
    && (BootSector->SectorsPerCluster != 32)
    && (BootSector->SectorsPerCluster != 64)
    && (BootSector->SectorsPerCluster != 128)) {

        return(FALSE);
    }

    if(BootSector->ReservedSectors
    || BootSector->Fats
    || BootSector->RootEntries
    || BootSector->Sectors
    || BootSector->SectorsPerFat
    || BootSector->LargeSectors) {

        return(FALSE);
    }

    //
    // ClustersPerFileRecord can be less than zero if file records
    // are smaller than clusters. This number is the negative of a shift count.
    // If clusters are smaller than file records then this number is
    // still the clusters per file records.
    //

    if(BootSector->ClustersPerFileRecordSegment <= -9) {
        if(BootSector->ClustersPerFileRecordSegment < -31) {
            return(FALSE);
        }

    } else if((BootSector->ClustersPerFileRecordSegment !=  1)
           && (BootSector->ClustersPerFileRecordSegment !=  2)
           && (BootSector->ClustersPerFileRecordSegment !=  4)
           && (BootSector->ClustersPerFileRecordSegment !=  8)
           && (BootSector->ClustersPerFileRecordSegment != 16)
           && (BootSector->ClustersPerFileRecordSegment != 32)
           && (BootSector->ClustersPerFileRecordSegment != 64)) {

        return(FALSE);
    }

    //
    // ClustersPerIndexAllocationBuffer can be less than zero if index buffers
    // are smaller than clusters.  This number is the negative of a shift count.
    // If clusters are smaller than index buffers then this number is
    // still the clusters per index buffers.
    //

    if(BootSector->DefClusPerIndexAllocBuffer <= -9) {
        if(BootSector->DefClusPerIndexAllocBuffer < -31) {
            return(FALSE);
        }

    } else if((BootSector->DefClusPerIndexAllocBuffer !=  1)
           && (BootSector->DefClusPerIndexAllocBuffer !=  2)
           && (BootSector->DefClusPerIndexAllocBuffer !=  4)
           && (BootSector->DefClusPerIndexAllocBuffer !=  8)
           && (BootSector->DefClusPerIndexAllocBuffer != 16)
           && (BootSector->DefClusPerIndexAllocBuffer != 32)
           && (BootSector->DefClusPerIndexAllocBuffer != 64)) {

        return(FALSE);
    }

    return(TRUE);
}


BOOL
NtfsInitializeVolumeData(
    IN  HPARTITION  PartitionHandle,
    OUT ULONG      *TotalSectorCount,
    OUT ULONG      *NonClusterSectors,
    OUT ULONG      *ClusterCount,
    OUT BYTE       *SectorsPerCluster
    )
{
    FPNTFS_BOOT_SECTOR BootSector;

    if(!ReadPartition(PartitionHandle,0,1,IoBuffer)) {
        fprintf(stderr,"\n");
        fprintf(stderr,textReadFailedAtSector,0L);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    BootSector = IoBuffer;

    //
    // The mirror boot sector is not included in the sector count
    // in the bpb.
    //
    *TotalSectorCount = BootSector->NumberSectors + 1;

    *ClusterCount = BootSector->NumberSectors / BootSector->SectorsPerCluster;

    *NonClusterSectors = 0;

    *SectorsPerCluster = BootSector->SectorsPerCluster;

    return(TRUE);
}


BOOL
NtfsBuildClusterBitmap(
    IN     HPARTITION       PartitionHandle,
    IN     UINT             FileHandle,
    IN OUT PARTITION_IMAGE *PartitionImage
    )
{
    FPNTFS_BOOT_SECTOR BootSector;
    ULONG u;

    //
    // Load the boot sector, as we need the bpb fields.
    //
    BootSector = (FPNTFS_BOOT_SECTOR)((FPBYTE)IoBuffer+(62*512));
    if(!ReadPartition(PartitionHandle,0,1,BootSector)) {
        fprintf(stderr,"\n");
        fprintf(stderr,textReadFailedAtSector,0L);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    //
    // Validate that we think we can deal with this drive. We impose
    // some limitations because of 16 bitness, memory constraints, etc.
    //
    // We disallow:
    //
    //  Volumes with more than 2^32 sectors
    //  Volumes with a cluster size > 16K
    //  Volumes with > 16K per FRS
    //
    if(BootSector->NumberSectorsh) {
        fprintf(stderr,"\n");
        fprintf(stderr,textNtfsUnsupportedConfig,0);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    if(BootSector->SectorsPerCluster > 32) {
        fprintf(stderr,"\n");
        fprintf(stderr,textNtfsUnsupportedConfig,1);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    if(BootSector->ClustersPerFileRecordSegment < 0) {
        u = (1L << (0 - BootSector->ClustersPerFileRecordSegment)) / 512;
    } else {
        u = BootSector->ClustersPerFileRecordSegment * BootSector->SectorsPerCluster;
    }
    if(u > 32) {
        fprintf(stderr,"\n");
        fprintf(stderr,textNtfsUnsupportedConfig,2);
        fprintf(stderr,"\n");
        return(FALSE);
    }
    SectorsPerFrs = (BYTE)u;

    //
    // Initialize mapping information for the MFT
    //
    if(!pNtfsSetUpMft(PartitionHandle,PartitionImage,BootSector)) {
        return(FALSE);
    }

    //
    // Transfer the volume bitmap to the output file.
    //
    if(!pNtfsTransferVolumeBitmap(PartitionHandle,PartitionImage,FileHandle)) {
        return(FALSE);
    }

    //
    // Analyze and fix up the bitmap.
    //
    if(!pNtfsProcessVolumeBitmap(PartitionImage,FileHandle)) {
        return(FALSE);
    }

    return(TRUE);
}


BOOL
pNtfsSetUpMft(
    IN HPARTITION          PartitionHandle,
    IN PARTITION_IMAGE    *PartitionImage,
    IN FPNTFS_BOOT_SECTOR  BootSector
    )
{
    ULONG Vbn,Vcn,Lcn,Lbn;
    BYTE SectorOffset;
    BYTE Remaining;
    BYTE Count;
    BYTE xCount;
    ULONG xStart;
    FPATTRIBUTE_RECORD Attribute;
    FPATTRIBUTE_LIST_ENTRY AttrListEntry;
    unsigned ArraySize;
    BOOL b;

    printf(textInitNtfsDataStruct);

    //
    // Allocate a scratch buffer to hold a buffered FRS
    //
    FrsScratchBuffer = malloc(SectorsPerFrs * 512);
    if(!FrsScratchBuffer) {
        fprintf(stderr,"\n%s\n",textOOM);
        return(FALSE);
    }

    //
    // Allocate a scratch buffer for lookups
    //
    MftLcnFrsScratchBuffer = malloc(SectorsPerFrs * 512);
    if(!MftLcnFrsScratchBuffer) {
        fprintf(stderr,"\n%s\n",textOOM);
        return(FALSE);
    }

    //
    // Allocate an initial buffer to store mappings.
    //
    MftMappings = malloc(sizeof(MFT_MAPPING));
    if(!MftMappings) {
        fprintf(stderr,"\n%s\n",textOOM);
        return(FALSE);
    }
    ArraySize = 1;

    //
    // Allocate an attribute list buffer.
    //
    AttrListBuffer = malloc(ATTR_LIST_BUFFER_SIZE);
    if(!AttrListBuffer) {
        fprintf(stderr,"\n%s\n",textOOM);
        return(FALSE);
    }

    //
    // Read FRS 0 into the first MFT FRS buffer, being sure
    // to resolve the Update Sequence Array. Remember the physical
    // location in the Lbn array.
    //
    MftMappings[0].Start = BootSector->MftStartLcn * BootSector->SectorsPerCluster;
    MftMappings[0].Count = SectorsPerFrs;
    SegmentsInMft = 1;

    if(!ReadPartition(PartitionHandle,MftMappings[0].Start,MftMappings[0].Count,(FPBYTE)IoBuffer+(61*512))) {
        fprintf(stderr,"\n");
        fprintf(stderr,textReadFailedAtSector,MftMappings[0].Start);
        fprintf(stderr,"\n");
        return(FALSE);
    }
    memmove(FrsScratchBuffer,(FPBYTE)IoBuffer+(61*512),MftMappings[0].Count*512);
    printf(".");

    if(!pNtfsMultiSectorFixup(FrsScratchBuffer)) {
        return(FALSE);
    }

    printf(".");

    //
    // Determine whether the MFT has an Attribute List attribute,
    // and if so, read it.
    //
    if(Attribute = pNtfsLocateAttributeRecord(FrsScratchBuffer,$ATTRIBUTE_LIST)) {

        b = pNtfsReadWholeAttribute(
                PartitionHandle,
                PartitionImage,
                Attribute,
                AttrListBuffer,
                0
                );

        if(!b) {
            return(FALSE);
        }

        printf(".");
        AttrListEntry = AttrListBuffer;

        //
        // Traverse the attribute list looking for the first
        // entry for the $DATA type. We know it must have at least one.
        // Note that we then immediately skip this one because we already
        // handled the 0th FRS.
        //
        while(AttrListEntry->TypeCode != $DATA) {
            AttrListEntry = (FPATTRIBUTE_LIST_ENTRY)((FPBYTE)AttrListEntry + AttrListEntry->Length);
        }

        do {
            AttrListEntry = (FPATTRIBUTE_LIST_ENTRY)((FPBYTE)AttrListEntry + AttrListEntry->Length);
            if(AttrListEntry->TypeCode == $DATA) {

                //
                // Find the start sector and sector count for the runs for this
                // file record (max 2 runs). The mapping for this must be
                // in a file record already visited. Find the Vcn and cluster
                // offset for this FRS. Use LookupMftLcn to find the Lcn.
                //
                // Convert from Frs to sectors, then to Vcn.
                //
                Vbn = AttrListEntry->SegmentReference.LowPart * SectorsPerFrs;
                Vcn = Vbn / BootSector->SectorsPerCluster;
                SectorOffset = (BYTE)(Vbn % BootSector->SectorsPerCluster);

                if(!pNtfsComputeMftLcn(PartitionHandle,Vcn,&Lcn)) {
                    return(FALSE);
                }
                printf(".");

                //
                // Sectors remaining in this frs is initially the whole frs
                //
                Remaining = SectorsPerFrs;

                //
                // Change the LCN back into an LBN and add the remainder
                // back in to get the sector we want to read. Then store
                // this in the next Lcn array slot.
                //
                Lbn = (Lcn * BootSector->SectorsPerCluster) + SectorOffset;

                xStart = Lbn;
                xCount = BootSector->SectorsPerCluster - SectorOffset;
                if(xCount > Remaining) {
                    xCount = Remaining;
                }

                Count = xCount;
                while(Remaining -= Count) {

                    Vbn += Count;
                    Vcn = Vbn / BootSector->SectorsPerCluster;

                    if(!pNtfsComputeMftLcn(PartitionHandle,Vcn,&Lcn)) {
                        return(FALSE);
                    }

                    Lbn = Lcn * BootSector->SectorsPerCluster;

                    Count = BootSector->SectorsPerCluster;
                    if(Count > Remaining) {
                        Count = Remaining;
                    }

                    //
                    // Check contiguity
                    //
                    if((xStart + xCount) == Lbn) {

                        xCount += Count;

                    } else {

                        MftMappings = realloc(MftMappings,(ArraySize+1)*sizeof(MFT_MAPPING));
                        if(!MftMappings) {
                            fprintf(stderr,"\n%s\n",textOOM);
                            return(FALSE);
                        }
                        MftMappings[ArraySize].Start = xStart;
                        MftMappings[ArraySize].Count = xCount;
                        ArraySize++;

                        xStart = Lbn;
                        xCount = Count;
                    }

                    printf(".");
                }

                MftMappings = realloc(MftMappings,(ArraySize+1)*sizeof(MFT_MAPPING));
                if(!MftMappings) {
                    fprintf(stderr,"\n%s\n",textOOM);
                    return(FALSE